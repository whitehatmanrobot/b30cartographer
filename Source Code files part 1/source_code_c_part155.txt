unsigned unused:27;
		unsigned lookup:5;
	} mode_0;
	struct
	{
		unsigned unused:31;
		unsigned lookup:1;
	} mode_1;
	struct
	{
		unsigned unused:28;
		unsigned lookup:4;
	} mode_2;
	struct
	{
		unsigned unused:28;
		unsigned lookup:4;
	} mode_3;
#else
	struct
	{
		unsigned pe:1;
		unsigned func:2;
		unsigned bp:1;
		unsigned sr:1;
		unsigned unused:27;
	} state;
	struct
	{
		unsigned lookup:5;
		unsigned unused:27;
	} mode_0;
	struct
	{
		unsigned lookup:1;
		unsigned unused:31;
	} mode_1;
	struct
	{
		unsigned lookup:4;
		unsigned unused:28;
	} mode_2;
	struct
	{
		unsigned lookup:4;
		unsigned unused:28;
	} mode_3;
#endif
} MAGIC;

typedef struct
{
	ULONG	latches;
	UTINY	*VGA_rplane;
	UTINY	*VGA_wplane;
	UTINY	*scratch;
	ULONG	sr_masked_val;
	ULONG	sr_nmask;
	ULONG	data_and_mask;
	ULONG	data_xor_mask;
	ULONG	latch_xor_mask;
	ULONG	bit_prot_mask;
	ULONG	plane_enable;
	ULONG	plane_enable_mask;
	ULONG	*sr_lookup;
	VOID	(*fwd_str_read_addr)();
	VOID	(*bwd_str_read_addr)();
	ULONG	dirty_flag;
	LONG	dirty_low;
	LONG	dirty_high;
	IU8	*video_copy;
	VOID	(*mark_byte)();
	VOID	(*mark_word)();
	VOID	(*mark_string)();
	ULONG	read_shift_count;
	ULONG	read_mapped_plane;
	ULONG	colour_comp;
	ULONG	dont_care;
	ULONG	v7_vid_copy_off;
	ULONG	copy_func_pbp;
	UTINY	*route_reg1;
	UTINY	*route_reg2;
	UTINY	*screen_ptr;
	ULONG	rotate;
#if defined(NEC_98)         
        unsigned char   *gvram_p00_copy;
        unsigned char   *gvram_p10_copy;
        unsigned char   *gvram_p20_copy;
        unsigned char   *gvram_p30_copy;
        unsigned char   *gvram_p01_copy;
        unsigned char   *gvram_p11_copy;
        unsigned char   *gvram_p21_copy;
        unsigned char   *gvram_p31_copy;
        long            gvram_dirty_flag0;
        long            gvram_dirty_flag1;
        unsigned char   read_bank;
        unsigned char   select_bank;
        unsigned char   *gvram_p00_ptr;
        unsigned char   *gvram_p10_ptr;
        unsigned char   *gvram_p20_ptr;
        unsigned char   *gvram_p30_ptr;
        unsigned char   *gvram_p01_ptr;
        unsigned char   *gvram_p11_ptr;
        unsigned char   *gvram_p21_ptr;
        unsigned char   *gvram_p31_ptr;
} NEC98_GLOBALS, VGA_GLOBALS;
#else  // !NEC_98
} VGA_GLOBALS;
#endif // !NEC_98

#if defined(NEC_98)         
extern struct NEC98_CPU_GLOBALS
#else  // !NEC_98
extern struct EGA_CPU_GLOBALS
#endif // !NEC_98
{
#if defined(NEC_98)         
        NEC98_GLOBALS    *globals;
#else  // !NEC_98
#ifndef	HOST_VGA_GLOBALS
	VGA_GLOBALS	*globals;
#endif
#endif // !NEC_98
	ULONG		saved_state;		/* Last value of EGA_CPU.ega_state.state */
	ULONG		saved_mode_chain;		/* Last value of mode/chain combined */
#if defined(NEC_98)         
        MAGIC           NEC98_state;
#else  // !NEC_98
	MAGIC		ega_state;
#endif // !NEC_98
	ULONG		fun_or_protection;   /* true means write function is 1-3 and/or there
						is bit protection, so latches must be used */
	ULONG		calc_data_xor;	/* Used to recalculate data_xor_mask when the
									bit prot reg changes */
	ULONG		calc_latch_xor;	/* Used to recalculate latch_xor_mask when the
									bit prot reg changes */
	ULONG		set_reset;
	ULONG		sr_enable;
	ULONG		sr_value;
	ULONG		ram_enabled;

	UTINY		write_mode;
	UTINY		chain;
	UTINY		doubleword;
	UTINY		*plane_offset;
	UTINY		*read_mapped_plane_ch2;
#ifdef V7VGA
	UTINY		seq_chain4;
	UTINY		seq_chain;
#endif
#if defined(NEC_98)
} NEC98_CPU;
#else  // !NEC_98
} EGA_CPU;
#endif // !NEC_98

#if defined(NEC_98)
#define NEC98GLOBS       NEC98_CPU.globals

#define	getVideolatches()		NEC98GLOBS->latches
#define	setVideolatches(value)		NEC98GLOBS->latches = value
#define	getVideorplane()		NEC98GLOBS->VGA_rplane
#define	setVideorplane(value)		NEC98GLOBS->VGA_rplane = value
#define	getVideowplane()		NEC98GLOBS->VGA_wplane
#define	setVideowplane(value)		NEC98GLOBS->VGA_wplane = value
#define	getVideoscratch()		NEC98GLOBS->scratch
#define	setVideoscratch(value)		NEC98GLOBS->scratch = value
#define	getVideosr_masked_val()		NEC98GLOBS->sr_masked_val
#define	setVideosr_masked_val(value)	NEC98GLOBS->sr_masked_val = value
#define	getVideosr_nmask()		NEC98GLOBS->sr_nmask
#define	setVideosr_nmask(value)		NEC98GLOBS->sr_nmask = value
#define	getVideodata_and_mask()		NEC98GLOBS->data_and_mask
#define	setVideodata_and_mask(value)	NEC98GLOBS->data_and_mask = value
#define	getVideodata_xor_mask()		NEC98GLOBS->data_xor_mask
#define	setVideodata_xor_mask(value)	NEC98GLOBS->data_xor_mask = value
#define	getVideolatch_xor_mask()	NEC98GLOBS->latch_xor_mask
#define	setVideolatch_xor_mask(value)	NEC98GLOBS->latch_xor_mask = value
#define	getVideobit_prot_mask()		NEC98GLOBS->bit_prot_mask
#define	setVideobit_prot_mask(value)	NEC98GLOBS->bit_prot_mask = value
#define	getVideoplane_enable()		NEC98GLOBS->plane_enable
#define	setVideoplane_enable(value)	NEC98GLOBS->plane_enable = value
#define	getVideoplane_enableMask()	NEC98GLOBS->plane_enable_mask
#define	setVideoplane_enable_mask(value)	NEC98GLOBS->plane_enable_mask = value
#define	getVideosr_lookup()		NEC98GLOBS->sr_lookup
#define	setVideosr_lookup(value)	NEC98GLOBS->sr_lookup = value
#define	getVideofwd_str_read_addr()	NEC98GLOBS->fwd_str_read_addr
#define	setVideofwd_str_read_addr(value)	NEC98GLOBS->fwd_str_read_addr = value
#define	getVideobwd_str_read_addr()	NEC98GLOBS->bwd_str_read_addr
#define	setVideobwd_str_read_addr(value)	NEC98GLOBS->bwd_str_read_addr = value
#define	getVideodirty_total()		NEC98GLOBS->dirty_flag
#define	setVideodirty_total(value)	NEC98GLOBS->dirty_flag = value
#define	getVideodirty_low()		NEC98GLOBS->dirty_low
#define	setVideodirty_low(value)	NEC98GLOBS->dirty_low = value
#define	getVideodirty_high()		NEC98GLOBS->dirty_high
#define	setVideodirty_high(value)	NEC98GLOBS->dirty_high = value
#define	getVideovideo_copy()		NEC98GLOBS->video_copy
#define	setVideovideo_copy(value)	NEC98GLOBS->video_copy = value
#define	getVideomark_byte()		NEC98GLOBS->mark_byte
#define	setVideomark_byte(value)	NEC98GLOBS->mark_byte = value
#define	getVideomark_word()		NEC98GLOBS->mark_word
#define	setVideomark_word(value)	NEC98GLOBS->mark_word = value
#define	getVideomark_string()		NEC98GLOBS->mark_string
#define	setVideomark_string(value)	NEC98GLOBS->mark_string = value
#define	getVideoread_shift_count()	NEC98GLOBS->read_shift_count
#define	setVideoread_shift_count(value)	NEC98GLOBS->read_shift_count = value
#define	getVideoread_mapped_plane()	NEC98GLOBS->read_mapped_plane
#define	setVideoread_mapped_plane(value)	NEC98GLOBS->read_mapped_plane = value
#define	getVideocolour_comp()		NEC98GLOBS->colour_comp
#define	setVideocolour_comp(value)	NEC98GLOBS->colour_comp = value
#define	getVideodont_care()		NEC98GLOBS->dont_care
#define	setVideodont_care(value)	NEC98GLOBS->dont_care = value
#define	getVideov7_bank_vid_copy_off()	NEC98GLOBS->v7_vid_copy_off
#define	setVideov7_bank_vid_copy_off(value)	NEC98GLOBS->v7_vid_copy_off = value
#define	getVideoscreen_ptr()		NEC98GLOBS->screen_ptr
#define	setVideoscreen_ptr(value)	NEC98GLOBS->screen_ptr = value
#define	getVideorotate()		NEC98GLOBS->rotate
#define	setVideorotate(value)		NEC98GLOBS->rotate = value
#define	getVideocalc_data_xor()		calc_data_xor
#define	setVideocalc_data_xor(value)	calc_data_xor = value
#define	getVideocalc_latch_xor()	calc_latch_xor
#define	setVideocalc_latch_xor(value)	calc_latch_xor = value
#define	getVideoread_byte_addr()		
#define	setVideoread_byte_addr(value)	
#define	getVideov7_fg_latches()		fg_latches
#define	setVideov7_fg_latches(value)	fg_latches = value
#define	getVideoGC_regs()		
#define	setVideoGC_regs(value)		
#define	getVideolast_GC_index()		
#define	setVideolast_GC_index(value)	
#define	getVideodither()		
#define	setVideodither(value)	
#define	getVideowrmode()	
#define	setVideowrmode(value)	
#define	getVideochain()	
#define	setVideochain(value)	
#define	getVideowrstate()	
#define	setVideowrstate(value)	

#define write_state NEC98_CPU.NEC98_state.state
#else  // !NEC_98
#ifndef CPU_40_STYLE	/* Vglobs done via access fns */
#ifdef	HOST_VGA_GLOBALS
/* Some hosts, such as the Mac, declare their own VGA_GLOBALS structure */
IMPORT	VGA_GLOBALS		HostVGAGlobals;
#define	VGLOBS			(&HostVGAGlobals)		/*Always used as a pointer*/
#else
#define VGLOBS			EGA_CPU.globals
#endif

#define	getVideolatches()		VGLOBS->latches
#define	setVideolatches(value)		VGLOBS->latches = value
#define	getVideorplane()		VGLOBS->VGA_rplane
#define	setVideorplane(value)		VGLOBS->VGA_rplane = value
#define	getVideowplane()		VGLOBS->VGA_wplane
#define	setVideowplane(value)		VGLOBS->VGA_wplane = value
#define	getVideoscratch()		VGLOBS->scratch
#define	setVideoscratch(value)		VGLOBS->scratch = value
#define	getVideosr_masked_val()		VGLOBS->sr_masked_val
#define	setVideosr_masked_val(value)	VGLOBS->sr_masked_val = value
#define	getVideosr_nmask()		VGLOBS->sr_nmask
#define	setVideosr_nmask(value)		VGLOBS->sr_nmask = value
#define	getVideodata_and_mask()		VGLOBS->data_and_mask
#define	setVideodata_and_mask(value)	VGLOBS->data_and_mask = value
#define	getVideodata_xor_mask()		VGLOBS->data_xor_mask
#define	setVideodata_xor_mask(value)	VGLOBS->data_xor_mask = value
#define	getVideolatch_xor_mask()	VGLOBS->latch_xor_mask
#define	setVideolatch_xor_mask(value)	VGLOBS->latch_xor_mask = value
#define	getVideobit_prot_mask()		VGLOBS->bit_prot_mask
#define	setVideobit_prot_mask(value)	VGLOBS->bit_prot_mask = value
#define	getVideoplane_enable()		VGLOBS->plane_enable
#define	setVideoplane_enable(value)	VGLOBS->plane_enable = value
#define	getVideoplane_enableMask()	VGLOBS->plane_enable_mask
#define	setVideoplane_enable_mask(value)	VGLOBS->plane_enable_mask = value
#define	getVideosr_lookup()		VGLOBS->sr_lookup
#define	setVideosr_lookup(value)	VGLOBS->sr_lookup = value
#define	getVideofwd_str_read_addr()	VGLOBS->fwd_str_read_addr
#define	setVideofwd_str_read_addr(value)	VGLOBS->fwd_str_read_addr = value
#define	getVideobwd_str_read_addr()	VGLOBS->bwd_str_read_addr
#define	setVideobwd_str_read_addr(value)	VGLOBS->bwd_str_read_addr = value
#define	getVideodirty_total()		VGLOBS->dirty_flag
#define	setVideodirty_total(value)	VGLOBS->dirty_flag = value
#define	getVideodirty_low()		VGLOBS->dirty_low
#define	setVideodirty_low(value)	VGLOBS->dirty_low = value
#define	getVideodirty_high()		VGLOBS->dirty_high
#define	setVideodirty_high(value)	VGLOBS->dirty_high = value
#define	getVideovideo_copy()		VGLOBS->video_copy
#define	setVideovideo_copy(value)	VGLOBS->video_copy = value
#define	getVideomark_byte()		VGLOBS->mark_byte
#define	setVideomark_byte(value)	VGLOBS->mark_byte = value
#define	getVideomark_word()		VGLOBS->mark_word
#define	setVideomark_word(value)	VGLOBS->mark_word = value
#define	getVideomark_string()		VGLOBS->mark_string
#define	setVideomark_string(value)	VGLOBS->mark_string = value
#define	getVideoread_shift_count()	VGLOBS->read_shift_count
#define	setVideoread_shift_count(value)	VGLOBS->read_shift_count = value
#define	getVideoread_mapped_plane()	VGLOBS->read_mapped_plane
#define	setVideoread_mapped_plane(value)	VGLOBS->read_mapped_plane = value
#define	getVideocolour_comp()		VGLOBS->colour_comp
#define	setVideocolour_comp(value)	VGLOBS->colour_comp = value
#define	getVideodont_care()		VGLOBS->dont_care
#define	setVideodont_care(value)	VGLOBS->dont_care = value
#define	getVideov7_bank_vid_copy_off()	VGLOBS->v7_vid_copy_off
#define	setVideov7_bank_vid_copy_off(value)	VGLOBS->v7_vid_copy_off = value
#define	getVideoscreen_ptr()		VGLOBS->screen_ptr
#define	setVideoscreen_ptr(value)	VGLOBS->screen_ptr = value
#define	getVideorotate()		VGLOBS->rotate
#define	setVideorotate(value)		VGLOBS->rotate = value
#define	getVideocalc_data_xor()		calc_data_xor
#define	setVideocalc_data_xor(value)	calc_data_xor = value
#define	getVideocalc_latch_xor()	calc_latch_xor
#define	setVideocalc_latch_xor(value)	calc_latch_xor = value
#define	getVideoread_byte_addr()		
#define	setVideoread_byte_addr(value)	
#define	getVideov7_fg_latches()		fg_latches
#define	setVideov7_fg_latches(value)	fg_latches = value
#define	getVideoGC_regs()		
#define	setVideoGC_regs(value)		
#define	getVideolast_GC_index()		
#define	setVideolast_GC_index(value)	
#define	getVideodither()		
#define	setVideodither(value)	
#define	getVideowrmode()	
#define	setVideowrmode(value)	
#define	getVideochain()	
#define	setVideochain(value)	
#define	getVideowrstate()	
#define	setVideowrstate(value)	

#else	/* CPU_40_STYLE */

extern void setVideorplane IPT1(IU8 *, value);
extern IU8 * getVideorplane IPT0();
extern void setVideowplane IPT1(IU8 *, value);
extern IU8 * getVideowplane IPT0();
extern void setVideoscratch IPT1(IU8 *, value);
extern IU8 * getVideoscratch IPT0();
extern void setVideosr_masked_val IPT1(IU32, value);
extern IU32 getVideosr_masked_val IPT0();
extern void setVideosr_nmask IPT1(IU32, value);
extern IU32 getVideosr_nmask IPT0();
extern void setVideodata_and_mask IPT1(IU32, value);
extern IU32 getVideodata_and_mask IPT0();
extern void setVideodata_xor_mask IPT1(IU32, value);
extern IU32 getVideodata_xor_mask IPT0();
extern void setVideolatch_xor_mask IPT1(IU32, value);
extern IU32 getVideolatch_xor_mask IPT0();
extern void setVideobit_prot_mask IPT1(IU32, value);
extern IU32 getVideobit_prot_mask IPT0();
extern void setVideoplane_enable IPT1(IU32, value);
extern IU32 getVideoplane_enable IPT0();
extern void setVideoplane_enable_mask IPT1(IU32, value);
extern IU32 getVideoplane_enable_mask IPT0();
extern void setVideosr_lookup IPT1(IUH *, value);
extern IUH * getVideosr_lookup IPT0();
extern void setVideofwd_str_read_addr IPT1(IUH *, value);
extern IUH * getVideofwd_str_read_addr IPT0();
extern void setVideobwd_str_read_addr IPT1(IUH *, value);
extern IUH * getVideobwd_str_read_addr IPT0();
extern void setVideodirty_total IPT1(IU32, value);
extern IU32 getVideodirty_total IPT0();
extern void setVideodirty_low IPT1(IS32, value);
extern IS32 getVideodirty_low IPT0();
extern void setVideodirty_high IPT1(IS32, value);
extern IS32 getVideodirty_high IPT0();
extern void setVideovideo_copy IPT1(IU8 *, value);
extern IU8 * getVideovideo_copy IPT0();
extern void setVideomark_byte IPT1(IUH *, value);
extern IUH * getVideomark_byte IPT0();
extern void setVideomark_word IPT1(IUH *, value);
extern IUH * getVideomark_word IPT0();
extern void setVideomark_string IPT1(IUH *, value);
extern IUH * getVideomark_string IPT0();
extern void setVideoread_shift_count IPT1(IU32, value);
extern IU32 getVideoread_shift_count IPT0();
extern void setVideoread_mapped_plane IPT1(IU32, value);
extern IU32 getVideoread_mapped_plane IPT0();
extern void setVideocolour_comp IPT1(IU32, value);
extern IU32 getVideocolour_comp IPT0();
extern void setVideodont_care IPT1(IU32, value);
extern IU32 getVideodont_care IPT0();
extern void setVideov7_bank_vid_copy_off IPT1(IU32, value);
extern IU32 getVideov7_bank_vid_copy_off IPT0();
extern void setVideoscreen_ptr IPT1(IU8 *, value);
extern IU8 * getVideoscreen_ptr IPT0();
extern void setVideorotate IPT1(IU32, value);
extern IU32 getVideorotate IPT0();
extern void setVideocalc_data_xor IPT1(IU32, value);
extern IU32 getVideocalc_data_xor IPT0();
extern void setVideocalc_latch_xor IPT1(IU32, value);
extern IU32 getVideocalc_latch_xor IPT0();
extern void setVideoread_byte_addr IPT1(IUH *, value);
extern IUH * getVideoread_byte_addr IPT0();
extern void setVideov7_fg_latches IPT1(IU32, value);
extern IU32 getVideov7_fg_latches IPT0();
extern void setVideoGC_regs IPT1(IUH **, value);
extern IUH ** getVideoGC_regs IPT0();
extern void setVideolast_GC_index IPT1(IU8, value);
extern IU8 getVideolast_GC_index IPT0();
extern void setVideodither IPT1(IU8, value);
extern IU8 getVideodither IPT0();
extern void setVideowrmode IPT1(IU8, value);
extern IU8 getVideowrmode IPT0();
extern void setVideochain IPT1(IU8, value);
extern IU8 getVideochain IPT0();
extern void setVideowrstate IPT1(IU8, value);
extern IU8 getVideowrstate IPT0();

#include "evidgen.h"	/* generated by MkCpuInt */

#ifdef C_VID
extern struct VideoVector C_Video;	/* in (generated) vglfunc.c */

#undef  getVideolatches
#define getVideolatches()	((*(C_Video.GetVideolatches))())
#undef	setVideolatches
#define	setVideolatches(value)	( (*(C_Video.SetVideolatches))(value))
#undef	SetWritePointers
#define SetWritePointers	setWritePointers
#undef	SetReadPointers
#define SetReadPointers	setReadPointers
#undef	SetMarkPointers
#define SetMarkPointers	setMarkPointers
#endif	/* C_VID */
#endif	/* CPU_40_STYLE */

#define write_state EGA_CPU.ega_state.state
#endif // !NEC_98

#define UNCHAINED	0
#define CHAIN2		1
#define CHAIN4		2

IMPORT ULONG sr_lookup[16];

#define N_WRITE_TYPES 24

#if defined(NEC_98)         
#define get_latch(n) (* ((UTINY *) (&NEC98GLOBS->latches) + n))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 (* (USHORT *) (&NEC98GLOBS->latches))
#define get_latch23 (* (USHORT *) (&NEC98GLOBS->latches + 2))

#define put_latch(n, value) * ((UTINY *) (&NEC98GLOBS->latches) + n) = (value)

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)
#else  // !NEC_98
#ifdef CPU_40_STYLE
extern IU32 latchval;	/* used for following latch macros */
#define get_latch(n) \
	(latchval = getVideolatches(),\
	(* ((UTINY *) (&latchval) + n)))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 \
	(latchval = getVideolatches(),  \
	(* (USHORT *) (&latchval)))

#define get_latch23 \
	(latchval = getVideolatches(),  \
	(* (USHORT *) (&latchval + 2)))

#define put_latch(n, value) \
	(* ((UTINY *) (&latchval) + n) = (value), \
	setVideolatches(latchval))

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)

#else	/* CPU_40_STYLE */

#define get_latch(n) (* ((UTINY *) (&VGLOBS->latches) + n))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 (* (USHORT *) (&VGLOBS->latches))
#define get_latch23 (* (USHORT *) (&VGLOBS->latches + 2))

#define put_latch(n, value) * ((UTINY *) (&VGLOBS->latches) + n) = (value)

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)

#endif	/* CPU_40_STYLE */
#endif // !NEC_98

/*
 * macro to do the logical operations on cpu data and the latch values
 */

#define do_logicals(val,latch)  (((latch) & ((val & getVideodata_and_mask()) \
		^ getVideodata_xor_mask())) | (val & ((latch) ^ getVideolatch_xor_mask())))


/* Routines */

extern void ega_mode0_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode0_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode0_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode0_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode0_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);

extern void ega_mode1_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode1_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode1_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_w_move IPT2(byte *,arg1, byte *,arg2);

extern void ega_mode2_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode2_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode2_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_w_move IPT2(byte *,arg1, byte *,arg2);

/* 1 plane masked write */
extern void ega_mode0_copy1_mask_b_write0 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write1 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write2 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write3 IPT1(byte *,arg1);

#ifdef VGG
extern boolean vga_mode0_gen_chn4_b_write IPT0();
extern boolean vga_mode0_gen_chn4_w_write IPT0();
extern boolean vga_mode0_gen_chn4_b_fill IPT0();
extern boolean vga_mode0_gen_chn4_w_fill IPT0();
extern boolean vga_mode0_gen_chn4_b_move IPT0();
/* wr 1 */
extern boolean vga_mode1_gen_chn4_b_write IPT0();
extern boolean vga_mode1_gen_chn4_w_write IPT0();
extern boolean vga_mode1_gen_chn4_b_fill IPT0();
extern boolean vga_mode1_gen_chn4_w_fill IPT0();
extern boolean vga_mode1_gen_chn4_b_move IPT0();
extern boolean vga_mode1_gen_chn4_w_move IPT0();
/* wr 2 */
extern boolean vga_mode2_gen_chn4_b_write IPT0();
extern boolean vga_mode2_gen_chn4_w_write IPT0();
extern boolean vga_mode2_gen_chn4_b_fill IPT0();
extern boolean vga_mode2_gen_chn4_w_fill IPT0();
extern boolean vga_mode2_gen_chn4_b_move IPT0();
extern boolean vga_mode2_gen_chn4_w_move IPT0();
/* wr 3 */
extern boolean vga_mode3_gen_chn4_b_write IPT0();
extern boolean vga_mode3_gen_chn4_w_write IPT0();
extern boolean vga_mode3_gen_chn4_b_fill IPT0();
extern boolean vga_mode3_gen_chn4_w_fill IPT0();
extern boolean vga_mode3_gen_chn4_b_move IPT0();
extern boolean vga_mode3_gen_chn4_w_move IPT0();

extern boolean vga_mode3_gen_chn_b_write IPT0();
extern boolean vga_mode3_gen_chn_w_write IPT0();
extern boolean vga_mode3_gen_chn_b_fill IPT0();
extern boolean vga_mode3_gen_chn_w_fill IPT0();
extern boolean vga_mode3_gen_chn_b_move IPT0();
extern boolean vga_mode3_gen_chn_w_move IPT0();

extern boolean vga_mode3_gen_b_write IPT0();
extern boolean vga_mode3_gen_w_write IPT0();
extern boolean vga_mode3_gen_b_fill IPT0();
extern boolean vga_mode3_gen_w_fill IPT0();
extern boolean vga_mode3_gen_b_move IPT0();
extern boolean vga_mode3_gen_w_move IPT0();
#endif /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egamode.h ===
/*
 * File: egamode.h
 *
 * SccsID = @(#)egamode.h	1.3 08/10/92 Copyright Insignia Solutions Ltd.
 *
 */


extern	boolean	(*choose_display_mode)();
extern	boolean	choose_ega_display_mode();
#ifdef VGG
#if defined(NEC_98)         
extern  boolean choose_NEC98_display_mode();
extern  boolean choose_NEC98_graph_mode();
extern  BOOL    video_emu_mode ;
#else  // !NEC_98
extern	boolean	choose_vga_display_mode();
#endif // !NEC_98
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egaports.h ===
/*
 * SccsID = @(#)egaports.h	1.17 10/21/92 Copyright Insignia Solutions Ltd.
 */

#ifdef	EGG
	/* defined in ega_write.c : */
	extern void ega_write_init IPT0();
	extern void ega_write_term IPT0();
	extern void ega_write_routines_update IPT1(CHANGE_TYPE,c);

#ifdef V7VGA
/* The video seven VGA board has extra memory, but the CRTC does not cross
 * bank boundaries unless the counter bank enable bit is set. 
 * This means that the size as far as wrapping and displaying is concerned is 
 * only one bank unless that bit is set.
 */
#define	EGA_PLANE_SIZE	0x20000
#define EGA_PLANE_DISP_SIZE  \
	(extensions_controller.ram_bank_select.as_bfld.counter_bank_enable? \
			EGA_PLANE_SIZE:0x10000)
#else
#define	EGA_PLANE_SIZE	0x10000
#define EGA_PLANE_DISP_SIZE EGA_PLANE_SIZE
#endif /* V7VGA */

	extern void ega_init IPT0();
	extern void ega_term IPT0();
	extern void ega_gc_outb_index IPT2(io_addr,ia,half_word,hw);
#ifdef	HUNTER
	extern int ega_get_line_compare IPT0();
	extern int ega_get_max_scan_lines IPT0();
	extern void ega_set_line_compare IPT1(int,i);
#endif
	IMPORT VOID update_banking IPT0();
	IMPORT VOID set_banking IPT2(IU8, rd_bank, IU8, wrt_bank);

	IMPORT VOID set_mark_funcs IPT0();

	extern int ega_int_enable;

	extern byte *EGA_planes;

#define EGA_plane01 EGA_planes
#define EGA_plane23 (EGA_planes+2)
#define EGA_plane0123 EGA_planes

#define FONT_MEM_SIZE	0x2000		/* max no of bytes in font memory block */
#define FONT_MEM_OFF	0x4000		/* mem offset of next font definition from previous */

#define FONT_BASE_ADDR	2

#define FONT_MAX_HEIGHT	32		/* max font support for 32 scanline high fonts */

#ifdef V7VGA
#define   set_v7_bank_for_seq_chain4( rd_bank, wrt_bank )  *(wrt_bank) =  \
			(((extensions_controller.ram_bank_select.as_bfld.cpu_write_bank_select & 1)<<2) \
			| (miscellaneous_output_register.as_bfld.page_bit_odd_even<<1) \
			| extensions_controller.page_select.as_bfld.extended_page_select); \
										*(rd_bank) =  \
			(((extensions_controller.ram_bank_select.as_bfld.cpu_read_bank_select & 1)<<2) \
			| (miscellaneous_output_register.as_bfld.page_bit_odd_even<<1) \
			| extensions_controller.page_select.as_bfld.extended_page_select)
#endif /* V7VGA */

#endif

#if defined(C_VID) || defined(A2CPU)

/*
 *	C_VID variants use the ports code in e/vga_ports.c
 */

#define Cpu_define_outb( port, func )
#else
/* Declare as Import to remove warnings */
#ifdef ANSI
IMPORT VOID Cpu_define_outb(IU16 adapterID, VOID (*asmFunc) IPT2(io_addr, port, half_word, value));
#else
IMPORT VOID Cpu_define_outb IPT2(IU16, adapterID, VOID (*)(), asmFunc);
#endif /* ANSI */
 
#endif /* C_VID || A2CPU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egagraph.h ===
/*
 * SccsID = @(#)egagraph.h	1.13 04/22/93  Copyright Insignia Solutions Ltd.
 */

#ifdef	EGG

typedef	union {
	half_word	as_byte;
	struct {
#ifdef	BIT_ORDER2
		unsigned screen_can_wrap : 1;
		unsigned split_screen_used : 1;
		unsigned ht_of_200_scan_lines : 1;
		unsigned double_pix_wid : 1;
		unsigned graph_shift_reg : 1;
		unsigned cga_mem_bank : 1;
		unsigned chained : 1;
		unsigned text_mode : 1;
#else
		unsigned text_mode : 1;
		unsigned chained : 1;
		unsigned cga_mem_bank : 1;
		unsigned graph_shift_reg : 1;
		unsigned double_pix_wid : 1;
		unsigned ht_of_200_scan_lines : 1;
		unsigned split_screen_used : 1;
		unsigned screen_can_wrap : 1;
#endif
	} as_bfld;
} DISPLAY_STATE;

#define EGA_PALETTE_SIZE 16
extern	struct	EGA_GLOBALS {
	int			actual_offset_per_line;	/* in bytes */
#ifdef VGG
	_10_BITS		screen_split;
	boolean			palette_change_required;
	boolean			colour_256;
	boolean			colour_select;	/* 16/64 size palette choice (AR10:7) */
	half_word		DAC_mask;
	int			mid_pixel_pad;	/* video bits 4&5 when AR10:7 = 1 */
	int			top_pixel_pad;	/* video bits 7 & 6 unless 256 colour mode */
	half_word		palette_ind[EGA_PALETTE_SIZE];
	boolean		multiply_vert_by_two;
#else
	_9_BITS			screen_split;
#endif
	int			colours_used;
	PC_palette		palette[EGA_PALETTE_SIZE];
	byte			border[3];
	int			plane_mask;
	int			intensity;
	boolean			attrib_font_select;
	int			prim_font_index;	/* index (0-3) of primary selected font	    */
	int			sec_font_index;		/* index (0-3) of secondary selected font   */
	int			underline_start;	/* scanline to start drawing underline attr */
	DISPLAY_STATE		display_state;
	byte			*regen_ptr[4];
} EGA_GRAPH;

#ifdef VGG
extern PC_palette *DAC;			/* Size is `VGA_DAC_SIZE' */
#endif

#define	get_screen_can_wrap()		(EGA_GRAPH.display_state.as_bfld.screen_can_wrap)
#define	get_200_scan_lines()		(EGA_GRAPH.display_state.as_bfld.ht_of_200_scan_lines)
#define	get_split_screen_used()		(EGA_GRAPH.display_state.as_bfld.split_screen_used)
#define	get_actual_offset_per_line()	(EGA_GRAPH.actual_offset_per_line)
#define	get_ptr_offset(ptr,offs)	((ptr) != NULL ? &((ptr)[offs]) : NULL)
#define	get_regen_ptr1(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[0],offs)
#define	get_regen_ptr2(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[1],offs)
#define	get_regen_ptr3(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[2],offs)
#define	get_regen_ptr4(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[3],offs)
#define	get_regen_ptr(x,offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[x],offs)
#define	get_plane_mask()		(EGA_GRAPH.plane_mask)
#define	get_intensity()			(EGA_GRAPH.intensity)
#define	plane0_enabled()		(get_plane_mask() & 0x1)
#define	plane01_enabled()		(get_plane_mask() & 0x3)
#define	plane1_enabled()		(get_plane_mask() & 0x2)
#define	plane2_enabled()		(get_plane_mask() & 0x4)
#define	plane23_enabled()		(get_plane_mask() & 0xC)
#define	plane3_enabled()		(get_plane_mask() & 0x8)
#define	all_planes_enabled()		(get_plane_mask() & 0xf)
#define	get_cga_mem_bank()		(EGA_GRAPH.display_state.as_bfld.cga_mem_bank)
#define	get_graph_shift_reg()		(EGA_GRAPH.display_state.as_bfld.graph_shift_reg)
#define	get_memory_chained()		(EGA_GRAPH.display_state.as_bfld.chained)
#define	get_double_pix_wid()		(EGA_GRAPH.display_state.as_bfld.double_pix_wid)
#define	get_munged_index()		(EGA_GRAPH.display_state.as_byte)
#define is_it_cga()			(EGA_GRAPH.display_state.as_byte & 0x60)
#define is_it_text()			((EGA_GRAPH.display_state.as_byte & 0x80) == 0x80)
#define	get_attrib_font_select()	(EGA_GRAPH.attrib_font_select)
#ifdef V7VGA
#define	get_screen_split()		(((EGA_GRAPH.screen_split.as_word)+1)<<EGA_GRAPH.multiply_vert_by_two)
#else
#define	get_screen_split()		((EGA_GRAPH.screen_split.as_word)+1)
#endif /* V7VGA */
#define	get_prim_font_index()		(EGA_GRAPH.prim_font_index)
#define	get_sec_font_index()		(EGA_GRAPH.sec_font_index)
#define	get_underline_start()		(EGA_GRAPH.underline_start)

#ifdef VGG
#define get_256_colour_mode()		(EGA_GRAPH.colour_256)
#define get_DAC_mask()			(EGA_GRAPH.DAC_mask)
#define get_colour_select()		(EGA_GRAPH.colour_select)
#define get_top_pixel_pad()		(EGA_GRAPH.top_pixel_pad)
#define get_mid_pixel_pad()		(EGA_GRAPH.mid_pixel_pad)
#if defined(NEC_98)         
#define get_palette_change_required()   (NEC98Display.palette.flag)
#else  // !NEC_98
#define get_palette_change_required()	(EGA_GRAPH.palette_change_required)
#endif // !NEC_98
#define get_palette_val(idx)		(EGA_GRAPH.palette_ind[(idx)])

#define set_256_colour_mode(val)	EGA_GRAPH.colour_256 = (val)
#define set_DAC_mask(val)		EGA_GRAPH.DAC_mask = (val)
#define set_colour_select(val)		EGA_GRAPH.colour_select = (val)
#define set_top_pixel_pad(val)		EGA_GRAPH.top_pixel_pad = (val)
#define set_mid_pixel_pad(val)		EGA_GRAPH.mid_pixel_pad = (val)
#if defined(NEC_98)         
#define set_palette_change_required(v)  NEC98Display.palette.flag = (v)
#else  // !NEC_98
#define set_palette_change_required(v)	EGA_GRAPH.palette_change_required = (v)
#endif // !NEC_98
#define set_palette_val(idx,val)	EGA_GRAPH.palette_ind[(idx)] = (val)
#define flag_palette_change_required()	EGA_GRAPH.palette_change_required = (TRUE)
#endif

#define	set_screen_can_wrap(val)	EGA_GRAPH.display_state.as_bfld.screen_can_wrap = (val)
#define	set_attrib_font_select(val)	EGA_GRAPH.attrib_font_select = (val)
#define	set_regen_ptr1(ptr)		EGA_GRAPH.regen_ptr[0] = (ptr)
#define	set_regen_ptr2(ptr)		EGA_GRAPH.regen_ptr[1] = (ptr)
#define	set_regen_ptr3(ptr)		EGA_GRAPH.regen_ptr[2] = (ptr)
#define	set_regen_ptr4(ptr)		EGA_GRAPH.regen_ptr[3] = (ptr)
#define	set_regen_ptr(x,ptr)		EGA_GRAPH.regen_ptr[(x)] = (ptr)
#define	set_plane_mask(val)		EGA_GRAPH.plane_mask = (val)
#define	set_intensity(val)		EGA_GRAPH.intensity = (val)
#define	set_cga_mem_bank(val)		EGA_GRAPH.display_state.as_bfld.cga_mem_bank = ((val) & 1)
#define	set_graph_shift_reg(val)	EGA_GRAPH.display_state.as_bfld.graph_shift_reg = ((val) & 1)
#define	set_memory_chained(val)		EGA_GRAPH.display_state.as_bfld.chained = ((val) & 1)
#define	set_text_mode(val) \
	EGA_GRAPH.display_state.as_bfld.text_mode = ((val) & 1)
#define	set_double_pix_wid(val)		EGA_GRAPH.display_state.as_bfld.double_pix_wid = ((val) & 1)
#define	set_200_scan_lines(val)		EGA_GRAPH.display_state.as_bfld.ht_of_200_scan_lines = (val)
#define	set_split_screen_used(val)	EGA_GRAPH.display_state.as_bfld.split_screen_used = (val)
#define	set_actual_offset_per_line(val)	EGA_GRAPH.actual_offset_per_line = (val)
#define	set_screen_split_hi(val)	EGA_GRAPH.screen_split.as_bfld.top_bit = (val)
#define	set_screen_split_lo(val)	EGA_GRAPH.screen_split.as_bfld.lo_byte = (val)
#define	set_screen_split(val)		EGA_GRAPH.screen_split.as_word = (val)
#define	set_prim_font_index(val)	EGA_GRAPH.prim_font_index = (val)
#define	set_sec_font_index(val)		EGA_GRAPH.sec_font_index = (val)
#define	set_underline_start(val)		EGA_GRAPH.underline_start = (val)

typedef	enum {
	ALPHA_MODE,
	GRAPHICS_MODE
} MODE_TYPE;

typedef enum {
	NO_SCROLL,
	TEXT_SCROLL,
	CGA_TEXT_SCROLL,
	CGA_GRAPH_SCROLL,
	EGA_GRAPH_SCROLL
#ifdef VGG
	,
	VGA_GRAPH_SCROLL
#endif
#ifdef V7VGA
	,
	V7VGA_GRAPH_SCROLL
#endif
} SCROLL_TYPE;

extern	char	mode_strings[][20];

#define	get_mode_string(mode)		mode_strings[(int) mode]

#define	RED	0
#define	GREEN	1
#define	BLUE	2

#define	get_palette_bit(color)		attribute_controller.palette[attribute_controller.address.as_bfld.index].as_bfld.color
#define	get_palette_color(col,sec_col)	((get_palette_bit(col)*0xA0)  | (get_palette_bit(sec_col)*0x50))

#define	get_border_bit(color)		attribute_controller.overscan_color.as_bfld.color
#define	get_border_color(col,sec_col)	((get_border_bit(col)*0xA0) | (get_border_bit(sec_col)*0x50))

#define	MAX_SCAN_LINES		350
#define	MAX_SCREEN_SPLIT	350

typedef	enum {
	SIMPLE_MARKING,
	CGA_GRAPHICS_MARKING,
	EGA_GRAPHICS_MARKING
} MARKING_TYPE;

/*
 * attribute bit selecting character to come from secondary font
 */

#define	SEC_FONT_ATTR	0x8

/*
 * The EGA underlines if the attr = X000X001, where X means 'dont care'.
 */
#define UL_ATTR_MASK	0x77	/* Mask to remove the X bits */
#define UL_ATTR		0x01	/* value to test against after masking */

/*
 * ======================================================================
 * Extern function prototypes.
 * ======================================================================
 */

IMPORT	void	dump_EGA_GRAPH IPT0();

/* AJO 18-Feb-93
 * The following prototype should be in gfx_upd.h (the code is in gfx_update.c),
 * however we can't put it there cos' gfx_upd.h most be included before
 * this file, but MARKING_TYPE and SCROLL_TYPE are defined in here; so short
 * of putting it in it own special include file this is the easiest option
 * for the moment.
 */
IMPORT void set_gfx_update_routines IPT3(T_calc_update, update_routine,
		MARKING_TYPE, marking_type, SCROLL_TYPE, scroll_type);

#endif	/* EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egatrace.h ===
/*
 *
 * SccsID @(#)egatrace.h	1.3 08/10/92 Copyright Insignia Solutions
 *
 *	The file is in binary format, with the following structure:
 *
 *	Adaptor type (byte),then..
 *
 *	op:data,data, etc.
 *	where op can be:
 *
 *	1	Set last_address read to M[data] (32bits)
 *	2	outb port,value (long,byte)
 *	3	outw port,value (long,word)
 *	4	inb port (long)
 *	5	M[addr] = data (long,byte)
 *	6	M[addr] = data (long,word)
 *	7	M[l_addr->h_addr] = data (long,long,byte)
 *	8	M[l_addr->h_addr] = data (long,long,word)
 *	9	M[l_addr->h_addr] = data,data.. (long,long, (h_addr-l_addr+1)*byte)
 *	10	Graphics Tick.
 *	11	Scroll.
 *	12	inw port (long)
 *	13	read byte (set lda to addr)
 *	14	read word (set lda to addr+1)
 *	15	read string (set lda to laddr or haddr dp DF)
 *	254	checkpoint
 *	255	End.
 *
 *	words & longs are Intel/Clipper format - ie low byte first.
 */

#define READ		1
#define OUTB		2
#define OUTW		3
#define INB		4
#define WRITE_BYTE	5
#define WRITE_WORD	6
#define FILL_BYTE	7
#define FILL_WORD	8
#define MOVE_BYTE	9
#define TICK		10
#define SCROLL		11
#define	INW		12
#define	READ_BYTE	13	/* lda = addr */
#define	READ_WORD	14	/* lda = addr + 1 */
#define	READ_STRING	15	/* lda = haddr ?? */

#define	MAX_DUMP_TYPE	15
#define	CHECKPT		254
#define EOFile		255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egaread.h ===
/* SccsID = @(#)egaread.h	1.5 08/10/92 Copyright Insignia Solutions */

#ifdef ANSI
extern void ega_read_init(void);
extern void ega_read_term(void);
extern void ega_read_routines_update(void);
extern boolean ega_need_read_op(int);
#else /* ANSI */
extern void ega_read_init();
extern void ega_read_term();
extern void ega_read_routines_update();
extern boolean ega_need_read_op();
#endif /* ANSI */

typedef struct
{
	ULONG	mode;
	UTINY	colour_compare;
	UTINY	colour_dont_care;
} READ_STATE;

IMPORT READ_STATE read_state;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\d_oper.h ===
/* 
   d_oper.h

   Define all Decoded Operand Types.
 */

/*
   static char SccsID[]="@(#)d_oper.h	1.1 05 Oct 1993 Copyright Insignia Solutions Ltd.";
 */


/*
   The Decoded Intel Operands.
   ---------------------------

   The naming convention used is similiar to that used in the Intel
   documentation for the 386 or 486 processors. See Appendix A - The
   Opcode Map, for details.

   Each decoded operand has an argument type, identifiers,
   addressability indication and specific values associated with it.
   The exact return values for each operand are listed below. The values
   should only be accessed through the macros provided, the layout may
   be changed in the future. The macros take a pointer to a DECODED_ARG
   as their argument.

   
   Operands are encoded in a two letter plus optional size form:-

      <addressing method><operand type><size>
   
   Addressing methods are denoted by upper case letters, viz:-

   C The operand is a control register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   D The operand is a debug register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   I The operand is an immediate value.

     immediate identifier.          DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY
     the value.                     DCD_IMMED1

   J The operand is a relative offset.

     addressability(Read/Write).    DCD_ADDRESSABILITY
     the value.                     DCD_IMMED1

   K The operand is two immediate values.

     addressability(Read/Write).    DCD_ADDRESSABILITY
     the first value.               DCD_IMMED1
     the second value.              DCD_IMMED2

   M The operand is held in memory.

     addressing mode.               DCD_IDENTIFIER
     sub type of addressing mode.   DCD_SUBTYPE
     addressability(Read/Write).    DCD_ADDRESSABILITY
     segment register identifier.   DCD_SEGMENT_ID
     addressing displacement.       DCD_DISP

   R The operand is a general register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   S The operand is a segment register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   T The operand is a test register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY
   
   V The operand is a register in the co-processor stack.

     stack addressing mode.              DCD_IDENTIFIER
     addressability(Read/Write).         DCD_ADDRESSABILITY
     stack relative register identifier. DCD_INDEX

   Operand types are denoted by lower case letters, viz:-

   a operand pair in memory, as used by BOUND.
     <size> = 16 word operands.
     <size> = 32 double word operands.

   b byte.

   d double word.

   i floating point integer
     <size>  16 16-bit word integer
     <size>  32 32-bit short integer
     <size>  64 64-bit long integer
     <size>  80 80-bit packed decimal integer

   p far pointer.
     <size> = 16 16:16 ptr (ie 32-bit)
     <size> = 32 16:32 ptr (ie 48-bit)

   r floating point real
     <size> = 32 32-bit short real
     <size> = 64 64-bit long real
     <size> = 80 80-bit temp real

   w word.

   s six-byte descriptor.
   
   Additionally the 'M' addressing method has a form with no operand
   type, but the following optional sizes:-
      
      <size>  14 =  14-byte data block
      <size>  28 =  28-byte data block
      <size>  94 =  94-byte data block
      <size> 108 = 108-byte data block
   
 */

/*
   The argument types:-
 */
#define A_	(UTINY)  0
#define A_Rb	(UTINY)  1 /* aka r8,r/m8                            */
#define A_Rw	(UTINY)  2 /* aka r16,r/m16                          */
#define A_Rd	(UTINY)  3 /* aka r32,r/m32                          */
#define A_Sw	(UTINY)  4 /* aka Sreg                               */
#define A_Cd	(UTINY)  5 /* aka CRx                                */
#define A_Dd	(UTINY)  6 /* aka DRx                                */
#define A_Td	(UTINY)  7 /* aka TRx                                */
#define A_M	(UTINY)  8 /* aka m                                  */
#define A_M14	(UTINY)  9 /* aka m14byte                            */
#define A_M28	(UTINY) 10 /* aka m28byte                            */
#define A_M94	(UTINY) 11 /* aka m94byte                            */
#define A_M108	(UTINY) 12 /* aka m108byte                           */
#define A_Ma16	(UTINY) 13 /* aka m16&16                             */
#define A_Ma32	(UTINY) 14 /* aka m32&32                             */
#define A_Mb	(UTINY) 15 /* aka m8,r/m8,moffs8                     */
#define A_Md	(UTINY) 16 /* aka m32,r/m32,moffs32                  */
#define A_Mi16	(UTINY) 17 /* aka m16int                             */
#define A_Mi32	(UTINY) 18 /* aka m32int                             */
#define A_Mi64	(UTINY) 19 /* aka m64int                             */
#define A_Mi80	(UTINY) 20 /* aka m80dec                             */
#define A_Mp16	(UTINY) 21 /* aka m16:16                             */
#define A_Mp32	(UTINY) 22 /* aka m16:32                             */
#define A_Mr32	(UTINY) 23 /* aka m32real                            */
#define A_Mr64	(UTINY) 24 /* aka m64real                            */
#define A_Mr80	(UTINY) 25 /* aka m80real                            */
#define A_Ms	(UTINY) 26 /* aka m16&32                             */
#define A_Mw	(UTINY) 27 /* aka m16,r/m16,moffs16                  */
#define A_I	(UTINY) 28 /* aka imm8,imm16,imm32                   */
#define A_J	(UTINY) 29 /* aka rel8,rel16,rel32                   */
#define A_K	(UTINY) 30 /* aka ptr16:16,ptr16:32                  */
#define A_V	(UTINY) 31 /* aka ST,push onto ST, ST(i)             */

/* allowable DCD_IDENTIFIER'S for byte registers */
#define A_AL	(USHORT)0
#define A_CL	(USHORT)1
#define A_DL	(USHORT)2
#define A_BL	(USHORT)3
#define A_AH	(USHORT)4
#define A_CH	(USHORT)5
#define A_DH	(USHORT)6
#define A_BH	(USHORT)7

/* allowable DCD_IDENTIFIER'S for word registers */
#define A_AX	(USHORT)0
#define A_CX	(USHORT)1
#define A_DX	(USHORT)2
#define A_BX	(USHORT)3
#define A_SP	(USHORT)4
#define A_BP	(USHORT)5
#define A_SI	(USHORT)6
#define A_DI	(USHORT)7

/* allowable DCD_IDENTIFIER'S for double word registers */
#define A_EAX	(USHORT)0
#define A_ECX	(USHORT)1
#define A_EDX	(USHORT)2
#define A_EBX	(USHORT)3
#define A_ESP	(USHORT)4
#define A_EBP	(USHORT)5
#define A_ESI	(USHORT)6
#define A_EDI	(USHORT)7

/* allowable DCD_IDENTIFIER'S for segment registers */
/* allowable DCD_SEGMENT_ID'S for segment addressing registers */
#define A_ES	(USHORT)0
#define A_CS	(USHORT)1
#define A_SS	(USHORT)2
#define A_DS	(USHORT)3
#define A_FS	(USHORT)4
#define A_GS	(USHORT)5

/* allowable DCD_IDENTIFIER'S for control registers */
#define A_CR0	(USHORT)0
#define A_CR1	(USHORT)1
#define A_CR2	(USHORT)2
#define A_CR3	(USHORT)3
#define A_CR4	(USHORT)4
#define A_CR5	(USHORT)5
#define A_CR6	(USHORT)6
#define A_CR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for debug registers */
#define A_DR0	(USHORT)0
#define A_DR1	(USHORT)1
#define A_DR2	(USHORT)2
#define A_DR3	(USHORT)3
#define A_DR4	(USHORT)4
#define A_DR5	(USHORT)5
#define A_DR6	(USHORT)6
#define A_DR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for test registers */
#define A_TR0	(USHORT)0
#define A_TR1	(USHORT)1
#define A_TR2	(USHORT)2
#define A_TR3	(USHORT)3
#define A_TR4	(USHORT)4
#define A_TR5	(USHORT)5
#define A_TR6	(USHORT)6
#define A_TR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for memory addressing type */
/* <addr size><mode><r/m> */
#define A_1600	  (USHORT) 0 /* [BX + SI]       */
#define A_1601	  (USHORT) 1 /* [BX + DI]       */
#define A_1602	  (USHORT) 2 /* [BP + SI]       */
#define A_1603	  (USHORT) 3 /* [BP + DI]       */
#define A_1604	  (USHORT) 4 /* [SI]            */
#define A_1605	  (USHORT) 5 /* [DI]            */
#define A_1606	  (USHORT) 6 /* [d16]           */
#define A_1607	  (USHORT) 7 /* [BX]            */

#define A_1610	  (USHORT) 8 /* [BX + SI + d8]  */
#define A_1611	  (USHORT) 9 /* [BX + DI + d8]  */
#define A_1612	  (USHORT)10 /* [BP + SI + d8]  */
#define A_1613	  (USHORT)11 /* [BP + DI + d8]  */
#define A_1614	  (USHORT)12 /* [SI + d8]       */
#define A_1615	  (USHORT)13 /* [DI + d8]       */
#define A_1616	  (USHORT)14 /* [BP + d8]       */
#define A_1617	  (USHORT)15 /* [BX + d8]       */

#define A_1620	  (USHORT)16 /* [BX + SI + d16] */
#define A_1621	  (USHORT)17 /* [BX + DI + d16] */
#define A_1622	  (USHORT)18 /* [BP + SI + d16] */
#define A_1623	  (USHORT)19 /* [BP + DI + d16] */
#define A_1624	  (USHORT)20 /* [SI + d16]      */
#define A_1625	  (USHORT)21 /* [DI + d16]      */
#define A_1626	  (USHORT)22 /* [BP + d16]      */
#define A_1627	  (USHORT)23 /* [BX + d16]      */

/* <addr size><mode><r/m> */
#define A_3200	  (USHORT)24 /* [EAX]       */
#define A_3201	  (USHORT)25 /* [ECX]       */
#define A_3202	  (USHORT)26 /* [EDX]       */
#define A_3203	  (USHORT)27 /* [EBX]       */
#define A_3205	  (USHORT)28 /* [d32]       */
#define A_3206	  (USHORT)29 /* [ESI]       */
#define A_3207	  (USHORT)30 /* [EDI]       */

#define A_3210	  (USHORT)31 /* [EAX + d8]  */
#define A_3211	  (USHORT)32 /* [ECX + d8]  */
#define A_3212	  (USHORT)33 /* [EDX + d8]  */
#define A_3213	  (USHORT)34 /* [EBX + d8]  */
#define A_3215	  (USHORT)35 /* [EBP + d8]  */
#define A_3216	  (USHORT)36 /* [ESI + d8]  */
#define A_3217	  (USHORT)37 /* [EDI + d8]  */

#define A_3220	  (USHORT)38 /* [EAX + d32] */
#define A_3221	  (USHORT)39 /* [ECX + d32] */
#define A_3222	  (USHORT)40 /* [EDX + d32] */
#define A_3223	  (USHORT)41 /* [EBX + d32] */
#define A_3225	  (USHORT)42 /* [EBP + d32] */
#define A_3226	  (USHORT)43 /* [ESI + d32] */
#define A_3227	  (USHORT)44 /* [EDI + d32] */

/* <addr size><S=SIB form><mode><base> */
#define A_32S00	  (USHORT)45 /* [EAX + si]       */
#define A_32S01	  (USHORT)46 /* [ECX + si]       */
#define A_32S02	  (USHORT)47 /* [EDX + si]       */
#define A_32S03	  (USHORT)48 /* [EBX + si]       */
#define A_32S04	  (USHORT)49 /* [ESP + si]       */
#define A_32S05	  (USHORT)50 /* [d32 + si]       */
#define A_32S06	  (USHORT)51 /* [ESI + si]       */
#define A_32S07	  (USHORT)52 /* [EDI + si]       */

#define A_32S10	  (USHORT)53 /* [EAX + si + d8]  */
#define A_32S11	  (USHORT)54 /* [ECX + si + d8]  */
#define A_32S12	  (USHORT)55 /* [EDX + si + d8]  */
#define A_32S13	  (USHORT)56 /* [EBX + si + d8]  */
#define A_32S14	  (USHORT)57 /* [ESP + si + d8]  */
#define A_32S15	  (USHORT)58 /* [EBP + si + d8]  */
#define A_32S16	  (USHORT)59 /* [ESI + si + d8]  */
#define A_32S17	  (USHORT)60 /* [EDI + si + d8]  */

#define A_32S20	  (USHORT)61 /* [EAX + si + d32] */
#define A_32S21	  (USHORT)62 /* [ECX + si + d32] */
#define A_32S22	  (USHORT)63 /* [EDX + si + d32] */
#define A_32S23	  (USHORT)64 /* [EBX + si + d32] */
#define A_32S24	  (USHORT)65 /* [ESP + si + d32] */
#define A_32S25	  (USHORT)66 /* [EBP + si + d32] */
#define A_32S26	  (USHORT)67 /* [ESI + si + d32] */
#define A_32S27	  (USHORT)68 /* [EDI + si + d32] */

/* memory address directly encoded in instruction */
#define A_MOFFS16   (USHORT)69 /* [d16] */
#define A_MOFFS32   (USHORT)70 /* [d32] */

/* <addr size><XLT>, xlat addressing form */
#define A_16XLT   (USHORT)71 /* [BX + AL]  */
#define A_32XLT   (USHORT)72 /* [EBX + AL] */

/* <addr size><ST><SRC|DST>, string addressing forms */
#define A_16STSRC (USHORT)73 /* [SI]  */
#define A_32STSRC (USHORT)74 /* [ESI] */
#define A_16STDST (USHORT)75 /* [DI]  */
#define A_32STDST (USHORT)76 /* [EDI] */

/* allowable DCD_SUBTYPE'S for memory addressing sub type */
/* <ss><index> */
#define A_SINO (UTINY) 0 /* No SIB byte */
#define A_SI00 (UTINY) 1 /* EAX       */
#define A_SI01 (UTINY) 2 /* ECX       */
#define A_SI02 (UTINY) 3 /* EDX       */
#define A_SI03 (UTINY) 4 /* EBX       */
#define A_SI04 (UTINY) 5 /* none      */
#define A_SI05 (UTINY) 6 /* EBP       */
#define A_SI06 (UTINY) 7 /* ESI       */
#define A_SI07 (UTINY) 8 /* EDI       */

#define A_SI10 (UTINY) 9 /* EAX x 2   */
#define A_SI11 (UTINY)10 /* ECX x 2   */
#define A_SI12 (UTINY)11 /* EDX x 2   */
#define A_SI13 (UTINY)12 /* EBX x 2   */
#define A_SI14 (UTINY)13 /* undefined */
#define A_SI15 (UTINY)14 /* EBP x 2   */
#define A_SI16 (UTINY)15 /* ESI x 2   */
#define A_SI17 (UTINY)16 /* EDI x 2   */

#define A_SI20 (UTINY)17 /* EAX x 4   */
#define A_SI21 (UTINY)18 /* ECX x 4   */
#define A_SI22 (UTINY)19 /* EDX x 4   */
#define A_SI23 (UTINY)20 /* EBX x 4   */
#define A_SI24 (UTINY)21 /* undefined */
#define A_SI25 (UTINY)22 /* EBP x 4   */
#define A_SI26 (UTINY)23 /* ESI x 4   */
#define A_SI27 (UTINY)24 /* EDI x 4   */

#define A_SI30 (UTINY)25 /* EAX x 8   */
#define A_SI31 (UTINY)26 /* ECX x 8   */
#define A_SI32 (UTINY)27 /* EDX x 8   */
#define A_SI33 (UTINY)28 /* EBX x 8   */
#define A_SI34 (UTINY)29 /* undefined */
#define A_SI35 (UTINY)30 /* EBP x 8   */
#define A_SI36 (UTINY)31 /* ESI x 8   */
#define A_SI37 (UTINY)32 /* EDI x 8   */

/* allowable DCD_IDENTIFIER'S for immediates */
#define A_IMMC  (USHORT)0 /* constant */
#define A_IMMB  (USHORT)1 /* byte */
#define A_IMMW  (USHORT)2 /* word */
#define A_IMMD  (USHORT)3 /* double word */
#define A_IMMWB (USHORT)4 /* word <- byte */
#define A_IMMDB (USHORT)5 /* double word <- byte */

/* allowable DCD_IDENTIFIER'S for co-processor registers */
#define A_ST   (USHORT)0 /* Stack Top */
#define A_STP  (USHORT)1 /* Push onto Stack Top */
#define A_STI  (USHORT)2 /* Stack Register relative to Stack Top */

/* allowable DCD_ADDRESSABILITY'S

   The operand addressability rules, bit encoded as follows:-
      Bit 0 = 1 ==> is source argument.
      Bit 1 = 1 ==> is destination argument.
 */
#define AA_   0
#define AA_R  1
#define AA_W  2
#define AA_RW 3


/*
   Macros to access operand values.
   All take pointer to DECODED_ARG as their argument.
 */

#define DCD_IDENTIFIER(p)     ((p)->identifier)
#define DCD_ADDRESSABILITY(p) ((p)->addressability)
#define DCD_SUBTYPE(p)        ((p)->sub_id)
#define DCD_SEGMENT_ID(p)     ((p)->arg_values[0])
#define DCD_DISP(p)           ((p)->arg_values[1])
#define DCD_IMMED1(p)         ((p)->arg_values[0])
#define DCD_IMMED2(p)         ((p)->arg_values[1])
#define DCD_INDEX(p)          ((p)->arg_values[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\equip.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Equipment word definitions
 *
 * Description	: The equipment word shows what optional devices are
 *		  attached to the PC
 *
 * Author	: Ross Beresford
 *
 * Notes	: None
 */

/* SccsID[]="@(#)equip.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifdef	BIGEND
#ifdef	BIT_ORDER1
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD printer_count:2;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD unused:1;

		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD diskette_present:1;
	} bits;
} EQUIPMENT_WORD;
#endif
#ifdef	BIT_ORDER2
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD unused:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD printer_count:2;

		HALF_WORD_BIT_FIELD diskette_present:1;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
	} bits;
} EQUIPMENT_WORD;
#endif
#endif

#ifdef	LITTLEND
#ifdef	BIT_ORDER1
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD diskette_present:1;

		HALF_WORD_BIT_FIELD printer_count:2;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD unused:1;
	} bits;
} EQUIPMENT_WORD;
#endif
#ifdef	BIT_ORDER2
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD diskette_present:1;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */

		HALF_WORD_BIT_FIELD unused:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD printer_count:2;
	} bits;
} EQUIPMENT_WORD;
#endif
#endif

#define EQUIP_FLAG		BIOS_VAR_START + 0x10

#define	RAM_SIZE_16K	0
#define	RAM_SIZE_32K	1
#define	RAM_SIZE_48K	2
#define	RAM_SIZE_64K	3

#define	VIDEO_MODE_UNUSED	0
#define	VIDEO_MODE_40X25_COLOUR	1
#define	VIDEO_MODE_80X25_COLOUR	2
#define	VIDEO_MODE_80X25_BW	3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egavideo.h ===
/* SccsID = @(#)egavideo.h      1.13 11/22/93 Copyright Insignia Solutions */

#define ega_char_height   0x485 /* word on IBM, but second byte always 0 */
#define ega_info          0x487 /* lots of useful info. */
#define ega_info3         0x488 /* EGA switches + feature bits. == 0xf9 */
#define EGA_SAVEPTR       0x4A8    /* offset into M of pointer to pointer table for parms etc */
#define VGA_DCC           0x48A /* offset into M of index into dcc table */

/* fields of info & info3: */
#define get_EGA_no_clear() (sas_hw_at_no_check(ega_info) & 0x80)
#define get_EGA_disp() ((sas_hw_at_no_check(ega_info) & 2)>>1)
#define get_EGA_mem() ((sas_hw_at_no_check(ega_info) & 0x60)>>5)
#define get_EGA_cursor_no_emulate() (sas_hw_at_no_check(ega_info) & 1)
#define set_EGA_cursor_no_emulate(val)  \
        sas_store_no_check(ega_info,    \
        (IU8)((sas_hw_at_no_check(ega_info) & 0xfe) | (val)));

#define get_EGA_feature() (sas_hw_at_no_check(ega_info3) & 0xf0)>>4
#define get_EGA_switches() (sas_hw_at_no_check(ega_info3) & 0xf)
/* offset into each entry of each section of ega mode parameters */
#define EGA_PARMS_COLS 0
#define EGA_PARMS_ROWS 1
#define EGA_PARMS_HEIGHT 2
#define EGA_PARMS_LENGTH 3      /* Word */
#define EGA_PARMS_SEQ   5       /* Sequencer regs 1-4 */
#define EGA_PARMS_SEQ_SIZE 4
#define EGA_PARMS_MISC  9       /* Misc. register */
#define EGA_PARMS_CRTC  10      /* CRT regs 0-24 */
#define EGA_PARMS_CRTC_SIZE 25
#define EGA_PARMS_CURSOR 20     /* CRT regs 10 & 11 */
#define EGA_PARMS_ATTR  35      /* Attribute regs 0-19 */
#define EGA_PARMS_ATTR_SIZE 20
#define EGA_PARMS_GRAPH 55      /* Graphics regs 0-8 */
#define EGA_PARMS_GRAPH_SIZE 9
#define EGA_PARMS_SIZE 64       /* Size of one entry in table */
#define FONT_LOAD_MODE 0xB      /* Screen 'mode' to use to load fonts */
/* Location of default ega mode parameters */
#define EGA_PARMS_OFFSET 0x0F09
#define VGA_PARMS_OFFSET 0x0150 /* was F09 but now have more modes in parm table */

#define EGA_PALETTE_ENABLE      0x20

/* Offsets into the save table of the various pointers */

/* Offsets into the save table of the various pointers */
#define PALETTE_OFFSET 4
#define ALPHA_FONT_OFFSET 8
#define GRAPH_FONT_OFFSET 12

/* Location of font definitions */
#if 0
#define EGA_CGMN        0xC2230
#define EGA_CGDDOT      0xC3160
#define EGA_HIFONT      0xC3990         /* 8x16 font for 640x480 ext */
#define EGA_CGMN_OFF    0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF  0x3160
#define EGA_HIFONT_OFF  0x3990
#define EGA_INT1F_OFF   0x3560
#endif

#ifdef VGG
/* Flags controlling extra bits of VGA BIOS, not in EGA one */
#define VGA_FLAGS       0x489
#define S350            0
#define S400            0x10
#define S200            0x80
#define PAL_LOAD_OFF    0x8
#define VGA_MONO        0x4
#define GREY_SCALE      0x2
#define VGA_ACTIVE      0x1
#define get_VGA_flags() sas_hw_at_no_check(VGA_FLAGS)
#define set_VGA_flags(val) sas_store_no_check(VGA_FLAGS, (val))
#define get_VGA_lines() (sas_hw_at_no_check(VGA_FLAGS) & 0x90)
#define set_VGA_lines(val) sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0x6f) | (val)))
#define is_GREY()       (sas_hw_at_no_check(VGA_FLAGS) & 2)
#define set_GREY(val)   sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0xfd) | (val)))
#define is_PAL_load_off() (sas_hw_at_no_check(VGA_FLAGS) & 0x80)
#define set_PAL_load_off(val) sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0xf7) | (val)))
#define is_MONO()       (sas_hw_at_no_check(VGA_FLAGS) & 4)

/* Location of INT10 AX=1b, second stage info table */
#define INT10_1B_DATA   0x01bc
#endif

/*
 * Defines for values indicating real number of scanlines on display
 * These are the values returned by INT10 AH=1B, and are also used
 * internally
 */
#define RS200   0
#define RS350   1
#define RS400   2
#define RS480   3

#ifdef ANSI
extern int get_scanlines(void);
extern sys_addr find_mode_table(int,sys_addr *);
extern sys_addr follow_ptr(sys_addr);
#else
extern int get_scanlines();
extern sys_addr find_mode_table();
extern sys_addr follow_ptr();
#endif /* ANSI */

#ifdef MSWDVR
IMPORT VOID host_mswin_disable IPT0();
#endif

#ifdef V7VGA
IMPORT VOID v7vga_extended_set_mode IPT0();
IMPORT VOID v7vga_func_6f IPT0();
#endif

#ifdef VGG
IMPORT VOID vga_set_palette IPT0();
IMPORT VOID vga_func_12 IPT0();
IMPORT VOID init_vga_dac IPT1( int, table );
#endif

#if defined(NTVDM) && defined(MONITOR)

#define F8x14    0
#define F8x8pt1  1
#define F8x8pt2  2
#define F9x14    3
#define F8x16    4
#define F9x16    5

typedef struct {
        word off;
        word seg;
} NativeFontAddr;

IMPORT NativeFontAddr nativeFontAddresses[6];
#endif  /* NTVDM & MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\fdisk.h ===
/* @(#)fdisk.h	1.9 02/10/93 Copyright Insignia Solutions Ltd. 
	
FILE NAME	:

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	:
DATE		:


=========================================================================

AMENDMENTS	:

=========================================================================
*/

IMPORT VOID disk_io IPT0();
IMPORT VOID disk_post IPT0();

IMPORT VOID fdisk_inb IPT2(io_addr, port, UTINY *, value);
IMPORT UTINY fdisk_read_dir IPT2(io_addr, port, UTINY *, value);
IMPORT VOID fdisk_inw IPT2(io_addr, port, USHORT *, value);
IMPORT VOID fdisk_outb IPT2(io_addr, port, UTINY, value);
IMPORT VOID fdisk_outw IPT2(io_addr, port, USHORT, value);
IMPORT VOID fdisk_ioattach IPT0();
IMPORT VOID fdisk_iodetach IPT0();
IMPORT VOID fdisk_physattach IPT1(int, driveno);
IMPORT VOID fdisk_reset IPT0();
IMPORT VOID hda_init IPT0();
IMPORT VOID host_fdisk_get_params IPT4(int, driveid, int *, n_cyl,
					int *, n_heads, int *, n_sects);
IMPORT VOID host_fdisk_term IPT0();
IMPORT int host_fdisk_rd IPT4(int, driveid, int,offset, int, nsecs, char *,buf);
IMPORT int host_fdisk_wt IPT4(int, driveid, int,offset, int, nsecs, char *,buf);
IMPORT VOID host_fdisk_seek0 IPT1(int, driveid);
IMPORT int host_fdisk_create IPT2(char *, filename, ULONG, units);

IMPORT VOID patch_rom IPT2(IU32, addr, IU8, val);
IMPORT VOID fast_disk_bios_attach IPT1( int, drive );
IMPORT VOID fast_disk_bios_detach IPT1( int, drive );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\emm.h ===
/* SccsID = @(#)emm.h	1.12 08/31/93 Copyright Insignia Solutions Ltd.
	
FILE NAME	: emm.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: July '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
#define	VERSION			0x40	/* memory manager version no.	*/
#define EMM_PAGE_SIZE		0x4000	/* page size  - 16k		*/
#define MAX_NO_HANDLES		255	/* max. no. of handles supported*/
					/* under EMS 4.0 ( 0 - 255 )	*/
#ifdef NTVDM
#define MAX_NO_PAGES		36 + 12 /* below 640KB = 36 pages	*/
					/* above 640KB = 12 pages	*/
#define MAX_ALTREG_SETS 	255	/* allowable alt map register set */
/* one byte represents 8 sets */
#define ALTREG_ALLOC_MASK_SIZE	(MAX_ALTREG_SETS + 7) / 8
#define IMPOSSIBLE_ALTREG_SET	255
#define INTEL_PAGE_SIZE 	0x1000	/* Intel CPU page size		*/
#define INTEL_PARAGRAPH_SIZE	0x10	/* Intel CPU paragraph size	*/
#define EMM_INTEL_PAGE_RATIO	4	/* 1 EMM PAGE = 4 INTEL PAGEs	*/
#define PAGE_PARA_RATIO 	0x100	/* 1 INTEL PAGE = 0x100 PARAs	*/
#define EMM_PAGE_TO_INTEL_PAGE(emm_page)    \
	(emm_page * EMM_INTEL_PAGE_RATIO)
#define SEGMENT_TO_INTEL_PAGE(segment)	    \
	(segment / PAGE_PARA_RATIO)

#else
#define MAX_NO_PAGES		32	/* max. no of locations for	*/
					/* mapping pages, (24 between	*/
					/* 256KB and 640KB and 8 between*/
					/* EM_start and EM_end		*/
#endif

#define MIN_FUNC_NO		0x40	/* Lowest function code		*/
#ifndef PROD
#define	MAX_FUNC_NO		0x5f	/* Highest function code	*/
#else					/* (includes trace options)	*/
#define	MAX_FUNC_NO		0x5d	/* Highest function code	*/
#endif
#define NAME_LENGTH		8	/* Length of handle name	*/
#define UNMAPPED		-1	/* EM page is not mapped in	*/
#define	MSB	     ((IU32)0x80000000)	/* used for pagemap operations	*/
/*
 *	The following 3 defines are used in specifying the current
 * 	or required mapping context
 */
#define EMPTY			-1	/* No page mapped in   		*/
#define LEAVE			-2	/* Leave existing page alone	*/
#define	FREE			-3	/* indicates page map not used 	*/

/*
 *	The following 4 defines are used in the function 26,
 *	Get Expanded Memory Hardware Information call
 */				
#define RAW_PAGE_SIZE		1024	/* size in paragraphs(16 bytes)	*/
#define ALT_REGISTER_SETS	0	/* Alternate register sets	*/
#define DMA_CHANNELS		0	/* No of DMA channels supported	*/
#define DMA_CHANNEL_OPERATION	0	
			

/*	ERROR RETURNS from Top Layer		*/


#ifdef NTVDM
#define EMM_SUCCESS		0
#endif
#define	EMM_HW_ERROR		0x81	/* memory allocation failure	*/
#define BAD_HANDLE		0x83	/* couldn't find handle		*/
#define	BAD_FUNC_CODE		0x84	/* Function code not defined	*/
#define NO_MORE_HANDLES		0x85	/* No handles available		*/
#define MAP_SAVED		0x86	/* Mapping context saved	*/
#define	NOT_ENOUGH_PAGES	0x87	/* Not enough Total pages	*/
#define NO_MORE_PAGES		0x88	/* No more pages available	*/
#define BAD_LOG_PAGE		0x8a	/* Invalid logical page no.	*/
#define BAD_PHYS_PAGE		0x8b	/* Invalid physical page no.	*/
#define MAP_IN_USE		0x8d	/* Mapping context already saved*/
#define NO_MAP			0x8e	/* The handle has no map saved	*/
#define BAD_SUB_FUNC		0x8f	/* Invalid sub-function code	*/
#define NOT_SUPPORTED		0x91	/* This function not supported	*/
#define MOVE_MEM_OVERLAP	0x92	/* Src and dest memory overlap	*/
#define TOO_FEW_PAGES		0x93	/* Not enough pages in handle	*/
#define OFFSET_TOO_BIG		0x95	/* Offset exceeds size of page	*/
#define LENGTH_GT_1M		0x96	/* Region length exceeds 1 Mbyte*/
#define XCHG_MEM_OVERLAP	0x97	/* Src and dest memory overlap	*/
#define BAD_TYPE		0x98	/* Unsupported memory type	*/

#ifdef NTVDM
#define UNSUPPORTED_ALT_REGS	0x9A	/* altreg set is not supported */
#define NO_FREE_ALT_REGS	0x9B	/* no free alt reg available */
#define INVALID_ALT_REG 	0x9d	/* invalid alt reg was given	*/
#endif

#define NO_ALT_REGS		0x9c	/* Alt. map regs not supported	*/
#define HANDLE_NOT_FOUND	0xa0	/* Can't find specified name	*/
#define NAME_EXISTS		0xa1	/* Handle name already used	*/
#define WRAP_OVER_1M		0xa2	/* Attempt made to wrap over 1M	*/
#define BAD_MAP			0xa3	/* Source array contents wrong	*/
#define ACCESS_DENIED		0xa4	/* O/S denies access to this	*/


#ifdef NTVDM
typedef struct	_LIM_CONFIG_DATA {
    boolean  initialized;		/* the structure contains meaningful data */
    unsigned short total_altreg_sets;	/* total alt mapping register set */
    unsigned long backfill;		/* back fill in bytes */
    unsigned short base_segment;	/* back fill starting segment */
    boolean  use_all_umb;		/* use all available UMB for frame */
} LIM_CONFIG_DATA, * PLIM_CONFIG_DATA;

IMPORT	boolean	get_lim_configuration_data(PLIM_CONFIG_DATA lim_config_data);
IMPORT	unsigned short get_no_altreg_sets(void);
IMPORT	unsigned short get_active_altreg_set(void);
IMPORT	boolean altreg_set_ok(unsigned short set);
IMPORT	boolean allocate_altreg_set(unsigned short * set);
IMPORT	boolean deallocate_altreg_set(unsigned short set);
IMPORT	boolean activate_altreg_set(unsigned short set, short * page_in);
IMPORT	short	get_segment_page_no(unsigned short segment);
IMPORT unsigned short get_lim_page_frames(unsigned short * page_table, PLIM_CONFIG_DATA lim_config_data);
IMPORT boolean init_lim_configuration_data(PLIM_CONFIG_DATA lim_config_data);
IMPORT unsigned short get_lim_backfill_segment(void);

#if defined(MONITOR) && !defined(PROD)
IMPORT unsigned short get_emm_page_size(void);
IMPORT unsigned short get_intel_page_size(void);
#endif

#endif


/*	Handle storage area layout
 *
 *	__________________________________________________________
 *	|  N  |  . Handle Name  .  |  Map Context |No.  |No.  |
 *	|_____|____________________|______________|_____|_____|___
 *
 *	name					  nsize
 * 	offset					  <----->
 *	|----->
 *	|	map offset
 *	|-------------------------->
 *	|		page offset
 *	|----------------------------------------->
 *
 *	N		No. of pages in handle
 *	Handle Name	Optional 8 character name
 *	Map Context	A 'snapshot' of the pages currently mapped
 *			requires a 2 byte entry for every physical
 *			page - (optional)
 *	No		Expanded memory page number assigned to handle
 */
#define NSIZE		2
#define	NAME_OFFSET	2
#define	MAP_OFFSET	(NAME_OFFSET + NAME_LENGTH)

/* page_offset is set by the init_expanded_memory() routine */

/*
 *	External declarations for Top level routines
 */

IMPORT void reset_emm_funcs IPT0();
 
/*
 *	External declarations for memory manager routines
 */
 
#ifdef ANSI
extern int		restore_map(short handle_no, unsigned short segment,
				    unsigned short offset,
				    short pages_out[], short pages_in[]);
#else /* ANSI */
extern int		restore_map();
#endif /* ANSI */

IMPORT VOID LIM_b_write   IPT1(sys_addr, intel_addr);
IMPORT VOID LIM_str_write IPT2(sys_addr, intel_addr, ULONG, length);
IMPORT VOID LIM_w_write   IPT1(sys_addr, intel_addr);

IMPORT boolean	handle_ok	IPT1(short, handle_no);
IMPORT short	get_new_handle	IPT1(short, no_pages);
IMPORT int	free_handle	IPT1(short, handle_no);
IMPORT void	print_handle_data IPT1(short, handle_no);
IMPORT short	get_total_handles IPT0();
IMPORT short	get_total_open_handles IPT0();
IMPORT int	reallocate_handle IPT3(short, handle_no,
				       short, old_page_count,
				       short, new_page_count);
#ifndef NTVDM
IMPORT ULONG	page_already_mapped IPT2(short, EM_page_no,
					 unsigned char *, physical_page_no);
#endif


IMPORT short	get_map_size	IPT0();
IMPORT boolean	map_saved	IPT1(short, handle_no);
IMPORT short	get_map_no IPT2(short, handle_no,
				unsigned char, physical_page_no);
IMPORT int	save_map IPT5(short, handle_no,
			      unsigned short, dst_segment,
			      unsigned short, dst_offset,
			      unsigned short, src_segment,
			      unsigned short, src_offset);

IMPORT int copy_exchange_data IPT8(unsigned char, type,
				   short, src_handle,
				   unsigned short, src_seg_page,
				   unsigned short, src_offset,
				   short, dst_handle,
				   unsigned short, dst_seg_page,
				   unsigned short, dst_offset,
				   unsigned long, length);

IMPORT short	alloc_page	IPT0();
IMPORT int	page_status	IPT1(short, EMpage_no);
IMPORT int	free_page	IPT1(short, EM_page_no);
IMPORT int	map_page	IPT2(short, EM_page_no,
				     unsigned char, physical_page_no);
IMPORT int	unmap_page	IPT1(unsigned char, physical_page_no);
IMPORT short	get_no_pages	IPT1(short, handle_no);
IMPORT void	set_no_pages	IPT2(short, handle_no, short, no_pages);
IMPORT short	get_total_pages IPT0();
IMPORT short	get_unallocated_pages IPT0();
IMPORT short	get_no_phys_pages IPT0();

IMPORT int init_expanded_memory IPT2(int, size, int, mem_limit);
IMPORT void free_expanded_memory IPT0();

IMPORT unsigned short get_base_address IPT0();
IMPORT unsigned short get_page_seg IPT1(unsigned char, page_no);

IMPORT short	get_EMpage_no IPT2(short, handle_no, short, logical_page_no);
IMPORT void	set_EMpage_no IPT3(short, handle_no, short, logical_page_no,
				   short, EM_page_no);

IMPORT void	set_map_no IPT3(short, handle_no,
				unsigned char, physical_page_no,
				short, EM_page_no);

IMPORT char *	get_name	IPT1(short, handle_no);
IMPORT void	set_name	IPT2(short, handle_no, char *, new_name);

/*
 *	External declarations for host specific routines
 */
 
IMPORT int	host_initialise_EM	IPT1(short, size);
IMPORT int	host_deinitialise_EM	IPT0();
IMPORT long	host_allocate_storage	IPT1(int, no_bytes);
IMPORT int	host_free_storage	IPT1(long, storage_ID);
IMPORT long	host_reallocate_storage IPT3(long, storage_ID,
			int, size, int, new_size);
IMPORT int	host_map_page 		IPT2(short, EM_page_no,
			unsigned short, segment);
IMPORT int	host_unmap_page		 IPT2(unsigned short, segment,
			short, EM_page_no);
IMPORT short	host_alloc_page		IPT0();
IMPORT int	host_free_page		IPT1(short, EM_page_no);
IMPORT int	host_copy_con_to_con	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_copy_con_to_EM	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_copy_EM_to_con	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_copy_EM_to_EM	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_exchg_con_to_con	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_exchg_con_to_EM	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_exchg_EM_to_EM	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);


#if defined(X86GFX) && defined(NTVDM)

// for x86 platform, we don't have to update logical page
// as they are in a single section of view.
// If we did an unmap as for mips, then mirror pages will
// get unmapped which is not what we want.

#define host_update_logical_page
#define host_patch_one_page     patch_one_page_full

#else /* (NTVDM AND X86GFX) */

#ifndef host_update_logical_page
#define host_update_logical_page	host_unmap_page
#define host_patch_one_page		patch_one_page_full
#endif

#endif /* (NTVDM AND X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\error.h ===
#ifdef NTVDM
#include "..\..\host\inc\error.h"

#else
#ifndef _INS_ERROR_H
#define _INS_ERROR_H
/*[
	Name:		error.h
	Derived From:	Base 2.0
	Author(s):	M.McCusker and J.D.R. (config msgs)
	Created On:	Unknown
	Sccs ID:	@(#)error.h	1.45 06/22/95
	Purpose:	Define the list of error messages and also the
			interface to the host_error family of functions.
	Notes:		This file is guarded against multiple inclusion.

MUST INCLUDE
	insignia.h

DESCRIPTION
	This file provides an interface into the SoftPC error handling system.

	It defines the main generic base error messages in a large enum.

	It also defines a list of error headers and variants.  3.0 host_error
	Now looks up the error code in a table of ERROR_STRUCTs to find what
	header to print and also in which of the possible variants to format
	the error panel.

	Header types are:-
		EH_WARNING		A warning message
		EH_ERROR		Runtime Error
		EH_CONFIG		Configuration File Problem
		EH_INSTALL		installation File Problem.

	Each variant has up to three separate strings that will be printed on
	the panel.  These strings change function depending on the error
	variant.

	Variant types are:-
		EV_SIMPLE		Simple Error Pnael, Message Only.
		EV_EXTRA_CHAR		Extra Char panel, current default.
		EV_BAD_FILE		Config Error variant bad file.
		EV_SYS_BAD_VALUE	Config System Bad Entry.
		EV_BAD_VALUE		Config bad user config entry.
		EV_BAD_INPUT		Input also variant of EV_EXTRA_CHAR.

	Each variant interprets the ErrData structure a little differently.
	The BAD VALUE/INPUT variants also allow input form the error panel
	into string_1 of the ErrData Structure.  For input if the user hits
	the Continue button on the panel the input filed is strcpy'd to
	string_1.  string_1 MUST be a pointer to an adequately sized char[].
	
		Name			Parameters
		EV_SIMPLE		No parameters required.
		EV_EXTRA_CHAR		1 - Extra Char.
		EV_BAD_FILE		1 - Name of problem file.
		EV_SYS_BAD_VALUE	1 - Current Value of entry.
					2 - Bad Option option name.
		EV_BAD_VALUE		1 - Current value char array (i/o).
					2 - Bad Option Name.
					3 - System Default Value.
		EV_BAD_INPUT		1 - Problem Line (i/o).

IMPORTED DATA
Error Description Tables	ERROR_STRUCT base_errors[];
				ERROR_STRUCT host_errors[];

base and host errors	Tables indexed by the error code that provide
			host_error_ext with the header and variant types.

TYPEDEFS

Parameter to extended error	struct
				{
					char *string_1;
					char *string_2;
					char *string_3;
				} ErrData, *ErrDataPtr;

Error Function Pointers		struct
				{
					SHORT (*error_conf)();
					SHORT (*error)();
					SHORT (*error_ext)();
				} ERRORFUNCS;

Ancillary data per error	struct
				{
					CHAR header;
					CHAR variant;
				} ERROR_STRUCT;

The error code enum,		See header file for details.

GLOBAL FUNCTIONS

Current Error Function Table	IMPORT ERRORFUNCS *working_error_funcs;

Error Macros			host_error_conf(panel, num, opts, extra)
				host_error(num, opts, extra)
				host_error_ext(num, opts, data)

host_error_conf

	SHORT host_error_conf
		(int panel, int errCode, int buttons, char *extraChar)

	host_error_conf will not be supported by the 3.0 generic Motif UIF.
	This call will just be a straight front end to a call of
	host_error_ext.

	See Also host_error_ext.

host_error

	SHORT host_error(int errCode, int buttons, char *extraChar)

	This function loads extraChar into string one of a local ErrData
	structure and calls host_error_ext.
	
	See also host_error_ext.

host_error_ext

	SHORT host_error_ext(int errCode, int buttons, ErrDataPtr errDataP)

	ErrCode is an index into either the base_errors array or the
	host_errors array, 1-999 base, 1001-1999 host_errors.  The header
	code and the variant type is looked up in this array.

	A maximum of three buttons can be or'ed into the buttons parameter
	which are: ERR_QUIT, ERR_CONT, ERR_RESET, ERR_DEF & ERR_CONFIG any
	three of these can be used, NB ERR_CONFIG and ERR_DEF are exactly the
	same ERR_CONFIG is provided for backwards compatibility.  The
	following macros are provided for convenience:-
		ERR_QU_CO_RE
		ERR_QU_CO_DE
		ERR_QU_CO
		ERR_QU_RE
		ERR_QU_DE
		ERR_STANDARD		Here for compatibility

	After the panel is displayed, and the user chooses an option button is
	interpreted as follows:-
		ERR_QUIT  - Call terminate(), doesn't return.
		ERR_CONT  - For some variants strcpy the input field.
		ERR_RESET - Calls Reboot.
		ERR_DEF } - No action.
		ERR_CONFIG}

	Finally, host_error_ext returns the option the user selected.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Button bit mask values
 */

#define	ERR_QUIT	1
#define	ERR_CONT	2
#define	ERR_RESET	4
#define	ERR_DEF		8
#define	ERR_CONFIG	8

#define	ERR_QU_CO_RE	( ERR_QUIT | ERR_CONT | ERR_RESET )
#define	ERR_QU_CO_DE	( ERR_QUIT | ERR_CONT | ERR_DEF )
#define	ERR_QU_CO	( ERR_QUIT | ERR_CONT )
#define	ERR_QU_RE	( ERR_QUIT | ERR_RESET )
#define	ERR_QU_DE	( ERR_QUIT | ERR_DEF )

#define	ERR_STANDARD	( ERR_QU_CO_RE )	/* here for compatibility */

/*
 * The following are the Generic Error messages displayed by
 * SoftPC.  Host Specific messages are defined in xxxx_error.h
 * where xxxx is the machine ID.
 */

/*
   New messages MUST be added to the end of the list, or replace a
   spare number. This rule prevents undue change to message catalogues,
   both Insignia-generated ones and translations provided by OEMs.
  
   YOU MUST UPDATE message.c AND err_tble.c
   YOU MUST REPORT A HOST IMPACT ON MESSAGE CATALOGUES
 */

typedef enum 
{
	EG_BAD_OP=0,
	EG_SLAVEPC_NO_LOGIN,
	EG_SLAVEPC_NO_RESET,	
	EG_SLAVEPC_BAD_LINE,
	EG_MISSING_HDISK,  
	EG_REAL_FLOPPY_IN_USE,
	EG_HDISK_BADPATH,	  
	EG_HDISK_BADPERM,	 
	EG_HDISK_INVALID,
	EG_NO_ROOM_FOR_LIM,
	EG_HDISK_CANNOT_CREATE,
	EG_HDISK_READ_ONLY, 
	EG_OWNUP,	 	     
	EG_FSA_NOT_FOUND,     
	EG_FSA_NOT_DIRECTORY,
	EG_FSA_NO_READ_ACCESS,  
	EG_NO_ACCESS_TO_FLOPPY, 
	EG_NO_ROM_BASIC,
	EG_SLAVE_ON_TTYA,  
	EG_TTYA_ON_SLAVE, 
	EG_SAME_HD_FILE, 
	EG_DFA_BADOPEN,
	EG_EXPANDED_MEM_FAILURE,	  
	EG_MISSING_FILE,            
	EG_CONT_RESET,		     
	EG_INVALID_EXTENDED_MEM_SIZE,
	EG_INVALID_EXPANDED_MEM_SIZE,
	EG_INVALID_AUTOFLUSH_DELAY,
	EG_INVALID_VIDEO_MODE,
	EG_NO_GRAPHICS,		/* Dumb terminal using spare slot */
	EG_REZ_UPDATE,		
	EG_NO_REZ_UPDATE,
	EG_HFX_NO_USE,
	EG_HFX_NO_NET,
	EG_HFX_IN_USE,
	EG_HFX_LOST_DIR,
	EG_HFX_NOT_DIR,
	EG_HFX_CANT_READ,
	EG_HFX_DRIVE_NO_USE,
	EG_HFX_DRIVE_ILL,
	EG_NO_FONTS,	
	EG_UNSUPPORTED_VISUAL,
	EG_NO_SOUND,
	EG_SIG_PIPE,         
	EG_MALLOC_FAILURE,  
	EG_NO_REAL_FLOPPY_AT_ALL,
	EG_SYS_MISSING_SPCHOME,
	EG_SYS_MISSING_FILE,
	EG_BAD_OPTION, 
	EG_WRITE_ERROR,		/* Dumb terminal using spare slot */
	EG_CONF_MISSING_FILE,
	EG_CONF_FILE_WRITE,
	EG_DEVICE_LOCKED,
	EG_DTERM_BADOPEN,
	EG_DTERM_BADTERMIO,
	EG_BAD_COMMS_NAME,
	EG_BAD_VALUE,
	EG_SYS_BAD_VALUE,
	EG_SYS_BAD_OPTION,
	EG_SYS_CONF_MISSING,
	EG_BAD_CONF,
	EG_CONF_MISSING,
	EG_BAD_MSG_CAT,
	EG_DEMO_EXPIRED,
	EG_GATE_A20,
	EG_NO_LOCKD,
	EG_DATE_FWD,
	EG_DATE_BACK,

	EG_NOT_CHAR_DEV,  /*  New generic floppy error.   GM */
	EG_MSW_256_COLOURS,
	EG_MSW_16_COLOURS,

	EG_HDISK_LOCKED,
	EG_UNKNOWN_LOCK,
	EG_NO_TERM_DESCR,
	EG_DEFAULT_TERM,

	EG_ST_BAD_OPTION,	/* New Serial Terminal config error messages */
	EG_ST_BAD_CONF,
	EG_ST_CONF_MISSING,

	EG_UNSUPPORTED_DEPTH,	/* BCN 1622 */
	
	EG_INSUF_MEMORY,

	EG_BAD_DISK_READ,
	EG_BAD_DISK_WRITE,
	
	EG_LICENSE_FAILURE,	/* Licensing error messages. BCN XXXX */
	EG_LICENSE_EXPIRED,
	EG_LICENSE_LOST,
	EG_3_MINS_LEFT,
	EG_TIMES_UP,
	EG_UNAUTHORISED,
	EG_LICENSE_EXCEEDED,
	EG_INSTALL_ON_SERVER,
	EG_FAILED_LMGRD,
	EG_FAILED_INITTAB,
	EG_UPDATE_LICFILE_FAILED,
	EG_WRONG_MSWDVR,
#ifdef DOS_APP_LIC
	EG_DAL_TOO_MUCH_NESTING,
	EG_DAL_LIC_EXPIRED,
	EG_DAL_LIC_EXCEEDED,
#endif
	EG_FAILED_RCLOCAL,

#ifdef SOFTWIN_API
	EG_API_MISMATCH,
#endif /* SOFTWIN_API */

	EG_OVERWRITE_DRIVE_C,

	EG_NO_SNDBLST_SUPPORT,
	EG_DIRECTORY,
#ifdef HOST_HELP
	EG_HELP_ERROR,
	EG_HELP_NOT_INSTALLED,
#endif /* HOST_HELP */
#ifdef SECURE
	EG_SYS_INSECURE,
#endif

	EG_INFINITE_LOOP,
	EG_DRIVER_MISMATCH,
	EG_MISSING_INS_VXD,
	NUM_BASE_ERRORS
} base_error_type;

/* The error message EG_HDISK_NOT_FOUND was a duplicate of EG_MISSING_HDISK
** so was removed. This define is in case EG_HDISK_NOT_FOUND is being used
** in anyone's host.
*/
#define       EG_HDISK_NOT_FOUND	EG_MISSING_HDISK

typedef struct
{
	char header;
	char varient;
} ERROR_STRUCT;

typedef enum
{
	EH_WARNING=0,
	EH_ERROR,
	EH_CONFIG,
	EH_INSTALL,
	EH_LAST
} base_error_headers;

typedef enum
{
	EV_SIMPLE=0,
	EV_EXTRA_CHAR,
	EV_BAD_FILE,
	EV_SYS_BAD_VALUE,
	EV_BAD_VALUE,
	EV_BAD_INPUT,
	EV_LAST
} base_error_varients;

/* 
 * 'string_1' is always used for input when necessary.  When it is
 * used for input it must point to a buffer with ample space.
 */
typedef struct
{
	char *string_1;	/* this must be a pointer to an ample buffer */
	char *string_2;
	char *string_3;
} ErrData, *ErrDataPtr;

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI

typedef struct
{
	SHORT (*error_conf)(int, int, int, char *);
	SHORT (*error)(int, int, char *);
	SHORT (*error_ext)(int, int, ErrDataPtr);
} ERRORFUNCS;

#else /* ANSI */

typedef struct
{
	SHORT (*error_conf)();
	SHORT (*error)();
	SHORT (*error_ext)();
} ERRORFUNCS;

#endif /* ANSI */

IMPORT ERRORFUNCS *working_error_funcs;

#define host_error_conf(panel, num, opts, extra)\
		(*working_error_funcs->error_conf)(panel, num, opts, extra)

#define host_error(num, opts, extra)\
		(*working_error_funcs->error)(num, opts, extra)

#define host_error_ext(num, opts, data)\
		(*working_error_funcs->error_ext)(num, opts, data)
/* Prototype for the host_get_system_error_function which
 * sits in the source code. Added 8.3.95
 */
IMPORT char * host_get_system_error IPT3 (char *, filename, int, line, int, errno);


/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"

#endif /* _INS_ERROR_H */
#endif /* ntvdm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\fla.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Floppy Disk Adaptor definitions
 *
 * Description	: This file contains those definitions that are used
 *		  by modules calling the FLA as well as thw FLA itself.
 *
 * Author	: Henry Nash
 *
 * Notes	: This file is included by fla.f and should not be
 *		  included directly.
 */

/* @(#)fla.h	1.5 08/26/92 */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 * The FLA also supports the IBM Digital Output Register (DOR) that is used
 * to control the physical drives.  The bits are assigned as follows:
 *
 *	Bits 0,1   - Drive select between drives 0-3
 *	Bit  2     - Not Reset (ie reset when low)
 *	Bit  3     - Interrupts/DMA  enabled
 *	Bits 4-7   - Motor on for drives 0-3
 *
 */ 

#define DOR_RESET	0x04
#define DOR_INTERRUPTS	0x08

/*
 * The following define the command codes supported by the FDC
 */

#define FDC_READ_TRACK    	0x02    
#define FDC_SPECIFY    		0x03
#define FDC_SENSE_DRIVE_STATUS	0x04
#define FDC_WRITE_DATA	    	0x05    
#define FDC_READ_DATA    	0x06    
#define FDC_RECALIBRATE    	0x07
#define FDC_SENSE_INT_STATUS    0x08
#define FDC_WRITE_DELETED_DATA  0x09
#define FDC_READ_ID    		0x0A
#define FDC_READ_DELETED_DATA   0x0C
#define FDC_FORMAT_TRACK    	0x0D
#define FDC_SEEK    		0x0F
#define FDC_SCAN_EQUAL    	0x11
#define FDC_SCAN_LOW_OR_EQUAL   0x19
#define FDC_SCAN_HIGH_OR_EQUAL  0x1D

#define FDC_COMMAND_MASK        0x1f    /* Bits that specify the command */

/*
 * The following mask specifies the Drive Ready Transition state in
 * Status register 0
 */

#define FDC_DRIVE_READY_TRANSITION 	0xC0

/*
 * The FDC Status register bit positions:
 */

#define FDC_RQM		0x80
#define FDC_DIO		0x40
#define FDC_NDMA	0x20
#define FDC_BUSY	0x10

/*
 * Extra registers required for SFD
 */

#define DIR_DRIVE_SELECT_0      (1 << 0)
#define DIR_DRIVE_SELECT_1      (1 << 1)
#define DIR_HEAD_SELECT_0       (1 << 2)
#define DIR_HEAD_SELECT_1       (1 << 3)
#define DIR_HEAD_SELECT_2       (1 << 4)
#define DIR_HEAD_SELECT_3       (1 << 5)
#define DIR_WRITE_GATE          (1 << 6)
#define DIR_DISKETTE_CHANGE     (1 << 7)

#define IDR_ID_MASK             0xf8

#define DCR_RATE_MASK           0x3
#define DCR_RATE_500            0x0
#define DCR_RATE_300            0x1
#define DCR_RATE_250            0x2
#define DCR_RATE_1000           0x3

#define DSR_RQM                 (1 << 7)
#define DSR_DIO                 (1 << 6)

#define DUAL_CARD_ID            0x50

/*
 * ============================================================================
 * External functions and data
 * ============================================================================
 */

/*
 * The flag that indiactes the FLA is busy, and cannot accept asynchronous
 * commands (eg motor off).
 */

extern boolean fla_busy;
extern boolean fla_ndma;

/*
 * The adaptor functions
 */

extern void fla_init IPT0();
extern void fla_inb IPT2(io_addr, port, half_word *, value);
extern void fla_outb IPT2(io_addr, port, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\flexlmif.h ===
/*[
 *****************************************************************************
 *	Name:			flexlmif.h
 *
 *	Derived From:		(original)
 *
 *	Author:			Bruce Anderson
 *
 *	Created On:		August 1993
 *
 *	Sccs ID:		@(#)flexlmif.h	1.4 02/10/94
 *
 *	Coding Stds:		2.0
 *
 *	Purpose:		interface for Flexlm dialog box
 *
 *	Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *****************************************************************************
]*/

#ifdef LICENSING
typedef struct
{
	IBOOL	demo_license ;
#ifdef SOFTWINDOWS_AND_SOFTPC	/* Needed when we have SoftPC and SoftWindows */
	IBOOL	softwindows ;
#endif
	CHAR	host_id[13] ;
	CHAR	server_name[64] ; /* Is this big enough? */
	CHAR	serial_number[20] ; 
	IU16	number_users ;
	IU16	date[3] ; /* day,month,year */
	CHAR	authorization[21] ; /* Code with no white space. */
	IU16	port_number ;
	IBOOL	rootinstall;	/* root is being given chance to install a license */
} FLEXLM_DIALOG ;


extern void Flexlm_dialog_popup IPT1( FLEXLM_DIALOG * , data ) ;
extern void Flexlm_dialog_close IPT0( ) ;
extern void Flexlm_dialog_get IPT1( FLEXLM_DIALOG * , data ) ;
extern void Flexlm_dialog_set IPT1( FLEXLM_DIALOG * , data ) ;
extern IBOOL Flexlm_install_license IPT1(IBOOL, rootinst) ;
extern void Flexlm_start_lmgrd IPT0() ;
extern void Flexlm_error_dialog IPT1( CHAR *, name ) ;
extern IBOOL Flexlm_warning_dialog IPT1( CHAR *, name ) ;
extern CHAR *Flexlm_get_lic_filename IPT0( ) ;

/* Callbacks */
extern IBOOL Flexlm_dialog_validate_authorization IPT1( CHAR * , authorization ) ;
extern IBOOL Flexlm_dialog_validate_serial IPT1( CHAR * , serial ) ;
extern IBOOL Flexlm_dialog_cancel_installation IPT0( ) ;
extern IBOOL Flexlm_dialog_install_license IPT0( ) ;
extern IBOOL Flexlm_dialog_quit_SoftPC IPT0( ) ;
#endif	/* LICENSING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ga_defs.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		ga_defs.h

 Description:

		This module contains defines to support the write mode
		copy function tester for the VGA emulation.

 Author:
		John Shanly

 Date:
		26 September 1990

 SccsID	"@(#)ga_defs.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."

======================================================================
]*/

IMPORT IHP Gdp;

IMPORT ULONG EasVal;
IMPORT ULONG Ead;
IMPORT ULONG Count;
IMPORT ULONG V1;
IMPORT ULONG V2;
IMPORT ULONG V3;
IMPORT ULONG V4;
IMPORT ULONG V5;

IMPORT ULONG V6;
IMPORT ULONG V7;
IMPORT ULONG V8;
IMPORT ULONG V9;
IMPORT ULONG V10;
IMPORT ULONG V11;
IMPORT ULONG V12;
IMPORT ULONG V13;
IMPORT ULONG V14;
IMPORT ULONG V15;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\floppy.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: High Density Floppy BIOS Definitions
 *
 * Description	: Definitions used in the floppy diskette BIOS emulation
 *
 * Author	: Ross Beresford
 *
 * Notes	: 
 *		 
 *		
 *		  
 */

/* @(#)floppy.h	1.9 08/25/93 */


/*
 *	FLOPPY DATA AREAS: we maintain the same data variables as the real
 *	BIOS in case applications know of their significance and use them.
 */

/*
 *	THE SEEK STATUS:
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive A needs recalibrating
 *        |   |   |   |   |   |   |
 *        |   |   |   |   |   |   +----- set if drive B needs recalibrating
 *        |   |   |   |   |   |
 *        |   |   |   |   |   +--------- (set if drive C needs recalibrating)
 *        |   |   |   |   |
 *        |   |   |   |   +------------- (set if drive D needs recalibrating)
 *        |   |   |   |
 *        |   |   |   +----------------- )
 *        |   |   |                      )
 *        |   |   +--------------------- )- unused
 *        |   |                          )
 *        |   +------------------------- )
 *        |
 *        +----------------------------- set when an interrupt is acknowledged
 */

#define SEEK_STATUS		(BIOS_VAR_START + 0x3e)

#define SS_RECAL_ON_0		(1 << 0)
#define SS_RECAL_ON_1		(1 << 1)
#define SS_RECAL_ON_2		(1 << 2)
#define SS_RECAL_ON_3		(1 << 3)
#define	SS_RECAL_MASK		(SS_RECAL_ON_0|SS_RECAL_ON_1| \
					SS_RECAL_ON_2|SS_RECAL_ON_3)
#define SS_INT_OCCURRED		(1 << 7)

/*
 *	THE MOTOR STATUS: this variable reflects the state of the 
 *	Digital Output Register in the floppy adapter
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive A motor is running
 *        |   |   |   |   |   |   |                                   
 *        |   |   |   |   |   |   +----- set if drive B motor is running
 *        |   |   |   |   |   |                                   
 *        |   |   |   |   |   +--------- (set if drive C motor is running)
 *        |   |   |   |   |                                   
 *        |   |   |   |   +------------- (set if drive D motor is running)
 *        |   |   |   |                                   
 *        |   |   |   +----------------- )   number of the drive that is
 *        |   |   |                      )-  currently selected in the
 *        |   |   +--------------------- )   floppy adapter
 *        |   |                                   
 *        |   +------------------------- unused
 *        |                                   
 *        +----------------------------- set during a write operation
 */

#define MS_MOTOR_0_ON		(1 << 0)
#define MS_MOTOR_1_ON		(1 << 1)
#define MS_MOTOR_2_ON		(1 << 2)
#define MS_MOTOR_3_ON		(1 << 3)
#define	MS_MOTOR_ON_MASK	(MS_MOTOR_0_ON|MS_MOTOR_1_ON| \
						MS_MOTOR_2_ON|MS_MOTOR_3_ON)
#define	MS_DRIVE_SELECT_0	(1 << 4)
#define	MS_DRIVE_SELECT_1	(1 << 5)
#define	MS_DRIVE_SELECT_MASK	(MS_DRIVE_SELECT_0|MS_DRIVE_SELECT_1)
#define MS_WRITE_OP		(1 << 7)

/* 
 *	THE MOTOR COUNT: this counter shows how many timer ticks must 
 *	elapse before the drive motors can be turned off. The timer
 *	interrupt handler decrements this value once per timer tick.
 */

#define MC_MAXIMUM		(~0)

/*
 *	THE FLOPPY STATUS:
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- )
 *        |   |   |   |   |   |   |      )
 *        |   |   |   |   |   |   +----- )   0 if the last operation was
 *        |   |   |   |   |   |          )-  carried out successfully;
 *        |   |   |   |   |   +--------- )   otherwise one of various
 *        |   |   |   |   |              )   error values
 *        |   |   |   |   +------------- )
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when there is a CRC error
 *        |   |   |                      
 *        |   |   +--------------------- set when the FDC has a bug
 *        |   |                                   
 *        |   +------------------------- set when a seek terminates abnormally
 *        |                                   
 *        +----------------------------- set when there is a time out
 */

#define FLOPPY_STATUS		(BIOS_VAR_START + 0x41)

#define FS_OK           	0x00
#define FS_BAD_COMMAND         	0x01
#define FS_BAD_ADDRESS_MARK    	0x02
#define FS_WRITE_PROTECTED      0x03
#define FS_SECTOR_NOT_FOUND    	0x04
#define FS_MEDIA_CHANGE		0x06
#define FS_DMA_ERROR         	0x08
#define FS_DMA_BOUNDARY        	0x09
#define FS_MEDIA_NOT_FOUND	0x0C

#define FS_CRC_ERROR         	(1 << 4)
#define FS_FDC_ERROR         	(1 << 5)
#define FS_SEEK_ERROR          	(1 << 6)
#define FS_TIME_OUT            	(1 << 7)

#define	FS_NONSENSICAL		(~0)

/*
 *	THE FDC STATUS: this array stores the result bytes returned from
 *	the floppy disk controller after a command has been executed. 
 */

/*
 *	THE RATE STATUS: this variable controls data rate scanning, 
 *	which is used to determine which of various types of media is 
 *	actually installed in a floppy drive.
 *
 *	+---+---+---+---+	Current data rate (reflects status of the
 *	| 7 | 6 | 5 | 4 |	Digital Control Register in the floppy
 *	+---+---+---+---+	adapter)
 *
 *	+---+---+---+---+
 *	| 3 | 2 | 1 | 0 |	Last data rate to try
 *	+---+---+---+---+
 *        ^   ^   ^   ^
 *        |   |   |   |
 *        |   |   |   +- unused
 *        |   |   |      
 *        |   |   +----- unused
 *        |   |          
 *        |   +--------- )  00 = 500 kbs data rate
 *        |              )- 01 = 300 kbs data rate
 *        +------------- )  10 = 250 kbs data rate
 *                          11 = 1000 kbs data rate
 *
 *	next_rate() is used to cycle through the possible data rates
 */

#define RATE_STATUS		(BIOS_VAR_START + 0x8B)

#define	RS_300	(1 << 6)
#define	RS_250	(1 << 7)
#define	RS_500	(0)
#define	RS_1000	(3 << 6)
#define	RS_MASK	(RS_300 | RS_250)

#ifdef	NTVDM
/* On NT, don't cycle through RS_1000. Why? */
#define	next_rate(rate) (rate == RS_1000? RS_500: \
			(rate == RS_500 ? RS_250: \
			(rate == RS_250 ? RS_300: RS_500)))
#else
#define	next_rate(rate)	(rate == RS_500 ? RS_250: \
			(rate == RS_250 ? RS_300: \
			(rate == RS_300 ? RS_1000: RS_500)))
#endif

/*
 *	Unused high density floppy variables
 */

#define HF_STATUS		(BIOS_VAR_START + 0x8C)
#define HF_ERROR		(BIOS_VAR_START + 0x8D)
#define HF_INT_FLAG		(BIOS_VAR_START + 0x8E)

/*
 *	THE DRIVE CAPABILITY INDICATORS: this variable describes what
 *	features are supported by floppy drives A and B
 *
 *	NB if Drive A supports 80 tracks, the BIOS assumes that the
 *	floppy adapter is a dual fixed disk/diskette adapter
 *
 *	+---+---+---+---+
 *	| 7 | 6 | 5 | 4 |	Drive B
 *	+---+---+---+---+	
 *
 *	+---+---+---+---+
 *	| 3 | 2 | 1 | 0 |	Drive A
 *	+---+---+---+---+
 *        ^   ^   ^   ^
 *        |   |   |   |
 *        |   |   |   +- set if drive supports 80 tracks
 *        |   |   |      
 *        |   |   +----- set for a multiple data rate drive
 *        |   |          
 *        |   +--------- set if the drive capability is determined
 *        |              
 *        +------------- unused
 *
 */

#define DRIVE_CAPABILITY	(BIOS_VAR_START + 0x8F)

#define DC_80_TRACK	(1 << 0)
#define DC_DUAL		DC_80_TRACK
#define DC_MULTI_RATE	(1 << 1)
#define DC_DETERMINED	(1 << 2)
#define	DC_MASK		(DC_80_TRACK|DC_MULTI_RATE|DC_DETERMINED)

/*
 *	THE DRIVE STATUS: one byte each for drive A and B; within the
 *	BIOS functions, the format is as follows:
 *
 *      <- media bits -> <- drive bits ->
 *       
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive supports 80 tracks
 *        |   |   |   |   |   |   |      
 *        |   |   |   |   |   |   +----- set for a multiple data rate drive
 *        |   |   |   |   |   |          
 *        |   |   |   |   |   +--------- set if capability is determined
 *        |   |   |   |   |              
 *        |   |   |   |   +------------- unused
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when media is determined
 *        |   |   |                      
 *        |   |   +--------------------- set when double stepping is required
 *        |   |                                   
 *        |   +------------------------- )  00 = 500 kbs data rate
 *        |                              )- 01 = 300 kbs data rate
 *        +----------------------------- )  10 = 250 kbs data rate
 *                                          11 = 1000 kbs data rate
 *
 *
 *	Outside the BIOS functions, the status is converted to a different
 *	format to be compatible with earlier releases of the BIOS
 *       
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- ) 000 = 360K in 360K undetermined
 *        |   |   |   |   |   |   |      ) 001 = 360K in 1.2M undetermined
 *        |   |   |   |   |   |   |      ) 010 = 1.2M in 1.2M undetermined
 *        |   |   |   |   |   |   +----- ) 011 = 360K in 360K media determined
 *        |   |   |   |   |   |          ) 100 = 360K in 1.2M media determined
 *        |   |   |   |   |   |          ) 101 = 1.2M in 1.2M media determined
 *        |   |   |   |   |   |          ) 110 = unused
 *        |   |   |   |   |   +--------- ) 111 = drive invalid
 *        |   |   |   |   |              
 *        |   |   |   |   +------------- unused
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when media is determined
 *        |   |   |                      
 *        |   |   +--------------------- set when double stepping is required
 *        |   |                                   
 *        |   +------------------------- )  00 = 500 kbs data rate
 *        |                              )- 01 = 300 kbs data rate
 *        +----------------------------- )  10 = 250 kbs data rate
 *                                          11 = 1000 kbs data rate
 */

#define FDD_STATUS		(BIOS_VAR_START + 0x90)

#define FS_MEDIA_DET		(1 << 4)
#define FS_DOUBLE_STEP		(1 << 5)

#define FS_360_IN_360		0x0
#define FS_360_IN_12		0x1
#define FS_12_IN_12		0x2
#define FS_288_IN_288		0x3
#define FS_DRIVE_SICK       	0x7

#define	media_determined(state)	((state & 3) + 3)

/*
 *	THE DRIVE TRACK: one byte each for drives A and B; records
 *	which track each drive last did a seek to
 *
 *	FDD_CLONK_TRACK and FDD_JUDDER_TRACK are track numbers used
 *	in the determination of track capacity
 */

#define FDD_TRACK		(BIOS_VAR_START + 0x94)

#define FDD_CLONK_TRACK		48
#define FDD_JUDDER_TRACK	10

/*
 *	DISKETTE PARAMETER TABLES: the disk pointer in the interrupt
 *	vector table addresses a table of floppy disk characteristics
 *	applying to the current drive and media; the entries in the
 *	table are referenced by offsets
 *
 *	Standard parameter tables are established in the ROM for common
 *	media and drive types; these are referenced from a drive type
 *	table also in ROM
 */

#define DISK_POINTER_ADDR	0x78

#define	DT_SPECIFY1		0	/* 1st FDC specify byte */
#define	DT_SPECIFY2		1	/* 2nd FDC specify byte */
#define	DT_MOTOR_WAIT		2	/* motor off wait time */
#define	DT_N_FORMAT		3	/* bytes/sector indicator */
#define	DT_LAST_SECTOR		4	/* sectors/track */
#define DT_GAP_LENGTH		5	/* gap length */
#define DT_DTL			6	/* data length */
#define DT_FORMAT_GAP_LENGTH	7	/* gap length for format */
#define DT_FORMAT_FILL_BYTE	8	/* fill byte for format */
#define DT_HEAD_SETTLE		9	/* head settle time/ms */
#define DT_MOTOR_START		10	/* motor start time/s */
#define DT_MAXIMUM_TRACK	11	/* maximum track number */
#define DT_DATA_TRANS_RATE	12	/* data transfer rate */

#define	DT_SIZE_OLD		11	/* old table size */
#define	DT_SIZE_NEW		13	/* new table size */

#define MOTOR_WAIT		0x25	/* standard motor off wait time */

#define	DR_CNT			9	/* number of drive types */
#define	DR_SIZE_OF_ENTRY	(sizeof(half_word) + sizeof(word))
					/* size of drive type entry */
#define	DR_WRONG_MEDIA		(1 << 7)/* set if "wrong" media for drive type */

/*
 *	SFD BIOS FLOPPY DISK EQUATES
 */


/*
 *	Drive intelligence level (returned by READ DASD TYPE function)
 */

#define	DRIVE_IQ_UNKNOWN	0
#define DRIVE_IQ_NO_CHANGE_LINE 1
#define DRIVE_IQ_CHANGE_LINE	2
#define DRIVE_IQ_RESERVED	3


/*
 *	Maximum track accessible for drive types
 */

#define	MAXIMUM_TRACK_ON_360	39
#define	MAXIMUM_TRACK_ON_12	79
#define	MAXIMUM_TRACK_ON_720	79
#define	MAXIMUM_TRACK_ON_144	79


/*
 *	Media types
 */

#define	MEDIA_TYPE_360_IN_360		1
#define	MEDIA_TYPE_360_IN_12		2
#define	MEDIA_TYPE_12_IN_12		3
#define	MEDIA_TYPE_720_IN_720		4
#define	MEDIA_TYPE_720_IN_144		5
#define	MEDIA_TYPE_144_IN_144		6

/*
 *	Floppy disk controller status register formats
 */

#define	ST0_UNIT_SELECT_0		(1 << 0)
#define	ST0_UNIT_SELECT_1		(1 << 1)
#define	ST0_HEAD_ADDRESS		(1 << 2)
#define	ST0_NOT_READY			(1 << 3)
#define	ST0_EQUIPMENT_CHECK		(1 << 4)
#define	ST0_SEEK_END			(1 << 5)
#define	ST0_INTERRUPT_CODE_0		(1 << 6)
#define	ST0_INTERRUPT_CODE_1		(1 << 7)

#define	ST1_MISSING_ADDRESS_MARK	(1 << 0)
#define	ST1_NOT_WRITEABLE		(1 << 1)
#define	ST1_NO_DATA			(1 << 2)
#define	ST1_UNUSED_AND_ALWAYS_0_0	(1 << 3)
#define	ST1_OVERRUN			(1 << 4)
#define	ST1_DATA_ERROR			(1 << 5)
#define	ST1_UNUSED_AND_ALWAYS_0_1	(1 << 6)
#define	ST1_END_OF_CYLINDER		(1 << 7)


/*
 *	DMA adapter command codes
 */

#define BIOS_DMA_READ	0x46	/* == write to memory */
#define BIOS_DMA_WRITE	0x4A	/* == read from memory */
#define BIOS_DMA_VERIFY	0x42	/* == verify against memory */

/*
 *	Number of floppy drives that can really be supported
 */

#if defined(NEC_98)
#define MAX_FLOPPY      0x1a
#else  // !NEC_98
#define MAX_FLOPPY	0x02
#endif // !NEC_98

/*
 *	Special value of sectors transferred count
 */

#define	IGNORE_SECTORS_TRANSFERRED	-1

/*
 *	One second in motor time units (1/8 seconds)
 */

#define	WAIT_A_SECOND	 8

/*
 *	Minimum head settle times in milliseconds
 */

#define	HEAD_SETTLE_360	20
#define	HEAD_SETTLE_12	15

/*
 *	FDC settle time in microseconds
 */

#define	FDC_SETTLE	45

/*
 *	Number of times to poll FDC for correct direction and controller
 *	ready before timing out
 */

#define FDC_TIME_OUT	10

/*
 *	SFD BIOS FLOPPY FUNCTION DEFINITIONS
 */

/*
 *	Primary external functions
 */

#ifdef ANSI
extern void diskette_io(void);
extern void diskette_int(void);
extern void diskette_post(void);
#else
extern void diskette_io();
extern void diskette_int();
extern void diskette_post();
#endif /* ANSI */

/*
 *	Secondary external functions
 */

#ifdef ANSI
extern void fl_disk_reset(int);
extern void fl_disk_status(int);
extern void fl_disk_read(int);
extern void fl_disk_write(int);
extern void fl_disk_verify(int);
extern void fl_disk_format(int);
extern void fl_fnc_err(int);
extern void fl_disk_parms(int);
extern void fl_disk_type(int);
extern void fl_disk_change(int);
extern void fl_format_set(int);
extern void fl_set_media(int);
extern void fl_diskette_setup(void);
#else
extern void fl_disk_reset();
extern void fl_disk_status();
extern void fl_disk_read();
extern void fl_disk_write();
extern void fl_disk_verify();
extern void fl_disk_format();
extern void fl_fnc_err();
extern void fl_disk_parms();
extern void fl_disk_type();
extern void fl_disk_change();
extern void fl_format_set();
extern void fl_set_media();
extern void fl_diskette_setup();
#endif /* ANSI */


/*
 *	Other external functions and data
 */

#ifdef ANSI
extern void drive_detect(int);
extern void translate_old(int);
extern void GetFormatParams(int *, int *, int *, int *);
#else
extern void drive_detect();
extern void translate_old();
extern void GetFormatParams();
#endif /* ANSI */


/*
 * External functions in the host.
 */
#ifdef ANSI
extern void host_floppy_init(int, int);
extern void host_floppy_term(int, int);
extern void host_attach_floppies (void);
extern void host_detach_floppies (void);
extern void host_flip_real_floppy_ind (void);
#else
extern void host_floppy_init();
extern void host_floppy_term();
extern void host_attach_floppies ();
extern void host_detach_floppies ();
extern void host_flip_real_floppy_ind ();
#endif /* ANSI */

/*
 *	Secondary function jump table definitions
 */

#define	FL_DISK_RESET	0x00
#define	FL_DISK_STATUS	0x01
#define	FL_DISK_READ	0x02
#define	FL_DISK_WRITE	0x03
#define	FL_DISK_VERF	0x04
#define	FL_DISK_FORMAT	0x05
#define	FL_DISK_PARMS	0x08
#define	FL_FNC_ERR	0x14
#define	FL_DISK_TYPE	0x15
#define	FL_DISK_CHANGE	0x16
#define	FL_FORMAT_SET	0x17
#define	FL_SET_MEDIA	0x18

#define	FL_JUMP_TABLE_SIZE	0x19

#define	fl_operation_in_range(op)	(op < FL_JUMP_TABLE_SIZE)

extern void ((*(fl_fnc_tab[]))());

#ifdef NTVDM
/*
 * NT can't assume the presence and placings of SoftPC ROMs.
 * These variables initialised from ntio.sys
 */
extern word int15_seg, int15_off;
extern word wait_int_seg, wait_int_off;
extern word dr_type_seg, dr_type_off;
extern sys_addr dr_type_addr;
#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\get_env.h ===
/*[
 *	Name:		get_env.h
 *
 *	Derived From:	(original)
 *
 *	Author:		Keith Rautenmbach
 *
 *	Created On:	March 1995
 *
 *	Sccs ID:	@(#)get_env.h	1.1 05/15/95
 *
 *	Purpose:	Prototypes for the Soft486 getenv() wrappers
 *
 *	(c) Copyright Insignia Solutions Ltd., 1995. All rights reserved
]*/


/* These functions are in base/support/get_env.c */

extern IBOOL IBOOLgetenv IPT2(char *, name, IBOOL, default_value);
extern ISM32 ISM32getenv IPT2(char *, name, ISM32, default_value);
extern char *STRINGgetenv IPT2(char *, name, char *, default_value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gendrvr.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	:	Pseudo terminal Interface Task.
 *
 * Desription	:	This module contains those function calls necessary to
 *			interface a PC driver to the pseudo terminal unix
 *			unix drivers.
 *
 * Author	:	Simon Frost/William Charnell
 *
 * Notes	:	None
 *
 */

/*
static char SccsID[]="@(#)gendrvr.h	1.4 09/24/92 Copyright Insignia Solutions Ltd.";
*/

#if defined (GEN_DRVR) || defined (CDROM)
extern void init_gen_drivers();
#endif /* GEN_DRVR || CDROM */

#ifdef GEN_DRVR
extern void gen_driver_io();
#endif /* GEN_DRVR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ga_mark.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		ga_mark.h

 Description:

		This header file allows C code to see generated routines.

 Author:
		John Shanly

 Date:
		5 December 1990

 SccsID	: @(#)ga_mark.h	1.8 04/15/94

        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

======================================================================
]*/

extern void _mark_byte_nch IPT1(IU32, eaOff);
extern void _mark_word_nch IPT1(IU32, eaOff);
extern void _mark_string_nch IPT2(IU32, eaOff, IU32, count);

extern void _mark_byte_ch4 IPT1(IU32, eaOff);
extern void _mark_word_ch4 IPT1(IU32, eaOff);
extern void _mark_string_ch4 IPT2(IU32, eaOff, IU32, count);

extern void _simple_mark_sml IPT1(IU32, eaOff);
extern void _simple_mark_lge IPT2(IU32, eaOff, IU32, count);

extern void _cga_mark_byte IPT1(IU32, eaOff);
extern void _cga_mark_word IPT1(IU32, eaOff);
extern void _cga_mark_string IPT2(IU32, eaOff, IU32, count);

typedef struct 
{
	IU32 (*b_mark) IPT1(IU32, eaOff);
	IU32 (*w_mark) IPT1(IU32, eaOff);
	void (*str_mark) IPT2(IU32, eaOff, IU32, count);
} MARK_POINTERS; 

typedef struct 
{
	IU32 (*b_mark) IPT1(IU32, eaOff);
	IU32 (*w_mark) IPT1(IU32, eaOff);
	IU32 (*d_mark) IPT1(IU32, eaOff);
	void (*str_mark) IPT2(IU32, eaOff, IU32, count);
} EVID_MARK_POINTERS; 

extern MARK_POINTERS simple_marks, cga_marks, nch_marks, ch4_marks;

extern IU32 _simple_b_read();
extern IU32 _simple_w_read();
extern void _simple_str_read();

extern IU32 _rd_ram_dsbld_byte();
extern IU32 _rd_ram_dsbld_word();
extern void _rd_ram_dsbld_string();
extern void _rd_ram_dsbld_fwd_string_lge();
extern void _rd_ram_dsbld_bwd_string_lge();

extern IU32 _rdm0_byte_nch();
extern IU32 _rdm0_word_nch();
extern void _rdm0_string_nch();
extern void _rdm0_fwd_string_nch_lge();
extern void _rdm0_bwd_string_nch_lge();

extern IU32 _rdm0_byte_ch4();
extern IU32 _rdm0_word_ch4();
extern void _rdm0_string_ch4();
extern void _rdm0_fwd_string_ch4_lge();
extern void _rdm0_bwd_string_ch4_lge();

extern IU32 _rdm1_byte_nch();
extern IU32 _rdm1_word_nch();
extern void _rdm1_string_nch();
extern void _rdm1_fwd_string_nch_lge();
extern void _rdm1_bwd_string_nch_lge();

extern IU32 _rdm1_byte_ch4();
extern IU32 _rdm1_word_ch4();
extern void _rdm1_string_ch4();
extern void _rdm1_fwd_string_ch4_lge();
extern void _rdm1_bwd_string_ch4_lge();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfirflop.h ===
/*[
	Name:		gfirflop.h
	Derived From:	2.0 gfirflop.h
	Author:		Henry Nash / David Rees
	Created On:	Unknown
	Sccs ID:	05/10/93 @(#)gfirflop.h	1.6
	Purpose:	Real Diskette functions declarations for GFI
	Notes:		On the Sun version, these globals are exported
               		from 'sun3_wang.c'.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern SHORT host_gfi_rdiskette_active IPT3(UTINY, hostID, BOOL, active,
                                            CHAR *, err);
extern SHORT host_gfi_rdiskette_attach IPT1(UTINY, drive);
extern void  host_gfi_rdiskette_detach IPT1(UTINY, drive);
extern void host_gfi_rdiskette_change IPT2(UTINY, hostID, BOOL, apply);
extern void  host_gfi_rdiskette_init IPT1(UTINY, drive);
extern void  host_gfi_rdiskette_term IPT1(UTINY, drive);
extern SHORT host_gfi_rdiskette_valid IPT3(UTINY, hostID, ConfigValues *, val,
                                           CHAR *, err);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfisflop.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: GFI Slave PC interface 
 *
 * Description	: Definitions required for Remote Procedure Call 
 *		  interface, etc.
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	:
 */

/* SccsID[]="@(#)gfisflop.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*****************************************************************************
 * RS232 port linked to IBM PC
 *****************************************************************************
 */

#define SLAVE_PC_PORT	"/dev/ttya"

/*****************************************************************************
 * Remote Procedure Call (RPC) defines
 *****************************************************************************
 */
#define MAXMSG		120	/* maximum size for message data */
#define MAXFLAGS	2	/* number of bytes in IBM flags   */

/* command ids */
#define LOGIN		0
#define LOGOUT		1
#define WTDMA		2
#define WTDOR		3
#define WTFDC		4
#define RDFDC		5
#define TESTINT		6
#define WTDISKB		7
#define RDDISKB		8
#define CHKMOTOR	9
#define CLRMSTAT	10
#define BLOCKBIOS	11
#define CLRINTFLAG	12
#define DATARATE	13
#define DRIVETYPE	14
#define DISKCHANGE	15
#define PRINTSTRING	100
#define IBMFLAGS	101
#define SIBMFLAG	102
#define BADCALL		200

/* status returns */
#define FDCSUCCESS	0
#define FDCTIMOUT	1
#define FDCFAIL		2
#define LINERR		3
 
/* IBM debugging flags */
#define FLAG0		0
#define FLAG1		1

/* FLAG0 */
#define WATCHPKTS	0x80
#define D_RAWMSG	0x40
#define D_LOGIN		0x20
#define D_LOGOUT	0x10
#define D_WTDOR		0x08
#define D_WTDMA		0x04
#define D_WTFDC		0x02
#define D_RDFDC		0x01
/* FLAG1 */
#define D_TESTINT	0x80
#define D_WTDBF		0x40
#define D_RDDBF		0x20
#define WATCHINT	0x10
#define WATCHPORT	0x08
#define PAUSE	        0x04
#define ALL		0xff
/*****************************************************************************
 * FDC interface command identifiers
 *****************************************************************************
 */
#define RDDATA		6
#define RDDELDATA	0xc
#define WTDATA		5
#define WTDELDATA	9
#define RDTRACK		2
#define RDID		0xa
#define FMTTRACK	0xd
#define SCANEQ		0x11
#define SCANLE		0x19
#define SCANHE		0x1d
#define RECAL		7
#define SENSINT		8
#define SPECIFY		3
#define SENSDRIVE	4
#define SEEK		0xf
#define MOTORON		0x12
#define MOTOROFF	0x13
#define SLEEP		0x14
#define DRVRESET	0x15

/* vpc gfi error codes
 */
#define LOGICAL		1
#define PROTOCOL	2
/****************************************************************************
 * I/O ports
 **************************************************************************** 
 * Floppy Disk Controller (8257A)
 */
#define FDC_MAIN_STATUS_REG  	(unsigned short) 0x3F4
#define FDC_DATA_REG	   	(unsigned short) 0x3F5

/* DMA controller (8237A)
 */
#define DMA_INTERNAL_FFLOP  	(unsigned short) 0xC
#define DMA_MODE_REG	  	(unsigned short) 0xB
#define DMA_BASADDR_CHAN2	(unsigned short) 0x4
#define DMA_COUNT_CHAN2	  	(unsigned short) 0x5	/* base addr + word cnt reg (wt) */
#define DMA_MASK_REG	  	(unsigned short) 0xA

/* DMA page register (channel 2)
 */
#define PAGE_REG_CHAN2	  	(unsigned short) 0x81

/* Digital Output Register
 */
#define DOR_PORT	  	(unsigned short) 0x3F2
/* *************************************************************************
 * FDC defines
 ***************************************************************************
 */
#define FDC_TO_CPU		(short) 0x40	/* DIO on  */
#define CPU_TO_FDC		(short) 0x00	/* DIO off */
#define DIO_MASK		(short) 0x40	/* mask to get DIO from main stat.reg */
#define RQM_MASK		(short) 0x80	/* mask to get RQM from main stat reg */
#define CB_MASK			(short) 0x10	/* mask to get CB  from main stat reg */
/***************************************************************************
 * DMA defines
 ***************************************************************************
 */
#define MEM_TO_FDC		(short) 1
#define FDC_TO_MEM		(short) 0
#define RDMODE			(unsigned char ) 0x4a
#define WTMODE			(unsigned char ) 0x46
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfiempty.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Empty definitions
 *
 * Description	: "Empty" functions declarations for GFI
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)gfiempty.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void gfi_empty_init(int);
extern int gfi_empty_command(FDC_CMD_BLOCK *, FDC_RESULT_BLOCK *);
extern int gfi_empty_drive_on(int);
extern int gfi_empty_drive_off(int);
extern int gfi_empty_reset(FDC_RESULT_BLOCK *);
extern int gfi_empty_high(int, half_word);
extern int gfi_empty_low(int);
extern int gfi_empty_drive_type(int);
extern int gfi_empty_change(int);

#else
extern void gfi_empty_init();
extern int gfi_empty_command();
extern int gfi_empty_drive_on();
extern int gfi_empty_drive_off();
extern int gfi_empty_reset();
extern int gfi_empty_high();
extern int gfi_empty_low();
extern int gfi_empty_drive_type();
extern int gfi_empty_change();
#endif /* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\getptis.h ===
{ 0 , " CopierActionCopyZero "},
{ 1 , " CopierActionCopyOne "},
{ 2 , " CopierActionCopyTwo "},
{ 3 , " CopierActionCopyThree "},
{ 4 , " CopierActionCopyFour "},
{ 5 , " CopierActionCopyFive "},
{ 6 , " CopierActionCopySix "},
{ 7 , " CopierActionCopyVariable "},
{ 8 , " CopierActionPatchJcond "},
{ 9 , " CopierActionBackoverMarker "},
{ 10 , " CopierActionSubrId "},
{ 11 , " CopierActionNpxExceptionData "},
{ 12 , " CopierActionNeedNextIntelEip "},
{ 13 , " CopierActionTupleImm "},
{ 14 , " CopierActionTupleDisp "},
{ 15 , " CopierActionTupleImm2 "},
{ 16 , " CopierActionTupleRetEIP "},
{ 17 , " CopierActionTearOffFlags "},
{ 18 , " CopierActionSetsFt "},
{ 19 , " CopierActionTrackFt "},
{ 20 , " CopierActionSrcFt "},
{ 21 , " CopierNoteSrcEAX "},
{ 22 , " CopierNoteSrcAX "},
{ 23 , " CopierNoteDstEAX "},
{ 24 , " CopierNoteDstAX "},
{ 25 , " CopierNoteDstAL "},
{ 26 , " CopierNoteSrcEBX "},
{ 27 , " CopierNoteSrcBX "},
{ 28 , " CopierNoteDstEBX "},
{ 29 , " CopierNoteDstBX "},
{ 30 , " CopierNoteDstBL "},
{ 31 , " CopierNoteSrcECX "},
{ 32 , " CopierNoteSrcCX "},
{ 33 , " CopierNoteDstECX "},
{ 34 , " CopierNoteDstCX "},
{ 35 , " CopierNoteDstCL "},
{ 36 , " CopierNoteSrcEDX "},
{ 37 , " CopierNoteSrcDX "},
{ 38 , " CopierNoteDstEDX "},
{ 39 , " CopierNoteDstDX "},
{ 40 , " CopierNoteDstDL "},
{ 41 , " CopierNoteSrcEBP "},
{ 42 , " CopierNoteDstEBP "},
{ 43 , " CopierNoteDstBP "},
{ 44 , " CopierNoteSrcEDI "},
{ 45 , " CopierNoteDstEDI "},
{ 46 , " CopierNoteDstDI "},
{ 47 , " CopierNoteSrcESI "},
{ 48 , " CopierNoteDstESI "},
{ 49 , " CopierNoteDstSI "},
{ 50 , " CopierNoteAddConstraintEAX "},
{ 51 , " CopierNoteRemoveConstraintEAX "},
{ 52 , " CopierNoteAddConstraintAX "},
{ 53 , " CopierNoteRemoveConstraintAX "},
{ 54 , " CopierNoteAddConstraintEBX "},
{ 55 , " CopierNoteRemoveConstraintEBX "},
{ 56 , " CopierNoteAddConstraintBX "},
{ 57 , " CopierNoteRemoveConstraintBX "},
{ 58 , " CopierNoteAddConstraintECX "},
{ 59 , " CopierNoteRemoveConstraintECX "},
{ 60 , " CopierNoteAddConstraintCX "},
{ 61 , " CopierNoteRemoveConstraintCX "},
{ 62 , " CopierNoteAddConstraintEDX "},
{ 63 , " CopierNoteRemoveConstraintEDX "},
{ 64 , " CopierNoteAddConstraintDX "},
{ 65 , " CopierNoteRemoveConstraintDX "},
{ 66 , " CopierNoteAddSingleInstruction "},
{ 67 , " CopierNoteProcessSingleInstruction "},
{ 68 , " CopierNoteSrcESP "},
{ 69 , " UnusedCopierNoteSrcSP "},
{ 70 , " CopierNotePostDstSP "},
{ 71 , " CopierNotePostDstESP "},
{ 72 , " CopierNotePostCommitPop "},
{ 73 , " CopierNoteHspTrackAbs "},
{ 74 , " CopierNoteHspTrackOpnd "},
{ 75 , " CopierNoteHspTrackReset "},
{ 76 , " CopierNoteHspAdjust "},
{ 77 , " CopierNotePigSynch "},
{ 78 , " CopierNoteMissPigSynch "},
{ 79 , " CopierNoteSrcUniverse "},
{ 80 , " CopierNoteSetDF "},
{ 81 , " CopierNoteClearDF "},
{ 82 , " CopierNoteBPILabel "},
{ 83 , " CopierActionLast "},
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfitest.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Test definitions
 *
 * Description	: Test functions declarations for GFI
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)gfitest.h	1.4 10/29/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT int gfi_test_command IPT2(FDC_CMD_BLOCK *, command_block,
	FDC_RESULT_BLOCK *, result_block);
IMPORT int gfi_test_drive_on IPT1(int, drive);
IMPORT int gfi_test_drive_off IPT1(int, drive);
IMPORT int gfi_test_high IPT1(int, drive);
IMPORT int gfi_test_drive_type IPT1(int, drive);
IMPORT int gfi_test_change IPT1(int, drive);
IMPORT int gfi_test_reset IPT1(FDC_RESULT_BLOCK *, result_block);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfx_upd.h ===
/*[
	Name:		gfx_upd.h
	Derived From:	Unknown
	Author:		Unknown
	Created On:	Unknown
	Sccs ID:	@(#)gfx_upd.h	1.27 07/09/93
	Purpose:	Unknown

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * PC palette structure.
 */
typedef struct
{
	half_word red; 		/* max = 0xff */
	half_word green;	/* max = 0xff */
	half_word blue; 	/* max = 0xff */
} PC_palette;


typedef boolean (*T_mark_byte) IPT1(int, off_in);
typedef boolean (*T_mark_word) IPT1(int, addr);
typedef boolean (*T_mark_fill) IPT2(int, laddr, int, haddr);
typedef boolean (*T_mark_wfill) IPT3(int, laddr, int, haddr, int, col);
typedef boolean (*T_mark_string)  IPT2(int, laddr, int, haddr);
typedef void    (*T_calc_update) IPT0();
typedef boolean (*T_scroll_up) IPT6(int, start, int, width, int, height, int, attr, int, nlines,int,dummy);
typedef boolean (*T_scroll_down) IPT6(int, start, int, width, int, height, int, attr, int, nlines,int,dummy);

typedef struct
{
	T_mark_byte mark_byte;	/* handle byte written to regenmemory */
	T_mark_word mark_word;
	T_mark_fill mark_fill;
	T_mark_wfill mark_wfill;
	T_mark_string mark_string;
	T_calc_update calc_update;
	T_scroll_up scroll_up;
	T_scroll_down scroll_down;
} UPDATE_ALG;
 
/* BCN 864 */
/* moved from gfx_update.c so other people can use it */
typedef	struct	{
	int	line_no;
	int	start;
	int	end;
	long	video_copy_offset;
#ifndef NEC_98
#ifdef VGG
	int	v7frig; /* for those annoying V7 (and undocumented VGA) modes */
			  /* with chars_per_line not a multiple of 4 */
#endif /* VGG */
#endif  // !NEC_98
} DIRTY_PARTS;

#if defined(NEC_98)
typedef struct{
        unsigned short  *codeadr ;      /* line top address TVRAM code          */
        unsigned short  *attradr ;      /* line top address TVRAM attribute */
}       STRC_COMP_LINE ;
#endif  // NEC_98

typedef enum {
#if defined(NEC_98)
        NEC98_TEXT_40,
        NEC98_TEXT_80,
        NEC98_TEXT_20L,
        NEC98_TEXT_25L,
        NEC98_GRAPH_200,
        NEC98_GRAPH_400,
        NEC98_T20L_G200,
        NEC98_T25L_G200,
        NEC98_T20L_G400,
        NEC98_T25L_G400,
        NEC98_GRAPH_200_SLT,
        NEC98_T20L_G200_SLT,
        NEC98_T25L_G200_SLT,
#endif  // NEC_98
        EGA_HI_SP,
        EGA_HI_SP_WR,
        EGA_MED_SP,
        EGA_MED_SP_WR,
        EGA_LO_SP,
        EGA_LO_SP_WR,
        EGA_HI,
        EGA_HI_WR,
        EGA_MED,
        EGA_MED_WR,
        EGA_LO,
        EGA_LO_WR,
        EGA_HI_FUN,
        EGA_MED_FUN,
        EGA_LO_FUN,
        EGA_TEXT_40,
        EGA_TEXT_40_WR,
        EGA_TEXT_40_SP,
        EGA_TEXT_40_SP_WR,
        CGA_TEXT_40,
        CGA_TEXT_40_WR,
        CGA_TEXT_40_SP,
        CGA_TEXT_40_SP_WR,
        TEXT_40_FUN,
        EGA_TEXT_80,
        EGA_TEXT_80_WR,
        EGA_TEXT_80_SP,
        EGA_TEXT_80_SP_WR,
        CGA_TEXT_80,
        CGA_TEXT_80_WR,
        CGA_TEXT_80_SP,
        CGA_TEXT_80_SP_WR,
        TEXT_80_FUN,
        CGA_HI,
        CGA_HI_FUN,
        CGA_MED,
        CGA_MED_FUN,
        DUMMY_FUN
} DISPLAY_MODE;


typedef struct
{
#if defined(NEC_98)
        void (*init_screen)(void);
#else   // !NEC_98
	void (*init_screen) IPT0();
#endif  // !NEC_98
	void (*init_adaptor) IPT2(int,arg1, int,arg2);
	void (*change_mode) IPT0();
	void (*set_screen_scale) IPT1(int,arg1);
	void (*set_palette) IPT2(PC_palette *,arg1, int,arg2);
	void (*set_border) IPT1(int,arg1);
	void (*clr_screen) IPT0();
	void (*flush_screen) IPT0();
	void (*mark_refresh) IPT0();
	void (*graphics_tick) IPT0();
	void (*start_update) IPT0();
	void (*end_update) IPT0();
	boolean (*scroll_up) IPT6(int, start, int, width, int, height,
					int, attr, int, nlines,int,dummy);
	boolean (*scroll_down) IPT6(int,arg1,int,arg2,int,arg3,int,arg4,int,
						arg5,int,arg6);
	void (*paint_cursor) IPT3(int,arg1, int,arg2, half_word,arg3);
#ifdef GISP_SVGA 
	void (*hide_cursor) IPT3(int,arg1, int,arg2, half_word,arg3);
#endif		/* GISP_SVGA */
#ifdef EGG
	void (*set_paint) IPT2(DISPLAY_MODE,arg1, int,arg2);
	void (*change_plane_mask) IPT1(int,arg1);
	void (*update_fonts) IPT0();
	void (*select_fonts) IPT2(int,arg1, int,arg2);
	void (*free_font) IPT1(int,arg1);
#endif
	void (*mode_select_changed) IPT1(int,arg1);
	void (*color_select_changed) IPT1(int,arg1);
	void (*screen_address_changed) IPT2(int,arg1, int,arg2);
	void (*cursor_size_changed) IPT2(int,arg1, int,arg2);	
	void (*scroll_complete) IPT0();	
} VIDEOFUNCS;

extern VIDEOFUNCS *working_video_funcs;

#if defined(NEC_98)
#ifndef NEC98VRAM
#define NEC98VRAM
typedef struct  {
        unsigned short  code;
        unsigned char           attr;
}       NEC98_VRAM_COPY;
#endif
#endif  // NEC_98

#define host_init_screen()\
	(working_video_funcs->init_screen)()
#define host_init_adaptor(ad,ht)\
	(working_video_funcs->init_adaptor)(ad,ht)
#define host_change_mode()\
	(working_video_funcs->change_mode)()
#define host_set_screen_scale(sz)\
	(working_video_funcs->set_screen_scale)(sz)
#define host_set_palette(pltt,sz)\
	(working_video_funcs->set_palette)(pltt,sz)
#define host_set_border_colour(col)\
	(working_video_funcs->set_border)(col)
#define host_clear_screen()\
	(working_video_funcs->clr_screen)()
#define host_flush_screen()\
	(working_video_funcs->flush_screen)()
#define host_mark_screen_refresh()\
	(working_video_funcs->mark_refresh)()
#define host_graphics_tick()\
	(working_video_funcs->graphics_tick)()
#define host_start_update()\
	(working_video_funcs->start_update)()
#define host_end_update()\
	(working_video_funcs->end_update)()
#define host_scroll_up(l,t,r,b,a,c)\
	(working_video_funcs->scroll_up)(l,t,r,b,a,c)
#define host_scroll_down(l,t,r,b,a,c)\
	(working_video_funcs->scroll_down)(l,t,r,b,a,c)
#define host_paint_cursor(x,y,attr)\
	(working_video_funcs->paint_cursor)(x,y,attr)
#ifdef GISP_SVGA
#define host_hide_cursor(x,y,attr)\
	(working_video_funcs->hide_cursor)(x,y,attr)
#endif		/* GISP_SVGA */
#ifdef EGG
#define host_set_paint_routine(mode,ht)\
	(working_video_funcs->set_paint)(mode,ht)
#define host_change_plane_mask(mode)\
	(working_video_funcs->change_plane_mask)(mode)
#define host_update_fonts()\
	(working_video_funcs->update_fonts)()
#define host_select_fonts(f1,f2)\
	(working_video_funcs->select_fonts)(f1,f2)
#define host_free_font(ind)\
	(working_video_funcs->free_font)(ind)
#endif /* EGG */

/* Overrideable in host defs if not desired */
#ifndef host_mode_select_changed
#define host_mode_select_changed(m)\
	(working_video_funcs->mode_select_changed)(m)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_color_select_changed
#define host_color_select_changed(c)\
	(working_video_funcs->color_select_changed)(c)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_screen_address_changed
#define host_screen_address_changed(start,end)\
	(working_video_funcs->screen_address_changed)(start,end)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_cursor_size_changed
#define host_cursor_size_changed(hi, lo)\
	(working_video_funcs->cursor_size_changed)(hi, lo)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_scroll_complete
#define host_scroll_complete()\
	(working_video_funcs->scroll_complete)()
#endif

/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"

extern void (*paint_screen)();	/* ptr to host routine to paint screen	*/
#ifdef V7VGA
extern void (*paint_v7ptr)();	/* ptr to host routine to paint V7 h/w pointer	*/
extern void (*clear_v7ptr)();	/* ptr to host routine to clear V7 h/w pointer	*/
#endif /* V7VGA */

extern UPDATE_ALG update_alg;
#if defined(NEC_98)
extern NEC98_VRAM_COPY *video_copy;
#else  // !NEC_98
extern byte *video_copy;
#endif // !NEC_98
extern MEM_HANDLERS vid_handlers;

extern boolean text_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean text_scroll_down IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean cga_text_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean cga_text_scroll_down IPT6(int, start, int, width,
	int, height, int, attr, int, nlines,int,dummy);
extern boolean cga_graph_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines, int, colour);
extern boolean cga_graph_scroll_down IPT6(int, start, int, width,
	int, height, int, attr, int, nlines, int, colour);

extern  void	dummy_calc IPT0();
extern	void	text_update IPT0();
#if defined(NEC_98)
IMPORT  void    NEC98_text_update(void);
#endif  // NEC_98

extern	void	cga_med_graph_update IPT0();
extern	void	cga_hi_graph_update IPT0();

extern	void	ega_text_update IPT0();
extern	void	ega_wrap_text_update IPT0();
extern	void	ega_split_text_update IPT0();
extern	void	ega_wrap_split_text_update IPT0();

extern	void	ega_graph_update IPT0();
extern	void	ega_wrap_graph_update IPT0();
extern	void	ega_split_graph_update IPT0();
extern	void	ega_wrap_split_graph_update IPT0();

extern	void	vga_graph_update IPT0();
extern	void	vga_split_graph_update IPT0();

#if defined(HERC)
extern  void	herc_update_screen IPT0();
#endif

extern	boolean	dummy_scroll IPT6(int,dummy1,int,dummy2,int,dummy3,
				int,dummy4,int,dummy5,int,dummy6);
extern	void	bios_has_moved_cursor IPT2(int,arg1, int,arg2);
extern	void	base_cursor_shape_changed IPT0();
extern	void	host_cga_cursor_has_moved IPT2(int,arg1, int,arg2);
extern	void	screen_refresh_required IPT0();

extern	void	host_ega_cursor_has_moved IPT2(int,arg1, int,arg2);
extern	void	flag_mode_change_required IPT0();
extern  void    reset_graphics_routines IPT0();
extern	void	reset_paint_routines IPT0();

// STREAM_IO codes are disabled on NEC_98 machines, enabled on others.
#ifndef NEC_98
#ifdef NTVDM
IMPORT  void    stream_io_update(void);
#endif
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gfi.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface level definitions
 *
 * Description	: Data structures for GFI
 *
 * Author	: Henry Nash + various others
 *
 */

/*
   static char SccsID[]="@(#)gfi.h	1.12 04/08/93 Copyright Insignia Solutions Ltd.";
 */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#define MAX_COMMAND_LEN		9	/* max number of command bytes */
#define MAX_RESULT_LEN		7	/* max number of result bytes */

typedef unsigned char FDC_CMD_BLOCK;
typedef unsigned char FDC_RESULT_BLOCK;


/* START: FDC COMMAND BLOCK DEFINITIONS >>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*
 * A simple access to the command type and drive
 */

/* the command itself	     */
#define get_type_cmd(ptr) (ptr[0] & 0x1f)
#define put_type_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* ...and the drive no	     */
#define get_type_drive(ptr) (ptr[1] & 0x3)
#define put_type_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 0 - read data, read deleted data, all scans
 */

/* multi-track		     */
#define get_c0_MT(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c0_MT(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c0_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c0_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* skip data 		     */
#define get_c0_skip(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c0_skip(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c0_cmd(ptr) (ptr[0] & 0x1f)
#define put_c0_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c0_pad(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c0_pad(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c0_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c0_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c0_drive(ptr) (ptr[1] & 0x3)
#define put_c0_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c0_cyl(ptr) ptr[2]
#define put_c0_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c0_hd(ptr) ptr[3]
#define put_c0_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c0_sector(ptr) ptr[4]
#define put_c0_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c0_N(ptr) ptr[5]
#define put_c0_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c0_EOT(ptr) ptr[6]
#define put_c0_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c0_GPL(ptr) ptr[7]
#define put_c0_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c0_DTL(ptr) ptr[8]
#define put_c0_DTL(ptr,val) ptr[8] = val

/*
 * Class 1 - write data, write deleted data
 */

/* multi-track		     */
#define get_c1_MT(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c1_MT(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c1_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c1_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c1_pad(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c1_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c1_cmd(ptr) (ptr[0] & 0x1f)
#define put_c1_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c1_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c1_pad1(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c1_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c1_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c1_drive(ptr) (ptr[1] & 0x3)
#define put_c1_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c1_cyl(ptr) ptr[2]
#define put_c1_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c1_hd(ptr) ptr[3]
#define put_c1_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c1_sector(ptr) ptr[4]
#define put_c1_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c1_N(ptr) ptr[5]
#define put_c1_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c1_EOT(ptr) ptr[6]
#define put_c1_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c1_GPL(ptr) ptr[7]
#define put_c1_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c1_DTL(ptr) ptr[8]
#define put_c1_DTL(ptr,val) ptr[8] = val

/*
 * Class 2 - read a track
 */

/* always 1 - FM not used    */
#define get_c2_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c2_MFM(ptr,val) ptr[0] = (ptr[0] & ~0x40) | ((val << 6) & 0x40)
/* skip data 		     */
#define get_c2_skip(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c2_skip(ptr,val) ptr[0] = (ptr[0] & ~0x20) | ((val << 5) & 0x20)
/* the command itself 	     */
#define get_c2_cmd(ptr) (ptr[0] & 0x1f)
#define put_c2_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* padding */
/* padding */
#define get_c2_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c2_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c2_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c2_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c2_drive(ptr) (ptr[1] & 0x3)
#define put_c2_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c2_cyl(ptr) ptr[2]
#define put_c2_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c2_hd(ptr) ptr[3]
#define put_c2_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c2_sector(ptr) ptr[4]
#define put_c2_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c2_N(ptr) ptr[5]
#define put_c2_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c2_EOT(ptr) ptr[6]
#define put_c2_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c2_GPL(ptr) ptr[7]
#define put_c2_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c2_DTL(ptr) ptr[8]
#define put_c2_DTL(ptr,val) ptr[8] = val

/*
 * Class 3 - format a track
 */

/* padding */
#define get_c3_pad(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c3_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c3_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c3_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c3_pad1(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c3_pad1(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c3_cmd(ptr) (ptr[0] & 0x1f)
#define put_c3_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c3_pad2(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c3_pad2(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c3_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c3_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c3_drive(ptr) (ptr[1] & 0x3)
#define put_c3_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* encoded bytes per sector  */
#define get_c3_N(ptr) ptr[2]
#define put_c3_N(ptr,val) ptr[2] = val
/* sectors per cylinder      */
#define get_c3_SC(ptr) ptr[3]
#define put_c3_SC(ptr,val) ptr[3] = val
/* gap length 		     */
#define get_c3_GPL(ptr) ptr[4]
#define put_c3_GPL(ptr,val) ptr[4] = val
/* filler byte		     */
#define get_c3_filler(ptr) ptr[5]
#define put_c3_filler(ptr,val) ptr[5] = val

/*
 * Class 4 - read ID
 */

/* padding */
#define get_c4_pad(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c4_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c4_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c4_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c4_pad1(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c4_pad1(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c4_cmd(ptr) (ptr[0] & 0x1f)
#define put_c4_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c4_pad2(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c4_pad2(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c4_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c4_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c4_drive(ptr) (ptr[1] & 0x3)
#define put_c4_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 5 - recalibrate
 */

/* padding */
#define get_c5_pad(ptr) ((ptr[0] & 0xe0) >> 5)
#define put_c5_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xe0) | ((val << 5) & 0xe0))
/* the command itself 	     */
#define get_c5_cmd(ptr) (ptr[0] & 0x1f)
#define put_c5_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c5_pad1(ptr) ((ptr[1] & 0xfc) >> 2)
#define put_c5_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xfc) | ((val << 2) & 0xfc))
/* drive unit */
#define get_c5_drive(ptr) (ptr[1] & 0x3)
#define put_c5_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 6 - specify
 */

/* the command itself 	     */
#define get_c6_cmd(ptr) (ptr[0] & 0x1f)
#define put_c6_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* step rate time	     */
#define get_c6_SRT(ptr) ((ptr[1] & 0xf0) >> 4)
#define put_c6_SRT(ptr,val) ptr[1] = (ptr[1] & ~0xf0) | ((val << 4) & 0xf0)
/* head unload time	     */
#define get_c6_HUT(ptr) (ptr[1] & 0xf)
#define put_c6_HUT(ptr,val) ptr[1] = (ptr[1] & ~0xf) | ((val << 0) & 0xf)
/* head load time	     */
#define get_c6_HLT(ptr) ((ptr[2] & 0xfe) >> 1)
#define put_c6_HLT(ptr,val) ptr[2] = (ptr[2] & ~0xfe) | ((val << 1) & 0xfe)
/* non-dma mode - not supp.  */
#define get_c6_ND(ptr) (ptr[2] & 0x1)
#define put_c6_ND(ptr,val) ptr[2] = (unsigned char)((ptr[2] & ~0x1) | ((val << 0) & 0x1))

/*
 * Class 7 - sense drive status
 */

/* the command itself 	     */
#define get_c7_cmd(ptr) (ptr[0] & 0x1f)
#define put_c7_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* which head 		     */
#define get_c7_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c7_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c7_drive(ptr) (ptr[1] & 0x3)
#define put_c7_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 8 - seek
 */

/* padding */
#define get_c8_pad(ptr) ((ptr[0] & 0xe0) >> 5)
#define put_c8_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xe0) | ((val << 5) & 0xe0))
/* the command itself 	     */
#define get_c8_cmd(ptr) (ptr[0] & 0x1f)
#define put_c8_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c8_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c8_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c8_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c8_head(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x4) | ((val << 2) & 0x4))
/* drive unit */
#define get_c8_drive(ptr) (ptr[1] & 0x3)
#define put_c8_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* new cylinder no for seek  */
#define get_c8_new_cyl(ptr) ptr[2]
#define put_c8_new_cyl(ptr,val) ptr[2] = val

/* END:   FDC COMMAND BLOCK DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* START: FDC RESULT BLOCK DEFINITIONS >>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*
 * Class 0 - read/write data, read/write deleted data,
 *    	     all scans, read/format a track
 */

/* status register 0         */
#define get_r0_ST0(ptr) ptr[0]
#define put_r0_ST0(ptr,val) ptr[0] = val
/* status register 1         */
#define get_r0_ST1(ptr) ptr[1]
#define put_r0_ST1(ptr,val) ptr[1] = val
/* status register 2         */
#define get_r0_ST2(ptr) ptr[2]
#define put_r0_ST2(ptr,val) ptr[2] = val
/* cylinder number 	     */
#define get_r0_cyl(ptr) ptr[3]
#define put_r0_cyl(ptr,val) ptr[3] = val
/* head number 		     */
#define get_r0_head(ptr) ptr[4]
#define put_r0_head(ptr,val) ptr[4] = val
/* sector number 	     */
#define get_r0_sector(ptr) ptr[5]
#define put_r0_sector(ptr,val) ptr[5] = val
/* encoded bytes per sector if N == 0  */
#define get_r0_N(ptr) ptr[6]
#define put_r0_N(ptr,val) ptr[6] = val

/*
 * Class 1 - a split up way of looking at Status registers
 * ST0 to ST2.
 */

/* Termination code  */
#define get_r1_ST0_int_code(ptr) ((ptr[0] & 0xc0) >> 6)
#define put_r1_ST0_int_code(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xc0) | ((val << 6) & 0xc0))
/* End of seek cmd   */
#define get_r1_ST0_seek_end(ptr) ((ptr[0] & 0x20) >> 5)
#define put_r1_ST0_seek_end(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* Equipment fault   */
#define get_r1_ST0_equipment(ptr) ((ptr[0] & 0x10) >> 4)
#define put_r1_ST0_equipment(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x10) | ((val << 4) & 0x10))
/* Device not ready  */
#define get_r1_ST0_not_ready(ptr) ((ptr[0] & 0x8) >> 3)
#define put_r1_ST0_not_ready(ptr,val) ptr[0] = (ptr[0] & ~0x8) | ((val << 3) & 0x8)
/* State of head     */
#define get_r1_ST0_head_address(ptr) ((ptr[0] & 0x4) >> 2)
#define put_r1_ST0_head_address(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x4) | ((val << 2) & 0x4))
/* Which drive	     */
#define get_r1_ST0_unit(ptr) (ptr[0] & 0x3)
#define put_r1_ST0_unit(ptr,val) ptr[0] = (ptr[0] & ~0x3) | ((val << 0) & 0x3)
/* Access off end of cylinder 		*/
#define get_r1_ST1_end_of_cylinder(ptr) ((ptr[1] & 0x80) >> 7)
#define put_r1_ST1_end_of_cylinder(ptr,val) ptr[1] = (ptr[1] & ~0x80) | ((val << 7) & 0x80)
/* CRC error in data field/ID		*/
#define get_r1_ST1_data_error(ptr) ((ptr[1] & 0x20) >> 5)
#define put_r1_ST1_data_error(ptr,val) ptr[1] = (ptr[1] & ~0x20) | ((val << 5) & 0x20)
/* timeout of device */
#define get_r1_ST1_over_run(ptr) ((ptr[1] & 0x10) >> 4)
#define put_r1_ST1_over_run(ptr,val) ptr[1] = (ptr[1] & ~0x10) | ((val << 4) & 0x10)
/* sector not found  */
#define get_r1_ST1_no_data(ptr) ((ptr[1] & 0x4) >> 2)
#define put_r1_ST1_no_data(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x4) | ((val << 2) & 0x4))
/* write protected   */
#define get_r1_ST1_write_protected(ptr) ((ptr[1] & 0x2) >> 1)
#define put_r1_ST1_write_protected(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x2) | ((val << 1) & 0x2))
/* Cannot find adress mask/ID  		*/
#define get_r1_ST1_no_address_mark(ptr) (ptr[1] & 0x1)
#define put_r1_ST1_no_address_mark(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x1) | ((val << 0) & 0x1))
/* Deleted data found in Read/Scan	*/
#define get_r1_ST2_control_mark(ptr) ((ptr[2] & 0x40) >> 6)
#define put_r1_ST2_control_mark(ptr,val) ptr[2] = (ptr[2] & ~0x40) | ((val << 6) & 0x40)
/* CRC error in data field		*/
#define get_r1_ST2_data_field_error(ptr) ((ptr[2] & 0x20) >> 5)
#define put_r1_ST2_data_field_error(ptr,val) ptr[2] = (ptr[2] & ~0x20) | ((val << 5) & 0x20)
/* cylinder miss-match 			*/
#define get_r1_ST2_wrong_cyclinder(ptr) ((ptr[2] & 0x10) >> 4)
#define put_r1_ST2_wrong_cyclinder(ptr,val) ptr[2] = (ptr[2] & ~0x10) | ((val << 4) & 0x10)
/* Match found in scan      		*/
#define get_r1_ST2_scan_equal_hit(ptr) ((ptr[2] & 0x8) >> 3)
#define put_r1_ST2_scan_equal_hit(ptr,val) ptr[2] = (ptr[2] & ~0x8) | ((val << 3) & 0x8)
/* Sector not found during scan command */
#define get_r1_ST2_scan_not_satisfied(ptr) ((ptr[2] & 0x4) >> 2)
#define put_r1_ST2_scan_not_satisfied(ptr,val) ptr[2] = (ptr[2] & ~0x4) | ((val << 2) & 0x4)
/* Invalid cylinder found		*/
#define get_r1_ST2_bad_cylinder(ptr) ((ptr[2] & 0x2) >> 1)
#define put_r1_ST2_bad_cylinder(ptr,val) ptr[2] = (ptr[2] & ~0x2) | ((val << 1) & 0x2)
/* Missing Address mark			*/
#define get_r1_ST2_no_address_mark(ptr) (ptr[2] & 0x1)
#define put_r1_ST2_no_address_mark(ptr,val) ptr[2] = (ptr[2] & ~0x1) | ((val << 0) & 0x1)

/*
 * Class 2 - sense drive status
 */

/* Device fault      		*/
#define get_r2_ST3_fault(ptr) ((ptr[0] & 0x80) >> 7)
#define put_r2_ST3_fault(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* Write protected diskette	*/
#define get_r2_ST3_write_protected(ptr) ((ptr[0] & 0x40) >> 6)
#define put_r2_ST3_write_protected(ptr,val) ptr[0] = (ptr[0] & ~0x40) | ((val << 6) & 0x40)
/* Device is ready		*/
#define get_r2_ST3_ready(ptr) ((ptr[0] & 0x20) >> 5)
#define put_r2_ST3_ready(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* Track zero found		*/
#define get_r2_ST3_track_0(ptr) ((ptr[0] & 0x10) >> 4)
#define put_r2_ST3_track_0(ptr,val) ptr[0] = (ptr[0] & ~0x10) | ((val << 4) & 0x10)
/* Double sided diskette	*/
#define get_r2_ST3_two_sided(ptr) ((ptr[0] & 0x8) >> 3)
#define put_r2_ST3_two_sided(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x8) | ((val << 3) & 0x8))
/* Side address signal		*/
#define get_r2_ST3_head_address(ptr) ((ptr[0] & 0x4) >> 2)
#define put_r2_ST3_head_address(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x4) | ((val << 2) & 0x4))
/* Which unit is selected	*/
#define get_r2_ST3_unit(ptr) (ptr[0] & 0x3)
#define put_r2_ST3_unit(ptr,val) ptr[0] = (ptr[0] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 3 - sense interrupt status
 */

/* status register 0         */
#define get_r3_ST0(ptr) ptr[0]
#define put_r3_ST0(ptr,val) ptr[0] = val
/* present cylinder number   */
#define get_r3_PCN(ptr) ptr[1]
#define put_r3_PCN(ptr,val) ptr[1] = val

/*
 * Class 4 - invalid codes
 */

/* status register 0         */
#define get_r4_ST0(ptr) ptr[0]
#define put_r4_ST0(ptr,val) ptr[0] = val

/* END:   FDC RESULT BLOCK DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<< */


/*
 * An entry data structure that holds information describing the number of bytes
 * in the fdc command/result phases. The index is the fdc command code, see
 * the INTEL Application note on the 8272A for a full description.
 *
 * The "result_byte" is the number of bytes in the standard FDC result phase
 * while "gfi_result_byte" is the number of bytes in the pseudo result phase
 * used by GFI and its server modules (ie some commands that do not normally
 * have a result phase, use an implicit Sense Interrupt Status result phase).
 */

typedef struct {
		 half_word cmd_bytes;		/* number of command bytes */
		 half_word result_bytes;	/* number of result bytes  */
		 half_word gfi_result_bytes;	/* number of GFI result bytes  */
		 half_word cmd_class;		/* class of the command    */
		 half_word result_class;	/* class of the result     */
		 boolean   dma_required;	/* dma required ?	   */
		 boolean   int_required;	/* interrupts required ?   */
	       } FDC_DATA_ENTRY;


/*
 * The following list the error codes that the GFI commands (see gfi.f) can
 * return.  0 is considered to be success.
 */

#define GFI_PROTOCOL_ERROR	1
#define GFI_FDC_TIMEOUT		2
#define GFI_FDC_LOGICAL_ERROR	3

/*
 * GFI Drive types
 */

#define GFI_DRIVE_TYPE_NULL		0	/* unidentified */
#define GFI_DRIVE_TYPE_360		1	/* 360K 5.25" */
#define GFI_DRIVE_TYPE_12		2	/* 1.2M 5.25" */
#define GFI_DRIVE_TYPE_720		3	/* 720K 3.5" */
#define GFI_DRIVE_TYPE_144		4	/* 1.44M 3.5" */
#define	GFI_DRIVE_TYPE_288		5	/* 2.88M 3.5" */

#ifdef NTVDM
#define GFI_DRIVE_TYPE_MAX              6
#endif


/***************************************************************************
**
**      Definitions and prototypes for the gfi_function_table,
**  the functions therein, and the orthogonal floppy interface functions.
**  Using the typedef'd prototypes should make it much easier to avoid
**  definition clashes.
**	This is now the only base floppy header file, and if you use the
**  generic unix_flop.c module, the only floppy header anywhere. The generic
**  code is meant to help a new unix port get quick floppy support; it is
**  not meant to replace fancy host floppy code.
**	The improvements that I have made to the floppy system in general are
**  also supposed to make life easier.
**
**      GM.
****************************************************************************
**
**
**
** The GFI has a structure containing pointers to functions that provide
** the diskette support for all possible drives (0-1) and drive types.
**  Each floppy emmulator module has a function for loading this table
** with the module's own local functions which can then be used by the
** gfi system to emmulate the sort of device the module was designed for.
**
** 	This table (of two structures - one for each possible drive)
**  is of course GLOBAL.
**
** The structure has the following fields:
**
** The GFI command function:		GFI_FUNC_ENTRY.command_fn,
** The GFI drive on function:		GFI_FUNC_ENTRY.drive_on_fn,
** The GFI drive off function:		GFI_FUNC_ENTRY.drive_off_fn,
** The GFI reset function:		GFI_FUNC_ENTRY.reset_fn,
** The GFI set high density function:	GFI_FUNC_ENTRY.high_fn,
** The GFI drive type function:		GFI_FUNC_ENTRY.drive_type_fn,
** The GFI disk changed function:	GFI_FUNC_ENTRY.change_fn
**
**   Structure definition:
**  -----------------------
*/
typedef struct
{
	SHORT (*command_fn) IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
	SHORT (*drive_on_fn) IPT1( UTINY, drive );
	SHORT (*drive_off_fn) IPT1( UTINY, drive );
	SHORT (*reset_fn) IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
	SHORT (*high_fn) IPT2( UTINY, drive, half_word, n);
	SHORT (*drive_type_fn) IPT1( UTINY, drive );
	SHORT (*change_fn) IPT1( UTINY, drive );

} GFI_FUNCTION_ENTRY;

/*
** ============================================================================
** External declarations and macros
** ============================================================================
**
**
**
** The data structure describing the fdc command/result phases, and the
** function pointer table set up by calls to the individual init functions
** in each of the GFI server modules.
**
**
**
** 	These tables are in gfi.c
*/
	IMPORT GFI_FUNCTION_ENTRY gfi_function_table[];
	IMPORT FDC_DATA_ENTRY     gfi_fdc_description[];
/*
**	The following functions form the interface between the GFI system
**  and the floppy module (whichever). They are global, but the only access
**  to the other functions gfi needs is via the gfi_function_table.
*/

IMPORT SHORT host_gfi_rdiskette_valid
	IPT3(UTINY,hostID,ConfigValues *,vals,CHAR *,err);

IMPORT SHORT host_gfi_rdiskette_active
	IPT3(UTINY, hostID, BOOL, active, CHAR, *err);

IMPORT SHORT gfi_empty_active
	IPT3(UTINY, hostID, BOOL, active, CHAR, *err);

IMPORT VOID  host_gfi_rdiskette_change
	IPT2(UTINY, hostID, BOOL, apply);

#ifndef host_rflop_drive_type
/* new function to say what kind of drive we have
*/
IMPORT SHORT host_rflop_drive_type IPT2 (INT, fd, CHAR *, name);
#endif /* host_rflop_drive_type */

/*  The gfi global functions. These need to be global because they are the
** interface to the private host dependant floppy functions. Each one does
** little more than call the real function via the table.
*/
/* The gfi_reset is special; not the same as the other floppy inits because
** it is called from main() to startup the gfi system by making both drives
** 'empty'. This means that it has no drive parameter.
*/

IMPORT SHORT gfi_drive_on IPT1( UTINY, drive );
IMPORT SHORT gfi_drive_off IPT1( UTINY, drive );
IMPORT SHORT gfi_low IPT1( UTINY, drive );
IMPORT SHORT gfi_drive_type IPT1( UTINY, drive );
IMPORT SHORT gfi_change IPT1( UTINY, drive );
IMPORT VOID gfi_init IPT0();
IMPORT SHORT gfi_reset IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
IMPORT SHORT gfi_high IPT2( UTINY, drive, half_word, n);
IMPORT SHORT gfi_fdc_command IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gispsvga.h ===
/*[
 * File Name		: gispsvga.h
 *
 * Derived From		: Template
 *
 * Author		: Mike
 *
 * Creation Date	: Feb 94
 *
 * SCCS Version		: @(#)gispsvga.h	1.1 02/22/94
 *!
 * Purpose
 *	This file contains prototypes for global functions and variables that
 *	get declared when GISP_SVGA is defined, and that don't use types
 *	defined in HostHwVgaH.  Those prototypes that do are in hwvga.h.
 *
 *	Well that's the theory.  Unfortunately almost all the prototypes
 *	are actually stil in hwvga.h, but should move here eventually!
 *
 *! (c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
]*/

#ifdef GISP_SVGA

extern void romMessageAddress IPT0( );
extern void gispROMInit IPT0( );


#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ggdc.h ===
#if defined(NEC_98)
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::    NEC98 Graphic Emulation Header    :::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


/*--------------------    MODE FF2 PORT ADDRESS      -------------------*/

#define MODE_FF2                        0x6A    /* mode FF2 PORT */

/*--------------------      G-GDC PORT ADDRESS      --------------------*/

#define GGDC_PARAMETER          0xA0    /* G-GDC PORT A0H */
#define GGDC_COMMAND            0xA2    /* G-GDC PORT A2H */

/*--------------------   VRAM SELECT PORT ADDRESS    -------------------*/

#define VRAM_DISPLAY            0xA4    /* displayed  bank select reg */
#define VRAM_DRAW                       0xA6    /* read/write bank select reg */

/*--------------------     PALETTE PORT ADDRESS     --------------------*/

#define PALETTE_A8                      0xA8    /* palette #3,#7( 8 colors) */
                                                                        /* palette index(16 colors) */
#define PALETTE_AA                      0xAA    /* palette #2,#6( 8 colors) */
                                    /* palette green(16 colors) */
#define PALETTE_AC                      0xAC    /* palette #1,#5( 8 colors) */
                                    /* palette red  (16 colors) */
#define PALETTE_AE                      0xAE    /* palette #0,#4( 8 colors) */
                                    /* palette blue (16 colors) */

/*--------------------      GRCG PORT ADDRESS      ---------------------*/

#define GRCG_MODE                       0x7C    /* GRCG mode reg */
#define GRCG_TILE                       0x7E    /* GRCG tile reg */

/*--------------------      EGC PORT ADDRESS       ---------------------*/

#define EGC_ACTIVE                      0x4A0   /* EGC active           reg     */
#define EGC_MODE                        0x4A2   /* EGC mode             reg     */
#define EGC_ROP                         0x4A4   /* EGC rastorop         reg     */
#define EGC_FORE                        0x4A6   /* EGC fore color       reg     */
#define EGC_MASK                        0x4A8   /* EGC mask                     reg */
#define EGC_BACK                        0x4AA   /* EGC back color       reg     */
#define EGC_BITAD                       0x4AC   /* EGC bit address      reg     */
#define EGC_LENGTH                      0x4AE   /* EGC bit length       reg */

/*--------------------      GGDC COMMAND SET       ---------------------*/

#define GGDC_RESET1                     0x00    
#define GGDC_RESET2                     0x01    
#define GGDC_RESET3                     0x09    
#define GGDC_SYNC_OFF           0x0E    
#define GGDC_SYNC_ON            0x0F    
#define GGDC_SLAVE                      0x6E    
#define GGDC_MASTER                     0x6F    
#define GGDC_START1                     0x6B    
#define GGDC_START2                     0x0D    
#define GGDC_STOP1                      0x05    
#define GGDC_STOP2                      0x0C    
#define GGDC_ZOOM                       0x46    
#define GGDC_SCROLL1            0x70    
#define GGDC_SCROLL2            0x71    
#define GGDC_SCROLL3            0x72    
#define GGDC_SCROLL4            0x73    
#define GGDC_SCROLL5            0x74    
#define GGDC_SCROLL6            0x75    
#define GGDC_SCROLL7            0x76    
#define GGDC_SCROLL8            0x77    
#define GGDC_CSRFORM            0x4B    
#define GGDC_PITCH                      0x47    
#define GGDC_LPEN                       0xC0    
#define GGDC_VECTW                      0x4C    
#define GGDC_VECTE                      0x6C    
#define GGDC_TEXTW1                     0x78    
#define GGDC_TEXTW2                     0x79    
#define GGDC_TEXTW3                     0x7A    
#define GGDC_TEXTW4                     0x7B    
#define GGDC_TEXTW5                     0x7C    
#define GGDC_TEXTW6                     0x7D    
#define GGDC_TEXTW7                     0x7E    
#define GGDC_TEXTW8                     0x7F    
#define GGDC_TEXTE                      0x68    
#define GGDC_CSRW                       0x49    
#define GGDC_CSRR                       0xE0    
#define GGDC_MASK                       0x4A    
#define GGDC_WRITE1                     0x20    
#define GGDC_WRITE2                     0x21    
#define GGDC_WRITE3                     0x22    
#define GGDC_WRITE4                     0x23    
#define GGDC_WRITE5                     0x28    
#define GGDC_WRITE6                     0x29    
#define GGDC_WRITE7                     0x2A    
#define GGDC_WRITE8                     0x2B    
#define GGDC_WRITE9                     0x30    
#define GGDC_WRITE10            0x31    
#define GGDC_WRITE11            0x32    
#define GGDC_WRITE12            0x33    
#define GGDC_WRITE13            0x38    
#define GGDC_WRITE14            0x39    
#define GGDC_WRITE15            0x3A    
#define GGDC_WRITE16            0x3B    
#define GGDC_READ1                      0xA0    
#define GGDC_READ2                      0xA1    
#define GGDC_READ3                      0xA2    
#define GGDC_READ4                      0xA3    
#define GGDC_READ5                      0xA8    
#define GGDC_READ6                      0xA9    
#define GGDC_READ7                      0xAA    
#define GGDC_READ8                      0xAB    
#define GGDC_READ9                      0xB0    
#define GGDC_READ10                     0xB1    
#define GGDC_READ11                     0xB2    
#define GGDC_READ12                     0xB3    
#define GGDC_READ13                     0xB8    
#define GGDC_READ14                     0xB9    
#define GGDC_READ15                     0xBA    
#define GGDC_READ16                     0xBB    
#define GGDC_DMAW1                      0x24    
#define GGDC_DMAW2                      0x25    
#define GGDC_DMAW3                      0x26    
#define GGDC_DMAW4                      0x27    
#define GGDC_DMAW5                      0x2C    
#define GGDC_DMAW6                      0x2D    
#define GGDC_DMAW7                      0x2E    
#define GGDC_DMAW8                      0x2F    
#define GGDC_DMAW9                      0x34    
#define GGDC_DMAW10                     0x35    
#define GGDC_DMAW11                     0x36    
#define GGDC_DMAW12                     0x37    
#define GGDC_DMAW13                     0x3C    
#define GGDC_DMAW14                     0x3D    
#define GGDC_DMAW15                     0x3E    
#define GGDC_DMAW16                     0x3F    
#define GGDC_DMAR1                      0xA4    
#define GGDC_DMAR2                      0xA5    
#define GGDC_DMAR3                      0xA6    
#define GGDC_DMAR4                      0xA7    
#define GGDC_DMAR5                      0xAC    
#define GGDC_DMAR6                      0xAD    
#define GGDC_DMAR7                      0xAE    
#define GGDC_DMAR8                      0xAF    
#define GGDC_DMAR9                      0xB4    
#define GGDC_DMAR10                     0xB5    
#define GGDC_DMAR11                     0xB6    
#define GGDC_DMAR12                     0xB7    
#define GGDC_DMAR13                     0xBC    
#define GGDC_DMAR14                     0xBD    
#define GGDC_DMAR15                     0xBE    
#define GGDC_DMAR16                     0xBF    

#define DRAWING                         1
#define NOTDRAW                         0

/*---------------------     MODE FF2 DATA SET      ---------------------*/

#define FF2_COLORSEL            0
#define FF2_EGCEXT                      1
#define FF2_LCD1MODE            2
#define FF2_LCD2MODE            3
#define FF2_LSIINIT                     4
#define FF2_GDCCLOCK1           5
#define FF2_GDCCLOCK2           6
#define FF2_REGWRITE            7

#define FF2_8COLOR                      0x00
#define FF2_16COLOR                     0x01
#define FF2_DISENB                      0x06
#define FF2_ENABLE                      0x07
#define FF2_GRCG                        0x08
#define FF2_EGC                         0x09
#define FF2_GT1DOT                      0x40
#define FF2_GTEQ                        0x41
#define FF2_GR640                       0x42
#define FF2_GR641                       0x43
#define FF2_INIOFF                      0x80
#define FF2_INION                       0x81
#define FF2_GDC25                       0x82
#define FF2_GDC50                       0x83
#define FF2_GDC25_1                     0x82
#define FF2_GDC50_1                     0x83
#define FF2_GDC25_2                     0x84
#define FF2_GDC50_2                     0x85

/*---------------------   VRAM SELECT DATA SET     ---------------------*/

#define FORE_BANK                       0x00    /* NEC98 G-VRAM select fore */
#define BACK_BANK                       0x01    /* NEC98 G-VRAM select back */

/*------------------------   PALETTE DATA SET    -----------------------*/

#define WIN_PALB                        0               /* windows palette Blue    */
#define WIN_PALG                        1               /* windows palette Green   */
#define WIN_PALR                        2               /* windows palette Red     */
#define WIN_PALQ                        3               /* windows palette Reserve */

#define NEC98PALG                        0               /* NEC98 16 colors palette Green */
#define NEC98PALR                        1               /* NEC98 16 colors palette Red   */
#define NEC98PALB                        2               /* NEC98 16 colors palette Blue  */

/*-----------------      GRAPHIC GLOBAL STRUCTURE     ------------------*/

        /* use for( Window->HARDWARE_STATE structure-> FullScreen ) */

typedef struct{
        unsigned char   command         ;
        unsigned char   count           ;
        unsigned char   param[16]       ;
}       _STRC_NOW;

typedef struct{

        UCHAR           sync_param[8]           ;       /* save sync       parameter */
        UCHAR           zoom_param                      ;       /* save zoom       parameter */
        UCHAR           scroll_param[8]         ;       /* save scroll     parameter */
        UCHAR           csrform_param[3]        ;       /* save csrform    parameter */
        UCHAR           pitch_param                     ;       /* save pitch      parameter */
        UCHAR           vectw_param[11]         ;       /* save vectw      parameter */
        UCHAR           textw_param[8]          ;       /* save textw      parameter */
        UCHAR           csrw_param[3]           ;       /* save csrw       parameter */
        UCHAR           mask_param[2]           ;       /* save mask       parameter */
        UCHAR           write                           ;       /* save write      command   */
        UCHAR           start_stop                      ;       /* save start/stop command   */
        _STRC_NOW       ggdc_now                        ;       /* save gdc set    parameter */

} STRC_GGDC_GLOBALS;

typedef struct{

        UCHAR   pal_8_data[4]           ; /* save  8 colors mode palette data */
        UCHAR   pal_16_data[16][3]      ; /* save 16 colors mode palette data */
        UCHAR   pal_16_index            ; /* save last use palette index reg  */

} STRC_PALETTE_GLOBALS;


typedef struct{

        UCHAR   grcg_mode                       ; /* save GRCG MODE REGISTER            */
        UCHAR   grcg_count                      ; /* save GRCG TILE REG's position 	*/
        UCHAR   grcg_tile[4]            ; /* save GRCG TILE REGISTER            */

} STRC_GRCG_GLOBALS;

/* structure for EGC register  1994/03/25 */
/*                                 /03/29 */
typedef struct {                                                // 940325
        unsigned short Reg0;                                    // 940325
        unsigned short Reg1;                                    // 940325
        unsigned short Reg2;                                    // 940325
        unsigned short Reg3;                                    // 940325
        unsigned short Reg4;                                    // 940325
        unsigned short Reg5;                                    // 940325
        unsigned short Reg6;                                    // 940325
        unsigned short Reg7;                                    // 940325
        unsigned short Reg3fb;                                  // 940329
        unsigned short Reg5fb;                                  // 940329
} STRC_EGC_REGS;                                                // 940325


typedef struct{
        unsigned long   asm_vram        ; /* vram start address         4 bytes */
        unsigned long   asm_ead         ; /* gdc draw start address 4 bytes */
        unsigned long   asm_pitch       ; /* gdc next line                      4 bytes */
        unsigned long   asm_dir         ; /* gdc next move position     4 bytes */
        unsigned short  asm_dc          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d           ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d2          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d1          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_dm          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_ptn         ; /* gdc line pattern           2 bytes */
        unsigned short  asm_zoom        ; /* gdc zoom parameter         2 bytes */
        unsigned short  asm_sl          ; /* gdc graph char sline       2 bytes */
        unsigned short  asm_wg          ; /* gdc wg bit set                     2 bytes */
        unsigned short  asm_maskgdc     ; /* gdc mask for gdc 7-0       2 bytes */
        unsigned char   asm_txt[8]      ; /* gdc graph char data        8 bytes */
} GGDC_C_TO_ASM ;

typedef struct{
        unsigned long   lastead         ;
        unsigned short  lastdad         ;
        unsigned char   lastcsrr[5]     ;
} GGDC_CSRR_BACK ;

extern  DISPLAY_GLOBS                   NEC98Display ;
extern  STRC_GGDC_GLOBALS               ggdcglobs       ;
extern  STRC_PALETTE_GLOBALS    paletteglobs;
extern  STRC_GRCG_GLOBALS               grcgglobs       ;

extern STRC_EGC_REGS egc_regs;                  // EGC register 940325

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gisp_sas.h ===
/*[
 *
 *	File		:	gisp_sas.h
 *
 *	Derived from	:	next_sas.h
 *
 *	Purpose		:	gisp specific Roms offsets
 *				and Rom specific symbols etc.
 *
 *	Author		:	Rog
 *	Date		:	3 Feb 1993
 *
 *	SCCS id		:	@(#)gisp_sas.h	1.5 02/22/94
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifdef GISP_SVGA
#ifndef _GISP_SAS_H_
#define _GISP_SAS_H_

/* Offsets of our stuff into the ROMS */

/* from VGA.ASM */

#define INT10CODEFRAG_OFF	0x0400	/* Code frag to perform INT 10 */
#define FULLSCREENFLAG_OFFSET 	0x0410	/* Use host BIOS ? */
#define GISP_INT_10_ADDR_OFFSET	0x830	/* Int 10 moved to int 42 offset */
#define HOST_BIOS_ROUTINE	0x0821	/* JMP addr to patch */
#define HOST_INT_42_BIOS_ROUTINE	0x0841 /* Other JMP addr to patch :-) */


#ifdef IRET_HOOKS
/*
 *	The offset in bios1 of the BOP that returns us to the monitor.
 */

#define BIOS_IRET_HOOK_OFFSET	0x1c00
#endif /* IRET_HOOKS */


/* Data for the ROM moving stuff */

/* The address of the INT 10 entry point into the Host macines ROMS */

struct
HostVideoBiosEntrytag
{
		word	segment;
		word	offset;
} HostVideoBiosEntry , HostVideoBiosInt42Entry;

extern GLOBAL IBOOL LimBufferInUse IPT0();

#endif		/* _GISP_SAS_H_ */
#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gmi.h ===
/*
*
* Interface to gmi routines.
*
*/

/* static char SccsID[]="@(#)gmi.h	1.8 04/26/93 Copyright Insignia Solutions Ltd."; */
typedef enum 
{
	RAM,
	VIDEO,
	ROM,
	IN_FRAGMENT,
	NEXT_FRAGMENT
} mem_type;

typedef struct
{
	VOID	(*b_write)();
	VOID	(*w_write)();
	VOID	(*b_fill)();
	VOID	(*w_fill)();
	VOID	(*b_move)IPT4(UTINY *, laddr, UTINY *, haddr, UTINY *, src,
		 UTINY, src_type);
	VOID	(*w_move)();
} MEM_HANDLERS;

#ifndef UNIVERSAL	/* These are in host_cpu.h during a UNIVERSAL build. */

IMPORT	void	gmi_b_write IPT1(host_addr, intel_addr);
IMPORT	void	gmi_w_write IPT1(host_addr, intel_addr);
IMPORT	void	gmi_b_move IPT4(host_addr, intel_dest_start,
	host_addr, intel_dest_end, host_addr, intel_src, boolean, direction);
IMPORT	void	gmi_w_move IPT4(host_addr, intel_dest_start,
	host_addr, intel_dest_end, host_addr, intel_src, boolean, direction);
IMPORT	void	gmi_b_fill IPT2(host_addr, start, host_addr, end);
IMPORT	void	gmi_w_fill IPT2(host_addr, start, host_addr, end);
IMPORT	boolean	gmi_w_check IPT3(host_addr, laddr, host_addr, haddr,
	host_addr *, endaddr);
IMPORT	void	gmi_init IPT1(sys_addr, size);

#ifdef	CCPU
IMPORT	boolean	gmi_connect_mem IPT3(sys_addr, laddr, sys_addr, haddr,
	mem_type, type);
IMPORT	boolean	gmi_disconnect_mem IPT3(sys_addr, laddr,
	sys_addr, haddr, mem_type, type);
IMPORT	void	gmi_define_mem IPT2(mem_type, type, MEM_HANDLERS *, handlers);
#else	/* CCPU */
IMPORT	boolean	gmi_connect_mem	IPT3(host_addr, laddr, host_addr, haddr,
	mem_type, type);
IMPORT 	boolean	gmi_disconnect_mem IPT3(host_addr, laddr, host_addr, haddr,
	mem_type, type);
IMPORT	void	gmi_define_mem IPT2(mem_type, type, MEM_HANDLERS *, handlers);
#endif	/* CCPU */

#endif /* UNIVERSAL */

/*
 * defines for direction argument of gmi_x_move().
 * Has the same meaning as the INtel direction flag.
 */
#define FORWARDS 0
#define BACKWARDS 1

#ifdef EGATEST
#define gmi_redefine_mem(type,handlers) \
b_write_ptrs[(int)type] = handlers.b_write; \
w_write_ptrs[(int)type] = handlers.w_write; \
b_fill_ptrs[(int)type] = handlers.b_fill; \
w_fill_ptrs[(int)type] = handlers.w_fill; \
b_fwd_move_ptrs[(int)type] = handlers.b_move_fwd; \
b_bwd_move_ptrs[(int)type] = handlers.b_move_bwd; \
w_fwd_move_ptrs[(int)type] = handlers.w_move_fwd; \
w_bwd_move_ptrs[(int)type] = handlers.w_move_bwd; 
#else
#define gmi_redefine_mem(type,handlers) \
b_write_ptrs[(int)type] = handlers.b_write; \
w_write_ptrs[(int)type] = handlers.w_write; \
b_fill_ptrs[(int)type] = handlers.b_fill; \
w_fill_ptrs[(int)type] = handlers.w_fill; \
b_move_ptrs[(int)type] = handlers.b_move; \
w_move_ptrs[(int)type] = handlers.w_move; 
#endif /* EGATEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\harness.h ===
/*
*	MODULE:		harness.h
*
*	PURPOSE:	Some macros and typedefs etc for the test harness.
*				This file should be #included into the C file
*				which contains the function table.
*
*	AUTHOR:		Jason Proctor
*
*	DATE:		Fri Aug 11 1989
*/

/* SccsID[]="@(#)harness.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/* harness-wide system parameters */
#define MAXLINE	64
#define MAXFILE 16
#define MAXARGS	8

/* defines for standard C return types */
#define VOID	0
#define CHAR	1
#define SHORT	2
#define INT		3
#define LONG	4
#define HEX		5
#define LONGHEX	6
#define FLOAT	7
#define DOUBLE	8
#define STRPTR	9
#define BOOL	10
#define SYS		11

/* states for argument extraction subroutine */
#define NOTINQUOTE	0
#define INSQUOTE	1
#define INDQUOTE	2

/* typedef for master function table */
typedef struct
{
	char *func_name;			/* name of the function as a string */
	int nparams;				/* how many params it takes */
	int return_type;			/* what kind of animal it returns */
	int (*func) ();				/* pointer to 'glue' function */
	int arg_type1;				/* type of arg 1 */
	int arg_type2;				/* .... etc .... */
	int arg_type3;
	int arg_type4;
	int arg_type5;
	int arg_type6;
	int arg_type7;
	int arg_type8;
} Functable;

/* typedef for linked list of variables */
typedef struct Var_List
{
	struct Var_List *next;
	struct Var_List *prev;
	char *vname;
	char *value;
	int vsize;
} Varlist;

/* typedef for return code union */
/* can be reduced to just longs and doubles (I think) */
/* due to return codes being held in registers/globals etc */
typedef union
{
	int i;
	long l;
	char *p;
	float f;
	double d;
} Retcodes;

/* macros for return code bits to make life easier */
#define ret_char		retcode.i
#define ret_short		retcode.i
#define ret_int			retcode.i
#define ret_long		retcode.l
#define ret_hex			retcode.i
#define ret_longhex		retcode.l
#define ret_strptr		retcode.p
#define ret_bool		retcode.i
#define ret_sys			retcode.i

/* and these are treated as doubles */
#define ret_float		retcode.f
#define ret_double		retcode.d
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\haw.h ===
/*[
 *	Product:		SoftWindows Revision 2.0
 *
 *	Name:			haw.h
 *
 *	Derived From:	Original
 *
 *	Authors:		Rob Tizzard
 *
 *	Created On:		16th April 1994
 *
 *	Purpose:		All base/host definitions for the SoftWindows
 *				    host audio wave driver interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/


#ifdef SCCSID
static char SccsID[]="@(#)haw.h	1.2 12/20/94";
#endif

/* Standard device sample formats */

#define HAW_INVALIDFORMAT     0x00000000       /* invalid format */
#define HAW_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define HAW_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define HAW_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define HAW_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define HAW_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define HAW_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define HAW_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define HAW_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define HAW_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define HAW_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define HAW_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define HAW_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

#define HAW_NAME_LEN  32	/* Device name length */

typedef struct {
      IUM8 channels;  				 /* Number of output channels */
      IBOOL pitch_control;      	 /* If TRUE device has pitch control */
      IBOOL playbackrate_control;  	 /* If TRUE device has playback rate control */ 
      IBOOL volume_control;          /* If TRUE device has volume control */  
      IBOOL lr_volume_control;       /* If TRUE device has left & right volume control */  
      IBOOL synchronous;    		 /* If TRUE device plays sounds synchronously */        
	  IU32	formats;				 /* Standard output sample formats supported */
	  IU8	dev_name[HAW_NAME_LEN];  /* Name of waveform output device */
} HAWO_CAPS;

/*
 * -----------------------------------------------------------------------------
 * Host input capabilites.
 * -----------------------------------------------------------------------------
 */

typedef struct {
      IUM8  channels;   	         /* Number of input channels */
      IBOOL synchronous;             /* If TRUE device records sounds synchronously */
	  IU32	formats;				 /* Standard output sample formats supported */
	  IU8	dev_name[HAW_NAME_LEN];  /* Name of waveform input device */
} HAWI_CAPS;

/*
 * -----------------------------------------------------------------------------
 * Host audio position structure.
 * -----------------------------------------------------------------------------
 */
 
/* position_type field values */

#define HAW_POSN_MILLI_SEC    (IUM8)1
#define HAW_POSN_SAMPLE       (IUM8)2
#define HAW_POSN_BYTE_COUNT   (IUM8)3

typedef struct {

	IUM8 position_type;   
			            
	union {
		IU32 milli_sec;    /* HAW_POSN_MILLI_SEC in milliseconds */
	 	IU32 sample;       /* HAW_POSN_SAMPLE  in number of wave samples*/
	 	IU32 byte_count;   /* HAW_POSN_BYTE_COUNT  in number of wave samples*/
	} u;

} HAW_POSN;

/*
 * -----------------------------------------------------------------------------
 * Host audio formats.
 * -----------------------------------------------------------------------------
 */

#define HAW_PCM_NOCOMPRESS (IUM8)0 /* Pulse Code Modulated, uncompressed. */
 
/* Adaptive Pulse Code Modulated (ADPCM) */

#define HAW_ADPCM_2 (IUM8)1  /* ADPCM, 2:1 compression */
#define HAW_ADPCM_3 (IUM8)2  /* ADPCM, 3:1 compression */
#define HAW_ADPCM_4 (IUM8)3  /* ADPCM, 4:1 compression */


/*
 * -----------------------------------------------------------------------------
 * Host audio function return codes.
 * -----------------------------------------------------------------------------
 */

#define HAW_OK            (IUM8)0  /* Sucessfully completed function. */
#define HAW_NOTSUPPORTED  (IUM8)1  /* Feature not supported */
#define HAW_INVALID       (IUM8)1  /* Feature not supported */

/*
 * -----------------------------------------------------------------------------
 * Default pitch & playback rates for hosts which don't have the support.
 * -----------------------------------------------------------------------------
 */

#define HAW_DEF_PITCH    	(HAW_FIXPNT)  0x00010000 /* 1.0 */
#define HAW_DEF_PLAYBACK    (HAW_FIXPNT)  0x00010000 /* 1.0 */

/*
 * -----------------------------------------------------------------------------
 * Host channel values.
 * -----------------------------------------------------------------------------
 */

#define HAW_MONO		(IUM8) 1
#define HAW_STEREO		(IUM8) 2

/*
 * -----------------------------------------------------------------------------
 * Host audio loop control constants.
 * -----------------------------------------------------------------------------
 */

#define HAW_LOOP_START   (IUM8)1
#define HAW_LOOP_END     (IUM8)2

/*
 * -----------------------------------------------------------------------------
 * Host sample sizes.
 * -----------------------------------------------------------------------------
 */

#define	HAW_SAMPLE_8	 (IUM8)8
#define	HAW_SAMPLE_16	 (IUM8)16

/*
 * -----------------------------------------------------------------------------
 * Host Miscilanous Structures
 * -----------------------------------------------------------------------------
 */
 
typedef IU32 HAW_FIXPNT;		/* Fixed point */

typedef struct {
	LIN_ADDR	callbackData;	/* Call back data */
} HAW_CALLBACK;

/*
 * -----------------------------------------------------------------------------
 * Host audio wave function prototypes.
 * -----------------------------------------------------------------------------
 */
 
extern IUM8 hawo_num_devices IPT0();

extern void hawo_query_capabilities IPT2
   (
   IUM8, device,	   /* Output device */
   HAWO_CAPS, *pcaps   /* Pointer to output capabilities structure. */
   );

extern IUM8 hawo_query_format IPT5
   (
   IUM8, device,	    /* Output device */
   IUM8, channels,      /* channels required */
   IUM8, data_type,     /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,   /* Samples per second. */
   IUM8, sample_size    /* 8 or 16-bit data samples. */
   );

extern IUM8 hawo_open IPT5
   (
   IUM8, device,	   /* Output device */
   IUM8, channels,     /* channels required */
   IUM8, data_type,    /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,  /* Samples per second. */
   IUM8, sample_size   /* 8 or 16-bit data samples. */
   );

extern HAW_FIXPNT hawo_get_pitch IPT1
   (
   IUM8, device	    /* Output device */
   );

extern HAW_FIXPNT hawo_get_playback_rate IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IU32 hawo_get_def_volume IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IUM8 hawo_set_pitch IPT2
   (
   IUM8, device,	    /* Output device */
   HAW_FIXPNT, pitch    /* New pitch value */
   );

extern IUM8 hawo_set_playback_rate IPT2
   (
   IUM8, device,	            /* Output device */
   HAW_FIXPNT, playback_rate	/* New playback value */
   );

extern IUM8 hawo_set_volume IPT2
   (
   IUM8, device,	    /* Output device */
   IU32, volume			/* New volume value */
   );

extern void hawo_write IPT6
   (
   IUM8, device,	        /* Output device */
   LIN_ADDR, data_addr,		/* Intel memory Pointer to wave data */
   IU32, data_size,			/* Number of bytes of output data */
   IUM8, flags,				/* Flags controlling loop playback */
   IU32, loops,				/* Number of times to play loop */
   HAW_CALLBACK *, hawo_callback	/* Callback function */
   );

extern void hawo_get_position IPT2
   (
   IUM8, device,	    /* Output device */
   HAW_POSN *, pinfo	/* Pointer to audio position(time) structure */
   );

extern void hawo_pause IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_restart IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_reset IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_close IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IBOOL hawo_is_active IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IUM8 hawo_break_loop IPT2
   (
   IUM8, device,	/* Output device */
   IBOOL, at_end	/* If TRUE action at end of loop, otherwise action immediately */
   );

extern IUM8 hawi_num_devices IPT0();

extern void hawi_query_capabilities IPT1
   (
   HAWI_CAPS, *pcaps   /* Pointer to input capabilities structure. */
   );

extern IUM8 hawi_query_format IPT4
   (
   IUM8, channels,      /* channels required */
   IUM8, data_type,     /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,   /* Samples per second. */
   IUM8, sample_size    /* 8 or 16-bit data samples. */
   );

extern IUM8 hawi_open IPT5
   (
   IUM8, channels,    /* channels required */
   IUM8, data_type,   /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate, /* Samples per second. */
   IUM8, sample_size,  /* 8 or 16-bit data samples. */
   LIN_ADDR, buff_addr
   );

extern void hawi_get_position IPT1
   (
   HAW_POSN *, pinfo	/* Pointer to audio position(time) structure */
   );

extern void hawi_add_buffer IPT3
   (
   IU32, data_addr,	    			/* Intel memory Pointer to wave data */
   IU32, data_size,	        		/* Number of bytes in input data buffer */
   HAW_CALLBACK *, hawi_callback	/* Callback function */
   );

extern void hawi_start IPT0();

extern void hawi_restart IPT0();

extern IBOOL hawi_is_active IPT0();

extern void hawi_close IPT0();

extern IBOOL hawo_hardware_acquire IPT1
   (
   IUM8, device	    /* Output device */
   );
   
extern IBOOL hawi_hardware_acquire IPT0();

extern void hawo_hardware_realease IPT1
   (
   IUM8, device	    /* Output device */
   );
   
extern void hawi_hardware_realease IPT0();

extern IBOOL hawo_enable IPT0();
extern IBOOL hawi_enable IPT0();

extern IBOOL hawo_disable IPT0();
extern IBOOL hawi_disable IPT0();

extern IBOOL hawo_WEP IPT0();
extern IBOOL hawi_WEP IPT0();

extern void hawo_dec_int_cnt IPT1
   (
   IUM8, device	    /* Output device */
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gore.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		gore.h

 Description:

		This is the header file for the Graphics Object Recognition
		( GORE ) system for communicating update information from
		the VGA emulation to the host graphics system.

 Author:
		John Shanly

 Date:
		6 November 1990

 SccsID	"@(#)gore.h	1.2 08/10/92 Copyright Insignia Solutions Ltd."

======================================================================
]*/

#ifdef INTERLEAVED

#define	B_POS_UNIT_DIFF	 4
#define	B_NEG_UNIT_DIFF	-4
#define	W_POS_UNIT_DIFF	 8
#define	W_NEG_UNIT_DIFF	-8
#define	CURR_LINE_DIFF	320

#else

#define	B_POS_UNIT_DIFF	 1
#define	B_NEG_UNIT_DIFF	-1
#define	W_POS_UNIT_DIFF	 2
#define	W_NEG_UNIT_DIFF	-2
#define	CURR_LINE_DIFF	80

#endif /* INTERLEAVED */


typedef struct
{
	VOID		(*b_wrt)();
	VOID		(*w_wrt)();
	VOID		(*b_str)();
	VOID		(*w_str)();
} GU_HANDLER;

typedef struct
{
	ULONG		obj_type;
	ULONG		offset;
	ULONG		tlx;
	ULONG		tly;
	ULONG		width;
	ULONG		height;
} OBJ_DATA;

typedef struct _OBJECT
{
	OBJ_DATA		data;
	struct _OBJECT	*next;
	struct _OBJECT	*prev;
} OBJECT, *OBJ_PTR;

typedef struct
{
	ULONG		curr_addr;
	ULONG		obj_start;
	ULONG		start;
	ULONG		end;
	ULONG		curr_line_end;
	ULONG		prev_line_start;
	ULONG		rect_width;
	ULONG		rect_height;
	OBJ_PTR	obj_ptr;
	OBJ_PTR	obj_ptr2;
	ULONG		count;
} GORE_DATA_WRT;

typedef struct
{
	ULONG		start;
	ULONG		end;
	ULONG		width;
	OBJ_PTR	obj_ptr;
} GORE_DATA_STR;

typedef struct
{
	ULONG			curr_line_diff;
	ULONG			max_vis_addr;
	ULONG			shift_count;
	GORE_DATA_WRT	gd_b_wrt;
	GORE_DATA_WRT	gd_w_wrt;
	GORE_DATA_STR	gd_b_str;
	GORE_DATA_STR	gd_w_str;
} GORE_DATA;

typedef	UTINY			OBJ_TYPE;

#define	OBJ_PTR_NULL	((OBJ_PTR) 0)

#define	INITIAL_MAX_LIST_SIZE	1000		/* Arbitrary */

#define	RANDOM_BW			0
#define	RANDOM_WW			1
#define	LINE_RIGHT_BW		2
#define	LINE_RIGHT_WW		3
#define	LINE_RIGHT_BS		4
#define	LINE_RIGHT_WS		5
#define	LINE_LEFT_BW		6
#define	LINE_LEFT_WW		7
#define	LINE_LEFT_BS		8
#define	LINE_LEFT_WS		9
#define	LINE_DOWN_BW		10
#define	LINE_DOWN_WW		11
#define	LINE_UP_BW			12
#define	LINE_UP_WW			13
#define	RECT_RIGHT_DOWN_BW	14
#define	RECT_RIGHT_DOWN_WW	15
#define	RECT_RIGHT_DOWN_BS	16
#define	RECT_RIGHT_DOWN_WS	17
#define	RECT_LEFT_DOWN_BW		18
#define	RECT_LEFT_DOWN_WW		19
#define	RECT_RIGHT_UP_BS		20
#define	RECT_RIGHT_UP_WS		21
#define	RECT_LEFT_UP_BS		22
#define	RECT_LEFT_UP_WS		23
#define	LINE_DOWN_LEFT_BW		24
#define	LINE_DOWN_RIGHT_BW	25
#define	LINE_DOWN_LEFT_WW		26
#define	LINE_DOWN_RIGHT_WW	27
#define	RECT_DOWN_RIGHT_BW	28
#define	RECT_DOWN_RIGHT_WW	29
#define	ANNULLED			30
#define	MAX_OBJ_TYPES		31

#define	NOT_PENDING		0
#define	BW			1
#define	WW			2
#define	BS			3
#define	WS			4

IMPORT GU_HANDLER gu_handler;
IMPORT GORE_DATA gd;
IMPORT VOID (*paint_screen)();
IMPORT VOID process_object_list();
IMPORT ULONG trace_gore;
IMPORT ULONG stat_gore;
IMPORT OBJ_PTR start_object();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\gvi.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Generic Video Interface Module definitions
 *
 * Description	: Definitions for users of the Generic Video Interface Module
 *
 * Author	: Henry Nash / David Rees
 *
 * Notes	: This file should be included by all external modules that
 *		  use the GVI module.
 */

/* SccsID[]="@(#)gvi.h	1.16 06/28/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Constant definitions
 * ============================================================================
 */

#define GAP_WIDTH	0xC0 	 /* Width of the gap in bytes                */
#define ODD_START       0xBA000L  /* Start of the odd bank                    */
#define ODD_END         0xBBF3FL  /* End of the odd bank                      */
#define EVEN_START      0xB8000L  /* Start of the even bank                   */
#define EVEN_END        0xB9F3FL  /* End of the even bank                     */
#define	ODD_OFFSET	(ODD_START-EVEN_START)	/* offset of odd bank to even bank */

#define SCAN_LINE_LENGTH 80	/* Length of a scan line in bytes */

#define CGA_CURS_HEIGHT	   2	 /* CGA 'usual' underscore cursor	      */
#define CGA_CURS_START     7	 /* CGA 'usual' underscore cursor	      */

#define MDA_CURS_HEIGHT    2	 /* Default MDA cursor height               */
#define MDA_CURS_START     7 	 /* Default MDA cursor starting scan line   */

#define CGA_HEIGHT	200	/* In host scan lines */
#define EGA_HEIGHT	350
#define HERC_HEIGHT	350
#define VGA_HEIGHT	400


/*
 * Legal modes for the adapter
 */
#undef TEXT
#define TEXT	        0	/* Alpha numeric mode 80 by 25, or 40 by 25  */
#define GRAPHICS	1	/* All Points Addressable 640x200 or 320x200 */

#define HIGH		0	/* APA 640x200,  2 colors		     */
#define MEDIUM		1	/* APA 320x200,  4 colors		     */
#define LOW		2	/* APA 160x100, 16 colors  (not supported)   */

#define VGA_DAC_SIZE	0x100
#ifdef EGG
#ifdef VGG
#define MAX_NUM_FONTS	8	/* VGA support 8 fonts */
#else
#define MAX_NUM_FONTS	4	/* EGA support 4 fonts */
#endif  /* VGG */
#endif  /* EGG */


#ifdef HERC

/* Hercules Page 0  */

#define P0_EVEN_START1      0x0000  /* Start of the even bank         */
#define P0_EVEN_END1        0x1E95  /* End of the even bank           */
#define P0_ODD_START1       0x2000  /* Start of the odd bank          */
#define P0_ODD_END1         0x3E95  /* End of the odd bank            */
#define P0_EVEN_START2      0x4000  /* Start of the even bank         */
#define P0_EVEN_END2        0x5E95  /* End of the even bank           */
#define P0_ODD_START2       0x6000  /* Start of the odd bank          */
#define P0_ODD_END2         0x7E95  /* End of the odd bank            */

/* Hercules Page 1   */

#define P1_EVEN_START1      0x8000  /* Start of the even bank         */
#define P1_EVEN_END1        0x9E95  /* End of the even bank           */
#define P1_ODD_START1       0xA000  /* Start of the odd bank          */
#define P1_ODD_END1         0xBE95  /* End of the odd bank            */
#define P1_EVEN_START2      0xC000  /* Start of the even bank         */
#define P1_EVEN_END2        0xDE95  /* End of the even bank           */
#define P1_ODD_START2       0xE000  /* Start of the odd bank          */
#define P1_ODD_END2         0xFE95  /* End of the odd bank            */

#define HERC_CURS_HEIGHT   2	 /* Default  Hercules MDA cursor height     */
#define HERC_CURS_START    13 	 /* Default  Hercules MDA cursor starting scan line   */

#endif	/* HERC */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#if defined(NEC_98)
extern  void    gvi_init(void);
#else  // !NEC_98
extern	void	gvi_init IPT1(half_word, v_adapter);
#endif // !NEC_98
extern	void	gvi_term IPT0();
extern	void	recalc_screen_params IPT0();

#ifdef EGG
IMPORT VOID ega_term IPT0();
IMPORT VOID ega_init IPT0();
#endif

#ifdef VGG
IMPORT VOID vga_term IPT0();
IMPORT VOID vga_init IPT0();
#endif

/*
 * The screen memory limits in host and PC address space
 */

extern sys_addr gvi_pc_low_regen;
extern sys_addr gvi_pc_high_regen;

/*
 * Variable to determine which video adapter is currently selected
 */

extern half_word video_adapter;

/*
 * screen height varies on EGA. It is set in two parts; the top bit is controlled by
 * a separate register to the lower 8 bits. The _9_BITS type is used to help emulate
 * this type of setting.
 */

#if defined(NEC_98)
typedef struct
{
                        BOOL    atrsel;
                        BOOL    graphmode;
                        BOOL    width;
                        BOOL    fontsel;
                        BOOL    graph88;
                        BOOL    kacmode;
                        BOOL    nvmwpermit;
                        BOOL    dispenable;
} MODE_FF;

/* ADD NEC98 Graphic Emulater's STRUC 930617 */

typedef struct
{
        BOOL                    vh;
        unsigned char           cr;
        unsigned short          lf;
        unsigned short          zw;
        unsigned long           sad1;
        unsigned short          sl1;
        BOOL                    im1;
        unsigned long           sad2;
        unsigned short          sl2;
        BOOL                    im2;
        unsigned char           lr;
        unsigned short          p;
        unsigned char           slrctl;
        unsigned char           dir;
        BOOL                    dgd;
        unsigned short          dc;
        unsigned short          d;
        unsigned short          d2;
        unsigned short          d1;
        unsigned short          dm;
        unsigned short          ptn;
        unsigned short          txt[8];
        unsigned long           ead;
        BOOL                    wg;
        unsigned short          dad;
        unsigned char           whl;
        unsigned char           mod;
        BOOL                    startstop;
} _STRC_GGDC ;

typedef struct{
        BOOL                    flag;
        PALETTEENTRY            data[16];
} _STRC_PALETTE ;

typedef struct{
        BOOL                    colorsel;
        BOOL                    egcext;
        BOOL                    lcd1mode;
        BOOL                    lcd2mode;
        BOOL                    lsiinit;
        BOOL                    gdcclock;
        BOOL                    regwrite;
} _STRC_MODE_FF2;

#endif // NEC_98
typedef union {
        word    as_word;
        struct
        {
#ifdef  BIT_ORDER1
                unsigned        unused          : 7,
                                top_bit         : 1,
                                low_byte        : 8;
#else
                unsigned        low_byte        : 8,
                                top_bit         : 1,
                                unused          : 7;
#endif
        } as_bfld;
} _9_BITS;

/*
 * VGA has greater resolution to VGA - some regs have an extra bit thrown in
 * in some register to boost them to 10 bits. Split this into three parts as
 * a super set of the 9_bit type.
 */

typedef union {
        word    as_word;
        struct
        {
#ifdef  BIT_ORDER1
                unsigned        unused          : 6,
                                top_bit         : 1,
				med_bit		: 1,
                                low_byte        : 8;
#else
                unsigned        low_byte        : 8,
				med_bit		: 1,
                                top_bit         : 1,
                                unused          : 6;
#endif
        } as_bfld;
} _10_BITS;
/*
 * Definition of variables which reflect the state of the current adapter
 */

typedef	struct {
	int mode_change_required;	/* Display mode changed not just in EGA */
	int bytes_per_line;		/* In TEXT mode the no. of bytes per line   */
	int chars_per_line;		/* In TEXT mode the no. of chars per line   */
	int char_width;			/* Width of a character in host pixels      */
	int char_height;		/* Height of a character in PC pixels       */
	int screen_start;		/* Address in adaptor memory of current screen */
#ifdef VGG
	_10_BITS screen_height;		/* Height in pc scanlines of screen	    */
#else
	_9_BITS	screen_height;		/* Height in pc scanlines of screen	    */
#endif
	half_word *screen_ptr;		/* pointer to start of regen buffer	    */
	int screen_length;		/* Number of bytes in one screenfull        */
#if defined(NEC_98)
        BOOL    crt_on;
#endif // NEC_98
	int display_disabled;		/* 0 if it's OK to do screen output.        */
					/* it is used to implement the VIDEO_ENABLE */
					/* bit in the mode select register          */
	int cursor_start;		/* scanlines from top of char block	    */
	int cursor_height;		/* in scanlines from cursor start	    */
	int cursor_start1;		/* start scanline of poss 2nd block	    */
	int cursor_height1;		/* height of 2nd block or 0 if none	    */
	int cur_x,cur_y;		/* Current cursor position */
	boolean PC_cursor_visible;	/* flag for cursor visible or not */
	boolean word_addressing;	/* if TRUE, bytes_per_line=2*chars_per_line */
#ifdef VGG
	boolean chain4_mode;
	boolean doubleword_mode;	/* if TRUE, bytes_per_line=4*chars_per_line */
					/* else bytes_per_line=chars_per_line	    */
#ifdef V7VGA
	boolean seq_chain4_mode;
	boolean seq_chain_mode;
#endif /* V7VGA */
#endif
	int pix_width;			/* Width of a PC pixel in host pixels	    */
	int pix_char_width;		/* Width of PC character pixel in host pixels (is this used?) */
	int pc_pix_height; 		/* Height of PC pixel in pixels   */
	int host_pix_height; 		/* Height of PC pixel in host pixels	    */
	int offset_per_line;		/* mirrors bytes_per_line for mda and cga, but can vary for ega */
	int screen_limit;		/* number of bytes in video_copy */
#if defined(NEC_98)
        BOOL    beep_on;
        BOOL    beep_changed;
        word    beep_rate;

        int     blink_rate;
        BOOL    blink_disable;
        int     pitch_width;
        BOOL    kcg_dot_mode;
/*--------------------------------------------------*/
        int     gvram_length;
        int     gvram_width;
        int     gvram_height;
        int     gvram_start;
        int     gvram_offset;
        int     gvram_text_line;
        int     gvram_line_char;
        int     gvram_scan;
        unsigned char   *gvram_ptr;
        unsigned char   *gvram_copy;
/*--------------------------------------------------*/
        MODE_FF modeff;
        _STRC_GGDC      ggdcemu ;
        _STRC_PALETTE   palette ;
        _STRC_MODE_FF2  modeff2 ;
#endif // NEC_98
} DISPLAY_GLOBS;

#if defined(NEC_98)
extern  DISPLAY_GLOBS   NEC98Display;
#else  // !NEC_98
extern	DISPLAY_GLOBS	PCDisplay;
#endif // !NEC_98

#if defined(NEC_98)
#define set_gvram_length(val)   NEC98Display.gvram_length = val
#define set_gvram_width(val)    NEC98Display.gvram_width  = val
#define set_gvram_height(val)   NEC98Display.gvram_height = val
#define set_gvram_start(val)    NEC98Display.gvram_start  = val
#define set_gvram_ptr(val)      NEC98Display.gvram_ptr    = val
#define set_gvram_copy(val)     NEC98Display.gvram_copy   = val
#define set_text_lines(val)     NEC98Display.gvram_text_line = val
#define set_line_per_char(val)  NEC98Display.gvram_line_char = val
#define set_gvram_scan(val)     NEC98Display.gvram_scan = val

#define get_gvram_length()      NEC98Display.gvram_length
#define get_gvram_width()       NEC98Display.gvram_width
#define get_gvram_height()      NEC98Display.gvram_height
#define get_gvram_start()       NEC98Display.gvram_start
#define get_gvram_ptr()         NEC98Display.gvram_ptr
#define get_gvram_copy()        NEC98Display.gvram_copy
#define get_text_lines()        NEC98Display.gvram_text_line
#define get_line_per_char()     NEC98Display.gvram_line_char
#define get_gvram_scan()        NEC98Display.gvram_scan

#define get_graph_ptr()         &((NEC98Display.gvram_ptr)[NEC98Display.gvram_start])
#define set_gvram_start_offset(val)     NEC98Display.gvram_offset = val
#define get_gvram_start_offset()        NEC98Display.gvram_offset

#define set_mode_change_required(val)   NEC98Display.mode_change_required = (val)
#define set_word_addressing(val)        NEC98Display.word_addressing = (val)
#define set_offset_per_line(val)        NEC98Display.offset_per_line = (val)
#define set_offset_per_line_recal(val)  { set_offset_per_line(val); recalc_screen_params(); }
#define set_word_addressing_recal(val)  { set_word_addressing(val); recalc_screen_params(); }
#define set_cur_x(val)                  NEC98Display.cur_x = (val)
#define set_cur_y(val)                  NEC98Display.cur_y = (val)
#define set_cursor_start(val)           NEC98Display.cursor_start = (val)
#define inc_cursor_start()              (NEC98Display.cursor_start)++
#define set_cursor_height(val)          NEC98Display.cursor_height = (val)
#define set_cursor_start1(val)          NEC98Display.cursor_start1 = (val)
#define set_cursor_height1(val)         NEC98Display.cursor_height1 = (val)
#define set_cursor_visible(val)         NEC98Display.PC_cursor_visible = (val)
#define set_display_disabled(val)       NEC98Display.display_disabled = (val)
#define set_bit_display_disabled(val)   NEC98Display.display_disabled |= (val)
#define clear_bit_display_disabled(val) NEC98Display.display_disabled &= ~(val)
#define set_bytes_per_line(val)         NEC98Display.bytes_per_line = (val)
#define set_chars_per_line(val)         NEC98Display.chars_per_line = (val)
#define set_horiz_total(val)            { set_chars_per_line(val); recalc_screen_params(); }
#define set_char_width(val)             NEC98Display.char_width = (val)
#define set_char_height(val)            NEC98Display.char_height = (val)
#define set_char_height_recal(val)      { set_char_height(val); recalc_screen_params(); }
#define set_screen_length(val)          NEC98Display.screen_length = (val)
#define set_screen_start(val)           NEC98Display.screen_start = (val)
#define set_screen_height(val)          NEC98Display.screen_height.as_word = (val)
#define set_screen_height_recal(val)    { set_screen_height(val); recalc_screen_params(); }
#define set_screen_height_lo(val)       NEC98Display.screen_height.as_bfld.low_byte = ((val) & 0xff)
#define set_screen_height_lo_recal(val) { set_screen_height_lo(val); recalc_screen_params(); }
#define set_screen_height_med(val)       NEC98Display.screen_height.as_bfld.med_bit = ((val) & 0xff)
#define set_screen_height_med_recal(val)        { set_screen_height_med(val); recalc_screen_params(); }
#define set_screen_height_hi(val)       NEC98Display.screen_height.as_bfld.top_bit = ((val) & 1)
#define set_screen_height_hi_recal(val) { set_screen_height_hi(val); recalc_screen_params(); }
#define set_screen_ptr(ptr)             NEC98Display.screen_ptr = (ptr)
#define set_pix_width(val)              NEC98Display.pix_width = (val)
#define set_pc_pix_height(val)          NEC98Display.pc_pix_height = (val)
#define set_host_pix_height(val)        NEC98Display.host_pix_height = (val)
#define set_pix_char_width(val)         NEC98Display.pix_char_width = (val)

#define get_mode_change_required()      (NEC98Display.mode_change_required)
#define get_offset_per_line()           (NEC98Display.offset_per_line)
#define get_pix_width()                 (NEC98Display.pix_width)
#define get_pc_pix_height()             (NEC98Display.pc_pix_height)
#define get_host_pix_height()           (NEC98Display.host_pix_height)
#define get_pix_char_width()            (NEC98Display.pix_char_width)
#define get_word_addressing()           (NEC98Display.word_addressing)
#define get_cur_x()                     (NEC98Display.cur_x)
#define get_cur_y()                     (NEC98Display.cur_y)
#define get_cursor_start()              (NEC98Display.cursor_start)
#define get_cursor_height()             (NEC98Display.cursor_height)
#define get_cursor_start1()             (NEC98Display.cursor_start1)
#define get_cursor_height1()            (NEC98Display.cursor_height1)
#define is_cursor_visible()             (NEC98Display.PC_cursor_visible != FALSE)
#define get_display_disabled()          (NEC98Display.display_disabled)
#define get_bytes_per_line()            (NEC98Display.bytes_per_line)
#define get_chars_per_line()            (NEC98Display.chars_per_line)
#define get_char_width()                (NEC98Display.char_width)
#define get_char_height()               (NEC98Display.char_height)
#define get_screen_length()             (NEC98Display.screen_length)
#define get_screen_start()              (NEC98Display.screen_start)
#define get_screen_height()             ((NEC98Display.screen_height.as_word+1)*get_pc_pix_height())
#define get_screen_height_lo()          (NEC98Display.screen_height.as_bfld.low_byte)
#define get_screen_height_hi()          (NEC98Display.screen_height.as_bfld.top_bit)
#define get_screen_end()                (get_screen_start() + get_screen_length() + gvi_pc_low_regen)
#define get_screen_ptr(offs)            &((NEC98Display.screen_ptr)[offs])
#define get_screen_base()               ((get_screen_start() << 1) + gvi_pc_low_regen)
#ifdef VGG
#define set_chain4_mode(val)            NEC98Display.chain4_mode = (val)
#define set_doubleword_mode(val)        NEC98Display.doubleword_mode = (val)
#define get_chain4_mode()               (NEC98Display.chain4_mode)
#define get_doubleword_mode()           (NEC98Display.doubleword_mode)
#ifdef V7VGA
#define set_seq_chain4_mode(val)        NEC98Display.seq_chain4_mode = (val)
#define set_seq_chain_mode(val) NEC98Display.seq_chain_mode = (val)
#define get_seq_chain4_mode()   (NEC98Display.seq_chain4_mode)
#define get_seq_chain_mode()    (NEC98Display.seq_chain_mode)
#endif /* V7VGA */
#endif
#else  // !NEC_98
#define	set_mode_change_required(val)	PCDisplay.mode_change_required = (val)
#define	set_word_addressing(val)	PCDisplay.word_addressing = (val)
#define	set_offset_per_line(val)	PCDisplay.offset_per_line = (val)
#define	set_offset_per_line_recal(val)	{ set_offset_per_line(val); recalc_screen_params(); }
#define	set_word_addressing_recal(val)	{ set_word_addressing(val); recalc_screen_params(); }
#define	set_cur_x(val)			PCDisplay.cur_x = (val)
#define	set_cur_y(val)			PCDisplay.cur_y = (val)
#define	set_cursor_start(val)		PCDisplay.cursor_start = (val)
#define	inc_cursor_start()		(PCDisplay.cursor_start)++
#define	set_cursor_height(val)		PCDisplay.cursor_height = (val)
#define	set_cursor_start1(val)		PCDisplay.cursor_start1 = (val)
#define	set_cursor_height1(val)		PCDisplay.cursor_height1 = (val)
#define	set_cursor_visible(val)		PCDisplay.PC_cursor_visible = (val)
#define	set_display_disabled(val)	PCDisplay.display_disabled = (val)
#define	set_bit_display_disabled(val)	PCDisplay.display_disabled |= (val)
#define	clear_bit_display_disabled(val)	PCDisplay.display_disabled &= ~(val)
#define	set_bytes_per_line(val)		PCDisplay.bytes_per_line = (val)
#define	set_chars_per_line(val)		PCDisplay.chars_per_line = (val)
#define	set_horiz_total(val)		{ set_chars_per_line(val); recalc_screen_params(); }
#define	set_char_width(val)		PCDisplay.char_width = (val)
#define	set_char_height(val)		PCDisplay.char_height = (val)
#define	set_char_height_recal(val)	{ set_char_height(val); recalc_screen_params(); }
#define	set_screen_length(val)		PCDisplay.screen_length = (val)
#define	set_screen_limit(val)		PCDisplay.screen_limit = (val)
#define set_screen_start(val)		PCDisplay.screen_start = (val)
#define	set_screen_height(val)		PCDisplay.screen_height.as_word = (val)
#define	set_screen_height_recal(val)	{ set_screen_height(val); recalc_screen_params(); }
#define set_screen_height_lo(val)       PCDisplay.screen_height.as_bfld.low_byte = ((val) & 0xff)
#define set_screen_height_lo_recal(val)	{ set_screen_height_lo(val); recalc_screen_params(); }
#define set_screen_height_med(val)       PCDisplay.screen_height.as_bfld.med_bit = ((val) & 0xff)
#define set_screen_height_med_recal(val)	{ set_screen_height_med(val); recalc_screen_params(); }
#define set_screen_height_hi(val)       PCDisplay.screen_height.as_bfld.top_bit = ((val) & 1)
#define set_screen_height_hi_recal(val)	{ set_screen_height_hi(val); recalc_screen_params(); }
#define	set_screen_ptr(ptr)		PCDisplay.screen_ptr = (ptr)
#define	set_pix_width(val)		PCDisplay.pix_width = (val)
#define	set_pc_pix_height(val)		PCDisplay.pc_pix_height = (val)
#define	set_host_pix_height(val)	PCDisplay.host_pix_height = (val)
#define	set_pix_char_width(val)		PCDisplay.pix_char_width = (val)

#define	get_mode_change_required()	(PCDisplay.mode_change_required)
#define	get_offset_per_line()		(PCDisplay.offset_per_line)
#define	get_pix_width()			(PCDisplay.pix_width)
#define	get_pc_pix_height()		(PCDisplay.pc_pix_height)
#define	get_host_pix_height()		(PCDisplay.host_pix_height)
#define	get_pix_char_width()		(PCDisplay.pix_char_width)
#define	get_word_addressing()		(PCDisplay.word_addressing)
#define	get_cur_x()			(PCDisplay.cur_x)
#define	get_cur_y()			(PCDisplay.cur_y)
#define	get_cursor_start()		(PCDisplay.cursor_start)
#define	get_cursor_height()		(PCDisplay.cursor_height)
#define	get_cursor_start1()		(PCDisplay.cursor_start1)
#define	get_cursor_height1()		(PCDisplay.cursor_height1)
#define	is_cursor_visible()		(PCDisplay.PC_cursor_visible != FALSE)
#define	get_display_disabled()		(PCDisplay.display_disabled)
#define	get_bytes_per_line()		(PCDisplay.bytes_per_line)
#define	get_chars_per_line()		(PCDisplay.chars_per_line)
#define	get_char_width()		(PCDisplay.char_width)
#define	get_char_height()		(PCDisplay.char_height)
#define	get_screen_length()		(PCDisplay.screen_length)
#define get_screen_start()		(PCDisplay.screen_start)
#ifdef VGG
#define get_screen_height()             ((video_adapter == VGA) ? ((PCDisplay.screen_height.as_word+1)<<EGA_GRAPH.multiply_vert_by_two) : \
							((PCDisplay.screen_height.as_word+1)*get_pc_pix_height()))
#else
#define get_screen_height()             ((PCDisplay.screen_height.as_word+1)*get_pc_pix_height())
#endif /* VGG */
#define get_screen_height_lo()          (PCDisplay.screen_height.as_bfld.low_byte)
#define get_screen_height_hi()          (PCDisplay.screen_height.as_bfld.top_bit)
#define	get_screen_end()		(get_screen_start() + get_screen_length() + gvi_pc_low_regen)
#define	get_screen_ptr(offs)		((PCDisplay.screen_ptr) + (offs))
#define get_screen_base()		((get_screen_start() << 1) + gvi_pc_low_regen)
#ifdef VGG
#define set_chain4_mode(val)		PCDisplay.chain4_mode = (val)
#define set_doubleword_mode(val)	PCDisplay.doubleword_mode = (val)
#define get_chain4_mode()		(PCDisplay.chain4_mode)
#define get_doubleword_mode()		(PCDisplay.doubleword_mode)
#ifdef V7VGA
#define set_seq_chain4_mode(val)	PCDisplay.seq_chain4_mode = (val)
#define set_seq_chain_mode(val)	PCDisplay.seq_chain_mode = (val)
#define get_seq_chain4_mode()	(PCDisplay.seq_chain4_mode)
#define get_seq_chain_mode()	(PCDisplay.seq_chain_mode)
#endif /* V7VGA */
#endif
#endif // !NEC_98

/*
 * useful macro to get character height in host pixels
 */
#define get_host_char_height()		(get_char_height()*get_host_pix_height()*get_pc_pix_height())

/*
 * Macros to check for regen buffer - both 8088 and M68000 address space
 */

#define gvi_pc_check_regen(addr) (addr >= gvi_pc_low_regen && addr <= gvi_pc_high_regen)
#if defined(NEC_98)
/******************************************************************* */
/* For PC-9801 Emulation related functions                           */
/******************************************************************* */
/*      Miscelinous macros used for PC-98 H/W architecture           */
/******************************************************************* */
/*  Color/Code conversion macro groups                               */
#define NEC98_CODE_LR    0x8080             /* Mask for determine L/R */
#define NEC98_CODE_MASK  0x7f7f             /* Mask for extract JIS   */
#define NEC98_CODE_BIAS  0x0020             /* Bias for NEC98 code     */
#define NEC98_CODE_LEFT  1                  /* LEFT CODE for flag     */
#define NEC98_CODE_RIGHT 2                  /* RIGHT CODE for flag    */

#define NEC98_ATR_COLOR          0xE0             /* Mask for color   */
#define NEC98_ATR_BLACK          0x00             /* Black            */
#define NEC98_ATR_REVERSE        0x04             /* Mask for reverse */
#define NEC98_ATR_BLINK          0x02             /* Mask for blink   */
#define NEC98_ATR_SECRET         0x01             /* Mask for secret  */
                                                 /* Note: negative!  */

#define NEC98_is_secret(x)       (!(x&NEC98_ATR_SECRET)) /* Is secret ?  */
#define NEC98_is_reverse(x)      (x&NEC98_ATR_REVERSE)   /* Is reverse ? */
#define NEC98_is_blink(x)        (x&NEC98_ATR_BLINK)     /* Is blink ?   */
#define NEC98_norm_color(x)      ((x&0x01)|((x&0x02)?0x04:0)|((x&0x04)?0x02:0))
#define NEC98_get_color(x)       NEC98_norm_color((x&NEC98_ATR_COLOR)>>5)
                                                    /* Extract color */
#define NEC98_EGA_BGCOLOR(x)     (x<<4)              /* EGA bg color  */
#define NEC98_EGA_FGCOLOR(x)     (x)                 /* EGA fg color  */

/* PC-98 Text-VRAM manupilation groups */

/* PC-98 text vram locations (32 bits offset addr.)                         */
#define NEC98_N_TEXT_P0_OFF      (0xA0000L)        /* First text page addr   */
#define NEC98_N_TEXT_P1_OFF      (0xA1000L)        /* Second text page addr  */
#define NEC98_N_ATTR_P0_OFF      (0xA2000L)        /* First Attribute page   */
#define NEC98_N_ATTR_P1_OFF      (0xA3000L)        /* Second attribute page  */

#define NEC98_H_TEXT_P0_OFF      (0xE0000L)        /* First text page addr   */
#define NEC98_H_TEXT_P1_OFF      (0xE1000L)        /* Second text page addr  */
#define NEC98_H_ATTR_P0_OFF      (0xE2000L)        /* First Attribute page   */
#define NEC98_H_ATTR_P1_OFF      (0xE3000L)        /* Second attribute page  */

extern BOOL HIRESO_MODE;
//#define       NEC98_TEXT_P0_OFF NEC98_N_TEXT_P0_OFF
//#define       NEC98_TEXT_P1_OFF NEC98_N_TEXT_P1_OFF
//#define       NEC98_ATTR_P0_OFF NEC98_N_ATTR_P0_OFF
//#define       NEC98_ATTR_P1_OFF NEC98_N_ATTR_P1_OFF
#define NEC98_TEXT_P0_OFF (HIRESO_MODE ? NEC98_H_TEXT_P0_OFF : NEC98_N_TEXT_P0_OFF)
#define NEC98_TEXT_P1_OFF (HIRESO_MODE ? NEC98_H_TEXT_P1_OFF : NEC98_N_TEXT_P1_OFF)
#define NEC98_ATTR_P0_OFF (HIRESO_MODE ? NEC98_H_ATTR_P0_OFF : NEC98_N_ATTR_P0_OFF)
#define NEC98_ATTR_P1_OFF (HIRESO_MODE ? NEC98_H_ATTR_P1_OFF : NEC98_N_ATTR_P1_OFF)

/* PC-98 text vram locations (32 bits flat addr.) */
#define NEC98TVA         (NEC98Display.screen_ptr)

#define NEC98_TEXT_P0_PTR        (NEC98_TEXT_P0_START+NEC98TVA)
#define NEC98_TEXT_P1_PTR        (NEC98_TEXT_P1_START+NEC98TVA)
#define NEC98_ATTR_P0_PTR        (NEC98_ATTR_P0_START+NEC98TVA)
#define NEC98_ATTR_P1_PTR        (NEC98_ATTR_P1_START+NEC98TVA)

/* PC-98 text vram locations (relative to MVDM's VIDEO memory) */
#define NEC98_TEXT_P0_START      0x0000
#define NEC98_TEXT_P1_START      0x1000
#define NEC98_ATTR_P0_START      0x2000
#define NEC98_ATTR_P1_START      0x3000

/* PC-98 text vram limits (relative to MVDM VIDEO memory) */
#define NEC98_REGEN_START        0x0000
#define NEC98_REGEN_END          0x3ffe

/* Address Conversion macros */
//#define       NEC98_EGA_char_loc(x)            (x-NEC98Display.screen_start)
//#define       NEC98_EGA_attr_loc(x)            (NEC98_EGA_char_loc(x)+NEC98TVA)
#define LINES_PER_SCREEN (NEC98Display.screen_length/NEC98Display.offset_per_line)                                                                                                                                                                                                                /*      (?_?) */ //????????
#define COLUMNS_PER_LINE        (NEC98Display.chars_per_line)
#define OFFSET_PER_LINE         (NEC98Display.offset_per_line)

#define set_crt_on(val) NEC98Display.crt_on=(val)
#define get_crt_on() (NEC98Display.crt_on)
#define set_beep_rate(val)      NEC98Display.beep_rate = (val)
#define get_beep_rate()         (NEC98Display.beep_rate)
#define set_beep_on(val)        NEC98Display.beep_on = (val)
#define get_beep_on()           (NEC98Display.beep_on)
#define set_beep_changed(val)   NEC98Display.beep_changed = (val)
#define get_beep_changed()      (NEC98Display.beep_changed)
#define set_pitch_width(val)    NEC98Display.pitch_width = (val)
#define get_pitch_width()       (NEC98Display.pitch_width)
#define set_blink_rate(val)     NEC98Display.blink_rate = (val)
#define get_blink_rate()        (NEC98Display.blink_rate)
#define set_blink_disable(val)  NEC98Display.blink_disable = (val)
#define get_blink_disable()     (NEC98Display.blink_disable)

#define PC_98   7
//#define NEC98_ATR_BLACK  0

/********************************************************************/
/* Statics/structures for PC-98 H/W architecture                    */
/********************************************************************/
#ifndef NEC98VRAM
#define NEC98VRAM
typedef struct  {
        unsigned short  code;
        unsigned char           attr;
}       NEC98_VRAM_COPY;
#endif

/* Structures represents PC-9801 multi split displaying */
typedef struct  {
        unsigned char *addr;              /* Beginning addr.            */
        int            lines;             /* Number of lines in region. */
} NEC98_SplitElem;

typedef struct  {
        int            nRegions;          /* Number of regions(max4)    */
        NEC98_SplitElem  split[4];         /* Each split elements        */
} NEC98_TextSplits;

extern NEC98_TextSplits  text_splits;    /* CRT split data structure     */
                                        /* Should be opened to ather's  */

/************************************************************************/
/*      Prototype declarations for NEC98 Prototypes                      */
/************************************************************************/
unsigned short Cnv_NEC98_ToSjisLR(NEC98_VRAM_COPY cell,unsigned short *flg);
NEC98_VRAM_COPY Get_NEC98_VramCellL( unsigned short loc );
NEC98_VRAM_COPY Get_NEC98_VramCellA( unsigned short *addr );
unsigned char Cnv_NEC98_atr( unsigned char attr );

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\herc.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Hercules Mono Display Adaptor declarations
 *
 * Description	: Definitions for users of the Hercules MDA
 *
 * Author	: P. Jadeja 
 *
 * Notes	: None
 */


/* SccsID[]=" @(#) @(#)herc.h	1.4 08/10/92 02/02/89 01/17/89 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#define HERC_SCAN_LINE_LENGTH 90

extern void herc_init IPT0();
extern void herc_term IPT0();
extern void herc_inb IPT2(io_addr, port, half_word *, value);
extern void herc_outb IPT2(io_addr, port, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hg_sas.h ===
/*===========================================================================*/

/*[
 * File Name		: hg_sas.h
 *
 * Derived From		: 
 *
 * Author		: Jane Sales
 *
 * Creation Date	: 29th August, 1992
 *
 * SCCS Version		: @(#)hg_sas.h	1.1 08/06/93
 *!
 * Purpose
 *	The hardware CPU - SAS interface
 *
 *! (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/*===========================================================================*/

extern void  a3_cpu_reset IPT0 ();
extern void  intl_cpu_init IPT1 (IU32, size);
extern IBOOL hg_protect_memory IPT3 (IU32, address, IU32, size, IU32, access);

extern void hh_enable_20_bit_wrapping IPT0 ();
extern void hh_disable_20_bit_wrapping IPT0 ();

extern void m_set_sas_base IPT1 (IHP, address);

/*===========================================================================*/
/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hfx.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: hfx.h
 *
 * Description	: Definitions and external declarations for HFX.
 *
 * Author	: J. Koprowski + L. Dworkin
 *
 * Sccs ID	: @(#)hfx.h	1.32 05/24/95
 *
 * Notes	:
 *
 * Mods		:
 */

#ifdef HFX

#ifdef SCCSID
/* static char SccsID[]="@(#)hfx.h	1.32 05/24/95 Copyright Insignia Solutions Ltd."; */
#endif

/****************************************************************/
/*								*/
/*           Redirector type definitions and constants.         */
/*								*/
/****************************************************************/
/*
 * Redirector CDS or current directory structure.
 */
#define DIRSTRLEN	(64+3)
#define TEMPLEN		(DIRSTRLEN*2)

typedef struct {
	char	curdir_text[DIRSTRLEN];	/* text of assignment and curdir */
	word		curdir_flags;	/* various flags */
	double_word	curdir_devptr;	/* local pointer to DPB or net device */
	word		curdir_id;	/* cluster of current dir (net ID) */
	word		whoknows;
	word		curdir_user_word;
	word		curdir_end;	/* end of assignment */
} CDS;

/* Flag word masks */
#define curdir_isnet	0x8000
#define curdir_inuse	0x4000
#define curdir_splice	0x2000
#define curdir_local	0x1000
#define curdir_sharing	0x0800
#define curdir_iscdrom	0x0080	/* this works with MSCDEX 2.20 */

/* The location of the fake IFS header we place in ROM */
/* to make DOS 4.01 happy. */

#define	IFS_SEG	0xf000
#define IFS_OFF	0x6000

#define REDIRIN	0x8
#define RECVRIN 0x80
#define MSNGRIN	0x4
#define SRVRIN	0x40

#ifndef PROD
extern IU32 severity;
#include "trace.h"

#define DEBUG_INPUT	0x1
#define DEBUG_REG	0x2
#define DEBUG_FUNC	0x4
#define DEBUG_HOST	0x8
#define DEBUG_INIT	0x10
#define DEBUG_CHDIR	0x20
#define hfx_trace0(trace_bit,str)	if(severity&trace_bit){fprintf(trace_file,str);}
#define hfx_trace1(trace_bit,str,p1)	if(severity&trace_bit){fprintf(trace_file,str,p1);}
#define hfx_trace2(trace_bit,str,p1,p2)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2);}
#define hfx_trace3(trace_bit,str,p1,p2,p3)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2,p3);}
#define hfx_trace4(trace_bit,str,p1,p2,p3,p4)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2,p3,p4);}
#else
#define hfx_trace0(trace_bit,str)
#define hfx_trace1(trace_bit,str,p1)
#define hfx_trace2(trace_bit,str,p1,p2)
#define hfx_trace3(trace_bit,str,p1,p2,p3)
#define hfx_trace4(trace_bit,str,p1,p2,p3,p4)
#endif /* !PROD */

typedef struct {
	double_word	SFLink;
	word		SFCount;
	word		SFTable;
} SF;

typedef struct {
	word		sf_ref_count;
	word		sf_mode;
	half_word	sf_attr;
	word		sf_flags;
	double_word	sf_devptr;
	word		sf_firclus;
	word		sf_time;
	word		sf_date;
	double_word	sf_size;
	double_word	sf_position;
	word		sf_cluspos;
	word		sf_dirsecl;
	word		sf_dirsech; /* Grew to 32 bits in DOS 4+ */
	half_word	sf_dirpos;
	half_word	sf_name[11];
	double_word	sf_chain;
	word		sf_UID;
	word		sf_PID;
	word		sf_MFT;
/*
 * New DOS 4+ fields. lst_clus field moved down here
 * because dirsec field grew to 32 bits.
 */
	word		sf_lst_clus;/* moved down */
	double_word	sf_ifs;		/* file is in this file sys */
} sf_entry;

#define SF_REF_COUNT 	sft_ea + 0
#define SF_MODE		sft_ea + 2
#define SF_ATTR		sft_ea + 4
#define SF_FLAGS	sft_ea + 5
#define SF_DEVPTR	sft_ea + 7
#define SF_FIRCLUS	sft_ea + 11	/* 0xb */
#define SF_TIME		sft_ea + 13	/* 0xd */
#define SF_DATE		sft_ea + 15	/* 0xf */
#define SF_SIZE		sft_ea + 17	/* 0x11 */
#define SF_POSITION	sft_ea + 21	/* 0x15 */
#define SF_CLUSPOS	sft_ea + 25	/* 0x19 */
#define SF_DIRSECL	sft_ea + 27	/* 0x1b */
#define SF_DIRSECH	sft_ea + 29	/* 0x1d */
#define SF_DIRPOS	sft_ea + 31	/* 0x1f */
#define SF_NAME		sft_ea + 32	/* 0x20 */
#define SF_CHAIN	sft_ea + 43	/* 0x2b */
#define SF_UID		sft_ea + 47	/* 0x2f */
#define SF_PID		sft_ea + 49	/* 0x31 */
#define SF_MFT		sft_ea + 51	/* 0x33 */
#define SF_LST_CLUS	sft_ea + 53 /* 0x35 - moved down here for DOS 4+ */
#define SF_IFS		sft_ea + 55 /* 0x37 */

#define SF_NET_ID SF_CLUSPOS

#define sf_default_number 0x5
#define sf_busy 0xffff
#define sf_free 0

#define sf_isfcb 0x8000
#define sf_isnet 0x8000
#define sf_close_nodate 0x4000
#define sf_pipe 0x2000
#define sf_no_inherit 0x1000
#define sf_net_spool 0x0800

#define devid_file_clean	0x40
#define devid_file_mask_drive	0x3f

#define devid_device		0x80
#define devid_device_EOF	0x40
#define devid_device_raw	0x20
#define devid_device_special	0x10
#define devid_device_clock	0x08
#define devid_device_null	0x04
#define devid_device_con_out	0x02
#define devid_device_con_in	0x01

#define devid_block_dev		0x1f

/* file modes */
#define access_mask	0x0f
#define open_for_read	0x00
#define open_for_write	0x01
#define open_for_both	0x02

#define sharing_mask		0xf0
#define sharing_compat		0x00
#define sharing_deny_both	0x10
#define sharing_deny_write	0x20
#define sharing_deny_read	0x30
#define sharing_deny_none	0x40
#define sharing_net_FCB		0x70
#define sharing_no_inherit	0x80

/*
 * DOS 4+ Extended Open "Does exist" & "Doesn't exist" action values.
 */

#define DX_MASK		0x03
#define DX_FAIL		0x00
#define DX_OPEN		0x01
#define DX_REPLACE	0x02

#define NX_MASK		0x30
#define NX_FAIL		0x00
#define NX_CREATE	0x10

/*
 * DOS error codes.
 * N.B. error_not_error is specific to this implementation, although
 * DOS assumes an error return of zero equals success.
 */
#define error_not_error			0
#define error_invalid_function		1
#define error_file_not_found		2
#define error_path_not_found		3
#define error_too_many_open_files	4
#define error_access_denied		5
#define error_invalid_handle		6
#define error_arena_trashed		7
#define error_not_enough_memory		8
#define error_invalid_block		9
#define error_bad_environment		10
#define error_bad_format		11
#define error_invalid_access		12
#define error_invalid_data		13
#define error_reserved			14
#define error_invalid_drive		15
#define error_current_directory		16
#define error_not_same_device		17
#define error_no_more_files		18

/* These are the universal int 24 mappings for the old INT 24 set of errors */
#define error_write_protect		19
#define error_bad_unit			20
#define error_not_ready			21
#define error_bad_command		22
#define error_CRC			23
#define error_bad_length		24
#define error_Seek			25
#define error_not_DOS_disk		26
#define error_sector_not_found		27
#define error_out_of_paper		28
#define error_write_fault		29
#define error_read_fault		30
#define error_gen_failure		31

/* These are the new 3.0 error codes reported through INT 24 */
#define error_sharing_violation		32
#define error_lock_violation		33
#define error_wrong_disk		34
#define error_FCB_unavailable		35
#define error_sharing_buffer_exceeded	36

/* New OEM network-related errors are 50-79 */
#define error_not_supported		50

/* End of INT 24 reportable errors */
#define error_file_exists		80
#define error_DUP_FCB			81
#define error_canot_make		82
#define error_FAIL_I24			83

/* New 3.0 network related error codes */
#define error_out_of_structures		84
#define error_Already_assigned		85
#define error_invalid_password		86
#define error_invalid_parameter		87
#define error_NET_write_fault		88
/*
 * error_is_not_directory is a code specific to this implementation.
 * It enables more code to be put in the base.
 */
#define error_is_not_directory		89

/* Interrupt 24 error codes */
#define error_I24_write_protect		0
#define error_I24_bad_unit		1
#define error_I24_not_ready		2
#define error_I24_bad_command		3
#define error_I24_CRC			4
#define error_I24_bad_length		5
#define error_I24_Seek			6
#define error_I24_not_DOS_disk		7
#define error_I24_sector_not_found	8
#define error_I24_out_of_paper		9
#define error_I24_write_fault		0xa
#define error_I24_read_fault		0xb
#define error_I24_gen_failure		0xc
/* NOTE: Code 0xD is used by MT-DOS */
#define error_I24_wrong_disk		0xf

/* The following are masks for the AH register on Int 24 */
#define Allowed_FAIL			0x08
#define Allowed_RETRY			0x10
#define Allowed_IGNORE			0x20
/* Note: ABORT is always allowed */

#define I24_operation			0x1	/* Z if READ, NZ if WRITE */
#define I24_area			0x6	/* 00 if DOS
						 * 01 if FAT
						 * 10 if root DIR
						 * 11 if DATA */
#define I24_class			0x80	/* Z if DISK, NZ if FAT */

/*
 * The following are offsets within the fifty three byte structure that
 * is used by search first and search next operations.
 */
#define DMA_DRIVE_BYTE 0
#define DMA_SEARCH_NAME 1
#define DMA_SATTRIB 12
#define DMA_LASTENT 13
#define DMA_DIRSTART 15
#define DMA_LOCAL_CDS 17
#define DMA_UNKNOWN 19
#define DMA_NAME 21
#define DMA_ATTRIBUTES 32
#define DMA_TIME 43
#define DMA_DATE 45
#define DMA_CLUSTER 47
#define DMA_FILE_SIZE 49

/*
 * DOS access masks used by create and open.
 */
#define open_for_read	0x00
#define open_for_write	0x01
#define open_for_both	0x02

/*
 * DOS file attribute masks.
 */
#define attr_read_only	0x1
#define attr_hidden	0x2
#define attr_system	0x4
#define attr_volume_id	0x8
#define attr_directory	0x10
#define attr_archive	0x20
#define attr_device	0x40

#define attr_bad	0x80
#define attr_good	0x7f

#define attr_all	(attr_hidden|attr_system|attr_directory)
#define attr_ignore	(attr_read_only|attr_archive|attr_device)
#define attr_changeable (attr_read_only|attr_hidden|attr_system|attr_archive)

/*
 * Disk information structure used by NetDiskInfo in the base,
 * and host_diskinfo.
 */
typedef struct
{
	double_word total_clusters;	/* Total number of blocks. */
	double_word clusters_free;	/* Total number of blocks free. */
	double_word bytes_per_sector;
	double_word sectors_per_cluster;
} DOS_DISK_INFO;

/*
 * Non-alphabetic DOS legal characters.  !! Needs checking. !!
 */
#define NON_ALPHA_DOS_CHARS "01234567890_-@$%^&!#{}()~`'"

/*
 * DOS file name length limits.
 */
#define MAX_DOS_NAME_LENGTH 8
#define MAX_DOS_EXT_LENGTH 3
#define MAX_DOS_FULL_NAME_LENGTH 12

/* defines for host_lseek "whence" */
#define REL_START 0
#define REL_CUR 1
#define REL_EOF 2

/****************************************************************/
/*								*/
/*		 HFX directory details structure.		*/
/*								*/
/****************************************************************/

typedef struct hfx_found_dir_entry
{
	half_word			attr;
	CHAR				*host_name;
	CHAR				*dos_name;
	LONG				direntry;
	struct hfx_found_dir_entry	*next;
} HFX_FOUND_DIR_ENT;

/*
 * This structure is actually host specific because of the 
 * HFX_DIR field which is defined in host_hfx.h and which must 
 * therefore be included prior to this file.
 */

typedef struct hfx_direntry
{
	HOST_DIR			*dir;
	CHAR				*name;
	CHAR				*template;
	LONG				direntry;
	HFX_FOUND_DIR_ENT		*found_list_head;
	HFX_FOUND_DIR_ENT		*found_list_curr;
	BOOL				first_find;
	struct hfx_direntry		*next;
	struct hfx_direntry		*last;
	half_word			search_attr;

	/* AJO 26/11/92
	 * The following is required to support architectures where
	 * pointers are longer than 32 bits.
	 */
#if LONG_SHIFT > 2
	IU32				id;
#endif /* LONG_SHIFT > 2 */
} HFX_DIR;

/****************************************************************/
/*								*/
/*		 External function declarations.		*/
/*								*/
/****************************************************************/
/*
 * Functions for generating mapped file extensions.
 */
extern unsigned short calc_crc	IPT2(unsigned char *, host_name,
	unsigned short, name_length);
extern void crc_to_str	IPT2(unsigned short, crc, unsigned char *, extension);

/*
 * Functions for retrieving system variables used by the redirector.
 */
extern void cds_info	IPT3(word, seg, word, off, int, num_cds_entries);
extern void sft_info	IPT2(word, seg, word, off);
extern double_word get_wfp_start	IPT0();
extern word get_curr_dir_end	IPT0();
extern double_word get_thiscds	IPT2(word *, seg, word *, off);
extern double_word get_thissft	IPT0();
extern double_word get_es_di	IPT0();
extern double_word get_ds_si	IPT0();
extern double_word get_ds_dx	IPT0();
extern half_word get_sattrib	IPT0();
extern double_word get_ren_wfp	IPT0();
extern double_word get_dmaadd	IPT1(int, format);
extern word get_current_pdb	IPT0();
extern double_word get_sftfcb	IPT0();
extern char *get_hfx_root	IPT1(half_word, hfx_entry);
extern char *get_hfx_global	IPT1(half_word, hfx_entry);
extern validate_hfxroot	IPT1(char *, path);
extern void hfx_root_changed	IPT1(char *, name);
extern word get_xoflag	IPT0();
extern void set_usercx	IPT1(word, cx);

/*
 * Redirector net functions.
 */
extern word NetInstall	IPT0();
extern word NetRmdir	IPT0();
extern word NetMkdir	IPT0();
extern word NetChdir	IPT0();
extern word NetClose	IPT0();
extern word NetCommit	IPT0();
extern word NetRead	IPT0();
extern word NetWrite	IPT0();
extern word NetLock	IPT0();
extern word NetUnlock	IPT0();
extern word NetDiskInfo	IPT0();
extern word NetSet_file_attr	IPT0();
extern word NetGet_file_info	IPT0();
extern word NetRename	IPT0();
extern word NetDelete	IPT0();
extern word NetOpen	IPT0();
extern word NetCreate	IPT0();
extern word NetSeq_search_first	IPT0();
extern word NetSeq_search_next	IPT0();
extern word NetSearch_first	IPT0();
extern word NetSearch_next	IPT0();
extern word NetAbort	IPT0();
extern word NetAssoper	IPT0();
extern word NetPrinter_Set_String	IPT0();
extern word NetFlush_buf	IPT0();
extern word NetLseek	IPT0();
extern word NetReset_Env	IPT0();
extern word NetSpool_check	IPT0();
extern word NetSpool_close	IPT0();
extern word NetSpool_oper	IPT0();
extern word NetSpool_echo_check	IPT0();
extern word NetUnknown	IPT0();
extern word NetExtendedAttr	IPT0();
extern word NetExtendedOpen	IPT0();

/*
 * Redirector as called by BOP 2F instruction.
 */
extern void redirector	IPT0();

/*
 * Base utility functions found in hfx_util.c.
 */
extern void pad_filename	IPT2(unsigned char *, instr,
	unsigned char *, outstr);
extern void unpad_filename	IPT2(unsigned char *, iname,
	unsigned char *, oname);
extern boolean match	IPT7(unsigned char *, host_path,
	unsigned char *, template, half_word, sattrib, int, init,
	unsigned char *, host_name, unsigned char *, dos_name,
	half_word *, attr);
extern int find	IPT7(HFX_DIR *, dir_ptr, unsigned char *, template,
	half_word, sattrib, unsigned char *, host_name,
	unsigned char *, dos_name, half_word *, attr, int, last_addr);
extern void cleanup_dirlist	IPT0();
extern boolean is_open_dir	IPT1(HFX_DIR *, dir_ptr);
extern void tidy_up_dirptr	IPT0();
extern void rm_dir	IPT1(HFX_DIR *, dir_ptr);

#if LONG_SHIFT > 2
/* AJO 26/11/92
 * Additional base utility functions required for architectures with pointers
 * longer than 32bits; found in hfx_util.c.
 */
extern HFX_DIR *hfx_get_dir_from_id IPT1 (IU32, hfx_dir_id);
#endif /* LONG_SHIFT > 2 */

/*
 * Base functions found in hfx_share.c.
 */
extern word check_access_sharing	IPT3(word, fd, half_word, a_s_m,
	boolean, rdonly);

/*
 * Base functions found in redirect.c.
 */
extern int net_use	IPT2( half_word, drive, char *, name );
extern int net_change	IPT2( half_word, drive, char *, name );
extern IBOOL is_global_hfx_drive	IPT1( half_word, hfx_entry);
extern int get_lastdrive	IPT0();
extern half_word get_current_drive IPT0();
extern VOID resolve_any_net_join IPT2(CHAR *,dos_path_in,CHAR *,dos_path_out);

extern BOOL cds_is_sharing IPT1(CHAR *, dos_path);

/*
 * Host functions in xxx_hfx.c called from HFX.
 */
extern void host_concat	IPT3(unsigned char *, path, unsigned char *, name,
	unsigned char *, result);
extern word host_create	IPT4(unsigned char *, name, word, attr,
	half_word, create_new, word *, fd);
extern void host_to_dostime	IPT3(time_t, secs_since_70, word *, date,
	word *, time);
extern time_t host_get_datetime	IPT2(word *, date, word *, thetime);
extern int host_set_time	IPT2(word, fd, time_t, hosttime);
extern word host_open	IPT6(unsigned char *, name, half_word, attrib,
	word *, fd, double_word *, size, word *, date, word *, thetime);
extern word host_truncate	IPT2(word, fd, long, size);
extern word host_close	IPT1(word, fd);
extern word host_commit	IPT1(word, fd);
extern word host_write	IPT4(word, fd, unsigned char *, buf, word, num,
	word *, count);
extern word host_read	IPT4(word, fd, unsigned char *, buf, word, num,
	word *, count);
extern word host_delete	IPT1(unsigned char *, name);
extern word host_rename	IPT2(unsigned char *, from, unsigned char *, to);
extern half_word host_getfattr	IPT1(unsigned char *, name);
extern word host_get_file_info	IPT4(unsigned char *, name, word *, thetime,
	word *, date, double_word *, size);
extern word host_set_file_attr	IPT2(unsigned char *, name, half_word, attr);
extern word host_lseek	IPT4(word, fd, double_word, offset, int, whence,
	double_word *, position);
extern word host_lock	IPT3(word, fd, double_word, start, double_word, length);
extern word host_unlock	IPT3(word, fd, double_word, start, double_word, length);
extern int host_check_lock	IPT0();
extern void host_disk_info	IPT2(DOS_DISK_INFO *, disk_info, int, drive);
extern word host_rmdir	IPT1(unsigned char *, host_path);
extern word host_mkdir	IPT1(unsigned char *, host_path);
extern word host_chdir	IPT1(unsigned char *, host_path);
extern void host_get_volume_id	IPT2(unsigned char *, net_path,
	unsigned char *, volume_id);
extern word host_gen_err	IPT1(int, the_errno);
extern void init_fd_hname	IPT0();

#ifndef	host_opendir
extern HOST_DIR *host_opendir	IPT1(const char *, host_path);
#endif	/* host_opendir */

#ifndef	host_readdir
extern struct host_dirent *host_readdir	IPT1(HOST_DIR *, dirp);
#endif	/* host_readdir */

#ifndef	host_access
extern int host_access	IPT2(unsigned char *, host_name, int, mode);
#endif	/* host_access */

extern CHAR *host_machine_name IPT0();
extern CHAR *host_get_file_name IPT1(CHAR *,pathname);
extern CHAR *host_make_file_path IPT3(CHAR *,buf, CHAR *,dirname,
                                     CHAR *,filename);
extern time_t host_dos_to_host_time IPT2( IU16, date, IU16, time );

#ifndef hfx_rename
extern INT hfx_rename IPT2(CHAR *,from, CHAR *,to);
#endif	/* hfx_rename */




/*
 * Host functions in xxx_map.c.
 */
extern int host_map_file	IPT4(unsigned char *, host_name,
	unsigned char *, match_name, unsigned char *, dos_name,
	unsigned char *, curr_dir);
extern boolean host_validate_path	IPT4(unsigned char *, net_path,
	word *, start_pos, unsigned char *, host_path, word, new_file);
extern void host_get_net_path	IPT3(unsigned char *, net_path,
	unsigned char *, original_dos_path, word *, start_pos);

/*
 * Host functions in xxx_unix.c or equivalent.
 */
extern boolean host_file_is_directory	IPT1(char *, name);
extern boolean host_validate_pathname	IPT1(char *, name);
extern boolean host_check_read_access	IPT1(char *, name);

extern half_word dos_ver;

/*
 * The following are constants associated with redirector system
 * variables.  However, their location varies between DOS versions
 * three and four, so variables need to be used.
 */
extern word DMAADD;
extern word CurrentPDB;
extern word SATTRIB;
extern word THISSFT;
extern word THISCDS;
extern word WFP_START;
extern word REN_WFP;
extern word CURR_DIR_END;
extern word SFT_STRUCT_LENGTH;

/* ================================================================== */

/*
   Instance Variables for HFX Driver, ie those variables which must
   be set up for each Virtual Machine under Windows 3.x. The NIDDB
   Manager (cf virtual.c) basically forces us to define these in one
   memory area.
 */

/* The instance structure (All variables tagged HFX_IN_) */
typedef struct
   {
   half_word HFX_IN_primary_drive;
   char **   HFX_IN_hfx_root_dir;
   int       HFX_IN_num_hfx_drives;   /* no. of hfx drives in use */
   int       HFX_IN_max_hfx_drives;   /* no. of possible drives to use */
   word      HFX_IN_old_flags[26];
   BOOL      HFX_IN_inDOS;
   BOOL      HFX_IN_HfxInstalled;     /* DOS has HFX driver (FSADRIVE) installed */

   /*
      Holds whether a drive is case sensitive or not, each drive masked
      in:  0 = case sensitive
           1 = case insensitive
    */
   IU32      HFX_IN_case_sense;

   /*
      Holds whether the default case for file names should be upper or lower
      case: 0 = lower case
            1 = upper case
    */
   IU32	     HFX_IN_upper_case;

   /*
      Holds whether the drive is in global use by hfx:
			0 = not in use by hfx
            1 = in use by hfx
    */
   IU32	     HFX_IN_global_hfx_drive;

   /*
      Holds the drive number related to the current HFX operation,
      setup in test_for_us().
    */
   IU8       HFX_IN_curr_driveno;
   HOST_DIR  *HFX_IN_this_dir;
   HFX_DIR   *HFX_IN_head_dir_ptr;
   HFX_DIR   *HFX_IN_tail_dir_ptr;
   UTINY     HFX_IN_current_dir[MAX_PATHLEN];   /* UNIX HOST requirement */
   } HFX_INSTANCE_DATA, **HFX_INSTANCE_DATA_HANDLE;

IMPORT HFX_INSTANCE_DATA_HANDLE hfx_handle;

/* Define access to instance variables via handle */
#define primary_drive  ((*hfx_handle)->HFX_IN_primary_drive)
#define hfx_root_dir   ((*hfx_handle)->HFX_IN_hfx_root_dir)
#define num_hfx_drives ((*hfx_handle)->HFX_IN_num_hfx_drives)
#define max_hfx_drives ((*hfx_handle)->HFX_IN_max_hfx_drives)
#define old_flags      ((*hfx_handle)->HFX_IN_old_flags)
#define inDOS          ((*hfx_handle)->HFX_IN_inDOS)
#define HfxInstalled   ((*hfx_handle)->HFX_IN_HfxInstalled)
#define case_sense     ((*hfx_handle)->HFX_IN_case_sense)
#define upper_case     ((*hfx_handle)->HFX_IN_upper_case)
#define global_hfx_drive      ((*hfx_handle)->HFX_IN_global_hfx_drive)
#define curr_driveno   ((*hfx_handle)->HFX_IN_curr_driveno)
#define this_dir       ((*hfx_handle)->HFX_IN_this_dir)
#define head_dir_ptr   ((*hfx_handle)->HFX_IN_head_dir_ptr)
#define tail_dir_ptr   ((*hfx_handle)->HFX_IN_tail_dir_ptr)
#define current_dir    ((*hfx_handle)->HFX_IN_current_dir)

/* ================================================================== */

enum
{
	DRIVE_FREE,
	DRIVE_RESERVED,
	DRIVE_INUSE
};

typedef	IU8	drv_stat;

IMPORT drv_stat	get_hfx_drive_state	IPT1(IU8, drive);
IMPORT void		set_hfx_drive_state	IPT2(IU8, drive, drv_stat, state);


#ifdef SWIN_HFX
/*
 *	Function called by Softwindows to check for network files, and
 *	function called by it to open a file.
 */

extern IBOOL Hfx_is_net_file IPT1(sys_addr, fname);
extern IU32 Hfx_open_file IPT7(IU8, function, IU8, flags, sys_addr, fname, IU16 *,fd_p, IU16 *, date, IU16 *, time, IBOOL *, rdonly);
extern IU32 Hfx_file_exists IPT1(sys_addr, fname);

/*
 *	An additional "unix like" file function, to duplicate a file handle.
 *	Returns -1 on failure.
 */

extern IS16 host_duph IPT1(IS16, oldHandle);

#endif /* SWIN_HFX */
#endif /* HFX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hg_cpu.h ===
/*===========================================================================*/

/*[
 * File Name		: hg_cpu.h
 *
 * Derived From		:
 *
 * Author		: Jane Sales
 *
 * Creation Date	: 20th July, 1992
 *
 * SCCS Version		: @(#)hg_cpu.h	1.2 08/19/94
 *!
 * Purpose
 *	This module contains the interface between the various modules of
 *	the hardware assisted CPU.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
]*/

/*===========================================================================*/

struct h_cpu_registers
	{
	IU32	GDT_base;
	IU16	GDT_limit;
	IU32	IDT_base;
	IU16	IDT_limit;
	IU32	LDT_base;
	IU16	LDT_limit;
	IU16	LDT_selector;
	IU32	TR_base;
	IU16	TR_limit;
	IU16	TR_selector;
	IU16	CS_limit;
	IU8		CS_ar;
	IU16	DS_limit;
	IU8		DS_ar;
	IU16	ES_limit;
	IU8		ES_ar;
	IU16	SS_limit;
	IU8		SS_ar;
	IU16	FS_limit;
	IU8		FS_ar;
	IU16	GS_limit;
	IU8		GS_ar;
	IU8		CPL;
	IU32	CR1;
	IU32	CR2;
	IU32	DR0;
	IU32	DR1;
	IU32	DR2;
	IU32	DR3;
	IU32	DR4;
	IU32	DR5;
	IU32	DR6;
	IU32	DR7;
	IU32	TR3;
	IU32	TR4;
	IU32	TR5;
	IU32	TR6;
	IU32	TR7;
	struct  hh_regs  *tp;		/* in hh_regs.h								*/	
	};

/*==========================================================================*/
/* macros for accessing registers in h_cpu_registers                        */
/* Intel ports only, so these endian macros should be OK 					*/

union bregs
	{
	ULONG  h_l;
	USHORT h_w[2];
	UTINY  h_c[4];
	};		
#define	WORD(n, v)	((*((union bregs *)(&v))).h_w[n])
#define	BYTE(n, v)	((*((union bregs *)(&v))).h_c[n])

#define EAX(c)	(((c)->tp)->t_eax)
#define AX(c)	WORD(0, ((c)->tp)->t_eax)
#define AH(c)	BYTE(1, ((c)->tp)->t_eax)
#define AL(c)	BYTE(0, ((c)->tp)->t_eax)
#define EBX(c)	(((c)->tp)->t_ebx)
#define BX(c)	WORD(0, ((c)->tp)->t_ebx)
#define BH(c)	BYTE(1, ((c)->tp)->t_ebx)
#define BL(c)	BYTE(0, ((c)->tp)->t_ebx)
#define ECX(c)	(((c)->tp)->t_ecx)
#define CX(c)	WORD(0, ((c)->tp)->t_ecx)
#define CH(c)	BYTE(1, ((c)->tp)->t_ecx)
#define CL(c)	BYTE(0, ((c)->tp)->t_ecx)
#define EDX(c)	(((c)->tp)->t_edx)
#define DX(c)	WORD(0, ((c)->tp)->t_edx)
#define DH(c)	BYTE(1, ((c)->tp)->t_edx)
#define DL(c)	BYTE(0, ((c)->tp)->t_edx)
#define DS(c)	WORD(0, ((c)->tp)->t_ds)
#define ES(c)	WORD(0, ((c)->tp)->t_es)
#define SS(c)	WORD(0, ((c)->tp)->t_ss)
#define CS(c)	WORD(0, ((c)->tp)->t_cs)
#define FS(c)	WORD(0, ((c)->tp)->t_fs)
#define GS(c)	WORD(0, ((c)->tp)->t_gs)
#define ESI(c)	(((c)->tp)->t_esi)
#define SI(c)	WORD(0, ((c)->tp)->t_esi)
#define EDI(c)	(((c)->tp)->t_edi)
#define DI(c)	WORD(0, ((c)->tp)->t_edi)
#define EFL(c)	(((c)->tp)->t_eflags)
#define FL(c)	WORD(0, ((c)->tp)->t_eflags)
#define IP(c)	WORD(0, ((c)->tp)->t_eip)
#define EIP(c)	(((c)->tp)->t_eip)
#define ESP(c)	(((c)->tp)->t_esp)
#define SP(c)	WORD(0, ((c)->tp)->t_esp)
#define EBP(c)	(((c)->tp)->t_ebp)
#define BP(c)	WORD(0, ((c)->tp)->t_ebp)
#define CR0(c)	(((c)->tp)->t_cr0)
#define MSW(c)	WORD(0, ((c)->tp)->t_cr0)

#define GDT_base(c)	((c)->GDT_base)
#define GDT_limit(c)	((c)->GDT_limit)
#define IDT_base(c)	((c)->IDT_base)
#define IDT_limit(c)	((c)->IDT_limit)
#define LDT_base(c)	((c)->LDT_base)
#define LDT_limit(c)	((c)->LDT_limit)
#define LDT_selector(c)	((c)->LDT_selector)
#define TR_base(c)	((c)->TR_base)
#define TR_limit(c)	((c)->TR_limit)
#define TR_selector(c)	((c)->TR_selector)
#define CS_ar(c)	((c)->CS_ar)
#define CS_limit(c)	((c)->CS_limit)
#define DS_ar(c)	((c)->DS_ar)
#define DS_limit(c)	((c)->DS_limit)
#define ES_ar(c)	((c)->ES_ar)
#define ES_limit(c)	((c)->ES_limit)
#define SS_ar(c)	((c)->SS_ar)
#define SS_limit(c)	((c)->SS_limit)
#define FS_ar(c)	((c)->FS_ar)
#define FS_limit(c)	((c)->FS_limit)
#define GS_ar(c)	((c)->GS_ar)
#define GS_limit(c)	((c)->GS_limit)
#define CPL(c)	((c)->CPL)
#define CR1(c)	((c)->CR1)
#define CR2(c)	((c)->CR2)

/*===========================================================================*/
/* Bit definitions                                                           */

/* CR0 register */

#define M_PE	0x0001		/* Protection enable 		*/
#define M_MP	0x0002		/* Maths present			*/
#define M_EM	0x0004		/* Emulation				*/
#define M_TS	0x0008		/* Task switched			*/
#define M_ET	0x0010		/* Extension type			*/
#define M_NE	0x0020		/* Numeric error			*/
#define M_WP	0x0100		/* Write protect			*/
#define M_AM	0x0400		/* Alignment mask			*/
#define M_NW	0x2000		/* Not write-through		*/
#define M_CD	0x4000		/* Cache disable			*/
#define M_PG	0x8000		/* Paging					*/

/* EFLAGS register */

#define	PS_C		0x0001		/* carry bit				*/
#define	PS_P		0x0004		/* parity bit				*/
#define	PS_AC		0x0010		/* auxiliary carry bit		*/
#define	PS_Z		0x0040		/* zero bit					*/
#define	PS_N		0x0080		/* negative bit				*/
#define	PS_T		0x0100		/* trace enable bit			*/
#define	PS_IE		0x0200		/* interrupt enable bit		*/
#define	PS_D		0x0400		/* direction bit			*/
#define	PS_V		0x0800		/* overflow bit				*/
#define	PS_IOPL		0x3000		/* I/O privilege level		*/
#define	PS_NT		0x4000		/* nested task flag			*/
#define	PS_RF		0x10000		/* Reset flag				*/
#define	PS_VM		0x20000		/* Virtual 86 mode flag		*/

#define HWCPU_POSSIBLE		0	/* Emulation can continue					*/
#define HWCPU_FAIL			1	/* O/S wouldn't run pc code					*/
#define HWCPU_HALT			2	/* HALT opcode executed						*/
#define HWCPU_IMPOSSIBLE	3	/* illegal opcode encountered				*/

#define HWCPU_TICKS			20	/* ticks per second							*/

typedef void (h_exception_handler_t) IPT2 (IU32, h_exception_num, IU32, h_error_code_t);
typedef void (COMMS_CB) IPT1(long, dummy);
extern VOID  (*Hg_spc_entry) IPT0();
extern IBOOL (*Hg_spc_async_entry) IPT0();
extern VOID  (*Hg_spc_return) IPT0();
extern IBOOL Hg_SS_is_big;
/*===========================================================================*/
/* functions                                                                 */

extern struct	hh_regs *hh_cpu_init IPT2 (IU32, size, IU32, monitor_address);
extern IS16		hh_cpu_simulate IPT0();
extern void		hh_mark_cpu_state_invalid IPT0();
extern void		hh_pm_pc_IDT_is_at IPT2 (IU32, address, IU32, length);
extern void		hh_LDT_is_at IPT2 (IU32, address, IU32, length);
extern IU32		hh_cpu_calc_q_ev_inst_for_time IPT1 (IU32, time);
extern IBOOL	hh_protect_memory IPT3 (IU32, address, IU32, size, IU32, access);
extern IBOOL	hh_set_intn_handler IPT2 (IU32, hh_int_num, h_exception_handler_t, hh_intn_handler);
extern IBOOL	hh_set_fault_handler IPT2 (IU32, hh_fault_num, h_exception_handler_t, hh_fault_handler);
extern VOID		hh_enable_IF_checks IPT1(IBOOL, whenPM);
extern IU32		hh_resize_memory IPT1(IU32, size);
extern VOID		hh_save_npx_state IPT1(IBOOL, reset);
#ifdef LIM
extern IU32	hh_LIM_allocate IPT2(IU32, n_pages, IHP *, addr);
extern IU32	hh_LIM_map IPT3(IU32, block, IU32, length, IHP, dst_addr);
extern IU32	hh_LIM_unmap IPT2(IHP, src_addr, IU32, length);
extern IU32	hh_LIM_deallocate IPT0();
#endif /* LIM */
extern VOID		hh_restore_npx_state IPT1(IBOOL, do_diff);
#ifndef PROD
extern void		hh_enable_slow_mode IPT0();
#endif /* PROD */
extern void		hh_cpu_terminate IPT0();

extern VOID		hg_resize_memory IPT1(IU32, size);
extern void		hg_os_bop_handler IPT1 (unsigned int, BOPNum);
extern void		hg_fault_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_1_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_6_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_10_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_13_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_14_handler IPT2 (IU32, fault_num, IU32, error_code);

/* The fpu fault handler (16) catches FPU exceptions, and generates SoftPC */
/* interrupt ( 0x75 ) which corresponds to IRQ13. */
extern void 	hg_fpu_fault_handler IPT2 (IU32, fault_num, IU32, error_code);

extern IU32		hg_callback_handler IPT1 (IU32, status);

extern VOID		hg_set_default_fault_handler IPT2(IU32, hg_fault_num,
					h_exception_handler_t, hg_handler);
extern IBOOL		hg_set_intn_handler IPT2 (IU32, interrupt_number,
					h_exception_handler_t *, function);
extern IBOOL		hg_set_fault_handler IPT2 (IU32, exception_number,
					h_exception_t *, function);
#ifdef IRET_HOOKS
extern void		hg_add_comms_cb IPT2(COMMS_CB, next_batch, IUS32, timeout);
#endif

extern VOID		host_display_win_logo IPT0 ();

/*===========================================================================*/
/* the data itself                                                           */

extern struct	h_cpu_registers *Cp;	
extern IBOOL	H_trace;

/*
 * We need to know if Windows is running as the fault handling is different
 * if it is. The variable is set/unset by BOPs inserted into our
 * modified DOSX, and by hg_cpu_reset.
 */
extern	IBOOL	H_windows;
extern	IBOOL 	H_regs_changed;

extern	IU32	Pc_timeout;			/* Value to return in if q_ev pending	*/
extern	IU32	Pc_q_ev_dec;		/* Chunk to dec q_ev counter by			*/

extern	IU32	Pc_woken;			/* Reason callback handler was called	*/
extern	IU32	Pc_timeout;
extern	IU32	Pc_if_set;
extern	IU32	Pc_tick;

extern	IU32	Pc_run_timeout;		/* Parameters "to" pc_run				*/
extern	IU32	Pc_run_option_none;
extern	IU32	Pc_run_if_set;
extern	IU32	Pc_run_pm_if_set;
extern	IU32	Pc_run_tick;

extern	IU32	Pc_prot_none;		/* Memory protection values				*/
extern	IU32	Pc_prot_read;
extern	IU32	Pc_prot_write;
extern	IU32	Pc_prot_execute;

extern	IU32	Pc_success;
extern	IU32	Pc_no_space;
extern	IU32	Pc_invalid_address;
extern	IU32	Pc_failure;
extern	IU32	Pc_invalid_argument;


/*===========================================================================*/
/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: host.h
 *
 * Description	: Host specific declarations for the machine dependant
 *		  modules of SoftPC. THIS IS A BASE INCLUDE FILE
 *
 * Author	: Henry Nash
 *
 * Notes	: Everything in here must portable !!!
 */

/* SccsID[]="@(#)host.h	1.6 09/14/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef PC_CONFIG
extern void pc_config();	
#endif

IMPORT	VOID	host_flip_real_floppy_ind IPT2(int, drive, BOOL, active);


extern void host_floppy_init();
extern void host_floppy_term();
extern void host_reset();

extern boolean host_rdiskette_open_drive();


/* Unix Utilities - xxxx_unix.c */
extern char           *host_get_cur_dir();
#ifndef host_memset
extern void            host_memset();
#endif /* nhost_memset */
extern int             host_get_file_size();
extern boolean         host_file_is_directory();
extern boolean         host_validate_pathname();
extern boolean         host_check_rd_wt_access();
extern boolean         host_check_read_access();
#ifdef SUSPEND
extern void	       suspend_softpc();
#endif
#ifndef REAL_VGA
IMPORT VOID memset4 IPT3( IU32, data, ULONG *, laddr, ULONG, count );
#endif
IMPORT VOID fill_alternate_bytes IPT3( IS8 *, start, IS8 *, end, IS8, value);
IMPORT VOID fill_both_bytes IPT3( IU16, data, IU16 *, dest, ULONG, len );

#ifdef	SETUID_ROOT

/* real/effective user ID stuff */
IMPORT void host_init_uid IPT0 ();
IMPORT void host_set_root IPT0 ();
IMPORT void host_revert_uid IPT0 ();

#endif	/* SETUID_ROOT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_cfg.h ===
/*[
	host_cfg.h	1.2 08/10/92

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/



#ifndef _HOST_CONFIG_H		/* ensure we are only included once */
#define _HOST_CONFIG_H

#endif	/* _HOST_CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_gwi.h ===
/*[
 *	Name:		host_gwi.h
 *
 *	Author:		Simion Calcev
 *
 *	Created On:	17th December 1991
 *
 *	Purpose:	To undefine GWI defines for those hosts which don't
 *				want to support the GWI interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hg_stat.h ===
/*===========================================================================*/
/*[
 *	File Name		:	hg_stat.h
 *
 *	Derived from		:	New.
 *
 *	Author			:	Wayne Plummer 
 *
 *	Creation Date		:	12 Apr 1993
 *	
 *	SCCS Version		:	@(#)hg_stat.h	1.1 08/06/93
 *!
 *	Purpose	
 *		This header file declares the variables and macros used
 *		for stats gathering in non-PROD builds of the GISP CPU.
 *
 *!	(c) Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *
]*/

/*===========================================================================*/

#ifdef PROD
#define PC_S_INC(NAME)
#else /* PROD */
#define PC_S_INC(NAME)	NAME++

IMPORT IU32	HG_S_SIM, HG_S_CALLB, HG_S_E20, HG_S_D20, HG_S_MINV,
		HG_S_LDT, HG_S_IDT, HG_S_CQEV, HG_S_PROT, HG_S_EIF,
		HG_S_INTC, HG_S_INTR, HG_S_PINT, HG_S_PFLT, HG_S_PVINT,
		HG_S_PWINT, HG_S_PWFLT, HG_S_PPMINT, HG_S_INTNH, HG_S_FLTH,
		HG_S_FLT1H, HG_S_FLT6H, HG_S_FLT6H_PFX, HG_S_FLT6H_BOP,
		HG_S_FLT6H_NOTBOP, HG_S_FLT6H_LOCK, HG_S_FLT13H, HG_S_FLT14H, HG_S_BOPFB,
		HG_S_BOPFB0, HG_S_BOPFB1, HG_S_BOPFB2, HG_S_BOPFB3,
		HG_S_SQEV, HG_S_GQEV, HG_S_TDQEV, HG_S_HOOK, HG_S_IHOOK,
		HG_S_UHOOK, HG_S_HOOKSEL, HG_S_HOOKBOP;

#endif /* PROD */

/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hosthunt.h ===
/*[
 *	Name:		host_hunt.h
 *	Derived from:	Original
 *	Author:		Philippa Watson
 *	Created on:	27 June 1991
 *	Sccs ID:	@(#)hosthunt.h	1.5 09/27/93
 *	Purpose:	This file contains host-configurable items for Hunter.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *
]*/

/* None of this file is needed for non-HUNTER builds. */
#ifdef	HUNTER

/*
** Binary file access modes.
*/

#ifdef NTVDM
#define	RB_MODE		"rb"
#define	WB_MODE		"wb"
#define	AB_MODE		"ab"
#else
#define	RB_MODE		"r"
#define	WB_MODE		"w"
#define	AB_MODE		"a"
#endif

/*
 * Host to PC co-ordinate conversion, and vice-versa.
 */
 
#define host_conv_x_to_PC(mode, x)	x_host_to_PC(mode, x)
#define host_conv_y_to_PC(mode, y)	y_host_to_PC(mode, y)
#define host_conv_PC_to_x(mode, x)	x_PC_to_host(mode, x)
#define host_conv_PC_to_y(mode, y)	y_PC_to_host(mode, y)

#endif	/* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_hun.h ===
HOST_HUNT.H no Longer exists!!! - Renamed to be HOSTHUNT.h (conform to 8.3 naming
conventions.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_fio.h ===
/*[
 *	Name:		host_fio.h
 *	Derived From:	Original
 *	Author:		Philippa Watson
 *	Created On:	7 February 1992
 *	Sccs Id:	@(#)host_fio.h	1.3 08/10/92
 *	Purpose:	Host-side definitions for standard file i/o. This
 *			version is placed in the base for hosts which support
 *			standard unix file i/o.
 *	Modified by Robert Kokuti 26/5/92, BCN 886
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

/* The HOST_FILE_DESC structure contains information to identify a file on disk
** For Unix, it corresponds to char *.
*/

#define	HOST_FILE_DESC	char *

/* The HOST_FILE structure contains any file information which needs to be
** passed to the calls below. For Unix, it corresponds to the FILE structure.
*/

#define	HOST_FILE	FILE *

/* host_fopen_for_read(HOST_FILE_DESC filename) opens the given file for reading and
** returns a HOST_FILE. If the returned value is zero then the open
** has failed, otherwise it has succeeded.
*/

#define	host_fopen_for_read(filename)	fopen(filename, "r")

/* host_fopen_for_write(HOST_FILE_DESC filename) opens the given file for writing and
** returns a HOST_FILE. If the returned value is zero then the open
** has failed, otherwise it has succeeded.
*/

#define	host_fopen_for_write(filename)	fopen(filename, "w")

/* host_fopen_for_write_plus(HOST_FILE_DESC filename) opens the given file for writing
** and reading and returns a HOST_FILE. If the returned value is zero
** then the open has failed, otherwise it has succeeded.
*/

#define host_fopen_for_write_plus(filename)	fopen(filename, "w+")

/* host_fcreate_disk_file(HOST_FILE_DESC filename) creates & opens the given file for writing
** and reading and returns a HOST_FILE. If the returned value is zero
** then the create & open has failed, otherwise it has succeeded.
*/

#define host_fcreate_disk_file(filename)	fopen(filename, "w+")

/* host_fclose(HOST_FILE file) closes the given file. This routine returns
** zero for success. Any other return value is failure.
*/

#define	host_fclose(file)	(fclose(file) != EOF)

/* host_fseek_abs(HOST_FILE file, LONG location) seeks to the given absolute
** position in the file (i.e. relative to the start). It returns zero for
** success. Any other return value is a failure.
*/

#define	host_fseek_abs(file, location)	fseek(file, location, SEEK_SET)

/* host_fwrite_buffer(unsigned char *buffer, int itemsize, int nitems,
** HOST_FILE file) writes nitems each of itemsize from the buffer to the
** file. It returns zero for success. Any other return value is a failure.
*/

#define host_fwrite_buffer(buffer, itemsize, nitems, file)	\
	(fwrite(buffer, itemsize, nitems, file) != nitems)
	
/* host_fread_buffer(unsigned char *buffer, int itemsize, int nitems,
** HOST_FILE file) reads nitems each of itemsize from the file into the
** buffer. It returns zero for success. Any other return value is a failure.
*/

#define host_fread_buffer(buffer, itemsize, nitems, file)	\
	(fread(buffer, itemsize, nitems, file) != nitems)

/* host_feof(HOST_FILE file) returns non-zero when end of file is read from
** the file. It returns zero otherwise.
*/

#define	host_feof(file)		feof(file)

/* A useful define to avoid using lots of seek/write pairs. If the result is 0
** then the seek and write were successful; otherwise one of them failed.
*/

#define	host_fwrite_buffer_at(file, location, buffer, itemsize, nitems)	\
	(host_fseek_abs(file, location) ||	\
	host_fwrite_buffer(buffer, itemsize, nitems, file))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_com.h ===
#ifndef _HOST_COM_H
#define _HOST_COM_H

/*[
	Name:		host_com.h
	Derived From:	Base 2.0
	Author:		Ross Beresford 
	Created On:	
	Sccs ID:	12/13/94 @(#)host_com.h	1.10
	Purpose:	
		Definition of the interface between the generic communications
		adapter emulation functions and the host specific functions.
		THIS IS A BASE MODULE

		Users of the comms emulation functions must provide an
		implementation of the following host specific functions:

VOID host_com_reset(adapter)
int adapter;
{
	Initialise communications channel for "adapter" 
}

SHORT host_com_valid
	(UTINY hostID, ConfigValues *val, NameTable *dummy, CHAR *errString)
{
	Routine to validate a comms entry, called by config system.
}

VOID host_com_change(UTINY hostID, BOOL apply)
{
	Routine called by config to clean up after validation depending
	on if apply is true or not.  If not then the validation files
	are to be closed, otherwise the active adapter is to be shutdown and
	the validation data transfered.
}

SHORT host_com_active(UTINY hostID, BOOL active, CHAR *errString)
{
	Connect the adapter to the outside world.  Open or close
	the adapter as appropiate.
}

VOID host_com_close(adapter)
int adapter;
{
	Close communications channel for "adapter"
}

VOID host_com_read(adapter, value, error_mask)
int adapter;
char *value;
int *error_mask;
{
	Read communications channel for "adapter", placing the result in the
	character address pointed to by "value". Bits in "error_mask" may be
	set to indicate that the character is invalid for the following
	reason(s):

	HOST_COM_FRAMING_ERROR		framing error
	HOST_COM_OVERRUN_ERROR		overrun error
	HOST_COM_PARITY_ERROR		parity error
	HOST_COM_BREAK_RECEIVED 	break on input line
	HOST_COM_NO_DATA		value was not data
}

VOID host_com_write(adapter, value)
int adapter;
char value;
{
	Write "value" to the  communications channel for "adapter"
}

VOID host_com_ioctl(adapter, request, arg)
int adapter;
int request;
long arg;
{
	Perform control function "request" qualified by "arg" on the
	communications channel for "adapter".

	Request may take the following values:

	HOST_COM_SBRK :- Set break control for "adapter"; "arg" has no
			 significance

	HOST_COM_CBRK :- Clear break control for "adapter"; "arg" has no
			 significance

	HOST_COM_SDTR :- Set data terminal ready for "adapter"; "arg" has no
			 significance

	HOST_COM_CDTR :- Clear data terminal ready for "adapter"; "arg" has
			 no significance

	HOST_COM_SRTS :- Set request to send for "adapter"; "arg" has no
			 significance

	HOST_COM_CRTS :- Clear request to send for "adapter"; "arg" has no
			 significance

	HOST_COM_INPUT_READY :- Set the value pointed to by (int *) "arg" to
				TRUE if there is input pending for "adapter"


	HOST_COM_MODEM :- Set the value pointed to by (int *) "arg" to the
			  current modem status; the following bit fields are
			  significant and represent the state of the modem
			  input signals:

		HOST_COM_MODEM_CTS	clear to send
		HOST_COM_MODEM_RI	ring indicator
		HOST_COM_MODEM_DSR	data set ready
		HOST_COM_MODEM_RLSD	received line signal detect

	HOST_COM_BAUD :- Change the baud rate to that corresponding to the
			 value of "arg"; the following values of "arg" are
			 significant:

		HOST_COM_B50		50 baud
		HOST_COM_B75		75 baud
		HOST_COM_B110		110 baud
		HOST_COM_B134		134.5 baud
		HOST_COM_B150		150 baud
		HOST_COM_B300		300 baud
		HOST_COM_B600		600 baud
		HOST_COM_B1200		1200 baud
		HOST_COM_B1800		1800 baud
		HOST_COM_B2000		2000 baud
		HOST_COM_B2400		2400 baud
		HOST_COM_B3600		3600 baud
		HOST_COM_B4800		4800 baud
		HOST_COM_B7200		7200 baud
		HOST_COM_B9600		9600 baud
		HOST_COM_B19200		19200 baud
		HOST_COM_B38400		38400 baud
		HOST_COM_B57600		57600 baud
		HOST_COM_B115200	115200 baud

	HOST_COM_FLUSH :- Flush output; "arg" has no significance

	HOST_COM_DATABITS :- Set the line discipline to use "arg" data bits.

	HOST_COM_STOPBITS :- Set the line discipline to use "arg" stop bits.

	HOST_COM_PARITY :- Set the line discipline to the parity setting
			   implied by "arg", which may take one of the
			   following values:

		HOST_COM_PARITY_NONE	no parity
		HOST_COM_PARITY_EVEN	even parity
		HOST_COM_PARITY_ODD	odd parity
		HOST_COM_PARITY_MARK	parity stuck at 1
		HOST_COM_PARITY_SPACE	parity stuck at 0
}

GLOBAL void host_com_enable_autoflush IFN1(IS32,adapter)
{
	Reset the autoflush disabled flag for the serial port.
}

GLOBAL void host_com_disable_autoflush IFN1(IS32,adapter)
{
	Cancel any outstanding autoflush event for the serial port and set the
	autoflush disabled flag for the serial port.
}

#ifndef macintosh
GLOBAL void host_com_xon_change IFN2(IU8,hostID, IBOOL,apply)
{
	If the serial port is not active then do nothing.
	If the serial port is active then change the flow control parameter of
	the device.
	If the serial port also has an asynchronous event manager defined then
	change the mode of the event manager.
}
#endif	macintosh

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

IMPORT VOID host_com_reset IPT1(int,adapter);

IMPORT SHORT host_com_valid
	IPT4(UTINY,hostID,ConfigValues *,val,NameTable *,dummy,CHAR *,errString);
IMPORT VOID host_com_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT SHORT host_com_active IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT VOID host_com_close IPT1(int,adapter);

#if defined(NTVDM) && defined(FIFO_ON)
IMPORT UTINY host_com_read_char(int adapter, FIFORXDATA *buffer, UTINY count);
IMPORT VOID host_com_fifo_char_read(int adapter);
#endif

IMPORT VOID host_com_read IPT3(int,adapter,UTINY *,value, int *,error_mask);
IMPORT VOID host_com_write IPT2(int,adapter, char,value);
IMPORT VOID host_com_ioctl IPT3(int,adapter, int,request, LONG,arg);

#ifdef NTVDM
extern	boolean host_com_check_adapter(int adapter);
extern void host_com_lock(int adapter);
extern void host_com_unlock(int adapter);
extern int host_com_char_read(int adapter, int da_int);
extern void host_com_disable_open(int adapter, int disableOpen);
extern void host_com_da_int_change(int adapter, int da_int_state, int da_data_state);
#define host_com_msr_callback(a,b)
#endif

#ifdef PS_FLUSHING
IMPORT void host_com_enable_autoflush IPT1(IS32,adapter);
IMPORT void host_com_disable_autoflush IPT1(IS32,adapter);
#endif	/* PS_FLUSHING */

#ifndef macintosh
IMPORT void host_com_xon_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* macintosh */

#define	HOST_COM_SBRK		0000001
#define	HOST_COM_CBRK		0000002
#define	HOST_COM_SDTR		0000003
#define	HOST_COM_CDTR		0000004
#define	HOST_COM_SRTS		0000005
#define	HOST_COM_CRTS		0000006
#define	HOST_COM_MODEM		0000007
#define	HOST_COM_BAUD		0000010 
#define	HOST_COM_FLUSH		0000011
#define	HOST_COM_INPUT_READY	0000012
#define	HOST_COM_DATABITS	0000013
#define	HOST_COM_STOPBITS	0000014
#define	HOST_COM_PARITY		0000015

#ifdef NTVDM
#define HOST_COM_LSR		0000016
#endif

#define	HOST_COM_FRAMING_ERROR	(1 << 0)
#define	HOST_COM_OVERRUN_ERROR	(1 << 1)
#define	HOST_COM_BREAK_RECEIVED	(1 << 2)
#define	HOST_COM_PARITY_ERROR	(1 << 3)
#define HOST_COM_NO_DATA		(1 << 4)
#ifdef NTVDM
#define HOST_COM_FIFO_ERROR	(1 << 7)
#endif

#define	HOST_COM_MODEM_CTS	(1 << 0)
#define	HOST_COM_MODEM_RI	(1 << 1)
#define	HOST_COM_MODEM_DSR	(1 << 2)
#define	HOST_COM_MODEM_RLSD	(1 << 3)

#define	HOST_COM_B50	 0000001
#define	HOST_COM_B75	 0000002
#define	HOST_COM_B110	 0000003
#define	HOST_COM_B134	 0000004
#define	HOST_COM_B150	 0000005
#define	HOST_COM_B300	 0000006
#define	HOST_COM_B600	 0000007
#define	HOST_COM_B1200	 0000010
#define	HOST_COM_B1800	 0000011
#define	HOST_COM_B2000	 0000012
#define	HOST_COM_B2400	 0000013
#define	HOST_COM_B3600	 0000014
#define	HOST_COM_B4800	 0000015
#define	HOST_COM_B7200	 0000016
#define	HOST_COM_B9600	 0000017
#define	HOST_COM_B19200	 0000020
#define	HOST_COM_B38400	 0000021
#define	HOST_COM_B57600	 0000022
#define	HOST_COM_B115200 0000023

#define	HOST_COM_PARITY_NONE	0000000
#define	HOST_COM_PARITY_EVEN	0000001
#define	HOST_COM_PARITY_ODD	0000002
#define	HOST_COM_PARITY_MARK	0000003
#define	HOST_COM_PARITY_SPACE	0000004

#endif /* _HOST_COM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_msw.h ===
/*[
 *	Product:	SoftPC-AT Revision 3.0
 *
 *	Name:		host_msw.h
 *
 *	Derived From:	Alpha MS-Windows Driver by Ross Beresford
 *
 *	Author:		Rob Tizzard
 *
 *	Created On:	1st November 1990
 *
 *	Sccs ID:	@(#)host_msw.h	1.43 07/08/94
 *
 *	Purpose:	All host dependent definitions for SoftPC MicroSoft
 *		  	Windows 3.0 driver.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
]*/

#if defined(MSWDVR) && defined(XWINDOW)

/*
 * -----------------------------------------------------------------------------
 * X include files.
 * -----------------------------------------------------------------------------
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xresource.h>
#include <X11/Xutil.h>

/* 
 * -----------------------------------------------------------------------------
 * GDIINFO data structure 
 * -----------------------------------------------------------------------------
 */ 

#define VERSION		0x0300     /* Windows version 3.0 */
#define TECHNOLOGY	DT_RASDISPLAY	   /* Raster Display */
#define BITSPIXEL     	4 	   /* Bits per pixel for display */
#define PLANES	  	1	   /* Number of planes for display */			
#define NUMCOLOURS	16	   /* Number of static colours in display table */
#define NUMFONTS	0	   /* Number of driver fonts */

/*
 * Basic dpLines value
 */
#ifdef SWIN_WIDE_LINES
#define LINES		(LC_POLYLINE|LC_WIDE|LC_STYLED|LC_WIDESTYLED|LC_INTERIORS)
#else
#define LINES		(LC_POLYLINE|LC_STYLED|LC_INTERIORS)
#endif

#ifdef SWIN_GRAPHICS_PRIMS	/* { */
/*
 * Basic dpCurves value
 */
#ifdef SWIN_WIDE_LINES
#define CURVES		(CC_CIRCLES|CC_PIE|CC_CHORD|CC_ELLIPSES|CC_WIDE|CC_STYLED|CC_WIDESTYLED|CC_INTERIORS)
#else
#define CURVES		(CC_CIRCLES|CC_PIE|CC_CHORD|CC_ELLIPSES|CC_STYLED|CC_INTERIORS)
#endif

/*
 * Basic dpPolygonals value
 */
#ifdef SWIN_WIDE_LINES
#define POLYGONALS	(PC_ALTPOLYGON|PC_RECTANGLE|PC_WINDPOLYGON|PC_SCANLINE|PC_WIDE|PC_STYLED|PC_WIDESTYLED|PC_INTERIORS)
#else
#define POLYGONALS	(PC_ALTPOLYGON|PC_RECTANGLE|PC_WINDPOLYGON|PC_SCANLINE|PC_STYLED|PC_INTERIORS)
#endif

#else	/* SWIN_GRAPHICS_PRIMS } { */

/*
 * Basic dpCurves value
 */
#ifdef SWIN_WIDE_LINES
#define CURVES		(CC_ELLIPSES|CC_WIDE|CC_STYLED|CC_WIDESTYLED|CC_INTERIORS)
#else
#define CURVES		(CC_ELLIPSES|CC_STYLED|CC_INTERIORS)
#endif

/*
 * Basic dpPolygonals value
 */
#ifdef SWIN_WIDE_LINES
#define POLYGONALS	(PC_RECTANGLE|PC_SCANLINE|PC_WIDE|PC_STYLED|PC_WIDESTYLED|PC_INTERIORS)
#else
#define POLYGONALS	(PC_RECTANGLE|PC_SCANLINE|PC_STYLED|PC_INTERIORS)
#endif

#endif /* SWIN_GRAPHICS_PRIMS  } */

#ifdef SWIN_BOLD_TEXT_OPTS	/* { */
#define TEXTUAL		(TC_CP_STROKE|TC_RA_ABLE|TC_EA_DOUBLE)
#else
#define TEXTUAL		(TC_CP_STROKE|TC_RA_ABLE)
#endif /* SWIN_BOLD_TEXT_OPTS	   } */

#define CLIP		CP_RECTANGLE		/* Rectangle */

#ifdef SWIN_DEVBMP
#define RASTER		(RC_BITBLT|RC_BITMAP64|RC_GDI20_OUTPUT|RC_SAVEBITMAP|RC_DI_BITMAP|RC_PALETTE|RC_DIBTODEV|RC_STRETCHBLT|RC_DEVBITS)
#else
#define RASTER		(RC_BITBLT|RC_BITMAP64|RC_GDI20_OUTPUT|RC_SAVEBITMAP|RC_DI_BITMAP|RC_PALETTE|RC_DIBTODEV)
#endif /* SWIN_DEVBMP */

#define DCMANAGE	DC_IGNOREDFNP		/* Display */
#define PALCOLOURS	0			/* Colours available in palette */
#define PALCOLRESERVED	0			/* Reserved colours for brushes & pens */
#define PALCOLOURRES	24			/* DAC RGB resolution */

/* X & Y dots per inch */

#define XDOTSPERINCH	((FLOAT) mswdvr.displayWidth / (FLOAT) mswdvr.displayWidthMM * 25.4)
#define YDOTSPERINCH 	((FLOAT) mswdvr.displayHeight / (FLOAT) mswdvr.displayHeightMM * 25.4)

/* 
 * -----------------------------------------------------------------------------
 * Image Data format
 * -----------------------------------------------------------------------------
 */

#define FORMAT		ZPixmap

#define HOSTBYTEORDER	MSBFirst
#define HOSTBITORDER	MSBFirst

#define MBYTEORDER	MSBFirst
#define MBITORDER	MSBFirst

/*
 * -----------------------------------------------------------------------------
 * Size of physical pen & brush data structures written to Intel memory
 * -----------------------------------------------------------------------------
 */

#define PPEN_SIZE	(sizeof(PEN_MAPPING))
#define PBRUSH_SIZE	(sizeof(BRUSH_MAPPING))

#ifdef SWIN_DEVBMP
/*
 * -----------------------------------------------------------------------------
 * Size of device bitmap entry tables
 * -----------------------------------------------------------------------------
 */

/*
 * number of entries in table
 */
#define PPBITMAP_MAX    512
/*
 * number of bytes to pass back to Intel (GDI) to describe
 * a device bitmap data structure (inc. PBITMAP structure)
 */
#define PPBITMAP_SIZE   (32 + sizeof(word))
#define BITMAP_FAILURE	0xffff		/* indicates cannot realize device bitmap */
#endif /* SWIN_DEVBMP */


/*
 * -----------------------------------------------------------------------------
 * Size of brush monochrome & colour tile data in bytes
 * -----------------------------------------------------------------------------
 */

#define BRUSH_MONO_SIZE		8
#define BRUSH_COLOUR_SIZE	64

/*
 * -----------------------------------------------------------------------------
 * Number of scratch areas.
 * -----------------------------------------------------------------------------
 */

#define MAX_SCRATCH_AREAS       2

/* 
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Types 
 * -----------------------------------------------------------------------------
 */

/* Pixel, RGB & shift unit */

typedef double_word	MSWPIXEL;
typedef double_word	MSWCOLOUR;
typedef half_word	SHIFTUNIT;

/* type of host pixel values, never seen by Windows */

typedef unsigned long	HOSTPIXEL;

/* Colourmap & translate table data structure */

typedef struct {
	HOSTPIXEL	pixel;		/* host pixel value */
	MSWCOLOUR	rgb;		/* RGB value */
} MSWCOLOURMAP;

#ifdef SWIN_GRAPHICS_PRIMS
/*
 * PolyPoints data structure and used in general for windows points
 * describing graphics operations
 */
typedef struct {
	SHORT	x;
	SHORT	y;
} WinPoint;

#define MAXPOINTS	512

#endif /* SWIN_GRAPHICS_PRIMS */

/* Drawing Rectangle */

typedef	XRectangle	Rectangle;

/* Window attributes */

typedef	XWindowAttributes	WindowAttributes;

/* Structure used in mapping MSW bitmaps to X pixmaps */

typedef struct {
   ULONG           type;           /* mapping type */
   BOOL            translate;      /* translate flag */
   Drawable        mapping;        /* mapped pixmap */
   LONG            x;              /* x origin of bitmap */
   LONG            y;              /* y origin of bitmap */
   word            width;          /* width of bitmap */
   word            height;         /* height of bitmap */
   word            bytes_per_line; /* width in bytes */
   half_word       planes;         /* number of bitmap planes */
   half_word       bitsPixel;      /* bits per pixel */
   double_word     bits;           /* Segment and offset of bitmap */
   half_word       *data;          /* bitmap data address */
   word            segmentIndex;   /* index to next Huge bitmap segment */
   word            scanSegment;    /* scan lines per segment */
   word            fillBytes;      /* unused bytes within a segment */
   HOSTPIXEL       foreground;     /* pixel corresponding to 1 */
   HOSTPIXEL       background;     /* pixel corresponding to 0 */
   LONG            active_x;       /* active area origin x */
   LONG            active_y;       /* active area origin y */
   ULONG           active_width;   /* active area width */
   ULONG           active_height;  /* active area height */
   IU32            flags;          /* creation flags */
#ifdef SWIN_DEVBMP
   BOOL		   deviceBitmap;   /* flag to test whether device bitmap */
#endif
} BITMAP_MAPPING;

/* Structure used in mapping MSW brushes to X GCs */

#ifdef SWIN_MEMTOMEM_ROPS
typedef struct
{
	IU16	left;
	IU16	top;
	IU16	right;
	IU16	bottom;
} Rect;
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * The following structure is kept in GDI and must be kept AS SMALL AS POSSIBLE.
 * This is the justification for use of the bit-fields (against Insignia
 * coding standards) & why some of the fields appear in other than the
 * obvious order - so that we can try to natural size align stuff (so that
 * there are no padding bytes added by the compiler). Note that more fields
 * could be moved into the pen/brush union but it doesn't end up saving
 * space - and could actually make it worse.
 *
 * NOTE - the handle field must be first - code in X_mswobj.c assumes that
 *	  it is the first item found in Intel memory & the pen/brush cache
 *	  code also depends on it.
 */
typedef struct {
	word		handle;			/* Unique brush identifier */
	word		line_width;		/* Pen line width */

	unsigned int	inuse:1;		/* Is brush/pen in use */
	unsigned int	tiled:1;		/* Brush tiled flag */
	unsigned int	width:4;		/* Brush width */
	unsigned int	height:4;		/* Brush height */
	unsigned int	monoPresent:1;		/* Mono bitmap present ? */
	unsigned int	colourPresent:1;	/* Colour bitmap present ? */
	unsigned int objectGCHandle:4;   	/* Entry within GC Table */
	unsigned int penXbackground:1;		/* pen background is X pixel! */

#ifdef SWIN_INVERTBRUSH_OPT
	unsigned int invertedTile:1;		/* brush tile is inverted */
#endif /* SWIN_INVERTBRUSH_OPT */

	int function;				/* GC function */

	union {
		struct {				/* BRUSHES only */
			unsigned int use_clip_mask:1;	/* clip mask None or !None */
#ifdef SWIN_MEMTOMEM_ROPS
			unsigned int patPresent:1;	/* pattern data present */
			unsigned int bmpBits:6;		/* pattern from mono bitmap */
			unsigned int xRotation:4;	/* x pattern rotation */
			unsigned int yRotation:4;	/* y pattern rotation */
#endif /* SWIN_MEMTOMEM_ROPS */
		} brush;
		struct {			/* PENS only */
			int line_style;		/* GC line style */
		} pen;
	} obj;

	MSWCOLOUR    foreground; 	      	/* Foreground colour */
	MSWCOLOUR    background; 	      	/* Backgound colour */

	HOSTPIXEL	fgPixel;		/* Foreground pixel value */
	HOSTPIXEL	bgPixel;		/* Background pixel value */

	half_word	monoBitmap[BRUSH_MONO_SIZE]; 	/* Data for mono brush */
	half_word	colourBitmap[BRUSH_COLOUR_SIZE];/* Data for colour brush */

	GC           gc;   	            		/* X GC to fill using brush */
	Pixmap	mapping;	     		/* Brush tile data mapping */
	Rectangle    clip_area;        		/* Area used when clipping */

#ifdef SWIN_MEMTOMEM_ROPS
	IU16		originX;		/* Brush tile origin x coord */
	IU16		originY;		/* Brush tile origin y coord */
	IS8		rop2;			/* Tiling rop */
#endif /* SWIN_MEMTOMEM_ROPS */

	IU8		style;			/* Brush style */
} BRUSH_MAPPING;

/*
 * Define structure that holds the stuff that used to be in BRUSH_MAPPING but is
 * taken out here to save space; this structure is cached in host memory and the
 * non-BRUSH_MAPPING members are recalculated when required.
 *
 * NOTE - gdi field must be first in the structure that follows; the
 *	  GET_BRUSH_PATTERN macro depends on it.
 */
typedef struct {
	BRUSH_MAPPING gdi;			/* copy of GDI bit of brush */
	XGCValues gcValues;			/* X GC values for display */
	unsigned long valueMask;		/* X GC value mask */
	IU8 patData[BRUSH_COLOUR_SIZE];		/* tiled brush pattern */
} X_BRUSH_MAPPING;

#ifdef SWIN_MEMTOMEM_ROPS
#define GET_BRUSH_PATTERN()		(((X_BRUSH_MAPPING *)bp)->patData)
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * Pens & brushes are all the same under X.
 */
#define PEN_MAPPING 	BRUSH_MAPPING
#define X_PEN_MAPPING 	X_BRUSH_MAPPING

/* Main windows driver data structure */

typedef struct {
	Display      *display;			/* X display */
	int          screen;			/* X screen */
	IS32	     intel_version;		/* version of Intel driver */
	Window       parent;			/* X Parent Window ID */
	Window       window;			/* X Output Window ID */
	Colormap     colourmap;			/* X colourmap */
	WindowAttributes  windowAttr;		/* X Output Window attributes */
	HOSTPIXEL    *planeMasks;	        /* X pixel plane masks */
	HOSTPIXEL    mergeMask;			/* X merged pixel plane masks */
	HOSTPIXEL    whitePixelValue;		/* X White pixel values */
	HOSTPIXEL    blackPixelValue;		/* X Black pixel value */
	ULONG	     displayWidth;		/* X Display width in pixels */
	ULONG	     displayHeight;		/* X Display height in pixels */
	ULONG        displayWidthMM;            /* X Display width in MM */
	ULONG        displayHeightMM;           /* X Display height in MM */
	ULONG        windowState;		/* Windows driver state */
	half_word    oldCrtModeByte;		/* Saved CRT Mode Byte */
	BOOL         crtModeByteSaved;		/* CRT Mode Byte saved flag */
	BOOL         sizeInitialised;		/* Windows size initialised flag */
	BOOL         envDefinedSize;		/* Windows size defined flag */
	BOOL	     winPtr;			/* Windows pointer active flag */
	BOOL         cursorDisplayed;		/* Cursor displayed flag */
	Cursor       cursor;			/* X ID of current cursor */
	int	     cursorCallbackActive;	/* warp suppression */
	int          cursorLastLocX;		/* Last x position of cursor */
	int	     cursorLastLocY;		/* Last y position of cursor */
	int          cursorXLocX;		/* x position of X pointer */
	int	     cursorXLocY;		/* y position of X pointer */
	BOOL         cursorXOutside;		/* X pointer outside window */
	word         version;			/* Windows version */
	word         nextSegment;		/* Windows next segment increment */
	word         flags;			/* Windows flags */
	word         deviceColourMatchSegment;	/* Segment of Windows function DeviceColourMatch */
	word         deviceColourMatchOffset;	/* Offset of Windows function DeviceColourMatch */
	word         bitsPixel;			/* Windows bits per pixel */
	word         numColours;		/* Windows colours */
	word         numPens;			/* Windows pens */
	word         palColours;		/* Windows palette colours */
	word         palColReserved;		/* Windows reserved palette colours */
	word         palColourRes;		/* Windows palette colours */
	UTINY        *colourToMono;		/* Windows colour to mono conversion table */
	MSWPIXEL     *colourTrans;		/* Windows colour translation table */
	MSWPIXEL     *invColourTrans;		/* Windows inverse colour translation table */
	BOOL         paletteModified;		/* Windows palette modified flag */
	BOOL         paletteEnabled;		/* Windows palette enabled flag */
	BITMAP_MAPPING    saveWindow;		/* Windows background output Window */
	UTINY	     *scratchMemory;		/* Windows driver global scratch area */
	ULONG	     scratchMemorySize;		/* Windows driver global scratch area size */
	BOOL         mode_change_exit;

	/* Store a tile pixmap and BRUSH_MAPPING structure for the brush improvement code */

	PEN_MAPPING	*ppen;
	BRUSH_MAPPING	*pbrush;

	X_PEN_MAPPING	*pxpen;
	X_BRUSH_MAPPING	*pxbrush;

	Pixmap		tile_mapping;
	word		tile_depth,tile_width,tile_height;

	/* Translation from host pixels to monochrome
	 * The HostToMono "function" enforces the 8-bit limit
	 */
	MSWPIXEL	hostToMono[256];
#ifdef SWIN_BACKING_STORE
	IBOOL		draw_direct;
#endif
} MSW_DATA;

#define HostToMono(hostpixel)	(mswdvr.hostToMono[(hostpixel)&0xff])

/*
 * -----------------------------------------------------------------------------
 * Driver optimizations
 * -----------------------------------------------------------------------------
 */

/* Enable Fast bitmap optimizations */

#define FASTBITMAP

/* Enable Output flush optimizations */

#define FLUSHSCANLINES		TRUE	
#define FLUSHPOLYLINES		TRUE		
#define FLUSHRECTANGLES		TRUE	
#define FLUSHELLIPSES		TRUE
#define FLUSHBITMAPS		TRUE	
#define FLUSHTEXT		TRUE

#endif /* MSWDVR_DEBUG */

/* 
 * -----------------------------------------------------------------------------
 * Host driver routines 
 * -----------------------------------------------------------------------------
 */

#if !(defined(MSWDVR_DEBUG) && defined(MSWDVR_MAIN))

/* For some reason, all of these function names are remapped with #defines.
 * The MSWDVR_DEBUG mechanism further remaps them to point to the
 * various debug routines instead, but this only happens in ms_windows.h
 *
 * To allow for fussy pre-processors, add a #define MSWDVR_MAIN which is
 * used in ms_windows.c to disable this particular translation.
 * 
 * The ideal solution would be to do away with this whole level of misdirection.
 */

#define	HostBitblt		BltBitblt
#define	HostColorInfo		ColColorInfo
#define HostControl		WinControl
#define HostDeviceBitmapBits	DibDeviceBitmapBits
#define	HostDisable		WinDisable
#define	HostEnable		WinEnable
#define HostEventEnd            PtrEventEnd
#define	HostExtTextOut		TxtExtTextOut
#define	HostFastBorder		BltFastBorder
#define HostSetDIBitsToDevice	DibSetDIBitsToDevice
#define	HostRealizeObject	ObjRealizeObject
#define	HostStrblt		TxtStrblt
#define	HostOutput		OutOutput
#define	HostPixel		WinPixel
#define	HostScanlr		WinScanlr
#define	HostSetCursor		PtrSetCursor
#define	HostSaveScreenBitmap	SavSaveScreenBitmap
#define	HostGetCharWidth	TxtGetCharWidth
#define HostSetPalette		ColSetPalette
#define HostGetPalette		ColGetPalette
#define HostSetPalTrans		ColSetPalTrans
#define HostGetPalTrans		ColGetPalTrans
#define HostUpdateColors	ColUpdateColors
#define HostPtrEnable           PtrEnable
#define HostPtrDisable          PtrDisable
#ifdef SWIN_DEVBMP
#define HostBitmapBits      ObjBitmapBits
#define HostSelectBitmap    ObjSelectBitmap
#endif /* SWIN_DEVBMP */


#endif /* !(defined(MSWDVR_DEBUG) && defined(MSWDVR_MAIN)) */

/* The following don't get a debug wrapper - don't know why... */

#define	HostLogo		LgoLogo
#define HostFillGDIInfo		WinFillGDIInfo
#define HostFillPDEVInfo	WinFillPDEVInfo
#define	HostMoveCursor		PtrMoveCursor
#define	HostCheckCursor		PtrCheckCursor	
#define HostStretchBlt		BltStretchBlt

/*
 * -----------------------------------------------------------------------------
 * Debug Entry Points
 * -----------------------------------------------------------------------------
 */

/* Functions */

#ifdef MSWDVR_DEBUG

/*
 * Low-level functions.
 */
extern VOID	DReportColEnquire IPT2(MSWCOLOUR,colour,sys_addr,pcolour);
extern VOID	DReportPixelEnquire IPT2(MSWPIXEL,pixel,MSWCOLOUR,rgb);
extern VOID	DPrintBitmap IPT3(UTINY *,bitmap,ULONG,bytes_per_line,ULONG,height);
extern VOID	DPrintMonoBitmap IPT4(UTINY *,bitmap,ULONG,bytes_per_line,ULONG,width,ULONG,height);
extern VOID	DPrintImageDetails IPT1(XImage *,img);
extern VOID	DPrintBitmapDetails IPT1(sys_addr,bm);
extern VOID	DPrintDevBitmapDetails IPT1(sys_addr,bm);
extern VOID	DPrintMessage IPT1(CHAR *,message);
extern VOID	DPrintInteger IPT1(LONG,integer);
extern VOID	DPrintColourmap IPT2(MSWCOLOURMAP *,colourmap,ULONG,colourmapSize);
extern VOID	DPrintSrcDstRect IPT6(LONG,sx,LONG,sy,LONG,dx,LONG,dy,ULONG,xext,ULONG,yext);
extern VOID	DPrintPBrush IPT1(sys_addr, lpBrush);
extern VOID	DPrintPPen IPT1(sys_addr,PPen);
extern VOID	DPrintDrawMode IPT2(sys_addr,DrawMode, BOOL, text);
extern VOID	DPrintDevice IPT1(sys_addr,Device);
extern VOID	DPrintlpPoints IPT2(sys_addr,lpPoints,word,Count);
extern VOID	DPrintClipRect IPT1(sys_addr,lpClipRect);
extern VOID	DPrintObject IPT3(word,style,sys_addr,lpInObj,sys_addr,lpOutObj);
extern VOID	DPrintFontInfo IPT1(sys_addr,pfont);
extern VOID	DPrintTextXForm IPT1(sys_addr,lpTextXForm);
extern VOID	DPrintDIBHeader IPT2(sys_addr,lpDIBHeader,word,setOrget);
extern VOID	DPrintTransTable IPT2(MSWPIXEL *,table,ULONG,tableSize);
extern VOID	DDrawLogo IPT1(sys_addr,stkframe);

/*
 * High-level functions
 */
extern VOID	DBitblt IPT11 ( sys_addr,lpDestDev, word,dstXOrg,word,dstYOrg,
		sys_addr,lpSrcDev,  word,srcXOrg,word,srcYOrg,
		word,xext,word,yext,double_word,rop3,
		sys_addr,lpPBrush,sys_addr,lpDrawMode);
extern VOID	DColorInfo IPT3(sys_addr,lpDestDev,double_word,colorin,sys_addr,lpPColor);
extern VOID	DControl IPT4(sys_addr,lpDestDev,word,wFunction,sys_addr,lpInData,sys_addr,lpOutData);
extern VOID	DDisable IPT1(sys_addr,lpDestDev);
extern VOID	DEnable IPT5(sys_addr,lpDestDev,word,wStyle,sys_addr,lpDestType,sys_addr,
		lpOutputFile,sys_addr,lpData);
extern VOID	DEnumDFonts IPT1(sys_addr,stkframe);
extern VOID	DEnumObj IPT1(sys_addr,stkframe);
extern VOID	DOutput IPT8(sys_addr,lpDestDev,word,lpStyle,word,Count,sys_addr,lpPoints,
		sys_addr,lpPPen,sys_addr,lpPBrush,sys_addr,lpDrawMode,sys_addr,lpClipRect);
extern VOID	DPixel IPT5(sys_addr,lpDestDev,word,x,word,y,double_word,PhysColor,sys_addr,lpDrawMode);
#ifdef SWIN_DEVBMP
extern VOID	DBitmapBits IPT4(sys_addr,lpDevice,double_word,fFlags,double_word,dwCount,double_word,lpBits);
extern VOID	DSelectBitmap IPT4(sys_addr,lpDevice,sys_addr,lpPrevBitmap,sys_addr,lpBitmap,double_word,fFlags);
#endif
extern VOID	DRealizeObject IPT5(word,Style,sys_addr,lpInObj,sys_addr,lpOutObj,word,originX,word,originY);
extern VOID	DStrblt IPT9(sys_addr,lpDestDev,word,DestxOrg,word,DestyOrg,sys_addr,lpClipRect,
		sys_addr,lpString,word,Count,sys_addr,lpFont,sys_addr,lpDrawMode, sys_addr,lpTextXForm);
extern VOID	DScanlr IPT5(sys_addr,lpDestDev,word,x,word,y,double_word,PhysColor,word,Style);
extern VOID	DDeviceMode IPT1(sys_addr,stkframe);
extern VOID	DInquire IPT1(sys_addr,stkframe);
extern VOID	DSetCursor IPT1(sys_addr,lpCursorShape);
extern VOID	DMoveCursor IPT1(sys_addr,stkframe);
extern VOID	DCheckCursor IPT1(sys_addr,stkframe);
extern VOID	DSaveScreenBitmap IPT5(word, command, word, x, word, y, word, xext, word, yext);
extern VOID	DExtTextOut IPT12(sys_addr, dstdev, word, dx, word, dy, sys_addr, cliprect, sys_addr, 
		str, word, strlnth, sys_addr, pfont, sys_addr, drawmode, sys_addr, textxform, 
		sys_addr, txtcharwidths, sys_addr, opaquerect, word, options);
extern VOID	DGetCharWidth IPT7(sys_addr,dstdev,sys_addr,buffer,word,first,word,last,sys_addr,
		pfont,sys_addr,drawmode,sys_addr,textxform);
extern VOID	DDeviceBitmap IPT1(sys_addr,stkframe);
extern VOID	DDeviceBitmapBits IPT8(sys_addr,lpDestDev,word,setOrget,word,startScan,word,
		numScans,sys_addr,lpDIBBits,sys_addr,lpDIBHeader,sys_addr,
		lpDrawMode,sys_addr,lpColorInfo);
extern VOID	DSetDIBitsToDevice IPT10(sys_addr, lpDestDev, word, screenXOrigin, word, 
		screenYOrigin, word, startScan, word, numScans, sys_addr, lpClipRect, 
		sys_addr, lpDrawMode, sys_addr, lpDIBBits, sys_addr, lpDIBHeader, 
		sys_addr, lpColorInfo);
extern VOID	DFastBorder IPT11(sys_addr,lpDestDev,word,dx,word,dy,word,xext,word,yext,
		word,hbt,word,vbt,double_word,rop3,sys_addr,pbrush,
		sys_addr,drawmode,sys_addr,cliprect);
extern VOID	DSetAttribute IPT1(sys_addr,stkframe);
extern VOID	DSetPalette IPT3(word,wIndex,word,wCount,sys_addr,lpColorTable);
extern VOID	DGetPalette IPT3(word,wIndex,word,wCount,sys_addr,lpColorTable);
extern VOID	DSetPalTrans IPT1(sys_addr,lpTranslate);
extern VOID	DGetPalTrans IPT1(sys_addr,lpTranslate);
extern VOID	DUpdateColors IPT5(word,wStartX,word,wStartY,word,wExtX,word,wExtY,sys_addr,lpTranslate);
extern char *	DGXopToString IPT1(int, gxop);
extern void	DPrintLineStyle IPT1(int, style);
extern void	DPrintBrushStyle IPT1(int, style);
extern void	DPrintStyle IPT1(int, lpStyle);

#else

#define DPrintMonoBitmap(bitmap,bytes_per_line,width,height)
#define DReportColEnquire(p1,p2)
#define DReportPixelEnquire(p1,p2)
#define	DPrintImageDetails(p1)
#define	DPrintBitmapDetails(p1) 
#define DPrintMessage(p1)
#define DPrintColourmap(p1,p2)
#define DPrintSrcDstRect(p1,p2,p3,p4,p5,p6)
#define DPrintGDIInfo
#define DPrintBitmap(p1,p2,p3)
#define DPrintPBrush(p1,p2)
#define DPrintPpen(p1)
#define DPrintDrawMode(p1,p2)
#define DPrintDevice(p1)
#define DPrintlpPoints(p1,p2)
#define DPrintClipRect(p1)
#define DPrintInteger(p1) 
#define DPrintTransTable(p1,p2)
#define DGXopToString (p1)
#define DPrintLineStyle (p1)
#define DPrintBrushStyle (p1)
#define	DPrintStyle (p1)

#define DBitblt(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define DColorInfo(p1,p2,p3)
#define DControl(p1,p2,p3,p4)
#define DDisable(p1)
#define DDeviceBitmapBits(p1,p2,p3,p4,p5,p6,p7,p8)
#define DEnable(p1,p2,p3,p4,p5)
#define DExtTextOut(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12)
#define DFastBorder(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define DGetPaletteEntries(p1,p2,p3)
#define DGetPaletteTranslate(p1,p2)
#define DOutput(p1,p2,p3,p4,p5,p6,p7,p8)
#define DPixel(p1,p2,p3,p4,p5)
#define DRealizeObject(p1,p2,p3,p4,p5)
#define DSaveScreenBitmap(p1,p2,p3,p4,p5)
#define DScanlr(p1,p2,p3,p4,p5)
#define DSetDIBitsToDevice(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)
#define DSetPaletteEntries(p1,p2,p3)
#define DSetPaletteTranslate(p1,p2)
#define DStrblt(p1,p2,p3,p4,p5,p6,p7,p8,p9)
#define DUpdateColors(p1,p2,p3,p4,p5)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_sig.h ===
/*
 *	File:		host_sig.h
 *
 *	Purpose:	header file to provide typedefs and prototypes
 *			for use with the host signal functions.
 *
 *	Author:	John Shanly
 *
 *	Date:		July 2, 1992
 *
 *	SccsID @(#)host_sig.h	1.3 11/17/92 Copyright (1992 )Insignia Solutions Ltd
 */

typedef void (*VOIDFUNC)();

#ifdef ANSI
GLOBAL void (*host_signal( int sig, VOIDFUNC handler )) ();
#else
GLOBAL void (*host_signal()) ();
#endif	/* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_lpt.h ===
#ifdef	PRINTER

#ifndef _HOST_LPT_H
#define _HOST_LPT_H
#if defined(NEC_98)         // NEC {

IMPORT  SHORT           host_lpt_valid
   IPT4(UTINY,hostID, ConfigValues *,val, NameTable *,dummy, CHAR *,errString);
IMPORT  VOID            host_lpt_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT  SHORT           host_lpt_active
                        IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT  void            host_lpt_close IPT0();
IMPORT  unsigned long   host_lpt_status IPT0();
IMPORT  BOOL            host_print_byte IPT1(byte, value);
//IMPORT        BOOL            host_print_doc IPT0();
//IMPORT        void            host_reset_print IPT0();
IMPORT  void            host_print_auto_feed IPT1(BOOL,auto_feed);

#define HOST_LPT_BUSY   (1 << 0)                // NEC
#else
/*[
	Name:		host_lpt.h
	Derived From:	Base 2.0
	Author:		Ross Beresford
	Created On:	
	Sccs ID:	11/14/94 @(#)host_lpt.h	1.8
	Purpose:	
		Definition of the interface between the generic printer
		adapter emulation functions and the host specific functions.
		THIS IS A BASE MODULE

		Users of the printer emulation functions must provide an
		implementation of the following host specific functions.
		In each of the calls, "adapter" is the index number for
		the parallel port (ie 0 for LPT1: through to 2 for LPT3:)

SHORT host_lpt_valid
	(UTINY hostID, ConfigValues *val, NameTable *dummy, CHAR *errString)
{
	Routine to validate a comms entry, called by config system.
}

VOID host_lpt_change(UTINY hostID, BOOL apply)
{
	Routine called by config to clean up after validation depending
	on if apply is true or not.  If not then the validation files
	are to be closed, otherwise the active adapter is to be shutdown and
	the validation data transfered.
}

SHORT host_lpt_active(UTINY hostID, BOOL active, CHAR *errString)
{
	Connect the adapter to the outside world.  Open or close
	the adapter as appropiate.
}

void host_lpt_close(adapter)
int adapter;
{
	Close connection to external printing device for the
	parallel port
}

unsigned long host_lpt_status(adapter)
int adapter;
{
	Return status of external printing device.  The
	following bits may be set in the return value; bits
	marked FOR FUTURE USE are not yet used by the base
	parallel port implementation.

	HOST_LPT_BUSY	printer is busy - wait for this bit
			to clear before sending further output

	HOST_LPT_PEND	printer is out of paper
			- FOR FUTURE USE

	HOST_LPT_SELECT	printer is in the selected state
			- FOR FUTURE USE

	HOST_LPT_ERROR	printer is in an error state
			- FOR FUTURE USE
}

boolean host_print_byte(adapter, value)
int adapter;
half_word value;
{
	Output "value" to the external printing device
}

void host_reset_print(adapter)
int adapter;
{
	<chrisP 4-Oct-91>
	Hard reset the printer.  This may involve...
	Flush the output to the external printing
	device
}

boolean host_print_doc(adapter)
int adapter;
{
	Flush the output to the external printing device
}

void host_print_auto_feed(adapter, auto_feed)
int adapter;
boolean auto_feed;
{
	If "auto_feed" is TRUE, then output an extra line
	feed character for each carriage return output to
	the external printing device.
}

GLOBAL void host_lpt_enable_autoflush IFN1(IS32, adapter)
{
	Reset the autoflush disabled flag for the printer port.
}

GLOBAL void host_lpt_disable_autoflush IFN1(IS32, adapter)
{
	Cancel any outstanding autoflush event for the printer port and set the
        autoflush disabled flag for the printer port.
}

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

Modifications:
		<chrisP 4-Oct-91>
		Change the name of host_print_doc() to host_reset_print().
		This reflects what is actually needed when it is called from printer.c.
		If your port really wants to print a document when the reset
		line becomes active, you can call your host_print_doc from 
		host_reset_print.
		
]*/

IMPORT	SHORT		host_lpt_valid
    IPT4(UTINY,hostID, ConfigValues *,val, NameTable *,dummy, CHAR *,errString);
IMPORT	VOID		host_lpt_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT	SHORT		host_lpt_active
	IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT	void		host_lpt_close IPT1(int,adapter);
IMPORT	unsigned long	host_lpt_status IPT1(int,adapter);
IMPORT	BOOL		host_print_byte IPT2(int,adapter, byte, value);
IMPORT	BOOL		host_print_doc IPT1(int,adapter);
IMPORT	void		host_reset_print IPT1(int,adapter);
IMPORT	void		host_print_auto_feed IPT2(int,adapter, BOOL,auto_feed);

#if defined(NTVDM)
IMPORT	BOOLEAN 	host_set_lpt_direct_access(int adapter, BOOLEAN direct_access);
IMPORT	UCHAR		host_read_printer_status_port(int adapter);
#endif

#ifdef PS_FLUSHING
IMPORT void host_lpt_enable_autoflush IPT1(IS32, adapter);
IMPORT void host_lpt_disable_autoflush IPT1(IS32, adapter);
#endif	/* PS_FLUSHING */

#if defined (NTVDM) && defined(MONITOR)
IMPORT void host_printer_setup_table(sys_addr table_addr, word nPorts, word * lptStatusPortAddr);
#endif

#define	HOST_LPT_BUSY	(1 << 0)
#define	HOST_LPT_PEND	(1 << 1)
#define	HOST_LPT_SELECT	(1 << 2)
#define	HOST_LPT_ERROR	(1 << 3)

/*
 * Printer port numbering convention. Internal numbering is 0 based,
 * and number_for_adapter() converts to the PC world's convention.
 */
#define LPT1			0
#define LPT2			1
#define LPT3			2

#define	number_for_adapter(adapter)	(adapter + 1)

#endif	// NEC_98                                          // NEC }

#endif /* _HOST_LPT_H */

#endif /* PRINTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_pth.h ===
/*[
 *	Name:		host_pth.h
 *
 *	Deived from:	(original)
 *
 *	Author:		John Cremer
 *
 *	Created on:	11 Oct 93
 *
 *	Sccs ID:	@(#)host_pth.h	1.1 10/13/93
 *
 *	Coding stds:	2.0
 *
 *	Purpose:	Definitions and function declarations for host pathname
 * 			editting routines.
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/

typedef	char	HOST_PATH;	/* host pathname string type */

extern HOST_PATH *HostPathAppendFileName IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */ 
    HOST_PATH *,dirPath,	/* directory pathname */
    CHAR *,fileName		/* file name to be appended */
);

extern HOST_PATH *HostPathAppendDirName IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */ 
    HOST_PATH *,dirPath,        /* directory pathname */
    CHAR *,dirName              /* directory name to be appended */
);

extern HOST_PATH *HostPathAppendPath IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */
    HOST_PATH *,dirPath,	/* existing directory path */
    HOST_PATH *,path		/* path to be appended */
);

extern HOST_PATH *HostPathMakeTempFilePath IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */
    HOST_PATH *,dirPath,	/* directory path, or NULL */
    CHAR *,fileName		/* file name, or NULL */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_nls.h ===
/*
 *	Name:			host_nls.h
 *	Derived From:		HP 2.0 host_nls.h
 *	Author:			Philippa Watson
 *	Created On:		23 January 1991
 *	Sccs ID:		@(#)host_nls.h	1.9 08/19/94
 *	Purpose:		Host side nls definitions.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * The following messages are the only ones that are not in the
 * NLS message catalog.  The first is used if SoftPC cannot open
 * the message catalog.  The second is used if a message is not found
 * in the catalog.
 */
#define CAT_OPEN_MSG            "Message file problem. Cannot find the native language support catalog\n"
#define CAT_ERROR_MSG           "Message file problem. Cannot find the required error text in the native language support catalogs."
#define EMPTY                   ""


/* Offset for accessing config NLS strings - the config dynamically 
   fills the config definitions with entries retrieved from NLS
   by accessing the message referenced by CONF_STR_OFFSET + hostID */
#define CONF_STR_OFFSET		2001

/* NLS definitions used to indicate the type of situation */
#define PNL_TITLE_GROUP		3001
#define PNL_TITLE_WARNING	3001
#define PNL_TITLE_ERROR		3002
#define PNL_TITLE_CONF_PROB	3003
#define PNL_TITLE_INST_PROB	3004

/* NLS definitions used in config to show what is not perfect */
#define PNL_CONF_GROUP		3010
#define PNL_CONF_PROB_FILE	3010
#define PNL_CONF_VALUE_REQUIRED	3011
#define PNL_CONF_CURRENT_VALUE	3012
#define PNL_CONF_DEFAULT_VALUE	3013
#define PNL_CONF_CHANGE_CURRENT	3014
#define PNL_CONF_NEW_VALUE	3015

/* NLS definitions used to display the User interface buttons */
#define PNL_BUTTONS_GROUP	3020
#define PNL_BUTTONS_DEFAULT	3020
#define PNL_BUTTONS_CONTINUE	3021
#define PNL_BUTTONS_EDIT	3027
#define PNL_BUTTONS_RESET	3022
#define PNL_BUTTONS_QUIT	3023
#define PNL_BUTTONS_ENTER	3024
#define PNL_BUTTONS_OR		3025
#define PNL_BUTTONS_COMMA	3026

/* NLS definitions used for reading the keyboard response to buttons on DT's */
#define PNL_DT_KEYS_DEFAULT	3030
#define PNL_DT_KEYS_CONTINUE	3031
#define PNL_DT_KEYS_EDIT	3036
#define PNL_DT_KEYS_RESET	3032
#define PNL_DT_KEYS_QUIT	3033
#define PNL_DT_KEYS_YES		3034
#define PNL_DT_KEYS_NO		3035
#define PNL_LIST_ON_MSG		3037
#define PNL_LIST_OFF_MSG	3038
#define PNL_LIST_COM_MSG	3039
#define PNL_LIST_SLV_MSG	3040
#define PNL_LIST_FPB_MSG	3041
#define PNL_LIST_FPA_MSG	3042
#define PNL_LIST_ED_MSG         3043
#define PNL_LIST_PRK_MSG        3044

extern void  host_nls_get_msg 		IPT3(int,msg_num,
						CHAR *,msg_buff,int,buff_len);
#ifdef NTVDM
#define host_nls_get_msg_no_check host_nls_get_msg
#else
extern void  host_nls_get_msg_no_check 	IPT3(int,msg_num,
						CHAR *,msg_buff,int,buff_len);
extern int nls_init IPT0();
#endif

/* In order to stabilise the numbers used in the NLS catalogues,
 * we now fix the C_* defines in config.h. The config_message
 * array in X_nls.c therefore needs to hold both the string and
 * and the official ID number. host_nls_scan_default is a utility
 * function to replace the direct array lookups.
 */ 
typedef struct {
	char	*name;		/* default string */
	IU8	hostID;		/* config ID number, e.g. C_SWITCHNPX */
} config_default;

extern CHAR *host_nls_scan_default	IPT2(int,msg_num,
					     config_default *,dflt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_sas.h ===
/*[
 *      Product:        SoftPC-AT Revision 3.0
 *
 *      Name:           host_sas.h
 *
 *      Derived From:   New
 *
 *      Authors:        A. Guthrie
 *
 *      Created On:     Wed Apr 24 18:33:01 BST 1991
 *
 *      Sccs ID:        @(#)host_sas.h	1.18 08/10/92
 *
 *      Purpose:        Defines the function pointer interface to host sas
 *			routines.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *
]*/
#if defined(BASE_SAS) && defined(HOST_SAS)

#ifndef SAS_PREFIX
#define SAS_PREFIX()	sas_
#endif /* SAS_PREFIX */

#define IDENT(a)	a
#define CAT(a,b)	IDENT(a)b
#define sas_term			CAT(SAS_PREFIX(),term)
#define sas_init			CAT(SAS_PREFIX(),init)
#define sas_memory_size			CAT(SAS_PREFIX(),memory_size)
#define sas_memory_type			CAT(SAS_PREFIX(),memory_type)
#define sas_blockop			CAT(SAS_PREFIX(),blockop)
#define sas_load			CAT(SAS_PREFIX(),load)
#define sas_loadw			CAT(SAS_PREFIX(),loadw)
#define sas_store			CAT(SAS_PREFIX(),store)
#define sas_storew			CAT(SAS_PREFIX(),storew)
#define sas_storedw			CAT(SAS_PREFIX(),storedw)
#define sas_store_no_check		CAT(SAS_PREFIX(),store_no_check)
#define sas_storew_no_check		CAT(SAS_PREFIX(),storew_no_check)
#define sas_storedw_no_check		CAT(SAS_PREFIX(),storedw_no_check)
#define sas_fills			CAT(SAS_PREFIX(),fills)
#define sas_fillsw			CAT(SAS_PREFIX(),fillsw)
#define sas_hw_at			CAT(SAS_PREFIX(),hw_at)
#define sas_w_at			CAT(SAS_PREFIX(),w_at)
#define sas_dw_at			CAT(SAS_PREFIX(),dw_at)
#define sas_hw_at_no_check		CAT(SAS_PREFIX(),hw_at_no_check)
#define sas_w_at_no_check		CAT(SAS_PREFIX(),w_at_no_check)
#define sas_dw_at_no_check		CAT(SAS_PREFIX(),dw_at_no_check)
#define sas_loads			CAT(SAS_PREFIX(),loads)
#define sas_stores			CAT(SAS_PREFIX(),stores)
#define sas_loads_no_check		CAT(SAS_PREFIX(),loads_no_check)
#define sas_stores_no_check		CAT(SAS_PREFIX(),stores_no_check)
#define sas_move_bytes_forward		CAT(SAS_PREFIX(),move_bytes_forward)
#define sas_move_words_forward		CAT(SAS_PREFIX(),move_words_forward)
#define sas_move_bytes_backward		CAT(SAS_PREFIX(),move_bytes_backward)
#define sas_move_words_backward		CAT(SAS_PREFIX(),move_words_backward)
#define sas_enable_20_bit_wrapping	CAT(SAS_PREFIX(),enable_20_bit_wrapping)
#define sas_disable_20_bit_wrapping	CAT(SAS_PREFIX(),disable_20_bit_wrapping)
#define sas_twenty_bit_wrapping_enabled	CAT(SAS_PREFIX(),twenty_bit_wrapping_enabled)
#define sas_part_enable_20_bit_wrap	CAT(SAS_PREFIX(),part_enable_20_bit_wrap)
#define sas_part_disable_20_bit_wrap	CAT(SAS_PREFIX(),part_disable_20_bit_wrap)
#define sas_scratch_address		CAT(SAS_PREFIX(),scratch_address)
#define sas_connect_memory		CAT(SAS_PREFIX(),connect_memory)
#define sas_overwrite_memory		CAT(SAS_PREFIX(),overwrite_memory)

#endif /* BASE_SAS && HOST_SAS */

#ifndef BASE_SAS

#ifdef HOST_SAS

typedef struct
{
	VOID		( *do_sas_init ) ();
	VOID		( *do_sas_term ) ();
	sys_addr	( *do_sas_memory_size ) ();
	half_word	( *do_sas_memory_type ) ();
	VOID		( *do_sas_load ) ();
	VOID		( *do_sas_loadw ) ();
	VOID		( *do_sas_store ) ();
	VOID		( *do_sas_storew ) ();
	VOID		( *do_sas_storedw ) ();
	VOID		( *do_sas_fills ) ();
	VOID		( *do_sas_fillsw) ();
	half_word	( *do_sas_hw_at ) ();
	word		( *do_sas_w_at ) ();
	double_word	( *do_sas_dw_at ) ();
	VOID		( *do_sas_loads ) ();
	VOID		( *do_sas_stores ) ();
	VOID		( *do_sas_move_bytes_forward ) ();
	VOID		( *do_sas_move_words_forward ) ();
	VOID		( *do_sas_move_bytes_backward ) ();
	VOID		( *do_sas_move_words_backward ) ();
	host_addr	( *do_sas_get_byte_addr ) ();
	host_addr	( *do_sas_inc_M_ptr ) ();
	host_addr	( *do_sas_M_get_dw_ptr ) ();
	VOID		( *do_sas_enable_20_bit_wrapping ) ();
	VOID		( *do_sas_disable_20_bit_wrapping ) ();
	host_addr	( *do_sas_scratch_address ) ();
	VOID		( *do_sas_connect_memory ) ();
	VOID		( *do_sas_store_no_check ) ();
	VOID		( *do_sas_storew_no_check ) ();
	VOID		( *do_sas_storedw_no_check ) ();
	half_word	( *do_sas_hw_at_no_check ) ();
	word		( *do_sas_w_at_no_check ) ();
	half_word	( *do_sas_blockop ) ();
	double_word	( *do_sas_dw_at_no_check ) ();
	BOOL		( *do_sas_twenty_bit_wrapping_enabled ) ();
	VOID		( *do_sas_part_enable_20_bit_wrap ) ();
	VOID		( *do_sas_part_disable_20_bit_wrap ) ();
	VOID		( *do_sas_loads_no_check ) ();
	VOID		( *do_sas_stores_no_check ) ();
	VOID		( *do_sas_overwrite_memory ) ();
} SAS_FUNCTIONS;

IMPORT SAS_FUNCTIONS	host_sas_funcs;

#define	sas_init( size ) \
	( *host_sas_funcs.do_sas_init ) ( size )
#define	sas_term( ) \
	( *host_sas_funcs.do_sas_term ) ( )
#define	sas_memory_size( ) \
	( *host_sas_funcs.do_sas_memory_size ) ( )
#define	sas_memory_type( ) \
	( *host_sas_funcs.do_sas_memory_type ) ( )
#define	sas_blockop( start, end, op ) \
	( *host_sas_funcs.do_sas_blockop ) ( start, end, op )
#define	sas_load( addr, val ) \
	( *host_sas_funcs.do_sas_load ) ( addr, val )
#define	sas_loadw( addr, val ) \
	( *host_sas_funcs.do_sas_loadw ) ( addr, val )
#define	sas_store( addr, val ) \
	( *host_sas_funcs.do_sas_store ) ( addr, val )
#define	sas_storew( addr, val ) \
	( *host_sas_funcs.do_sas_storew ) ( addr, val )
#define	sas_storedw( addr, val ) \
	( *host_sas_funcs.do_sas_storedw ) ( addr, val )
#define	sas_store_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_store_no_check ) ( addr, val )
#define	sas_storew_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_storew_no_check ) ( addr, val )
#define	sas_storedw_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_storedw_no_check ) ( addr, val )
#define	sas_fills( addr, val, len ) \
	( *host_sas_funcs.do_sas_fills ) ( addr, val, len )
#define	sas_fillsw( addr, val, len ) \
	( *host_sas_funcs.do_sas_fillsw ) ( addr, val, len )
#define	sas_hw_at( addr ) \
	( *host_sas_funcs.do_sas_hw_at ) ( addr )
#define	sas_w_at( addr ) \
	( *host_sas_funcs.do_sas_w_at ) ( addr )
#define	sas_dw_at( addr ) \
	( *host_sas_funcs.do_sas_dw_at ) ( addr )
#define	sas_hw_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_hw_at_no_check ) ( addr )
#define	sas_w_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_w_at_no_check ) ( addr )
#define	sas_dw_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_dw_at_no_check ) ( addr )
#define	sas_loads( src, dest, len ) \
	( *host_sas_funcs.do_sas_loads ) ( src, dest, len )
#define	sas_stores( dest, src, len ) \
	( *host_sas_funcs.do_sas_stores ) ( dest, src, len )
#define	sas_move_bytes_forward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_bytes_forward ) ( src, dest, len )
#define	sas_move_words_forward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_words_forward ) ( src, dest, len )
#define	sas_move_bytes_backward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_bytes_backward ) ( src, dest, len )
#define	sas_move_words_backward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_words_backward ) ( src, dest, len )
#define	get_byte_addr( address ) \
	( *host_sas_funcs.do_sas_get_byte_addr ) ( address )
#define	inc_M_ptr( buf, offset ) \
	( *host_sas_funcs.do_sas_inc_M_ptr ) ( buf, offset )
#define	M_get_dw_ptr( offset ) \
	( *host_sas_funcs.do_sas_M_get_dw_ptr ) ( offset )
#define	sas_enable_20_bit_wrapping() \
	( *host_sas_funcs.do_sas_enable_20_bit_wrapping ) ()
#define	sas_disable_20_bit_wrapping() \
	( *host_sas_funcs.do_sas_disable_20_bit_wrapping ) ()
#define	sas_part_enable_20_bit_wrap( flag, target, source) \
	( *host_sas_funcs.do_sas_part_enable_20_bit_wrap ) ( flag, target, source)
#define	sas_part_disable_20_bit_wrap( flag, target, source) \
	( *host_sas_funcs.do_sas_part_disable_20_bit_wrap ) ( flag, target, source)
#define	sas_twenty_bit_wrapping_enabled() \
	( *host_sas_funcs.do_sas_twenty_bit_wrapping_enabled ) ()
#define	sas_scratch_address( length ) \
	( *host_sas_funcs.do_sas_scratch_address ) ( length )
#define	sas_connect_memory( laddr, haddr, len ) \
	( *host_sas_funcs.do_sas_connect_memory ) ( laddr, haddr, len )
#define	sas_loads_no_check( src, dest, len ) \
	( *host_sas_funcs.do_sas_loads_no_check ) ( src, dest, len )
#define	sas_stores_no_check( dest, src, len ) \
	( *host_sas_funcs.do_sas_stores_no_check ) ( dest, src, len )
#define	sas_overwrite_memory( dest, len ) \
	( *host_sas_funcs.do_sas_overwrite_memory ) ( dest, len )

#endif /* HOST_SAS */

#endif /* BASE_SAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_uis.h ===
#ifndef _HOST_UIS_H
#define _HOST_UIS_H

typedef enum 
{
	PT_WARNING,
	PT_ERROR,
	PT_INFORM,
	PT_QUESTION,
	PT_WORKING,
	PT_LAST
} PTInd;

#define PM_WARNING	pm_warning_image
#define PM_ERROR	pm_error_image
#define PM_INFORM	pm_inform_image
#define PM_QUESTION	pm_question_image
#define PM_WORKING	pm_working_image

/* control button stuff */
#define LEFT_RA_POSITION	25	/* 25 percent */
#define CENTRE_LA_POSITION	37	/* 37 percent */
#define CENTRE_RA_POSITION	62	/* 62 percent */
#define RIGHT_LA_POSITION	75	/* 75 percent */
#define NON_DEF_TOP_OFFSET	10

#ifdef HOST_HELP
/*
	Control button positions for dialogs with four buttons - ie those
	with OK, Reset, Cancel, and Help.
*/
#define FIRST_RA_POSITION	23	/* percent */
#define SECOND_LA_POSITION	27
#define SECOND_RA_POSITION	48
#define THIRD_LA_POSITION	52
#define THIRD_RA_POSITION	73
#define FOURTH_LA_POSITION	77

#endif /*HOST_HELP*/


typedef struct
{
	XtAppContext context;
	Widget toplevel;
	Widget main_win;	/* SoftPC main window */
        Widget pc_screen;	/* SoftPC screen widget */
	BOOL ready;		/* SoftPC uif Ready */
	LONG paneCount;
	int decorNoSize, decorSize;
	XmString panelTitles[PT_LAST];
} UIS;

IMPORT UIS uis;
IMPORT BOOL BatchMode;

IMPORT LONG uis_event_loop IPT2(LONG *,loop, BOOL,wait_non_zero);
IMPORT XmString wordWrap IPT3(XmString,str,Dimension,width,XmFontList,fList);

#ifdef HOST_HELP
IMPORT void callContextHelp IPT1(long, callContext) ;
IMPORT void callMainHelp IPT0() ;
IMPORT void callHelpOnHelp IPT0() ;
#endif

IMPORT CHAR pm_warning_image[];
IMPORT CHAR pm_error_image[];
IMPORT CHAR pm_inform_image[];
IMPORT CHAR pm_question_image[];
IMPORT CHAR pm_working_image[];

IMPORT void MGInstallMwmCloseCallback();

IMPORT void UxPopupInterface();
IMPORT void UxPopdownInterface();

#endif /* _HOST_UIS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\host_str.h ===
/*[
 *	Name:		host_str.h
 *
 *	Derived From:	(original)
 *
 *	Author:		John Cremer
 *
 *	Created On:	Oct 93
 *
 *	Sccs ID:	@(#)host_str.h	1.1 10/29/93
 *
 *	Coding Stds:	2.0
 *
 *	Purpose:	Provide prototypes for additional string manipulation
 *			functions.
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/


 
GLOBAL CHAR *HostStrdup IPT1(
    CHAR *, s1		/* string to be duplicated */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hwvga.h ===
/*[
 *
 *	File		:	hwvga.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	interface definition for hardware vga routines
 *
 *	Author		:	Rog
 *	Date		:	23 Feb 1993
 *
 *    SCCS Garbage	:	@(#)hwvga.h	1.5 11/22/93
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:
 *				Prototypes that don't depend on types
 *				defined in HostHwVgaH should go in gispsvga.h
 *				not here.  This file does contain some 
 *				prototypes from before this split was made.
 *
]*/


#ifdef GISP_SVGA
#ifndef _HWVGA_H_
#define _HWVGA_H_

/* Video Mode types*/

#define	ALPHA		0x00
#define GRAPH		0x01
#define UNIMP		0x03
#define NA		0x04

/* Plane storage types	*/
#define ALPHA_INTERLEAVED	0x0001	/* Mode3 et ak is ca00ca00ca00 etc */
#define GRAPH_PACKED		0x0100	/* Vid modes are packed */
/* Data */

typedef struct
{
	IS8		modeType;		/* Current Video Mode Type */
	IS8		numPlanes;		/* number of planes in use */
	BOOL		runningFullScreen;	/* Are we fs at the moment */
	BOOL		fullScreenAvail;	/* Can we go Full Screen */
	BOOL		forcedFullScreen;	/* Are we full screen coz we want it */
	VGAState	* pSavedVGAState;	/* Any saved VGA State */
	BOOL		savedStateValid;
	struct		{
				IU32	offset;
				IU32	segment;
			} hostSavePtr;
	IU8		dccIndex;
	IU32		planeStorage;		/* Storage methods in planes */
}
vInfo;

extern vInfo videoInfo;


/* Prototypes */

BOOL videoModeIs IPT2( IU8 , videoMode , IU8 , videoType );
BOOL hostIsFullScreen IPT0( );
BOOL hostEasyMode IPT0( );
void hostFindPlaneStorage IPT0( );
void hostRepaintDecoration IPT0( );
void enableFullScreenVideo IPT0( );
void disableFullScreenVideo IPT1( BOOL , syncEmulation  );
void syncEmulationToHardware IPT1( pVGAState , currentVGAState );
void readEmulationState IPT1( pVGAState , currentVGAState );
void initHWVGA IPT0( );
void getHostFontPointers IPT0( );
void setupHwVGAGlobals IPT0( );
void loadFontToVGA IPT5( sys_addr , table , int , count , int , charOff , int , fontNum , int , nBytes );
void loadFontToEmulation IPT5( sys_addr , table , int , count , int , charOff , int , fontNum , int , nBytes );
void hostFreeze IPT0();
void hostUnfreeze IPT0();
void mapHostROMs IPT0( );

#ifndef hostStartFullScreen
void hostStartFullScreen IPT0();
#endif	/* hostStartFullScreen */

#ifndef	hostStopFullScreen
void hostStopFullScreen IPT0();
#endif	/* hostStopFullScreen */

#ifdef	HUNTER
void hunterGetFullScreenInfo IPT0();
#endif	/* HUNTER */

extern BOOL NeedGISPROMInit;

#endif /* _HWVGA_H_ */
#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\idetect.h ===
/*
 * File:        idetect.h
 *
 * Author:      J.Roper
 *
 * Import Necessary items for IDLE DETECT
 *
 * SccsID @(#)idetect.h 1.6 08/25/93 Copyright Insignia Solutions Ltd
 */

#ifndef NTVDM
extern int idle_no_video;
extern int idle_no_comlpt;
extern int idle_no_disk;
#endif

void    idetect();
void    idle_set();
void    idle_ctl();

#define IDLE_INIT               0
#define IDLE_KYBD_POLL  1
#define IDLE_TIME_TICK  2
#define IDLE_WAITIO             3


#ifdef NTVDM
/*
 * NT VDM idling system based on waits - call funcs for counter idle indicators
 * to allow them to cancel waits.
 */
VOID HostIdleNoActivity(VOID);

#define IDLE_video()    HostIdleNoActivity()
#define IDLE_comlpt()   HostIdleNoActivity()
#define IDLE_disk()     HostIdleNoActivity()

/* exported just for kb_setup_vector intialization */
extern word *pICounter;
extern word *pCharPollsPerTick;
extern word *pMinConsecutiveTicks;
extern word IdleNoActivity;
extern word ienabled;

#else
#define IDLE_video()    idle_no_video = 0
#define IDLE_comlpt()   idle_no_comlpt = 0
#define IDLE_disk()     idle_no_disk = 0
#endif

#define IDLE_tick()             idetect(IDLE_TIME_TICK)
#define IDLE_poll()             idetect(IDLE_KYBD_POLL)
#define IDLE_waitio()   idetect(IDLE_WAITIO)
#define IDLE_init()             idetect(IDLE_INIT)
#define IDLE_set(a,b)   idle_set(a,b)
#define IDLE_ctl(a)             idle_ctl(a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\hunter.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Hunter -- the bug finder.
 *
 * Description	: External definitions for the hunter globals and routines.
 *
 * Author	: David Rees
 *
 * Notes	: DAR r3.2 - retyped host_hunter_image_check to int to
 *		             match changes in sun3_hunt.c, hunter.c 
 */

/* static char SccsID[]="@(#)hunter.h	1.10 09/01/92 Copyright Insignia Solutions Ltd."; */

/* This file has no effect unless HUNTER is defined. */
#ifdef	HUNTER

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
** Defines required by hunter base files
*/

/* EGA screen lengths (in scan lines) */
#define CGA_SCANS	200	/* CGA graphics modes screen length */
#define EGA_SCANS	350	/* EGA graphics mode screen length */
#define VGA_SCANS	400	/* VGA modes screen length */
#define	VGA_GSCANS	480	/* VGA graphics modes screen length */

/* Macro to determine whether a given point is inside a no check box. The
** point is given in PC terms.
*/
#define	xy_inabox(x, y)		(check_inside(x, y) >= 0)

/* Report types */
#define BRIEF			0
#define ABBREV			1
#define FULL			2

/* CGA screen dump sizes */
#define HUNTER_REGEN_SIZE     (16*1024)
#define HUNTER_BIOS_SIZE      0x90
#define HUNTER_SD_SIZE        (HUNTER_REGEN_SIZE + HUNTER_BIOS_SIZE)

/*
 * intel memory position defines for data stored in bios variables
 * used relative to BIOS_VAR_START to get bd indexes
 */
#define VID_MODE	0x449	/* vd_video_mode */
#define VID_COLS	0x44A	/* vd_cols_on_screen */
#define	VID_LEN  	0x44C	/* vd_crt_len */
#define	VID_ADDR	0x44E	/* vd_crt_start */
#define	VID_CURPOS	0x450	/* cursor table 8 pages */
#define	VID_CURMOD	0x460	/* vd_cursor_mode */
#define	VID_PAGE	0x462	/* vd_current_page */
#define VID_INDEX	0x463	/* vd_addr_6845 */
#define	VID_THISMOD	0x465	/* vd_cursor_mode */
#define	VID_PALETTE	0x466	/* vd_crt_palette */
#define VID_ROWS	0x484	/* vd_crt_rows - EGA only */

/*
** Screen dump mode bytes for EGA-type dumps.
*/
#define	EGA_SOURCE	0	/* Data gathered on EGA */
#define	VGA_SOURCE	1	/* Data gathered on VGA */
#define	V7VGA_SOURCE	2	/* Data gathered on Super7 VGA */

/*
** Structure for variables required by hunter base files
*/
typedef	struct
{
	word		h_page_length;	/* text bytes per page */
	half_word 	h_bd_page;	/* Active page from bios dump */
	word		h_sd_no;	/* no of current screen */
	half_word	spc_mode;	/* Mode in current spc bios */
	half_word	spc_page;	/* Page in current spc bios */
	word		spc_cols;	/* Columns in current spc bios */
	half_word	*h_regen;	/* current regen */
	half_word	*h_scrn_buffer;	/* current screendump */
#ifdef EGG
	half_word	*ega_r_planes;	/* EGA current regen data */
	half_word	*ega_s_planes;	/* EGA current screen dump data */
	half_word	e_sd_mode;	/* Data pack mode */
	int		h_line_compare;	/* line compare from VGA reg */
	int		h_max_scans;	/* max scan lines from VGA reg */
	half_word	h_bd_rows;	/* Rows from bios dunp */
	half_word	spc_rows;	/* softPC bios rows */
#endif	/* EGG */
	word		h_linecount;	/* Line within script file */
	word		h_scrn_length;	/* text bytes per screen */
	half_word	h_bd_mode;	/* Mode from bios dump */
	half_word	h_pixel_bits;	/* bits per pixel increment */
	half_word	h_report;
	BOOL		h_check_attr;	/* Value of HUCHECK env. variable */
	word		h_areas;	/* No. of non-check areas on screen */
	BOOL		h_txterr_prt;	/* stop txt error printing */
	word		h_gfxerr_max;	/* Value of HUGFXERR env. variable */
	char		h_filename_sd[MAXPATHLEN];	/* Ext filename, .sd */
	half_word	h_bios_buffer[HUNTER_BIOS_SIZE];/* current bios dump */
	word		h_bd_cols;	/* Cols from bios dump */
	word		h_bd_start;	/* plane start address */
	half_word	hc_mode;	/* video mode of active display screen */
	half_word	h_chk_mode;	/* value of HUCHKMODE env var */
	BOOL		h_gfxerr_prt;	/* stop gfx error printing */
}	BASE_HUNT_VARS;

IMPORT	BASE_HUNT_VARS	bh_vars;

/* Macros for accessing the above base hunter variables. */
#define	hunter_page_length	bh_vars.h_page_length
#define	hunter_bd_page		bh_vars.h_bd_page
#define	hunter_sd_no		bh_vars.h_sd_no
#define SPC_mode		bh_vars.spc_mode
#define SPC_page		bh_vars.spc_page
#define SPC_cols		bh_vars.spc_cols
#define hunter_regen		bh_vars.h_regen
#define hunter_scrn_buffer	bh_vars.h_scrn_buffer
#ifdef EGG
#define ega_regen_planes	bh_vars.ega_r_planes
#define ega_scrn_planes		bh_vars.ega_s_planes
#define ega_sd_mode		bh_vars.e_sd_mode
#define hunter_line_compare	bh_vars.h_line_compare
#define hunter_max_scans	bh_vars.h_max_scans
#define hunter_bd_rows		bh_vars.h_bd_rows
#define SPC_rows		bh_vars.spc_rows
#endif	/* EGG */
#define hunter_linecount	bh_vars.h_linecount
#define hunter_scrn_length	bh_vars.h_scrn_length
#define hunter_bd_mode		bh_vars.h_bd_mode
#define hunter_pixel_bits	bh_vars.h_pixel_bits
#define hunter_report		bh_vars.h_report
#define hunter_check_attr	bh_vars.h_check_attr
#define hunter_areas		bh_vars.h_areas
#define hunter_txterr_prt	bh_vars.h_txterr_prt
#define hunter_gfxerr_max	bh_vars.h_gfxerr_max
#define hunter_filename_sd	bh_vars.h_filename_sd
#define hunter_bios_buffer	bh_vars.h_bios_buffer
#define hunter_bd_cols		bh_vars.h_bd_cols
#define hunter_bd_start		bh_vars.h_bd_start
#define current_mode		bh_vars.hc_mode
#define hunter_chk_mode		bh_vars.h_chk_mode
#define hunter_gfxerr_prt	bh_vars.h_gfxerr_prt

/*
** Functions required by base hunter stuff
*/
#ifdef	ANSI

IMPORT	SHORT	check_inside(USHORT x, USHORT y);
IMPORT	VOID	save_error(int x, int y);
#ifndef	hunter_fopen
IMPORT	int	hunter_getc(FILE *p);
#endif	/* hunter_fopen */

#else	/* ANSI */

IMPORT	SHORT	check_inside();
IMPORT	VOID	save_error();
#ifndef	hunter_fopen
IMPORT	int	hunter_getc();
#endif	/* hunter_fopen */

#endif	/* ANSI */

/*------------------------------------------------------------------------*/

#define HUNTER_TITLE          "SoftPC -- TRAPPER "
#define HUNTER_TITLE_PREV     "SoftPC -- TRAPPER PREVIEW "
#define HUNTER_FLIP_STR       "Flip Screen"
#define HUNTER_DISP_STR       "Display Errors"
#define HUNTER_CONT_STR       "Continue"
#define HUNTER_NEXT_STR       "Next"
#define HUNTER_PREV_STR       "Previous"
#define HUNTER_ABORT_STR      "Abort"
#define HUNTER_ALL_STR        "All"
#define HUNTER_EXIT_STR       "Exit error display"
#define HUNTER_AUTO_ON_STR    "Select box carry On/Off"
#define HUNTER_AUTO_OFF_STR   "Select box delete"
#define HUNTER_DELBOXES_STR   "Delete all boxes"

#define HUNTER_SETTLE_TIME    50        /* about 2.75 secs */
#define HUNTER_SETTLE_NO       5        /* default # of settles before giveup */
#define HUNTER_FUDGE_NO       0      /* default % increase for deltas */
#define HUNTER_START_DELAY   50      /* default additional # of timetix before accepting 1st scancode (about 2.75 secs) */
#define HUNTER_GFXERR_MAX     5      /* default no of grafix errors printed out */
#define HUNTER_TXTERR_MAX     10      /* no of text errors o/p  */
#define HUNTER_FUDGE_NO_ULIM  65535   /* limit made as large as possible */
#define HUNTER_START_DELAY_ULIM 65535 /* for config.c */
#define HUNTER_GFXERR_ULIM   200     /* max no allowed in config.c */
#define HUNTER_SETTLE_NO_ULIM 255     /* as large as possible */
#define IMAGE_ERROR		0
#define REGEN_ERROR		1	/* error type indicators for flipscr */

#define ABORT                 0
#define CONTINUE              1
#define PAUSE                 2
#define PREVIEW               3

#define HUNTER_NEXT			1
#define HUNTER_PREV			2
#define HUNTER_ALL			3
#define HUNTER_EXIT		  	4
 
#define MAX_BOX		     8

#define VIDEO_MODES	      7 /* No of std video modes	 */
#define REQD_REGS	      8 /* MC6845 r0 - r7 */

/* hunter checking equates */
#define HUNTER_SHORT_CHK	0
#define HUNTER_LONG_CHK		1
#define HUNTER_MAX_CHK		2

/* declarations of environment variable variables */

extern half_word hunter_mode;             /* ABORT, PAUSE or CONTINUE */

/* declarations of other globals */

extern boolean   hunter_initialised;  /* TRUE if hunter_init() done */	
extern boolean   hunter_pause;            /* TRUE if PAUSEd */

/* non_check region structure definition */

typedef struct  box_rec {		  
                     boolean    free;
                     boolean    carry;
		     boolean	drawn;
                     USHORT     top_x, top_y;
                     USHORT     bot_x, bot_y;
        	        } BOX;

/* video mode structure definition */
typedef struct mode_rec {
			char	*mnemonic;
			half_word mode_reg;
			half_word R[REQD_REGS];
			} MR;

/*
** Structure for all host functions called from Trapper base functions.
*/

typedef struct
{
#ifdef	ANSI
	/* host initialisation */
	VOID (*init) (half_word hunter_mode);
	
	/* enable/disable menus according to flag */
	VOID (*activate_menus) (BOOL activate);

	/* for flip screen */
	VOID (*flip_indicate) (BOOL sd_file);

	/* for error display */
	VOID (*mark_error) (USHORT x, USHORT y);
	VOID (*wipe_error) (USHORT x, USHORT y);

	/* for RCN menu */
	VOID (*draw_box) (BOX *box);
	VOID (*wipe_box) (BOX *box);

	/* for host image checking - can only be done if data
	** can be read from the host screen
	*/
	ULONG (*check_image) (BOOL initial);
	VOID (*display_image) (BOOL image_swapped);
	VOID (*display_status) (CHAR *message);

#else	/* ANSI */

	/* host initialisation */
	VOID (*init) ();

	/* enable/disable menus according to flag */
	VOID (*activate_menus) ();

	/* for flip screen */
	VOID (*flip_indicate) ();

	/* for error display */
	VOID (*mark_error) ();
	VOID (*wipe_error) ();

	/* for RCN menu */
	VOID (*draw_box) ();
	VOID (*wipe_box) ();

	/* for host image checking - can only be done if data
	** can be read from the host screen
	*/
	ULONG (*check_image) ();
	VOID (*display_image) ();
	VOID (*display_status) ();
#endif	/* ANSI */
}
	HUNTER_HOST_FUNCS;
	
IMPORT	HUNTER_HOST_FUNCS	hunter_host_funcs;

/*
** Macros for calling all the host hunter functions
*/

#define	hh_init(mode)		(hunter_host_funcs.init) (mode)
#define	hh_activate_menus(flag)	(hunter_host_funcs.activate_menus) (flag)
#define	hh_flip_indicate(sd)	(hunter_host_funcs.flip_indicate) (sd)
#define	hh_mark_error(x, y)	(hunter_host_funcs.mark_error) (x, y)
#define	hh_wipe_error(x, y)	(hunter_host_funcs.wipe_error) (x, y)
#define	hh_draw_box(box_ptr)	(hunter_host_funcs.draw_box) (box_ptr)
#define	hh_wipe_box(box_ptr)	(hunter_host_funcs.wipe_box) (box_ptr)
#define	hh_check_image(init)	(hunter_host_funcs.check_image) (init)
#define	hh_display_image(swap)	(hunter_host_funcs.display_image) (swap)
#define	hh_display_status(msg)	(hunter_host_funcs.display_status) (msg)

/*
** Structure for all base Trapper functions which may be called from the
** host.
*/

typedef struct
{
#ifdef	ANSI
	/* Functions called by Trapper menu */
	VOID (*start_screen) (USHORT screen_no);	/* Fast forward */
	VOID (*next_screen) (VOID);
	VOID (*prev_screen) (VOID);
	VOID (*show_screen) (USHORT screen_no, BOOL compare);
	VOID (*continue_trap) (VOID);
	VOID (*abort_trap) (VOID);
	
	/* Functions called by Errors menu */
	VOID (*flip_screen) (VOID);
	VOID (*next_error) (VOID);
	VOID (*prev_error) (VOID);
	VOID (*all_errors) (VOID);
	VOID (*wipe_errors) (VOID);
	
	/* Functions called by RCN menu */
	VOID (*delete_box) (VOID);
	VOID (*carry_box) (VOID);
	
	/* Functions called from mouse event handling */
	VOID (*select_box) (USHORT x, USHORT y);
	VOID (*new_box) (BOX *box);

#else	/* ANSI */

	/* Functions called by Trapper menu */
	VOID (*start_screen) ();	/* Fast forward */
	VOID (*next_screen) ();
	VOID (*prev_screen) ();
	VOID (*show_screen) ();
	VOID (*continue_trap) ();
	VOID (*abort_trap) ();
	
	/* Functions called by Errors menu */
	VOID (*flip_screen) ();
	VOID (*next_error) ();
	VOID (*prev_error) ();
	VOID (*all_errors) ();
	VOID (*wipe_errors) ();
	
	/* Functions called by RCN menu */
	VOID (*delete_box) ();
	VOID (*carry_box) ();
	
	/* Functions called from mouse event handling */
	VOID (*select_box) ();
	VOID (*new_box) ();
#endif	/* ANSI */
}
	HUNTER_BASE_FUNCS;
	
IMPORT	HUNTER_BASE_FUNCS	hunter_base_funcs;

/*
** Macros to access the base functions defined above.
*/

#define	bh_start_screen(scr_no)	(hunter_base_funcs.start_screen) (scr_no)
#define	bh_next_screen()	(hunter_base_funcs.next_screen) ()
#define	bh_prev_screen()	(hunter_base_funcs.prev_screen) ()
#define	bh_show_screen(scr_no, compare) \
		(hunter_base_funcs.show_screen) (scr_no, compare)
#define	bh_continue()		(hunter_base_funcs.continue_trap) ()
#define	bh_abort()		(hunter_base_funcs.abort_trap) ()
#define	bh_flip_screen()	(hunter_base_funcs.flip_screen) ()
#define	bh_next_error()		(hunter_base_funcs.next_error) ()
#define	bh_prev_error()		(hunter_base_funcs.prev_error) ()
#define	bh_all_errors()		(hunter_base_funcs.all_errors) ()
#define	bh_wipe_errors()	(hunter_base_funcs.wipe_errors) ()
#define	bh_delete_box()		(hunter_base_funcs.delete_box) ()
#define	bh_carry_box()		(hunter_base_funcs.carry_box) ()
#define	bh_select_box(x, y)	(hunter_base_funcs.select_box) (x, y)
#define	bh_new_box(box_ptr)	(hunter_base_funcs.new_box) (box_ptr)

/*
** Structure for the display adapter specific functions.
*/

typedef	struct
{
#ifdef	ANSI
	BOOL (*get_sd_rec) (int rec);	/* Unpack a screen dump */
	BOOL (*init_compare) (VOID);	/* Prepare for comparison */
	long (*compare) (int pending);	/* Do a comparison */
	VOID (*bios_check) (VOID);	/* Check the bios area */
	VOID (*pack_screen)(FILE *dmp_ptr);	/* Pack the SoftPC screen */
	BOOL (*getspc_dump)(FILE *dmp_ptr, int rec);	/* Unpk SoftPC screen */
	VOID (*flip_regen) (BOOL swapped);	/* Swap dumped and real scrs */
	VOID (*preview_planes) (VOID);	/* View the dump data in preview mode */

#ifdef	EGG
	VOID (*check_split) (VOID);		/* Check for split screen */
	VOID (*set_line_compare) (int value);	/* Set line compare register */
	int (*get_line_compare) (VOID);		/* Get line compare reg value */
	int (*get_max_scan_lines) (VOID);	/* Get max scan lines value */
#endif	/* EGG */

#else	/* ANSI */

	BOOL (*get_sd_rec) ();		/* Unpack a screen dump */
	BOOL (*init_compare) ();	/* Prepare for comparison */
	long (*compare) ();		/* Do a comparison */
	VOID (*bios_check) ();		/* Check the bios area */
	VOID (*pack_screen)();		/* Pack the SoftPC screen */
	BOOL (*getspc_dump)();		/* Unpk SoftPC screen */
	VOID (*flip_regen) ();		/* Swap the dumped and real screen */
	VOID (*preview_planes) ();	/* View the dump data in preview mode */

#ifdef	EGG
	VOID (*check_split) ();		/* Check for split screen */
	VOID (*set_line_compare) ();	/* Set line compare register */
	int (*get_line_compare) ();	/* Get line compare reg value */
	int (*get_max_scan_lines) ();	/* Get max scan lines value */
#endif	/* EGG */

#endif	/* ANSI	*/
}
	HUNTER_VIDEO_FUNCS;

IMPORT	HUNTER_VIDEO_FUNCS	*hv_funcs;

/*
** Macros to access the hunter video functions
*/
#define	hv_get_sd_rec(rec)		(hv_funcs->get_sd_rec)(rec)
#define	hv_init_compare()		(hv_funcs->init_compare)()
#define	hv_compare(pending)		(hv_funcs->compare)(pending)
#define	hv_bios_check()			(hv_funcs->bios_check)()
#define	hv_pack_screen(file_ptr)	(hv_funcs->pack_screen)(file_ptr)
#define	hv_getspc_dump(file_ptr, rec)	(hv_funcs->getspc_dump)(file_ptr, rec)
#define	hv_flip_regen(swapped)		(hv_funcs->flip_regen)(swapped)
#define hv_preview_planes()		(hv_funcs->preview_planes)()

#ifdef	EGG
#define	hv_check_split()		(hv_funcs->check_split)()
#define	hv_set_line_compare(value)	(hv_funcs->set_line_compare)(value)
#define	hv_get_line_compare()		(hv_funcs->get_line_compare)()
#define	hv_get_max_scan_lines()		(hv_funcs->get_max_scan_lines)()
#endif	/* EGG */
	
/* Macros for printfs. TTn for information; TEn for errors; TWn for warnings.
** Note - these macros have been designed to "swallow the semicolon" and
** evaluate as a single expression so it's quite ok to write the following
** code:
**		if (something)
**			TT0("dfhjjgjf");
**		else
**			TE0("gfdg");
*/

#define PS0(s)			fprintf(trace_file, s)
#define	PS1(s, a1)		fprintf(trace_file, s, a1)
#define	PS2(s, a1, a2)		fprintf(trace_file, s, a1, a2)
#define	PS3(s, a1, a2, a3)	fprintf(trace_file, s, a1, a2, a3)
#define	PS4(s, a1, a2, a3, a4)	fprintf(trace_file, s, a1, a2, a3, a4)
#define	PS5(s, a1, a2, a3, a4, a5)	\
				fprintf(trace_file, s, a1, a2, a3, a4, a5)
#define	PS6(s, a1, a2, a3, a4, a5, a6)	\
				fprintf(trace_file, s, a1, a2, a3, a4, a5, a6)
#define	PS7(s, a1, a2, a3, a4, a5, a6, a7)		\
				fprintf(trace_file,	\
					s, a1, a2, a3, a4, a5, a6, a7)
#define	PS8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				fprintf(trace_file,	\
					s, a1, a2, a3, a4, a5, a6, a7, a8)
#ifndef	newline
#define	newline			PS0("\n")
#endif	/* newline */

#define	TP0(is, s)		(VOID)(					\
				PS0(is),				\
				PS0(s),					\
				newline					\
				)
#define	TP1(is, s, a1)		(VOID)(					\
				PS0(is),				\
				PS1(s, a1),				\
				newline					\
				)
#define	TP2(is, s, a1, a2)	(VOID)(					\
				PS0(is),				\
				PS2(s, a1, a2),				\
				newline					\
				)
#define	TP3(is, s, a1, a2, a3)	(VOID)(					\
				PS0(is),				\
				PS3(s, a1, a2, a3),			\
				newline					\
				)
#define	TP4(is, s, a1, a2, a3, a4)					\
				(VOID)(					\
				PS0(is),				\
				PS4(s, a1, a2, a3, a4),			\
				newline					\
				)
#define	TP5(is, s, a1, a2, a3, a4, a5)					\
				(VOID)(					\
				PS0(is),				\
				PS5(s, a1, a2, a3, a4, a5),		\
				newline					\
				)
#define	TP6(is, s, a1, a2, a3, a4, a5, a6)				\
				(VOID)(					\
				PS0(is),				\
				PS6(s, a1, a2, a3, a4, a5, a6),		\
				newline					\
				)
#define	TP7(is, s, a1, a2, a3, a4, a5, a6, a7)				\
				(VOID)(					\
				PS0(is),				\
				PS7(s, a1, a2, a3, a4, a5, a6, a7),	\
				newline					\
				)
#define	TP8(is, s, a1, a2, a3, a4, a5, a6, a7, a8)			\
				(VOID)(					\
				PS0(is),				\
				PS8(s, a1, a2, a3, a4, a5, a6, a7, a8),	\
				newline					\
				)

#define	TT0(s)			TP0("TRAPPER: ", s)
#define	TT1(s, a1)		TP1("TRAPPER: ", s, a1)
#define	TT2(s, a1, a2)		TP2("TRAPPER: ", s, a1, a2)
#define	TT3(s, a1, a2, a3)	TP3("TRAPPER: ", s, a1, a2, a3)
#define	TT4(s, a1, a2, a3, a4)	TP4("TRAPPER: ", s, a1, a2, a3, a4)
#define	TT5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER: ", s, a1, a2, a3, a4, a5)
#define	TT6(s, a1, a2, a3, a4, a5, a6)	\
				TP6("TRAPPER: ", s, a1, a2, a3, a4, a5, a6)
#define	TT7(s, a1, a2, a3, a4, a5, a6, a7)	\
				TP7("TRAPPER: ", s, a1, a2, a3, a4, a5, a6, a7)
#define	TT8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				TP8("TRAPPER: ",	\
				s, a1, a2, a3, a4, a5, a6, a7, a8)

#define	TE0(s)			TP0("TRAPPER error: ", s)
#define	TE1(s, a1)		TP1("TRAPPER error: ", s, a1)
#define	TE2(s, a1, a2)		TP2("TRAPPER error: ", s, a1, a2)
#define	TE3(s, a1, a2, a3)	TP3("TRAPPER error: ", s, a1, a2, a3)
#define	TE4(s, a1, a2, a3, a4)	TP4("TRAPPER error: ", s, a1, a2, a3, a4)
#define	TE5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER error: ", s, a1, a2, a3, a4, a5)
#define	TE6(s, a1, a2, a3, a4, a5, a6)	\
				TP6("TRAPPER error: ", s, a1, a2, a3, a4, a5, a6)
#define	TE7(s, a1, a2, a3, a4, a5, a6, a7)		\
				TP7("TRAPPER error: ",	\
				s, a1, a2, a3, a4, a5, a6, a7)
#define	TE8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				TP8("TRAPPER error: ",	\
				s, a1, a2, a3, a4, a5, a6, a7, a8)

#define	TW0(s)			TP0("TRAPPER warning: ", s)
#define	TW1(s, a1)		TP1("TRAPPER warning: ", s, a1)
#define	TW2(s, a1, a2)		TP2("TRAPPER warning: ", s, a1, a2)
#define	TW3(s, a1, a2, a3)	TP3("TRAPPER warning: ", s, a1, a2, a3)
#define	TW4(s, a1, a2, a3, a4)	TP4("TRAPPER warning: ", s, a1, a2, a3, a4)
#define	TW5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER warning: ", s, a1, a2, a3, a4, a5)
#define	TW6(s, a1, a2, a3, a4, a5, a6)					\
				TP6("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6)
#define	TW7(s, a1, a2, a3, a4, a5, a6, a7)				\
				TP7("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6, a7)
#define	TW8(s, a1, a2, a3, a4, a5, a6, a7, a8)				\
				TP8("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6, a7, a8)
/*
 * ============================================================================
 * Function definitions
 * ============================================================================
 */

/* function in keybd_io, only called by hunter */
extern int bios_buffer_size();

/* function in keyba, only called by hunter */
extern int buffer_status_8042();

/* functions in hunter called from reset, timer */
extern void hunter_init();
extern void do_hunter();

#endif	/* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\jcgensyn.h ===
# define NAME 257
# define STRING 258
# define CONSTANT 259
# define DIGEST 260
# define OPSUB0 261
# define OPSUB1 262
# define OPSUB2 263
# define LSQUARE 264
# define RSQUARE 265
# define OR 266
# define COMMA 267
# define ARROW 268
# define LCURL 269
# define RCURL 270
# define LBRACKET 271
# define RBRACKET 272
# define SEMICOLON 273
# define LANGLE 274
# define RANGLE 275
# define COLON 276
# define STAR 277
# define DOT 278
# define INVALID 279
# define MODENAME 280
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ica.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	: Interrupt Controller Adapter definitions
 *
 * Description	: Include file for users of the ICA
 *
 * Author	: Jim Hatfield / David Rees
 *
 * Notes	: Rewritten from an original by Henry Nash
 */

/* SccsID[]="@(#)ica.h	1.25 10/19/95 Copyright Insignia Solutions Ltd."; */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#define	ICA_MASTER	0
#define ICA_SLAVE	1

#define	EGA_VTRACE_INT	2
#define	AT_EGA_VTRACE_INT	1
#define	AT_EGA_VTRACE_ADAPTER	1

/*
 * Allow the host to override the default values if its wants to
 */
#ifndef HOST_CPU_MOUSE_INT
#define HOST_AT_CPU_MOUSE_INT           1
#define HOST_AT_CPU_MOUSE_ADAPTER       1
#define HOST_AT_MOUSE_INT_VEC           0x0a
#define HOST_CPU_MOUSE_INT              2
#endif /* HOST_CPU_MOUSE_INT */
/*
 * CPU hardware interrupt definitions
 */
/* For the XT */
#define CPU_TIMER_INT   	0
#define CPU_KB_INT      	1
#define CPU_MOUSE_INT      	HOST_CPU_MOUSE_INT
#define AT_CPU_MOUSE_INT      	HOST_AT_CPU_MOUSE_INT
#define AT_CPU_MOUSE_ADAPTER	HOST_AT_CPU_MOUSE_ADAPTER
#define	MOUSE_VEC		HOST_AT_MOUSE_INT_VEC
#if defined(NEC_98)
#define CPU_CRTV_INT            2
#endif // NEC_98
#define CPU_RS232_SEC_INT   	3
#define CPU_RS232_PRI_INT   	4
#define CPU_DISK_INT   		5
#define CPU_DISKETTE_INT   	6
#define CPU_PRINTER_INT   	7

#if defined(NEC_98)
#define CPU_NO_DEVICE          -1
#define CPU_RS232_THIRD_INT    12
#endif

/* Different lines for the AT */
#define CPU_PRINTER2_INT	5

/*
 * For the Slave Chip on the AT
 */
#define CPU_RTC_INT		0

#if defined (NOVELL) || defined (NOVELL_IPX)
#define NETWORK_INT		2
#endif

#if defined (SWIN_HAW) 
#define SWIN_HAW_INT		3
#endif

#if defined (ASPI)
#define ASPI_INT		4
#endif

#define CPU_AT_NPX_INT		5	/* NPX exception */
#define CPU_AT_DISK_INT		6

 
#ifndef CPU_30_STYLE

/* def of bits in the CPU_INTERRUPT_MAP ?? */
#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */
 
#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)
#endif /* 3.0 CPU */

#define DIVIDE_OVERFLOW_INT     0

#define	END_INTERRUPT	0x20

extern void ica0_init IPT0();
extern void ica1_init IPT0();
extern void ica0_post IPT0();
extern void ica1_post IPT0();

extern void ica_hw_interrupt_cancel IPT2(IU32, adapter, IU32, line_no);
extern IU8 ica_scan_irr IPT1(IU32, adapter);
extern void ica_interrupt_cpu IPT2(IU32, adapter, IU32, line);
extern void ica_eoi IPT3(IU32, adapter, IS32 *, line, IBOOL, rotate);

#if defined (NTVDM)

#ifdef MONITOR
extern void ica_iret_hook_called IPT1(IU32, line);
extern void ica_iret_hook_control IPT3(IU32, adapter, IU32, line, IBOOL, enable);
#endif

VOID ica_RestartInterrupts(ULONG);
extern IS32 ica_intack IPT1(IU32 *, hook_addr);

extern void ica_clear_int(IU32 adapter, IU32 line);
extern void ica_inb(io_addr port, IU8 *val);
extern void ica_outb(io_addr port, IU8 val);
extern void ica_hw_interrupt(IU32 adapter, IU32 line_no, IS32 call_count);




/*
 *  The NTVDM ica adapter structure has been moved to \nt\private\inc\vdm.h
 *  and is almost identical to the standard softpc ica adapter structure.
 *  It was Extracted to make it visible clearly from the monitor\kernel on
 *  x86
 *
 *  Notable differences:
 *  1. added ica_delayedints field for ntvdm's implementaion of delayed ints
 *  2. type definitions have change to match win32
 *  3. ADAPTER_STATE has been renamed to VDMVIRTUALICA
 *  4. Does not implement CPU_40 iret hooks
 *
 */
#include <vdm.h>
extern VDMVIRTUALICA VirtualIca[];

#else   /* ndef NTVDM */

extern void SWPIC_clear_int IPT2(IU32, adapter, IU32, line_no);
extern void SWPIC_init_funcptrs IPT0();
extern void SWPIC_inb IPT2(io_addr, port, IU8 *, value);
extern void SWPIC_outb IPT2(io_addr, port, IU8, value);
extern void SWPIC_hw_interrupt IPT3(IU32, adapter, IU32, line_no,
	IS32, call_count);

#ifdef HOOKED_IRETS
extern IS32 ica_intack IPT1(IU32 *, hook_addr);
extern void ica_iret_hook_called IPT1(IU32, line);
extern void ica_enable_iret_hooks IPT0();
extern void ica_disable_iret_hooks IPT0();
extern void ica_iret_hook_control IPT3(IU32, adapter, IU32, line, IBOOL, enable);
#else	/* !HOOKED_IRETS */
extern IS32 ica_intack IPT0();
#endif	/* !HOOKED_IRETS */

#ifdef CPU_40_STYLE
typedef void (*ICA_CALLBACK) IPT1(IU32, parm);
extern IBOOL action_interrupt IPT4(IU32, adapter, IU32, line, ICA_CALLBACK, func, IU32, parm);
extern void cancel_action_interrupt IPT2(IU32, adapter, IU32, line);
extern void ica_async_hw_interrupt IPT3(IU32, adapter, IU32, line_no,
        IS32, call_count);

extern void ica_check_stale_iret_hook IPT0();
#define MAX_ISR_DEPTH   3   /* max recursion level of ISR before ints blocked */
#define MAX_INTR_DELTA_FOR_LOST_HOOK	85
#endif /* CPU_40_STYLE */

typedef struct {
        IBOOL	ica_master;   /* TRUE = Master; FALSE = Slave		*/

	IU8	ica_irr;	/* Interrupt Request Register		*/
	IU8	ica_isr;	/* In Service Register			*/
	IU8	ica_imr;	/* Interrupt Mask Register		*/
	IU8	ica_ssr;	/* Slave Select Register		*/

	IU16	ica_base;	/* Interrupt base address for cpu	*/
	IU16	ica_hipri;	/* Line no. of highest priority line	*/
	IU16	ica_mode;	/* Various single-bit modes		*/

	IS32	ica_count[8];	/* This is an extension of ica_irr for	*/
				/* our frig. Contains HOW MANY of each	*/
				/* interrupt is required		*/
	IU32	ica_int_line;	/* Current pending interrupt		*/
				/* being counted down by the CPU	*/

	IU32	ica_cpu_int;	/* The state of the INT line to the CPU	*/

#ifdef CPU_40_STYLE             /* callback structure for action_interrupt() */
        IU32    callback_parm[8];       /* callback parameter */
	ICA_CALLBACK callback_fn[8];	/* callback fn */
	IS32	isr_depth[8];	/* iret hook recursion level */
	IS32	isr_progress[8][MAX_ISR_DEPTH + 1];	/* isr aging by int */
	IS32	isr_time_decay[8][MAX_ISR_DEPTH];	/* isr aging by time */
#endif

} ADAPTER_STATE;


/* 'no callback' define for action_interrupt callbacks */
#define NO_ICA_CALLBACK ((ICA_CALLBACK) 0L)

#endif  /* NTVDM */


#if !defined(NTVDM)
#ifdef  REAL_ICA

extern void host_ica_hw_interrupt IPT3(IU32, adap, IU32, line, IS32, cnt);
extern void host_ica_hw_interrupt_delay IPT4(IU32, adap, IU32, line, IS32, cnt, IS32, delay);
extern void host_ica_clear_int IPT2(IU32, adap, IU32, line);

#define ica_hw_interrupt(ms,line,cnt)				host_ica_hw_interrupt(ms, line, cnt)
#define	ica_hw_interrupt_delay(ms,line,cnt,delay)	host_ica_hw_interrupt(ms, line, cnt)
#define ica_clear_int(ms, line)						host_ica_clear_int(ms, line)

#else   /* REAL_ICA */

/*
 *  Change these. They come last.
 */

#define ica_inb(port,val)                       ((*ica_inb_func) (port,val))
#define ica_outb(port,val)                      ((*ica_outb_func) (port,val))
#define ica_hw_interrupt(ms,line,cnt)           ((*ica_hw_interrupt_func) (ms,line,cnt))
#define ica_clear_int(ms,line)                  ((*ica_clear_int_func) (ms,line))

 
/*
 *  PIC access functions needed for HW & SW
 */
extern void (*ica_inb_func) IPT2(io_addr, port, IU8 *, value);
extern void (*ica_outb_func) IPT2(io_addr, port, IU8, value);
extern void (*ica_hw_interrupt_func) IPT3(IU32, adapter, IU32, line_no,
	IS32, call_count);
extern void (*ica_clear_int_func) IPT2(IU32, adapter, IU32, line_no);

#endif  /* REAL_ICA */
#endif  /* !NTVDM */

#ifdef GISP_CPU
/*
 *	Prototype functions for interfaces provided by the ICA.
 */

typedef IBOOL HOOK_AGAIN_FUNC IPT1(IUM32, callers_ref);
extern void Ica_enable_hooking IPT3(IUM8, line_number,
			HOOK_AGAIN_FUNC *, hook_again, IUM32, callers_ref);

extern void Ica_hook_bop IPT1(IUM8, line_number);

#endif /* GISP_CPU */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ipx.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			ipx.h
 *	Derived From:	Original
 *	Author:			Jase
 *	Created On:		Oct 6 1992
 *	Sccs ID:		12/11/92 @(#)ipx.h	1.5
 *	Purpose:		Base defines & typedefs for IPX implementations.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 *	Rcs ID:			
 *			$Source: /masterNeXT3.0/host/inc/RCS/next_novell.h,v $
 *			$Revision: 1.2 $
 *			$Date: 92/10/15 14:37:48 $
 *			$Author: jason $
 ]*/

/* DEFINES */

/* IPX device file */
#define		sIPXDevice						"/dev/ipx"

/* IPX function selector codes */
#define		kIPXOpenSocket					0x00
#define		kIPXCloseSocket					0x01
#define		kIPXGetLocalTarget				0x02
#define		kIPXSendPacket					0x03
#define		kIPXListenForPacket				0x04
#define		kIPXScheduleEvent				0x05
#define		kIPXCancelEvent					0x06
/* note missing 0x07 selector */
#define		kIPXGetIntervalMarker			0x08
#define		kIPXGetInternetAddress			0x09
#define		kIPXRelinquishControl			0x0a
#define		kIPXDisconnectFromTarget		0x0b

/* SPX function selector codes */
#define		kSPXInitialize					0x10
#define		kSPXEstablishConnection			0x11
#define		kSPXListenForConnection			0x12
#define		kSPXTerminateConnection			0x13
#define		kSPXAbortConnection				0x14
#define		kSPXGetConnectionStatus			0x15
#define		kSPXSendSequencedPacket			0x16
#define		kSPXListenForSequencedPacket	0x17

/* selector code bounds */
#define		kMinSelector					0x00
#define		kMaxSelector					0x17

/* in-use codes */
#define		kAvailable						0x00
#define		kCounting						0xfd
#define		kListening						0xfe
#define		kSending						0xff

/* completion codes */
#define		kSuccess						0x00
#define		kWatchdogTerminate				0xed
#define		kNoPathFound					0xfa
#define		kEventCancelled					0xfc
#define		kPacketOverflow					0xfd
#define		kSocketTableFull				0xfe
#define		kNotInUse						0xff
#define		kSocketAlreadyOpen				0xff
#define		kNoSuchSocket					0xff

/* number of open sockets we support */
/* currently at IPX maximum */
#define		kMaxOpenSockets					150

/* maximum size of IPX packet */
#define		kMaxPacketSize					576

/* packet buffer size */
#define		kPacketBufferSize				1536

/* maximum NCP data size - for IPXGetBufferSize function */
#define		kMaxNCPDataSize					1024

/* size of IPX header */
#define		kHeaderSize						30

/* event types */
#define		kNoEvent						0
#define		kIPXEvent						1
#define		kAESEvent						2

/********************************************************/

/* TYPEDEFS */

/* IPX structures */

typedef struct
{
	USHORT			packetChecksum;
	USHORT			packetLength;
	UTINY			packetControl;
	UTINY			packetType;
	UTINY			packetDestNet [4];
	UTINY			packetDestNode [6];
	UTINY			packetDestSock [2];
	UTINY			packetSrcNet [4];
	UTINY			packetSrcNode [6];
	UTINY			packetSrcSock [2];

} IPXHeaderRec;

typedef struct
{
	UTINY			net [4];
	UTINY			node [6];
	UTINY			sock [2];

} IPXAddressRec;

/* DOS ECB record (from NetWare DOS Programmers Guide) */
typedef struct ECB
{
	sys_addr		ecbLinkAddress;
	UTINY			ecbESRAddress [4];
	UTINY			ecbInUseFlag;
	UTINY			ecbCompletionCode;
	USHORT			ecbSocketNumber;
	UTINY			ecbIPXWorkspace [4];
	UTINY			ecbDriverWorkspace [12];
	UTINY			ecbImmediateAddress [6];
	USHORT			ecbFragmentCount;
	UTINY			ecbFragmentAddress1 [4];
	USHORT			ecbFragmentSize1;
	UTINY			ecbFragmentAddress2 [4];
	USHORT			ecbFragmentSize2;

} ECBRec;

/* host IPX implementation structures */

typedef struct
{
	int				socketFD;
	USHORT			socketNumber;
	BOOL			socketTransient;

} SocketRec;

/* linked-list of IPX or AES events */
typedef struct Event
{
	struct Event	*eventNext;
	struct Event	*eventPrev;
	UTINY			eventType;
	sys_addr		eventECB;
	SocketRec		*eventSocket;
	USHORT			eventClock;

} EventRec;

typedef struct
{
	BOOL			ipxInitialised;
	USHORT			ipxSelector;
	USHORT			ipxClock;
	UTINY			ipxNetwork [4];
	UTINY			ipxNode [6];
	UTINY			ipxBuffer [kPacketBufferSize];
	SocketRec		ipxSockets [kMaxOpenSockets];
	EventRec		*ipxQueue;
	EventRec		*ipxEvent;

} IPXGlobalRec;

/********************************************************/

/* PROTOTYPES */

/* imports */

/* dispatchers */
IMPORT VOID			IPXBop IPT0 ();
IMPORT VOID			IPXHost IPT0 ();

/* host interface stuff */
IMPORT BOOL			host_ipx_init IPT0 ();

IMPORT VOID			host_ipx_tick IPT0 ();

IMPORT VOID			host_ipx_raise_exception IPT0 ();

IMPORT BOOL			host_ipx_open_socket IPT1 (SocketRec *, socket);
IMPORT VOID			host_ipx_close_socket IPT1 (SocketRec *, socket);

IMPORT VOID			host_ipx_send_packet IPT1 (SocketRec *, socket);
IMPORT BOOL			host_ipx_poll_socket IPT1 (SocketRec *, socket);

IMPORT VOID			host_ipx_load_packet IPT2
	(SocketRec *, socket, sys_addr, ecbAddress);
IMPORT BOOL			host_ipx_save_packet IPT2
	(SocketRec *, socket, sys_addr, ecbAddress);

IMPORT BOOL			host_ipx_rip_query IPT1 (IPXAddressRec *, ipxAddr);

/* base stuff accessed from host */

IMPORT EventRec 	*FindEvent IPT3
	(UTINY, linkType, sys_addr, ecbAddress, SocketRec *, linkSocket);

/********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\jformate.h ===
/*[
 *	Name:           jformatE.h
 *
 *      Derived From:   (original)
 *
 *      Author:        	Jerry Kramskoy
 *
 *      Created On:    	16 April 1993
 *
 *      Sccs ID:        @(#)jformatE.h	1.16 04/21/95
 *
 *      Purpose:      	describes the file format for the host binary
 *			emitted by 'jcc'.
 *
 *      Design document:/HWRD/SWIN/JCODE/jcobjfmt
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/


/* 

   History:
   ===================================================
   	version 04/21/95:	extended object file format.
   ===================================================

   if JLD_OBJFILE_HDR.magic == JLD_OBJ_MAGIC, then no JLD_OBJFILE_EXT or JLD_SECTION_EXT records are present.

   If JLD_OBJFILE_HDR.magic == JLD_OBJ_MAGIC_X, this is an extended object file format ...
   then a JLD_OBJFILE_EXT record immediately follows the JLD_OBJFILE_HDR, and
   a JLD_SECTION_EXT record immediately follows a JLD_SECTION_HDR.

   For extended format, the first code segment in the file is ALWAYS aligned to a cache-line boundary.

 */


/*
	The object file contains the target-machine binary emitted via
	jcc, along with header information.

	the input file to jcc may contain many sections of jcode.  jcc emits
	code/data into one of 8 selectable segments associated with one
	section.  These segment types (enum JLD_SEGTYPES) are:

	(IF NEW EXECUTABLE TYPES OF SEGMENT ARE ADDED, UPDATE the macro
	JLD_IS_EXECUTABLE below)

		JLD_CODE		-- inline host code derived from Jcode 
		JLD_CODEOUTLINE		-- out of line host code derived from Jcode
		JLD_DATA		-- host data derived from Jcode
		JLD_APILOOKUP		-- api lookup data

		JLD_IMPORTS		-- externals required for section
		JLD_EXPORTS		-- addresses exported from section to OTHER sections
		JLD_STRINGSPACE		-- string space to hold all symbol names defd/refd in section
		JLD_INTELBIN		-- intel binary as labelled Jcode data for debugging
		JLD_INTELSYM		-- intel symbolic as labelled Jcode data for debugging
		JLD_SYMJCODE		-- generated streamed Jcode as labelled Jcode data
					   for debugging
		JLD_DEBUGTAB		-- tuples of JADDRS pointing to labels in the above
					   three segment types and the generated host code
					   for debugging
		JLD_D2SCRIPT		-- debug test script information encoded as a stream
		JLD_CLEANUP		-- cleanup records
		JLD_PATCH		-- compiler-generated patch up requests
					   of data bytes in JDATA form, no labels.

	jcc allows separate compilations of sections from the input file
	to produce separate object files. e.g; sections 1,2 ->file A
	section 3 -> file B, and sections 4->20 in file C.

	This format describes the contents of one of these files.  The file
	layout is:

		----------------------
		! obj.file hdr       !
		---------------------- <=== extension file hdr, if present
		! section hdr for 1st!
		! section	     !
		---------------------- <=== extension section 1 hdr, if present
		! segments for 1st   !
		! section	     !
		----------------------
		! section hdr for 2nd!
		! section	     !
		---------------------- <=== extension section 2 hdr, if present
		! segments for 2nd   !
		! section	     !
		----------------------
		!		     !
		!	etc.	     !
		!		     !
		----------------------
		! section hdr for Nth!
		! section	     !
		---------------------- <=== extension section 3 hdr, if present
		! segments for Nth   !
		! section	     !
		----------------------

	Linking amalgamates the sections into one section for all the files
	presented to the process.  Files are processed in order of occurrence in
	the command line.  Per file the following actions occur ...

	The sections are processed in order of occurrence in the file.
	This produces one section for the file.

	Within a section, segments are always processed in order,
	from lowest enum value (JLD_CODE) upto, but excluding JLD_NSEGS.

	Normally, each segment has its own space allocation, so that all the contents
	of JLD_DATA segments are grouped together in an area separate to, say, the
	contents for JLD_IMPORTS.  As a section is processed, the contents of its
	different segment types are concatenated into their respective spaces.
	However, different segment types can be GROUPED to SHARE the SAME space.
	If segment type X is attributed with segment group X, then its space allocation
	is taken from X's overall space.  If segment type X is attributed with segment
	group Y, then this causes the following to happen ...

		1]. No memory is allocated for segment type X.
		2]. The size of segment type X is totalled in with the size of
		    segment type Y.
		3]. The segment contents for X get concatenated into Y.  The order of
		    this concatenation is governed by where segment type X occurs in 
		    the segment processing order, based upon its enum, as stated above.

	For example, suppose we only have 5 segment types ... A,B,C,D and E.  Let's
	suppose we set the segment attributes as {A, C, D all map to segment group of type A}, 
	{B maps to segment group of type B}, and {E maps to segment group of type E}.
	Also suppose our segment types are enumerated in the order {B=0,C,A,E,D}.
	Finally suppose we have a file with 2 sections, where

1.		(sect #1, segType A is 100 bytes long),
2.		(sect #1, segType B is 200 bytes long),
3.		(sect #1, segType C is 300 bytes long),
4.		(sect #1, segType D is 400 bytes long),
5.		(sect #1, segType E is 500 bytes long),
6.		(sect #2, segType A is 110 bytes long),
7.		(sect #2, segType B is 120 bytes long),
8.		(sect #2, segType C is 130 bytes long),
9.		(sect #2, segType D is 140 bytes long),
10.		(sect #2, segType E is 0 bytes long),

	Overall sizing would add up the sizes of all segments, attributing the space
	to the segment type of the group to which the segment belongs.  Hence we get the
	following total sizes ...

		segType A needs sz(1) + sz(3) + sz(4) + sz(6) + sz(8) + sz(9) = 1180 bytes
		segType B needs sz(2) + sz(7) = 320 bytes
		segType C needs 0 bytes (allocated out of segType A)
		segType D needs 0 bytes (ditto)
		segType E needs 500 bytes.

	We hence have a requirement for 'globally allocated segments' of types A,B and E
	of sizes 1180,320 and 500 bytes respectively.

	As sect #1 is processed, we process segment types in the order B,C,A,E,D as per
	the enum.  We use the segment group associated with the segment type to select
	which actual segment type to copy the segment contents into, so we would be
	allocating (2) out of B, then (3) out of A, then (1) out of A, then (5) out of E,
	and finally (4) out of A giving ...

	A:			B:			E:
		------------		-------------		--------------
	0	! cont(3)  !	0	! cont(2)   !  	0	! cont(5)    !
		------------  		-------------		--------------
	300	! cont(1)  !	200	! free	    !	500	! free	     !
		------------  		-------------		--------------
	400	! cont(4)  !
		------------
	800	! free     !
		------------
	

	Then section #2 is processed in the same manner, and we allocate the space
	the same way, allocating (7) out of B, then (8) out of A, then (6) out of A, then (10) out of E,
	and finally (9) out of A giving ...
	
	A:			B:			E:
		------------		-------------		--------------
	0	! cont(3)  !	0	! cont(2)   !  	0	! cont(5)    !
		------------  		-------------		--------------
	300	! cont(1)  !	200	! cont(7)   !	500	! free       !
		------------  		-------------		--------------
	400	! cont(4)  !	320	! free      !
		------------		-------------
	800	! cont(8)  !
		------------
	930	! cont(6)  !
		------------
	1040	! cont(9)  !
		------------
	1180	! free	   !
		------------

	Currently, we are grouping JLD_CODE and JLD_CODEOUTLINE together, to share the
	JLD_CODE segment type.  This allows pc-relative branching to be used to access
	the out-of-line code from the in-line code.  If these weren't grouped, then the
	JLD_CODEOUTLINE segment would load after all the inline code (given current enums)
	and would probably be unreachable efficiently.

	Other files would concatenate into these segments in the exactly the same manner.

	If we are linking, rather than loading, then the output binary file contains 1 section,
	with five segments, two which are empty, and the other three are of segment types
	A,B and E, of sizes 1180, 320 and 500 respectively.  LINKING MUST ALWAYS BE DONE, when
	more than one section is involved.

	On loading, the order these segments occur in memory is also controlled by the segment
	type enum.  Lower value enums appear lower in memory.  The loader only expects ONE linked
	binary file, and hence will refuse to load if the file contains more than one section.
	This section is executable PROVIDED that all unresolved references (i.e;
	extant IMPORTs and Intel relocs) can be resolved dynamically at load time.  The loader
	can be called at any time, but for patching up of Intel relocatable values, this
	must be after Windows has loaded within Softwin.  

	
	When loaded, the section is laid out, within the DATA space of the process, as 

			--------------------
			!	code seg   !
			--------------------
			!	data seg   !
			--------------------
			!   api lookup seg !
			--------------------
*/


/*===========================================================================*/
/*			INTERFACE DATA TYPES				     */
/*===========================================================================*/
/* version 0 does NOT support extension records */
#define JLD_VERSION_NUMBER	1

#define JLD_MAX_INPUTFILES	1000

/* segment types */
/* ------------- */

/* These should be cast to IU16 values, before emitting in obj.file */

/* NOTE: the patch segment should follow the others, since the binary
 * code generation assumes that any labels used in the PATCH segment
 * are defined earlier.
 */

typedef enum
{

JLD_CODE=0,			/* inline host code derived from Jcode */
JLD_CODEOUTLINE,		/* out of line host code derived from Jcode */
JLD_DATA,			/* host data derived from Jcode */
JLD_APILOOKUP,			/* api lookup data		*/
JLD_STRINGSPACE,		/* string space to hold all symbol names defd/refd in section */
JLD_EXPORTS,			/* addresses exported from section to OTHER sections */
JLD_IMPORTS,			/* externals required for section */

/* segments providing information for debugging tools */
JLD_INTELBIN,		/* the original intel binary being turned into Jcode by
					   flowBm, packaged as a set of JDATA operations, one per`
					   byte of Intel instruction. The first byte of each Intel
					   instruction is preceeded by a JLABEL with a symbol of
					   the form "IBnnnn" for the nnnn'th Intel instruction
					   being processed. */
JLD_INTELSYM,		/* the binary from above disassembled and packaged as
					   JDATA operations, with labels of the form "ISnnnn"
					   preceeding the first byte of the nnnn'th Intel 
					   instruction */
JLD_SYMJCODE,		/* the streamed Jcode generated, with labels of the form
					   "SJnnnn" inserted at the start of the code generated 
					   from the nnnn'th Intel instruction */
JLD_DEBUGTAB,		/* a set of four JADDR operations for each Intel 
					   instruction, the addresses in the tuple for the nnnn'th
					   Intel instruction, are thos of the labels "IBnnnn",
					   "ISnnnn", "JBnnnn", and "SJnnnn". The "JBnnnn" labels
					   are inserted in the real Jcode which will be compiled`						   into host binary. These tuples will allow debugging 
					   software to do things like print the Intel binary and/or
					   symbolic instructions that generated a particular host
					   instruction. see typedef for JLD_DEBUGTUPLE below */
JLD_D2SCRIPT,		/* d2Bm script information for running the test "API"
					   compiled into the other segments */

JLD_CLEANUP,			/* cleanup records */
JLD_PATCH,			/* compiler-generated patch up requests */

JLD_NSEGS,			/* #.of above segments */

/* The following don't take any segment space in obj.file.
 * they are only required to specify type of IMPORTed symbol
 * in IMPORT_ENTRYs, for accessing static addresses (determined at
 * process load time)
 */

JLD_CCODE,			/* IMPORT a 'C' static code address */
JLD_CDATA,			/* IMPORT a 'C' static data address */

JLD_ACODE,			/* IMPORT an assembler static code address */
JLD_ADATA,			/* IMPORT an assembler static data address */

JLD_ALLSEGS			/* total #.of different segments	   */

} JLD_SEGTYPES;


typedef enum
{
	RS_8=0,
	RS_16,
	RS_32,
	RS_64,
	RS_UU
} RELOC_SZ;
	


typedef	enum
{
	PATCHABLE=1,
	EXPORTABLE=2,
	DISCARDABLE=4,
	ALLOCATE_ONLY=8
} SEGATTR;


typedef struct 
{
	IUH		attributes;
	JLD_SEGTYPES	segmentGroup;
	CHAR		*name;
} JLD_SEGATTRIBUTES;


typedef struct 
{
	IUH 		*ibPtr;
	CHAR		*isPtr;
	IUH 		*jbPtr;
	CHAR		*sjPtr;
} JLD_DEBUGTUPLE;


typedef struct {
	IU32	segLength[JLD_NSEGS];		/* #.bytes in each segment */
	IU32	segStart[JLD_NSEGS];		/* byte offset into file for each segment */
	IU32	nextSectHdrOffset;		/* file offset to next header (0 if no more) */
} JLD_SECTION_HDR;

/* alignments for code layout */

typedef enum {
	AL_INST=1,
	AL_CACHE_LINE=2,
	AL_PAGE_BOUNDARY=3
} JLD_ALIGN;

#define	JLD_OBJ_MAGIC	0xafaffafa	/* no extension records */
#define	JLD_OBJ_MAGIC_X	0xafaffafb	/* contains extension records */

/* machine types */
#define JLD_HPPA	1
#define JLD_SPARC	2
#define JLD_68K		3
#define JLD_PPC		4
#define JLD_MIPS	5
#define JLD_AXP		6
#define JLD_VAX		7

typedef struct {
	IU32	magic;				/* identify as jcode obj.file 		*/
	IU32	jccVersion;			/* compiler version	      		*/
	IU32	flowBmVersion;			/* flowBm version			*/
	IU32	machine;			/* machine to run this binary on 	*/
	IU32	nSections;			/* #.sections in file			*/
	IU32	firstSectHdrOffset;		/* file offset to first section header  */
} JLD_OBJFILE_HDR;






/* ============================================================================================= */
/*			OBJECT FILE EXTENSIONS							 */
/* ============================================================================================= */

typedef enum {					/* version numbers for obj.file hdr extension record */
	OextVers1=1				/* add new version numbers as required		     */
} JLD_OBJFILE_EXT_VERSIONS;




typedef enum {					/* version numbers for section hdr extension record */
	SextVers1=1				/* add new version numbers as required		    */
} JLD_SECTION_EXT_VERSIONS;




/* extension records */

typedef struct {
	IU32	recLength;			/* size of record, in bytes (includes this IU32) */
	IU32	version;			/* version number for this record */
} JLD_OBJFILE_EXT_Vers1;

typedef struct {
	IU32	recLength;			/* size of record, in bytes (includes this IU32) */
	IU32	version;			/* version number for this record */
	IU32	codeAlign;			/* alignment for code segment ... (IU32)(JLD_ALIGN) */
	IU32	groupId;			/* subroutine sorting group for this section */
	IU32	groupOrdinal;			/* ordinal of this subroutine within sorting group */
} JLD_SECTION_EXT_Vers1;

/* NOTE: A new version derived from current structure MUST contain current structure
 * at top of new structure !!!! ... DO NOT DELETE OLDER VERSION STRUCTURES
 */


/* the current structures that reflects the latest extensions should be indicated
 * here ... ditto for version numbers.
 */
#define	JLD_CURRENT_OBJEXT_VERSION		OextVers1
#define JLD_CURRENT_SECTION_EXT_VERSION		SextVers1


/* compiler and linker output current versions ... */
typedef	JLD_OBJFILE_EXT_Vers1		JLD_CURRENT_OBJEXT;
typedef JLD_SECTION_EXT_Vers1		JLD_CURRENT_SECTION_EXT;

/* the linker/loader understands current and older versions */





/* ============================================================================================= */
/*			RELOCATION								 */
/* ============================================================================================= */

typedef enum
{
	RT_ATTR_NONE=0,
	RT_ATTR_IMPORT_OFFSET=1,
	RT_ATTR_SEG_TYPE=2,
	RT_ATTR_HEX=4
} RTATTRS;

/* attributes for relocation types */
/* see SegRTAttr[] below.  The 'name' is used by jld when printing out relocation
 * type.  The attrib field also controls how reloc.info is printed.
 * If attribute RT_ATTR_IMPORT_OFFSET, then it expects to find an IMPORT_ENTRY with
 * offset into STRINGSPACE, where name is stored.
 * If RT_ATTR_SEGTYPE, then it interprets value as segment type.
 * If RT_ATTR_HEX, it prints value as %08x.
 */

#define JLD_NPATCHVALUES	2

typedef struct 
{
	CHAR 	*name;
	RTATTRS	attrib[JLD_NPATCHVALUES];
} JLDRTATTR;

/* patch up request entry */
/* these reside within segment type JLD_PATCH only */
/* (sect_hdr->segLength[JLD_PATCH] / sizeof(PATCH_ENTRY) gives the number
 * of relocation entries in the 'patching' segment.
 */

typedef struct {
	IU16		section;		/* section id in which this PATCH_ENTRY occurs		*/
	IU16		segType;		/* which segment requires the patch applied to it 	*/
	IU16		relocSize;		/* the size of the value to be patched in (RELOC_SZ)	*/
	IU16		chainCount;		/* number of records compressed into following PATCH_ENTRY spaces
				*/
	IU32		segOffset;		/* offset to place to patch in this seg		*/
	IU32		patchInfo;		/* private info.to host patcher indicating instruction 	*/
						/* (pair) format that needs patching			*/
	IU32		relocType;		/* how to derive the value to be passed to the patcher	*/
	IU32		value1;			/* relocation value (interpreted based on relocType)	*/
	IU32		value2;			/* relocation value (interpreted based on relocType)	*/
} PATCH_ENTRY;

/* The PATCH_ENTRYs may be compressed, so that entries which differ only in
 * the segOffset will be represented as a PATCH_ENTRY for the first segOffset
 * followed by additional PATCH_ENTRY records used as arrays of IU32s for
 * the additional offsets. The total number of IU32 entries represented
 * is recorded in the leading PATCH_ENTRY in chainCount: a chainCount of
 * zero means "no chain". The number JLD_CHAIN_MAX is the number of IU32s
 * stored in a single PATCH_ENTRY.
 */
#define JLD_CHAIN_MAX	7	


 /* relocType values */
 /* ---------------- */
#define RT_RSVD	0

#define RT_SELID	1
#define RT_RELOC1	2
#define RT_RELOC2	3
#define RT_RELOC3	4
#define RT_RELOC4	5
#define RT_RELOC5	6
#define RT_HGLBL_ABS	7
#define RT_HGLBL_PCREL	8
#define RT_HLCL_ABS	9
#define RT_HLCL_PCREL	10
#define RT_HGLBL_SEGOFF 11
#define RT_LAST		12


/*
The following can be used to patch JLD_CODE, JLD_DATA and JLD_APILOOKUP segments to get
Intel information or related descriptor cache information.

Relocation types				Patch action (and when patched)
-----------------				-------------------------------
RT_RSVD						Reserved for internal use by the linker.

RT_SELID,  value1.			    	(Windows init.) Map value1 (nominal selector) ->
						actual 16-bit selector.  Patch in this value. 

RT_RELOC1, value1, value2.			(Windows init.) Map value1 as above.  Get ea24
						corresponding to base of this Intel segment.
						Patch in 'ea24 + value2'. value2 is a 16-bit
						Intel ip.

RT_RELOC2, value1, value2.			(Windows init.) Map value1 as above.  Get ea24
						corresponding to base of this Intel segment.
						Patch in 'ea24<<4 + value2'. 

RT_RELOC3, value1, 0				(Windows init). Map value1 as above.  Get corresponding
						compiled desc.cache entry address (host-sized addr)
						and patch in.

RT_RELOC4, value1, value2.			(Windows init.) Map value1 as above.  
						Patch in 'mapped value<<16 + value2'. 


RT_RELOC5, value1, value2.			(Windows init.) Map value1 as above.  Get ea32b
						corresponding to base of this Intel segment.
						Patch in 'ea32b {+} value2'. value2 is a 16-bit
						Intel ip.



The following can be used to patch JLD_CODE, JLD_CODEOUTLINE, JLD_DATA and JLD_APILOOKUP segments to
get host addresses (such as 'C' externals and procedures, or CPU infrastructure
offline code, or other jcode exports).  pc-relative patchups (*_PCREL) are only legal when
within JLD_CODE, and then only when the value to be patched in corresponds to
a jcode export)

RT_HGLBL_ABS, 	value1,value2.			value1 is segment offset in corresponding IMPORTS segment
						to byte 0 of entry.
RT_HGLBL_PCREL, value1,value2.			value1 is segment offset in corresponding IMPORTS segment
						to byte 0 of entry.

The following can be used to patch JLD_CODE, JLD_CODEOUTLINE, JLD_DATA and JLD_APILOOKUP
segments with host addresses of other symbols LOCAL to the section.  Here, 'value1' and
'value2' indicate the segment offset and type, in which some symbol X is DEFINED.  The
PATCH_ENTRY identifies that the address of X needs to be patched into some LOCAL segment,
of type 'segType', at offset 'segOffset'.  *_ABS will cause the loader to patch in the loaded
address of X.  *_PCREL will cause the linker to patch in the relative displacement from the
patched object to X.

RT_HLCL_ABS, 	value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.
RT_HLCL_PCREL, 	value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.

The linker converts RT_HGLBL_ABS into RT_HGLBL_SEGOFF, when it sees a definition for the
symbol IMPORTED by the RT_HGLBL_ABS.
RT_HGLBL_SEGOFF,value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.



*/


/* locally scoped definitions and references 
 * ----------------------------------------- 
 * This corresponds to all non-GLOBAL symbols defined and referenced within
 * a section.  'jcc' handles these by use of RT_HLCL_* relocation requests
 * for all references, where the entry embeds the seg.offset and type of the 
 * defn.address of the symbol (as determined by jcc).  The linker/loader
 * just needs to relocate this by a). its location within the overall
 * global segment allocation, and then b). by the base address of that
 * segment when loaded.
 */


/* globally scoped definitions
 * ---------------------------
 * all named symbols here can be accessed from other sections.
 * these entries reside within segment type JLD_EXPORTS only
 * (sect_hdr->segLength[JLD_EXPORTS] / sizeof(EXPORT_ENTRY) gives the number
 * of entries in the 'exports' segment.
 */
typedef struct {
	IU16		section;		/* section in which this EXPORT_ENTRY occurs */
	IU16		segType;		/* segment within which exported symbol is defined */
	IU32		nameOffset;		/* offset within JLD_STRINGS segment to 'C' string for name */
	IU32		segOffset;		/* offset into segment where symbol is defined */
} EXPORT_ENTRY;






/* global references entry
 * -----------------------
 * all named symbols here are defined in another section.
 * these entries reside within segment type JLD_IMPORTS only 
 * (sect_hdr->segLength[JLD_IMPORTS] / sizeof(IMPORT_ENTRY) gives the number
 * of relocation entries in the 'imports' segment.
 *
 * NB: this is the only segment allowed to mention segType values JLD_CCODE, JLD_CDATA,
 * JLD_ACODE and JLD_ADATA.
 */
typedef struct {
	IU16		section;		/* section in which this IMPORT_ENTRY occurs */
	IU16		padding;		/* for alignment...  	*/
	IU32		nameOffset;		/* offset within JLD_STRINGS segment to 'C' string for name */
} IMPORT_ENTRY;




#define	JLD_NOFILE_ERR		1			/* missing file */
#define	JLD_BADFILE_ERR		2			/* bad file format */
#define JLD_UNRESOLVED_ERR	3			/* could not resolve all addresses */
#define JLD_BADMACH_ERR		4			/* wrong machine type for binary */
#define JLD_DUPSYMB_ERR		5			/* wrong machine type for binary */
#define JLD_INTERNAL_ERR	6			/* fatal error !! */
#define JLD_SPACE_ERR	 	7			/* not enough memory */
#define JLD_PATCH_ERR	 	8			/* patcher encountered relocation error */
#define JLD_INTERSEGREL_ERR	9			/* relative relocation request between
							 * DIFFERENT segment types
							 */
#define JLD_VERSION_MISMATCH	10			/* api.bin version no match */


/* following typedef gives segment information */
/* size of segments for all sections in all files (indexed by segment type) */
/* pointers to loaded areas for these segments (indexed by segment type) */
/* next free offset into loaded areas (indexed by segment type) */
typedef struct
{
	IHPE	free_base;	/* base of original malloc */
	IHPE	base;		/* aligned base */
	IU32	size;
	IU32	segOffset;
	IU32	alignment;	/* required alignment for this segment */
} SEGINFO;


/* loader symbol table entry format (for a defined symbol) */
typedef struct {
	IU16	section;
	IU16	segType;
	IUH	segOffset;
	CHAR 	*file;
} LDSYMB;


/*===========================================================================*/
/*			INTERFACE GLOBALS   				     */
/*===========================================================================*/
#ifdef JLD_PRIVATE		/* ONLY defined from within lnkload.c */


GLOBAL 	JLD_SEGATTRIBUTES SegAttributes[JLD_ALLSEGS] =
{
	/* JLD_CODE */
	{PATCHABLE|EXPORTABLE, JLD_CODE, "JC"},

	/* JLD_CODEOUTLINE */
	/* Note: grouped with JLD_CODE segment for section */
	{PATCHABLE|EXPORTABLE, JLD_CODE, "JK"},

	/* JLD_DATA */
	{PATCHABLE|EXPORTABLE, JLD_DATA, "JD"},

	/* JLD_APILOOKUP */
	{PATCHABLE|EXPORTABLE|ALLOCATE_ONLY, JLD_APILOOKUP, "JA"},

	/* JLD_STRINGSPACE */
	{DISCARDABLE, JLD_STRINGSPACE, "JS"},

	/* JLD_EXPORTS */
	{DISCARDABLE, JLD_EXPORTS, "JX"},

	/* JLD_IMPORTS */
	{DISCARDABLE, JLD_IMPORTS, "JI"},

	/* JLD_INTELBIN */
	{0, JLD_INTELBIN, "IB"},

	/* JLD_INTELSYM */
	{0, JLD_INTELSYM, "IS"},

	/* JLD_SYMJCODE */
	{0, JLD_SYMJCODE, "SJ" },

	/* JLD_DEBUGTAB */
	{PATCHABLE, JLD_DEBUGTAB, "DT"},

	/* JLD_D2SCRIPT */
	{0, JLD_D2SCRIPT, "DS" },

	/* JLD_CLEANUP */
	{PATCHABLE|ALLOCATE_ONLY, JLD_CLEANUP, "CR" },

	/* JLD_PATCH */
	{DISCARDABLE, JLD_PATCH, "JP"},

	/* JLD_NSEGS */
	{0, JLD_NSEGS, ""},

	/* JLD_CCODE */
	{0, JLD_CCODE, "CC"},

	/* JLD_CDATA */
	{0, JLD_CDATA, "CD"},

	/* JLD_ACODE */
	{0, JLD_ACODE, "AC"},

	/* JLD_ADATA */
	{0, JLD_ADATA, "AD"}
};


/* How relocSize is printed out */
GLOBAL	CHAR *SegSizeAttr[RS_UU+1] = 
{
	"08",	/* RS_8 */
	"16",	/* RS_16 */
	"32", 	/* RS_32 */
	"64",   /* RS_64 */
	"??"	/* RS_UU  */
};


/* How relocType is printed out */
/* if SYMBOLIC, then name extracted from namespace */
GLOBAL	JLDRTATTR SegRTAttr[RT_LAST+1] =
{
	{"    rsvd", RT_ATTR_NONE, RT_ATTR_NONE},
	{"   selid", RT_ATTR_HEX, RT_ATTR_NONE},
	{"  reloc1", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc2", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc3", RT_ATTR_HEX, RT_ATTR_NONE},
	{"  reloc4", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc5", RT_ATTR_HEX, RT_ATTR_HEX},
	{" glb.abs", RT_ATTR_IMPORT_OFFSET, RT_ATTR_HEX},
	{" glb.pcr", RT_ATTR_IMPORT_OFFSET, RT_ATTR_HEX},
	{" lcl.abs", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{" lcl.pcr", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{"glb.segr", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{"????????", RT_ATTR_NONE, RT_ATTR_NONE}
};

#endif

IMPORT 	JLD_SEGATTRIBUTES SegAttributes[];
IMPORT	CHAR 		  *SegSizeAttr[];
IMPORT	JLDRTATTR	  SegRTAttr[];


/* global segment allocation information */
extern	SEGINFO	GlblSegInfo[JLD_NSEGS];

/* indicates lnk/load error occurred */
IMPORT  IBOOL   JLdErr;

/* indicates what the error was */
IMPORT  IU32    JLdErrCode;

/* whether linking or loading */
IMPORT	IBOOL	Loading;

/* machine patcher is targeted for */
IMPORT	IUH	PatchingMachine;

/* tracing*/
IMPORT	IBOOL	DumpImports;
IMPORT	IBOOL	DumpExports;
IMPORT	IBOOL	DumpPatch;
IMPORT	IBOOL	DumpCode;
IMPORT	IBOOL	DumpDebug;
 





/*===========================================================================*/
/*			INTERFACE PROCEDURES				     */
/*===========================================================================*/

/* GroupSeg */
/* Concatenate */
IMPORT	void	PatchUp IPT0();


/* following macro indicates whether a given segment is executable */
#define	JLD_IS_EXECUTABLE(segNo)	((segNo == JLD_CODE) || (segNo == JLD_CODEOUTLINE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ios.h ===
/*
 * SoftPC-AT Version 2.0
 *
 * Title        : I/O Address Space definitions
 *
 * Description  : Definitions for users of the I/O Address Space Module
 *
 * Author       : Rod MacGregor (bless his cotton socks)
 *
 * Notes        : None
 */

/* SccsID[]= @(#)ios.h  1.25 09 Feb 1995 */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* Size of i/o memory array in half-words */

#if defined( NTVDM ) || defined ( GISP_SVGA ) || defined ( SFELLOW )
#define PC_IO_MEM_SIZE  0x10000 /* Must be a power of two! */
#else
#define PC_IO_MEM_SIZE  0x400   /* Must be a power of two! */
#endif

#ifdef NTVDM
typedef struct _extioentry {
    io_addr ioaddr;
    char    iadapter;
    struct _extioentry *ioextnext;
} ExtIoEntry, *PExtIoEntry;
#endif /* NTVDM */


#if defined(NEC_98)
/*
 * AT Keyboard adapter
 */

#define KEYBA_PORT_START        0x60
#define KEYBA_PORT_END          0x6e

#define KEYBA_IO_BUFFERS        0x60
#define KEYBA_STATUS_CMD        0x64

/*
 * The diskette IO address range
 */

#define FLOPPY_1MB_PORT_START           0x90
#define FLOPPY_1MB_PORT_END             0x9E
#define FLOPPY_640KB_PORT_START         0xC8
#define FLOPPY_640KB_PORT_END           0xCE
#define FLOPPY_1MB_640KB_PORT_START     0xBE
#define FLOPPY_1MB_640KB_PORT_END       0xBE

/*
 * The supported diskette IO addresses
 */

#define READ_STATUS_REG_1MB     0x90
#define WRITE_CMD_REG_1MB       0x92
#define READ_DATA_1MB           0x92
#define READ_STATUS_REG_640KB   0xC8
#define WRITE_CMD_REG_640KB     0xCA
#define READ_DATA_640KB         0xCA
#define MODE_CHG_1MB_640KB      0xBE

/*
 * The hard disk IO address range  This is not "SCSI".
 */

#define HD_PORT_START           0x80
#define HD_PORT_END             0x82

/* The addresses of the four ports assigned to the HDA. */

#define HD_ODR                  0x80
#define HD_IDR                  0x80
#define HD_OCR                  0x82
#define HD_ISR                  0x82

/*
 * PC-98 Keyboard adapter
 */

#define KEYBD_PORT_START        0x41
#define KEYBD_PORT_END          0x4F

#define KEYBD_DATA_READ         0x41
#define KEYBD_STATUS_CMD        0x43

/*
 * Calendar and Clock - Changed from RTC & CMOS.
 */
#define CALENDAR_PORT_START     0x20
#define CALENDAR_PORT_END       0x2E

#define CALENDAR_SET_REG        0x20

/*
 * System Port - Only PC-9800.
 */
#define SYSTEM_PORT_START       0x31
#define SYSTEM_PORT_END         0x3F

#define SYSTEM_READ_PORT_A      0x31
#define SYSTEM_READ_PORT_B      0x33
#define SYSTEM_READ_PORT_C      0x35
#define SYSTEM_WRITE_PORT_C     0x35
#define SYSTEM_WRITE_MODE       0x37

/*
 * Timer adapter -
 * Only (N-mode)Counter-1 differs port address from Counter-0 & 2.
 */

#define TIMER_PORT_START        0x71
#define TIMER_PORT_END          0x7F

#define TIMER0_REG              0x71
#define TIMER1_REG              0x73
#define TIMER2_REG              0x75
#define TIMER_MODE_REG          0x77

/*
 * DMA registers
 */

/* DMA controller I/0 space ranges */
#define DMA_PORT_START          0x01
#define DMA_PORT_END            0x1F

/* DMA controller address registers */
#define DMA_CH0_ADDRESS         0x01
#define DMA_CH0_COUNT           0x03
#define DMA_CH1_ADDRESS         0x05
#define DMA_CH1_COUNT           0x07
#define DMA_CH2_ADDRESS         0x09
#define DMA_CH2_COUNT           0x0B
#define DMA_CH3_ADDRESS         0x0D
#define DMA_CH3_COUNT           0x0F

/* DMA controller miscellaneous registers */
#define DMA_SHARED_REG_A                0x11
#define DMA_WRITE_REQUEST_REG           0x13
#define DMA_WRITE_ONE_MASK_BIT          0x15
#define DMA_WRITE_MODE_REG              0x17
#define DMA_CLEAR_FLIP_FLOP             0x19
#define DMA_SHARED_REG_B                0x1B
#define DMA_CLEAR_MASK                  0x1D
#define DMA_WRITE_ALL_MASK_BITS         0x1F

/* DMA bank register I/O space range */
#define DMA_PAGE_PORT_START             0x21
#define DMA_PAGE_PORT_END               0x29

/* DMA bank registers */
#define DMA_CH0_PAGE_REG                0x27
#define DMA_CH1_PAGE_REG                0x21
#define DMA_CH2_PAGE_REG                0x23
#define DMA_CH3_PAGE_REG                0x25
#define DMA_MODE_REG                    0x29

/*
 * Interrupt Control Registers
 */
#define ICA0_PORT_START         0x00
#define ICA0_PORT_END           0x02

#define ICA0_PORT_0             0x00
#define ICA0_PORT_1             0x02

#define ICA1_PORT_START         0x08
#define ICA1_PORT_END           0x0A

#define ICA1_PORT_0             0x08
#define ICA1_PORT_1             0x0A

/*
 * RS232 Adaptors
 */
#define RS232_COM1_PORT_START           0x30
#define RS232_COM1_PORT_END             0x3E
#define RS232_COM2_PORT_START           0xB0
#define RS232_COM2_PORT_END             0xB3
#define RS232_COM3_PORT_START           0xB2
#define RS232_COM3_PORT_END             0xBB

/*
 * Parallel printer adaptors
 */
#ifdef  PRINTER
#define LPT1_PORT_START         0x40
#define LPT1_PORT_END           0x4E
#endif  /* PRINTER */

/*
 * Line Counter Only PC-9800
 */
#define LINE_COUNTER_PORT_START         0x70
#define LINE_COUNTER_PORT_END           0x7A

/*
 * GRCG (Graphics Charger)
 */

#define GRCG_NORMAL_PORT_START          0x7C
#define GRCG_NORMAL_PORT_END            0x7E
#define GRCG_HIRESO_PORT_START          0xA4
#define GRCG_HIRESO_PORT_END            0xA6

/*
 * GDC (Graphic Display Controler)
 */
#define TEXT_GDC_PORT_START             0x60
#define TEXT_GDC_PORT_END               0x6E
#define GRAPH_GDC_PORT_START            0xA0
#define GRAPH_GDC_PORT_END              0xAE

/*
 * EGC (Enhanced Graphics Charger)
 */
#define EGC_PORT_START          0x4A0
#define EGC_PORT_END            0x4AE

/*
 * CG ROM
 */
#define CG_ROM_PORT_START       0xA1
#define CG_ROM_PORT_END         0xAF

/*
 * NMI Controller
 */
#define NMIC_PORT_START         0x50
#define NMIC_PORT_END           0x5E

/*
 * MOUSE CONTROLLER
 */
#define MOUSE_NMODE_PORT_START          0x7FD9
#define MOUSE_NMODE_PORT_END            0x7FDF

#define MOUSE_HMODE_PORT_START          0x61
#define MOUSE_HMODE_PORT_END            0x6F

#define CPU_PORT_START                  0xF0
#define CPU_PORT_END                    0xF6

/*
 * The following defines a key for each adaptor.  This is used as a
 * parameter to the io_connect_port() function.
 */
#define EMPTY_ADAPTOR           0
#define ICA0_ADAPTOR            1
#define DMA_ADAPTOR             2
#define ICA1_ADAPTOR            3
#define TIMER_ADAPTOR           4
#define NMI_ADAPTOR             5
#define HDA_ADAPTOR             6
#define FLOPPY_1MB_ADAPTOR      7
#define FLOPPY_640KB_ADAPTOR    8
#define FLOPPY_1MB_640KB        9
#define COM1_ADAPTOR            10
#define DMA_PAGE_ADAPTOR        11
#define MOUSE_ADAPTOR           12
#define CALENDAR_ADAPTOR        13
#define SYSTEM_PORT             14
#define TEXT_GDC_ADAPTOR        15
#define CG_ADAPTOR              16
#define LINE_COUNTER            17
#define GRAPHIC_ADAPTOR         18
#define GRCG                    19
#define EGC                     20
#define KEYB_ADAPTOR            21
#ifdef PRINTER
#define LPT1_ADAPTER            22
#endif
#define COM2_ADAPTOR            23
#define COM3_ADAPTOR            24
#define CPU_PORT                25
#define CALENDER_PORT           26

#define SPARE_ADAPTER1          27
#define SPARE_ADAPTER2          28
#define SPARE_ADAPTER3          29
#define SPARE_ADAPTER4          30
#define SPARE_ADAPTER5          31
#define SPARE_ADAPTER6          32
#define SPARE_ADAPTER7          33
#define SPARE_ADAPTER8          34

#define IO_MAX_NUMBER_ADAPTORS  35
#define NUMBER_SPARE_ADAPTERS   (SPARE_ADAPTER8 - SPARE_ADAPTER1)

#else  // !NEC_98
/*
 * The IO address range for the Monochrome Display Adapter.
 */

#define MDA_PORT_START          0x3B0
#define MDA_PORT_END            0x3BF


#ifdef HERC
#define HERC_PORT_START         0x3B0
#define HERC_PORT_END           0x3BF
#endif

/*
 * Memory bounds for the colour graphics adaptor
 */

#define CGA_PORT_START          0x3D0
#define CGA_PORT_END            0x3DF

/*
 * The individual enhanced adaptor registers
 */

#define EGA_SEQ_INDEX           0x3C4
#define EGA_SEQ_DATA            0x3C5
#define EGA_CRTC_INDEX          0x3D4
#define EGA_CRTC_DATA           0x3D5
#define EGA_GC_INDEX            0x3CE
#define EGA_GC_DATA             0x3CF
#define EGA_GC_POS1             0x3CC
#define EGA_GC_POS2             0x3CA
#define EGA_AC_INDEX_DATA       0x3C0
#define EGA_AC_SECRET           0x3C1           /* mentioned in "programmer's guide to pc & ps/2 video systems" p36 tip */
#define EGA_MISC_REG            0x3C2
#define EGA_FEAT_REG            0x3DA
#define EGA_IPSTAT0_REG         0x3C2
#define EGA_IPSTAT1_REG         0x3DA
#define VGA_MISC_READ_REG       0x3CC
#define VGA_FEAT_READ_REG       0x3CA

/*
 * Extra registers in VGA for controlling the DAC
 */

#ifdef VGG
#define VGA_DAC_MASK            0x3C6
#define VGA_DAC_RADDR           0x3C7   /* Address for reads */
#define VGA_DAC_WADDR           0x3C8   /* Address for writes */
#define VGA_DAC_DATA            0x3C9   /* DAC data */
#endif

/*
 * The individual colour adaptor registers
 */

#define CGA_INDEX_REG           0x3D4
#define CGA_DATA_REG            0x3D5
#define CGA_CONTROL_REG         0x3D8
#define CGA_COLOUR_REG          0x3D9
#define CGA_STATUS_REG          0x3DA

/*
 * Internal colour adaptor registers, accessed via data/index registers
 */

#define CGA_R14_CURS_ADDRH      0xE
#define CGA_R15_CURS_ADDRL      0xF

/*
 * The diskette IO address range
 */

#define DISKETTE_PORT_START     0x3F0
#define DISKETTE_PORT_END       0x3F7

/*
 * The supported diskette IO addresses
 */

#define DISKETTE_ID_REG         0x3f1
#define DISKETTE_DOR_REG        0x3F2
#define DISKETTE_STATUS_REG     0x3F4
#define DISKETTE_DATA_REG       0x3F5
#define DISKETTE_FDISK_REG      0x3f6
#define DISKETTE_DIR_REG        0x3f7
#define DISKETTE_DCR_REG        0x3f7


/*
 * The hard disk IO address range
 */

#define DISK_PORT_START         0x1F0
#define DISK_PORT_END           0x1F8

/* The addresses of the four ports assigned to the HDA. */

#define HD_PORT_0               0x320
#define HD_PORT_1               0x321
#define HD_PORT_2               0x322
#define HD_PORT_3               0x323


/*
 * PPI adapter
 */
/* On the AT, PPI_GENERAL is like the combination of
 * PPI_GENERAL and PPI_SWITCHES on the XT. All the switch
 * information is in the AT CMOS RAM ports 70-7f
 */
#define PPI_PORT_START          0x60
#define PPI_PORT_END            0x6f

#define PPI_KEYBOARD            0x60
#define PPI_GENERAL             0x61
#define PPI_SWITCHES            0x62

/*
 * AT Keyboard adapter
 */

#define KEYBA_PORT_START        0x60
#define KEYBA_PORT_END          0x6e

#define KEYBA_IO_BUFFERS        0x60
#define KEYBA_STATUS_CMD        0x64

/*
 * CMOS and Real Time Clock
 */
/*
 * These are defined in cmos.h
 *
#define CMOS_PORT_START         0x70
#define CMOS_PORT_END           0x7f

#define CMOS_PORT               0x70
#define CMOS_DATA               0x71
 */

/*
 * Timer adapter
 */

#define TIMER_PORT_START        0x40
#define TIMER_PORT_END          0x5F

#define TIMER0_REG              0x40
#define TIMER1_REG              0x41
#define TIMER2_REG              0x42
#define TIMER_MODE_REG          0x43

/*
 * DMA registers
 */

/* DMA controller I/0 space ranges */
#define DMA_PORT_START          0x00
#define DMA_PORT_END            0x1F

#define DMA1_PORT_START         0xC0
#define DMA1_PORT_END           0xDF

/* DMA controller address registers */
#define DMA_CH0_ADDRESS         0x00
#define DMA_CH0_COUNT           0x01
#define DMA_CH1_ADDRESS         0x02
#define DMA_CH1_COUNT           0x03
#define DMA_CH2_ADDRESS         0x04
#define DMA_CH2_COUNT           0x05
#define DMA_CH3_ADDRESS         0x06
#define DMA_CH3_COUNT           0x07

#define DMA_CH4_ADDRESS         0xC0
#define DMA_CH4_COUNT           0xC2
#define DMA_CH5_ADDRESS         0xC4
#define DMA_CH5_COUNT           0xC6
#define DMA_CH6_ADDRESS         0xC8
#define DMA_CH6_COUNT           0xCA
#define DMA_CH7_ADDRESS         0xCC
#define DMA_CH7_COUNT           0xCE

/* DMA controller miscellaneous registers */
#define DMA_SHARED_REG_A        0x08
#define DMA_WRITE_REQUEST_REG   0x09
#define DMA_WRITE_ONE_MASK_BIT  0x0A
#define DMA_WRITE_MODE_REG      0x0B
#define DMA_CLEAR_FLIP_FLOP     0x0C
#define DMA_SHARED_REG_B        0x0D
#define DMA_CLEAR_MASK          0x0E
#define DMA_WRITE_ALL_MASK_BITS 0x0F

#define DMA1_SHARED_REG_A       0xD0
#define DMA1_WRITE_REQUEST_REG  0xD2
#define DMA1_WRITE_ONE_MASK_BIT 0xD4
#define DMA1_WRITE_MODE_REG     0xD6
#define DMA1_CLEAR_FLIP_FLOP    0xD8
#define DMA1_SHARED_REG_B       0xDA
#define DMA1_CLEAR_MASK         0xDC
#define DMA1_WRITE_ALL_MASK_BITS        0xDE

/* DMA page register I/O space range */
#define DMA_PAGE_PORT_START     0x80
#define DMA_PAGE_PORT_END       0x9F

/* DMA page registers */
#define DMA_CH0_PAGE_REG        0x87
#define DMA_CH1_PAGE_REG        0x83
#define DMA_FLA_PAGE_REG        0x81
#define DMA_HDA_PAGE_REG        0x82
#define DMA_CH5_PAGE_REG        0x8b
#define DMA_CH6_PAGE_REG        0x89
#define DMA_CH7_PAGE_REG        0x8a
#define DMA_REFRESH_PAGE_REG    0x8f
#define MFG_PORT        0x80
#define DMA_FAKE1_REG   0x84
#define DMA_FAKE2_REG   0x85
#define DMA_FAKE3_REG   0x86
#define DMA_FAKE4_REG   0x88
#define DMA_FAKE5_REG   0x8c
#define DMA_FAKE6_REG   0x8d
#define DMA_FAKE7_REG   0x8e

/*
 * Interrupt Control Registers
 */

#    define ICA0_PORT_START     0x20
#    define ICA0_PORT_END       0x3F

#    define ICA0_PORT_0         0x20
#    define ICA0_PORT_1         0x21

#    define ICA1_PORT_START     0xA0
#    define ICA1_PORT_END       0xBF

#    define ICA1_PORT_0         0xA0
#    define ICA1_PORT_1         0xA1

/*
 * RS232 Adaptors
 */

#define RS232_COM1_PORT_START   0x3F8
#define RS232_COM1_PORT_END     0x3FF
#define RS232_COM2_PORT_START   0x2F8
#define RS232_COM2_PORT_END     0x2FF
#define RS232_COM3_PORT_START   0x3e8
#define RS232_COM3_PORT_END     0x3eF
#define RS232_COM4_PORT_START   0x2e8
#define RS232_COM4_PORT_END     0x2eF
#define RS232_PRI_PORT_START    0x3F8
#define RS232_PRI_PORT_END      0x3FF
#define RS232_SEC_PORT_START    0x2F8
#define RS232_SEC_PORT_END      0x2FF

/*
 * Parallel printer adaptors
 */

#ifdef  PRINTER
#define LPT1_PORT_START         0x3bc
#define LPT1_PORT_END           0x3c0
#define LPT2_PORT_START         0x378
#define LPT2_PORT_END           0x37c
#define LPT3_PORT_START         0x278
#define LPT3_PORT_END           0x27c

#define LPT_MASK                0xff0
#endif  /* PRINTER */

/* SoundBlaster I/O Ports */

#ifdef SWIN_SNDBLST_NULL
#define SNDBLST1_PORT_START             0x0220
#define SNDBLST1_PORT_END               0x022F
#define SNDBLST2_PORT_START             0x0240
#define SNDBLST2_PORT_END               0x026F
#endif

/*
 * PCI configuration ports.
 */

#define PCI_CONFIG_ADDRESS       0xcf8
#define PCI_CONFIG_DATA          0xcfc

#ifndef SFELLOW
/*
 * The following defines a key for each adaptor.  This is used as a
 * parameter to the io_connect_port() function.
 */


#define EMPTY_ADAPTOR           0
#define DMA_ADAPTOR             1
#define ICA0_ADAPTOR            2
#define TIMER_ADAPTOR           3
#define PPI_ADAPTOR             4
#define NMI_ADAPTOR             5
#define COM2_ADAPTOR            6
#define HDA_ADAPTOR             7
#define MDA_ADAPTOR             8
#define CGA_ADAPTOR             9
#define FLA_ADAPTOR             10
#define COM1_ADAPTOR            11
#define DMA_PAGE_ADAPTOR        12
#define MOUSE_ADAPTOR           13

#define EGA_SEQ_ADAP_INDEX      15
#define EGA_SEQ_ADAP_DATA       16
#define EGA_GC_ADAP_INDEX       17
#define EGA_GC_ADAP_DATA        18
#define EGA_CRTC_ADAPTOR        19
#define EGA_AC_ADAPTOR          20
#define EGA_MISC_ADAPTOR        21
#define EGA_FEAT_ADAPTOR        22
#define EGA_IPSTAT0_ADAPTOR     23
#define EGA_IPSTAT1_ADAPTOR     24
#define ICA1_ADAPTOR            25
#define AT_KEYB_ADAPTOR         26
#define CMOS_ADAPTOR            27
#ifdef HERC
#define HERC_ADAPTOR            28
#endif
#if (NUM_SERIAL_PORTS > 2)
#define COM3_ADAPTOR            29
#define COM4_ADAPTOR            30
#endif
#ifdef PRINTER
#define LPT1_ADAPTER            31
#define LPT2_ADAPTER            32
#define LPT3_ADAPTER            33
#endif /* PRINTER */

#ifdef VGG
#define VGA_DAC_INDEX_PORT      34
#define VGA_DAC_DATA_PORT       35
#endif

#define SNDBLST_ADAPTER         36

#ifdef NTVDM    /* Spare slots for user supplied VDDs */
#define SPARE_ADAPTER1          37
#define SPARE_ADAPTER2          38
#define SPARE_ADAPTER3          39
#define SPARE_ADAPTER4          40
#define SPARE_ADAPTER5          41
#define SPARE_ADAPTER6          42
#define SPARE_ADAPTER7          43


#define IO_MAX_NUMBER_ADAPTORS  44      /* make this equal to the highest used plus one please! */

#define NUMBER_SPARE_ADAPTERS   (SPARE_ADAPTER7 - SPARE_ADAPTER1)

#else   /* NTVDM */

#ifdef GISP_SVGA
#define GISP_VGA_FUDGE_ADAPTER          36
#define IO_MAX_NUMBER_ADAPTORS          37
#else           /* GISP_SVGA */

/* Adapter for SoundBlaster Null Driver */

#ifdef SWIN_SNDBLST_NULL
#define SNDBLST_ADAPTER         36
#endif

#ifndef IO_MAX_NUMBER_ADAPTORS
#define IO_MAX_NUMBER_ADAPTORS  37      /* make this equal to the highest used plus one please! */
#endif

#endif          /* GISP_SVGA */
#endif  /* NTVDM */
#else   /* SFELLOW */

/*
 * StringFellow doesn't need most of the emulated hardware, as
 * it has the real thing.
 */

#define EMPTY_ADAPTOR                                   0
#define HW_ADAPTOR_DW                                   1
#define HW_ADAPTOR_W                                    2
#define HW_ADAPTOR_B                                    3
#define KEY64_ADAPTOR                                   4
#define KEY60_ADAPTOR                                   5
#define DMA_ADAPTOR                                     6
#define PPI_ADAPTOR                                     7
#define CMOS_ADAPTOR                                    8
#define MFG_ADAPTOR                                     9
#define PCI_CONFIG_ADDRESS_ADAPTOR                      10
#define PCI_CONFIG_PORT_ADAPTOR                         11
#define PCI_CONFIG_DATA_ADAPTOR0                        12
#define PCI_CONFIG_DATA_ADAPTOR13                       13
#define PCI_CONFIG_DATA_ADAPTOR2                        14
#define PIC_SLAVE_ADAPTOR                               15
#define PIC_MASTER_ADAPTOR                              16
#define SF_EGA_GC_ADAP_INDEX                            17
#define SF_EGA_GC_ADAP_DATA                             18
#define IO_MAX_NUMBER_ADAPTORS  19      /* make this equal to the highest used plus one please! */

#endif /*SFELLOW */
#endif // !NEC_98

#if defined(NEC_98)
#define CMOS_ADAPTOR            27
#endif // !NEC_98

/*
 * The Bit masks for specifying Read/Write access when connecting ports
 * to the IO bus.
 */

#define IO_READ         1
#define IO_WRITE        2
#define IO_READ_WRITE   (IO_READ | IO_WRITE)

/*
 * Values to return if no adaptor is connected to a port
 */

#define IO_EMPTY_PORT_BYTE_VALUE        0xFF
#define IO_EMPTY_PORT_WORD_VALUE        0xFFFF

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT void     inb IPT2(io_addr, io_address, half_word *, value);
IMPORT void     outb IPT2(io_addr, io_address, half_word, value);
IMPORT void     inw IPT2(io_addr, io_address, word *, value);
IMPORT void     outw IPT2(io_addr, io_address, word, value);
#ifdef SPC386
IMPORT void     ind IPT2(io_addr, io_address, IU32 *, value);
IMPORT void     outd IPT2(io_addr, io_address, IU32, value);
#endif /* SPC386 */

IMPORT void     io_define_inb
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, half_word *, value)
#endif  /* ANSI */
);

#ifdef SFELLOW
IMPORT void     io_define_inw
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, word *, value)
#endif  /* ANSI */
);

IMPORT void     io_define_ind
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, IU32 *, value)
#endif  /* ANSI */
);
#endif  /* SFELLOW */

IMPORT void     io_define_in_routines
(
#ifdef  ANSI
        half_word adapter,
        void (*inb_func) IPT2(io_addr, io_address, half_word *, value),
        void (*inw_func) IPT2(io_addr, io_address, word *, value),
        void (*insb_func) IPT3(io_addr, io_address, half_word *, valarray,
                word, count),
        void (*insw_func) IPT3(io_addr, io_address, word *, valarray,
                word, count)
#endif  /* ANSI */
);

IMPORT void     io_define_outb
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, half_word, value)
#endif  /* ANSI */
);

#ifdef SFELLOW
IMPORT void     io_define_outw
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, word, value)
#endif  /* ANSI */
);

extern void     io_define_outd
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, IU32, value)
#endif  /* ANSI */
);
#endif  /* SFELLOW */

IMPORT void     io_define_out_routines
(
#ifdef  ANSI
        half_word adapter,
        void (*outb_func) IPT2(io_addr, io_address, half_word, value),
        void (*outw_func) IPT2(io_addr, io_address, word, value),
        void (*outsb_func) IPT3(io_addr, io_address, half_word *, valarray,
                word, count),
        void (*outsw_func) IPT3(io_addr, io_address, word *, valarray,
                word, count)
#endif  /* ANSI */
);

#ifdef NTVDM
IMPORT IBOOL    io_connect_port IPT3(io_addr, io_address, half_word, adapter,
        half_word, mode);
#else
IMPORT void     io_connect_port IPT3(io_addr, io_address, half_word, adapter,
        half_word, mode);
#endif  /* NTVDM */

IMPORT void     io_disconnect_port IPT2(io_addr, io_address, half_word, adapter);
IMPORT void     io_init IPT0();

/* Externs and macros for io_redefine_inb/outb */
#ifdef MAC68K
IMPORT char     *Ios_in_adapter_table;
IMPORT char     *Ios_out_adapter_table;
#else
IMPORT char     Ios_in_adapter_table[];
IMPORT char     Ios_out_adapter_table[];
#endif

IMPORT void     (*Ios_inb_function  [])
        IPT2(io_addr, io_address, half_word *, value);
IMPORT void     (*Ios_inw_function  [])
        IPT2(io_addr, io_address, word *, value);
extern void     (*Ios_ind_function  [])
        IPT2(io_addr, io_address, IU32 *, value);
IMPORT void     (*Ios_insb_function [])
        IPT3(io_addr, io_address, half_word *, valarray, word, count);
IMPORT void     (*Ios_insw_function [])
        IPT3(io_addr, io_address, word *, valarray, word, count);

IMPORT void     (*Ios_outb_function [])
        IPT2(io_addr, io_address, half_word, value);
IMPORT void     (*Ios_outw_function [])
        IPT2(io_addr, io_address, word, value);
extern void     (*Ios_outd_function [])
        IPT2(io_addr, io_address, IU32, value);
IMPORT void     (*Ios_outsb_function[])
        IPT3(io_addr, io_address, half_word *, valarray, word, count);
IMPORT void     (*Ios_outsw_function[])
        IPT3(io_addr, io_address, word *, valarray, word, count);

/* FAST_FUNC_ADDR() used on the Mac to avoid routing by the jump table every time... */
#ifndef FAST_FUNC_ADDR
#define FAST_FUNC_ADDR(func)    func
#endif  /* FAST_FUNC_ADDR */

#define io_redefine_outb(adaptor,func)  Ios_outb_function[adaptor] = FAST_FUNC_ADDR(func)
#define io_redefine_inb(adaptor,func)   Ios_inb_function[adaptor] = FAST_FUNC_ADDR(func)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\j_c_lang.h ===
/*
 *      Name:           j_c_lang.h
 *
 *      Author:         Simon Frost
 *
 *      Created on:     February 1994
 *
 *      SccsID:         @(#)j_c_lang.h	1.2 08/19/94
 *
 *      Purpose:        This file contains the necessary declarations for C
 *                      files generated from J-code.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 */
/* defines needed for basic types */
#define	jccc_parm1 r2 
#define	jccc_parm2 r3 
#define	jccc_parm3 r4 
#define	jccc_parm4 r5 
#define	jccc_gdp r1 
/* define variables (register replacements) used */
extern IUH	rnull ; /* holder for a null arg in calls and null return args */
extern IUH	r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,r11,r12,r13,r14,r15,
		r16,r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31;

/* prototypes for support functions - see j_c_lang.c ? how many are used */
extern IUH mask IPT2(IUH, bitpos, IUH, len);
extern IUH rorl IPT2(IUH, src, IUH, rots);
extern IUH rorw IPT2(IUH, src, IUH, rots);
extern IUH rorb IPT2(IUH, src, IUH, rots);
extern IUH roll IPT2(IUH, src, IUH, rots);
extern IUH rolw IPT2(IUH, src, IUH, rots);
extern IUH rolb IPT2(IUH, src, IUH, rots);

#ifdef LITTLEND
#define	UOFF_15_8(a)	(((IU8 *)(a))+1)
#define	SOFF_15_8(a)	(((IS8 *)(a))+1)
#define	REGBYTE		0
#define	REGWORD		0
#define	REGLONG		0
#endif
#ifdef BIGEND
#define UOFF_15_8(a)	((IU8 *)(a) + sizeof(IUH)-2)
#define SOFF_15_8(a)	((IS8 *)(a) + sizeof(IUH)-2)
#define	REGBYTE		(sizeof(IUH) -1)
#define	REGWORD		(sizeof(IUH)/2 -1)
#define	REGLONG		(sizeof(IUH)/4 -1)
#endif
#define __J_C_LANG	/* mark as already included */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\keyba.h ===
/*
 * SoftPC AT Revision 2.0
 *
 * Title        : Keyboard Adpator definitions
 *
 * Description  : Definitions for users of the keyboard Adaptor
 *
 * Author       : WTG Charnell
 *
 * Notes        : None
 */



/* @(#)keyba.h	1.10 08/10/92 Copyright Insignia Solutions Ltd."; */


#define RESEND_CODE 0xfe
#define ACK_CODE 0xfa
#define BAT_COMPLETION_CODE 0xaa

extern void kbd_inb IPT2( io_addr, port, half_word *, val );
extern void kbd_outb IPT2( io_addr, port, half_word, val );
#ifndef REAL_KBD
extern void ( *host_key_down_fn_ptr ) IPT1( int, key );
extern void ( *host_key_up_fn_ptr ) IPT1( int, key );
#endif
extern void ( *do_key_repeats_fn_ptr ) IPT0();
extern void keyboard_init IPT0();
extern void keyboard_post IPT0();
extern void AT_kbd_init IPT0();
extern void AT_kbd_post IPT0();

#ifdef HUNTER
/*
** AT Hunter uses these two functions.
** AT keyboard is different so slight mods for AT Hunter.
**
*/
/*
** Puts a scan code (type is half_word) into Keyboard Buffer.
** Returns success; either TRUE or FALSE.
*/
extern int hunter_codes_to_translate IPT1(half_word, scan_code);
/*
** Returns number of chars in the keyboard buffer that the BIOS
** reads. Will only be 1 or 0.
*/
extern int buffer_status_8024();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\keycaps.h ===
/*[
	Name:		IBMKeyCaps.h
	Derived From:	New Development
	Author:		gvdl
	Created On:	31 July 1991
	Sccs ID:	08/10/92 @(#)keycaps.h	1.3
	Purpose:	Table of all keycaps indexed by matrix code.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef UIF_TEST

#define MISSING_KEY ((UTINY) 0x01)
#define BAD_DOWN    ((UTINY) 0x02)
#define BAD_UP      ((UTINY) 0x04)
#define DUP_KEY     ((UTINY) 0x08)

LOCAL CHAR *keycaps[] =
{
	"",
	"`",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"0",
	"-",
	"=",
	"",
	"Backspace",
	"Tab",
	"q",
	"w",
	"e",
	"r",
	"t",
	"y",
	"u",
	"i",
	"o",
	"p",
	"[",
	"]",
	"\\",
	"Caps",
	"a",
	"s",
	"d",
	"f",
	"g",
	"h",
	"j",
	"k",
	"l",
	";",
	"'",
	"102 1/2Ret",
	"Return",
	"ShiftL",
	"102 1/2ShL",
	"z",
	"x",
	"c",
	"v",
	"b",
	"n",
	"m",
	",",
	".",
	"/",
	"",
	"ShiftR",
	"CntrlL",
	"",
	"AltL",
	"Space",
	"AltR",
	"",
	"CntrlR",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"Insert",
	"Delete",
	"",
	"",
	"Left",
	"Home",
	"End",
	"",
	"Up",
	"Down",
	"PgUp",
	"PgDn",
	"",
	"",
	"Right",
	"Num",
	"kp7",
	"kp4",
	"kp1",
	"",
	"kp/",
	"kp8",
	"kp5",
	"kp2",
	"kp0",
	"kp*",
	"kp9",
	"kp6",
	"kp3",
	"kp.",
	"kp-",
	"kp+",
	"",
	"kpEnter",
	"",
	"Esc",
	"",
	"F01",
	"F02",
	"F03",
	"F04",
	"F05",
	"F06",
	"F07",
	"F08",
	"F09",
	"F10",
	"F11",
	"F12",
	"PrtScr",
	"Scroll",
	"Pause",
};

#endif /* UIF_TEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\keyboard.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title        : keyboard.h
 *
 * Description  : defines for keyboard translations
 *
 * Author       : Simon Frost
 *
 * Notes        :
 *
 */

/* SccsID[]="@(#)keyboard.h	1.7 10/08/92 Copyright Insignia Solutions Ltd."; */


#define KH_BUFFER_SIZE  32

/*
 * Constants
 */

#define PC_KEY_UP	0x80		/* PC scan code up marker	*/
#define OVERFLOW	0xFF		/* PPI error indicator		*/

/*
 * Keyboard shift state veriable
 */

#define	kb_flag		0x417
/*#define	kb_flag		M[0x417]*/

/*
 * Significance of bits in above
 */

#define INS_STATE	0x80		/* insert state */
#define CAPS_STATE	0x40		/* caps lock on */
#define NUM_STATE	0x20		/* num lock on */
#define SCROLL_STATE	0x10		/* scroll lock on */
#define ALT_SHIFT	0x08		/* alt key depressed */
#define CTL_SHIFT	0x04		/* control key depressed */
#define LEFT_SHIFT	0x02		/* left shift key depressed */
#define RIGHT_SHIFT	0x01		/* right shift key depressed */
#define LR_SHIFT	0x03		/* both/either shift keys */

/*
 * Second status byte
 */

#define	kb_flag_1		0x418
/*#define kb_flag_1	M[0x418]*/

/*
 * Bit significance
 */

#define	INS_SHIFT	0x80		/* Insert key depressed */
#define CAPS_SHIFT	0x40		/* Caps Lock key depressed */
#define NUM_SHIFT	0x20		/* Num lock depressed */
#define	SCROLL_SHIFT	0x10		/* scroll lock key depressed */
#define HOLD_STATE	0x08		/* ctl-num lock pressed */

#define SYS_SHIFT	0x04		/* system key pressed and held	*/
/*
 * Third status byte	Keyboard LED flags
 */

#define	kb_flag_2		0x497
/*#define kb_flag_2	M[0x497]*/

/*
 * Bit significance
 */

#define KB_LEDS		0x07		/* Keyboard LED state bits 	*/
#define KB_FA		0x10		/* Acknowledgment received	*/
#define KB_FE 		0x20  		/* Resend received flag		*/
#define KB_PR_LED	0x40		/* Mode indicator update	*/
#define KB_ERR		0x80		/* Keyboard transmit error flag	*/

/*
 * Fourth status byte	Keyboard mode status and type flags
 */

#define	kb_flag_3		0x496
/*#define kb_flag_3	M[0x496]*/

/*
 * Bit significance
 */

#define LC_E1  		0x01		/* Last code was the E1 code	*/
#define LC_E0		0x02		/* Last code was the E0 code	*/
#define R_CTL_SHIFT	0x04		/* Right control key down	*/
#define GRAPH_ON 	0x08		/* All graphics key down	*/
#define KBX   	 	0x10		/* KBX installed               	*/
#define SET_NUM_LK	0x20		/* Force Num lock		*/
#define LC_AB		0x40		/* Last char was 1st ID char.	*/
#define RD_ID		0x80		/* Doing a read ID		*/

/*
 * Keyboard/LED commands
 */
#define KB_RESET	0xff		/* self diagnostic command	*/
#define KB_RESEND	0xfe		/* resend command		*/
#define KB_MAKE_BREAK	0xfa		/* typamatic comand		*/
#define KB_ENABLE	0xf4		/* keyboard enable		*/
#define KB_TYPA_RD	0xf3		/* typamatic rate/delay cmd	*/
#define KB_READ_ID	0xf2		/* read keyboard ID command	*/
#define KB_ECHO		0xee		/* echo command			*/
#define LED_CMD		0xed		/* LED write command		*/

/*
 * 8042 commands
 */
#define DIS_KBD		0xad		/* disable keyboard command	*/
#define ENA_KBD		0xae		/* enable keyboard command	*/

/*
 * 8042 response
 */
#define KB_OVER_RUN	0xff		/* over run scan code		*/
#define KB_RESEND	0xfe		/* resend request		*/
#define	KB_ACK		0xfa		/* acknowledge from transmsn.	*/

/*
 * enhanced keyboard scan codes
 */
#define ID_1		0xab		/* 1st ID character for KBX	*/
#define ID_2		0x41		/* 2nd ID character for KBX	*/
#define ID_2A		0x54		/* alt. 2nd ID char. for KBX	*/
#define F11_M		87		/* F11 make			*/
#define F12_M		88		/* F12 make			*/
#define MC_E0		224		/* general marker code		*/
#define MC_E1		225		/* pause key marker code	*/


/*
 * Storage for ALT + keypad sequence entry
 */

#define	alt_input 0x419
/*#define alt_input	M[0x419]*/

/*
 * Key definitions for U.S. keyboard
 */

#define NUM_KEY		69		/* Num lock scan code */
#define SCROLL_KEY	70		/* scroll lock scan code */
#define ALT_KEY		56		/* alt key scan code */
#define CTL_KEY		29		/* control key scan code */
#define CAPS_KEY	58		/* caps lock   scan code */
#define	LEFT_SHIFTKEY	42		/* left shift  key code */
#define RIGHT_SHIFTKEY	54		/* right shift key code */
#define INS_KEY		82		/* insert key  scan code */
#define DEL_KEY		83		/* delete key  scan code */
#define COMMA_KEY	51		/* comma key scan code */
#define DOT_KEY		52		/* fullstop key scan code */

#define SPACEBAR	57		/* space bar  scan code */
#define HOME_KEY	71		/* keypad home key scan code */
#define TAB_KEY		15		/* Tab/Back tab key  scan code */
#define PRINT_SCR_KEY	55		/* print screen / * key code */
#define KEY_PAD_PLUS	78		/* plus key on num keypad */
#define KEY_PAD_MINUS	74		/* minus key on num keypad */
#define TOP_1_KEY	2		/* number 1 at top */
#define BS_KEY		14		/* backspace key */
#define F1_KEY		59		/* 1st function key */
#define UPARR8		72		/* up arrow / '8' */
#define LARR4		75		/* left arrow / '4' */
#define RARR6		77		/* right arrow / '6' */
#define DOWNARR2	80		/* down arrow / '2' */
#define KEY_PAD_ENTER	28
#define KEY_PAD_SLASH	53		/* / on num keypad	*/
#define F10_KEY		68		/* 10th function key	*/
#define F11_KEY		87
#define F12_KEY		88
#define WT_KEY		86
#define SYS_KEY 	84		/* system key		*/
/* Bit 7 = 1 if break key hit */
#define	bios_break	 0x471
/*#define bios_break	M[0x471]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

typedef struct
{
	void (*kb_prepare) IPT0();
	void (*kb_restore) IPT0();
	void (*kb_init) IPT0();
	void (*kb_shutdown) IPT0();
	void (*kb_light_on) IPT1(half_word,pattern);
	void (*kb_light_off) IPT1(half_word,pattern);
} KEYBDFUNCS;

extern KEYBDFUNCS *working_keybd_funcs;

#define host_kybd_prepare()		(*working_keybd_funcs->kb_prepare)()
#define host_kybd_restore()		(*working_keybd_funcs->kb_restore)()
#define host_kb_init()		(*working_keybd_funcs->kb_init)()
#define host_kb_shutdown()		(*working_keybd_funcs->kb_shutdown)()
#define host_kb_light_on(pat)	(*working_keybd_funcs->kb_light_on)(pat)
#define host_kb_light_off(pat)	(*working_keybd_funcs->kb_light_off)(pat)

/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\kybdmtx.h ===
/*[
 *      Name:		kybdmtx.h
 *
 *      Derived From:	DEC 3.0 kybdmtx.gi and kybdcpu.gi
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	18th February 1992
 *
 *      Sccs ID:        @(#)kybdmtx.h	1.2 08/10/92
 *
 *      Purpose:	Host keyboard definitions
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/
   
/* the type of keyboard being used	*/

#define KY83		83
#define KY101		101
#define KY102		102

/* keyboard matrix actions		*/

#define KYINIT		0
#define KYSWITCHUP	1
#define KYSWITCHDN	2
#define KYLOCK		3
#define KYLOCK1		4
#define KYUNLK		6
#define KYUNLK1		7
#define KYUNLK2		8
#define KYTOGLOCK	9
#define KYTOGLOCK1	10
#define KYTOGLOCK2	11
#define KYALOCK1	12

IMPORT VOID kyhot IPT0();
IMPORT VOID kyhot2 IPT0();
IMPORT VOID kyhot3 IPT0();
IMPORT VOID kybdmtx IPT2(LONG, action, LONG, qualify);
IMPORT VOID kybdcpu101 IPT2(int, stat, unsigned int, pos);

#define	OPEN	0
#define CLOSED	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\lm_attr.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_attr.h	1.1 05/19/93 */
/******************************************************************************

	    COPYRIGHT (c) 1990, 1992 by Globetrotter Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Globetrotter Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Globetrotter Software Inc.

 *****************************************************************************/
/*	
 *	Module:	lm_attr.h v3.4
 *
 *	Description: 	Attribute tags for FLEXlm setup parameters.
 *
 *	M. Christiano
 *	5/3/90
 *
 *	Last changed:  8/13/92
 *
 */

#define LM_A_DECRYPT_FLAG	1	/* (short) */
#define LM_A_DISABLE_ENV	2	/* (short) */
#define LM_A_LICENSE_FILE	3	/* (char *) */
#define LM_A_CRYPT_CASE_SENSITIVE 4	/* (short) */
#define LM_A_GOT_LICENSE_FILE	5	/* (short) */
#define LM_A_CHECK_INTERVAL	6	/* (int) */
#define LM_A_RETRY_INTERVAL	7	/* (int) */
#define LM_A_TIMER_TYPE		8	/* (int) */
#define LM_A_RETRY_COUNT	9	/* (int) */
#define	LM_A_CONN_TIMEOUT	10	/* (int) */
#define	LM_A_NORMAL_HOSTID	11	/* (short) */
#define LM_A_USER_EXITCALL	12	/* PTR to func returning int */
#define	LM_A_USER_RECONNECT	13	/* PTR to func returning int */
#define LM_A_USER_RECONNECT_DONE 14	/* PTR to func returning int */
#define LM_A_USER_CRYPT		15	/* PTR to func returning (char *) */
#define	LM_A_USER_OVERRIDE	16	/* (char *) */
#define LM_A_HOST_OVERRIDE	17	/* (char *) */
#define LM_A_PERIODIC_CALL	18	/* PTR to func returning int */
#define LM_A_PERIODIC_COUNT	19	/* (int) */
#define LM_A_NO_DEMO		20	/* (short) */
#define LM_A_NO_TRAFFIC_ENCRYPT	21	/* (short) */
#define LM_A_USE_START_DATE	22	/* (short) */
#define LM_A_MAX_TIMEDIFF	23	/* (int) */
#define LM_A_DISPLAY_OVERRIDE	24	/* (char *) */
#define LM_A_ETHERNET_BOARDS	25	/* (char **) */
#define LM_A_ANY_ENABLED	26	/* (short) */
#define LM_A_LINGER		27	/* (long) */
#define LM_A_CUR_JOB		28	/* (LM_HANDLE *) */
#define LM_A_SETITIMER		29	/* PTR to func returning void, eg PFV */
#define LM_A_SIGNAL		30	/* PTR to func returning PTR to */
					/*    function returning void, eg:
					      PFV (*foo)(); 	*/
#define LM_A_TRY_COMM		31	/* (short) Try old comm versions */
#define LM_A_VERSION		32	/* (short) FLEXlm version */
#define LM_A_REVISION		33	/* (short) FLEXlm revision */
#define LM_A_COMM_TRANSPORT	34	/* (short) Communications transport */
					/*	  to use (LM_TCP/LM_UDP) */
#define LM_A_CHECKOUT_DATA	35	/* (char *) Vendor-defined checkout  */
					/*				data */

#ifdef VMS
#define LM_A_EF_1		1001	/* (int) */
#define LM_A_EF_2		1002	/* (int) */
#define LM_A_EF_3		1003	/* (int) */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\lm_clien.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_client.h	1.2 12/23/93 */
/******************************************************************************


	    COPYRIGHT (c) 1988, 1992 by Highland Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Highland Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Highland Software Inc.

 *****************************************************************************/
/*
 *	Module:	lm_client.h v3.21
 *
 *	Description: Definitions for the license manager programs.
 *
 *	M. Christiano
 *	2/13/88
 *
 *	Last changed:  9/29/92
 *
 */

#ifndef _LM_CLIENT_H_
#define _LM_CLIENT_H_

#ifdef VMS
#include "param.h"
#else
#include <sys/param.h>
#endif

#if defined (sgi) || defined (MIPS)
#include <sys/types.h>
#endif

#if defined(MOTO_88K)
#define MAXPATHLEN 1024
#endif
#if defined(sco)
#define MAXPATHLEN PATHSIZE
#endif

/*
 *	FLEXlm version
 */

#define FLEXLM_VERSION 2
#define FLEXLM_REVISION 4
#define FLEXLM_PATCH "a"
extern float FLEXlm_VERSION;	/* Actual version #, in lmgr.a */

/*
 *	Codes returned from all client library routines
 */

#define	NOCONFFILE	-1	/* Can't find license file */
#define BADFILE		-2	/* License file corrupted */
#define NOSERVER	-3	/* Cannot connect to a license server */
#define MAXUSERS	-4	/* Maximum number of users reached */
#define NOFEATURE	-5	/* No such feature exists */
#define NOSERVICE	-6	/* No TCP/IP service "license" */
#define NOSOCKET	-7	/* No socket to talk to server on */
#define BADCODE		-8	/* Bad encryption code */
#define	NOTTHISHOST	-9	/* l_host failure code */
#define	LONGGONE	-10	/* Software Expired */
#define	BADDATE		-11	/* Bad date in license file */
#define	BADCOMM		-12	/* Bad return from server */
#define NO_SERVER_IN_FILE -13	/* No servers specified in license file */
#define BADHOST		-14	/* Bad SERVER hostname in license file */
#define CANTCONNECT	-15	/* Cannot connect to server */
#define CANTREAD	-16	/* Cannot read from server */
#define CANTWRITE	-17	/* Cannot write to server */
#define NOSERVSUPP	-18	/* Server does not support this feature */
#define SELECTERR	-19	/* Error in select system call */
#define SERVBUSY	-20	/* Application server "busy" (connecting) */
#define OLDVER		-21	/* Config file doesn't support this version */
#define CHECKINBAD	-22	/* Feature checkin failed at daemon end */
#define BUSYNEWSERV	-23	/* Server busy/new server connecting */
#define USERSQUEUED	-24	/* Users already in queue for this feature */
#define	SERVLONGGONE	-25	/* Version not supported at server end */
#define	TOOMANY		-26	/* Request for more licenses than supported */
#define CANTREADKMEM	-27	/* Cannot read /dev/kmem */
#define CANTREADVMUNIX	-28	/* Cannot read /vmunix */
#define CANTFINDETHER	-29	/* Cannot find ethernet device */
#define NOREADLIC	-30	/* Cannot read license file */
#define	TOOEARLY	-31	/* Start date for feature not reached */
#define	NOSUCHATTR	-32	/* No such attr for lm_set_attr/ls_get_attr */
#define	BADHANDSHAKE	-33	/* Bad encryption handshake with server */
#define CLOCKBAD	-34	/* Clock difference too large between 
							client/server */
#define FEATQUEUE	-35	/* We are in the queue for this feature */
#define FEATCORRUPT	-36	/* Feature database corrupted in daemon */
#define BADFEATPARAM	-37	/* dup_select mismatch for this feature */
#define FEATEXCLUDE	-38	/* User/host on EXCLUDE list for feature */
#define FEATNOTINCLUDE	-39	/* User/host not in INCLUDE list for feature */
#define CANTMALLOC	-40	/* Cannot allocate dynamic memory */
#define NEVERCHECKOUT	-41	/* Feature never checked out (lm_status()) */
#define BADPARAM	-42	/* Invalid parameter */
#define NOKEYDATA	-43	/* No FLEXlm key data */
#define BADKEYDATA	-44	/* Invalid FLEXlm key data */
#define FUNCNOTAVAIL	-45	/* FLEXlm function not available */
#define DEMOKIT		-46	/* FLEXlm software is demonstration version */
#define NOCLOCKCHECK	-47	/* Clock check not available in daemon */
#define BADPLATFORM	-48	/* FLEXlm platform not enabled */
#define DATE_TOOBIG	-49	/* Date too late for binary format */
#define EXPIREDKEYS	-50	/* FLEXlm key data has expired */
#define NOFLEXLMINIT	-51	/* FLEXlm not initialized */
#define NOSERVRESP	-52	/* Server did not respond to message */
#define CHECKOUTFILTERED -53	/* Request rejected by vendor-defined filter */
#define NOFEATSET 	-54	/* No FEATURESET line present in license file */
#define BADFEATSET 	-55	/* Incorrect FEATURESET line in license file */
#define CANTCOMPUTEFEATSET -56	/* Cannot compute FEATURESET line */
#define SOCKETFAIL	-57	/* socket() call failed */
#define SETSOCKFAIL	-58	/* setsockopt() failed */
#define BADCHECKSUM	-59	/* message checksum failure */
#define SERVBADCHECKSUM	-60	/* server message checksum failure */
#define SERVNOREADLIC	-61	/* Cannot read license file from server */
#define NONETWORK	-62	/* Network software (tcp/ip) not available */
#define NOTLICADMIN	-63	/* Not a license administrator */
#define REMOVETOOSOON	-64	/* lmremove request too soon */

/*
 *	Values for the "flag" parameter in the lm_checkout() call
 */

#define LM_CO_NOWAIT	0	/* Don't wait, report status */
#define LM_CO_WAIT	1	/* Don't return until license is available */
#define LM_CO_QUEUE	2	/* Put me in the queue, return immediately */
#define LM_CO_LOCALTEST	3	/* Perform local checks, no checkout */
#define LM_CO_TEST	4	/* Perform all checks, no checkout */

/*
 *	Parameter values for the checkout "group_duplicates" parameter
 *	In order to specify what constitutes a duplicate, 'or' together
 *	from the set { LM_DUP_USER LM_DUP_HOST LM_DUP_DISP LM_DUP_VENDOR}, 
 *	or use:
 *		LM_DUP_NONE or LM_DUP_SITE.  
 */
#define LM_DUP_NONE 0x4000	/* Don't allow any duplicates */
#define LM_DUP_SITE   0		/* Nothing to match => everything matches */
#define LM_DUP_USER   1		/* Allow dup if user matches */
#define LM_DUP_HOST   2		/* Allow dup if host matches */
#define LM_DUP_DISP   4		/* Allow dup if display matches */
#define LM_DUP_VENDOR 8		/* Allow dup if vendor-defined matches */
#define LM_COUNT_DUP_STRING "16384"	/* For ls_vendor.c: LM_DUP_NONE */
#define LM_NO_COUNT_DUP_STRING "3"	/* For ls_vendor.c: _USER | _HOST */

#define RESERVED_SERVER "SERVER"
#define RESERVED_PROG "DAEMON"
#define RESERVED_FEATURE "FEATURE"
#define RESERVED_FEATURESET "FEATURESET"

#define MAX_FEATURE_LEN 30		/* Longest featurename string */
#define DATE_LEN	11		/* dd-mmm-yyyy */
#define MAX_CONFIG_LINE	200		/* Maximum length of a configuration 
							file line */
#define	MAX_SERVER_NAME	32		/* Maximum FLEXlm length of hostname */
#define	MAX_HOSTNAME	64		/* Maximum length of a hostname */
#define	MAX_DISPLAY_NAME 32		/* Maximum length of a display name */
#define MAX_USER_NAME 20		/* Maximum length of a user name */
#define MAX_VENDOR_CHECKOUT_DATA 32	/* Maximum length of vendor-defined */
					/*		checkout data       */
#define MAX_DAEMON_NAME 10		/* Max length of DAEMON string */
#define MAX_SERVERS	5		/* Maximum number of servers */
#define MAX_USER_DEFINED 64		/* Max size of vendor-defined string */
#define MAX_VER_LEN 10			/* Maximum length of a version string */
#define MAX_LONG_LEN 10			/* Length of a long after sprintf */
#define MAX_SHORT_LEN 5			/* Length of a short after sprintf */
#define MAX_INET 16			/* Maximum length of INET addr string */
#define MAX_BINDATE_YEAR 2027		/* Binary date has 7-bit year */

/*
 *	License file location
 */

#define LM_DEFAULT_ENV_SPEC "LM_LICENSE_FILE"	/* How a user can specify */

#ifdef VMS
#define LM_DEFAULT_LICENSE_FILE "SYS$COMMON:[SYSMGR]FLEXLM.DAT"
#else
#define LM_DEFAULT_LICENSE_FILE "/usr/local/flexlm/licenses/license.dat"
#endif

/*
 *	V1/V2 compatibility macros
 */
#define _lm_errno lm_cur_job->lm_errno
#define uerrno lm_cur_job->u_errno   /* Unix errno corresponding to _lm_errno */

/*
 *	Structure types
 */

#define VENDORCODE_BIT64	1	/* 64-bit code */
#define VENDORCODE_BIT64_CODED	2	/* 64-bit code with feature data */
#define LM_DAEMON_INFO_TYPE	101	/* DAEMON_INFO data structure */
#define LM_JOB_HANDLE_TYPE	102	/* Job handle */
#define LM_LICENSE_HANDLE_TYPE	103	/* License handle */
#define LM_FEATURE_HANDLE_TYPE	104	/* Feature handle */
/*
 *	Host identification data structure
 */
typedef struct hostid {			/* Host ID data */
			short override;	/* Hostid checking override type */
#define NO_EXTENDED 1			/* Turn off extended hostid */
#define DEMO_SOFTWARE 2			/* DEMO software, no hostid */
			short type;	/* Type of HOST ID */
#define	NOHOSTID 0
#define HOSTID_LONG 1			/* Longword hostid, eg, SUN */
#define HOSTID_ETHER 2			/* Ethernet address, eg, VAX */
#define HOSTID_ANY 3			/* Any hostid */
#define HOSTID_USER 4			/* Username */
#define HOSTID_DISPLAY 5		/* Display */
#define HOSTID_HOSTNAME 6		/* Node name */
			union {
				long data;
#define ETHER_LEN 6			/* Length of an ethernet address */
				unsigned char e[ETHER_LEN];
				char user[MAX_USER_NAME+1];
				char display[MAX_DISPLAY_NAME+1];
				char host[MAX_HOSTNAME+1];
			      } id;
#define hostid_value id.data
#define hostid_eth id.e
#define hostid_user id.user
#define hostid_display id.display
#define hostid_hostname id.host
		      } HOSTID;
#define HOSTID_USER_STRING "USER="
#define HOSTID_HOSTNAME_STRING "HOSTNAME="
#define HOSTID_DISPLAY_STRING "DISPLAY="

#define MAX_CRYPT_LEN 20	/* use 8 bytes of encrypted return string to
				   produce a 16 char HEX representation  + 4 */

/*
 *	Vendor encryption seed
 */

typedef struct vendorcode {
			    short type;	    /* Type of structure */
			    long data[2];   /* 64-bit code */
			  } VENDORCODE;

typedef struct vendorcode2 {
			    short type;	   /* Type of structure */
			    long data[2];  /* 64-bit code */
			    long keys[3];  
					   
					   
			  } VENDORCODE2;

#define LM_CODE(name, x, y, k1, k2, k3)  static VENDORCODE2 name = \
						{ VENDORCODE_BIT64_CODED, \
						  (x), (y), (k1), (k2), (k3) }

#define LM_CODE_GLOBAL(name, x, y, k1, k2, k3)  VENDORCODE2 name = \
						{ VENDORCODE_BIT64_CODED, \
						  (x), (y), (k1), (k2), (k3) }

/*
 *	Server data from the license file FEATURE file
 */
typedef struct lm_server {		/* License servers */
			    char name[MAX_HOSTNAME+1];	/* Hostname */
			    struct hostid id;		/* hostid */
			    struct lm_server *next;	/* NULL =none */
				/* Fields below are only used in servers */
			    int fd1;	/* File descriptor for output */
			    int fd2;	/* File descriptor for input */
			    int state;	/* State of connection on fd1 */
			    int us;	/* "the host we are running on" flag */
			    int port;	/* What internet port # to use */
			    long exptime; /* When this connection attempt
						times out */
			  } LM_SERVER;

/*
 *	Feature data from the license file FEATURE file
 */
typedef struct config {			/* Feature data line */
			char feature[MAX_FEATURE_LEN+1]; /* Ascii name */
			double version;			/* Feature's version */
			char daemon[MAX_DAEMON_NAME+1];	/* DAEMON to serve */
			char date[DATE_LEN+1];		/* Expiration date */
			int users;			/* Licensed # users */
			char code[MAX_CRYPT_LEN+1];	/* encryption code */
			char user_string[MAX_USER_DEFINED+1];
						    /* User-defined string */
			struct hostid id;		/* Licensed host */
			LM_SERVER *server;		/* License server(s) */
			int lf;				/* License file index */
			struct config *next;		/* Ptr to next one */
		      } CONFIG;

/*
 *	License file pointer returned by l_open_file()
 */

#ifndef FILE
#include <stdio.h>
#endif

typedef struct license_file {
			      struct license_file *next;
			      int type;	/* Type of pointer */
#define LF_NO_PTR	0			/* Nothing */
#define LF_FILE_PTR	1			/* (FILE *) */
#define LF_STRING_PTR	2			/* In-memory string */
			      union {
					FILE *f;
					struct str {
							char *s;
							char *cur;
						   } str;
				    } ptr;
			    } LICENSE_FILE, *LF_POINTER;

/*
 *	User customization - CLIENT LIBRARY use only
 */
typedef void (*PFV)();

typedef struct lm_options {

#ifdef VMS
	int ef_1;		/* Three event flags for various timers */
	int ef_2;
	int ef_3;
#endif
	short decrypt_flag;	/* Controls whether encryption/decryption
							happens on lm_start */
	short disable_env;	/* Don't allow LM_LICENSE_FILE as location */
	char config_file[MAXPATHLEN+1];	/* The license file */
	short crypt_case_sensitive; 
				/* If <>0, encryption code in license file
						is case-sensitive. */
	short got_config_file;	/* Flag to indicate whether config_file
							is filled in */
	int check_interval;	/* Check interval (sec) (- implies no check) */
	int retry_interval;	/* Reconnection retry interval */
	int timer_type;
	int retry_count;	/* Number of reconnection retrys */
	int conn_timeout;	/* How long to wait for connect to complete */
	short normal_hostid;	/* 0 for extended, <> 0 for normal checking */
	int (*user_exitcall)();	/* Pointer to (user-supplied) exit handler */
	int (*user_reconnect)();	/* Pointer to (user) reconnection handler */
	int (*user_reconnect_done)();	
				/* Pointer to reconnection-complete handler */
	char *(*user_crypt)();	/* Pointer to (user-supplied) encryption 
							routine */
	char user_override[MAX_USER_NAME+1];	/* Override username */
	char host_override[MAX_SERVER_NAME+1];	/* Override hostname */
	char display_override[MAX_DISPLAY_NAME+1];	/* Override display */
	char vendor_checkout_data[MAX_VENDOR_CHECKOUT_DATA+1];	
				/* vendor-defined checkout data */
	int (*periodic_call)();	/* User-supplied call every few times
							thru lm_timer() */
	int periodic_count;	/* # of lm_timer() per periodic_call() */
	short no_demo;		/* Do not allow demo software */
	short any_enabled;	/* Allow "ANY" as hostid */
	short no_traffic_encrypt;	/* Do not encrypt traffic */
	short use_start_date;	/* Enforce the start date in the license file */
	int max_timediff;	/* Maximum time diff: client/server (minutes) */
	char **ethernet_boards;	/* User-supplied Ethernet device table */
				/*  list of string ptrs, ending with a
						NULL pointer */ 
	long linger_interval;	/* How long license lingers after program exit
						or checkin (seconds) */
	void (*setitimer)();	/* Substitute for setitimer() */
	PFV (*sighandler)();	/* Substitute for signal() */
	short try_old_comm;	/* Does l_connect() try old comm version code */
	short cache_file;	/* Does l_init_file() cache the LF data --
						lmgrd ONLY */
 	} LM_OPTIONS;

/*
 *	Data associated with a VENDOR (connection info, license file
 *		data pointers, etc.) - CLIENT LIBRARY use only
 */

typedef struct lm_daemon_info {
	short type;			/* Structure ID */
	struct lm_daemon_info *next;	/* Forward ptr */
	int commtype;			/* Communications type */
#define LM_TCP			1	/* TCP */
#define LM_UDP			2	/* UDP */
	int socket;			/* Socket file descriptor */
	int usecount;			/* Socket use count */
	int serialno;			/* Socket "serial #" */
	LM_SERVER *server;		/* servers associated with socket */
	char daemon[MAX_DAEMON_NAME+1]; /* Which daemon socket refers to */
	long encryption;		/* Handshake encryption code */
	int comm_version;		/* Communications version of server */
	int comm_revision;		/* Communications rev of server */
	int our_comm_version;		/* Our current comm version */
	int our_comm_revision;		/* Our current comm rev */
	short heartbeat;		/* Send heartbeat messages (== 1 except 
							for utility programs) */
		       } LM_DAEMON_INFO;

/*
 *	Handles returned by FLEXlm
 */

typedef struct lm_handle {
			   int type;		/* Type of struct */
			   LM_DAEMON_INFO *daemon; /* Daemon data */
			   LM_OPTIONS *options;	/* Options for this job */
			   int lm_errno;	/* Most recent error */
			   int u_errno;		/* unix error (errno) 
						   corresponding to lm_errno */
			   CONFIG *line;	/* Pointer to list of license 
							file lines */
			   char **lic_files;	/* Array of license file names*/
			   int lfptr;		/* Current license file ptr */
			   LF_POINTER license_file_pointers;
						/* LF data pointers */
#define LFPTR_INIT -1
#define LFPTR_FILE1 0 
			   VENDORCODE code;	/* Encryption code */
			 } LM_HANDLE;	/* Handle returned by certain calls */

typedef struct lm_license_handle {
				   int type;	/* LM_LICENSE_HANDLE_TYPE */
				   int handle;	/* License handle from daemon */
				 } LM_LICENSE_HANDLE;
		
typedef struct lm_feature_handle {
				   int type;	/* LM_FEATURE_HANDLE_TYPE */
				   char *code;	/* Encryption code from license
						   file line */
				 } LM_FEATURE_HANDLE;
		

/*
 *	User data returned from the license server
 */
typedef struct lm_users {
			   struct lm_users *next;
			   char name[MAX_USER_NAME + 1];
			   char node[MAX_SERVER_NAME + 1];
			   char display[MAX_DISPLAY_NAME + 1];
			   char vendor_def[MAX_VENDOR_CHECKOUT_DATA + 1];
			   int nlic;	/* Number of licenses */
			   short opts;	/* options flag */
#define INQUEUE		0x1	/* User is in queue */
#define HOSTRES		0x2	/* Reservation for a host "node" */
#define USERRES		0x4	/* Reservation for user "name" */
#define DISPLAYRES	0x8	/* Reservation for display "name" */
#define GROUPRES	0x10	/* Reservation for group "name" */
#define INTERNETRES	0x20	/* Reservation for internet "name" */
#define lm_isres(x) ((x) & (HOSTRES | USERRES | DISPLAYRES | GROUPRES | INTERNETRES))
						/* This is a reservation */
			   long time;		/* Seconds value from timeval */
			   double version;	/* Version of software */
			   long linger;		/* Linger interval */
			   LM_SERVER *server;	/* License server */
			   LM_LICENSE_HANDLE license; /* License handle */
			   LM_FEATURE_HANDLE feature; /* feature handle */
			 } LM_USERS;


typedef struct _lm_setup_data {			/* OBSOLETE in FLEXlm v2.0 */
				short decrypt_flag;	
				int timer_type;
				int check_interval, retry_count, retry_interval;
				int (*reconnect)(), (*reconnect_done)();
				int (*exitcall)();
				char *(*crypt)();
				short crypt_case_sensitive;
				int conn_timeout;
				char config_file[MAXPATHLEN+1];
				short disable_env, normal_hostid;
				char user_override[MAX_USER_NAME+1];
				char host_override[MAX_SERVER_NAME+1];
				int (*periodic_call)(), periodic_count;
				short no_demo, no_traffic_encrypt;
				short use_start_date;
				int max_timediff;
				char display_override[MAX_DISPLAY_NAME+1];
#ifdef VMS
				int ef_1, ef_2, ef_3;
#endif
			} SETUP_DATA;

/*
 *	These definitions are here so client software doesn't need
 *	<sys/time.h>
 */
#define LM_REAL_TIMER    1234
#define LM_VIRTUAL_TIMER 4321

/*
 *	Some function types
 */

extern CONFIG *lm_auth_data();
extern char *lm_daemon();
extern char *lm_display();
extern char *lm_errstring();
extern char **lm_feat_list();
extern char *lm_feat_set();
extern CONFIG *lm_get_config();
extern HOSTID *lm_gethostid();
extern HOSTID *lm_getid_type();
extern char *lm_hostname();
extern char *lm_lic_where();
extern CONFIG *lm_next_conf();
extern CONFIG *lm_test_conf();
extern LM_USERS *lm_userlist();
/*
 *	The current job handle
 */
extern LM_HANDLE *lm_cur_job;

extern char *lm_username();
typedef struct hosttype { 
			  int code; 	/* machine type (see lm_hosttype.h) */
			  char *name; 	/* Machine name, eg. sun 3/50 */
#define MAX_HOSTTYPE_NAME 50		/* Longest hosttype name length */
			  int flexlm_speed; /* Speed determined at run time */
			  int vendor_speed; /* Speed claim by vendor */
			} HOSTTYPE;
extern HOSTTYPE *lm_hosttype();

/*
 *	Alternate definitions for SPARC COMPLIANT code
 */
#ifdef SPARC_COMPLIANT
#define LIS_HELLO		LM_HELLO
#define LIS_REREAD		LM_REREAD
#define LIS_TRY_ANOTHER		LM_TRY_ANOTHER
#define LIS_OK			LM_OK
#define LIS_NO_SUCH_FEATURE	LM_NO_SUCH_FEATURE
#ifndef SPARC_COMPLIANT_FUNCS
#define SPARC_COMPLIANT_FUNCS
#define lm_daemon lis_daemon
#define lm_feat_list lis_feat_list
#define lm_flush_config lis_flush_config
#define lm_free_daemon_list lis_free_daemon_list
#define lm_get_config lis_get_config
#define lm_get_dlist lis_get_dlist
#define l_master_list lis_master_list
#define lm_next_conf lis_next_conf
#endif	/* ndef SPARC_COMPLIANT_FUNCS */
#endif /* SPARC_COMPLIANT */

#endif /* _LM_CLIENT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\loader.h ===
/*[
 *	Name:           loader.h
 *
 *      Author:        	Jerry Kramskoy
 *
 *      Created On:    	22 April 1993
 *
 *      Sccs ID:        @(#)loader.h	1.8 03/02/95
 *
 *      Purpose:      	dynamic loader for jcode derived binary
 *
 *      Design document:/HWRD/SWIN/JCODE/lnkload
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/



/*===========================================================================*/
/*			INTERFACE DATA TYPES				     */
/*===========================================================================*/




/*===========================================================================*/
/*			INTERFACE GLOBALS   				     */
/*===========================================================================*/


/*===========================================================================*/
/*			HOST PROVIDED PROCEDURES			     */
/*===========================================================================*/

extern VOID host_set_data_execute IPT2(IU8, *base, IU32, size);


/*===========================================================================*/
/*			INTERFACE PROCEDURES				     */
/*===========================================================================*/

/* link/load jcode object files */

typedef void (*VFUNC)();

extern	IBOOL	JLd IPT4(CHAR *, executable, IUH, version, IU32 *, err,
	VFUNC, allocCallback);

/* get load address of base of typed segment */
extern	IUH	JSegBase 	IPT1(IUH, segType);

/* get load address of base of typed segment */
extern	IUH	JSegLength	IPT1(IUH, segType);

/* free up loader data structures once all address queries have been done */
extern	void	JLdRelease	IPT0();

/* free up segments regardless of discardable attribute */
extern void   JLdReleaseAll IPT0();

extern IUH JCodeSegBase IPT0();
extern IUH JCodeSegLength IPT0();
extern IUH JLookupSegBase IPT0();
extern IUH JLookupSegLength IPT0();
extern IUH JCleanupSegBase IPT0();
extern IUH JCleanupSegLength IPT0();

/* interface notes
   ---------------

   To load an already linked jcode object file:

   CHAR *ldReqs[] = {
	"fileA"
   };

   IBOOL loadSuccess = Jld("fileA", &err);
   if (!loadSuccess)
   {
	if (err == JLD_NOFILE_ERR)
		missing file ...
	else
	if (err == JLD_BADFILE_ERR)
		errors in obj.file ...
	else
	if (err == JLD_UNRESOLVED_ERR)
		cant use, cos unresolved refs ...
	else
	if (err == JLD_BADMACH_ERR)
		cant use, cos binary is for wrong machine type!!!
	else
	if (err == JLD_VERSION_MISMATCH)
		cant use, cos binary does not match KRNL286.EXE
   }


   Then query for addresses ...

   apiLookUpBase = JSegBase(JLD_APILOOKUP);

   Once all addresses have been determined ...

   JLdRelease();

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\lock.h ===
/*
	
FILE NAME	: lock.h
DESCRIPTION	: Interface for locking functions.

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J. Koprowski
DATE		: June 1990


=========================================================================

AMENDMENTS	:

=========================================================================
*/

/* SccsID[]="@(#)lock.h	1.7 09/24/92 Copyright Insignia Solutions Ltd."; */

#ifdef ANSI
extern boolean gain_ownership(int);
extern void release_ownership(int);
extern void critical_region(void);
extern boolean host_place_lock(int, CHAR *);
extern boolean host_check_for_lock(int);
extern void host_clear_lock(int);
#else
extern boolean gain_ownership();
extern void release_ownership();
extern void critical_region();
extern boolean host_place_lock();
extern boolean host_check_for_lock();
extern void host_clear_lock();
#endif /* ANSI */
extern int host_get_hostname_from_stat IPT4(struct stat *,filestat, CHAR *,hostname, CHAR *, pathname, int, fd);
IMPORT BOOL host_ping_lockd_for_file IPT1(CHAR *,path);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\lq2500.h ===
/*[
 *		Name:			LQ2500.h
 *
 *		Derived from:	nowhere
 *
 *		Author:			Chris Paterson
 *
 *		Created on:		11:44:05  25/7/1991
 *
 *		Purpose:		This file is the interface to the base part of an LQ-2500 printer
 *						emulator.  It takes a text stream from the host_get_next_print_byte
 *						routine in host code and calls a set of host dependent routines
 *						that provide a generic interface to the host's printing facilities.
 *
 *		SccsId:			@(#)LQ2500.h	1.3 09/02/94
 *		(c) Copyright Insignia Solutions Ltd., 1991.  All rights reserved.
]*/


/* constants */

#define	EPSON_STANDARD	0		/* character sets */
#define	EPSON_IBM		1
#define	USER_DEFINED	2

#define	USA			0
#define	FRANCE		1
#define	GERMANY		2
#define	UK			3
#define	DENMARK_1	4
#define	SWEDEN		5
#define	ITALY		6
#define	SPAIN_1		7
#define	JAPAN		8
#define	NORWAY		9
#define	DENMARK_2	10
#define	SPAIN_2		11
#define	LATIN_AMERICA	12
#define	MAX_COUNTRY	12

#define	FONT_NAME_SIZE	31		/* characters in a pstring */


/* Types... */

/* LQ2500-specific initial settings struct... */
typedef struct LQconfig {
	IU8	autoLF;
	UTINY	font;			// not used
	TINY	pitch;
	IU8	condensed;
	USHORT	pageLength;		// in half-inch units
	USHORT	leftMargin;		// in columns
	USHORT	rightMargin;
	TINY	cgTable;
	TINY	country;
	/* These are used by the host bit of the LQ2500: */
	SHORT	monoSize;
	SHORT	propSize;
	CHAR	monoFont[FONT_NAME_SIZE+1];			// pascal strings
	CHAR	proportionalFont[FONT_NAME_SIZE+1];
} LQconfig;


/*  Globals... */
IMPORT LQconfig SelecType;


/* Prototypes: */

IMPORT	VOID		Emulate_LQ2500(VOID);
IMPORT	VOID		Reset_LQ2500(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\low_intp.h ===
/* File             : low_intp.h
 *
 * Description      : Low-level routines for emulators called from host_print_doc().
 *
 * Author           : David Rees
 *
 * SccsId			: @(#)low_intp.h	1.6 09/23/94
 *
 * Mods:
 *		<chrisP 27Jul91>
 *		Added LQ2500 emulation - insignia.h'ified, etc
 *		These routines are sort of printer independent.  The idea is that when
 *		a new printer emulation is added, these routines can be added to,
 *		stubbed out, and change their behaviour depending on the currently
 *		selected printer.  The same goes for the #DEFINEs.
 */

/* constants */

#define	CONDENSED	0x01		/* squash chars down to 60% */
#define	DOUBLE_WIDTH	0x02	/* expand chars up to 200% */

#define	EMPHASIZED	0x01		/* like bold */
#define	DOUBLE_STRIKE	0x02	/* like bold */
#define	UNDERLINE	0x04
#define	ITALIC		0x08
#define	SUPER		0x10		/* super and sub script */
#define	SUB			0x20

#define	PROPORTIONAL	-1
#define	PICA		0
#define	ELITE		1
#define	CPI15		2			/* 15 Char per inch */

#define	LQ_ROMAN		0		/* EPSON LQ font numbers */
#define	LQ_SANS_SERIF	1
#define	LQ_COURIER		2
#define	LQ_PRESTIGE		3
#define	LQ_SCRIPT		4
#define	MAX_FONT		4

/* printer emulation globals... */

IMPORT	SHORT	PrintError;			/* set to tell emulations to abort */
IMPORT	SHORT	HResolution;		/* set by emulation to establish scaling ... */
IMPORT	SHORT	VResolution;		/* ... for MoveHead() routine. */

IMPORT	SHORT	CurrentCol;			/* current print head position ... */
IMPORT	SHORT	CurrentRow;			/* ... at emulated printer resolution */
IMPORT	SHORT	BufferWidth;		/* width of chars in print buffer (ditto) */

/* Prototypes... */

IMPORT	BOOL	host_auto_LF_for_print(VOID);
IMPORT	SHORT	host_get_next_print_byte(VOID);

IMPORT	VOID		host_PrintChar(IU8 ch);
IMPORT	VOID		host_PrintBuffer(IU8 mode);
IMPORT	VOID		host_EjectPage(VOID);
IMPORT	VOID		host_CancelBuffer(VOID);
IMPORT	VOID		host_DeleteCharacter(VOID);
IMPORT	VOID		host_SetScale(SHORT type);
IMPORT	VOID		host_ReSetScale(SHORT type);
IMPORT	VOID		host_SetStyle(SHORT type);
IMPORT	VOID		host_ReSetStyle(SHORT type);
IMPORT	VOID		host_SelectPitch(TINY Pitch);
IMPORT	VOID		host_SelectFont(TINY Font);
IMPORT	VOID		host_ProcessGraphics(TINY mode, SHORT colLeft);
IMPORT	VOID		host_LqClearUserDefined(VOID);
IMPORT	VOID		host_LqPrintUserDefined(IU8 ch);
IMPORT	BOOL		host_LqDefineUserDefined(SHORT offset, SHORT columns, IU8 ch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\lm_code.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_code.h	1.4 08/19/94 */
/******************************************************************************

	    COPYRIGHT (c) 1990, 1992 by Globetrotter Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Globetrotter Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Globetrotter Software Inc.

 *****************************************************************************/
/*	
 *	Module:	lm_code.h v3.3
 *
 *	Description: 	Encryption codes to be used in a VENDORCODE macro 
 *			for FLEXlm daemons, create_license, lm_init(),
 *			and lm_checkout() call - modify these values 
 *			for your own use.  (The VENDOR_KEYx values
 *			are assigned by Highland Software).
 *
 *	example LM_CODE() macro:
 *
 *		LM_CODE(var_name, ENCRYPTION_CODE_1, ENCRYPTION_CODE_2,
 *				VENDOR_KEY1, VENDOR_KEY2, VENDOR_KEY3);
 *
 */

/*
 *	VENDOR's private encryption seed
 */

#define ENCRYPTION_CODE_1 0x75ac39bf
#define ENCRYPTION_CODE_2 0x4fd10552

/*
 * Encryption keys for DOS application licensing
 */

#define DAL_ENCRYPTION_CODE_1 0xf26b9ea0
#define DAL_ENCRYPTION_CODE_2 0x4c251cb6

/*
 *	FLEXlm vendor keys
 */

#define VENDOR_KEY1 0x2751aaa6
#define VENDOR_KEY2 0x984ecf13
#define VENDOR_KEY3 0x23916ef3

/*
 *	FLEXlm vendor name
 */

#define VENDOR_NAME "insignia"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\mark_ima.h ===
/*[
	Name:		mark_image.h
	Derived From:	base 2.0 (markformicon)
	Author:		gvdl
	Created On:	7 May 1991
	Sccs ID:	08/10/92 @(#)mark_image.h	1.3
	Purpose:	Defines an image for hunter error marking.
	Notes:		insignia.h must be included prior to this file.

	Format_version:		1
	Width:			64
	Height:			64
	Depth:			1
	Valid_bits_per_item:	16

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#define MARK_HEIGHT	64
#define MARK_WIDTH	64
#define MARK_DEPTH	1
#define MARK_BYTES	8

LOCAL USHORT mark_image[256] =
{
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x000E, 0x0000, 0x0000, 0x7000, 0x000F, 0x0000, 0x0000, 0xF000,
	0x000F, 0x8000, 0x0001, 0xF000, 0x0007, 0xC000, 0x0003, 0xE000,
	0x0003, 0xE000, 0x0007, 0xC000, 0x0001, 0xE000, 0x0007, 0x8000,
	0x0000, 0xF000, 0x000F, 0x0000, 0x0000, 0x3800, 0x001C, 0x0000,
	0x0000, 0x1C00, 0x0038, 0x0000, 0x0000, 0x0C00, 0x0030, 0x0000,
	0x0000, 0x0200, 0x0040, 0x0000, 0x0000, 0x0100, 0x0080, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0100, 0x0080, 0x0000, 0x0000, 0x0200, 0x0040, 0x0000,
	0x0000, 0x0C00, 0x0030, 0x0000, 0x0000, 0x1C00, 0x0038, 0x0000,
	0x0000, 0x3800, 0x001C, 0x0000, 0x0000, 0xF000, 0x000F, 0x0000,
	0x0001, 0xE000, 0x0007, 0x8000, 0x0003, 0xE000, 0x0007, 0xC000,
	0x0007, 0xC000, 0x0003, 0xE000, 0x000F, 0x8000, 0x0001, 0xF000,
	0x000F, 0x0000, 0x0000, 0xF000, 0x000E, 0x0000, 0x0000, 0x7000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\mda.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Mono Display Adaptor declarations
 *
 * Description	: Definitions for users of the MDA
 *
 * Author	: David Rees
 *
 * Notes	: None
 */


/* SccsID[]="@(#)mda.h	1.4 02/23/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT VOID mda_init IPT0();
IMPORT VOID mda_term IPT0();
IMPORT VOID mda_inb IPT2(io_addr, address, half_word *, value);
IMPORT VOID mda_outb IPT2(io_addr, address, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\make_dis.h ===
/*[
 *	Name:		make_disk.h
 *	Derived From:	Original
 *	Author:		Philippa Watson
 *	Created On:	7 February 1992
 *	Sccs Id:	@(#)make_disk.h	1.7 08/19/94
 *	Purpose:	Interface file for make_disk.c.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

#ifndef SOURCE
/* this set of macros allow to do some fancy stuff for HD creation 
   other than just simply read the data from the Data File (e.g de-compression on the fly)
   The default set is, however, equivalent to the simple case. These macros may be 
   overwritten in host_fio.h.
 */
#define	SOURCE 												HOST_FILE
#define SOURCE_DESC 										HOST_FILE_DESC
#define SOURCE_OPEN(source_desc)							host_fopen_for_read(source_desc)
#define SOURCE_READ_HEADER(buffer, size, length, source) 	host_fread_buffer(buffer, size, length, source)
#define SOURCE_READ_DATA(buffer, size, length, source) 		host_fread_buffer(buffer, size, length, source)
#define SOURCE_END(source)									host_feof(source)
#define SOURCE_CLOSE(source)								host_fclose(source)
#define SOURCE_FSEEK_ABS(source, pos)						host_fseek_abs(source, pos)
#define SOURCE_LAST_MOD_TIME(source)						getDosTimeDate(source)
#endif /* ! SOURCE */

/* This function returns 0 if the disk is successfully created; non-zero
** otherwise.
*/
IMPORT int MakeDisk IPT5(
	HOST_FILE_DESC, diskFileDesc,	/* C string, name of disk to create */
	unsigned, 	size,		/* size in Mb, no upper limit */
	char, 		disktype,	/* b for bootable, n non-bootable,
				  	v just return DOS version ID. */
	SOURCE_DESC, dataFileDesc,	/* file where the compressed Dos and */
					/* Insignia data lives */
	char, 		zeroFill );		/* z to fill disk with zeros, n don't.*/

IMPORT int MakeDiskWithDelete IPT6(
	HOST_FILE_DESC, diskFileDesc,	/* C string, name of disk to create */
	unsigned, 	size,		/* size in Mb, no upper limit */
	char, 		disktype,	/* b for bootable, n non-bootable,
				  	v just return DOS version ID. */
	SOURCE_DESC, dataFileDesc,	/* file where the compressed Dos and */
					/* Insignia data lives */
	char, 		zeroFill , /* z to fill disk with zeros, n don't, */
					/* dont and truncate the disk. */
	int , delete_source_b /* If true then delete HD source files after use. */
	) ;

#ifndef DeleteHDDataFile
IMPORT void DeleteHDDataFile IPT1( HOST_FILE_DESC , dataFileDesc ) ;
#endif /* ! DeleteHDDataFile */
#ifndef FeedbackHDCreation
IMPORT void FeedbackHDCreation IPT1( int , file_number ) ;
#endif /* ! FeedbackHDCreation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\mouse16b.h ===
/*[
 *
 *	File		:	mouse16b.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	Header file to define the interface to
 *				the 32 side bit of the 16 bit mouse driver
 *
 *				This is required because we still need the 
 *				BOPs so that the inport emulation is kept
 *				up to date
 *
 *	Author		:	Rog
 *	Date		:	22 Feb 1992
 *
 *	SCCS Gumph	:	@(#)mouse16b.h	1.2 01/11/94
 *
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/


#ifndef _MOUSE_16B_H_
#define _MOUSE_16B_H_

/* prototypes */

void mouse16bInstall IPT0( );
void mouse16bSetBitmap IPT3( MOUSE_SCALAR * , hotspotX ,
				MOUSE_SCALAR * , hotspotY ,
					word * , bitmapAddr );
void mouse16bDrawPointer IPT1( MOUSE_CURSOR_STATUS , * cursorStat );
void mouse16bShowPointer IPT1( MOUSE_CURSOR_STATUS , * cursorStat );
void mouse16bHidePointer IPT0( );

/* Data */

/* Structure containing all the entry points into the 16 bit code */

struct mouseIOTag {
	sys_addr	mouse_io;
	sys_addr	mouse_video_io;
	sys_addr	mouse_int1;
	sys_addr	mouse_version;
	sys_addr	mouse_copyright;
	sys_addr	video_io;
	sys_addr	mouse_int2;
	sys_addr	entry_point_from_32bit;
	sys_addr	int33function0;
	sys_addr	int33function1;
	sys_addr	int33function2;
	sys_addr	int33function9;
	sys_addr	current_position_x;
	sys_addr	current_position_y;
	sys_addr	mouseINB;
	sys_addr	mouseOUTB;
	sys_addr	mouseOUTW;
}	mouseIOData;

        
#endif _MOUSE_16B_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\mouse.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	:  mouse.h
 *
 * Description	: Microsoft Mouse
 *
 * Author	: 
 *
 * Notes	:
 */

/* SccsID[]="@(#)mouse.h	1.7 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/* Mouse port number definitions. */
#if defined(NEC_98)
#define NMODE_BASE              0x7FD9
#define HMODE_BASE              0x61
#define MOUSE_PORT_START        0
#define MOUSE_PORT_END          6
#define MOUSE_PORT_0            0
#define MOUSE_PORT_1            2
#define MOUSE_PORT_2            4
#define MOUSE_PORT_3            6

#define NEC98_CPU_MOUSE_INT2     6   //INT2 Master PIC
#define NEC98_CPU_MOUSE_INT6     5   //INT6 Slave PIC

#define NEC98_CPU_MOUSE_ADAPTER0 0
#define NEC98_CPU_MOUSE_ADAPTER1 1
#else  // !NEC_98
#define MOUSE_PORT_0		0x023c
#define MOUSE_PORT_1		0x023d
#define MOUSE_PORT_2		0x023e
#define MOUSE_PORT_3		0x023f

#define MOUSE_PORT_START	0x023c
#define MOUSE_PORT_END		0x023f
#endif // !NEC_98

/* Internal mouse status word bits. */
#define LEFT_BUTTON_DOWN	0x04
#define LEFT_BUTTON_CHANGE	0x20
#define RIGHT_BUTTON_DOWN	0x01
#define RIGHT_BUTTON_CHANGE	0x08
#define MOVEMENT		0x40

/* Internal mode register word bits. */
#define HOLD			0x20

/* Inport internal registers. */
#define INTERNAL_MOUSE_STAT_REG	0x0
#define INTERNAL_DATA1_REG	0x1
#define INTERNAL_DATA2_REG	0x2
#define INTERNAL_DATA3_REG	0x3
#define INTERNAL_DATA4_REG	0x4
#define INTERFACE_STATUS_REG	0x5
#define INTERFACE_CONTROL_REG	0x6
#define INTERNAL_MODE_REG	0x7

/*
 * Maximum acceleration threshold - treated as unsigned word by supplied
 * handler routine so 0xffff is large rather than -1.
 */
#define MAX_THRESHOLD		0xffff


/* Count of the number of different bop functions. */
#define NUM_MOUSE_FUNCS		(sizeof(mouse_functions)/sizeof(SHORT (*)()))

/*
 * Definitions below are copied from MS-Windows Intel mouse driver and are
 * required to acknowledge mouse interrupts.
 */
#define ACK_PORT		0x0020
#define ACK_SLAVE_PORT		0x00a0
#define EOI			0x20
#define PMODE_WINDOWS		1
#define INPORT_MAX_INTERRUPTS	30

/*
 * Machine word bit definitions.
 */
#define BIT0	(1 << 0)
#define BIT1	(1 << 1)
#define BIT2	(1 << 2)
#define BIT3	(1 << 3)
#define BIT4	(1 << 4)
#define BIT5	(1 << 5)
#define BIT6	(1 << 6)
#define BIT7	(1 << 7)
#define BIT8	(1 << 8)
#define BIT9	(1 << 9)
#define BIT10	(1 << 10)
#define BIT11	(1 << 11)
#define BIT12	(1 << 12)
#define BIT13	(1 << 13)
#define BIT14	(1 << 14)
#define BIT15	(1 << 15)

/* Microsoft Inport mouse driver assumes mouse has 2 buttons so so do we. */
#define INPORT_NUMBER_BUTTONS	2

/* Size of Intel MOUSEINFO structure. */
#define MOUSEINFO_SIZE		14

/* Offset of fuunction parameters from frame pointer in Intel. */
#define PARAM_OFFSET		6

IMPORT void mouse_init IPT0();
IMPORT void mouse_inb IPT2(io_addr, port, half_word *, value);
IMPORT void mouse_outb IPT2(io_addr, port, half_word, value);
IMPORT void mouse_send IPT4(int, Delta_x, int, Delta_y, int, left, int, right);

IMPORT ULONG mouse_last;  /* remembers last time mouse was processed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\msw_dbg.h ===
/*[
 * 	Name:		msw_dbg.h
 *
 *	Derived From:	debug.h
 *
 *	Author:		P. Ivimey-Cook
 *
 *	Created On:	7/6/94
 *
 *	SCCS ID:	@(#)msw_dbg.h	1.4 08/19/94
 *
 *	Coding Stds:	2.0
 *
 *	Purpose:	
 *			
 *
 *    Copyright Insignia Solutions Limited 1994. All rights reserved.
 *
]*/

#ifndef MSW_DBG_H
#define MSW_DBG_H

#include <stdio.h>
#include "trace.h"

/*
 * -----------------------------------------------------------------------------
 * Error & debug entry points for display driver low level functions 
 * -----------------------------------------------------------------------------
 */

#ifndef PROD

#define msw_error0(p1)		{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1); fputc('\n', trace_file); }
#define msw_error1(p1,p2)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2); fputc('\n', trace_file); }
#define msw_error2(p1,p2,p3)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2,p3); fputc('\n', trace_file); }
#define msw_error3(p1,p2,p3,p4)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2,p3,p4); fputc('\n', trace_file); }

#else

#define msw_error0(p1)
#define msw_error1(pl,p2)
#define msw_error2(pl,p2,p3)
#define msw_error3(pl,p2,p3,p4)

#endif

#if !defined(PROD) && defined(MSWDVR_DEBUG)

#ifndef	newline
#define	newline	fprintf(trace_file, "\n")
#endif

extern IU32 msw_verbose;	/* general trace flags */
extern IU32 msw_enterexit;	/* enter / leave trace flags */
extern int mswdvr_debug;

/*
 * Debug levels. Higher levels get more output. Controlled by
 * variable 'mswdvr_debug'.
 */
#define MSWDLEV_SILENT	0
#define MSWDLEV_MIN	1
#define MSWDLEV_AVG	2
#define MSWDLEV_MAX	3

/* cf:  unused?? I think so. PIC
 * #define QUIET	1
 * #define MILD	(QUIET + 1)
 * #define VERBOSE (MILD + 1)
 */

/*
 * Functional Unit flags: Basically the frontend API calls.
 */
#define MSW_MISC_VERBOSE		0x00000001	/* Any Functional unit not otherwise covered */
#define MSW_BITBLT_VERBOSE		0x00000002	/* BitBlt call */
#define MSW_COLOUR_VERBOSE		0x00000004	/* ColorInfo call */
#define MSW_CONTROL_VERBOSE		0x00000008	/* Control call */
#define MSW_ENAB_DISAB_VERBOSE		0x00000010	/* Enable and Disable calls */
#define MSW_ENUM_VERBOSE		0x00000020	/* EnumDFonts and EnumObj calls */
#define MSW_OUTPUT_VERBOSE		0x00000040	/* Output call */
#define MSW_PIXEL_VERBOSE		0x00000080	/* Pixel call */
#define MSW_BITMAP_VERBOSE		0x00000100	/* Bitmap, BitmapBits calls */
#define MSW_REALIZEOBJECT_VERBOSE	0x00000200	/* RealizeObject call */
#define MSW_SCANLR_VERBOSE		0x00000400	/* ScanLR call */
#define MSW_DEVICEMODE_VERBOSE		0x00000800	/* DeviceMode call */
#define MSW_INQUIRE_VERBOSE		0x00001000	/* Inquire call */
#define MSW_CURSOR_VERBOSE		0x00002000	/* {Set,Move,Check}Cursor calls */
#define MSW_TEXT_VERBOSE		0x00004000	/* StrBlt, ExtTextOut, GetCharWidth calls */
#define MSW_DEVICEBITMAP_VERBOSE	0x00008000	/* DeviceBitmap, DeviceBitmapBits, SetDIBits, SaveScreenBitmap calls */
#define MSW_FASTBORDER_VERBOSE		0x00010000	/* FastBorder call */
#define MSW_ATTRIBUTE_VERBOSE		0x00020000	/* SetAttribute call */
#define MSW_PALETTE_VERBOSE		0x00040000	/* {Get,Set} Palette call */

/*
 * Other (lower-level) Verbose flags
 */
#define MSW_MEMTOMEM_VERBOSE		0x00080000	/* Code dealing with memory bitmaps specifically */
#define MSW_LOWLEVEL_VERBOSE		0x00100000	/* Code performing low level ops - e.g. XLib calls */
#define MSW_CONVERT_VERBOSE		0x00200000	/* (Bitmap) Conversion code */
#define MSW_INTELIO_VERBOSE		0x00400000	/* Code dealing with reading/writing M */
#define MSW_OBJECT_VERBOSE		0x00800000	/* Object routines (e.g. ObjPBrushAccess() */
#define MSW_RESOURCE_VERBOSE		0x01000000	/* Resource routines (e.g. ResAllocateXXX() */
#define MSW_WINDOW_VERBOSE		0x02000000	/* Routines dealing with windows e.g. WinOpen(), WinUMap() */
#define MSW_CACHE_VERBOSE		0x04000000	/* Routines dealing with GDI brush/pen cache */

/*
 * Generic tracing stuff to avoid nasty defines everywhere
 */

#define msw_cond(bit)		((msw_verbose & (bit)) != 0)
#define msw_cond_lev(bit, lev)	(((msw_verbose & (bit)) != 0) && (mswdvr_debug >= (lev)))
#define msw_cond_enter(bit)	((msw_enterexit & (bit)) != 0)
#define msw_cond_leave(bit)	((msw_enterexit & (bit)) != 0)
#define msw_entering_msg(fn)	fprintf(trace_file, "Entering: %s ", fn)
#define msw_exiting_msg(fn)	fprintf(trace_file, "Exiting : %s ", fn)

#define msw_do_trace(trace_bit, call)			if (msw_cond(trace_bit)) { call; }
#define msw_do_lev_trace(trace_bit, lev,call)		if (msw_cond_lev(trace_bit,lev)) { call; }

#define msw_trace_enter(trace_bit,fnname) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			newline; \
		}
#define msw_trace_enter0(trace_bit,fnname,str) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str); \
			newline; \
		}
#define msw_trace_enter1(trace_bit,fnname,str,p0) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0); \
			newline; \
		}
#define msw_trace_enter2(trace_bit,fnname,str,p0,p1) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1); \
			newline; \
		}
#define msw_trace_enter3(trace_bit,fnname,str,p0,p1,p2)	\
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2); \
			newline; \
		}
#define msw_trace_enter4(trace_bit,fnname,str,p0,p1,p2,p3) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3); \
			newline; \
		}
#define msw_trace_enter5(trace_bit,fnname,str,p0,p1,p2,p3,p4) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4); \
			newline; \
		}
#define msw_trace_enter6(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5); \
			newline; \
		}
#define msw_trace_enter7(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6); \
			newline; \
		}
#define msw_trace_enter8(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7); \
			newline; \
		}
#define msw_trace_enter9(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8); \
			newline; \
		}
#define msw_trace_enter10(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9); \
			newline; \
		}
#define msw_trace_enter11(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10); \
			newline; \
		}
#define msw_trace_enter12(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11); \
			newline; \
		}

#define msw_trace_leave(trace_bit,fnname)		if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);newline; }
#define msw_trace_leave0(trace_bit,fnname,str)		if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);fprintf(trace_file,str); newline;}
#define msw_trace_leave1(trace_bit,fnname,str, r0)	if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);fprintf(trace_file,str, r0); newline;}

#define	msw_trace0(trace_bit,str)			if (msw_cond(trace_bit)) { fprintf(trace_file, str); newline; }
#define	msw_trace1(trace_bit,str,p0)			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0);newline; }
#define	msw_trace2(trace_bit,str,p0,p1)			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1);newline; }
#define	msw_trace3(trace_bit,str,p0,p1,p2)		if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2);newline; }
#define	msw_trace4(trace_bit,str,p0,p1,p2,p3)		if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	msw_trace5(trace_bit,str,p0,p1,p2,p3,p4)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	msw_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	msw_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	msw_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); newline; }
#define	msw_trace9(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7,p8); newline; }

#define	msw_lev_trace0(trace_bit,lev,str)		if (msw_cond_lev(trace_bit,lev)) {  fprintf(trace_file, str); newline; }
#define	msw_lev_trace1(trace_bit,lev,str,p0)		if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0);newline; }
#define	msw_lev_trace2(trace_bit,lev,str,p0,p1)		if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1);newline; }
#define	msw_lev_trace3(trace_bit,lev,str,p0,p1,p2)	if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2);newline; }
#define	msw_lev_trace4(trace_bit,lev,str,p0,p1,p2,p3)	if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	msw_lev_trace5(trace_bit,lev,str,p0,p1,p2,p3,p4) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	msw_lev_trace6(trace_bit,lev,str,p0,p1,p2,p3,p4,p5) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	msw_lev_trace7(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	msw_lev_trace8(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); newline; }
#define	msw_lev_trace9(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7,p8); newline; }


/*
** The _no_nl macros also print messages when appropriate, but they do
** not put a new line afterwards.
*/
#define	msw_trace0_no_nl(trace_bit, str)				\
		if (msw_cond(trace_bit)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	msw_trace1_no_nl(trace_bit, str, p0)				\
		if (msw_cond(trace_bit)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	msw_trace2_no_nl(trace_bit, str, p0, p1)			\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}
#define	msw_trace3_no_nl(trace_bit, str, p0, p1, p2)			\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1, p2);		\
			fflush( trace_file );				\
		}
#define	msw_trace4_no_nl(trace_bit, str, p0, p1, p2, p3)		\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1, p2, p3);	\
			fflush( trace_file );				\
		}

#define	msw_lev_trace0_no_nl(trace_bit, lev, str)			\
		if (msw_cond(trace_bit,lev)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	msw_lev_trace1_no_nl(trace_bit, lev, str, p0)			\
		if (msw_cond(trace_bit,lev)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	msw_lev_trace2_no_nl(trace_bit, lev, str, p0, p1)		\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}
#define	msw_lev_trace3_no_nl(trace_bit, lev, str, p0, p1, p2)		\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1, p2);		\
			fflush( trace_file );				\
		}
#define	msw_lev_trace4_no_nl(trace_bit, lev, str, p0, p1, p2, p3)	\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1, p2, p3);	\
			fflush( trace_file );				\
		}

#else   /* !defined(PROD) && !defined(MSWDVR_DEBUG) */

/*
 * PROD or non_MSWDVR-debug flags.
 */
#define	msw_trace_enter(trace_bit,nm)
#define	msw_trace_enter0(trace_bit,nm,str)
#define	msw_trace_enter1(trace_bit,nm,str,p0)
#define	msw_trace_enter2(trace_bit,nm,str,p0,p1)
#define	msw_trace_enter3(trace_bit,nm,str,p0,p1,p2)
#define	msw_trace_enter4(trace_bit,nm,str,p0,p1,p2,p3)
#define	msw_trace_enter5(trace_bit,nm,str,p0,p1,p2,p3,p4)
#define	msw_trace_enter6(trace_bit,nm,str,p0,p1,p2,p3,p4,p5)
#define	msw_trace_enter7(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_trace_enter8(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_trace_enter9(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_trace_enter10(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)
#define	msw_trace_enter11(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)
#define	msw_trace_enter12(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define	msw_trace_leave(trace_bit,nm)
#define	msw_trace_leave0(trace_bit,nm,str)
#define	msw_trace_leave1(trace_bit,nm,str,p0)

#define msw_do_trace(trace_bit,call)
#define msw_do_lev_trace(trace_bit,lev,call)

#define	msw_trace0(trace_bit,str)
#define	msw_trace1(trace_bit,str,p0)
#define	msw_trace2(trace_bit,str,p0,p1)
#define	msw_trace3(trace_bit,str,p0,p1,p2)
#define	msw_trace4(trace_bit,str,p0,p1,p2,p3)
#define	msw_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	msw_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	msw_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_trace9(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_trace0_no_nl(trace_bit,str)
#define	msw_trace1_no_nl(trace_bit,str,p0)
#define	msw_trace2_no_nl(trace_bit,str,p0,p1)
#define	msw_trace3_no_nl(trace_bit,str,p0,p1,p2)
#define	msw_trace4_no_nl(trace_bit,str,p0,p1,p2,p3)
#define	msw_lev_trace0(trace_bit,lev,str)
#define	msw_lev_trace1(trace_bit,lev,str,p0)
#define	msw_lev_trace2(trace_bit,lev,str,p0,p1)
#define	msw_lev_trace3(trace_bit,lev,str,p0,p1,p2)
#define	msw_lev_trace4(trace_bit,lev,str,p0,p1,p2,p3)
#define	msw_lev_trace5(trace_bit,lev,str,p0,p1,p2,p3,p4)
#define	msw_lev_trace6(trace_bit,lev,str,p0,p1,p2,p3,p4,p5)
#define	msw_lev_trace7(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_lev_trace8(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_lev_trace9(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_lev_trace0_no_nl(trace_bit,lev,str)
#define	msw_lev_trace1_no_nl(trace_bit,lev,str,p0)
#define	msw_lev_trace2_no_nl(trace_bit,lev,str,p0,p1)
#define	msw_lev_trace3_no_nl(trace_bit,lev,str,p0,p1,p2)
#define	msw_lev_trace4_no_nl(trace_bit,lev,str,p0,p1,p2,p3)

#endif  /* !defined(PROD) && !defined(MSWDVR_DEBUG) */

#endif	/* MSW_DBG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\mouse_io.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Mouse Driver Definitions
 *
 * Description	: Definitions of constants and structures used in SoftPC's 
 *		  emulation of the Microsoft Mouse Driver
 *
 * Author	: Ross Beresford
 *
 * Notes	: Values were derived from the following sources:
 *		     Microsoft Mouse User's Guide
 *		     IBM PC-XT Technical Reference Manuals
 *		     Microsoft InPort Technical Note
 */
 
/*
 * char SccsID[] = "@(#)mouse_io.h	1.27 12/21/94 Copyright Insignia Solutions Ltd."
 */

/*
 *	CONSTANTS USED IN IO FUNCTION EMULATION
 *	=======================================
 */

/*
 *	function definitions
 */
#define	MOUSE_RESET				0
#define	MOUSE_SHOW_CURSOR			1
#define	MOUSE_HIDE_CURSOR			2
#define	MOUSE_GET_POSITION			3
#define	MOUSE_SET_POSITION			4
#define	MOUSE_GET_PRESS				5
#define	MOUSE_GET_RELEASE			6
#define	MOUSE_SET_RANGE_X			7
#define	MOUSE_SET_RANGE_Y			8
#define	MOUSE_SET_GRAPHICS			9
#define	MOUSE_SET_TEXT				10
#define	MOUSE_READ_MOTION			11
#define	MOUSE_SET_SUBROUTINE			12
#define	MOUSE_LIGHT_PEN_ON			13
#define	MOUSE_LIGHT_PEN_OFF			14
#define	MOUSE_SET_RATIO				15
#define	MOUSE_CONDITIONAL_OFF			16
#define	MOUSE_UNRECOGNISED			17
#define	MOUSE_UNRECOGNISED_2			18
#define	MOUSE_SET_DOUBLE_SPEED			19
#define MOUSE_SWAP_SUBROUTINE			20
#define MOUSE_GET_STATE_SIZE			21
#define MOUSE_SAVE_STATE			22
#define MOUSE_RESTORE_STATE			23
#define MOUSE_SET_ALT_SUBROUTINE		24
#define MOUSE_GET_ALT_SUBROUTINE		25
#define MOUSE_SET_SENSITIVITY			26
#define MOUSE_GET_SENSITIVITY			27
#define MOUSE_SET_INT_RATE			28
#define MOUSE_SET_POINTER_PAGE			29
#define MOUSE_GET_POINTER_PAGE			30
#define MOUSE_DRIVER_DISABLE			31
#define MOUSE_DRIVER_ENABLE			32
#define MOUSE_SOFT_RESET			33
#define MOUSE_SET_LANGUAGE			34
#define MOUSE_GET_LANGUAGE			35
#define MOUSE_GET_INFO				36
#define	MOUSE_GET_DRIVER_INFO			37
#define	MOUSE_GET_MAX_COORDS			38
#define MOUSE_GET_MASKS_AND_MICKEYS		39
#define MOUSE_SET_VIDEO_MODE			40
#define MOUSE_ENUMERATE_VIDEO_MODES		41
#define MOUSE_GET_CURSOR_HOT_SPOT		42
#define MOUSE_LOAD_ACCELERATION_CURVES		43
#define MOUSE_READ_ACCELERATION_CURVES		44
#define MOUSE_SET_GET_ACTIVE_ACCELERATION_CURVE	45
#define MOUSE_MICROSOFT_INTERNAL		46
#define MOUSE_HARDWARE_RESET			47
#define MOUSE_SET_GET_BALLPOINT_INFO		48
#define MOUSE_GET_MIN_MAX_VIRTUAL_COORDS	49
#define MOUSE_GET_ACTIVE_ADVANCED_FUNCTIONS	50
#define MOUSE_GET_SWITCH_SETTINGS		51
#define MOUSE_GET_MOUSE_INI			52

#define	MOUSE_FUNCTION_MAXIMUM		53

#define	mouse_function_in_range(function)	\
	(function >= 0 && function < MOUSE_FUNCTION_MAXIMUM)

#define	MOUSE_SPECIAL_COPYRIGHT		0x4d
#define	MOUSE_SPECIAL_VERSION		0x6d

/*
 *	button definitions
 */
#define	MOUSE_LEFT_BUTTON		0
#define	MOUSE_RIGHT_BUTTON		1
#define	MOUSE_LEFT_BUTTON_DOWN_BIT	(1 << MOUSE_LEFT_BUTTON)
#define MOUSE_RIGHT_BUTTON_DOWN_BIT	(1 << MOUSE_RIGHT_BUTTON)

#define	mouse_button_description(x)	(x ? "DOWN" : "UP")

#define	MOUSE_BUTTON_MAXIMUM		2

#define	mouse_button_in_range(button)	\
	(button >= 0 && button < MOUSE_BUTTON_MAXIMUM)

/*
 *	mickey to pixel ratio definitions
 */
#define	MOUSE_RATIO_X_DEFAULT		8
#define	MOUSE_RATIO_Y_DEFAULT		16
#define	MOUSE_RATIO_SCALE_FACTOR	8

/*
 * The upper limit of this has been commented out, as it is redundant
 * when applied to a signed short.
 */
#define	mouse_ratio_in_range(ratio)	(ratio > 0/* && ratio <= 32767*/)
 
/*
 *	mouse sensitivity definitions
 */
#define MOUSE_SENS_MULT			100
#define MOUSE_SENS_MIN			1
#define MOUSE_SENS_MIN_VAL		(MOUSE_SENS_MULT* 1/32)
#define MOUSE_SENS_DEF			50
#define MOUSE_SENS_DEF_VAL		(MOUSE_SENS_MULT* 1)
#define MOUSE_SENS_MAX			100
#define MOUSE_SENS_MAX_VAL		(MOUSE_SENS_MULT* 14/4)

#define	mouse_sens_in_range(sens)	(sens >= MOUSE_SENS_MIN && sens <= MOUSE_SENS_MAX)

#define MOUSE_DOUBLE_DEF		50

/*
 *	text cursor definitions
 */

#define	MOUSE_TEXT_CURSOR_TYPE_SOFTWARE	0
#define	MOUSE_TEXT_CURSOR_TYPE_HARDWARE	1

#define	MOUSE_TEXT_CURSOR_TYPE_DEFAULT	MOUSE_TEXT_CURSOR_TYPE_SOFTWARE
#define	MOUSE_TEXT_CURSOR_TYPE_MAXIMUM	2

#define	mouse_text_cursor_type_in_range(type)	\
	(type >= 0 && type < MOUSE_TEXT_CURSOR_TYPE_MAXIMUM)

#define	MOUSE_TEXT_SCREEN_MASK_DEFAULT	0xffff
#define	MOUSE_TEXT_CURSOR_MASK_DEFAULT	0x7700

/*
 *	graphics cursor definitions
 */

#define	MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT	-1
#define	MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT	-1
#define	MOUSE_GRAPHICS_CURSOR_WIDTH		16
#define	MOUSE_GRAPHICS_CURSOR_DEPTH		16

#define	MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT	\
{ 0x3fff, 0x1fff, 0x0fff, 0x07ff, \
  0x03ff, 0x01ff, 0x00ff, 0x007f, \
  0x003f, 0x001f, 0x01ff, 0x10ff, \
  0x30ff, 0xf87f, 0xf87f, 0xfc3f }
#define	MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT	\
{ 0x0000, 0x4000, 0x6000, 0x7000, \
  0x7800, 0x7c00, 0x7e00, 0x7f00, \
  0x7f80, 0x7fc0, 0x7c00, 0x4600, \
  0x0600, 0x0300, 0x0300, 0x0000 }

/*
 *	call mask definitions
 */
#define	MOUSE_CALL_MASK_POSITION_BIT		(1 << 0)
#define	MOUSE_CALL_MASK_LEFT_PRESS_BIT		(1 << 1)
#define	MOUSE_CALL_MASK_LEFT_RELEASE_BIT	(1 << 2)
#define	MOUSE_CALL_MASK_RIGHT_PRESS_BIT		(1 << 3)
#define	MOUSE_CALL_MASK_RIGHT_RELEASE_BIT	(1 << 4)
#define MOUSE_CALL_MASK_SHIFT_KEY_BIT		(1 << 5)
#define MOUSE_CALL_MASK_CTRL_KEY_BIT		(1 << 6)
#define MOUSE_CALL_MASK_ALT_KEY_BIT		(1 << 7)
#define	MOUSE_CALL_MASK_SIGNIFICANT_BITS \
	(MOUSE_CALL_MASK_POSITION_BIT	  |	\
	 MOUSE_CALL_MASK_LEFT_PRESS_BIT	  |	\
	 MOUSE_CALL_MASK_LEFT_RELEASE_BIT |	\
	 MOUSE_CALL_MASK_RIGHT_PRESS_BIT  |	\
	 MOUSE_CALL_MASK_RIGHT_RELEASE_BIT)
#define MOUSE_CALL_MASK_KEY_BITS \
	(MOUSE_CALL_MASK_SHIFT_KEY_BIT |	\
	 MOUSE_CALL_MASK_CTRL_KEY_BIT  |	\
	 MOUSE_CALL_MASK_ALT_KEY_BIT)
#define NUMBER_ALT_SUBROUTINES			3


/*
 *	virtual screen definitions
 */
#define	MOUSE_VIRTUAL_SCREEN_ORIGIN_X	0
#define	MOUSE_VIRTUAL_SCREEN_ORIGIN_Y	0
#define	MOUSE_VIRTUAL_SCREEN_WIDTH	640
#define MOUSE_VIRTUAL_SCREEN_DEPTH      200
/* for CGA this is used all the time, for EGA it's replaced by a variable and only used for default initialisations */


/*
 *	double speed definitions
 */
#define	MOUSE_TIMER_INTERRUPTS_PER_SECOND	30
#define	MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT	4
#define	MOUSE_DOUBLE_SPEED_SCALE		2

/*
 *	driver state definitions
 */
#define	MOUSE_CURSOR_DISPLAYED	0
#define	MOUSE_CURSOR_DEFAULT	(MOUSE_CURSOR_DISPLAYED - 1)

#define	MOUSE_UNINSTALLED	0
#define	MOUSE_INSTALLED		(~MOUSE_UNINSTALLED)

#define MOUSE_TYPE_INPORT	3

/*
 *	conditional off area definitions
 */
#define	MOUSE_CONDITIONAL_OFF_MARGIN_X	24
#define	MOUSE_CONDITIONAL_OFF_MARGIN_Y	8

/*
 *	CONSTANTS USED IN BIOS ACCESS
 *	=============================
 */

/*
 *	Video io function numbers
 */
#define	MOUSE_VIDEO_SET_MODE		0
#ifdef V7VGA
#define	MOUSE_V7_VIDEO_SET_MODE		0x6f05
#endif /* V7VGA */
#define	MOUSE_VIDEO_SET_CURSOR		1
#define	MOUSE_VIDEO_READ_LIGHT_PEN	4
#define	MOUSE_VIDEO_WRITE_TELETYPE	14
#define	MOUSE_VIDEO_LOAD_FONT		17

/*
 *	Number of valid video modes
 */

#ifdef EGG
#ifdef VGG
#define	MOUSE_VIDEO_MODE_MAXIMUM	0x14
#else
#define	MOUSE_VIDEO_MODE_MAXIMUM	0x11	
#endif /* VGG */
#else
#define	MOUSE_VIDEO_MODE_MAXIMUM	8	
#endif


/*
 *	Video variable addresses in BIOS data area
 */
#define	MOUSE_VIDEO_CRT_MODE		0x449
#define	MOUSE_VIDEO_CRT_START		0x44e
#define	MOUSE_VIDEO_CARD_BASE		0x463

/*
 *	CONSTANTS USED IN ADAPTER ACCESS
 *	================================
 */

/*
 *	graphics adapter (CGA or MDA) definitions
 */
#define	MOUSE_CURSOR_HIGH_BYTE		0xe
#define	MOUSE_CURSOR_LOW_BYTE		0xf

#define	MOUSE_GRAPHICS_MODE_PITCH	640

/*
 *	InPort (bus mouse) adapter definitions
 */
#define	MOUSE_INPORT_ADDRESS_REG	0x23c
#define	MOUSE_INPORT_DATA_REG		0x23d
#define	MOUSE_INPORT_ID_REG		0x23e
#define	MOUSE_INPORT_TEST_REG		0x23f

#define	MOUSE_INPORT_ADDRESS_RESET_BIT	(1 << 7)

#define	MOUSE_INPORT_ADDRESS_STATUS	0x0
#define	MOUSE_INPORT_ADDRESS_DATA1	0x1
#define	MOUSE_INPORT_ADDRESS_DATA2	0x2
#define	MOUSE_INPORT_ADDRESS_DATA3	0x3
#define	MOUSE_INPORT_ADDRESS_DATA4	0x4
#define	MOUSE_INPORT_ADDRESS_IF_STATUS	0x5
#define	MOUSE_INPORT_ADDRESS_IF_CONTROL	0x6
#define	MOUSE_INPORT_ADDRESS_MODE	0x7

#define	MOUSE_INPORT_MODE_HOLD_BIT	(1 << 5)

#define	MOUSE_INPORT_STATUS_B3_STATUS_BIT	(1 << 0)
#define	MOUSE_INPORT_STATUS_B2_STATUS_BIT	(1 << 1)
#define	MOUSE_INPORT_STATUS_B1_STATUS_BIT	(1 << 2)
#define	MOUSE_INPORT_STATUS_B3_DELTA_BIT	(1 << 3)
#define	MOUSE_INPORT_STATUS_B2_DELTA_BIT	(1 << 4)
#define	MOUSE_INPORT_STATUS_B1_DELTA_BIT	(1 << 5)
#define	MOUSE_INPORT_STATUS_MOVEMENT_BIT	(1 << 6)
#define	MOUSE_INPORT_STATUS_COMPLETE_BIT	(1 << 7)

#define	MOUSE_INPORT_STATUS_B1_TRANSITION_MASK	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | MOUSE_INPORT_STATUS_B1_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B1_UP	\
	(0 | 0)
#define	MOUSE_INPORT_STATUS_B1_PRESSED	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | MOUSE_INPORT_STATUS_B1_DELTA_BIT)
#define	MOUSE_INPORT_STATUS_B1_DOWN	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | 0)
#define	MOUSE_INPORT_STATUS_B1_RELEASED	\
	(0 | MOUSE_INPORT_STATUS_B1_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B3_TRANSITION_MASK	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | MOUSE_INPORT_STATUS_B3_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B3_UP	\
	(0 | 0)
#define	MOUSE_INPORT_STATUS_B3_PRESSED	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | MOUSE_INPORT_STATUS_B3_DELTA_BIT)
#define	MOUSE_INPORT_STATUS_B3_DOWN	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | 0)
#define	MOUSE_INPORT_STATUS_B3_RELEASED	\
	(0 | MOUSE_INPORT_STATUS_B3_DELTA_BIT)

#define	MOUSE_INPORT_ID_SIGNATURE	0xde

#define	MOUSE_INPORT_MODE_VALUE		0x09


/* Conditions to determine if the mouse pointer emulation is enabled */
/*@ACW*/

#define POINTER_EMULATION_OS	 1  /* use O.S. pointer for input   */
#define POINTER_EMULATION_SOFTPC 0  /* use softpc pointer emulation */



/*
 *	DECLARATION OF PUBLIC FUNCTIONS
 *	===============================
 */

/*
 *	NB functions called via BOP instructions are declared in bios.h
 */
extern boolean mouse_tester();

/*
 *	DEFINITION OF OBJECT TYPES USED IN THE EMULATION
 *	================================================
 */

/*
 *	A bit address relative to the start of the CGA regen buffer in 
 *	graphics mode
 */
typedef sys_addr MOUSE_BIT_ADDRESS;

/*
 *	A byte address relative to the start of the CGA regen buffer in 
 *	text or graphics mode
 */
typedef sys_addr MOUSE_BYTE_ADDRESS;

/*
 *	A scalar value
 */
typedef short MOUSE_SCALAR;

/*
 *	A counter value
 */
typedef short MOUSE_COUNT;

/*
 *	A state value
 */
typedef	short MOUSE_STATE;

/*
 *	A speed value in Mickeys per timer interval
 */
typedef	short MOUSE_SPEED;

/*
 *	A user subroutine call mask
 */
typedef	unsigned short MOUSE_CALL_MASK;

/*
 *	A word of screen data
 */

typedef	unsigned short MOUSE_SCREEN_DATA;

/*
 *	32 bits of screen data for graphics mode - 1 byte replicated four times
 */

typedef	IU32 MOUSE_SCREEN_DATA_GR;

/*
 *	A vector
 */
typedef struct
{
	MOUSE_SCALAR 		x;
	MOUSE_SCALAR 		y;
} MOUSE_VECTOR;

/*
 *	A virtual screen position
 */
typedef struct
{
	MOUSE_SCALAR 		x;
	MOUSE_SCALAR 		y;
} MOUSE_POINT;

/*
 *	A virtual screen area
 */
typedef struct
{
	MOUSE_POINT 		top_left;
	MOUSE_POINT 		bottom_right;
} MOUSE_AREA;

/*
 *	A cursor status frame
 */
typedef struct
{
	MOUSE_POINT 		position;
	MOUSE_STATE 		button_status;
} MOUSE_CURSOR_STATUS;

/*
 *	A button status frame
 */
typedef struct
{
	MOUSE_POINT 		press_position;
	MOUSE_POINT 		release_position;
	MOUSE_COUNT 		press_count;
	MOUSE_COUNT 		release_count;
} MOUSE_BUTTON_STATUS;

/*
 *	A text cursor
 */
typedef struct
{
	MOUSE_SCREEN_DATA 	screen;
	MOUSE_SCREEN_DATA 	cursor;
} MOUSE_SOFTWARE_TEXT_CURSOR;

/*
 *	A graphics cursor
 */
typedef struct
{
	MOUSE_POINT 			hot_spot;
	MOUSE_VECTOR 			size;
	MOUSE_SCREEN_DATA			screen[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA 		cursor[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		screen_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		screen_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		cursor_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		cursor_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
} MOUSE_GRAPHICS_CURSOR;

/*
 *	An InPort data frame
 */
typedef struct
{
	half_word		status;
	signed_char		data_x;
	signed_char		data_y;
} MOUSE_INPORT_DATA;

/*
 *	DEFINITION OF METHODS THAT MAY BE APPLIED TO THE OBJECT TYPES
 *	=============================================================
 */

/*
 *	MOUSE_POINT methods
 */

/*
 *	Coerce the point object "*point_ptr" to lie within the
 *	area object "*area_ptr"
 */
#define	point_coerce_to_area(point_ptr, area_ptr)		\
{								\
	if ((point_ptr)->x < (area_ptr)->top_left.x)		\
		(point_ptr)->x = (area_ptr)->top_left.x;	\
	else if ((point_ptr)->x > (area_ptr)->bottom_right.x)	\
		(point_ptr)->x = (area_ptr)->bottom_right.x;\
								\
	if ((point_ptr)->y < (area_ptr)->top_left.y)		\
		(point_ptr)->y = (area_ptr)->top_left.y;	\
	else if ((point_ptr)->y > (area_ptr)->bottom_right.y)	\
		(point_ptr)->y = (area_ptr)->bottom_right.y;\
}

/*
 *	Coerce the point object "*point_ptr" to lie on the grid
 *	defined by the vector object "*grid_ptr"
 */
#define point_coerce_to_grid(point_ptr, grid_ptr)		\
{								\
	(point_ptr)->x -= (point_ptr)->x % (grid_ptr)->x;	\
	(point_ptr)->y -= (point_ptr)->y % (grid_ptr)->y;	\
}

/*
 *	Copy "*source_ptr" to "*destination_ptr"
 */
#define	point_copy(source_ptr, destination_ptr)			\
{								\
	(destination_ptr)->x = (source_ptr)->x;			\
	(destination_ptr)->y = (source_ptr)->y;			\
}

/*
 *	Move "*point_ptr" by "*offset_ptr"
 */
#define point_translate(point_ptr, offset_ptr)			\
{								\
	(point_ptr)->x += (offset_ptr)->x;			\
	(point_ptr)->y += (offset_ptr)->y;			\
}

/*
 *	Move "*point_ptr" back by "*offset_ptr"
 */
#define point_translate_back(point_ptr, offset_ptr)		\
{								\
	(point_ptr)->x -= (offset_ptr)->x;			\
	(point_ptr)->y -= (offset_ptr)->y;			\
}

/*
 *	Set "*point_ptr" from the "x_value" and "y_value"
 */
#define	point_set(point_ptr, x_value, y_value)			\
{								\
	(point_ptr)->x = x_value;				\
	(point_ptr)->y = y_value;				\
}



/*
 *	MOUSE_AREA methods
 */

/*
 *	Transform the area "*source_ptr" so that the top left point
 *	really does lie above and to the left of the bottom right
 *	point
 */
#define	area_normalise(area_ptr)				\
{								\
	MOUSE_SCALAR temp;					\
								\
	if ((area_ptr)->top_left.x > (area_ptr)->bottom_right.x)\
	{							\
		temp = (area_ptr)->top_left.x;			\
		(area_ptr)->top_left.x = (area_ptr)->bottom_right.x;\
		(area_ptr)->bottom_right.x = temp;		\
	}							\
								\
	if ((area_ptr)->top_left.y > (area_ptr)->bottom_right.y)\
	{							\
		temp = (area_ptr)->top_left.y;			\
		(area_ptr)->top_left.y = (area_ptr)->bottom_right.y;\
		(area_ptr)->bottom_right.y = temp;		\
	}							\
}

/*
 *	Copy "*source_ptr" to "*desination_ptr"
 */
#define	area_copy(source_ptr, destination_ptr) 			\
	memcpy(destination_ptr,source_ptr, sizeof(MOUSE_AREA))

/*
 *	Answer whether "*area1_ptr" intersects "*area2_ptr"
 */
#define area_is_intersected_by_area(area1_ptr, area2_ptr)	\
(    ((area1_ptr)->bottom_right.x > (area2_ptr)->top_left.x)	\
  && ((area1_ptr)->bottom_right.y > (area2_ptr)->top_left.y)	\
  && ((area1_ptr)->top_left.x < (area2_ptr)->bottom_right.x)	\
  && ((area1_ptr)->top_left.y < (area2_ptr)->bottom_right.y))

/*
 *	Clip "*area1_ptr" so that it lies fully within "*area2_ptr"
 */
#define area_coerce_to_area(area1_ptr, area2_ptr)			\
{									\
	if ((area1_ptr)->top_left.x < (area2_ptr)->top_left.x)		\
		(area1_ptr)->top_left.x = (area2_ptr)->top_left.x;	\
	else if ((area1_ptr)->top_left.x > (area2_ptr)->bottom_right.x)	\
		(area1_ptr)->top_left.x = (area2_ptr)->bottom_right.x;	\
									\
	if ((area1_ptr)->bottom_right.x < (area2_ptr)->top_left.x)	\
		(area1_ptr)->bottom_right.x = (area2_ptr)->top_left.x;	\
	else if ((area1_ptr)->bottom_right.x > (area2_ptr)->bottom_right.x)\
		(area1_ptr)->bottom_right.x = (area2_ptr)->bottom_right.x;\
									\
	if ((area1_ptr)->top_left.y < (area2_ptr)->top_left.y)		\
		(area1_ptr)->top_left.y = (area2_ptr)->top_left.y;	\
	else if ((area1_ptr)->top_left.y > (area2_ptr)->bottom_right.y)	\
		(area1_ptr)->top_left.y = (area2_ptr)->bottom_right.y;	\
									\
	if ((area1_ptr)->bottom_right.y < (area2_ptr)->top_left.y)	\
		(area1_ptr)->bottom_right.y = (area2_ptr)->top_left.y;	\
	else if ((area1_ptr)->bottom_right.y > (area2_ptr)->bottom_right.y)\
		(area1_ptr)->bottom_right.y = (area2_ptr)->bottom_right.y;\
}

/*
 *	Return the width of "*area_ptr"
 */
#define area_width(area_ptr)					\
((area_ptr)->bottom_right.x - (area_ptr)->top_left.x)

/*
 *	Return the depth of "*area_ptr"
 */
#define	area_depth(area_ptr)					\
((area_ptr)->bottom_right.y - (area_ptr)->top_left.y)




/*
 *	MOUSE_VECTOR methods
 */

/*
 *	Multiply "*vector1_ptr" by "*vector2_ptr"
 */
#define vector_multiply_by_vector(vector1_ptr, vector2_ptr)	\
{								\
	(vector1_ptr)->x *= (vector2_ptr)->x;			\
	(vector1_ptr)->y *= (vector2_ptr)->y;			\
}

/*
 *	Divide "*vector1_ptr" by "*vector2_ptr"
 */
#define vector_divide_by_vector(vector1_ptr, vector2_ptr)	\
{								\
	(vector1_ptr)->x /= (vector2_ptr)->x;			\
	(vector1_ptr)->y /= (vector2_ptr)->y;			\
}

/*
 *	Make "*vector1_ptr" the modulus of the division of "*vector1_ptr" 
 *	by "*vector2_ptr"
 */
#define vector_mod_by_vector(vector1_ptr, vector2_ptr)		\
{								\
	(vector1_ptr)->x %= (vector2_ptr)->x;			\
	(vector1_ptr)->y %= (vector2_ptr)->y;			\
}

/*
 *	Scale "*vector_ptr" by scale factor "scale"
 */
#define vector_scale(vector_ptr, scale)				\
{								\
	(vector_ptr)->x *= scale;				\
	(vector_ptr)->y *= scale;				\
}

/*
 *	Set "*vector_ptr" from the "x_value" and "y_value"
 */
#define	vector_set(vector_ptr, x_value, y_value)		\
{								\
	(vector_ptr)->x = x_value;				\
	(vector_ptr)->y = y_value;				\
}




/*
 *	MOUSE_SCALAR methods
 */

#define scalar_absolute(x) ((x) >= 0 ? (x) : -(x))




/*
 *	MOUSE_SOFTWARE_TEXT_CURSOR and MOUSE_GRAPHICS_CURSOR methods
 */

#define	software_text_cursor_copy(source_ptr, destination_ptr)	\
{								\
	(destination_ptr)->screen = (source_ptr)->screen;	\
	(destination_ptr)->cursor = (source_ptr)->cursor;	\
}

#define	graphics_cursor_copy(source_ptr, destination_ptr)	\
	memcpy(destination_ptr,source_ptr, sizeof(MOUSE_GRAPHICS_CURSOR))
	
#define SHIFT_VAL	((IU32)0xff0000ff)

/*
 * Not all platforms support cursor larger than 16 x 16. Some do, some don't.
 * We keep a list of vendors with the boolean cursor_is_big set to TRUE if
 * 32 x 32 cursors are supported.
 */

struct VENDOR_INFO
{
	char	*vendor_name;
	boolean	cursor_is_big;
};

	/* used to determine whether adapter is in text or graphics mode, by peeping at the BIOS mode variable */
#define	in_text_mode()	(sas_hw_at_no_check(vd_video_mode) < 4 || sas_hw_at_no_check(vd_video_mode) == 7)

typedef struct
{
	void (*restore_cursor) IPT0();
	void (*deinstall) IPT0();
	BOOL (*installed) IPT0();
	BOOL (*in_use) IPT0();
	void (*reset) IPT0();
	void (*set_position) IPT2(USHORT,newx, USHORT,newy);
	void (*set_graphics) IPT3(MOUSE_SCALAR *,xptr,MOUSE_SCALAR *,yptr,word *,ba);
	void (*cursor_display) IPT0();
	void (*cursor_undisplay) IPT0();
	void (*cursor_mode_change) IPT0();
} HOSTMOUSEFUNCS;

#if defined(HOST_MOUSE) || defined(NTVDM)

IMPORT HOSTMOUSEFUNCS	*working_mouse_funcs;

#define host_mouse_restore_cursor()\
	(working_mouse_funcs->restore_cursor)()

#define host_deinstall_host_mouse()\
	(working_mouse_funcs->deinstall)()

#define host_mouse_installed()\
	(working_mouse_funcs->installed)()

#define host_mouse_in_use()\
	(working_mouse_funcs->in_use)()

#define host_mouse_reset()\
	(working_mouse_funcs->reset)()

#define host_mouse_set_position(x,y)\
	(working_mouse_funcs->set_position)(x,y)

#define host_mouse_set_graphics(x,y,z)\
	(working_mouse_funcs->set_graphics)(x,y,z)

#define host_mouse_cursor_display()\
	(working_mouse_funcs->cursor_display)()

#define host_mouse_cursor_undisplay()\
	(working_mouse_funcs->cursor_undisplay)()

#define host_mouse_cursor_mode_change()\
	(working_mouse_funcs->cursor_mode_change)()
	
#else	/* HOST_MOUSE */

#define host_mouse_restore_cursor()

#define host_deinstall_host_mouse()

#define host_mouse_installed()	FALSE

#define host_mouse_in_use()	FALSE

#define host_mouse_reset()

#define host_mouse_set_position(x,y)

#define host_mouse_set_graphics(x,y,z)

#define host_mouse_cursor_display()

#define host_mouse_cursor_undisplay()

#define host_mouse_cursor_mode_change()
	
#endif	/* HOST_MOUSE */

#ifdef NTVDM
VOID host_enable_delta_motion IPT0();
VOID host_disable_delta_motion IPT0();
#ifdef X86GFX
extern  void host_mouse_conditional_off_enabled(void);
#else
extern  void mouse_video_mode_changed(int new_mode);
#endif

#endif	/* NTVDM */


/*
   Define (if not already defined EGA register sizes). Unfortunately
   a wide range of files include this file and historically it has
   just become a large unstructured lump of definitions. Given many
   users don't need the following Instance Variable Definitions, avoid
   making all these files include egavideo.h by copying the relevant
   definitions here.
 */

#ifndef EGA_PARMS_SEQ_SIZE
#define EGA_PARMS_SEQ_SIZE 4
#endif

#ifndef EGA_PARMS_CRTC_SIZE
#define EGA_PARMS_CRTC_SIZE 25
#endif

#ifndef EGA_PARMS_ATTR_SIZE
#define EGA_PARMS_ATTR_SIZE 20
#endif

#ifndef EGA_PARMS_GRAPH_SIZE
#define EGA_PARMS_GRAPH_SIZE 9
#endif


/*
   Structure to represent the acceleration data.
 */
#define NR_ACCL_CURVES		4
#define NR_ACCL_MICKEY_COUNTS	32
#define NR_ACCL_SCALE_FACTORS	32
#define NR_ACCL_NAME_CHARS	16
typedef struct
  {
  half_word ac_length[NR_ACCL_CURVES];
  half_word ac_count[NR_ACCL_CURVES][NR_ACCL_MICKEY_COUNTS];
  half_word ac_scale[NR_ACCL_CURVES][NR_ACCL_SCALE_FACTORS];
  half_word ac_name[NR_ACCL_CURVES][NR_ACCL_NAME_CHARS];
  } ACCELERATION_CURVE_DATA;

/*
   Structure which represents the saved mouse state (context) for DOS
   programs.

   button_transitions - For functions 5 & 6.
   mouse_gear - Mickey to Pixel Ratio Declarations. NB all mouse gears are
		scaled by MOUSE_RATIO_SCALE_FACTOR.
   mouse_sens - Sensitivity. NB Sensitivity is multiplied in BEFORE Mickey to
		Pixels ratios.
   text_cursor_type - This is either HARDWARE or SOFTWARE.
   black_hole - Conditional off area.
   cursor_flag - Internal cursor flag.
   cursor_status - Cursor button status and virtual screen position.
   cursor_window - Virtual screen window constraining the cursor.
   light_pen_mode - Light pen emulation mode.
   mouse_motion - Accumulated Mickey counts for function 11.
   mouse_raw_motion - Accumulated raw Mickey counts for func 39.
   cursor_position, cursor_fractional_position - Integral and fractional parts
						 of raw cursor position.
   cursor_page - Video page mouse pointer is currently on.
   active_acceleration_curve - Currently active acceleration curve. In
			       range 1-4.
   acceleration_curve_data - The acceleration curve data.
   next_video_mode - Tracks enumerated video modes for func 41.
 */
typedef struct
   {
   MOUSE_BUTTON_STATUS MC_button_transitions[MOUSE_BUTTON_MAXIMUM];
   MOUSE_VECTOR        MC_mouse_gear;
   MOUSE_VECTOR        MC_mouse_sens;
   MOUSE_VECTOR        MC_mouse_sens_val;
   word                MC_mouse_double_thresh;
   MOUSE_STATE         MC_text_cursor_type;
   MOUSE_SOFTWARE_TEXT_CURSOR MC_software_text_cursor;
   MOUSE_GRAPHICS_CURSOR      MC_graphics_cursor;
   word                MC_user_subroutine_segment;
   word                MC_user_subroutine_offset;
   MOUSE_CALL_MASK     MC_user_subroutine_call_mask;
   boolean             MC_alt_user_subroutines_active;
   word                MC_alt_user_subroutine_segment[NUMBER_ALT_SUBROUTINES];
   word                MC_alt_user_subroutine_offset[NUMBER_ALT_SUBROUTINES];
   MOUSE_CALL_MASK     MC_alt_user_subroutine_call_mask[NUMBER_ALT_SUBROUTINES];
   MOUSE_AREA          MC_black_hole;
   MOUSE_SPEED         MC_double_speed_threshold;
   int                 MC_cursor_flag;
   MOUSE_CURSOR_STATUS MC_cursor_status;
   MOUSE_AREA          MC_cursor_window;
   boolean             MC_light_pen_mode;
   MOUSE_VECTOR        MC_mouse_motion;
   MOUSE_VECTOR        MC_mouse_raw_motion;
   MOUSE_POINT         MC_cursor_position_default;
   MOUSE_POINT         MC_cursor_position;
   MOUSE_POINT         MC_cursor_fractional_position;
   int                 MC_cursor_page;
   int		       MC_active_acceleration_curve;
   ACCELERATION_CURVE_DATA   MC_acceleration_curve_data;
   int                 MC_next_video_mode;
   } MOUSE_CONTEXT;

/*
   Instance Variables for Mickey Mouse (MM) Driver, ie those variables which
   must be set up for each Virtual Machine under Windows 3.x. The NIDDB Manager
   (cf virtual.c) basically forces us to define these in one memory area.

   text_cursor_background - Area from which background can be restored.
   graphics_cursor_background - Area from which background can be restored.
   save_area - Actual area of screen covered by graphics cursor.
   black_hole_default - Conditional off area.
   ega_default_crtc  - Pointers to default EGA register values.
   ega_default_seq   - 
   ega_default_graph - 
   ega_default_attr  - 
   ega_default_misc  - 
   ega_current_crtc  - Current EGA register state, according to mouse driver.
   ega_current_graph - 
   ega_current_seq   - 
   ega_current_attr  - 
   ega_current_misc  - 
   cursor_EM_disabled - Indicates cursor should be disabled inside a
			windowed Enhanced Mode DOS box. This overrides
			the cursor_flag variable.
 */
typedef struct
   {
   MOUSE_CONTEXT     MM_IN_mouse_context;
   USHORT            MM_IN_mouse_driver_disabled;
   SHORT             MM_IN_current_video_mode;
   MOUSE_SCREEN_DATA MM_IN_text_cursor_background;
   MOUSE_SCREEN_DATA MM_IN_graphics_cursor_background[MOUSE_GRAPHICS_CURSOR_DEPTH];
   boolean           MM_IN_save_area_in_use;
   MOUSE_POINT       MM_IN_save_position;
   MOUSE_AREA        MM_IN_save_area;
   boolean           MM_IN_user_subroutine_critical;
   MOUSE_CALL_MASK   MM_IN_last_condition_mask;
   word              MM_IN_saved_AX;
   word              MM_IN_saved_BX;
   word              MM_IN_saved_CX;
   word              MM_IN_saved_DX;
   word              MM_IN_saved_SI;
   word              MM_IN_saved_DI;
   word              MM_IN_saved_ES;
   word              MM_IN_saved_BP;
   word              MM_IN_saved_DS;
   MOUSE_AREA        MM_IN_virtual_screen;
   MOUSE_VECTOR      MM_IN_cursor_grid;
   MOUSE_VECTOR      MM_IN_text_grid;
   MOUSE_AREA        MM_IN_black_hole_default;
   word              MM_IN_saved_int33_segment;
   word              MM_IN_saved_int33_offset;
   word              MM_IN_saved_int10_segment;
   word              MM_IN_saved_int10_offset;
   word              MM_IN_saved_int0A_segment;
   word              MM_IN_saved_int0A_offset;
   IBOOL             MM_IN_int10_chained;

#ifdef	MOUSE_16_BIT
   IBOOL             MM_IN_is_graphics_mode;
#endif	/* MOUSE_16_BIT */ 

#ifdef EGG
#ifndef REAL_VGA
#ifdef VGG
   UTINY             MM_IN_vga_background
			[MOUSE_GRAPHICS_CURSOR_DEPTH][MOUSE_GRAPHICS_CURSOR_WIDTH];
#endif /* VGG */

   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_mid[MOUSE_GRAPHICS_CURSOR_DEPTH];
   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
#endif /* nREAL_VGA */

   sys_addr          MM_IN_ega_default_crtc;
   sys_addr          MM_IN_ega_default_seq;
   sys_addr          MM_IN_ega_default_graph;
   sys_addr          MM_IN_ega_default_attr;
   sys_addr          MM_IN_ega_default_misc;
   half_word         MM_IN_ega_current_crtc[EGA_PARMS_CRTC_SIZE];
   half_word         MM_IN_ega_current_graph[EGA_PARMS_GRAPH_SIZE];
   half_word         MM_IN_ega_current_seq[EGA_PARMS_SEQ_SIZE];
   half_word         MM_IN_ega_current_attr[EGA_PARMS_ATTR_SIZE];
   half_word         MM_IN_ega_current_misc;
#endif /* EGG */

#ifdef HERC
   MOUSE_AREA        MM_IN_HERC_graphics_virtual_screen;
#endif /* HERC */
   boolean           MM_IN_cursor_EM_disabled;
   } MM_INSTANCE_DATA, **MM_INSTANCE_DATA_HANDLE;

/*
   Define access to instance variables via handle.
 */

IMPORT MM_INSTANCE_DATA_HANDLE mm_handle;

#define button_transitions \
   ((*mm_handle)->MM_IN_mouse_context.MC_button_transitions)
#define mouse_gear \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_gear)
#define mouse_sens \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_sens)
#define mouse_sens_val \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_sens_val)
#define mouse_double_thresh \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_double_thresh)
#define text_cursor_type \
   ((*mm_handle)->MM_IN_mouse_context.MC_text_cursor_type)
#define software_text_cursor \
   ((*mm_handle)->MM_IN_mouse_context.MC_software_text_cursor)
#define graphics_cursor \
   ((*mm_handle)->MM_IN_mouse_context.MC_graphics_cursor)
#define user_subroutine_segment \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_segment)
#define user_subroutine_offset \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_offset)
#define user_subroutine_call_mask \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_call_mask)
#define alt_user_subroutines_active \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutines_active)
#define alt_user_subroutine_segment \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_segment)
#define alt_user_subroutine_offset \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_offset)
#define alt_user_subroutine_call_mask \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_call_mask)
#define black_hole \
   ((*mm_handle)->MM_IN_mouse_context.MC_black_hole)
#define double_speed_threshold \
   ((*mm_handle)->MM_IN_mouse_context.MC_double_speed_threshold)
#define cursor_flag \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_flag)
#define cursor_status \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_status)
#define cursor_window \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_window)
#define light_pen_mode \
   ((*mm_handle)->MM_IN_mouse_context.MC_light_pen_mode)
#define mouse_motion \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_motion)
#define mouse_raw_motion \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_raw_motion)
#define cursor_position_default \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_position_default)
#define cursor_position \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_position)
#define cursor_fractional_position \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_fractional_position)
#define cursor_page \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_page)
#define active_acceleration_curve \
   ((*mm_handle)->MM_IN_mouse_context.MC_active_acceleration_curve)
#define acceleration_curve_data \
   ((*mm_handle)->MM_IN_mouse_context.MC_acceleration_curve_data)
#define next_video_mode \
   ((*mm_handle)->MM_IN_mouse_context.MC_next_video_mode)

#define mouse_context              ((*mm_handle)->MM_IN_mouse_context)
#define mouse_driver_disabled      ((*mm_handle)->MM_IN_mouse_driver_disabled)
#define current_video_mode         ((*mm_handle)->MM_IN_current_video_mode)
#define text_cursor_background     ((*mm_handle)->MM_IN_text_cursor_background)
#define graphics_cursor_background ((*mm_handle)->MM_IN_graphics_cursor_background)
#define save_area_in_use           ((*mm_handle)->MM_IN_save_area_in_use)
#define save_position              ((*mm_handle)->MM_IN_save_position)
#define save_area                  ((*mm_handle)->MM_IN_save_area)
#define user_subroutine_critical   ((*mm_handle)->MM_IN_user_subroutine_critical)
#define last_condition_mask        ((*mm_handle)->MM_IN_last_condition_mask)
#define saved_AX                   ((*mm_handle)->MM_IN_saved_AX)
#define saved_BX                   ((*mm_handle)->MM_IN_saved_BX)
#define saved_CX                   ((*mm_handle)->MM_IN_saved_CX)
#define saved_DX                   ((*mm_handle)->MM_IN_saved_DX)
#define saved_SI                   ((*mm_handle)->MM_IN_saved_SI)
#define saved_DI                   ((*mm_handle)->MM_IN_saved_DI)
#define saved_ES                   ((*mm_handle)->MM_IN_saved_ES)
#define saved_BP                   ((*mm_handle)->MM_IN_saved_BP)
#define saved_DS                   ((*mm_handle)->MM_IN_saved_DS)
#define virtual_screen             ((*mm_handle)->MM_IN_virtual_screen)
#define cursor_grid                ((*mm_handle)->MM_IN_cursor_grid)
#define text_grid                  ((*mm_handle)->MM_IN_text_grid)
#define black_hole_default         ((*mm_handle)->MM_IN_black_hole_default)
#define saved_int33_segment        ((*mm_handle)->MM_IN_saved_int33_segment)
#define saved_int33_offset         ((*mm_handle)->MM_IN_saved_int33_offset)
#define saved_int10_segment        ((*mm_handle)->MM_IN_saved_int10_segment)
#define saved_int10_offset         ((*mm_handle)->MM_IN_saved_int10_offset)
#define saved_int0A_segment        ((*mm_handle)->MM_IN_saved_int0A_segment)
#define saved_int0A_offset         ((*mm_handle)->MM_IN_saved_int0A_offset)
#define int10_chained              ((*mm_handle)->MM_IN_int10_chained)

#ifdef	MOUSE_16_BIT
#define is_graphics_mode           ((*mm_handle)->MM_IN_is_graphics_mode)
#endif	/* MOUSE_16_BIT */ 

#ifdef EGG
#ifndef REAL_VGA
#ifdef VGG
#define vga_background             ((*mm_handle)->MM_IN_vga_background)
#endif /* VGG */

#define ega_backgrnd_lo            ((*mm_handle)->MM_IN_ega_backgrnd_lo)
#define ega_backgrnd_mid           ((*mm_handle)->MM_IN_ega_backgrnd_mid)
#define ega_backgrnd_hi            ((*mm_handle)->MM_IN_ega_backgrnd_hi)
#endif /* nREAL_VGA */

#define ega_default_crtc           ((*mm_handle)->MM_IN_ega_default_crtc)
#define ega_default_seq            ((*mm_handle)->MM_IN_ega_default_seq)
#define ega_default_graph          ((*mm_handle)->MM_IN_ega_default_graph)
#define ega_default_attr           ((*mm_handle)->MM_IN_ega_default_attr)
#define ega_default_misc           ((*mm_handle)->MM_IN_ega_default_misc)
#define ega_current_crtc           ((*mm_handle)->MM_IN_ega_current_crtc)
#define ega_current_graph          ((*mm_handle)->MM_IN_ega_current_graph)
#define ega_current_seq            ((*mm_handle)->MM_IN_ega_current_seq)
#define ega_current_attr           ((*mm_handle)->MM_IN_ega_current_attr)
#define ega_current_misc           ((*mm_handle)->MM_IN_ega_current_misc)
#endif /* EGG */

#ifdef HERC
#define HERC_graphics_virtual_screen ((*mm_handle)->MM_IN_HERC_graphics_virtual_screen)
#endif /* HERC */

#define cursor_EM_disabled         ((*mm_handle)->MM_IN_cursor_EM_disabled)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\msw_keyb.h ===
/*[
 *
 * SoftPC-AT revision 3.0
 *
 * Title        : Definitions for MS-Windows keyboard driver functions.
 *
 * Description  : This file contains the definitions for msw_keybd.c.
 *
 * Author       : Jerry Sexton
 *
 * Notes        :
 *
]*/

/* SccsID[]="@(#)msw_keybd.h	1.2 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
=========================================================================
 Macros.
=========================================================================
 */

/* Null pointers. */
#define TINY_NULL	((TINY *) 0)

/* General definitions. */
#define NO_NUMLOCK	0
#define NUMLOCK		1

/* Virtual keys. */

#define VK_LBUTTON	0x01
#define VK_RBUTTON	0x02
#define VK_CANCEL	0x03

/* 4..7 undefined */

#define VK_BACK		0x08
#define VK_TAB		0x09

/* 0x0a .. 0x0b undefined */

#define VK_CLEAR	0x0c
#define VK_RETURN	0x0d

#define VK_SHIFT	0x10
#define VK_CONTROL	0x11
#define VK_MENU		0x12
#define VK_PAUSE	0x13
#define VK_CAPITAL	0x14
		/* 0x15..0x1a */
#define VK_ESCAPE	0x1b
		/* 0x1c..0x1f */
#define VK_SPACE	0x20
#define VK_PRIOR	0x21	/* page up */
#define VK_NEXT		0x22	/* page down */
#define VK_END		0x23
#define VK_HOME		0x24
#define VK_LEFT		0x25
#define VK_UP		0x26
#define VK_RIGHT	0x27
#define VK_DOWN		0x28
#define VK_SELECT	0x29
#define VK_PRINT	0x2a
#define VK_EXECUTE	0x2b
#define VK_SNAPSHOT	0x2c	/* Printscreen key.. */

#define VK_INSERT	0x2d
#define VK_DELETE	0x2e
#define VK_HELP		0x2f
#define VK_0		0x30
#define VK_1		0x31
#define VK_2		0x32
#define VK_3		0x33
#define VK_4		0x34
#define VK_5		0x35
#define VK_6		0x36
#define VK_7		0x37
#define VK_8		0x38
#define VK_9		0x39
		/* 0x40 */
#define VK_A		0x41
#define VK_B		0x42
#define VK_C		0x43
#define VK_D		0x44
#define VK_E		0x45
#define VK_F		0x46
#define VK_G		0x47
#define VK_H		0x48
#define VK_I		0x49
#define VK_J		0x4a
#define VK_K		0x4b
#define VK_L		0x4c
#define VK_M		0x4d
#define VK_N		0x4e
#define VK_O		0x4f
#define VK_P		0x50
#define VK_Q		0x51
#define VK_R		0x52
#define VK_S		0x53
#define VK_T		0x54
#define VK_U		0x55
#define VK_V		0x56
#define VK_W		0x57
#define VK_X		0x58
#define VK_Y		0x59
#define VK_Z		0x5a
		/* 0x5b..0x5f */
#define VK_NUMPAD0	0x60
#define VK_NUMPAD1	0x61
#define VK_NUMPAD2	0x62
#define VK_NUMPAD3	0x63
#define VK_NUMPAD4	0x64
#define VK_NUMPAD5	0x65
#define VK_NUMPAD6	0x66
#define VK_NUMPAD7	0x67
#define VK_NUMPAD8	0x68
#define VK_NUMPAD9	0x69
#define VK_MULTIPLY	0x6a
#define VK_ADD		0x6b
#define VK_SEPARATER	0x6c
#define VK_SUBTRACT	0x6d
#define VK_DECIMAL	0x6e
#define VK_DIVIDE	0x6f

#define VK_F1		0x70
#define VK_F2		0x71
#define VK_F3		0x72
#define VK_F4		0x73
#define VK_F5		0x74
#define VK_F6		0x75
#define VK_F7		0x76
#define VK_F8		0x77
#define VK_F9		0x78
#define VK_F10		0x79
#define VK_F11		0x7a
#define VK_F12		0x7b
#define VK_F13		0x7c
#define VK_F14		0x7d
#define VK_F15		0x7e
#define VK_F16		0x7f

#define VK_OEM_F17	0x80
#define VK_OEM_F18	0x81
#define VK_OEM_F19	0x82
#define VK_OEM_F20	0x83
#define VK_OEM_F21	0x84
#define VK_OEM_F22	0x85
#define VK_OEM_F23	0x86
#define VK_OEM_F24	0x87

/* 0x88..0x8f unassigned */

#define VK_NUMLOCK	0x90
#define VK_OEM_SCROLL	0x91		/* ScrollLock */

/* 0x92..0xb9 unassigned */

#define VK_OEM_1	0xba		/* ';:' for US */
#define VK_OEM_PLUS	0xbb		/* '+' any country */
#define VK_OEM_COMMA	0xbc		/* ',' any country */
#define VK_OEM_MINUS	0xbd		/* '-' any country */
#define VK_OEM_PERIOD	0xbe		/* '.' any country */
#define VK_OEM_2	0xbf		/* '/?' for US */
#define VK_OEM_3	0xc0		/* '`~' for US */

/* 0xc1..0xda unassigned */

#define VK_OEM_4	0xdb		/* '[{' for US */
#define VK_OEM_5	0xdc		/* '\|' for US */
#define VK_OEM_6	0xdd		/* ']}' for US */
#define VK_OEM_7	0xde		/* ''"' for US */
#define VK_OEM_8	0xdf

/* codes various extended or enhanced keyboards */
#define VK_F17		0xe0		/* F17 key on ICO, win 2.xx */
#define VK_F18		0xe1		/* F18 key on ICO, win 2.xx */

#define VK_OEM_102	0xe2		/* "<>" or "\|" on RT 102-key kbd. */

#define VK_ICO_HELP	0xe3		/* Help key on ICO */
#define VK_ICO_00	0xe4		/* 00 key on ICO */

/* E5h unassigned */

#define VK_ICO_CLEAR	0xe6 */

/* E7h .. E8h unassigned */

/*	Nokia/Ericsson definitions */

#define VK_ERICSSON_BASE 0xe8

#define VK_OEM_RESET	(VK_ERICSSON_BASE + 1)	/* e9 */
#define VK_OEM_JUMP	(VK_ERICSSON_BASE + 2)	/* ea */
#define VK_OEM_PA1	(VK_ERICSSON_BASE + 3)	/* eb */
#define VK_OEM_PA2	(VK_ERICSSON_BASE + 4)	/* ec */
#define VK_OEM_PA3	(VK_ERICSSON_BASE + 5)	/* ed */
#define VK_OEM_WSCTRL	(VK_ERICSSON_BASE + 6)	/* ee */
#define VK_OEM_CUSEL	(VK_ERICSSON_BASE + 7)	/* ef */
#define VK_OEM_ATTN	(VK_ERICSSON_BASE + 8)	/* f0 */
#define VK_OEM_FINNISH	(VK_ERICSSON_BASE + 9)	/* f1 */
#define VK_OEM_COPY	(VK_ERICSSON_BASE + 10)	/* f2 */
#define VK_OEM_AUTO	(VK_ERICSSON_BASE + 11)	/* f3 */
#define VK_OEM_ENLW	(VK_ERICSSON_BASE + 12)	/* f4 */
#define VK_OEM_BACKTAB	(VK_ERICSSON_BASE + 13)	/* f5 */


/* F6h..FEh unassigned. */

/* Defines for inquireData structure. */
#define BEGINRANGE1		255
#define ENDRANGE1		254
#define BEGINRANGE2		255
#define ENDRANGE2		254
#define TO_ASCII_STATE_SIZE	4

/*
=========================================================================
 Keyboard driver structure definitions.
=========================================================================
 */
typedef struct tagKBINFO
{
	UTINY	 Begin_First_Range;
	UTINY	 End_First_Range;
	UTINY	 Begin_Second_Range;
	UTINY	 End_Second_Range;
	SHORT	 StateSize;		/* size of ToAscii state block. */
} KBINFO;

#define INTEL_KBINFO_SIZE	6	/* Size of KBINFO structure in INTEL. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\m_errorp.h ===
#ifndef _x_ERROR_H
#define _x_ERROR_H

struct _buttonCap {
	swidget *w;
	int  opt;
};

LOCAL SHORT X_error_conf();
LOCAL SHORT X_error();
LOCAL SHORT X_error_ext();

#define BAD_FORM ((swidget) -1)

#endif /* _x_ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\msw_snd.h ===
/*[
 *	Product:		SoftWindows Revision 2.0
 *
 *	Name:			msw_sound.h
 *
 *	Derived From:	Original
 *
 *	Authors:		Rob Tizzard
 *
 *	Created On:		16th April 1994
 *
 *	Purpose:		All definitions for the SoftWindows Windows audio 
 *					wave driver interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/

#ifdef SCCSID
static char SccsID[]="@(#)msw_snd.h	1.1 07/13/94";
#endif

/*
 * -----------------------------------------------------------------------------
 * Function return values.
 * -----------------------------------------------------------------------------
 */
 
/* Signal host error */

#define WAVE_SUCCESS    (IU32) 0
#define WAVE_FAILURE    (IU32) 1

/* Base error codes */

#define MMSYSERR_BASE 		0 
#define WAVERR_BASE		  	32 

/* Waveform audio error return values */

#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* General error return values */

#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */

/*
 * -----------------------------------------------------------------------------
 * Windows Data structure sizes.
 * -----------------------------------------------------------------------------
 */

#define MAXPNAMELEN		32		/* Product Name string length */
#define SIZEOF_MMTIME	6		/* Size of MMTIME structure in bytes */

/*
 * -----------------------------------------------------------------------------
 * Flags for dwSupport field of WAVEOUTCAPS.
 * -----------------------------------------------------------------------------
 */

#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010	 /* Synchronous device */

/*
 * -----------------------------------------------------------------------------
 * Manufacturer IDs, Product IDs & driver version numbers
 * -----------------------------------------------------------------------------
 */

#define MM_INSIGNIA          2       /* Insignia Solutions */

#define MM_SOFTWIN_WAVEOUT  13       /* SoftWindows waveform output */
#define MM_SOFTWIN_WAVEIN   13       /* SoftWindows waveform input */

#define WAV_OUT_VERSION	    0x0100   /* Output Wave Sound Driver Version */
#define WAV_IN_VERSION	    0x0100   /* Input Wave Sound Driver Version */

/*
 * -----------------------------------------------------------------------------
 * Defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
 * -----------------------------------------------------------------------------
 */

#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/*
 * -----------------------------------------------------------------------------
 * Defines for wave formats
 * -----------------------------------------------------------------------------
 */

#define WAVE_FORMAT_PCM     1

/* General wave format datastructure */

typedef struct  {
    IU16   wFormatTag;        /* format type */
    IU16   nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    IU32   nSamplesPerSec;    /* sample rate */
    IU32   nAvgBytesPerSec;   /* for buffer estimation */
    IU16   nBlockAlign;       /* block size of data */
} WAVEFORMAT;

/* PCM wave datastructure */

typedef struct  {
    WAVEFORMAT  wf;
    IU16        wBitsPerSample;
} PCMWAVEFORMAT;

/*
 * -----------------------------------------------------------------------------
 * Per allocation structure for wave
 * -----------------------------------------------------------------------------
 */

typedef struct {
    IU32           dwCallback;     /* client's callback */
    IU32           dwInstance;     /* client's instance data */
    IU32           hWave;          /* handle for stream */
    IU32           dwFlags;        /* allocation flags */
	IU32			dwByteCount;	/* byte count since last reset */
    PCMWAVEFORMAT  pcmwf;          /* format of wave data */
}WAVEALLOC;

/*
 * -----------------------------------------------------------------------------
 * Wave header structure.
 * -----------------------------------------------------------------------------
 */

/* flags for dwFlags field of WAVEHDR */

#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

typedef struct WAVHDR {
    LIN_ADDR	    lpData;          /* pointer to locked data buffer */
    IU32       		dwBufferLength;  /* length of data buffer */
    IU32       		dwBytesRecorded; /* used for input only */
    IU32       		dwUser;          /* for client's use */
    IU32       		dwFlags;         /* assorted flags (see defines) */
    IU32       		dwLoops;         /* loop control counter */
	LIN_ADDR		lpNext;         /* reserved for driver */
    IU32       		reserved;        /* reserved for driver */
} WAVEHDR;

/*
 * -----------------------------------------------------------------------------
 * Types for wType field in MMTIME struct
 * -----------------------------------------------------------------------------
 */
 
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ms_windo.h ===
/*[
 *	Product:	SoftPC-AT Revision 3.0
 *
 *	Name:		ms_windows.h
 *
 *	Derived From:	Alpha MS-Windows Driver by Ross Beresford
 *
 *	Author:		Rob Tizzard
 *
 *	Created On:	1st November 1990
 *
 *	SCCS ID:	@(#)ms_windows.h	1.66 07/06/94
 *
 *	Purpose:	This module defines the interface between the MS-Windows
 *		  	GDI and its dedicated display driver. 
 *
 * 	Notes:	 	The identifiers used in "windows.inc" are adopted here
 *		  	wherever possible; "windows.inc" is the definitions
 *		  	file supplied with the MS-Windows Software Development
 *		  	Kit.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

#ifdef MSWDVR
/*
 * -----------------------------------------------------------------------------
 * MS-Windows definitions
 * -----------------------------------------------------------------------------
 */

/* Windows versions */

#define WINDOWS2        0x0100
#define WINDOWS3        0x0300

/*  Binary raster ops */

#define  R2_BLACK             1               /*  0       */
#define  R2_NOTMERGEPEN       2               /* DPon     */
#define  R2_MASKNOTPEN        3               /* DPna     */
#define  R2_NOTCOPYPEN        4               /* PN       */
#define  R2_MASKPENNOT        5               /* PDna     */
#define  R2_NOT               6               /* Dn       */
#define  R2_XORPEN            7               /* DPx      */
#define  R2_NOTMASKPEN        8               /* DPan     */
#define  R2_MASKPEN           9               /* DPa      */
#define  R2_NOTXORPEN         10              /* DPxn     */
#define  R2_NOP               11              /* D        */
#define  R2_MERGENOTPEN       12              /* DPno     */
#define  R2_COPYPEN           13              /* P        */
#define  R2_MERGEPENNOT       14              /* PDno     */
#define  R2_MERGEPEN          15              /* DPo      */
#define  R2_WHITE             16              /*  1       */

/*  Ternary raster operations - interesting byte only */

#define  BLACKNESS   0x00  /* dest <- BLACK                       */
#define  NOTSRCERASE 0x11  /* dest <- (NOT source) AND (NOT dest) */
#define  MASKNOTSRC  0x22  /* dest <- (NOT source) AND dest       */
#define  NOTSRCCOPY  0x33  /* dest <- (NOT source)                */
#define  SRCERASE    0x44  /* dest <- source AND (NOT dest )      */
#define  DSTINVERT   0x55  /* dest <- (NOT dest)                  */
#define  SRCINVERT   0x66  /* dest <- source XOR      dest        */
#define  NOTMASKSRC  0x77  /* dest <- NOT (source AND dest)       */
#define  SRCAND      0x88  /* dest <- source AND dest             */
#define  NOTXORSRC   0x99  /* dest <- (NOT source) XOR dest       */
#define  NOP         0xAA  /* dest <- dest                        */
#define  MERGEPAINT  0xBB  /* dest <- (NOT source) OR dest        */
#define  SRCCOPY     0xCC  /* dest <- source                      */
#define  MERGESRCNOT 0xDD  /* dest <- source OR (NOT dest)        */
#define  SRCPAINT    0xEE  /* dest <- source OR dest              */
#define  WHITENESS   0xFF  /* dest <- WHITE                       */

#define  PATINVERT   0x5A  /* dest <- pattern XOR     dest        */
#define  OP6A        0x6A  /* dest <- (src AND pattern) XOR dest  */
#define  OPB8        0xB8  /* dest <- (p XOR dst) AND src) XOR p  */
#define  MERGECOPY   0xC0  /* dest <- (source AND pattern)        */
#define  OPE2        0xE2  /* dest <- (p XOR dst) AND src) XOR dst*/
#define  PATCOPY     0xF0  /* dest <- pattern                     */
#define  PATMERGE    0xFA  /* dest <- dst OR pat                  */
#define  PATPAINT    0xFB  /* dest <- DPSnoo                      */

#define	ISBINARY(rop) ((rop & 0x0F) == ((rop & 0xF0) >> 4))
#define	TOBINARY(rop) ((rop & 0x0F) + 1)

/* GDI data structure values */

#define GDIINFOSIZE	55				/* GDIINFO data structure size in words */
#define NUMBRUSHES	~0				/* Number of brushes = infinite */
#define NUMPENS		NUMCOLOURS*5			/* Number pens = NUMCOLOURS * 5 styles */
#define	XSIZ		240				/* Display width in millimeters */
#define	YSIZ		175				/* Display depth in millimeters */
#define	XRES		640				/* Display width in pixels */
#define	YRES		350				/* Display depth in scan lines */
#define	HYPOTENUSE	61				/* Distance moving X and Y */
#define	Y_MAJOR_DIST	48				/* Distance moving Y only */
#define	X_MAJOR_DIST	38				/* Distance moving X only */
#define	MAX_STYLE_ERR	HYPOTENUSE*2			/* Segment length for line styles */

/* GDI logical object definitions */

#define OBJ_PEN         1
#define OBJ_BRUSH       2
#define OBJ_FONT        3
#ifdef SWIN_DEVBMP
#define OBJ_PBITMAP		5

/*
 * BitmapBits parameter for the bit transfer operation
 */
#define DBB_SET         1
#define DBB_GET         2
#define DBB_COPY        4
#endif /* SWIN_DEVBMP */

/* GDI Brush Style definitions */

#define BS_SOLID	0
#define BS_HOLLOW	1
#define BS_HATCHED	2
#define BS_PATTERN	3

/* GDI Pen Style definitions */

#define LS_SOLID	0
#define	LS_DASHED	1
#define LS_DOTTED	2
#define LS_DOTDASHED	3
#define	LS_DASHDOTDOT	4
#define LS_NOLINE	5
#define LS_INSIDEFRAME	6

/* GDI Hatch Style definitions. */

#define HS_HORIZONTAL	0	/* ----- */
#define HS_VERTICAL	1	/* ||||| */
#define HS_FDIAGONAL	2	/* ///// */
#define HS_BDIAGONAL	3	/* \\\\\ */
#define HS_CROSS	4	/* +++++ */
#define HS_DIAGCROSS	5	/* xxxxx */

/* GDI Pen Style definitions */

#define PS_SOLID	0	/* _______ */
#define PS_DASH		1	/* ------- */
#define PS_DOT		2	/* ....... */
#define PS_DASHDOT	3	/* _._._._ */
#define PS_DASHDOTDOT	4	/* _.._.._ */
#define PS_NULL		5	/*         */

/* GDI Background type */

#define     TRANSPARENT         1
#define     OPAQUE              2

/* GDI Output Objects */

#define OS_ARC		3
#define OS_SCANLINES	4
#define OS_RECTANGLE	6
#define OS_ELLIPSE	7
#define OS_POLYLINE	18
#define OS_WINDPOLYGON	20
#define OS_ALTPOLYGON	22
#define OS_PIE		23
#define OS_CHORD	39
#define OS_CIRCLE	55
#define OS_ROUNDRECT	72
#define	OS_BEGINNSCAN	80
#define	OS_ENDNSCAN	81

/* GDI ScanLR flags */

#define	SCAN_LEFT	2
#define SCAN_RIGHT	0
#define SCAN_COLOUR	1
#define SCAN_NOTCOLOUR	0

/* GDI Save Screen Bitmap flags */

#define	SSB_SAVE	0
#define	SSB_RESTORE	1
#define	SSB_IGNORE	2

/* GDI Font Offsets */

#define	FONT_HEADER_SIZE	66
#define	FONT_CHARTABLE_OFFSET	52

/* GDI Extended Text Output options */

#define	ETO_OPAQUE_FILL	(1 << 1)
#define	ETO_OPAQUE_CLIP (1 << 2)

/* Brush Width & Height */

#define BRUSH_WIDTH	8
#define BRUSH_HEIGHT	8

/* Windows 3.0 static colours */

#define STATICCOLOURS	20

/* RLE DIB formats */

#define BI_RGB	 0x00
#define BI_RLE8	 0x01
#define BI_RLE4	 0x02

/*
 * GDI Control Escapes. The list of code numbers extracted directly out
 * of the Windows 3.1 DDK guide.
 */

#define ABORTDOC		(2)
#define BANDINFO		(24)
#define BEGIN_PATH		(4096)
#define CLIP_TO_PATH		(4097)
#define DRAFTMODE		(7)
#define DRAWPATTERNRECT		(25)
#define ENABLEDUPLEX		(28)
#define ENABLEPAIRKERNING	(769)
#define ENABLERELATIVEWIDTHS	(768)
#define END_PATH		(4098)
#define ENDDOC			(11)
#define ENUMPAPERBINS		(31)
#define ENUMPAPERMETRICS	(34)
#define ENUMPAPERMETRICS	(34)
#define EPSPRINTING		(33)
#define EXT_DEVICE_CAPS		(4099)
#define FLUSHOUTPUT		(6)
#define GETCOLORTABLE		(5)
#define GETEXTENDEDTEXTMETRICS	(256)
#define GETEXTENTTABLE		(257)
#define GETFACENAME		(513)
#define GETPAIRKERNTABLE	(258)
#define GETPHYSPAGESIZE		(12)
#define GETPRINTINGOFFSET	(13)
#define GETSCALINGFACTOR	(14)
#define GETSETPAPERBINS		(29)
#define GETSETPAPERMETRICS	(35)
#define GETSETPRINTORIENT	(30)
#define GETTECHNOLOGY		(20)
#define GETTRACKKERNTABLE	(259)
#define GETVECTORBRUSHSIZE	(27)
#define GETVECTORPENSIZE	(26)
#define NEWFRAME		(1)
#define NEXTBAND		(3)
#define PASSTHROUGH		(19)
#define QUERYESCSUPPORT		(8)
#define RESETDEVICE		(128)
#define RESTORE_CTM		(4100)
#define SAVE_CTM		(4101)
#define SET_ARC_DIRECTION	(4102)
#define SET_BACKGROUND_COLOR	(4103)
#define SET_BOUNDS		(4109)
#define SET_CLIP_BOX		(4108)
#define SET_POLY_MODE		(4104)
#define SET_SCREEN_ANGLE	(4105)
#define SET_SPREAD		(4106)
#define SETABORTPROC		(9)
#define SETALLJUSTVALUES	(771)
#define SETCOLORTABLE		(4)
#define SETCOPYCOUNT		(17)
#define SETKERNTRACK		(770)
#define SETLINECAP		(21)
#define SETLINEJOIN		(22)
#define SETMITERLIMIT		(23)
/* #define SETPRINTERDC		(9)  printers only - same code == SETABORTPROC */
#define STARTDOC		(10)
#define TRANSFORM_CTM		(4107)

/* 
 * -----------------------------------------------------------------------------
 * GDIINFO data structure flags
 * -----------------------------------------------------------------------------
 */ 

/*
 * 'dpTechnology' values
 */
#define DT_PLOTTER	(0)
#define DT_RASDISPLAY	(1)
#define DT_RASPRINTER	(2)
#define DT_RASCAMERA	(3)
#define DT_CHARSTREAM	(4)
#define DT_METAFILE	(5)
#define DT_DISPFILE	(6)

/*
 * 'dpLines' style flags
 */
#define LC_NONE		0x0000
#define LC_POLYLINE	0x0002
#define LC_WIDE		0x0010
#define LC_STYLED	0x0020
#define LC_WIDESTYLED	0x0040
#define LC_INTERIORS	0x0080

/*
 * 'dpPolygonals' style flags
 */
#define PC_NONE		0x0000
#define PC_ALTPOLYGON	0x0001
#define PC_RECTANGLE	0x0002
#define PC_WINDPOLYGON	0x0004
#define PC_SCANLINE	0x0008
#define PC_WIDE		0x0010
#define PC_STYLED	0x0020
#define PC_WIDESTYLED	0x0040
#define PC_INTERIORS	0x0080

/*
 * 'dpCurves' style flags
 */
#define CC_NONE		0x0000
#define CC_CIRCLES	0x0001
#define CC_PIE		0x0002
#define CC_CHORD	0x0004
#define CC_ELLIPSES	0x0008
#define CC_WIDE		0x0010
#define CC_STYLED	0x0020
#define CC_WIDESTYLED	0x0040
#define CC_INTERIORS	0x0080
#define CC_ROUNDRECT	0x0100

/*
 * 'dpText' style flags
 */
#define TC_OP_CHARACTER	0x0001	/* see ddag sect 2.1.9.1 */
#define TC_OP_STROKE	0x0002	/* see ddag sect 2.1.9.1 */
#define TC_CP_STROKE	0x0004
#define TC_CR_90	0x0008
#define TC_CR_ANY	0x0010
#define TC_SF_X_YINDEP	0x0020
#define TC_SA_DOUBLE	0x0040
#define TC_SA_INTEGER	0x0080
#define TC_SA_CONTIN	0x0100
#define TC_EA_DOUBLE	0x0200
#define TC_IA_ABLE	0x0400
#define TC_UA_ABLE	0x0800
#define TC_SO_ABLE	0x1000
#define TC_RA_ABLE	0x2000
#define TC_VA_ABLE	0x4000
#define TC_RESERVED	0x8000

/*
 * 'dpClip' values
 */
#define CP_NONE		(0)
#define CP_RECTANGLE	(1)
#define CP_REGION	(2)

/*
 * 'dpRaster' flag values
 */
#define RC_NONE		0x0000
#define RC_BITBLT	0x0001
#define RC_BANDING	0x0002
#define RC_SCALING	0x0004
#define RC_BITMAP64	0x0008
#define RC_GDI20_OUTPUT	0x0010
#define RC_GDI20_STATE	0x0020
#define RC_SAVEBITMAP	0x0040
#define RC_DI_BITMAP	0x0080
#define RC_PALETTE	0x0100
#define RC_DIBTODEV	0x0200
#define RC_BIGFONT	0x0400
#define RC_STRETCHBLT	0x0800
#define RC_FLOODFILL	0x1000
#define RC_STRETCHDIB	0x2000
#define RC_OP_DX_OUTPUT	0x4000
#define RC_DEVBITS	0x8000

/*
 * 'dpDCManage' values. These are NOT OR-able values!
 */
#define DC_MULTIPLE	(0)		/* this is my name - MSWIN doesn't give one. -- pic */
#define DC_SPDEVICE	(1)
#define DC_1PDEVICE	(2)
#define DC_IGNOREDFNP	(4)
#define DC_ONLYONE	(6)		/* this is my name - MSWIN doesn't give one. -- pic */

/*
 * 'dpCaps1' flag values.
 */
#define C1_TRANSPARENT	0x0001
#define TC_TT_ABLE	0x0002

/* 
 * -----------------------------------------------------------------------------
 * PDEVICE data structure 
 * -----------------------------------------------------------------------------
 */

#ifdef SWIN_DEVBMP
#define PDEVICESIZE	36			/* size of intel data structure in bytes */
#define PDEVICEBITMAP	0x4000	/* device type indication of a device bitmap */
#else /* SWIN_DEVBMP */
#define PDEVICESIZE	26		/* Data structure size in bytes */
#endif /* SWIN_DEVBMP */

#define PDEVICEMAGIC	0x2000		/* Device type display */

/*
 * -----------------------------------------------------------------------------
 * Windows return status codes
 * -----------------------------------------------------------------------------
 */

#define MSWSUCCESS	1
#define MSWFAILURE	0
#define MSWSIMULATE	-1

/* 
 * -----------------------------------------------------------------------------
 *  GDI Logo Layout 
 * -----------------------------------------------------------------------------
 */

#define	LOGOSTRPROD1	0
#define	LOGOSTRPROD2	(LOGOSTRPROD1 + 1)
#define	LOGOSTRPRODMAX	(LOGOSTRPROD2 + 1)
#define	LOGOSTRCOPY1	(LOGOSTRPROD2 + 1)
#define	LOGOSTRCOPY2	(LOGOSTRCOPY1 + 1)
#define	LOGOSTRCOPY3	(LOGOSTRCOPY2 + 1)
#define	LOGOSTRCOPY4	(LOGOSTRCOPY3 + 1)
#define	LOGOSTRCOPY5	(LOGOSTRCOPY4 + 1)
#define	LOGOSTRCOPY6	(LOGOSTRCOPY5 + 1)
#define	LOGOSTRMAX	(LOGOSTRCOPY6 + 1)

#define	LOGOMAGIC	1

#define	LOGO_MERGE_Y	64
#define	LOGO_PROD_Y	196
#define	LOGO_COPY_Y	266
#define	LOGO_LEADING	16

/*
 * -----------------------------------------------------------------------------
 * General definitions  
 * -----------------------------------------------------------------------------
 */

#ifndef min
#define min(a,b)                ((a)>(b) ? (b) : (a))
#endif

#ifndef max
#define max(a,b)                ((a)<(b) ? (b) : (a))
#endif

/*
 * -----------------------------------------------------------------------------
 * Memory definitions 
 * -----------------------------------------------------------------------------
 */

/* Memory masks */

#define HGHNIBMASK	0xF0
#define LOWNIBMASK	0x0F
#define HGHWORDMASK	0xFFFF0000
#define LOWWORDMASK	0x0000FFFF
#define BYTEMASK	((half_word) ~(0))
#define WORDMASK	((word) ~(0))
#define DOUBLEWORDMASK	((double_word) ~(0))

/* Bits per byte, word, double word  */

#define BITSPERNIBBLE	4
#define BITSPERBYTE	8
#define BITSPERWORD	16
#define BITSPERRGB	24

#ifdef SWIN_TEXT_OPTS
IMPORT ULONG	Seg_0_base32b;
#endif /* SWIN_TEXT_OPTS */

/* Components in byte */

#define NIBBLEPERBYTE	2

/* Macros for accessing Intel memory */

#define getbprm(stk,byt,var)	var = sas_hw_at_no_check((stk)+(byt));

#define getprm(stk,wrd,var)	var = sas_w_at_no_check(((stk)+((wrd)<<1)));

#define getlprm(stk,wrd,var)	var = sas_dw_at_no_check(stk+(wrd<<1))
/*
				{ word prvtmpoff, prvtmpseg; \
				prvtmpoff = sas_w_at_no_check((stk)+((wrd)<<1)); \
				prvtmpseg = sas_w_at_no_check((stk)+(((wrd)+1)<<1)); \
				var = ((double_word) prvtmpseg << BITSPERWORD) + (double_word) prvtmpoff; \
				}
*/
#define getptr(stk,wrd,var)	{ word prvtmpoff, prvtmpseg; \
				prvtmpoff = sas_w_at_no_check((stk)+((wrd)<<1)); \
				prvtmpseg = sas_w_at_no_check((stk)+(((wrd)+1)<<1)); \
				var = effective_addr(prvtmpseg, prvtmpoff); \
				}

#define getrgbcol(stk,wrd,var) 	{ \
				getlprm(stk,wrd,var); \
				ReverseRGB(var); \
				}

#define putbprm(stk,byt,var)	{ \
				sas_store_no_check((stk)+(byt),(var)); \
				}
#define putprm(stk,wrd,var) 	sas_storew_no_check((stk)+((wrd)<<1), (var))
#define putarry(addr,var) 	sas_storew_no_check((addr)+idx, (var)); \
				idx += WORD_SIZE
#define putlprm(stk,wrd,var)	sas_storedw_no_check((stk)+((wrd)<<1), var)
/*
				{ \
				sas_storew_no_check((stk)+((wrd)<<1), ((var) & LOWWORDMASK)); \
				sas_storew_no_check((stk)+(((wrd)+1)<<1),((var) >> BITSPERWORD)); \
				}
*/
#define putrgbcol(stk,wrd,var)	{ \
				ReverseRGB(var); \
				putlprm(stk,wrd,var); \
				}
				
#define getSegment(addr)	(word) ((addr & HGHWORDMASK) >> BITSPERWORD)
#define getOffset(addr)		(word) (addr & LOWWORDMASK)

/* Initial size of memory to malloc */

#define INITMEMALLOC    1024

/* Bit select macro */

#define BIT(num)        ((0x01)<<(num))

/* BITS <-> BYTES conversion macros */

#define BITSTOBYTES8(x)         (((x) + 0x7)>>3)
#define BITSTOBYTES16(x)        ((((x) + 0xf) & ~0xf)>>3)
#define BITSTOBYTES32(x)        ((((x) + 0x1f) & ~0x1f)>>3)
#define BYTESTOBITS(x)          ((x)<<3)

/* Expand memory allocation if needed */

#define ExpandMemory(addr, size, newsize, type)  \
\
{ \
type *tempAddr; \
if ((size) < ((newsize) * sizeof(type))) {\
        size = (newsize) * sizeof(type);        \
        while ((tempAddr = (type *) host_realloc((void *)addr, (size_t)size)) == NULL) \
        {       \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        } \
                addr = tempAddr; \
                }       }

/*
 * Converts a ROP3 to a ROP2, assuming no Source component. (i.e. Dest/Pat combinations only)
 */
#define ROP3toROP2(x)	(((x)>>2)&0x0F)+1

/*
 * -----------------------------------------------------------------------------
 * Window definitions
 * -----------------------------------------------------------------------------
 */

/* CRT mode byte data address */

#define CRT_MODE_BYTE_ADDR      0x0449

/*
 * Window_state defines whether the driver window is opened and
 * mapped. At a SoftPC reset,the state should become UNENABLED; when
 * the driver is first used,the driver window will be opened and
 * mapped,and the state should become ENABLED. If the driver is disabled,
 * the window is unmapped but not closed,and the state should become
 * DISABLED. */

#define WINDOW_STATE_UNENABLED  0
#define WINDOW_STATE_ENABLED    (WINDOW_STATE_UNENABLED + 1)
#define WINDOW_STATE_DISABLED   (WINDOW_STATE_ENABLED + 1)
#define WINDOW_STATE_ERROR   	(WINDOW_STATE_DISABLED + 1)

/* Host Independent Functions */

IMPORT word     WinFillGDIInfo IPT2(sys_addr,arg1,LONG,arg2);
IMPORT word     WinFillPDEVInfo IPT2(sys_addr,arg1,LONG,arg2);

/* Host dependent Functions */

IMPORT VOID     WinOpen IPT0();
IMPORT VOID     WinClose IPT0();
IMPORT VOID     WinMap IPT0();
IMPORT VOID     WinUmap IPT0();
IMPORT VOID     WinDirtyUpdate IPT5(BOOL,arg1,LONG,arg2,LONG,arg3,ULONG,arg4,ULONG,arg5);
IMPORT VOID     WinDirtyFlush IPT0();
IMPORT VOID     WinResize IPT0();
IMPORT VOID     WinSizeRestore IPT0();
IMPORT void     HostWEP IPT0();

/*
 * -----------------------------------------------------------------------------
 * BitBlt & FastBorder  definitions
 * -----------------------------------------------------------------------------
 */

/* Maximum number of border rectangles */

#define BORDER_RECT_MAX 4

/* ROP Logical Operation Table Dimensions */

#define NUMROPS         256
#define ROPTABLEWIDTH  	16 

/* Valid operands for ROP3 */

#define NONE    0       /* None */
#define SRC     1       /* Source */
#define DST     2       /* Destination */
#define PAT     3       /* Patterned brush */
#define SCTCH   4       /* Scratch area */
#define SSCTCH  5       /* Subsidurary scratch area */

/* Valid logical operators for ROP3 */

#define NOT	0
#define AND	1
#define OR 	2	
#define XOR	3
#define SET	4
#define CLEAR	5
#define COPY	6

#ifdef SWIN_MEMTOMEM_ROPS
/*
 * BCN 2482- these defines removed - 'D' conflicts with the
 * CCPU register variable 'D' (DX reg).
 *
 * Defines for Bitblt operands defined by the rop3 value
 *
 *  #define P       ((IU8) 0xf0)
 *  #define S       ((IU8) 0xcc)
 *  #define D       ((IU8) 0xaa)
 */

IMPORT VOID (*BmpRop3Supported[]) IPT5(
				BITMAP_MAPPING *,srcBitmap,
				BITMAP_MAPPING *,dstBitmap,
				Rectangle *, srcRect,
				Rectangle *, dstRect,
				BRUSH_MAPPING *, bp
				);
IMPORT IU8 BmpOperandTable[];

IMPORT IU8  *convertedLine;
IMPORT ULONG    convertedLineSize;

extern VOID	
BmpRop3MemToMem IPT6(BITMAP_MAPPING *,srcBitmap,BITMAP_MAPPING *,dstBitmap,
Rectangle *, srcRect, Rectangle *,dstRect, IU8, rop3, BRUSH_MAPPING *, bp);
extern BOOL
DirRectFill IPT6(BITMAP_MAPPING *,dstBitmap,BRUSH_MAPPING *,bp, 
LONG,x,LONG,y,ULONG,xExt,ULONG, yExt);
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * -----------------------------------------------------------------------------
 * Bitmap definitions
 * -----------------------------------------------------------------------------
 */

/* Mapping types */

#define MAP_NULL        0
#define MAP_BITMAP      1
#define MAP_DISPLAY     2

/* BmpOpen flag parameter bit fields */

#define BMPNONE         0x0
#define BMPTRANS        0x1
#define BMPOVRRD        0x2

/* Bitmap formats */

#define MAX_BITMAP_TYPES	4

/* Note that BITMAP16 format is not currently supported (2/12/92) */

#define MONOCHROME	1	/* bits per pixel=1 */
#define BITMAP4		4	/* bits per pixel=4 */
#define BITMAP8		8	/* bits per pixel=8 */
#define BITMAP16        16      /* bits per pixel=16 */
#define BITMAP24	24	/* bits per pixel=24 */

/* Bitmap line conversion functions */

IMPORT VOID	ConvBitmapFormat IPT2(BITMAP_MAPPING *,arg1, ULONG *,arg2);
IMPORT VOID	Conv1To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI1ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI4ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI8ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI24ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     ConvTrans1To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI24ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI1ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI4ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI8ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);

/* Host Independent Functions */

IMPORT  VOID    BmpPatternedBrush IPT4(sys_addr,arg1,BRUSH_MAPPING *,arg2,MSWPIXEL,arg3,MSWPIXEL,arg4);
IMPORT  VOID    BmpClip IPT8(SHORT *,arg1,SHORT *,arg2,SHORT *,arg3,SHORT *,arg4,USHORT *,arg5,USHORT *,arg6,USHORT,arg7,USHORT,arg8);
IMPORT  VOID    BmpBitmapToBitmap IPT9(BITMAP_MAPPING *,arg1,BITMAP_MAPPING *,arg2,ULONG,arg3,LONG,arg4,LONG,arg5,ULONG,arg6,ULONG,arg7,LONG,arg8,LONG,arg9);
IMPORT  VOID    BmpLoadBitmap IPT2(sys_addr,arg1,BITMAP_MAPPING *,arg2);
IMPORT	VOID	BmpLoadBitmapHeader IPT2(sys_addr,bmptr,BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpSaveBitmap IPT1(BITMAP_MAPPING *,arg1);
IMPORT  VOID    BmpDestroyBitmap IPT1(BITMAP_MAPPING *,arg1);
IMPORT	LONG	BmpMSWType IPT1(sys_addr,bmptr);

#ifdef SWIN_DEVBMP
IMPORT  VOID    BmpSetBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
IMPORT  VOID    BmpGetBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
IMPORT  VOID    BmpCopyBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
#endif /* SWIN_DEVBMP */


/* Array of Binary ROP Functions supported for BitmapToBitmap
 * NB. 0 means "not supported"
 */

IMPORT	VOID	(*MoveLine[]) IPT7(SHIFTUNIT *,srcbits, SHIFTUNIT *,dstbits, ULONG,srcoffset,ULONG,dstoffset,ULONG,lshift,ULONG,rshift,ULONG,width);


/* Host dependent Functions */

IMPORT  BOOL    BmpFastDspToBmp IPT11(sys_addr,bmptr,IU8,rop,
	sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,bx,LONG,by,ULONG,xext,ULONG,yext,LONG,dx,LONG,dy);
IMPORT  BOOL    BmpFastBmpToDsp IPT11(sys_addr,bmptr,IU8,rop,
	sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,bx,LONG,by,ULONG,xext,ULONG,yext,LONG,dx,LONG,dy);
#ifdef SWIN_MEMTOMEM_ROPS
extern  BOOL    BmpFastBmpToBmp IPT12(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	SHORT,sx,SHORT,sy,USHORT,xext,USHORT,yext, SHORT,dx,SHORT,dy);
#else
IMPORT  BOOL    BmpFastBmpToBmp IPT12(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,sx,LONG,sy,ULONG,xext,ULONG,yext, LONG,dx,LONG,dy);
#endif
IMPORT  BOOL    BmpFastDspToDsp IPT10(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,LONG,sx,LONG,sy,ULONG,xext,ULONG,yext,
	LONG,dx,LONG,dy);
IMPORT  VOID    BmpOpen IPT9(sys_addr,bmptr,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,active_x,LONG,active_y,ULONG,active_width,ULONG,active_height,
	ULONG,flags,BITMAP_MAPPING *,bm_return);
IMPORT  VOID    BmpClose IPT1(BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpCancel IPT1(BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpInit IPT0();
IMPORT  VOID    BmpTerm IPT0();
#ifdef SWIN_BMPTOXIM
IMPORT  VOID    BmpPutMSWBitmap IPT4(BITMAP_MAPPING *,bitmap, IU8,rop,
	SHORT,src_x, SHORT,src_y);
#else
IMPORT  VOID    BmpPutMSWBitmap IPT4(BITMAP_MAPPING *,bitmap, IU8,rop,
	LONG,src_x, LONG,src_y);
#endif
IMPORT  VOID    BmpGetMSWBitmap IPT5(BITMAP_MAPPING *,bitmap, IU8,rop,
	LONG,dst_x, LONG,dst_y, BRUSH_MAPPING *,bp);
IMPORT	VOID	BmpFastSolidFill IPT6(BITMAP_MAPPING *,bm,BRUSH_MAPPING *,bp,LONG,x,LONG,y,IS32,xext,FAST IS32,yext);

/*
 * -----------------------------------------------------------------------------
 * Colour definitions
 * -----------------------------------------------------------------------------
 */

/* Valid colour formats supported */

#define COLOUR2         2
#define COLOUR8         8
#define COLOUR16        16
#define COLOUR256       256
#define COLOURTRUE24	0xFFFF

/* RGB shift values */

#define RGB_FLAGS_SHIFT         24
#define RGB_RED_SHIFT           16
#define RGB_GREEN_SHIFT         8
#define RGB_BLUE_SHIFT          0
#define RGB_SHIFT      		BITSPERBYTE

/* RGB values */

#define RGB_BLACK       (MSWCOLOUR) (0x00000000)
#define RGB_BLUE        (MSWCOLOUR) (0x000000FF)
#define RGB_GREEN       (MSWCOLOUR) (0x0000FF00)
#define RGB_RED         (MSWCOLOUR) (0x00FF0000)
#define RGB_WHITE       (MSWCOLOUR) (0x00FFFFFF)
#define RGB_FLAGS       (MSWCOLOUR) (0xFF000000)

/* Masks */

#define RGB_MASK        (UTINY) (BYTEMASK)
#define PAL_INDEX_MASK  ~(DOUBLEWORDMASK << mswdvr.bitsPixel)

/* Colour to monochrome threshold */

#define BW_THRESHOLD    (RGB_MASK*3)/2

/* Make sure no palette translation occurs for a colour */

#define ColNoTranslate(colour) (colour & ~(RGB_FLAGS))

/* RGB <-> BGR */

#define ReverseRGB(rgb) \
\
{ half_word     loByte, miByte, hiByte; \
  if ((rgb & RGB_FLAGS) != RGB_FLAGS) { \
  	hiByte = (rgb & RGB_RED) >> RGB_RED_SHIFT; \
  	miByte = (rgb & RGB_GREEN) >> RGB_GREEN_SHIFT; \
  	loByte = (rgb & RGB_BLUE) >> RGB_BLUE_SHIFT; \
  	rgb = ((MSWCOLOUR) loByte << RGB_RED_SHIFT) | \
              ((MSWCOLOUR) miByte << RGB_GREEN_SHIFT) | \
	      ((MSWCOLOUR) hiByte << RGB_BLUE_SHIFT); } }

/* Swap macro */

#define swap(a, b)      { ULONG tempDWord=a; a = b; b = tempDWord; }

/* Host Independent Functions */

IMPORT VOID             ColDitherBrush IPT2(MSWCOLOUR,arg1, BRUSH_MAPPING *,arg2);
IMPORT HOSTPIXEL        ColPixel IPT1(MSWCOLOUR,arg1);
IMPORT MSWPIXEL         ColLogPixel IPT1(MSWCOLOUR,arg1);
IMPORT MSWCOLOUR        ColRGB IPT1(MSWPIXEL,arg1);
IMPORT MSWCOLOUR        ColLogRGB IPT1(MSWPIXEL,arg1);

/* Host dependent Functions */

IMPORT VOID		ColSetColourmapEntry IPT2(MSWCOLOURMAP *,arg1, MSWCOLOUR,arg2);
IMPORT BOOL             ColInit IPT0();
IMPORT VOID             ColTerm IPT0();
IMPORT VOID             ColTranslateBrush IPT1(BRUSH_MAPPING *,arg1);
IMPORT VOID             ColTranslatePen IPT1(PEN_MAPPING *,arg1);
IMPORT VOID		ColUpdatePalette IPT2(word,arg1, word,arg2);
IMPORT MSWPIXEL		ColMono IPT1(MSWCOLOUR,arg1);

/*
 * -----------------------------------------------------------------------------
 * Text definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT VOID     TxtMergeRectangle IPT2(Rectangle *,arg1, Rectangle *,arg2);

/* Host dependent Functions */

IMPORT VOID     TxtInit IPT0();
IMPORT VOID     TxtTerm IPT0();
IMPORT VOID	TxtOpaqueRectangle IPT3(BITMAP_MAPPING *,arg1, Rectangle *,arg2, MSWCOLOUR,arg3);
IMPORT VOID	TxtPutTextBitmap IPT4(BITMAP_MAPPING *,arg1, BITMAP_MAPPING *,arg2, ULONG,arg3, ULONG,arg4);
IMPORT VOID	TxtTextAccess IPT4(MSWCOLOUR,arg1, MSWCOLOUR,arg2, word,arg3, Rectangle *,arg4);

/*
 * -----------------------------------------------------------------------------
 * DIB definitions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT VOID DibInit IPT0();
IMPORT VOID DibTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Object definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT VOID	ObjGetRect IPT2(sys_addr,arg1, Rectangle *,arg2);
#ifdef SWIN_DEVBMP
IMPORT word     ObjPBitmapOpen IPT1(sys_addr, arg1);
IMPORT VOID     ObjPBitmapRestore IPT2(sys_addr, arg1, word *, arg2);
IMPORT VOID     ObjPBitmapSave IPT3(sys_addr, arg1, sys_addr, arg2, word, arg3);
IMPORT VOID     ObjPBitmapClose IPT1(word, arg1);
IMPORT BITMAP_MAPPING   *ObjPBitmapAccess IPT1(sys_addr, lpPBitmap);
#endif /* SWIN_DEVBMP */


/* Host dependent Functions */

IMPORT VOID             ObjInit IPT0();
IMPORT VOID             ObjTerm IPT0();
IMPORT BRUSH_MAPPING    *ObjPBrushAccess IPT4(sys_addr,pbr,BITMAP_MAPPING *,bmp,IU8,rop2,sys_addr,clip);
IMPORT PEN_MAPPING      *ObjPPenAccess IPT5(sys_addr,pp,BITMAP_MAPPING *,bmp,IU8,rop2,sys_addr,clip,word,back_mode);
IMPORT word		ObjPenOpen IPT1(sys_addr,arg1);
IMPORT VOID		ObjPenClose IPT1(word,arg1);
IMPORT word		ObjBrushOpen IPT3(sys_addr,arg1, word,arg2, word,arg3);
IMPORT VOID		ObjBrushClose IPT1(word,arg1);
IMPORT VOID 		ObjPPenSave IPT2(sys_addr,arg1, word,arg2);
IMPORT VOID		ObjPPenRestore IPT2(sys_addr,arg1, word *,arg2);
IMPORT VOID 		ObjPBrushSave IPT2(sys_addr,arg1, word,arg2);
IMPORT VOID		ObjPBrushRestore IPT2(sys_addr,arg1, word *,arg2);
IMPORT	BOOL		ObjValidPPen IPT1(sys_addr,ppen);

#ifdef SWIN_MEM_POLYLINE
IMPORT	BOOL		ObjDirPPen IPT1(sys_addr,ppen);
#endif /* SWIN_MEM_POLYLINE */


/*
 * -----------------------------------------------------------------------------
 * Pattern Library definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT  VOID    LibHatchedTile IPT4(BRUSH_MAPPING *,arg1, word,arg2, MSWPIXEL,arg3, MSWPIXEL,arg4);

/* Host dependent Functions */

IMPORT  VOID    LibPatLibInit IPT0();
IMPORT  VOID    LibPatLibTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Save screen bitmap definitions
 * -----------------------------------------------------------------------------
 */

IMPORT  VOID    SavInit IPT0();
IMPORT  VOID    SavTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Pointer definitions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT	VOID	PtrInit IPT0();
IMPORT	VOID	PtrTerm IPT0();
                    
/*
 * -----------------------------------------------------------------------------
 * Resource defintions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT VOID     ResInit IPT0();
IMPORT VOID     ResTerm IPT0();
IMPORT VOID	ResAllocateBitmapMapping IPT3(BITMAP_MAPPING *,arg1, ULONG,arg2, ULONG,arg3);
IMPORT VOID	ResDeallcateBitmapMapping IPT1(BITMAP_MAPPING *, arg1);
IMPORT VOID	ResAllocateBitmapMemory IPT1(BITMAP_MAPPING *,arg1);
IMPORT VOID	ResDeallcateBitmapMemory IPT1(BITMAP_MAPPING *, arg1);

/*
 * -----------------------------------------------------------------------------
 * Global variables
 * -----------------------------------------------------------------------------
 */

/* Windows driver global data area */

IMPORT MSW_DATA	mswdvr;

/* Bitmap line conversion function tables */

IMPORT VOID     (*convFuncs[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*convTransFuncs[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvFuncsEToI[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvFuncsIToE[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvTransFuncsEToI[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvTransFuncsIToE[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();

/* Context information set in ms_windows.c to provide global information
 * about the overall operation. Note that this information is independent
 * of the host implementation and is therefore defined in the Base include
 * file.
 */
typedef struct {
	int	dest_depth;		/* format changes in BitBlt */
	IBOOL	translate_palette;	/* needed for index colours? */
	IBOOL	dest_is_display;	/* used by Mac etc */
} MSW_CONTEXT;

IMPORT MSW_CONTEXT msw_context;

#ifdef SWIN_DEVBMP
IMPORT BITMAP_MAPPING   *ppbitmap;
IMPORT ULONG            ppbitmapEntries;
IMPORT ULONG            ppbitmapSize;
#endif /* SWIN_DEVBMP */

IMPORT IBOOL		mode_exit;	/* tells us if exite due to video mode change */

/*
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Top Level Functions
 * -----------------------------------------------------------------------------
 */

IMPORT VOID	BltBitblt IPT11(sys_addr,lpDestDev,word,wDestX,word,wDestY,sys_addr,lpSrcDev,word,wSrcX,word,wSrcY,word,wXext,word,wYext,IU8,rop3,sys_addr,lpPBrush,sys_addr,lpDrawMode);

IMPORT VOID 	BltStretchBlt IPT14(sys_addr,dstdev,word,dx,word,dy,word,xext,word,yext,sys_addr,arg6,word,arg7,word,arg8,word,arg9,word,arg10,
                    IU8,rop,sys_addr,pbrush,sys_addr,drawmode,sys_addr,cliprect);

IMPORT VOID	BltFastBorder IPT11(sys_addr,dstdev,word,dx,word,dy,word,xext,
		word,yext,word,bt,word,vbt,IU8,rop,sys_addr,pbrush,
		sys_addr,drawmode,sys_addr,cliprect);

IMPORT VOID	ColColorInfo IPT3(sys_addr,arg1,double_word,arg2,sys_addr,arg3);
IMPORT VOID 	ColSetPalette IPT3(word,arg1,word,arg2,sys_addr,arg3);
IMPORT VOID	ColGetPalette IPT3(word,arg1,word,arg2,sys_addr,arg3);
IMPORT VOID	ColSetPalTrans IPT1(sys_addr,arg1);
IMPORT VOID	ColGetPalTrans IPT1(sys_addr,arg1);
IMPORT VOID	ColUpdateColors IPT5(word,arg1,word,arg2,word,arg3,word,arg4,sys_addr,arg5);

IMPORT VOID	DibDeviceBitmapBits IPT8(sys_addr,arg1,word,arg2,word,arg3,word,arg4,double_word,arg5,sys_addr,arg6,sys_addr,arg7,sys_addr,arg8);
IMPORT VOID	DibSetDIBitsToDevice IPT10(sys_addr,arg1,word,arg2,word,arg3,word,arg4,word,arg5,sys_addr,arg6,sys_addr,arg7,double_word,arg8,sys_addr,arg9,sys_addr,arg10);

IMPORT VOID	LgoLogo IPT1(sys_addr,arg1);

IMPORT VOID	ObjRealizeObject IPT5(word,arg1,sys_addr,arg2,sys_addr,arg3,word,arg4,word,arg5);

IMPORT VOID	OutOutput IPT8(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,sys_addr,arg6,sys_addr,arg7,sys_addr,arg8);

IMPORT VOID	PtrCheckCursor IPT0();

IMPORT VOID	PtrMoveCursor IPT2(word,arg1,word,arg2);

IMPORT VOID	PtrSetCursor IPT1(sys_addr,arg1);

IMPORT VOID	SavSaveScreenBitmap IPT5(word,arg1,word,arg2,word,arg3,word,arg4,word,arg5);

IMPORT VOID	TxtExtTextOut IPT12(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,word,arg6,sys_addr,arg7,sys_addr,arg8,sys_addr,arg9,
			      sys_addr,arg10,sys_addr,arg11,word,arg12);

IMPORT VOID	TxtGetCharWidth IPT7(sys_addr,arg1,sys_addr,arg2,word,arg3,word,arg4,sys_addr,arg5,sys_addr,arg6,sys_addr,arg7);

IMPORT VOID	TxtStrblt IPT9(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,word,arg6,sys_addr,arg7,sys_addr,arg8,sys_addr,arg9);

IMPORT VOID	WinControl IPT4(sys_addr,arg1,word,arg2,sys_addr,arg3,sys_addr,arg4);
IMPORT VOID	WinDisable IPT1(sys_addr,arg1);
IMPORT VOID	WinEnable IPT5(sys_addr,arg1,word,arg2,sys_addr,arg3,sys_addr,arg4,sys_addr,arg5);
IMPORT VOID	WinPixel IPT5(sys_addr,arg1,word,arg2,word,arg3,MSWCOLOUR,arg4,sys_addr,arg5);
IMPORT VOID	WinScanlr IPT5(sys_addr,arg1,word,arg2,word,arg3,MSWCOLOUR,arg4,word,arg5);

#ifdef SWIN_DEVBMP
IMPORT VOID ObjBitmapBits IPT4(sys_addr,lpDevice,double_word,fFlags,double_word,dwCount,double_word,lpBits);
IMPORT VOID ObjSelectBitmap IPT4(sys_addr,lpDevice,sys_addr,lpPrevBitmap,sys_addr,lpBitmap,double_word,fFlags);
#endif /* SWIN_DEVBMP */

/*
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Low Level Functions (Totally host dependent)
 * -----------------------------------------------------------------------------
 */

IMPORT MSWCOLOUR	LowGetPixel IPT3(BITMAP_MAPPING *,arg1,ULONG,arg2,ULONG,arg3);
IMPORT VOID	     	LowSetPixel IPT5(BITMAP_MAPPING *,arg1,ULONG,arg2,ULONG,arg3,ULONG,arg4,MSWCOLOUR,arg5);
IMPORT VOID 		LowStretchArea IPT3(BITMAP_MAPPING *,arg1, BITMAP_MAPPING *,arg2, Rectangle *,arg3);
IMPORT VOID		LowFillArea IPT2(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2);
IMPORT VOID	     	LowCopyArea IPT3(BITMAP_MAPPING *,arg1,BITMAP_MAPPING *,arg2, ULONG,arg3);
IMPORT VOID		LowFillRectangle IPT6(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawRectangle IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID 		LowFillRoundRect IPT8(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6,ULONG,arg7,ULONG,arg8);
IMPORT VOID		LowDrawRoundRect IPT8(BITMAP_MAPPING *,arg1,PEN_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6,ULONG,arg7,ULONG,arg8);
IMPORT VOID		LowFillRectangles IPT4(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,Rectangle *,arg3, ULONG,arg4);
IMPORT VOID		LowDrawLine IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,LONG,arg5,LONG,arg6);
IMPORT VOID		LowFillEllipse IPT6(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawEllipse IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawScanline IPT5(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5);
IMPORT VOID		LowFillScanline IPT5(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5);

/*
 *------------------------------------------------------------------------------
 * SmartCopy specific defines, global variables and externs
 *------------------------------------------------------------------------------
 */

#ifndef HostProcessClipData
/* List of #defines from "windows.h" v3.10 */
 
#define CF_NULL              0
#define CF_TEXT		     1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
 
#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
 
/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF
 
/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF
 
#define POLL_UPDATE_HOST_CLIPBOARD 0
#define POLL_UPDATE_WINDOWS_CLIPBOARD 1
#define POLL_UPDATE_WINDOWS_DISPLAY	2

#ifndef HOST_CLIPBOARD_TIMEOUT
#define HOST_CLIPBOARD_TIMEOUT 40
#endif

/* types of clipbop */
 
#define GETPOLLADDR             0
#define PROCESSCLIPBOARD        1
#define POLLFORCINPUT           2
#define GETCBDATA               3
#define REMOVEPOLLADDR          4
#define GETPOLLREASON           5
#define EMPTYCLIPBOARD			6
#define DONEPROCESSING			7
 
extern BOOL 	smcpyInitialised;	/* SmartCopy initialised ? */
extern BOOL 	smcpyMissedPoll;
extern int  Reasonforpoll;	/* Why has smartcopy been polled */

extern VOID HostProcessClipData();
extern IBOOL HostClipboardChanged();
extern VOID HostResetClipboardChange();
extern VOID HostInitClipboardChange();
extern VOID HostGetClipData();
extern IBOOL HostAssessClipData();
extern VOID HostGetPollReason();
extern VOID msw_causepoll();
extern IBOOL msw_stillpolling();

#endif /* HostProcessClipData */
#endif /* MSWDVR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\m_fs.h ===
#ifndef _x_FS_H
#define _x_FS_H

typedef enum {
	NEW_DISK_SEL = 0,
	OPEN_C_SEL,
	OPEN_D_SEL,
	OPEN_FSA_SEL,
	KEYB_FILE_SEL,
	LAST_SEL
} titleEnum;

#endif /* _x_FS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\m_lpcmp.h ===
#ifndef _M_LPCMp_H
#define _M_LPCMp_H

typedef struct {
	Widget menu, text;
	UTINY nameID, typeID;
	BOOL checked, active;
} lpcmEntry;

#define MAX_BUTTONS 10

#ifdef ANSI
IMPORT VOID lpcmVerifyEntry();
IMPORT VOID lpcmRefreshPanel(lpcmEntry entry[], UTINY numEntries);
#else /* ANSI */
IMPORT VOID lpcmVerifyEntry();
IMPORT VOID lpcmRefreshPanel();
#endif /* ANSI */

#endif /* _M_LPCMp_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\m_keybdp.h ===
/*[
	Name:		M_keybdP.h
	Derived From:	Cut out of M_keybd.c
	Author:		gvdl
	Created On:	30 July 1991
	Sccs ID:	08/10/92 @(#)M_keybdP.h	1.4
	Purpose:	Default KeySym to AT matrix keycode mapping table.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

In the table below the index of the entry is the AT matrix code as returned
to the keyboard internal CPU.
]*/

/*
 * Local variables used in X keycode to PC keycode conversion
 */
LOCAL KeySym KeySymTable[] = 
{
	XK_BackSpace,		/*   0  0x00 */
	XK_grave,		/*   1  0x01 */
	XK_1,			/*   2  0x02 */
	XK_2,			/*   3  0x03 */
	XK_3,			/*   4  0x04 */
	XK_4,			/*   5  0x05 */
	XK_5,			/*   6  0x06 */
	XK_6,			/*   7  0x07 */
	XK_7,			/*   8  0x08 */
	XK_8,			/*   9  0x09 */
	XK_9,			/*  10  0x0a */
	XK_0,			/*  11  0x0b */
	XK_minus,		/*  12  0x0c */
	XK_equal,		/*  13  0x0d */
	0,			/*  14  0x0e */
	XK_BackSpace,		/*  15  0x0f */
	XK_Tab,			/*  16  0x10 */
	XK_q,			/*  17  0x11 */
	XK_w,			/*  18  0x12 */
	XK_e,			/*  19  0x13 */
	XK_r,			/*  20  0x14 */
	XK_t,			/*  21  0x15 */
	XK_y,			/*  22  0x16 */
	XK_u,			/*  23  0x17 */
	XK_i,			/*  24  0x18 */
	XK_o,			/*  25  0x19 */
	XK_p,			/*  26  0x1a */
	XK_bracketleft,		/*  27  0x1b */
	XK_bracketright,	/*  28  0x1c */
	XK_backslash,		/*  29  0x1d */
	XK_Caps_Lock,		/*  30  0x1e */
	XK_a,			/*  31  0x1f */
	XK_s,			/*  32  0x20 */
	XK_d,			/*  33  0x21 */
	XK_f,			/*  34  0x22 */
	XK_g,			/*  35  0x23 */
	XK_h,			/*  36  0x24 */
	XK_j,			/*  37  0x25 */
	XK_k,			/*  38  0x26 */
	XK_l,			/*  39  0x27 */
	XK_semicolon,		/*  40  0x28 */
	XK_apostrophe,		/*  41  0x29 */
	0,			/*  42  0x2a */
	XK_Return,		/*  43  0x2b */
	XK_Shift_L,		/*  44  0x2c */
	0,			/*  45  0x2d */
	XK_z,			/*  46  0x2e */
	XK_x,			/*  47  0x2f */
	XK_c,			/*  48  0x30 */
	XK_v,			/*  49  0x31 */
	XK_b,			/*  50  0x32 */
	XK_n,			/*  51  0x33 */
	XK_m,			/*  52  0x34 */
	XK_comma,		/*  53  0x35 */
	XK_period,		/*  54  0x36 */
	XK_slash,		/*  55  0x37 */
	0,			/*  56  0x38 */
	XK_Shift_R,		/*  57  0x39 */
	XK_Control_L,		/*  58  0x3a */
	0,			/*  59  0x3b */
	XK_Alt_L,		/*  60  0x3c */
	XK_space,		/*  61  0x3d */
	XK_Alt_R,		/*  62  0x3e */
	0,			/*  63  0x3f */
	XK_Control_R,		/*  64  0x40 */
	0,			/*  65  0x41 */
	0,			/*  66  0x42 */
	0,			/*  67  0x43 */
	0,			/*  68  0x44 */
	0,			/*  69  0x45 */
	0,			/*  70  0x46 */
	0,			/*  71  0x47 */
	0,			/*  72  0x48 */
	0,			/*  73  0x49 */
	0,			/*  74  0x4a */
	XK_Insert,		/*  75  0x4b */
	XK_Delete,		/*  76  0x4c */
	0,			/*  77  0x4d */
	0,			/*  78  0x4e */
	XK_Left,		/*  79  0x4f */
	XK_Home,		/*  80  0x50 */
	XK_End,			/*  81  0x51 */
	0,			/*  82  0x52 */
	XK_Up,			/*  83  0x53 */
	XK_Down,		/*  84  0x54 */
	XK_Prior,		/*  85  0x55 */
	XK_Next,		/*  86  0x56 */
	0,			/*  87  0x57 */
	0,			/*  88  0x58 */
	XK_Right,		/*  89  0x59 */
	XK_Num_Lock,		/*  90  0x5a */
	XK_KP_7,		/*  91  0x5b */
	XK_KP_4,		/*  92  0x5c */
	XK_KP_1,		/*  93  0x5d */
	0,			/*  94  0x5e */
	XK_KP_Divide,		/*  95  0x5f */
	XK_KP_8,		/*  96  0x60 */
	XK_KP_5,		/*  97  0x61 */
	XK_KP_2,		/*  98  0x62 */
	XK_KP_0,		/*  99  0x63 */
	XK_KP_Multiply,		/* 100  0x64 */
	XK_KP_9,		/* 101  0x65 */
	XK_KP_6,		/* 102  0x66 */
	XK_KP_3,		/* 103  0x67 */
	XK_KP_Decimal,		/* 104  0x68 */
	XK_KP_Subtract,		/* 105  0x69 */
	XK_KP_Add,		/* 106  0x6a */
	0,			/* 107  0x6b */
	XK_KP_Enter,		/* 108  0x6c */
	0,			/* 109  0x6d */
	XK_Escape,		/* 110  0x6e */
	0,			/* 111  0x6f */
	XK_F1,			/* 112  0x70 */
	XK_F2,			/* 113  0x71 */
	XK_F3,			/* 114  0x72 */
	XK_F4,			/* 115  0x73 */
	XK_F5,			/* 116  0x74 */
	XK_F6,			/* 117  0x75 */
	XK_F7,			/* 118  0x76 */
	XK_F8,			/* 119  0x77 */
	XK_F9,			/* 120  0x78 */
	XK_F10,			/* 121  0x79 */
	XK_F11,			/* 122  0x7a */
	XK_F12,			/* 123  0x7b */
	XK_Print,		/* 124  0x7c */
	XK_Scroll_Lock,		/* 125  0x7d */
	XK_Pause,		/* 126  0x7e */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ppi.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: PPI Adpator definitions
 *
 * Description	: Definitions for users of the PPI Adaptor 
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)ppi.h	1.4 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void ppi_init(void);
extern void ppi_inb(io_addr,half_word *);
extern void ppi_outb(io_addr,half_word);
#else
extern void ppi_init();
extern void ppi_inb();
extern void ppi_outb();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\novell.h ===
/*[
 *	Name:			novell.h
 *
 *	Derived From:	original
 *
 *	Author:			David Linnard
 *
 *	Created On:		28th May, 1992
 *
 *	Purpose :		Main Novell include file
 *
 *  Interface:
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/

/* SccsID[]="@(#)novell.h	1.11 05/15/95 Copyright Insignia Solutions Ltd."; */

/*
 * Constants and macros to access Transmit Control Blocks (TCBs)
 */


/* TCB fields */
#define TCBDriverWS			0	/* 6 bytes of driver workspace - unused by us */
#define TCBDataLength		6	/* Total frame length - But use CX for real value for Ethernet */
#define TCBFragStrucPtr		8	/* FAR pointer to Fragment Structure */
#define TCBMediaHeaderLen	12	/* Length of Media header - which comes next. May be zero */
#define TCBMediaHeader		14	/* The media header */

#define getTCBDataLength(TCB)	sas_w_at(TCB+TCBDataLength)
#define getTCBFragStruc(TCB)	effective_addr( sas_w_at( TCB+TCBFragStrucPtr + 2 ), sas_w_at( TCB+TCBFragStrucPtr ) )
#define getTCBMediaHdrLen(TCB)	sas_w_at(TCB+TCBMediaHeaderLen)
#define getTCBMediaHdr(TCB,i)	sas_hw_at(TCB+TCBMediaHeader+i)

/* Fragment structure fields */
#define FFragmentCount		0	/* Number of fragments. Cannot be zero */
#define FFrag0Address 		2	/* FAR pointer to first fragment data */
#define	FFrag0Length		6	/* Length of first fragment */

#define getnTFrags(FF)		sas_w_at(FF+FFragmentCount)
#define getTFragPtr(FF,i)	effective_addr( sas_w_at( FF+FFrag0Address+6*i+2 ), sas_w_at( FF+FFrag0Address+6*i ) )
#define getTFragLen(FF,i)	sas_w_at(FF+FFrag0Length+6*i)

/*
 * Constants and macros to access Receive Control Blocks (RCBs)
 */

/* RCB fields */
#define RCBDriverWS			0	/* 8 bytes of driver workspace - unused by us */
#define RCBReserved			8	/* 36 bytes of reserved space */
#define RCBFragCount		44	/* Number of fragments */
#define RCBFrag0Addr		46	/* Pointer to first fragment */
#define RCBFrag0Len			50	/* Length of first fragment */

#define getnRFrags(RCB)		sas_w_at(RCB+RCBFragCount)
#define getRFragPtr(RCB,i)	effective_addr( sas_w_at( RCB+RCBFrag0Addr+6*i+2 ), sas_w_at( RCB+RCBFrag0Addr+6*i ) )
#define getRFragLen(RCB,i)	sas_w_at(RCB+RCBFrag0Len+6*i)

/* Media/Frame types as defined in Appendix B-2 of ODI Developer's Guide */
#define VIRTUAL_LAN		0	/* Used for 'tunnelled' IPX on APpleTalk */
#define	ENET_II			2
#define ENET_802_2		3
#define	ENET_802_3		5
#define ENET_SNAP		10
#define TOKN_RING		4
#define TOKN_RING_SNAP	11

/* Max number of active protocols - Should be plenty!! */
#define	MAX_PROTOS		10

/* AddProtocolID errors as defined on p. 15-8 of ODI Developer's Guide */
#define LSLERR_OUT_OF_RESOURCES	0x8001
#define LSLERR_BAD_PARAMETER	0x8002
#define LSLERR_DUPLICATE_ENTRY	0x8009

/* network hardware defines */
#define	ENET_HARDWARE			1
#define	TOKN_HARDWARE			2

/* size of standard IPX header */
#define	IPX_HDRSIZE				30

/* maximum Ethernet multicast addresses */
#define	MAX_ENET_MC_ADDRESSES	16

/************************  typedefs  ***********************/

typedef struct
{
	IU16	frameID;
	IU8		protoID[6];
	int		fd;
} ODIproto;

/* define a 6 byte quantity for use in the wds hdr */
typedef unsigned char   netAddr[6];

typedef	unsigned long	netNo	;

/* Note that word quantities in IPX headers are BIGEND */
typedef struct
{
	IU16		checksum	;	/* Checksum - always FFFF */
	IU16	 	IPXlength	;	/* Length according to IPX */
	IU8			transport	;	/* Count of bridges enountered? */
	IU8			type		;	/* Packet type - usually 0 or 4 */
	netNo		destNet		;	/* Destination network */
	netAddr		destNode	;	/* Destination Ethernet address */
	IU16		destSock	;	/* Destination socket */
	netNo		srcNet		;	/* Source network */
	netAddr		srcNode		;	/* Source Ethernet address */
	IU16		srcSock		;	/* Source socket */	
	IU8		 	data[547]	;	/* The packet */
} IPXPacket_s ;


typedef struct rcvPacket_t
{
	IU8			length[2];		/* Packet length if any */
	IU8			MAChdr[14];		/* MAC size - right for E2 & 802.3 */
	IPXPacket_s	pack;			/* The received IPX packet */
} rcvPacket_s ;


/* Host routine declarations */
extern	IU32	host_netInit IPT2 (IU16, frame, IU8 *, nodeAddr);
extern	void	host_termNet IPT0 ();

extern	IU32 	host_AddProtocol IPT2
	(IU16, frameType, IU8 *, protoID) ;
extern	void 	host_DelProtocol IPT2
	(IU16, frameType, IU8 *, protoID) ;

extern	void	host_sendPacket IPT2
	(sys_addr, theTCB, IU32, packLen) ;

extern	void	host_AddEnetMCAddress IPT1 (IU8 *, address);
extern	void	host_DeleteEnetMCAddress IPT1 (IU8 *, address);

extern	void	host_changeToknMultiCast IPT2
	(IU16, addrPt1, IU16, addrPt2);

extern	void	host_changePromiscuous IPT2
	(IU16, boardNo, IU16, enableDisableMask ) ;

extern	IU16	host_OpenSocket IPT1 (IU16, socketNumber);
extern	void	host_CloseSocket IPT1 (IU16, socketNumber);

/* Base routine declarations */
extern	void	movReadBuffIntoM IPT0 ();
extern	void	DriverInitialize IPT0 ();
extern	void	DriverSendPacket IPT0 ();
extern	void	DriverReadPacket IPT0 ();
extern	void	DriverMulticastChange IPT0 ();
extern	void	DriverShutdown IPT0 ();
extern	void	DriverAddProtocol IPT0 ();
extern	void	DriverChangePromiscuous IPT0 ();
extern	void	DriverCheckForMore IPT0 ();
#ifdef V4CLIENT
extern	void	ODIChangeIntStatus IPT1 ( IU16, status ) ;
#endif	/* V4CLIENT */
extern	void	net_term IPT0 ();

/* misc defines */

#ifndef PROD
#define		NOT_FOR_PRODUCTION( someCode )  someCode ;
#else
#define		NOT_FOR_PRODUCTION( someCode ) 
#endif

/********************** end of novell.h *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\printer.h ===
#ifdef	PRINTER

/*
 * SoftPC Revision 2.0
 *
 * Title	: IBM PC Parallel Printer Adaptor definitions
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the Parallel Printer adaptor emulation
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	:
 */ 

/* SccsID[]="@(#)printer.h	1.7 11/14/94 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#if defined(NEC_98)
extern  void printer_init();
extern  void printer_post();
extern  void printer_status_changed();

#define LPT1_READ_DATA          0x40
#define LPT1_WRITE_DATA         0x40
#define LPT1_READ_SIGNAL1       0x42
#define LPT1_READ_SIGNAL2       0x44
#define LPT1_WRITE_SIGNAL2      0x44
#define LPT1_WRITE_SIGNAL1      0x46
#else  // !NEC_98
#ifdef ANSI
extern	void printer_init(int);
extern	void printer_post(int);
extern	void printer_status_changed(int);
#else
extern	void printer_init();
extern	void printer_post();
extern	void printer_status_changed();
#endif

#ifdef PS_FLUSHING
extern void printer_psflush_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* PS_FLUSHING */

/*
 * The following 6 defines refer to the address in the BIOS data area
 * at which the LPT port addresses and timeout values can be found.
 * The actual values for the port addresses (LPT1_PORT_START and  ..._END)
 * are defined in host_lpt.h
 */
#define LPT1_PORT_ADDRESS	(BIOS_VAR_START + 8)
#define LPT2_PORT_ADDRESS	(BIOS_VAR_START + 0xa)
#define LPT3_PORT_ADDRESS	(BIOS_VAR_START + 0xc)

#define LPT1_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x78)
#define LPT2_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x79)
#define LPT3_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x7a)

#if defined(NTVDM)
extern void printer_is_being_closed(int adapter);
#endif
#endif // !NEC_98

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\quick_ev.h ===
/*[
************************************************************************
	Name:			quick_ev.h
	Author:			WTG Charnell
	Created:		Unknown
	Sccs ID:		@(#)quick_ev.h	1.20 06/08/95

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

	Purpose:		Quick Event Manager definitions
	Description:		Definitions for users of the quick
				event manager

************************************************************************
]*/

#include	"host_qev.h"	/* for q_ev_handle typedef */

typedef void (*Q_CALLBACK_FN) IPT1(long, parm);

extern void q_event_init IPT0();
extern void delete_q_event IPT1(q_ev_handle, handle);
extern void dispatch_q_event IPT0();
extern void delete_tic_event IPT1(q_ev_handle, handle);
extern void tic_event_init IPT0();
extern q_ev_handle add_tic_event IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);
extern q_ev_handle add_q_event_i IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);
extern q_ev_handle add_q_event_t IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);

#ifndef NTVDM
extern q_ev_handle add_q_ev_int_action IPT5(unsigned long, time, Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, param);
#endif

#ifndef CPU_40_STYLE
/*
 * Host access routines for 3.0 CPU (4.0 supplies its own prototypes
 * in generated include files).
 */
#ifndef host_calc_q_ev_inst_for_time
extern ULONG host_calc_q_ev_inst_for_time IPT1( ULONG, time );
#endif /* host_calc_q_ev_inst_for_time */
#ifdef NTVDM
extern ULONG host_calc_q_ev_time_for_inst IPT1(ULONG, inst);
#endif

extern void host_q_ev_set_count IPT1( ULONG, count );
extern ULONG host_q_ev_get_count IPT0();

#else	/* CPU_40_STYLE */
extern IU32 calc_q_inst_for_time IPT1(IU32, time);
extern IU32 calc_q_time_for_inst IPT1(IU32, inst);
#define host_calc_q_ev_inst_for_time      calc_q_inst_for_time
#define host_calc_q_ev_time_for_inst      calc_q_time_for_inst
#endif	/* CPU_40_STYLE */

#ifndef NTVDM
#ifdef CPU_40_STYLE

/* data structure used to control add_q_ev_int_action requests */
typedef struct aqeia_req {
	IS32 ident;		/* queue identifier, 0 - unused */
	Q_CALLBACK_FN func;
	IU32 adapter;
	IU32 line;
	IU32 param;
	struct aqeia_req *next;
} Q_INT_ACT_REQ, *Q_INT_ACT_REQ_PTR;

#define Q_INT_ACT_NULL	((Q_INT_ACT_REQ_PTR)0)

#endif  /* CPU_40_STYLE */

#endif  /* !NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\profile.h ===
/*[
*************************************************************************

	Name:		profile.h
	Author:		Simon Frost
	Created:	September 1993
	Derived from:	Original
	Sccs ID:	@(#)profile.h	1.9 01/31/95
	Purpose:	Include file for the Profiling system & Interfaces

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

/* ------------------- Data Structures & Types -------------------- */
typedef ISM32 EOIHANDLE;
typedef ISM32 SOIHANDLE;

/*
 * Two IUHs to allow for variety of host timestamp data. May be secs/usecs
 * or large integer or whatever is appropriate.
 */
typedef struct {
    IUH data[2];
} PROF_TIMESTAMP, *PROF_TIMEPTR;

typedef struct {
    IUH eoiHandle;
    PROF_TIMESTAMP timestamp;
    IUH arg;
} EOI_BUFFER_FORMAT;

typedef struct eoinode EOINODE, *EOINODE_PTR;	/* forward decln */
typedef struct eoiarg EOIARG, *EOIARG_PTR;	/* ditto */
typedef struct graphlist GRAPHLIST, *GRAPHLIST_PTR;	/* ditto */

/* Active SOIs (Sequences Of Interest) stored in list of these nodes */
typedef struct soinode {

    SOIHANDLE handle;		/* SOI identifier */
    EOIHANDLE startEOI;		/* EOI of start event */
    EOIHANDLE endEOI;		/* EOI of end event */
    EOIARG_PTR startArg;	/* extra level graphing - start arg */
    EOIARG_PTR endArg;		/* extra level graphing - end arg */
    IUM32 startCount;		/* # of times start EOI occured */
    IUM32 endCount;		/* # of times end EOI occured */
    PROF_TIMESTAMP soistart;	/* timestamp of SOI start */
    struct soinode *next;	/* pointer to next SOI */
    IU8 flags;			/* flags for this SOI */
    DOUBLE time;		/* usecs spent in SOI - daft times ignored */
    DOUBLE maxtime;		/* longest valid elapsed time */
    DOUBLE mintime;		/* shortest elapsed time */
    DOUBLE bigmax;		/* longest invalid time */
    DOUBLE bigtime;		/* total contributed by daft times */
    IUM32 discardCount;		/* # of discarded times */

} SOINODE, *SOINODE_PTR;

#define SOIPTRNULL (SOINODE_PTR)0

/* Active Events linked to Active SOIs by pointers to SOI structures */
typedef struct soilist {

    SOINODE_PTR soiLink;	/* SOI that this event starts/ends */
    struct soilist *next;	/* next active SOI */

} SOILIST, *SOILIST_PTR;

#define SLISTNULL (SOILIST_PTR)0

/* Events which contain arguments hold them in sorted list of these nodes */
struct eoiarg {

    struct eoiarg *next;	/* pointer to next argument value */
    struct eoiarg *back;	/* previous argument node */
    IUM32 count;		/* how many events have had this value */
    IUM32 value;		/* event argument this node represents */
    SOILIST_PTR startsoi;	/* SOIs which this arg starts if auto SOI */
    SOILIST_PTR endsoi;		/* SOIs which this arg ends if auto SOI */
    GRAPHLIST_PTR graph;	/* pointer into graph list for this node */

};

#define ARGPTRNULL (EOIARG_PTR)0

/*
 * This structure is used to form the list used in EOI graphing.
 * It gives two links for 'free' and then goes off down a chain of more 
 * succession links. (This gives loops & if's in one struct).
 * Pointers to these nodes can be found in EOI nodes and EOI argument nodes.
 */
struct graphlist {
    struct graphlist *next;	/* list connecting pointer -not graph related */
    EOINODE_PTR  graphEOI;	/* EOI for graph node */
    EOIARG_PTR graphArg;	/* EOI argument if relevant */
    IUM32 numpred;		/* how many predecessors */
    IUM32 numsucc;		/* how many succecessors */
    struct graphlist *succ1;	/* pointer to first successor */
    IUM32 succ1Count;		/* # of times first successor found */
    struct graphlist *succ2;	/* pointer to second successor */
    IUM32 succ2Count;		/* # of times second successor found */
    struct graphlist *extra;	/* if two successors not enuf look here */
    ISM32 indent;		/* for report printing */
    IU8 state;			/* flags for node state */
};

/* defines for graph state (bits) on reporting */
#define GR_SUCC1_TROD	1
#define GR_SUCC2_TROD	2
#define GR_TRAMPLED    (GR_SUCC1_TROD|GR_SUCC2_TROD)
#define GR_PRINTED	4

#define GRAPHPTRNULL	(GRAPHLIST_PTR)0

/*
 * If a SOI is registered at the arg level & collects sequences between 'same valued'
 * args, the endEOI of the pair must be available from the start EOI. The start EOI
 * contains a pointer to a list in the following format.
 */
struct soiargends {
	EOIHANDLE endEOI;
	struct soiargends *next;
};

typedef struct soiargends SOIARGENDS, *SOIARGENDS_PTR;

#define SOIARGENDNULL	(SOIARGENDS_PTR)0

/*
 * Active Events registered for profiling run are stored in list(s) of these
 * nodes.
 */
struct eoinode {

    struct eoinode *next;	/* pointer to next event */
    struct eoinode *back;	/* pointer to previous event */
    IUM32 count;		/* # of times EOI occured */
    EOIHANDLE handle;		/* EOI identifier */
    CHAR *tag;			/* 'real world' identifier */
    EOIARG_PTR args;		/* list of arguments to event (may be null) */
    EOIARG_PTR lastArg;		/* last argument node accessed */
    PROF_TIMESTAMP timestamp;	/* time of last EOI (usec) */
    SOILIST_PTR startsoi;	/* SOI pointers which this event starts */
    SOILIST_PTR endsoi;		/* SOI pointers which this event ends */
    GRAPHLIST_PTR graph;	/* pointer to graph list for this node */
    SOIARGENDS_PTR argsoiends;	/* arg level 'same value' end list */
    IU16 flags;			/* characteristics of this EOI */

};

#define EOIPTRNULL (EOINODE_PTR)0

/*
 * This structure mirrors the initial elements of those lists we may
 * want to sort into 'popularity' order (based on the 'count' element).
 * This is intended to reduce search times for common elements
 */
typedef struct sortlist {
    struct sortlist *next;	/* pointer to next element */
    struct sortlist *back;	/* pointer to previous element */
    IUM32 count;		/* # of times element occured */
} *SORTSTRUCT, **SORTSTRUCT_PTR;

/* New SOI flags */
#define SOI_DEFAULTS	0	/* No flags  - default settings */
#define SOI_AUTOSOI	0x20	/* SOI generated by AUTOSOI */
#define SOI_FROMARG	0x40	/* SOI generated by arg level connection */

/* New EOI 'capability' flags */
#define EOI_DEFAULTS	0	/* No flags  - default settings */
#define EOI_DISABLED	1	/* Delay EIO until enable call. */
#define EOI_KEEP_GRAPH	2	/* Track Predecessors for graphing */
#define EOI_KEEP_ARGS	4	/* Keep & count arguments passed */
#define EOI_ENABLE_ALL	8	/* Trigger enable of all EOIs */
#define EOI_DISABLE_ALL	0x10	/* Trigger disable of all EOIs */
#define EOI_AUTOSOI	0x20	/* Make SOIs automatically out of like EOIs */
#define EOI_HOSTHOOK	0x40	/* Hook out to host profiling system */
#define EOI_NOTIME	0x80	/* No timestamps needed (not in SOI) */

/* The above get used in the EOI node flag element. This also contains 
 * extra info as specified below.
 */
#define EOI_HAS_SOI	0x100	/* some SOI associated with this EOI */
#define EOI_NEW_ARGS_START_SOI	0x200	/* arg level soi with 'same value' ends */

/* Mask used to clear new eoi flags for enable table */
#define ENABLE_MASK (EOI_DISABLED|EOI_ENABLE_ALL|EOI_DISABLE_ALL|EOI_HOSTHOOK)

/* ---------------------- Interfaces -------------------------- */
extern IBOOL Profiling_enabled;           /* conventional profiling Disabled?  */

extern EOIHANDLE NewEOI IPT2(CHAR *, tag, IU8, flags);

extern void SetEOIAsHostTrigger IPT1(EOIHANDLE, handle);
extern void ClearEOIAsHostTrigger IPT1(EOIHANDLE, handle);
extern void SetEOIAutoSOI IPT1(EOIHANDLE, handle);
extern void ClearEOIAutoSOI IPT1(EOIHANDLE, handle);
extern void EnableEOI IPT1(EOIHANDLE, handle);
extern void EnableAllEOIs IPT0();
extern void DisableEOI IPT1(EOIHANDLE, handle);
extern void DisableAllEOIs IPT0();
extern void ResetEOI IPT1(EOIHANDLE, handle);
extern void ResetAllEOIs IPT0();
extern void ResetAllSOIs IPT0();

extern void AtEOIPoint IPT1(EOIHANDLE, handle);
extern void AtEOIPointArg IPT2(EOIHANDLE, handle, IUH, arg);

extern CHAR *GetEOIName IPT1(EOIHANDLE, handle);

extern SOIHANDLE AssociateAsSOI IPT2(EOIHANDLE, start, EOIHANDLE, end);
extern SOIHANDLE AssociateAsArgSOI IPT5(EOIHANDLE, start, EOIHANDLE, end,
				IUM32, startArg, IUM32, endArg, IBOOL, sameArgs);

extern void GenerateAllProfileInfo IPT1(FILE *, stream);
extern void CollateFrequencyList IPT2(FILE *, stream, IBOOL, reportstyle);
extern void CollateSequenceGraph IPT1(FILE *, stream);
extern void SummariseEvent IPT2(FILE *, stream, EOIHANDLE, handle);
extern void SummariseSequence IPT2(FILE *, stream, SOIHANDLE, handle);
extern void SummariseAllSequences IPT1(FILE *, stream);
extern void OrderedSequencePrint IPT3(SOIHANDLE, startEOI, SOIHANDLE, endEOI, FILE *, stream);
extern void dump_profile IPT0();
extern void reset_profile IPT0();

/* support fns for Frag Profiling */
extern void EnableFragProf IPT0();
extern void DisableFragProf IPT0();
extern void DumpFragProfData IPT0();


extern void ProcessProfBuffer IFN0();
extern void ProfileInit IFN0();

extern EOI_BUFFER_FORMAT **GdpProfileInit IPT3 (EOI_BUFFER_FORMAT, *rawDataBuf,
			 EOI_BUFFER_FORMAT, *endRawData,
			 IU8, *enable);
extern EOI_BUFFER_FORMAT **GdpProfileUpdate IPT2 (EOI_BUFFER_FORMAT, *rawDataBuf, IU8, *enable);


/* Declns for host i/f */
#ifdef NTVDM
extern void HostEnterProfCritSec IPT0();
extern void HostLeaveProfCritSec IPT0();
#else
#define HostEnterProfCritSec()	/* Nothing */
#define HostLeaveProfCritSec()	/* Nothing */
#endif
extern PROF_TIMEPTR HostTimestampDiff IPT2(PROF_TIMEPTR, tbegin, PROF_TIMEPTR, tend);
extern void HostAddTimestamps IPT2(PROF_TIMEPTR, tbase, PROF_TIMEPTR, taddn);
extern void HostSlipTimestamp IPT2(PROF_TIMEPTR, tbase, PROF_TIMEPTR, tdelta);
extern void HostWriteTimestamp IPT1(PROF_TIMEPTR, addr);
extern void HostPrintTimestamp IPT2(FILE *, stream, PROF_TIMEPTR, stamp);
extern char *HostProfInitName IPT0();
extern void HostProfHook IPT0();
extern void HostProfArgHook IPT1(IUH, arg);
extern double HostProfUSecs IPT1(PROF_TIMEPTR, stamp);
extern IU32 HostGetClocksPerSec IPT0();
extern IU32 HostGetProfsPerSec IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\rtc_bios.h ===
/* @(#)rtc_bios.h	1.4 08/10/92 Copyright Insignia Solutions Ltd.

FILE NAME	: rtc_bios.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: OCT '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
#define	USER_FLAG		(BIOS_VAR_START + 0x98)
#define USER_FLAG_SEG		(BIOS_VAR_START + 0x9A)
#define RTC_LOW			(BIOS_VAR_START + 0x9C)
#define	RTC_HIGH		(BIOS_VAR_START + 0x9E)
#define RTC_WAIT_FLAG_ADDR	(BIOS_VAR_START + 0xA0)

#define rtc_wait_flag		RTC_WAIT_FLAG_ADDR

#define TIME_DEC		50000L		/* 1000000/20 assumes 20 interrupts/sec	*/

typedef	union	{
		double_word	total;
		struct	{ 
			word	high;
			word	low;
			}	half;
		} DOUBLE_TIME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\rommap.h ===
/*[
 *
 *	File		:	rommap.h
 *
 *	Derived from	:	(original)
 *
 *	Purpose		:	structure for full screen host api to fill in
 *				describing the location of host ROMs
 *
 *	Author		:	Rog
 *	Date		:	15 March 1992
 *
 *	RCS Gumph	:	
 *		$Source: /MasterNeXT486/RCStree/base/inc/rommap.h,v $
 *		$Revision: 1.1 $
 *		$Date: 93/03/18 12:18:26 $
 *		$Author: rog $
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifndef _ROMMAP_H_
#define _ROMMAP_H_


/* Structure to hold a PC address range to describe a single mapping */

typedef struct
{
	unsigned int	startAddress;
	unsigned int	endAddress;
} mapRange , * pMapRange;


/*
	Structure to describe the state of the host machines IVT after boot up
	and a *all* the mappings performed

	Note that size of structure in use will be sizeof( romMapInfo ) + 
		numberROMS * sizeof( mapRange ) ....
*/

typedef struct
{
	unsigned char	* initialIVT;	/* ptr to read only 4k buffer...*/
	unsigned int	numberROMs;	/* Number of discrete mappings */
	mapRange	ROMaddresses[ 0 ];
}
ROMMapInfo , * pROMMapInfo;

#endif		/* _ROMMAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\sasp.h ===
/*[
 * File Name		: sasp.h
 *
 * Derived From		: Template
 *
 * Author		: Mike
 *
 * Creation Date	: October 93
 *
 * SCCS Version		: @(#)sasp.h	1.2 12/20/93
 *!
 * Purpose
 *	This module holds and maintains the SAS function pointers.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
]*/

extern void SasSetPointers IPT1(struct SasVector *, newPointers);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\rs232.h ===
#ifndef _RS232_H
#define _RS232_H

/*[
	Name:		rs232.h
	Derived From:	Base 2.0
	Author:		Paul Huckle
	Created On:	
	Sccs ID:	05/11/94 @(#)rs232.h	1.14
	Purpose:	Definitions for users of the RS232 Adapter Module

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifndef NEC_98
/* register type definitions follow: */

typedef half_word BUFFER_REG;

#ifdef LITTLEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD LSByte:8;
      WORD_BIT_FIELD MSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#ifdef BIGEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD MSByte:8;
      WORD_BIT_FIELD LSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#else //NEC_98
/* register type definitions follow: */

// Date read/write port
//      I/O port address ch.1 = 0x30 , ch.2 = 0xB1 , ch.3 = 0xB9
typedef half_word BUFFER_REG;

// Timer counter image table
//      I/O port address ch.1 = 0x75 (ch.1 only)
#ifdef LITTLEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD LSByte:8;
      WORD_BIT_FIELD MSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#ifdef BIGEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD MSByte:8;
      WORD_BIT_FIELD LSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif

// Command port bit image table
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                             // Command port 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD tx_enable:1;
         HALF_WORD_BIT_FIELD ER:1;
         HALF_WORD_BIT_FIELD rx_enable:1;
         HALF_WORD_BIT_FIELD send_break:1;
         HALF_WORD_BIT_FIELD error_reset:1;
         HALF_WORD_BIT_FIELD RS:1;
         HALF_WORD_BIT_FIELD inter_reset:1;
         HALF_WORD_BIT_FIELD pad:1;
           } bits;
      } COMMAND8251;
#endif
#ifdef BIT_ORDER1
typedef union {                             // Command port 8251
   half_word all;
    struct {
         HALF_WORD_BIT_FIELD pad:1;
         HALF_WORD_BIT_FIELD inter_reset:1;
         HALF_WORD_BIT_FIELD RS:1;
         HALF_WORD_BIT_FIELD error_reset:1;
         HALF_WORD_BIT_FIELD send_break:1;
         HALF_WORD_BIT_FIELD rx_enable:1;
         HALF_WORD_BIT_FIELD ER:1;
         HALF_WORD_BIT_FIELD tx_enable:1;
           } bits;
      } COMMAND8251;
#endif

// Mode set port bit image table.
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                                 // Mode port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD baud_rate:2;
         HALF_WORD_BIT_FIELD char_length:2;
         HALF_WORD_BIT_FIELD parity_enable:1;
         HALF_WORD_BIT_FIELD parity_even:1;
         HALF_WORD_BIT_FIELD stop_bit:2;
           } bits;
      } MODE8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Mode port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD stop_bit:2;
         HALF_WORD_BIT_FIELD parity_even:1;
         HALF_WORD_BIT_FIELD parity_enable:1;
         HALF_WORD_BIT_FIELD char_length:2;
         HALF_WORD_BIT_FIELD baud_rate:2;
           } bits;
      } MODE8251;
#endif

// Mask set port bit image table.
//      I/O port address ch.1 = 0x35 , ch.2 = 0xB0 , ch.3 = 0xB2
//                                      (ch.2,3 is write only)
#ifdef BIT_ORDER2
typedef union {                                 // Mask port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD RXR_enable:1;
         HALF_WORD_BIT_FIELD TXE_enable:1;
         HALF_WORD_BIT_FIELD TXR_enable:1;
         HALF_WORD_BIT_FIELD pad:5;
           } bits;
      } MASK8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Mask port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD pad:5;
         HALF_WORD_BIT_FIELD TXR_enable:1;
         HALF_WORD_BIT_FIELD TXE_enable:1;
         HALF_WORD_BIT_FIELD RXR_enable:1;
           } bits;
      } MASK8251;
#endif

// Read status port bit image table
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                                 // Read status 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD tx_ready:1;
         HALF_WORD_BIT_FIELD rx_ready:1;
         HALF_WORD_BIT_FIELD tx_empty:1;
         HALF_WORD_BIT_FIELD parity_error:1;
         HALF_WORD_BIT_FIELD overrun_error:1;
         HALF_WORD_BIT_FIELD framing_error:1;
         HALF_WORD_BIT_FIELD break_detect:1;
         HALF_WORD_BIT_FIELD DR:1;
           } bits;
      } STATUS8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Read status 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD DR:1;
         HALF_WORD_BIT_FIELD break_detect:1;
         HALF_WORD_BIT_FIELD framing_error:1;
         HALF_WORD_BIT_FIELD overrun_error:1;
         HALF_WORD_BIT_FIELD parity_error:1;
         HALF_WORD_BIT_FIELD tx_empty:1;
         HALF_WORD_BIT_FIELD rx_ready:1;
         HALF_WORD_BIT_FIELD tx_ready:1;
           } bits;
      } STATUS8251;
#endif

// Read signal port bit image table.
//      I/O port address ch.1 = 0x33 , ch.2 = 0xB0 , ch.3 = 0xB2
//                               (ch.2,3 is bard IR level sence)
#ifdef BIT_ORDER2
typedef union {                                 // Read signal 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD IR:2;
         HALF_WORD_BIT_FIELD pad:3;
         HALF_WORD_BIT_FIELD CD:1;
         HALF_WORD_BIT_FIELD CS:1;
         HALF_WORD_BIT_FIELD RI:1;
           } bits;
      } SIGNAL8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Read signal 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD RI:1;
         HALF_WORD_BIT_FIELD CS:1;
         HALF_WORD_BIT_FIELD CD:1;
         HALF_WORD_BIT_FIELD pad:3;
         HALF_WORD_BIT_FIELD IR:2;
           } bits;
      } SIGNAL8251;
#endif

// Timer mode set port bit image table.
//      I/O port address ch.1 = 0x77
//                               (ch.1 only)
#ifdef BIT_ORDER2
typedef union {                                 // Timer mode set
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD bin:1;
         HALF_WORD_BIT_FIELD mode:3;
         HALF_WORD_BIT_FIELD latch:2;
         HALF_WORD_BIT_FIELD counter:2;
           } bits;
      } TIMER_MODE;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Timer mode set
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD counter:2;
         HALF_WORD_BIT_FIELD latch:2;
         HALF_WORD_BIT_FIELD mode:3;
         HALF_WORD_BIT_FIELD bin:1;
           } bits;
      } TIMER_MODE;
#endif
#endif //NEC_98

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD data_available:1;
		 HALF_WORD_BIT_FIELD tx_holding:1;
		 HALF_WORD_BIT_FIELD rx_line:1;
		 HALF_WORD_BIT_FIELD modem_status:1;
		 HALF_WORD_BIT_FIELD pad:4;
	       } bits;
      } INT_ENABLE_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:4;
		 HALF_WORD_BIT_FIELD modem_status:1;
		 HALF_WORD_BIT_FIELD rx_line:1;
		 HALF_WORD_BIT_FIELD tx_holding:1;
		 HALF_WORD_BIT_FIELD data_available:1;
	       } bits;
      } INT_ENABLE_REG;
#endif

#if defined(NTVDM) && defined(FIFO_ON)
#ifdef BIT_ORDER2
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD no_int_pending:1;
         HALF_WORD_BIT_FIELD interrupt_ID:3;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD fifo_enabled:2;
           } bits;
      } INT_ID_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD fifo_enabled:2;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD interrupt_ID:3;
         HALF_WORD_BIT_FIELD no_int_pending:1;
           } bits;
      } INT_ID_REG;
#endif
#else   /* NTVDM */

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD no_int_pending:1;
		 HALF_WORD_BIT_FIELD interrupt_ID:2;
		 HALF_WORD_BIT_FIELD pad:5;
	       } bits;
      } INT_ID_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:5;
		 HALF_WORD_BIT_FIELD interrupt_ID:2;
		 HALF_WORD_BIT_FIELD no_int_pending:1;
	       } bits;
      } INT_ID_REG;
#endif

#endif  /* ifdef NTVDM */

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD word_length:2;
		 HALF_WORD_BIT_FIELD no_of_stop_bits:1;
		 HALF_WORD_BIT_FIELD parity_enabled:1;
		 HALF_WORD_BIT_FIELD even_parity:1;
		 HALF_WORD_BIT_FIELD stick_parity:1;
		 HALF_WORD_BIT_FIELD set_break:1;
		 HALF_WORD_BIT_FIELD DLAB:1;
	       } bits;
      } LINE_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD DLAB:1;
		 HALF_WORD_BIT_FIELD set_break:1;
		 HALF_WORD_BIT_FIELD stick_parity:1;
		 HALF_WORD_BIT_FIELD even_parity:1;
		 HALF_WORD_BIT_FIELD parity_enabled:1;
		 HALF_WORD_BIT_FIELD no_of_stop_bits:1;
		 HALF_WORD_BIT_FIELD word_length:2;
	       } bits;
      } LINE_CONTROL_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD DTR:1;
		 HALF_WORD_BIT_FIELD RTS:1;
		 HALF_WORD_BIT_FIELD OUT1:1;
		 HALF_WORD_BIT_FIELD OUT2:1;
		 HALF_WORD_BIT_FIELD loop:1;
		 HALF_WORD_BIT_FIELD pad:3;
	       } bits;
      } MODEM_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:3;
		 HALF_WORD_BIT_FIELD loop:1;
		 HALF_WORD_BIT_FIELD OUT2:1;
		 HALF_WORD_BIT_FIELD OUT1:1;
		 HALF_WORD_BIT_FIELD RTS:1;
		 HALF_WORD_BIT_FIELD DTR:1;
	       } bits;
      } MODEM_CONTROL_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD data_ready:1;
		 HALF_WORD_BIT_FIELD overrun_error:1;
		 HALF_WORD_BIT_FIELD parity_error:1;
		 HALF_WORD_BIT_FIELD framing_error:1;
		 HALF_WORD_BIT_FIELD break_interrupt:1;
		 HALF_WORD_BIT_FIELD tx_holding_empty:1;
		 HALF_WORD_BIT_FIELD tx_shift_empty:1;
#if defined(NTVDM) && defined(FIFO_ON)
		 HALF_WORD_BIT_FIELD fifo_error:1;
#else
		 HALF_WORD_BIT_FIELD pad:1;
#endif
	       } bits;
      } LINE_STATUS_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
#if defined(NTVDM) && defined(FIFO_ON)
		 HALF_WORD_BIT_FIELD fifo_error:1;
#else
		 HALF_WORD_BIT_FIELD pad:1;
#endif
		 HALF_WORD_BIT_FIELD tx_shift_empty:1;
		 HALF_WORD_BIT_FIELD tx_holding_empty:1;
		 HALF_WORD_BIT_FIELD break_interrupt:1;
		 HALF_WORD_BIT_FIELD framing_error:1;
		 HALF_WORD_BIT_FIELD parity_error:1;
		 HALF_WORD_BIT_FIELD overrun_error:1;
		 HALF_WORD_BIT_FIELD data_ready:1;
	       } bits;
      } LINE_STATUS_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD delta_CTS:1;
		 HALF_WORD_BIT_FIELD delta_DSR:1;
		 HALF_WORD_BIT_FIELD TERI:1;
		 HALF_WORD_BIT_FIELD delta_RLSD:1;
		 HALF_WORD_BIT_FIELD CTS:1;
		 HALF_WORD_BIT_FIELD DSR:1;
		 HALF_WORD_BIT_FIELD RI:1;
		 HALF_WORD_BIT_FIELD RLSD:1;
	       } bits;
      } MODEM_STATUS_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD RLSD:1;
		 HALF_WORD_BIT_FIELD RI:1;
		 HALF_WORD_BIT_FIELD DSR:1;
		 HALF_WORD_BIT_FIELD CTS:1;
		 HALF_WORD_BIT_FIELD delta_RLSD:1;
		 HALF_WORD_BIT_FIELD TERI:1;
		 HALF_WORD_BIT_FIELD delta_DSR:1;
		 HALF_WORD_BIT_FIELD delta_CTS:1;
	       } bits;
      } MODEM_STATUS_REG;
#endif

#if defined(NEC_98)
/* register select code definitions follow: */

#define RS232_CH1_TX_RX         0x30            //
#define RS232_CH2_TX_RX         0xB1            // Data read/write port address
#define RS232_CH3_TX_RX         0xB9            //

#define RS232_CH1_CMD_MODE      0x32            // Command write ,
#define RS232_CH2_CMD_MODE      0xB3            //  mode set port address
#define RS232_CH3_CMD_MODE      0xBB            //

#define RS232_CH1_STATUS        0x32            //
#define RS232_CH2_STATUS        0xB3            //  status read  port address
#define RS232_CH3_STATUS        0xBB            //

#define RS232_CH1_MASK          0x35            //
#define RS232_CH2_MASK          0xB0            // IR mask set port address
#define RS232_CH3_MASK          0xB2            //

#define RS232_CH1_SIG           0x33            //
#define RS232_CH2_SIG           0xB0            // Signal read port address
#define RS232_CH3_SIG           0xB2            //

#define RS232_CH1_TIMERSET      0x77            // Timer set port address (ch.1 only)
#define RS232_CH1_TIMERCNT      0x75            // Timer counter set port address (ch.1 only)

#else  // !NEC_98
#if defined(NTVDM) && defined(FIFO_ON)
/* refer to NS 16550A data sheet for fifo control register description
   DMA is not supported because so far there are not such a COMM adapter with
   DMA channel  out there
*/
#ifdef BIT_ORDER2
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD enabled:1;
         HALF_WORD_BIT_FIELD rx_reset:1;
         HALF_WORD_BIT_FIELD tx_reset:1;
         HALF_WORD_BIT_FIELD dma_mode_selected:1;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD trigger_level:2;
           } bits;
      } FIFO_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD trigger_level:2;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD dma_mode_selected:1
         HALF_WORD_BIT_FIELD tx_reset:1;
         HALF_WORD_BIT_FIELD rx_reset:1
         HALF_WORD_BIT_FIELD enabled:1;
           } bits;
      } FIFO_CONTROL_REG;
#endif

#endif

/* register select code definitions follow: */

#define RS232_TX_RX	0
#define RS232_IER	1
#define RS232_IIR	2
#if defined(NTVDM) && defined(FIFO_ON)
#define RS232_FIFO  2
#endif
#define RS232_LCR	3
#define RS232_MCR	4
#define RS232_LSR	5
#define RS232_MSR	6
#define RS232_SCRATCH	7
#endif // !NEC_98

#define RS232_COM1_TIMEOUT (BIOS_VAR_START + 0x7c)
#define RS232_COM2_TIMEOUT (BIOS_VAR_START + 0x7d)
#define RS232_COM3_TIMEOUT (BIOS_VAR_START + 0x7e)
#define RS232_COM4_TIMEOUT (BIOS_VAR_START + 0x7f)
#define RS232_PRI_TIMEOUT (BIOS_VAR_START + 0x7c)
#define RS232_SEC_TIMEOUT (BIOS_VAR_START + 0x7d)

#define GO 0           /* We can emulate requested configuration */
#define NO_GO_SPEED 1  /* We can't emulate requested line speed */
#define NO_GO_LINE  2  /* We can't emulate requested line setup */

#if defined(NTVDM) && defined(FIFO_ON)
/* fifo size defined in NS16550 data sheet */
#define FIFO_SIZE   16
/* the real fifo size in our simulation code. Increase this will get
   a better performance(# rx interrupts going down and read call count to
   the serial driver also going down). However, if application is using
   h/w handshaking, we may still delivery extra chars to it. This may provoke
   the app. By using 16bytes fifo, we are safe because the application
   must have logic to handle it.
*/

#define FIFO_BUFFER_SIZE    FIFO_SIZE
#endif

#define OFF 0
#define ON 1
#define LEAVE_ALONE 2
#define	change_state(external_state, internal_state) \
	((external_state == internal_state) ? LEAVE_ALONE : external_state)

#if defined(NTVDM) && defined(FIFO_ON)
#define FIFO_INT 6   /* fifo rda time out interrupt ID */
#endif

#define RLS_INT 3     /* receiver line status interrupt ID */
#define RDA_INT 2     /* data available interrupt ID */
#define THRE_INT 1    /* tx holding register empty interrupt ID */
#define MS_INT 0      /* modem status interrupt ID */

#define DATA5 0       /* line control setting for five data bits */
#define DATA6 1       /* line control setting for six data bits */
#define DATA7 2       /* line control setting for seven data bits */
#define DATA8 3       /* line control setting for eight data bits */

#define STOP1 0       /* line control setting for one stop bit */
#define STOP2 1       /* line control setting for one and a half or two
                         stop bits */

#ifdef NTVDM
// collision with winbase.h PARITY_ON define
#define PARITYENABLE_ON 1   /* line control setting for parity enabled */
#define PARITYENABLE_OFF 0  /* line control setting for parity disabled */
#else
#define PARITY_ON 1   /* line control setting for parity enabled */
#define PARITY_OFF 0  /* line control setting for parity disabled */
#endif

#ifdef NTVDM
// collision with winbase.h PARITY_ODD define
#define EVENPARITY_ODD 0  /* line control setting for odd parity */
#define EVENPARITY_EVEN 1 /* line control setting for even parity */
#else
#define PARITY_ODD 0  /* line control setting for odd parity */
#define PARITY_EVEN 1 /* line control setting for even parity */
#endif

#define PARITY_STICK 1  /* line control setting for stick(y) parity */

#define PARITY_FIXED 2  /* Internal state setting for fixed parity */

#if defined(NEC_98)
#define COM1 0
#define COM2 1
#define COM3 2
#else  // !NEC_98
#define COM1 0
#define COM2 1
#if (NUM_SERIAL_PORTS > 2)
#define COM3 2
#define COM4 3
#endif
#endif // !NEC_98

#if defined(NTVDM) && defined(FIFO_ON)
typedef     struct _FIFORXDATA{
    half_word   data;
    half_word   error;
}FIFORXDATA, *PFIFORXDATA;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void com_init IPT1(int, adapter);
extern void com_post IPT1(int, adapter);

extern void com_flush_printer IPT1(int, adapter);

extern void com_inb IPT2(io_addr, port, half_word *, value);
extern void com_outb IPT2(io_addr, port, half_word, value);

extern void com_recv_char IPT1(int, adapter);
extern void recv_char IPT1(long, adapter);
extern void com_modem_change IPT1(int, adapter);
extern void com_save_rxbytes IPT2(int,n, CHAR *,buf);
extern void com_save_txbyte IPT1(CHAR,value);

#ifdef PS_FLUSHING
extern void com_psflush_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* PS_FLUSHING */

#ifdef NTVDM
extern void com_lsr_change(int adapter);
#endif

#if defined(NEC_98)
#define adapter_for_port(port) \
        (( (port == 0x30) || (port == 0x32) || (port == 0x33) || (port == 0x35) || (port == 0x75) ) ? COM1 :\
    (( (port == 0xB0) || (port == 0xB1) || (port == 0xB3) ) ? COM2 : COM3))

#ifdef SHORT_TRACE
#define id_for_adapter(adapter)         (adapter + '1')
#endif

#else  // !NEC_98
#if (NUM_SERIAL_PORTS > 2)
#define	adapter_for_port(port) \
	(((port & 0x300) == 0x300) ? \
		(((port & 0xf8) == 0xf8) ? COM1 : COM3) \
		        : \
		(((port & 0xf8) == 0xf8) ? COM2 : COM4))

#ifdef SHORT_TRACE
#define	id_for_adapter(adapter)	 	(adapter + '1')
#endif

#else

#define	adapter_for_port(port)	(((port) >= RS232_PRI_PORT_START && (port) <= RS232_PRI_PORT_END) ? COM1 : COM2)


#ifdef SHORT_TRACE
#define	id_for_adapter(adapter)	(adapter == COM1 ? 'P' : 'S')
#endif
#endif /* more than 2 serial ports */
#endif // !NEC_98

#ifdef IRET_HOOKS
/*
 * A macro we need for IRET hooks, the number of bits in a an async
 * character on a comms line, which is about 8 (for the character)
 * plus two stop bits.
 */
#define BITS_PER_ASYNC_CHAR 10
#endif /* IRET_HOOKS */

/* BCN 2730 define generic macros which can be SVID3 or old style
 * in either case the structure used should be a termios
 */

#ifdef SVID3_TCGET
#define	TCGET TCGETS
#define	TCSET TCSETS
#define	TCSETF TCSETSF
#else
#define	TCGET TCGETA
#define	TCSET TCSETA
#define	TCSETF TCSETAF
#endif	/* SVID3_TCGET */

#endif /* _RS232_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\sas.h ===
/*
*
*	Ade Brownlow	
*	Tue Dec 11 90	
*
*	sas.h 
*
*	This file replaces the old sas.h. Macros are no longer used for
*	the sas functions they are always functions. This file takes
*	into account backward M .
*
*	Mike - Oct 93
*	A lot of these interfaces aren't used in 3.0, so we'll cut them out
*	of 4.0 altogether.  Use of them in the base is hence depricated!
*
*	4.0 also switches to function pointers, so there's a pretty big
*	#ifdef CPU_40_STYLE in here.
*
*	By the way, Jeremy has documented this interface in
*	HWRD/SOFT486(SAS)/DES
*
*	SccsID: @(#)sas.h	1.70 07/07/95
*
*/

#include "host_sas.h"

/* memory types for sas */

#ifdef CPU_40_STYLE

typedef enum  { 
	SAS_RAM, 
	SAS_VIDEO, 
	SAS_ROM, 
	SAS_WRAP, 
	SAS_IO, 
	SAS_MM_LIM, 
	SAS_INACCESSIBLE,
	SAS_DANGEROUS 
} SAS_MEM_TYPE;
#define SAS_VDD SAS_IO
#define SAS_MAX_TYPE		SAS_DANGEROUS

#else /* CPU_40_STYLE */

#define SAS_RAM			0
#define SAS_VIDEO		1
#define SAS_ROM			2
#define SAS_WRAP		3
#define SAS_IO			4
#define SAS_MM_LIM		5
#define SAS_INACCESSIBLE	6
#define SAS_DANGEROUS		7
#define SAS_MAX_TYPE		SAS_DANGEROUS

#endif /* CPU_40_STYLE else */

#define SAS_TYPE_TO_STRING(type) (\
		((type) == SAS_RAM)? "RAM" :\
		((type) == SAS_VIDEO)? "VIDEO" :\
		((type) == SAS_ROM)? "ROM" :\
		((type) == SAS_WRAP)? "WRAP" :\
		((type) == SAS_IO)? "IO" :\
		((type) == SAS_MM_LIM)? "MM_LIM" :\
		((type) == SAS_INACCESSIBLE)? "INACCESSIBLE" :\
		((type) == SAS_DANGEROUS)? "DANGEROUS" :\
		"UNKNOWN TYPE")


/* one #defined function */
#define sas_disconnect_memory(l,h) sas_connect_memory(l,h,SAS_INACCESSIBLE);

#ifdef CPU_40_STYLE


/********************************************************/
/*
 * This interface now uses function pointers, so we need to set up
 * a set of macros with the traditional SAS names that will pick-up
 * the functions pointed to.
 *
 * sas_init and sas_term don't use pointers
 */

#define sas_load(addr, val) *val = sas_hw_at(addr)
#define sas_loadw(addr, val) *val = sas_w_at(addr)
#define sas_loaddw(addr, val) *val = sas_dw_at(addr)

extern void sas_init IPT1(PHY_ADDR, size);
extern void sas_term IPT0();

#include	<sas4gen.h>

#ifdef NTVDM
#ifdef CCPU
extern IU8 *c_GetLinAdd IPT1(IU32, lin_addr);
#define NtGetPtrToLinAddrByte(x) c_GetLinAdd(x)
#else /* !CCPU */
extern IU8 *NtGetPtrToLinAddrByte IPT1(IU32, lin_addr);
#endif /* CCPU */
#endif /* NTVDM */

/*
 * TEMPORARY FOR NT!!!!!
 */

extern host_addr Start_of_M_area;       /* host addr (char *) of start of M */
extern  IHPE    Length_of_M_area;       /* offset of end of M */
#else /* CPU_40_STYLE */
#define sas_set_buf(buf,addr)	buf=get_byte_addr(addr)

extern host_addr Start_of_M_area;	/* host addr (char *) of start of M */
#ifdef	GISP_CPU
extern	IHPE	Length_of_M_area;	/* offset of end of M */
#else
extern sys_addr Length_of_M_area;	/* sys addr (long) offset of end of M */
#endif	/* GISP_CPU */

/* the following is for integration only */

#ifdef CHEAT
#ifdef M_IS_POINTER
extern half_word *M;
#else
extern half_word M[];
#endif /* M_IS_POINTER */
#endif /* CHEAT */

/*
	The following is to allow hosts to redefine the sas_interface to
	function pointers is they so wish
*/

#if !defined(HOST_SAS) || defined(BASE_SAS)

/********************************************************/
/* pointer manipulation macros */
/*
 * Note that the PHY_ADDR casts in get_byte_addr shouldn't need to be
 * there, but I've put them in to reduce BCN 2275's impact on other files.
 * I'll take them out in a future BCN.
 *
 *						Mike.
 */

#ifdef BACK_M
#define inc_M_ptr(p,o)	(p-(o))
#define get_byte_addr(addr) ((IU8 *)((IHPE)Start_of_M_area + Length_of_M_area - 1 - (PHY_ADDR)(addr)))
#define M_get_dw_ptr(address) ((IHPE)Start_of_M_area + Length_of_M_area - 1 - (long)(address) - 3)
#else /* BACK_M */
#define inc_M_ptr(p,o)	(p+(o))
#define get_byte_addr(addr) ((IU8 *)((IHPE)Start_of_M_area + (PHY_ADDR)(addr)))
#define M_get_dw_ptr(address) ((IHPE)Start_of_M_area + (long)(address))
#endif /* BACK_M */

/********************************************************/

/********************************************************/

/*
 * These function prototypes and macros were taken out to make implementation
 * of 4.0 easier.  We'll leave them in for builds prior to 3.0 though.
 *
 */
#ifndef CPU_30_STYLE
#define M_low (long)Start_of_M_area
#define M_high (long)(Length_of_M_area-1)
#ifdef BACK_M
#define get_addr(type,address) (M_low+M_high- (long)(address) - (sizeof(type)-1))
#define get_offset_into_M(p) (M_high - p)
#else /* BACK_M */
#define get_addr(type,address) (M_low+ (long)(address))
#define get_offset_into_M(p) (p - M_low)
#endif /* BACK_M */
#define M_index_hw(p,a) (*(get_byte_addr(get_offset_into_M(p)+a))) 
#define M_index_w(p,a) (*(get_word_addr(get_offset_into_M(p)+(a*sizeof (word))))) 
#define M_index_dw(p,a) (*(get_double_word_addr(get_offset_into_M(p)+(a*sizeof(double_word)))))
#define M_index(t,p,a) (*(get_addr(t,get_offset_into_M(p)+(a*sizeof(t)))))
#define M_get_hw_ptr(a) get_byte_addr(a)
#define M_get_w_ptr(a) get_word_addr(a)
#define get_word_addr(address) ((host_addr)get_addr(word,address))
#define get_double_word_addr(address) ((host_addr)get_addr(double_word,address))

extern void sas_part_enable_20_bit_wrap IPT3(BOOL, for_write,
	sys_addr, start_offset, sys_addr, end_offset);
extern void sas_part_disable_20_bit_wrap IPT3(BOOL, for_write,
	sys_addr, start_offset, sys_addr, end_offset);
extern void sas_move_bytes_backward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_move_words_backward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
#endif /* !CPU_30_STYLE */

/********************************************************/
/* function declarations */
extern void sas_init IPT1(sys_addr, size);
extern void sas_term IPT0();
#ifdef	GISP_CPU
extern IHPE sas_memory_size IPT0 ();
#else
extern sys_addr sas_memory_size IPT0();
#endif	/* GISP_CPU */
extern void sas_connect_memory IPT3(sys_addr, low, sys_addr, high,
	half_word, type);
extern void sas_overwrite_memory IPT2(sys_addr, addr, int, type);

#ifdef NTVDM
/* We call xms functions(which in turn, will call sas functions) to
   manage the A20 line wrapping. The reason is that we want to keep
   the A20 line current state in himem.sys so that we don't have to
   bop to 32 bits side to get the state.
*/
extern void xmsEnableA20Wrapping(void);
extern void xmsDisableA20Wrapping(void);
#endif  /* NTVDM */

extern half_word sas_memory_type IPT1(sys_addr, addr);
extern void sas_enable_20_bit_wrapping IPT0();
extern void sas_disable_20_bit_wrapping IPT0();
extern BOOL sas_twenty_bit_wrapping_enabled IPT0();
extern half_word sas_hw_at IPT1(sys_addr, addr);
extern word sas_w_at IPT1(sys_addr, addr);
extern double_word sas_dw_at IPT1(sys_addr, addr);
extern half_word sas_hw_at_no_check IPT1(sys_addr, addr);
extern word sas_w_at_no_check IPT1(sys_addr, addr);
extern double_word sas_dw_at_no_check IPT1(sys_addr, addr);
extern void sas_load IPT2(sys_addr, addr, half_word *, val);
extern void sas_store IPT2(sys_addr, addr, half_word, val);
extern void sas_store_no_check IPT2(sys_addr, addr24, half_word, val);
#ifndef SUN_VA
extern void sas_loadw IPT2(sys_addr, addr, word *, val);
extern void sas_storew IPT2(sys_addr, addr, word, val);
extern void sas_storew_no_check IPT2(sys_addr, addr24, word, val);
#else
extern void sas_loadw_swap IPT2(sys_addr, addr, word *, val);
extern void sas_storew_swap IPT2(sys_addr, addr, word, val);
#endif	/* SUN_VA */
extern void sas_storedw IPT2(sys_addr, addr, double_word, val);
extern void sas_loads IPT3(sys_addr, src, host_addr, dest, sys_addr, len);
extern void sas_stores IPT3(sys_addr, dest, host_addr, src, sys_addr, len);
extern int sas_strlen IPT1(sys_addr, str_ptr);
extern void sas_move_bytes_forward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_move_words_forward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_fills IPT3(sys_addr, addr, half_word, val, sys_addr, len);
extern void sas_fillsw IPT3(sys_addr, addr, word, val, sys_addr, len);
extern host_addr sas_scratch_address IPT1(sys_addr, length);
extern host_addr sas_transbuf_address IPT2(sys_addr, intel_dest_addr, sys_addr, length);
extern void sas_loads_to_transbuf IPT3(sys_addr, src, host_addr, dest, sys_addr, len);
extern void sas_stores_from_transbuf IPT3(sys_addr, dest, host_addr, src, sys_addr, len);

#endif /* HOST_SAS */

/*
 * These are the physical memory interfaces introduced in 4.0.  As
 * physical and linear addresses are the same before 4.0, we can
 * just point them at the appropriate linear addresses.
 */

#define sas_PR8		sas_hw_at
#define sas_PR16	sas_w_at
#define sas_PR32	sas_dw_at
#define sas_PW8		sas_store
#define sas_PW16	sas_storew
#define sas_PW32	sas_storedw
#define sas_PWS		sas_stores
#define sas_PRS		sas_loads

#endif /* ! CPU_40_STYLE */

/********************************************************/
/* this marco is used as a replacement for cpu_sw_interrupt */

#define exec_sw_interrupt(c,i)	\
{				\
    word cs,ip;			\
				\
    cs = getCS(); ip = getIP(); \
				\
    setCS(c); setIP(i); 	\
    host_simulate();		\
				\
    setCS(cs); setIP(ip);	\
}


/********************************************************/
/* Size of memory array in half-words */
#define PC_MEM_SIZE 	0x100000L		/* 1 Mbyte 	*/
#define MEMORY_TOP      0xA0000L                /* 640K DOS limit */

/* Memory bounds for the colour graphics adaptor */

#ifdef BACK_M

#ifndef HERC_REGEN_BUFF
#define CGA_REGEN_BUFF	0xBBFFFL
#define MDA_REGEN_BUFF	0xB7FFFL
#define HERC_REGEN_BUFF	0xBFFFFL
#endif /* HERC_REGEN_BUFF */

#else

#ifndef HERC_REGEN_BUFF
#define CGA_REGEN_BUFF	0xB8000L
#define MDA_REGEN_BUFF	0xB0000L
#define HERC_REGEN_BUFF	0xB0000L
#endif /* HERC_REGEN_BUFF */

#endif /* BACK_M */

#define CGA_REGEN_START	0xB8000L
#define CGA_REGEN_END		0xBBFFFL
#define CGA_REGEN_LENGTH	(CGA_REGEN_END - CGA_REGEN_START + 1L)

#define MDA_REGEN_START	0xB0000L
#define MDA_REGEN_END		0xB7FFFL
#define MDA_REGEN_LENGTH	(MDA_REGEN_END - MDA_REGEN_START + 1L)

#define HERC_REGEN_START	0xB0000L
#define HERC_REGEN_END	0xBFFFFL
#define HERC_REGEN_LENGTH	(HERC_REGEN_END - HERC_REGEN_START + 1L)

/*
 * Constants used by the sas initialisation function.  These consist of
 * memory locations and PC instructions for the BIOS calling structure.
 *
 * The BIOS calls are via the BOP pseudo instruction and these are 
 * positioned at the real entry points for the PC.  See the BIOS module
 * for a more detailed description of the calling mechanism.
 */

/* General Intel memory parameters */


#if defined(NEC_98)
#define BIOSN_START             0xE8000L
#define BIOSH_START             0xF0000L
#else  // !NEC_98
#define BIOS_START_OFFSET	0x0000L
#define BIOS1_END_SEGMENT	0xF000L
#define BIOS1_END_OFFSET 	0x7000L 	/* End of 1st half of ROM */
#define BIOS2_START_SEGMENT	0xF000L
#define BIOS2_START_OFFSET 	0xE000L		/* 2nd half of BIOS ROM	*/
#endif // !NEC_98
#define	BAD_OP			0xC5		/* filling RAM for the use of */

#if defined(NEC_98)
#define ROM_START               0xE8000L
#else  // !NEC_98
#define	BASIC_ROM		0xFE000L	/* Start of Basic Rom */
#define ROM_START		0xC0000L	/* Start of Expansion ROM @ 768k */
#endif // !NEC_98

#define FIXED_DISK_START	0xC8000L	/* Start fixed disk BIOS*/
#define FIXED_DISK_END		0xCA000L	/* End fixed disk BIOS +1 */

#define	START_SEGMENT		0xF000		/* 8088 start address */
#define	START_OFFSET		0xFFF0

#if defined(NEC_98)
#define MEMORY_SWITCH_START_N   0xA3FE0L
#define MEMORY_SWITCH_START_H   0xE3FE0L
#endif // NEC_98

/*
 * The follwoing are the offsets for the entry points to the
 * BIOS function calls.  These will be loaded into the interrupt vector
 * table.  
 * the Segments are defined later, depending upon GISP_SVGA
 * for which they will be the global Rom address variables
 */

#define COPYRIGHT_OFFSET	0xE008
#define RESET_OFFSET		0xE05B
#define BOOT_STRAP_OFFSET	0xE6F2
#define DOS_OFFSET		0x7C00
#define KEYBOARD_IO_OFFSET	0xE82E
#define DISKETTE_IO_OFFSET	0xEC49
#ifndef GISP_SVGA
#define VIDEO_IO_OFFSET		0xF065
#else		/* GISP_SVGA */
#define VIDEO_IO_OFFSET		0x0810
#define CGA_VIDEO_IO_OFFSET	0xF065
#endif		/* GISP_SVGA  */
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_OFFSET	0xF841
#define EQUIPMENT_OFFSET	0xF84D
#define TIME_OF_DAY_OFFSET	0xFE6E
#define DISK_IO_OFFSET		0x0256
#define RS232_IO_OFFSET		0xE739
#define CASSETTE_IO_OFFSET	0xF859
#define PRINTER_IO_OFFSET	0xEFD2
#define PRINT_SCREEN_OFFSET	0xFF54
#define BASIC_OFFSET		0xEC00
#define VIDEO_PARM_OFFSET	0xF0A4
#define DISKETTE_TB_OFFSET	0xEFC7
#define DISK_TB_OFFSET		0x03E7
#define EXTEND_CHAR_OFFSET	0x0000
#define MOUSE_VIDEO_IO_OFFSET	0xED80

#if defined(NTVDM) && !defined(X86GFX)
#define MOUSE_IO_INTERRUPT_SEGMENT  0xF000
#define MOUSE_IO_INTERRUPT_OFFSET   0xED00
#endif

#define KEYBOARD_BREAK_INT_OFFSET   0xFF35
#define PRINT_SCREEN_INT_OFFSET	    0xFF3B
#define USER_TIMER_INT_OFFSET	    0xFF41

/* ... and the device interrupts...  */
#define UNEXP_INT_OFFSET	0x6f00
#define DUMMY_INT_OFFSET	0xFF4B
#define TIMER_INT_OFFSET	0xFEA5
#define ILL_OP_INT_OFFSET       0xFF30
#define KB_INT_OFFSET		0xE987
#define DISKETTE_INT_OFFSET	0xEF57
#define DISK_INT_OFFSET		0x0760
#define MOUSE_INT1_OFFSET	0xEE00
#define MOUSE_INT2_OFFSET	0xEE80
#define	MOUSE_VERSION_OFFSET	0xED20
#define	MOUSE_COPYRIGHT_OFFSET	0xED40
#define RTC_INT_OFFSET		0x4B1B
#define D11_INT_OFFSET		0x1BE0
#define	REDIRECT_INT_OFFSET	0x1C2F
#define X287_INT_OFFSET		0x1C38

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_OFFSET  0xFF53

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_OFFSET	0xe850
#define RCPU_NOP_OFFSET		0xe950
#define RCPU_INT15_OFFSET	0xe970
#define RCPU_INT4A_OFFSET	0x4B30

/* ...and the data tables */
#define CONF_TABLE_OFFSET       0xE6F5

#define	DR_TYPE_OFFSET		0x0C50

#define MD_TBL1_OFFSET          (DR_TYPE_OFFSET + 0x15)
#define MD_TBL2_OFFSET          (MD_TBL1_OFFSET + 0xd)
#define MD_TBL3_OFFSET          (MD_TBL2_OFFSET + 0xd)
#define MD_TBL4_OFFSET          (MD_TBL3_OFFSET + 0xd)
#define MD_TBL5_OFFSET          (MD_TBL4_OFFSET + 0xd)
#define MD_TBL6_OFFSET          (MD_TBL5_OFFSET + 0xd)

#define RCPU_WAIT_INT_OFFSET    0x0CE0

/*
 * ROM locations of disk parameter blocks
 */

#define	DISKIO_OFFSET		0x2e86
#define	DISKISR_OFFSET		0x33b7
#define	DISKWAIT_OFFSET		0x329f	/* DISKIO_OFFSET + 0x419 */
#define	DPB0_OFFSET		0x0421
#define	DPB1_OFFSET		0x0431

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_OFFSET	0xF0A4
#define VID_LENS_OFFSET		0xF0E4
#define VID_COLTAB_OFFSET	0xF0EC
#define VID_MODTAB_OFFSET	0xF0F4
#define	CHAR_GEN_OFFSET		0xFA6E


/* Location of EGA entry point for INT 10 */
#ifndef GISP_SVGA 
#define EGA_ENTRY_OFF	0x0898
#else	 	/* GISP_SVGA */
#define EGA_ENTRY_OFF	0x0800
#endif		/* GISP_SVGA */

/* Off set info for EGA character tables */
#define EGA_CGMN_OFF	0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF	0x3160
#define EGA_HIFONT_OFF	0x3990
#define EGA_INT1F_OFF	0x3560

/*
* To enable our drivers to output messages generated from
* our bops we use a scratch area inside our rom.
*/

#define DOS_SCRATCH_PAD_OFFSET		0x6400
#define DOS_SCRATCH_PAD_END_OFFSET	0x6fff

#ifndef GISP_SVGA

#define BIOS_START_SEGMENT	0xF000
#define	SYSROM_SEG		0xF000
#define	SYSROMORG_SEG		0xFe00
#define COPYRIGHT_SEGMENT	0xF000
#define RESET_SEGMENT		0xF000
#define BOOT_STRAP_SEGMENT	0xF000
#define DOS_SEGMENT		0x0000
#define KEYBOARD_IO_SEGMENT	0xF000
#define DISKETTE_IO_SEGMENT	0xF000
#define VIDEO_IO_SEGMENT	0xF000
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_SEGMENT	0xF000
#define EQUIPMENT_SEGMENT	0xF000
#define TIME_OF_DAY_SEGMENT	0xF000
#define DISK_IO_SEGMENT		0xC800
#define RS232_IO_SEGMENT	0xF000
#define CASSETTE_IO_SEGMENT	0xF000
#define PRINTER_IO_SEGMENT	0xF000
#define PRINT_SCREEN_SEGMENT	0xF000
#define BASIC_SEGMENT		0xF000
#define VIDEO_PARM_SEGMENT	0xF000
#define DISKETTE_TB_SEGMENT	0xF000
#define DISK_TB_SEGMENT		0xC800
#define EXTEND_CHAR_SEGMENT	0xF000
#ifndef MOUSE_VIDEO_IO_SEGMENT
#define MOUSE_VIDEO_IO_SEGMENT	0xF000
#endif /* MOUSE_VIDEO_IO_SEGMENT */

#define KEYBOARD_BREAK_INT_SEGMENT  0xF000
#define PRINT_SCREEN_INT_SEGMENT    0xF000
#define USER_TIMER_INT_SEGMENT	    0xF000

/* ... and the device interrupts...  */
#define UNEXP_INT_SEGMENT	0xF000
#define DUMMY_INT_SEGMENT	0xF000
#define TIMER_INT_SEGMENT	0xF000
#define ILL_OP_INT_SEGMENT      0xF000
#define KB_INT_SEGMENT		0xF000
#define DISKETTE_INT_SEGMENT	0xF000
#define DISK_INT_SEGMENT	0xC800
#ifndef MOUSE_INT1_SEGMENT
#define MOUSE_INT1_SEGMENT	0xF000
#endif /* MOUSE_INT1_SEGMENT */
#ifndef MOUSE_INT2_SEGMENT
#define MOUSE_INT2_SEGMENT	0xF000
#endif /* MOUSE_INT2_SEGMENT */
#ifndef	MOUSE_VERSION_SEGMENT
#define	MOUSE_VERSION_SEGMENT	0xF000
#endif /* MOUSE_VERSION_SEGMENT */
#ifndef	MOUSE_COPYRIGHT_SEGMENT
#define	MOUSE_COPYRIGHT_SEGMENT	0xF000
#endif /* MOUSE_COPYRIGHT_SEGMENT */
#define RTC_INT_SEGMENT		0xF000
#define D11_INT_SEGMENT		0xF000
#define	REDIRECT_INT_SEGMENT	0xF000
#define	X287_INT_SEGMENT	0xF000

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_SEGMENT 0xF000

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_SEGMENT	KB_INT_SEGMENT
#define RCPU_NOP_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT15_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT4A_SEGMENT	RTC_INT_SEGMENT

/* ...and the data tables */
#define CONF_TABLE_SEGMENT	0xF000

#define	DISKETTE_IO_1_SEGMENT	0xFE00
#define	DR_TYPE_SEGMENT		DISKETTE_IO_1_SEGMENT

#define MD_TBL1_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL2_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL3_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL4_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL5_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL6_SEGMENT         DISKETTE_IO_1_SEGMENT
#define DPB0_SEGMENT		0xF000
#define DPB1_SEGMENT		0xF000

#define RCPU_WAIT_INT_SEGMENT	DISKETTE_IO_1_SEGMENT

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_SEGMENT	0xF000
#define VID_LENS_SEGMENT	0xF000
#define	VID_COLTAB_SEGMENT	0xF000
#define VID_MODTAB_SEGMENT	0xF000
#define	CHAR_GEN_SEGMENT	0xF000

/* Off set info for EGA character tables */
#define EGA_CGMN_OFF	0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF	0x3160
#define EGA_HIFONT_OFF	0x3990
#define EGA_INT1F_OFF	0x3560

#define DOS_SCRATCH_PAD_SEGMENT          0xF000
#define DOS_SCRATCH_PAD_END_SEGMENT      0xF000

/* ...and the 20 bit address corresponding to the above */

#define BIOS_START		(sys_addr)(BIOS_START_SEGMENT * 16L) + \
					(sys_addr)BIOS_START_OFFSET
#define BIOS1_END		(sys_addr)(BIOS1_END_SEGMENT * 16L) + \
					(sys_addr)BIOS1_END_OFFSET
#define BIOS2_START		(sys_addr)(BIOS2_START_SEGMENT * 16L) + \
					(sys_addr)BIOS2_START_OFFSET
#define START_ADDR 		(sys_addr)(START_SEGMENT * 16L) + \
					(sys_addr)START_OFFSET
#define COPYRIGHT_ADDR 		(sys_addr)(COPYRIGHT_SEGMENT * 16L) + \
					(sys_addr)COPYRIGHT_OFFSET
#define RESET_ADDR 		(sys_addr)(RESET_SEGMENT * 16L) + \
					(sys_addr)RESET_OFFSET
#define BOOT_STRAP_ADDR		(sys_addr)(BOOT_STRAP_SEGMENT * 16L)  + \
					(sys_addr)BOOT_STRAP_OFFSET
#define KEYBOARD_IO_ADDR	(sys_addr)(KEYBOARD_IO_SEGMENT * 16L) + \
					(sys_addr)KEYBOARD_IO_OFFSET
#define DISKETTE_IO_ADDR	(sys_addr)(DISKETTE_IO_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_IO_OFFSET
#define VIDEO_IO_ADDR		(sys_addr)(VIDEO_IO_SEGMENT * 16L) + \
					(sys_addr)VIDEO_IO_OFFSET
#define MEMORY_SIZE_ADDR	(sys_addr)(MEMORY_SIZE_SEGMENT * 16L) + \
					(sys_addr)MEMORY_SIZE_OFFSET
#define EQUIPMENT_ADDR		(sys_addr)(EQUIPMENT_SEGMENT * 16L) + \
					(sys_addr)EQUIPMENT_OFFSET
#define TIME_OF_DAY_ADDR	(sys_addr)(TIME_OF_DAY_SEGMENT * 16L) + \
					(sys_addr)TIME_OF_DAY_OFFSET
#define DISK_IO_ADDR		(sys_addr)(DISK_IO_SEGMENT * 16L) + \
					(sys_addr)DISK_IO_OFFSET
#define RS232_IO_ADDR		(sys_addr)(RS232_IO_SEGMENT * 16L) + \
					(sys_addr)RS232_IO_OFFSET
#define CASSETTE_IO_ADDR	(sys_addr)(CASSETTE_IO_SEGMENT * 16L) + \
					(sys_addr)CASSETTE_IO_OFFSET
#define PRINTER_IO_ADDR		(sys_addr)(PRINTER_IO_SEGMENT * 16L) + \
					(sys_addr)PRINTER_IO_OFFSET
#define PRINT_SCREEN_ADDR	(sys_addr)(PRINT_SCREEN_SEGMENT * 16L) + \
					(sys_addr)PRINT_SCREEN_OFFSET
#define BASIC_ADDR		(sys_addr)(BASIC_SEGMENT * 16L) + \
					(sys_addr) BASIC_OFFSET
#define DISKETTE_TB_ADDR	(sys_addr)(DISKETTE_TB_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_TB_OFFSET
#define DISK_TB_ADDR		(sys_addr)(DISK_TB_SEGMENT * 16L) + \
					(sys_addr)DISK_TB_OFFSET
#define MOUSE_VIDEO_IO_ADDR	(sys_addr)(MOUSE_VIDEO_IO_SEGMENT * 16L) + \
					(sys_addr)MOUSE_VIDEO_IO_OFFSET
#define DUMMY_INT_ADDR		(sys_addr)(DUMMY_INT_SEGMENT * 16L) + \
					(sys_addr)DUMMY_INT_OFFSET
#define TIMER_INT_ADDR		(sys_addr)(TIMER_INT_SEGMENT * 16L) + \
					(sys_addr)TIMER_INT_OFFSET
#define KB_INT_ADDR		(sys_addr)(KB_INT_SEGMENT * 16L) + \
					(sys_addr)KB_INT_OFFSET
#define DISKETTE_INT_ADDR	(sys_addr)(DISKETTE_INT_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_INT_OFFSET
#define DISK_INT_ADDR		(sys_addr)(DISK_INT_SEGMENT * 16L) + \
					(sys_addr)DISK_INT_OFFSET
#define UNEXP_INT_ADDR		(sys_addr)(UNEXP_INT_SEGMENT * 16L) + \
					(sys_addr)UNEXP_INT_OFFSET
#define MOUSE_INT1_ADDR		(sys_addr)(MOUSE_INT1_SEGMENT * 16L) + \
					(sys_addr)MOUSE_INT1_OFFSET
#define MOUSE_INT2_ADDR		(sys_addr)(MOUSE_INT2_SEGMENT * 16L) + \
					(sys_addr)MOUSE_INT2_OFFSET
#define MOUSE_VERSION_ADDR	(sys_addr)(MOUSE_VERSION_SEGMENT * 16L) + \
					(sys_addr)MOUSE_VERSION_OFFSET
#define MOUSE_COPYRIGHT_ADDR	(sys_addr)(MOUSE_COPYRIGHT_SEGMENT * 16L) + \
					(sys_addr)MOUSE_COPYRIGHT_OFFSET
#define ADDR_COMPATIBILITY_ADDR	(sys_addr)(ADDR_COMPATIBILITY_SEGMENT * 16L) + \
					(sys_addr)ADDR_COMPATIBILITY_OFFSET
#define CONF_TABLE_ADDR   	(sys_addr)(CONF_TABLE_SEGMENT * 16L) + \
					(sys_addr)CONF_TABLE_OFFSET
#define DISK_BASE_ADDR          (sys_addr)(DISK_BASE_SEGMENT * 16L) + \
					(sys_addr)DISK_BASE_OFFSET
#define DR_TYPE_ADDR            (sys_addr)(DR_TYPE_SEGMENT * 16L) + \
					(sys_addr)DR_TYPE_OFFSET
#define DISKETTE_IO_1_ADDR      (sys_addr)(DISKETTE_IO_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_IO_OFFSET
#define MD_TBL1_ADDR            (sys_addr)(MD_TBL1_SEGMENT * 16L) + \
					(sys_addr)MD_TBL1_OFFSET
#define MD_TBL2_ADDR            (sys_addr)(MD_TBL2_SEGMENT * 16L) + \
					(sys_addr)MD_TBL2_OFFSET
#define MD_TBL3_ADDR            (sys_addr)(MD_TBL3_SEGMENT * 16L) + \
					(sys_addr)MD_TBL3_OFFSET
#define MD_TBL4_ADDR            (sys_addr)(MD_TBL4_SEGMENT * 16L) + \
					(sys_addr)MD_TBL4_OFFSET
#define MD_TBL5_ADDR            (sys_addr)(MD_TBL5_SEGMENT * 16L) + \
					(sys_addr)MD_TBL5_OFFSET
#define MD_TBL6_ADDR            (sys_addr)(MD_TBL6_SEGMENT * 16L) + \
					(sys_addr)MD_TBL6_OFFSET
#define RCPU_WAIT_INT_ADDR      (sys_addr)(RCPU_WAIT_INT_SEGMENT * 16L) + \
					(sys_addr)RCPU_WAIT_INT_OFFSET
#define	DPB0		0xfe421	
#define	DPB1		0xfe431

/* Addresses in Intel memory of constant keyboard tables */
#define K6     0xFE87EL
#define K7     0xFE886L
#define K8     0xFE88EL
#define K9     0xFE8C8L
#define K10    0xFE8E6L
#define K11    0xFE98AL
#define K30    0xFEA87L

/* Video Stuff CGA */

#define VID_PARMS	(sys_addr)(VID_PARMS_SEGMENT * 16L) + \
						(sys_addr)VID_PARMS_OFFSET
#define	VID_LENS			(sys_addr)(VID_LENS_SEGMENT * 16L) + \
					(sys_addr)VID_LENS_OFFSET
#define	VID_COLTAB			(sys_addr)(VID_COLTAB_SEGMENT * 16L) + \
					(sys_addr)VID_COLTAB_OFFSET
#define	VID_MODTAB			(sys_addr)(VID_COLTAB_SEGMENT * 16L) + \
					(sys_addr)VID_MODTAB_OFFSET
#define	CHAR_GEN_ADDR			(sys_addr)(CHAR_GEN_SEGMENT * 16L) + \
					(sys_addr)CHAR_GEN_OFFSET

#define DOS_SCRATCH_PAD (sys_addr)(DOS_SCRATCH_PAD_SEGMENT * 16L) + \
					(sys_addr)DOS_SCRATCH_PAD_OFFSET
#define DOS_SCRATCH_PAD_END (sys_addr)(DOS_SCRATCH_PAD_END_SEGMENT * 16L) + \
					(sys_addr)DOS_SCRATCH_PAD_END_OFFSET

#ifdef EGG
#define EGA_ROM_START		0xC0000L	/* start of EGA BIOS ROM */
#ifdef STINGER
#define EGA_ROM_END		0xC4A00L	/* end of EGA BIOS ROM +1 */
#else		/* ~STINGER */
#ifdef V7VGA
#define EGA_ROM_END		0xC5000L	/* end of EGA BIOS ROM +1 */
#else
#define EGA_ROM_END		0xC4000L	/* end of EGA BIOS ROM +1 */
#endif /* V7VGA */
#endif		/* STINGER */
#endif		/* EGG */

#ifdef EGG

#define EGA_SEG	0xC000			/* Segment Address For the ega ROM */

/* EGA Font stuff */

#define EGA_CGMN	0xC2230
#define EGA_CGDDOT	0xC3160
#define EGA_HIFONT	0xC3990		/* 8x16 font for 640x480 ext */

#endif		/* EGG */



#else		/* GISP_SVGA */

/* The segment which the bios is gonna be loaded into */
extern word	Bios1Segment;
extern word	Bios2Segment;
extern word	EgaROMSegment;
extern word	EgaFontSegment;

/* Define all the segment address values to be out variables, just in case */

#define COPYRIGHT_SEGMENT	Bios1Segment
#define RESET_SEGMENT		Bios1Segment
#define BOOT_STRAP_SEGMENT	Bios1Segment
#define DOS_SEGMENT		0x0000
#define KEYBOARD_IO_SEGMENT	Bios1Segment
#define DISKETTE_IO_SEGMENT	Bios1Segment
#define VIDEO_IO_SEGMENT	Bios1Segment
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_SEGMENT	Bios1Segment
#define EQUIPMENT_SEGMENT	Bios1Segment
#define TIME_OF_DAY_SEGMENT	Bios1Segment
#define DISK_IO_SEGMENT		0xC800
#define RS232_IO_SEGMENT	Bios1Segment
#define CASSETTE_IO_SEGMENT	Bios1Segment
#define PRINTER_IO_SEGMENT	Bios1Segment
#define PRINT_SCREEN_SEGMENT	Bios1Segment
#define BASIC_SEGMENT		Bios1Segment
#define VIDEO_PARM_SEGMENT	Bios1Segment
#define DISKETTE_TB_SEGMENT	Bios1Segment
#define DISK_TB_SEGMENT		0xC800
#define EXTEND_CHAR_SEGMENT	Bios1Segment
#ifndef MOUSE_VIDEO_IO_SEGMENT
#define MOUSE_VIDEO_IO_SEGMENT	Bios1Segment
#endif /* MOUSE_VIDEO_IO_SEGMENT */

#define KEYBOARD_BREAK_INT_SEGMENT  Bios1Segment
#define PRINT_SCREEN_INT_SEGMENT    Bios1Segment
#define USER_TIMER_INT_SEGMENT	    Bios1Segment

/* ... and the device interrupts...  */
#define UNEXP_INT_SEGMENT	Bios1Segment
#define DUMMY_INT_SEGMENT	Bios1Segment
#define TIMER_INT_SEGMENT	Bios1Segment
#define ILL_OP_INT_SEGMENT      Bios1Segment
#define KB_INT_SEGMENT		Bios1Segment
#define DISKETTE_INT_SEGMENT	Bios1Segment
#define DISK_INT_SEGMENT	0xC800
#ifndef MOUSE_INT1_SEGMENT
#define MOUSE_INT1_SEGMENT	Bios1Segment
#endif /* MOUSE_INT1_SEGMENT */
#ifndef MOUSE_INT2_SEGMENT
#define MOUSE_INT2_SEGMENT	Bios1Segment
#endif /* MOUSE_INT2_SEGMENT */
#ifndef	MOUSE_VERSION_SEGMENT
#define	MOUSE_VERSION_SEGMENT	Bios1Segment
#endif /* MOUSE_VERSION_SEGMENT */
#ifndef	MOUSE_COPYRIGHT_SEGMENT
#define	MOUSE_COPYRIGHT_SEGMENT	Bios1Segment
#endif /* MOUSE_COPYRIGHT_SEGMENT */
#define RTC_INT_SEGMENT		Bios1Segment
#define D11_INT_SEGMENT		Bios1Segment
#define	REDIRECT_INT_SEGMENT	Bios1Segment
#define	X287_INT_SEGMENT	Bios1Segment

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_SEGMENT Bios1Segment

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_SEGMENT	KB_INT_SEGMENT
#define RCPU_NOP_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT15_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT4A_SEGMENT	RTC_INT_SEGMENT

/* ...and the data tables */
#define CONF_TABLE_SEGMENT	Bios1Segment

#define	DISKETTE_IO_1_SEGMENT	Bios2Segment
#define	DR_TYPE_SEGMENT		DISKETTE_IO_1_SEGMENT

#define MD_TBL1_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL2_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL3_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL4_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL5_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL6_SEGMENT         DISKETTE_IO_1_SEGMENT
#define DPB0_SEGMENT		Bios1Segment
#define DPB1_SEGMENT		Bios1Segment

#define RCPU_WAIT_INT_SEGMENT	DISKETTE_IO_1_SEGMENT

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_SEGMENT	Bios1Segment
#define VID_LENS_SEGMENT	Bios1Segment
#define	VID_COLTAB_SEGMENT	Bios1Segment
#define VID_MODTAB_SEGMENT	Bios1Segment
#define	CHAR_GEN_SEGMENT	Bios1Segment

/*
	All the entrypoints and table locations for the roms are held in
	this structure (romAddress) - it should be initialised in
	host_rom_init() 
*/

extern struct romAddressTag {
	sys_addr	startAddr;
	sys_addr	bios1StartAddr;
	sys_addr	bios2StartAddr;
	sys_addr	copyrightAddr;
	sys_addr	resetAddr;
	sys_addr	bootStrapAddr;
	sys_addr	keyboardIOAddr;
	sys_addr	disketteIOAddr;
	sys_addr	videoIOAddr;
	sys_addr	memorySizeAddr;
	sys_addr	equipmentAddr;
	sys_addr	timeOfDayAddr;
	sys_addr	diskIOAddr;
	sys_addr	rs232IOAddr;
	sys_addr	cassetteIOAddr;
	sys_addr	printerIOAddr;
	sys_addr	printScreenAddr;
	sys_addr	basicAddr;
	sys_addr	disketteTbAddr;
	sys_addr	diskTbAddr;
	sys_addr	mouseIOIntAddr;
	sys_addr	mouseVideoIOAddr;
	sys_addr	dummyIntAddr;
	sys_addr	timerIntAddr;
	sys_addr	kbIntAddr;
	sys_addr	diskettIntAddr;
	sys_addr	diskIntAddr;
	sys_addr	unexpIntAddr;
	sys_addr	mouseInt1Addr;
	sys_addr	mouseInt2Addr;
	sys_addr	mouseVersionAddr;
	sys_addr	mouseCopyrightAddr;
	sys_addr	addrCompatAddr;
	sys_addr	k6;
	sys_addr	k7;
	sys_addr	k8;
	sys_addr	k9;
	sys_addr	k10;
	sys_addr	k11;
	sys_addr	k30;
	sys_addr	confTableAddr;
	sys_addr	diskBaseAddr;
	sys_addr	drTypeAddr;
	sys_addr	disketteIO1Addr;
	sys_addr	mdTbl1Addr;
	sys_addr	mdTbl2Addr;
	sys_addr	mdTbl3Addr;
	sys_addr	mdTbl4Addr;
	sys_addr	mdTbl5Addr;
	sys_addr	mdTbl6Addr;
	sys_addr	rcpuWaitIntAddr;
	sys_addr	diskParamBlock0;
	sys_addr	diskParamBlock1;
	sys_addr	vidParms;
	sys_addr	vidLens;
	sys_addr	vidColTab;
	sys_addr	vidModTab;
	sys_addr	charGen;
#ifdef EGG
	sys_addr	egaStart;
	sys_addr	egaEnd;
	sys_addr	egaFonts;
	sys_addr	egaCgmn;
	sys_addr	egaCgDot;
	sys_addr	egaHiFont;
#endif		/* EGG */
	sys_addr	dosScratchPad;
	sys_addr	dosScratchPadEnd;
}	romAddress;

/* Define out all the 20 bit addresses to be our structure */

#define BIOS_START_SEGMENT		Bios1Segment
#define	SYSROM_SEG			Bios1Segment
#define	SYSROMORG_SEG			Bios2Segment
#define	START_ADDR			romAddress.startAddr
#define BIOS_START			romAddress.bios1StartAddr
#define BIOS2_START			romAddress.bios2StartAddr
#define COPYRIGHT_ADDR 			romAddress.copyrightAddr
#define RESET_ADDR 			romAddress.resetAddr
#define BOOT_STRAP_ADDR			romAddress.bootStrapAddr
#define KEYBOARD_IO_ADDR		romAddress.keyboardIOAddr
#define DISKETTE_IO_ADDR		romAddress.disketteIOAddr
#define VIDEO_IO_ADDR			romAddress.videoIOAddr
#define MEMORY_SIZE_ADDR		romAddress.memoryIOAddr
#define EQUIPMENT_ADDR			romAddress.equipmentAddr
#define TIME_OF_DAY_ADDR		romAddress.timeOfDayAddr
#define DISK_IO_ADDR			romAddress.diskIOAddr
#define RS232_IO_ADDR			romAddress.rs232IOAddr
#define CASSETTE_IO_ADDR		romAddress.cassetteIOAddr
#define PRINTER_IO_ADDR			romAddress.printerIOAddr
#define PRINT_SCREEN_ADDR		romAddress.printScreenAddr
#define BASIC_ADDR			romAddress.basicAddr
#define DISKETTE_TB_ADDR		romAddress.disketteTbAddr
#define DISK_TB_ADDR			romAddress.diskTbAddr
#define MOUSE_VIDEO_IO_ADDR		romAddress.mouseVideoIntAddr
#define DUMMY_INT_ADDR			romAddress.dummyIntAddr
#define TIMER_INT_ADDR			romAddress.timerIntAddr
#define KB_INT_ADDR			romAddress.kbIntAddr
#define DISKETTE_INT_ADDR		romAddress.disketteIntAddr
#define DISK_INT_ADDR			romAddress.diskIntAddr
#define UNEXP_INT_ADDR			romAddress.unexpIntAddr
#define MOUSE_INT1_ADDR			romAddress.mouseInt1Addr
#define MOUSE_INT2_ADDR			romAddress.mouseInt2Addr
#define MOUSE_VERSION_ADDR		romAddress.mouseVersionAddr
#define MOUSE_COPYRIGHT_ADDR		romAddress.mouseCopyrightAddr
#define ADDR_COMPATIBILITY_ADDR		romAddress.addrCompatAddr
#define CONF_TABLE_ADDR   		romAddress.confTableAddr
#define DISK_BASE_ADDR			romAddress.diskBaseAddr
#define DR_TYPE_ADDR           		romAddress.drTypeAddr
#define DISKETTE_IO_1_ADDR		romAddress.disketteIO1Addr
#define MD_TBL1_ADDR			romAddress.mdTbl1Addr
#define MD_TBL2_ADDR           		romAddress.mdTbl2Addr
#define MD_TBL3_ADDR		        romAddress.mdTbl3Addr
#define MD_TBL4_ADDR            	romAddress.mdTbl4Addr
#define MD_TBL5_ADDR            	romAddress.mdTbl5Addr
#define MD_TBL6_ADDR            	romAddress.mdTbl6Addr
#define RCPU_WAIT_INT_ADDR		romAddress.rcpuWaitAddr
#define DPB0				romAddress.diskParamBlock0
#define DPB1				romAddress.diskParamBlock1
#define VID_PARMS			romAddress.vidParms
#define VID_LENS			romAddress.vidLens
#define VID_COLTAB			romAddress.vidColTab
#define VID_MODTAB			romAddress.vidModTab
#define	CHAR_GEN_ADDR			romAddress.charGen
#define DOS_SCRATCH_PAD			romAddress.dosScratchPad
#define DOS_SCRATCH_PAD_END		romAddress.dosScratchPadEnd

/* Addresses in Intel memory of constant keyboard tables */

#define K6		romAddress.k6
#define K7		romAddress.k7
#define K8		romAddress.k8
#define K9		romAddress.k9
#define K10		romAddress.k10
#define K11		romAddress.k11
#define	K30		romAddress.k30

/* The Video Rom Stuff */

#ifdef 	EGG
#define EGA_SEG		EgaROMSegment
#define EGA_ROM_START	romAddress.egaStart	/* start of EGA BIOS ROM */
#define EGA_ROM_END	romAddress.egaEnd	/* end of EGA BIOS ROM +1 */
#define EGA_CGMN	romAddress.egaCgmn
#define EGA_CGDDOT	romAddress.egaCgDot
#define EGA_HIFONT	romAddress.egaHiFont
#endif		/* EGG */

#endif /* GISP_SVGA */

/*
 * Offsets for a set of instructions that are used in virtualisation
 * of our bios accesses (eg IO) on 386 & later processors.
 */

#define BIOS_STI_OFFSET   0x3000
#define BIOS_CLI_OFFSET   0x3010
#define BIOS_INB_OFFSET   0x3020
#define BIOS_INW_OFFSET   0x3030
#define BIOS_IND_OFFSET   0x3040
#define BIOS_OUTB_OFFSET  0x3050
#define BIOS_OUTW_OFFSET  0x3060
#define BIOS_OUTD_OFFSET  0x3070
#define BIOS_WRTB_OFFSET  0x3080
#define BIOS_WRTW_OFFSET  0x3090
#define BIOS_WRTD_OFFSET  0x30a0
#define BIOS_RDB_OFFSET   0x30b0
#define BIOS_RDW_OFFSET   0x30c0
#define BIOS_RDD_OFFSET   0x30d0
#define BIOS_YIELD_OFFSET 0x30e0
#define BIOS_STOSB_OFFSET 0x30f0
#define BIOS_STOSW_OFFSET 0x3110
#define BIOS_STOSD_OFFSET 0x3130
#define BIOS_BAD_OFFSET   0x3200	/* Must be added to sas.h + bios1.rom */


/* The addresses of the Bios timer/motor count variables in 8088 space */
#define TIMER_LOW 	BIOS_VAR_START + 0x6c
#define TIMER_HIGH 	BIOS_VAR_START + 0x6e
#define TIMER_OVFL 	BIOS_VAR_START + 0x70
#define MOTOR_STATUS	BIOS_VAR_START + 0x3F
#define MOTOR_COUNT	BIOS_VAR_START + 0x40


/*
 *  SAS Block Operations
 */
#define SAS_BLKOP_CHECKSUM 1

/*
 * Offset entry point for DEC's PCSA.
 */
#define PCSA_OFFSET	0x170

/* Union for accessing an entry in the Interrupt Vector table */
#ifdef BACK_M

#ifdef BIGEND
typedef union   {
		double_word all;
		struct  {
			half_word hw0;
			half_word hw1;
			half_word hw2;
			half_word hw3;
	        	} hwords;
		} IVT_ENTRY;
#endif

#ifdef LITTLEND
typedef union   {
		double_word all;
		struct  {
			half_word hw3;
			half_word hw2;
			half_word hw1;
			half_word hw0;
	        	} hwords;
		} IVT_ENTRY;
#endif

#else /* BACK_M */

#ifdef BIGEND
typedef union   {
		double_word all;
		struct  {
			half_word hw3;
			half_word hw2;
			half_word hw1;
			half_word hw0;
	        	} hwords;
		} IVT_ENTRY;
#endif

#ifdef LITTLEND
typedef union   {
		double_word all;
		struct  {
			half_word hw0;
			half_word hw1;
			half_word hw2;
			half_word hw3;
	        	} hwords;
		} IVT_ENTRY;
#endif
#endif /* BACK_M */

#if defined(NEC_98)

#ifndef RL_ROM

#define N_INT00_OFFSET  0x0936
#define N_INT01_OFFSET  0x0936
#define N_INT02_OFFSET  0x08f0
#define N_INT03_OFFSET  0x0936
#define N_INT04_OFFSET  0x0936
#define N_INT05_OFFSET  0x0936
#define N_INT06_OFFSET  0x0936
#define N_INT07_OFFSET  0x0936
#define N_INT08_OFFSET  0x0603
#define N_INT09_OFFSET  0x0E59
#define N_INT0A_OFFSET  0x0937
#define N_INT0B_OFFSET  0x0937
#define N_INT0C_OFFSET  0x1833
#define N_INT0D_OFFSET  0x0937
#define N_INT0E_OFFSET  0x0937
#define N_INT0F_OFFSET  0x0937
#define N_INT10_OFFSET  0x0937
#define N_INT11_OFFSET  0x0937
#define N_INT12_OFFSET  0x0937
#define N_INT13_OFFSET  0x0937
#define N_INT14_OFFSET  0x0937
#define N_INT15_OFFSET  0x0937
#define N_INT16_OFFSET  0x0937
#define N_INT17_OFFSET  0x0937
#define N_INT18_OFFSET  0x0ABD
#define N_INT19_OFFSET  0x1596
#define N_INT1A_OFFSET  0x0680
#define N_INT1B_OFFSET  0x1A82
#define N_INT1C_OFFSET  0x0500
#define N_INT1D_OFFSET  0x0936
#define N_INT1E_OFFSET  0x0000
#define N_INT1F_OFFSET  0x0200

#define H_INT00_OFFSET  0x01F3
#define H_INT01_OFFSET  0x01F3
#define H_INT02_OFFSET  0x0119
#define H_INT03_OFFSET  0x01F3
#define H_INT04_OFFSET  0x01F3
#define H_INT05_OFFSET  0x01F3
#define H_INT06_OFFSET  0x01F3
#define H_INT07_OFFSET  0x01F3
#define H_INT08_OFFSET  0x195b
#define H_INT09_OFFSET  0x08A8
#define H_INT0A_OFFSET  0x01F4
#define H_INT0B_OFFSET  0x01F4
#define H_INT0C_OFFSET  0x13F7
#define H_INT0D_OFFSET  0x01F4
#define H_INT0E_OFFSET  0x01F4
#define H_INT0F_OFFSET  0x01F4
#define H_INT10_OFFSET  0x2B05
#define H_INT11_OFFSET  0x01F4
#define H_INT12_OFFSET  0x01F4
#define H_INT13_OFFSET  0x01F4
#define H_INT14_OFFSET  0x01F4
#define H_INT15_OFFSET  0x01F4
#define H_INT16_OFFSET  0x01F4
#define H_INT17_OFFSET  0x01F4
#define H_INT18_OFFSET  0x0430
#define H_INT19_OFFSET  0x0D7A
#define H_INT1A_OFFSET  0x2AC0
#define H_INT1B_OFFSET  0x1B78
#define H_INT1C_OFFSET  0x1780
#define H_INT1D_OFFSET  0x0000
#define H_INT1E_OFFSET  0x01F3
#define H_INT1F_OFFSET  0x5DD0

#else

#define N_INT00_OFFSET  0x0936
#define N_INT01_OFFSET  0x0936
#define N_INT02_OFFSET  0x08F0
#define N_INT03_OFFSET  0x0936
#define N_INT04_OFFSET  0x0936
#define N_INT05_OFFSET  0x0936
#define N_INT06_OFFSET  0x0936
#define N_INT07_OFFSET  0x0936
#define N_INT08_OFFSET  0x064E
#define N_INT09_OFFSET  0x0E44
#define N_INT0A_OFFSET  0x0937
#define N_INT0B_OFFSET  0x0937
#define N_INT0C_OFFSET  0x183D
#define N_INT0D_OFFSET  0x0937
#define N_INT0E_OFFSET  0x0937
#define N_INT0F_OFFSET  0x0937
#define N_INT10_OFFSET  0x0936
#define N_INT11_OFFSET  0x0936
#define N_INT12_OFFSET  0x2369
#define N_INT13_OFFSET  0x22F7
#define N_INT14_OFFSET  0x0937
#define N_INT15_OFFSET  0x0937
#define N_INT16_OFFSET  0x0937
#define N_INT17_OFFSET  0x0937
#define N_INT18_OFFSET  0x0ABD
#define N_INT19_OFFSET  0x1596
#define N_INT1A_OFFSET  0x0680
#define N_INT1B_OFFSET  0x1A82
#define N_INT1C_OFFSET  0x0500
#define N_INT1D_OFFSET  0x0936
#define N_INT1E_OFFSET  0x0000
#define N_INT1F_OFFSET  0x0200

#define H_INT00_OFFSET  0x01BF
#define H_INT01_OFFSET  0x01BF
#define H_INT02_OFFSET  0x00E5
#define H_INT03_OFFSET  0x01BF
#define H_INT04_OFFSET  0x01BF
#define H_INT05_OFFSET  0x01BF
#define H_INT06_OFFSET  0x01BF
#define H_INT07_OFFSET  0x01BF
#define H_INT08_OFFSET  0x1876
#define H_INT09_OFFSET  0x07D8
#define H_INT0A_OFFSET  0x01C0
#define H_INT0B_OFFSET  0x01C0
#define H_INT0C_OFFSET  0x131E
#define H_INT0D_OFFSET  0x01C0
#define H_INT0E_OFFSET  0x01C0
#define H_INT0F_OFFSET  0x01C0
#define H_INT10_OFFSET  0x2755
#define H_INT11_OFFSET  0x0021
#define H_INT12_OFFSET  0x24FC
#define H_INT13_OFFSET  0x23E7
#define H_INT14_OFFSET  0x01C0
#define H_INT15_OFFSET  0x01C0
#define H_INT16_OFFSET  0x01C0
#define H_INT17_OFFSET  0x01C0
#define H_INT18_OFFSET  0x0360
#define H_INT19_OFFSET  0x0C80
#define H_INT1A_OFFSET  0x2710
#define H_INT1B_OFFSET  0x1A20
#define H_INT1C_OFFSET  0x1690
#define H_INT1D_OFFSET  0x0000
#define H_INT1E_OFFSET  0x01BF
#define H_INT1F_OFFSET  0x6400

#endif

#define N_BIOS_SEGMENT  0xFD80
#define BASIC_SEGMENT   0xE800
#define H_BIOS_SEGMENT  0xF800
#define H_GBIO_SEGMENT  0xF000

#define BIOS_MODE       0x0AC0
#define MACHINE_FLAG    0x0AB7
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\smeg.h ===
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DESIGNER		: Jeremy Maiden

REVISION HISTORY	:
First version		: May 1992


MODULE NAME		: smeg

SOURCE FILE NAME	: smeg.h

PURPOSE			: spy on cpus and things

SccsID			: @(#)smeg.h	1.5 08/10/92

*/

#include TypesH
#include SignalH
#include FCntlH
#include IpcH
#include ShmH
#include TimeH

#include <errno.h>

#define	SMEG_EOT	0
#define	SMEG_STRING	1
#define	SMEG_NUMBER	2
#define	SMEG_RATE	3
#define	SMEG_BOOL	4
#define	SMEG_ROBIN	5
#define	SMEG_PROFILE	6
#define	SMEG_DANGER	7


struct	SMEG_ITEM
{
	CHAR	name[32];
	ULONG	type;
	ULONG	colour;
	ULONG	sm_min, sm_max, sm_value, previous_sm_value;
};

#define	MAX_SMEG_ITEM	50

#define	BLACK	0
#define	RED	1
#define	GREEN	2
#define	YELLOW	3
#define	BLUE	4
#define	WHITE	5


#define	SHM_KEY	123456789

#define	COLLECT_DATA	0
#define	FREEZE_DATA		1

LOCAL	INT	shmid;		/* shared memory */
LOCAL	struct	SMEG_ITEM	*smegs;
LOCAL	ULONG	*pidptr;
LOCAL	ULONG	*cntrlptr;


/* sets up shared memory for communication with SoftPC in the same machine */
LOCAL	VOID	shm_init()

{
	/* if shared memory doesn't exist we'll have to invent it */
	shmid = shmget(SHM_KEY, MAX_SMEG_ITEM * sizeof(struct SMEG_ITEM), 0777);
	if (shmid  < 0)
	{
		shmid = shmget(SHM_KEY, MAX_SMEG_ITEM * sizeof(struct SMEG_ITEM), 0777 | IPC_CREAT);
		if (shmid < 0)
		{
			perror( "smeg" );
			printf("Can't create shared memory - exiting\n");
			exit(-1);
		}
	}
	pidptr = (ULONG *) shmat(shmid, NULL, 0);
	cntrlptr = pidptr + 1;
	smegs = (struct SMEG_ITEM *)( pidptr + 2 );
}


LOCAL	INT	shm_in_contact()

{
	struct	shmid_ds	desc;

	shmctl(shmid, IPC_STAT, &desc);
	return(desc.shm_nattch > 1);
}


LOCAL	VOID	shm_terminate()

{
	struct	shmid_ds	desc;

	shmdt(smegs);	/* detach from shared memory */
	shmctl(shmid, IPC_STAT, &desc);
	if (desc.shm_nattch == 0)	/* if we're the last, delete it */
		shmctl(shmid, IPC_RMID, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\rom.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: ROM Space definitions
 *
 * Description	: Definitions for users of the Saved ROM
 *
 * Author	: Paul Huckle
 *
 * Mods: (r3.2) : On the Mac II running MultiFinder, we can't have much
 *                static storage, so big arrays are verboten. Hence use
 *                malloc() to grab storage from the heap, and declare
 *                pointers instead.		  
 */

/* SccsID[]="@(#)rom.h	1.9 10/30/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifndef macintosh
    extern half_word ROM_BIOS1[];
    extern half_word ROM_BIOS2[];
#endif

IMPORT void rom_init IPT0();
IMPORT void rom_checksum IPT0();
IMPORT void copyROM IPT0();
IMPORT void search_for_roms IPT0();
IMPORT void read_video_rom IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\smeg_hea.h ===
/*[
************************************************************************

        Name:           smeg_head.h
        Author:         W. Plummer
        Created:        May 1992
        Sccs ID:        @(#)smeg_head.h	1.4 08/10/92
        Purpose:        Stats Gathering for the SMEG utility

        (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

************************************************************************
]*/

#ifdef SMEG

/*
 * Smeg Variables....
 */

#define SMEG_IN_DELTA			0
#define SMEG_IN_VIDEO			1
#define SMEG_IN_IDLE			2
#define SMEG_IN_PM			3
#define SMEG_IN_DELTA_COMPILER		4
#define SMEG_IN_USER		5
#define SMEG_IN_GDI		6
#define SMEG_IN_KERNEL		7
#define SMEG_IN_OTHER		8
#define NR_OF_SAMPLE_TYPES		SMEG_IN_OTHER + 1

#define SMEG_NR_OF_THREADED_COMPS	9
#define SMEG_NR_OF_WRITECHECK_CALLS	10
#define SMEG_NR_OF_DESCR_COMPS		11
#define SMEG_NR_OF_REGN_INDEX_UPDS	12
#define SMEG_NR_OF_STACKCHECK_CALLS	13
#define SMEG_NR_OF_INTRPT_CHECKS_FAST	14
#define SMEG_NR_OF_INTRPT_CHECKS_SLOW	15
#define SMEG_NR_OF_FRAG_ENTRIES		16
#define SMEG_NR_OF_REGN_UPDS		17
#define SMEG_NR_OF_OVERWRITES		18
#define SMEG_NR_OF_CHECKOUTS		19
#define SMEG_NR_OF_STRINGWRITE_CALLS	20
#define SMEG_NR_OF_STRINGREAD_CALLS	21
#define SMEG_NR_OF_STRUCTCHECK_CALLS	22
#define SMEG_NR_OF_READCHECK_CALLS	23

#define SMEG_WIN_APIS			24



#define SMEG_START		(GG_FIRST+20)
#define SMEG_SAVE		(SMEG_START)
#define SMEG_BASE		((SMEG_SAVE)+2*sizeof(ULONG))

/*
 * Smeg Macros
 */

/* increment GDP variable */

#define SMEG_INC(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_SAVE)) = X1>					\
	<X1 = *(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG)))>		\
	<nop_after_load>						\
	<X1 += 1>							\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = X1>		\
	<X1 = *(Gdp + ^(SMEG_SAVE))>					\
	<nop_after_load>						\
    }


/* set GDP variable non zero */

#define SMEG_SET(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = Sp>		\
    }


/* set GDP variable to zero */

#define SMEG_CLEAR(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = Zero>	\
    }


#else /* SMEG */

#define SMEG_INC(smeg_id)		/* SMEG_INC == NOP */
#define SMEG_SET(smeg_id)		/* SMEG_SET == NOP */
#define SMEG_CLEAR(smeg_id)		/* SMEG_CLEAR == NOP */

#endif /* SMEG */

#define SMEG_TRUE  1
#define SMEG_FALSE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\spcfile.h ===
/*
	SccsID @(#)host_unix.h	1.1 10/2/90 Copyright Insignia Solutions Ltd
*/
#define STANDARD	1234
#define SILENT		2345
#define CONT_AND_QUIT	3456

extern char *host_find_file();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\standard.h ===
/*
*	MODULE:		standard.h
*
*	PURPOSE:	Some macros and forward declarations to make
*				life a bit easier.
*
*	AUTHOR:		Jason Proctor
*
*	DATE:		Fri Aug 11 1989
*/

/* SccsID[]="@(#)standard.h	1.4 08/10/92 Copyright Insignia Solutions Ltd."; */

#ifndef FILE
#include <stdio.h>
#endif

/* boolean stuff */
#define bool int		/* best way I have for declaring bools */
#define NOT		!

#ifndef TRUE
#define FALSE	0
#define TRUE	!0
#endif /* ! TRUE */

/* for system calls etc */
#undef SUCCESS
#undef FAILURE
#define SUCCESS	0
#define FAILURE	~SUCCESS

/* equivalence testing */
#define EQ		==
#define NE		!=
#define LT		<
#define GT		>
#define LTE		<=
#define GTE		>=

/* operators */
#define AND		&&
#define OR		||
#define XOR		^
#define MOD		%

/* hate single quotes! */
#define SPACE	' '
#define LF		'\n'
#define TAB		'\t'
#define Null	'\0'
#define SINGLEQ	'\''
#define DOUBLEQ	'"'
#define SHRIEK	'!'
#define DOLLAR	'$'
#define HYPHEN	'-'
#define USCORE	'_'
#define DECPOINT	'.'

/* for ease in deciphering ioctl-infested listings etc */
#define STDIN	0
#define STDOUT	1
#define STDERR	2

/* for readability only */
#define NOWORK
#define NOBREAK
#define TYPECAST

/* null pointer as a long */
#undef NULL
#define NULL	0L

/* to escape compiler warnings and lint errors etc */
#define CNULL	TYPECAST (char *) 0L
#define FNULL	TYPECAST (int (*) ()) 0L

/* some stuff to help out */
#define streq(x, y)	(strcmp (x, y) == 0)

/* standard stuff */
extern char *malloc ();
extern char *getenv ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\sndblst.h ===
/***************************************************************************
*
*    nt_sb.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/

/*
*    Hardware and version information
*    In DOS terms: SET BLASTER=A220 I5 D1 T3
*/

#define SB_VERSION          0x201       // SB 2.0 (DSP 2.01+)
#define VSB_INTERRUPT       0x05        // Interrupt 5
#define VSB_DMA_CHANNEL     0x01        // DMA Channel 1
#define NO_DEVICE_FOUND     0xFFFF      // returned if no device found

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

extern USHORT SbDmaChannel;
extern USHORT SbInterrupt;

/*
*    General function prototypes
*/

BOOL
SbInitialize(
    VOID
    );

VOID
SbTerminate(
    VOID
    );

VOID
SbGetDMAPosition(
    VOID
    );

VOID
ResetAll(
    VOID
    );

/*****************************************************************************
*
*    #DSP related definitions
*
*****************************************************************************/

/*
*    DSP Ports
*/

#define RESET_PORT          0x06        // used to reset SoundBlaster
#define READ_STATUS         0x0E        // 0xFF-data to read, 0x7F-no data to read
#define READ_DATA           0x0A        // App reads data from this port
#define WRITE_STATUS        0x0C        // 0x7f-port ready, 0xFF-port not ready
#define WRITE_PORT          0x0C        // Data or command

/*
*    Only implemented commands are defined
*/

/*
*    DSP commands - miscellaneous
*/

#define DSP_GET_VERSION     0xE1    // dsp version command
#define DSP_CARD_IDENTIFY   0xE0    // byte inverter
#define DSP_TABLE_MUNGE     0xE2    // jump table munging
#define DSP_LOAD_RES_REG    0xE4    // load byte into reserved register
#define DSP_READ_RES_REG    0xE8    // read byte from reserved register
#define DSP_GENERATE_INT    0xF2    // generate an interrupt

/*
*    DSP commands - speaker
*/

#define DSP_SPEAKER_ON      0xD1    // speaker on command
#define DSP_SPEAKER_OFF     0xD3    // speaker off command

/*
*    DSP commands - DMA mode
*/

#define DSP_SET_SAMPLE_RATE 0x40    // set the sample rate (one byte format)
#define DSP_SET_BLOCK_SIZE  0x48    // set dma block size
#define DSP_PAUSE_DMA       0xD0    // pause dma
#define DSP_CONTINUE_DMA    0xD4    // continue dma
#define DSP_STOP_AUTO       0xDA    // Stop auto init dma

#define DSP_WRITE           0x14    // Start single cycle output (8-bit PCM mono)
#define DSP_WRITE_HS        0x91    // Start single cycle high-speed output (8-bit PCM mono)
#define DSP_WRITE_AUTO      0x1C    // Start auto init output (8-bit PCM mono)
#define DSP_WRITE_HS_AUTO   0x90    // Start auto init high=speed output (8-bit PCM mono)
#define DSP_READ            0x24    // Start single cycle input (not implemented)

//
// DSP commands - MIDI
//

#define MIDI_READ_POLL                          0x30
#define MIDI_READ_INTERRUPT                     0x31
#define MIDI_READ_TIMESTAMP_POLL        0x32
#define MIDI_READ_TIMESTAMP_INTERRUPT   0x33
#define MIDI_READ_POLL_WRITE_POLL_UART  0x34
#define MIDI_READ_INTERRUPT_WRITE_POLL_UART     0x35
#define MIDI_READ_TIMESTAMP_INTERRUPT_WRITE_POLL_UART   0x37
#define MIDI_WRITE_POLL                         0x38

#define MPU_RESET                               0xFF    // Enables & Sets MIDI to use both ports
#define MPU_PASSTHROUGH_MODE    0x3F    // Starts dumb mode; only active command is set path
#define MPU_GET_VERSION                 0xAC    // Returns version number after acknowledge
#define MPU_GET_REVISION                0xAD    // BUGBUG: Returns 0x09, for some unknown reason!
#define MPU_PORTS_AVAILABLE             0xAE    // Which ports are available? (bit0=port1, bit1=port2)
#define MPU_SET_MIDI_PATH               0xEB    // Sets which port(s) will be used
#define MPU_DUMB_WAVETABLE              0xF1    // Turns on wavetable synth for dumb mode
#define MPU_DUMB_EXTERNAL               0xF2    // Turns on external MIDI for dumb mode
#define MPU_DUMB_BOTH                   0xF3    // Turns on both wavetable synth and external MIDI

/*
*    Performance parameters for single and auto-init DMA fine tuning
*/
#define AUTO_BLOCK_SIZE     0x200   // size of each buffer in auto
#define DEFAULT_LOOKAHEAD   0x600   // target # of bytes to queue to kernel driver
#define MAX_WAVE_BYTES      0x3000  // maximum # of bytes to queue to kernel driver
#define SINGLE_PIECES       2       // number of pieces in each single write
#define SINGLE_SLEEP_ADJ    15      // number of overhead milliseconds in single
#define DSP_BUFFER_TOTAL_BURSTS (MAX_WAVE_BYTES / AUTO_BLOCK_SIZE)

/*****************************************************************************
*
*    #FM related definitions
*
*****************************************************************************/

/*
*    OPL2/Adlib Ports
*/

#define ADLIB_REGISTER_SELECT_PORT 0x388 // select the register to write data
#define ADLIB_STATUS_PORT          0x388 // read to determine opl2 status
#define ADLIB_DATA_PORT            0x389 // write data port

/*
*    FM information
*/

#define AD_MASK             0x04    // adlib register used to control opl2
#define AD_NEW              0x105   // used to determine if app entering opl3 mode
#define BATCH_SIZE          40      // how much data is batched to opl2

typedef struct {                    // structure written to fm device
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;

/*****************************************************************************
*
*    #Mixer related definitions
*
*****************************************************************************/

/*
*    Mixer Ports
*/

#define MIXER_ADDRESS       0x04        // Mixer address port
#define MIXER_DATA          0x05        // Mixer data port

/*
*    Mixer Commands
*/

#define MIXER_RESET         0x00    // reset mixer to initial state
#define MIXER_MASTER_VOLUME 0x02    // set master volume
#define MIXER_FM_VOLUME     0x06    // set opl2 volume
#define MIXER_CD_VOLUME     0x08    // set cd volume
#define MIXER_VOICE_VOLUME  0x0A    // set wave volume


//
// Midi ports
//

#define MPU401_DATA_PORT        0x330
#define ALT_MPU401_DATA_PORT    0x300
#define MPU401_COMMAND_PORT     0x331
#define ALT_MPU401_COMMAND_PORT 0x301

#define MPU_INTELLIGENT_MODE    0
#define MPU_UART_MODE           1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\suplib.h ===
/*[
 *	Name:		suplib.h
 *
 *	Derived from:	None
 *
 *	Author:		James Bowman
 *
 *	Created on:	17 Nov 93
 *
 *	Sccs ID:	@(#)suplib.h	1.5 08/19/94
 *
 *	Coding stds:	2.0
 *
 *	Purpose:	Declarations for functions in the sup library
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/

#ifndef	_SUPLIB_H
#define _SUPLIB_H

/* Try to guess a PATHSEP_CHAR, if we don't already have one.
 * Use Mac or NT correct values, otherwise use UNIX '/'
 */

#ifndef PATHSEP_CHAR

#ifdef macintosh
#define	PATHSEP_CHAR 	':'
#endif

#ifdef NTVDM
#define PATHSEP_CHAR	'\\'
#endif

#ifndef PATHSEP_CHAR
#define PATHSEP_CHAR	'/'	/* default UNIX separator */
#endif

#endif /* PATHSEP_CHAR */

typedef char HOST_PATH;

/*
 * Path completion module
 */

GLOBAL HOST_PATH *Host_path_complete IPT3(
    HOST_PATH *, buf,		/* buffer for resulting pathname */ 
    HOST_PATH *, dirPath,		/* directory pathname */
    char *, fileName		/* file name to be appended */
);


/*
 * Generated File module
 */

typedef IBOOL (*DifferProc) IPT4(IUM32, where, IU8 *, oldData, IU8 *, newData, IUM32, size);

GLOBAL FILE *GenFile_fopen IPT4(
  char *, true_name,
  char *, mode,
  DifferProc, ignoreDifference,
  int, verbosity);
GLOBAL void GenFileAbortAllFiles IPT0();
GLOBAL void GenFileAbortFile IPT1(FILE *, file);
GLOBAL int  GenFile_fclose IPT1(FILE *, file);
GLOBAL int GenFile_fclose IPT1(FILE *, file);
#endif	/* _SUPLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\spc_icon.h ===
/*[
************************************************************************
	Name:			spc_icon.h	(Originally SoftPC_icon.h)
	Author/Designer:	SoftPC		Unknown
				SoftWindows	Bruce Anderson
	Sccs ID:		@(#)spc_icon.h	1.4 06/29/94

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

	Purpose:		SoftPC's default icon bitmap
************************************************************************
]*/
#ifdef SOFTWINDOWS
#define icon_mask_width 80
#define icon_mask_height 48
static unsigned char icon_mask_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
   0x00, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe1, 0xff,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xef, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xe7, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7,
   0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xef, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7,
   0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7, 0x79, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x7e, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x78, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#define spc_icon_width 80
#define spc_icon_height 48
static unsigned char spc_icon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xf8,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0xfe, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xff, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x76, 0xc7, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x10, 0x12, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
   0x40, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xc3,
   0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x76, 0xc3, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x12, 0xf3, 0x33, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x90, 0x40, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xc0, 0x74, 0xc7, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x76, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x12, 0xc3,
   0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0xc3, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xc3, 0x30, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x76, 0xfb, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x10, 0x12, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
   0x40, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0x0f,
   0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x76, 0x03, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xb0, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50,
   0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x2d, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x24, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x50, 0xa5, 0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x50, 0xad, 0x4a, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
   0xb5, 0x4a, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xa5, 0x31,
   0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

#else /* Not SOFTWINDOWS */
#define spc_icon_width 48
#define spc_icon_height 48
static unsigned char spc_icon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00,
   0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x01, 0x00,
   0x00, 0xe0, 0xff, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x07, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x1f, 0x00,
   0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0x00,
   0x80, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x01,
   0xe0, 0xff, 0xff, 0xff, 0x3f, 0x03, 0xf0, 0xff, 0xff, 0xff, 0xdf, 0x07,
   0xf8, 0xff, 0xff, 0xff, 0xdf, 0x0f, 0xfc, 0xff, 0xff, 0xff, 0xdf, 0x1f,
   0xfe, 0xff, 0xff, 0xff, 0xa3, 0x37, 0xfc, 0xff, 0xff, 0xff, 0x5d, 0x17,
   0xf8, 0xff, 0xff, 0xff, 0xd9, 0x08, 0xf0, 0xff, 0xff, 0xff, 0xc3, 0x07,
   0xe0, 0xff, 0xff, 0xff, 0xe7, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xcf, 0x01,
   0x80, 0xff, 0xff, 0x5f, 0x9c, 0x00, 0x00, 0xff, 0xff, 0xef, 0x5c, 0x00,
   0x00, 0xfe, 0xff, 0x6f, 0x2d, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x13, 0x00,
   0x00, 0xf8, 0xff, 0x9f, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x5f, 0x05, 0x00,
   0x00, 0xe0, 0xff, 0xe3, 0x02, 0x00, 0x00, 0xc0, 0x9f, 0x5d, 0x01, 0x00,
   0x00, 0x80, 0xcf, 0xdd, 0x00, 0x00, 0x00, 0x00, 0xef, 0x5d, 0x00, 0x00,
   0x00, 0x00, 0x0e, 0x22, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1c, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0x0d, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif /* SOFTWINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\swinmgre.h ===
/*[
 *      Name:           swinmgrE.h
 *
 *      Derived From:   (original);
 *
 *      Author:         Antony Helliwell
 *
 *      Created On:     22 Apr 1993
 *
 *      Sccs ID:        @(#)swinmgrE.h	1.1 8/2/93
 *
 *      Purpose:        External Interface to SoftWindows CPU routines
 *
 *	Design document:
 *			-
 *
 *	Test document:
 *
 *      (c); Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/

/* Enable patching to pre-compiled Windows fragments */
GLOBAL VOID	ApiEnable IPT0();
/* Disable patching to pre-compiled Windows fragments */
GLOBAL VOID	ApiDisable IPT0();
/* Clear the table of recorded Windows segment information */
GLOBAL VOID	ApiResetWindowsSegment IPT0();
/* Register a Windows segment with the CPU. */
GLOBAL VOID	ApiRegisterWinSeg IPT2(ULONG, nominal_sel, ULONG, actual_sel);
/* Register a fixed Windows segment with the CPU. */
GLOBAL VOID	ApiRegisterFixedWinSeg IPT2(ULONG, actual_sel, ULONG, length);
/* Compile all fixed Windows segment descriptors */
GLOBAL VOID	ApiCompileFixedDesc IPT0();
/* Get the Windows segment selector for the given nominal selector */
GLOBAL ULONG	ApiGetRealSelFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea32b for the given nominal selector */
GLOBAL IHP	ApiGetSegEa32FromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea24 for the given nominal selector */
GLOBAL ULONG	ApiGetSegBaseFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows descriptor base for the given nominal selector */
GLOBAL IHP	ApiGetDescBaseFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea24 for the given actual selector */
GLOBAL ULONG	ApiSegmentBase IPT1(ULONG, actual_sel);
/* Get the Windows descriptor base for the given actual selector */
GLOBAL IHP	ApiDescriptorBase IPT1(ULONG, actual_sel);
/* Return the maximum number of fixed Windows segments supported */
GLOBAL ULONG	ApiFixedDescriptors IPT0();

GLOBAL VOID	ApiBindBinary IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\swinhelp.h ===
/*(
 * ============================================================================
 * 
 * 	Name:		swinhelp.h
 *
 * 	Author:		Anthony Shaughnessy
 *
 * 	Created on:	4th July 1994
 *
 * 	Sccs ID:	@(#)swinhelp.h	1.1 07/13/94
 *
 * 	Purpose:	Manifest constants to be used with context sensitive
 * 			help.  The numbers are the contexts, which are passed
 * 			to the context help system to give the relevant help.
 *			Designed to be used with HyperHelp from Bristol.
 *
 *	(c) Copyright Insignia Solutions Ltd., 1994.  All rights reserved.
 *
 * ============================================================================
)*/

/*[
 * ============================================================================
 *
 *	Numbers in here can be changed, but take care to avoid conflicts with
 *	other numbers defined in the project file.  Note that if any numbers
 *	are changed, both the SoftWindows executable and the HyperHelp (.hlp)
 *	file must be recompiled.
 *
 *	It is suggested that any additional values defined in your project
 *	file or another include file should be above 200 to avoid conflict.
 *
 * ============================================================================
]*/

/*[
 * ============================================================================
 *
 *	Contexts which we think may be called from scripts etc. which invoke
 *	the hyperhelp executable - may be passed on the command line:
 *
 *			hyperhelp helpfile.hlp -c 1
 *
 *	May also be called from within the executable.
 *
 * ============================================================================
]*/

#define HELP_MAIN	1		/* Contents page */
#define HELP_INSTALL	2		/* Installing SoftWindows */

/*[
 * ============================================================================
 *
 *	Contexts that are called from within our executable:
 *
 *		WinHelp(Display, helpfile, HELP_CONTEXT, HELP_DISPLAY);
 *
 * ============================================================================
]*/

#define HELP_DISPLAY	101		/* Display dialog */
#define HELP_OPEN	102		/* Open disk dialog */
#define HELP_NEW	103		/* New disk dialog */
#define HELP_PRINTER	104		/* Printer types dialog */
#define HELP_COM	105		/* Com ports dialog */
#define HELP_KEYBOARD	106		/* Keyboard map file dialog */
#define HELP_MEMORY	107		/* Memory dialog */
#define HELP_AUTOFLUSH	108		/* Autoflush dialog */
#define HELP_FILESELECT	109		/* Generic file selection box */
#define HELP_SOUND	110		/* Sound device dialog */
#define HELP_MENUS	111		/* Main menu bar */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\tape_io.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: IBM PC Cassette IO BIOS declarations
 *
 * Description	: This module contains definitions that are used in
 *		  accessing the Cassette IO BIOS. In the AT BIOS, the
 *		  original Cassette IO functionality has been greatly
 *		  extended to provide support for multi-tasking systems.
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	: For a detailed description of the XT and AT Cassette IO
 *		  BIOS functions, refer to the following manuals:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section A-72 System BIOS)
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 5-164 BIOS1)
 */

/* SccsID[]="@(#)tape_io.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Cassette I/O Functions
 */

#define	INT15_INVALID			0x86
#ifdef JAPAN
#define INT15_GET_BIOS_TYPE		0x49
#define INT15_KEYBOARD_INTERCEPT	0x4f
#define INT15_GETSET_FONT_IMAGE		0x50
#define INT15_EMS_MEMORY_SIZE		512
#endif // JAPAN

/*
 * Multi-tasking Extensions
 */

/* device open */
#define	INT15_DEVICE_OPEN		0x80

/* device close */
#define	INT15_DEVICE_CLOSE		0x81

/* program termination */
#define	INT15_PROGRAM_TERMINATION	0x82

/* event wait */
#define	INT15_EVENT_WAIT		0x83
#define	INT15_EVENT_WAIT_SET		0x00
#define	INT15_EVENT_WAIT_CANCEL		0x01

/* joystick support */
#define	INT15_JOYSTICK			0x84
#define	INT15_JOYSTICK_SWITCH		0x00
#define	INT15_JOYSTICK_RESISTIVE	0x01

/* system request key pressed */
#define	INT15_REQUEST_KEY		0x85
#define	INT15_REQUEST_KEY_MAKE		0x00
#define	INT15_REQUEST_KEY_BREAK		0x01

/* timed wait */
#define	INT15_WAIT			0x86

/* block move */
#define	INT15_MOVE_BLOCK		0x87

/* extended memory size determine */
#define	INT15_EMS_DETERMINE		0x88

/* processor to virtual mode */
#define	INT15_VIRTUAL_MODE		0x89

/* device busy loop and interrupt complete */
#define	INT15_DEVICE_BUSY		0x90
#define	INT15_INTERRUPT_COMPLETE	0x91
#define	INT15_DEVICE_DISK		0x00
#define	INT15_DEVICE_FLOPPY		0x01
#define	INT15_DEVICE_KEYBOARD		0x02
#define	INT15_DEVICE_NETWORK		0x80
#define	INT15_DEVICE_FLOPPY_MOTOR	0xfd
#define	INT15_DEVICE_PRINTER		0xfe

/* return configuration parameters pointer */
#define	INT15_CONFIGURATION		0xc0

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void cassette_io()
 *	{
 *		This routine performs the Cassette I/O BIOS function. When
 *		an INT 15 occurs, the assembler BIOS calls this function to
 *		do the actual work involved using a BOP instruction.
 *
 *		As no Cassette device is implemented on SoftPC, the
 *		Cassette I/O functions just return with an appropriate error.
 *
 *		On the AT, INT 15 is used to provide multi-tasking support
 *		as an extension to the Cassette I/O functionality. Most
 *		of these functions are supported in the same way as in
 *		real AT BIOS.
 *	}
 */
extern	void cassette_io();

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\timestmp.h ===
/*[
*************************************************************************

	Name:		timestmp.h
	Author:		Simon Frost
	Created:	May 1994
	Derived from:	Original
	Sccs ID:	@(#)timestmp.h	1.1 06/27/94
	Purpose:	Include file for timestamp data structures & functions

	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.

Note: these timestamp functions are used by the quick event system to 
recalibrate the time convertion. Functionally, they may be the same as
those used for the profiling system, but are declared seperately as the
same mechanism may not be suitable for both uses.
*************************************************************************
]*/
/* main data structure for timestamp functions to manipulate */
typedef struct {
	IUH data[2];
} QTIMESTAMP, *QTIMESTAMP_PTR;

void host_q_timestamp_init IPT0();
IUH host_q_timestamp_diff IPT2(QTIMESTAMP_PTR, tbegin, QTIMESTAMP_PTR, tend);
void host_q_write_timestamp IPT1(QTIMESTAMP_PTR, stamp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\tgdc.h ===
#if defined(NEC_98)
/* TEXT GDC include file */

/* TGDC port address     */
#define TGDC_READ_STATUS                        0x60
#define TGDC_WRITE_PARAMETER            0x60
#define TGDC_WRITE_COMMAND                      0x62
#define TGDC_READ_DATA                          0x62
#define TGDC_CRT_INTERRUPT                      0x64
#define TGDC_WRITE_MODE1                        0x68
#define TGDC_WRITE_BORDER                       0x6C

/* TGDC command number */
#define GDC_RESET0              0x00
#define GDC_RESET1              0x01
#define GDC_RESET2              0x09

#define GDC_SYNC0               0x0E
#define GDC_SYNC1               0x0F

#define GDC_START0              0x6B
#define GDC_START1              0x0D

#define GDC_STOP0               0x0c
#define GDC_STOP1               0x05

#define GDC_SCROLL              0x70

#define GDC_CSRFORM             0x4B

#define GDC_PITCH               0x47

#define GDC_VECTW               0x4C

#define GDC_CSRW                0x49

#define GDC_CSRR                0xE0

#define GDC_WRITE               0x20

#define GDC_READ                0xA0

/* TGDC structures */

typedef struct
{
                        unsigned char   command;
                        int                             count;
                        unsigned char   param[16];
} NOW_COMMAND;

typedef struct
{
                        unsigned char   border;
                        unsigned char   sync[8];
                        unsigned char   scroll[16];
                        unsigned char   pitch;
                        unsigned char   csrform[3];
                        BOOL                    startstop;
                        NOW_COMMAND             now;
} TGDC_GLOBS;

extern TGDC_GLOBS tgdcglobs;

typedef struct
{
        unsigned char   modeff_data[8];
        unsigned char   modeff2_data[7];
} MODEFF_GLOBS;

extern MODEFF_GLOBS modeffglobs;

IMPORT void text_gdc_init IPT0();
IMPORT void text_gdc_inb IPT2(io_addr, port, half_word *, value);
IMPORT void text_gdc_outb IPT2(io_addr, port, half_word *, value);
IMPORT void text_gdc_post IPT0();

IMPORT void VSYNC_beats IPT0();
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\tmstrobe.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: time_strobe.h
 *
 * Description	: Interface specification for routines to be
 *		  called from the timeri tick. 
 *
 * Author(s)	: Leigh Dworkin
 *
 * Notes	: 
 */
 
/* SccsID[]="@(#)tmstrobe.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void time_strobe()
 *	{
 *		This function comprises all the base functions to
 *		be performed in the timer tick. Every PC tick (about 20Hz)
 *		this routine is called from the host in xxx_timer.c
 *	}
 */
extern	void time_strobe();

/*
 *	void callback(num_pc_ticks, routine)
 *	long num_pc_ticks;
 *	void (*routine)();
 *	{
 *		This function calls the routine when num_pc_ticks have
 *		elapsed.
 *	}
 */
extern	void callback();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\tcpip.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			tcpip.h
 *	Derived From:	Original
 *	Author:			Jase
 *	Created On:		Jan 22 1993
 *	Sccs ID:		07/14/93 @(#)tcpip.h	1.3
 *	Purpose:		Defines & typedefs for the TCP/IP implementation.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 *	Rcs ID:			
 *			$Source$
 *			$Revision$
 *			$Date$
 *			$Author$
 ]*/

/********************************************************/

/* DEFINES */

/* LAN Workplace function codes */
#define kTCPAccept					0x01
#define kTCPBind					0x02
#define kTCPClose					0x03
#define kTCPConnect					0x04
#define kTCPGetMyIPAddr				0x05
#define kTCPGetMyMacAddr			0x06
#define kTCPGetPeerName				0x07
#define kTCPGetSockName				0x08
#define kTCPGetSockOpt				0x09
#define kTCPGetSubnetMask			0x0a
#define kTCPIoctl					0x0b
#define kTCPListen					0x0c
#define kTCPSelect					0x0d
#define kTCPSetMyIPAddr				0x0e
#define kTCPSetSockOpt				0x0f
#define kTCPShutdown				0x10
#define kTCPSocket					0x11
#define kTCPRecv					0x12
#define kTCPRecvFrom				0x13
#define kTCPSend					0x14
#define kTCPSendTo					0x15
#define kTCPGetBootpVSA				0x16
#define kTCPGetSNMPInfo				0x17
#define kTCPGetPathInfo				0x18

/* LAN Workplace ioctl selectors */
#define	kIoctlFionRead				26239
#define	kIoctlFionBIO				26238
#define	kIoctlAtMark				29477
#define	kIoctlSetUrgHandler			3

/* LAN Workplace error numbers Unix doesn't have */
#define	EOK							0

/* LAN Workplace error numbers */
#define	kEOK			        	0
#define	kEBADF						9
#define	kEINVAL						22
#define	kEWOULDBLOCK				35
#define	kEINPROGRESS				36
#define	kEALREADY					37
#define	kENOTSOCK					38
#define	kEDESTADDRREQ				39
#define	kEMSGSIZE					40
#define	kEPROTOTYPE					41
#define	kENOPROTOOPT				42
#define	kEPROTONOSUPPORT			43
#define	kESOCKTNOSUPPORT			44
#define	kEOPNOTSUPP					45
#define	kEPFNOSUPPORT				46
#define	kEAFNOSUPPORT				47
#define	kEADDRINUSE					48
#define	kEADDRNOTAVAIL				49
#define	kENETDOWN					50
#define	kENETUNREACH				51
#define	kENETRESET					52
#define	kECONNABORTED				53
#define	kECONNRESET					54
#define	kENOBUFS					55
#define	kEISCONN					56
#define	kENOTCONN					57
#define	kESHUTDOWN					58
#define	kETOOMANYREFS				59
#define	kETIMEDOUT					60
#define	kECONNREFUSED				61
#define	kELOOP						62
#define	kENAMETOOLONG				63
#define	kEHOSTDOWN					64
#define	kEHOSTUNREACH				65
#define	kEASYNCNOTSUPP				67

/* items in error table */
#define	kErrorTableEntries \
	(sizeof (ErrorTable) / sizeof (ErrorTable [0]))

/* asynchronous request mask */
#define	kNoWaitMask					0x80

/* maximum packet size */
#define kInitialTCPBufferSize		1024

/* config keys */
#define	sScriptKey					"SCRIPT"
#define	sProfileKey					"PROFILE"
#define	sLWPCFGKey					"LWP_CFG"
#define	sTCPCFGKey					"TCP_CFG"
#define	sLANGCFGKey					"LANG_CFG"

/* default values for config keys */
#define	sDefaultScriptPath			"C:\\NET\\SCRIPT"
#define	sDefaultProfilePath			"C:\\NET\\PROFILE"
#define	sDefaultLWPCFGPath			"C:\\NET\\HSTACC"
#define	sDefaultTCPCFGPath			"C:\\NET\\TCP"
#define	sDefaultLANGCFGPath			"C:\\NET\\BIN"

/********************************************************/

/* TYPEDEFS */

typedef struct
{
	IBOOL			tcpInitialised;
	int				tcpBufSize;
	char			*tcpBuffer;

} TCPGlobalRec;

typedef struct
{
	IU8				hostError;
	IU8				lanwError;

}	ErrorConvRec;

/********************************************************/

/* PROTOTYPES */

/* GLOBAL */

/* TCP/IP entry points */
GLOBAL void			TCPInit IPT0 ();
GLOBAL void			TCPEntry IPT0 ();
GLOBAL void			TCPInterrupt IPT0 ();
GLOBAL void			TCPTick IPT0 ();
GLOBAL void			TCPEvent IPT0 ();

#ifndef	PROD
extern void			force_yoda IPT0 ();
#endif

/* host functions accessed */
extern void			host_raise_sigio_exception IPT0 ();

/********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\timer.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Timer Adaptor definitions
 *
 * Description	: Definitions for users of the Timer Adaptor 
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	: None
 *
 * Mods: (r3.2) : Export the variable timer_video_enabled, which is
 *                set in mda.c and cga.c when the bit in the mode
 *                register of the 6845 chip which controls whether
 *                the video display is on or off is flipped. (SCR 257).
 *
 *       (r3.3) : Remove definition of struct timeval and stuct timezone
 *                for SYSTEMV. Equivalent host_ structures are now declared
 *                in host_time.h.
 */
/* SccsID[]="@(#)timer.h	1.15 10/27/93 Copyright Insignia Solutions Ltd."; */
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
/*
 * Information about the PC timer itself
 */
#define TIMER_CLOCK_RATE        1193180L	/* Count rate of timer chip Hz */
#define TIMER_MICROSECS_PER_TICK (1000000.0 / TIMER_CLOCK_RATE)
#define MIN_COUNTER_VAL         65536L           /* This many ticks at TIMER_CLOCK_RATE = 18.2 ms */
#define PC_TICK_INTV		(MIN_COUNTER_VAL * (1000000.0 / TIMER_CLOCK_RATE))
#define TIMER_BIT_MASK 0x3e3
#define GATE_SIGNAL_LOW		0
#define GATE_SIGNAL_HIGH	1
#define GATE_SIGNAL_RISE	2

/*
 * Our internal structures
 */

typedef struct
{
	word nticks;
	unsigned long wrap;
} Timedelta;

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern ULONG get_DOS_ticks IPT0(); /* get current DOS ticks */

extern void timer_init IPT0();
extern void timer_post IPT0();
extern void axe_ticks IPT1(int, ticks);
extern void SWTMR_init_funcptrs IPT0();
extern void SWTMR_inb IPT2(io_addr, port, half_word *, value);
extern void SWTMR_outb IPT2(io_addr, port, half_word, value);
extern void SWTMR_gate IPT2(io_addr, port, half_word, value);
extern void SWTMR_time_tick IPT0();
extern void host_release_timeslice IPT0();

#ifndef host_block_timer
extern void host_block_timer IPT0();
#endif /* host_block_timer */

#ifndef host_release_timer
extern void host_release_timer IPT0();
#endif /* host_release_timer */

extern void host_timer2_waveform IPT5(unsigned int, a, unsigned long, b,
	unsigned long, c, int, d, int, e);
#ifdef NTVDM
void HostPpiState(half_word);
#else
extern void host_enable_timer2_sound IPT0();
extern void host_disable_timer2_sound IPT0();
#endif
extern void host_ring_bell IPT1(long, a);
extern void host_alarm IPT1(long, a);
extern unsigned long host_idealAlarm IPT0();

extern IU32 host_speed IPT1( IU32, ControlMachineNumber );

extern void host_timer_init IPT0();
#ifdef SWIN_MOUSE_OPTS
extern void host_timer_setup IPT1(BOOL, fast_timer);
extern void generic_timer_setup IPT1(BOOL, fast_timer);
#else
extern void host_timer_setup IPT0();
extern void generic_timer_setup IPT0();
#endif /* SWIN_MOUSE_OPTS */
extern void host_timer_shutdown IPT0();
extern void host_timer_event IPT0();
extern void generic_timer_event IPT0();

#ifdef HUNTER
extern word timer_batch_count;
#endif /* HUNTER */

extern int timer_int_enabled;
extern boolean timer_video_enabled;

#define timer_inb(port,val)                     ((*timer_inb_func) (port,val))
#define timer_outb(port,val)                    ((*timer_outb_func) (port,val))
#define timer_gate(port,val)                    ((*timer_gate_func) (port,val))
#define time_tick()				((*timer_tick_func) ())


/*
 *  TIMER access functions needed for HW & SW
 */
extern void (*timer_inb_func) IPT2(io_addr, port, half_word *, value);
extern void (*timer_outb_func) IPT2(io_addr, port, half_word, value);
extern void (*timer_gate_func) IPT2(io_addr, port, half_word, value);
extern void (*timer_tick_func) IPT0();

#ifdef NTVDM
extern ULONG EoiIntsPending;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\timeval.h ===
/*
 * SoftPC/SoftWindows
 *
 * Name:        : timeval.h
 *
 * Title        : Host Time structure definitions
 *
 * Sccs ID:     : @(#)timeval.h 1.5 04/20/94
 *
 * Description  : Definitions for users of host-specific time functions.
 *
 * Author       : David Rees
 *
 * Notes        : Make time structures available: host_timeval,
 *                host_timezone, host_tm.
 */

/* SccsID[]="@(#)timeval.h	1.5 04/20/94 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

struct host_timeval {
    IS32 tv_sec;
    IS32 tv_usec;
};



struct host_timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

#ifndef NTVDM
struct host_tm {
	int     tm_sec;
	int     tm_min;
	int     tm_hour;
	int     tm_mday;
	int     tm_mon;
	int     tm_year;
	int     tm_wday;
	int     tm_yday;
	int     tm_isdst;
};
#endif


/*
 * External Declarations
 */

extern time_t host_time IPT1(time_t *, tloc);
extern struct host_tm *host_localtime IPT1(time_t *, clock);

#ifndef NTVDM
extern void host_gettimeofday IPT2(struct host_timeval *, time,
				   struct host_timezone *, zone);
#else
extern void host_GetSysTime(struct host_timeval *);
#define host_gettimeofday(timeval, timezn) host_GetSysTime((timeval))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\tredltr.h ===
typedef union  {
	struct node *nod;	/* node */
	CHAR *str;		/* string */
	CHAR *ide;		/* identifier */
	IBOOL boo;		/* boolean */
	IHPE lit;		/* literal */
} YYSTYPE;
extern YYSTYPE yylval;
# define c_case 257
# define c_endcase 258
# define c_fallthrough 259
# define c_default 260
# define c_else 261
# define c_endif 262
# define c_endswitch 263
# define c_if 264
# define c_then 265
# define c_switch 266
# define c_control 267
# define c_identifier 268
# define c_hook 269
# define c_trace 270
# define ADDR 271
# define ADDRESSOF 272
# define ALIGN 273
# define ARRAYBASE 274
# define ASM 275
# define ASSERT 276
# define BEGIN 277
# define CALL 278
# define COCALL 279
# define MACRO 280
# define CONTROL 281
# define DATA 282
# define DEPART 283
# define DO 284
# define ELSE 285
# define ELIPSIS 286
# define END 287
# define ENDIF 288
# define ENDWHILE 289
# define ENUM 290
# define EMBED 291
# define EXTERNAL 292
# define FP32 293
# define FP64 294
# define FP80 295
# define FPH 296
# define I_FALSE 297
# define GENERATOR 298
# define GETMEMBER 299
# define GOTO 300
# define GT_EQ 301
# define I_HBIT 302
# define IF 303
# define IN 304
# define INOUT 305
# define INCREMENT 306
# define INLINE 307
# define INVOKE 308
# define LABEL 309
# define LOC 310
# define I_BOOL 311
# define I_LS16 312
# define I_LS32 313
# define I_LS8 314
# define LT_EQ 315
# define MODULE 316
# define I_MS8 317
# define OP 318
# define OPERAND 319
# define OPERATOR 320
# define OUT 321
# define PRESERVE 322
# define RECORD 323
# define REF 324
# define RESTORE_STACK 325
# define RETURN 326
# define ROTATE_LEFT 327
# define ROTATE_RIGHT 328
# define SAVE_STACK 329
# define SECTION_LABEL 330
# define SHIFT_LEFT 331
# define SHIFT_RIGHT 332
# define SIZEOF 333
# define SUBROUTINE 334
# define COROUTINE 335
# define TABLE 336
# define THEN 337
# define I_TRUE 338
# define TYPE 339
# define TYPEOF 340
# define TYPESET 341
# define VAR 342
# define WHILE 343
# define REPEAT 344
# define CONSTANT 345
# define BOOLEAN 346
# define IDENTIFIER 347
# define STRING 348
# define CONFIGURATION 349
# define SAD 350
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\trace.h ===
#ifndef _TRACE_H
#define _TRACE_H
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Trace module definitions
 *
 * Description	: Definitions for users of the trace module
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)trace.h	1.13 10/28/94 06/27/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Trace codes 
 */

#define DUMP_NONE	0x00		/* Dump no data		*/
#define DUMP_REG	0x01		/* Dump the registers	*/
#define DUMP_CODE	0x02		/* Dump the last 16 words of code */
#define DUMP_SCREEN	0x04		/* Dump the screen buffer */
#define DUMP_FLAGS 	0x08		/* Dump the flags */
#define DUMP_INST  	0x10   	        /* Dump the next instruction */
#define DUMP_CSIP	0x20		/* Dump CS:IP to backtrace file */
#define DUMP_NPX        0x40            /* Dump NPX Registers */
#define LAST_DEST       0x80            /* dump out last destination addr DELTA */
#define DUMP_ALL	0xFF		/* Dump the lot		*/

/*
 * Verbose bit masks - set the following bits in the io_verbose
 * variable to produce the following trace outputs:
 */

#define GENERAL_VERBOSE 	0x01L	/* General I/O		*/
#define TIMER_VERBOSE 		0x02L	/* Print I/O for timers */
#define ICA_VERBOSE 		0x04L	/* Print I/O for Int Controller Adapt */
#define CGA_VERBOSE		0x08L	/* Print I/O for Colour graphics Adap */
#define FLA_VERBOSE		0x10L	/* Print I/O for Floppy disk Adaptor  */
#define HDA_VERBOSE		0x20L	/* Print I/O for Hard disk Adaptor    */
#define RS232_VERBOSE		0x40L	/* Print I/O for RS232 Adaptor        */
#define PRINTER_VERBOSE		0x80L	/* Print I/O for Printer Adaptor      */
#define PPI_VERBOSE		0x100L	/* Print I/O for PPI Adaptor          */
#define DMA_VERBOSE		0x200L	/* Print I/O for PPI Adaptor          */
#define GFI_VERBOSE		0x400L	/* Print I/O for GFI modules	      */
#define MOUSE_VERBOSE		0x800L	/* Print I/O for Mouse modules	      */
#define MDA_VERBOSE		0x1000L	/* Print I/O for Mono Display Adapter */
#define ICA_VERBOSE_LOCK	0x2000L	/* message for ica lock flag set */
#define DISKBIOS_VERBOSE 	0x4000L	/* Print disk bios messages 	*/
#define EGA_PORTS_VERBOSE	0x8000L	/* Print out EGA port accesses	*/
#define EGA_WRITE_VERBOSE	0x10000L /* Print out EGA write state	*/
#define EGA_READ_VERBOSE	0x20000L /* Print out EGA read state	*/
#define EGA_DISPLAY_VERBOSE	0x40000L /* Print out EGA display state	*/
#define EGA_ROUTINE_ENTRY	0x80000L /* Print out EGA routine trace	*/
#define EGA_VERY_VERBOSE	0xf8000L /* Print out all EGA stuff	*/
#define FLOPBIOS_VERBOSE	0x100000L /* Print floppy bios messages 	*/
#define AT_KBD_VERBOSE		0x200000L /* Print AT keyboard messages	*/
#define BIOS_KB_VERBOSE		0x400000L /* Print BIOS keyboard messages  */
#define CMOS_VERBOSE		0x800000L /* Cmos and real-time clock */
#define HUNTER_VERBOSE		0x1000000L /* Hunter verbosity */
#define PTY_VERBOSE		0x2000000L /* Print Pesudo-terminal messages */
#define GEN_DRVR_VERBOSE	0x4000000L /* Generic driver messages */
#ifdef HERC
#define HERC_VERBOSE		0x8000000L /* Hercules graphics board */
#endif
#define IPC_VERBOSE		0x10000000L /* Interproc communication debug */
#define LIM_VERBOSE		0x20000000L /* LIM messages */
#define HFX_VERBOSE		0x40000000L /* severity of HFX messages */
#define NET_VERBOSE		0x80000000L /* Print out LAN driver messages */

/* sub message types */

#define MAP_VERBOSE		0x1L	/* map messages */
#define CURSOR_VERBOSE		0x2L	/* cursor manipulation messages */
#define NHFX_VERBOSE		0x4L	/* subsid HFX messages */
#define CDROM_VERBOSE		0x8L	/* cdrom **VERY** verbose */
#define CGA_HOST_VERBOSE	0x10L	/* Get host CGA messages */
#define EGA_HOST_VERBOSE	0x20L	/* Get host EGA messages */
#define Q_EVENT_VERBOSE		0x40L   /* quick event manager messages */
#define WORM_VERBOSE		0x80L   /* Worm Drive messages */
#define WORM_VERY_VERBOSE	0x100L  /* Worm Verbose Drive messages */
#define HERC_HOST_VERBOSE	0x200L	/* Get host HERC messages */
#define GORE_VERBOSE		0x400L	/* Get GORE messages */
#define GORE_ERR_VERBOSE	0x800L	/* Get GORE error messages */
#define GLUE_VERBOSE		0x1000L	/* Get glue messages */
#define SAS_VERBOSE		0x2000L	/* Get sas messages */
#define IOS_VERBOSE		0x4000L	/* Get ios messages */
#define SCSI_VERBOSE		0x8000L	/* SCSI messages */
#define SWIN_VERBOSE		0x10000L	/* SoftWindows messages */
#define GISPSVGA_VERBOSE	0x20000L	/* GISP SVGA */
#define DPMI_VERBOSE		0x40000L	/* standalone DPMI host */
#define HWCPU_VERBOSE		0x80000L	/* H/W CPU */
#define	MSW_VERBOSE		0x100000L	/* windows driver */
#define	API_VERBOSE		0x200000L	/* pre-compiled apis */

/*
 * To get adapter independent tracings
 */

#define ALL_ADAPT_VERBOSE	HERC_HOST_VERBOSE | CGA_HOST_VERBOSE | EGA_HOST_VERBOSE

/*
 * Error strings
 */

#define ENOT_SUPPORTED	"BIOS function not supported in Rev 1.0"
#define EBAD_VIDEO_MODE "Video mode not supported in Rev 1.0"
#define EUNEXPECTED_INT "Unexpected interrupt occurred"

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void trace(char *, int);
extern void trace_init(void);

#ifdef DELTA
extern void file_back_trace(char *);
extern void print_back_trace(void);
#endif /* DELTA */

#else
extern void trace();
extern void trace_init();

#ifdef DELTA
extern void file_back_trace();
extern void print_back_trace();
#endif /* DELTA */

#endif /* ANSI */
extern FILE *trace_file;

IMPORT IU32 sub_io_verbose;

#endif /* _TRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\unix_asy.h ===
/*[
 *      Name:		unix_async.h
 *
 *      Derived From:	DEC 3.0 host_async.h
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	19th February 1992
 *
 *      Sccs ID:        @(#)unix_async.h	1.5 03/14/94
 *
 *      Purpose:	Unix specific async definitions.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

#define ASYNC_NOMEM		1
#define ASYNC_NBIO		2	
#define ASYNC_AIOOWN		3
#define ASYNC_AIOSTAT		4
#define ASYNC_BADHANDLE		5
#define ASYNC_NDELAY		6
#define ASYNC_BADHANDLER	7
#define ASYNC_BADOPN		8
#define ASYNC_FCNTL		9

#define ASYNC_XON		0
#define ASYNC_XOFF		1
#define ASYNC_IGNORE		2
#define ASYNC_RAW		3

#ifdef	ANSI
IMPORT  ULONG     addAsyncEventHandler(int fd,int (*eventhandler)(),VOID (*errhandler)(),int mode,CHAR *buf,int bufsiz,int opn,int *err);
IMPORT int     (*changeAsyncEventHandler(ULONG handle, int (*eventhandler)(), char *buf, int bufsiz, int opn, int *err)) ();
#else	/* ANSI */
IMPORT	ULONG 	addAsyncEventHandler();
IMPORT  int     (*changeAsyncEventHandler())();
#endif	/* ANSI */
IMPORT  VOID	initAsyncMgr IPT0();
IMPORT  int     AsyncOperationMode IPT3(ULONG, handle, int, opn, int *, err);
IMPORT  int     removeAsyncEventHandler IPT2(ULONG, handle, int *, err);
IMPORT  VOID    AsyncMgr IPT0();
IMPORT  VOID    terminateAsyncMgr IPT0();
extern	void	AsyncEventMgr IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\unix_loc.h ===
/*[
 * ============================================================================
 *
 *	Name:		unix_lock.h
 *
 *	Derived From:	lock.h(part)
 *
 *	Author:		Andrew Ogle
 *
 *	Created On:	18th Febuary 1993
 *
 *	Sccs ID:	@(#)unix_lock.h	1.1 02/22/93
 *
 *	Purpose:
 *
 *		Define procedures related to UNIX locking that are called
 *		from UNIX specific code in the base but where the code
 *		must be provided by the host.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *
 * ============================================================================
]*/

IMPORT int host_get_hostname_from_stat IPT4(struct stat *, filestat,
		CHAR *, hostname, CHAR *, pathname, int, fd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\unix_cnf.h ===
/*
 *	Name:		unix_cnf.h
 *	Derived From:	HP 3.0 hp_config.h (Philipa Watson)
 *	Author:		gvdl
 *	Created On:	09 March 1991
 *	Sccs ID:	@(#)unix_cnf.h	1.7 10/27/93
 *	Purpose:	Host side config defines
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * HOST defines for resource value option names. These are host specific and may
 * be changed or added to without base recompilation as long as the method used
 * below is adhered to.
 */

/* Host specific hostID #defines. */
#define C_LAST_OPTION   LAST_BASE_CONFIG_DEFINE+1

/************************************/
/* Defines for host specific things */
/************************************/

/* The name of the resource file for this host machine. */
#ifndef USER_HOME
#define USER_HOME	"HOME"
#endif /* USER_HOME */

#ifndef SYSTEM_HOME
#define SYSTEM_HOME	"SPCHOME"
#endif /* SYSTEM_HOME */

#ifdef HUNTER
#ifndef SYSTEM_CONFIG
#define SYSTEM_CONFIG	"$SPCHOME/trap.spcconfig"
#endif /* SYSTEM_CONFIG */
#else
#ifndef SYSTEM_CONFIG
#define SYSTEM_CONFIG	"$SPCHOME/sys.spcconfig"
#endif /*SYSTEM_CONFIG */
#endif /* HUNTER */

#ifndef USER_CONFIG
#define USER_CONFIG	"$HOME/.spcconfig"
#endif /* USER_CONFIG */

#ifdef HUNTER
IMPORT VOID
#ifdef ANSI
loadNlsString(CHAR **strP, USHORT catEntry);
#else /* ANSI */
loadNlsString();
#endif /* ANSI */
#endif /* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\umb.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    UMB.H

Abstract:

    Header file for UMB management functions

Author:

    William Hsieh (williamh) Created 21-Sept-1992

[Environment:]



[Notes:]



Revision History:


--*/
#ifndef DWORD
#define DWORD	unsigned long
#endif
#ifndef WORD
#define WORD	unsigned short
#endif
#ifndef PVOID
#define PVOID	void *
#endif

#define     UMB_BASE_ADDRESS	0xC0000 // UMB base address
#define     UMB_MAX_OFFSET	0x40000 // UMB max. valid offset + 1

#define     UMB_PAGE_PROTECTION PAGE_EXECUTE_READWRITE

#define     HOST_PAGE_SIZE		0x1000	// 4KB
#define CONFIG_DATA_STRING L"Configuration Data"
#define KEY_VALUE_BUFFER_SIZE 2048


// We keep UMB in a list with each block has the following structure
typedef struct _UMBNODE {
    DWORD   Base;			// block base address(linear address)
    DWORD   Size;			// block size in bytes
    WORD    Owner;			// Misc flags
    DWORD   Mask;			// page mask, bit 0 -> first page
					// bit on -> page committed
    struct _UMBNODE *Next;		// pointer to next block
} UMBNODE, *PUMBNODE;

// A ROM block can't be owned by anybody, the address space is reserved
// no memory are committed. To own a ROM block, the caller has to
// include the ROM block first and then reserve the block
// A RAM block can only be owned by XMS. The address space is reserved
// and committed. UMBs allocated for XMS should be reserved and committed
// all the time.
// The address space for EMM block is NOT reserved.
#define     UMB_OWNER_NONE	0xFFFF	// nobody own the block
#define     UMB_OWNER_ROM	0xFFFE	// UMB is a ROM block
#define     UMB_OWNER_RAM	0xFFFD	// UMB is a RAM block
#define     UMB_OWNER_EMM	0xFFFC	// UMB owned by EMM
#define     UMB_OWNER_XMS	0xFFFB	// UMB owned by XMS
#define     UMB_OWNER_VDD	0xFFFA	// UMB owned by VDD

// Function prototype definitions
BOOL
VDDCommitUMB(
PVOID	Address,
DWORD	Size
);

BOOL
VDDDeCommitUMB(
PVOID	Address,
DWORD	Size
);

BOOL
ReserveUMB(
WORD Owner,
PVOID *Address,
DWORD *Size
);

BOOL
ReleaseUMB(
WORD  Owner,
PVOID Address,
DWORD Size
);

BOOL
GetUMBForEMM(VOID);

BOOL
InitUMBList(VOID);

PUMBNODE CreateNewUMBNode
(
DWORD	BaseAddress,
DWORD	Size,
WORD	Owner
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\vgaports.h ===
#ifdef	VGG
/* This file is not used for a non-VGA port. */

/*[
	Name:		vgaports.h
	Derived From:	original
	Author:		Phil Taylor
	Created On:	December 1990
	Sccs ID:	@(#)vgaports.h	1.13 01/13/95
	Purpose:	VGA ports definitions.
	
	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef BIT_ORDER1

/* CRTC Mode Control Register. Index 0x17 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned hardware_reset		: 1,	/* NO		*/
		word_or_byte_mode		: 1,	/* YES 		*/
		address_wrap			: 1,	/* NO 		*/
		not_used			: 1,
		count_by_two			: 1,	/* NO		*/
		horizontal_retrace_select	: 1,	/* NO		*/
		select_row_scan_counter		: 1,	/* NO		*/
		compatibility_mode_support	: 1;	/* YES - CGA graphics banks		*/
	} as_bfld;
} MODE_CONTROL;

/* CRTC Overflow Register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned vertical_retrace_start_bit_9	: 1,	/* NO	*/
		vertical_display_enab_end_bit_9	: 1,	/* YES	*/
		vertical_total_bit_9		: 1,	/* NO	*/
		line_compare_bit_8		: 1,	/* YES	*/
		start_vertical_blank_bit_8	: 1,	/* NO	*/
		vertical_retrace_start_bit_8	: 1,	/* NO	*/
		vertical_display_enab_end_bit_8	: 1,	/* YES	*/
		vertical_total_bit_8		: 1;	/* NO	*/
	} as_bfld;
} CRTC_OVERFLOW;

/* CRTC Max Scan Line Register. Index 9 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned double_scanning		: 1,	/* pixel height * 2 */
		line_compare_bit_9			: 1,	/* YES	*/
		start_vertical_blank_bit_9		: 1,	/* NO	*/
		maximum_scan_line			: 5;	/* YES	*/
	} as_bfld;
} MAX_SCAN_LINE;

/* CRTC Cursor Start Scan Line Register. Index A */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 2,
		cursor_off			: 1,	/* YES	*/
		cursor_start			: 5;	/* YES	*/
	} as_bfld;
} CURSOR_START;

/* CRTC Cursor End Scan Line Register. Index B */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 1,
		cursor_skew_control		: 2,	/* NO	*/
		cursor_end			: 5;	/* YES	*/
	} as_bfld;
} CURSOR_END;

/* Sequencer Reset Register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 6,
		synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
		asynchronous_reset		: 1;		/* NO - damages video and font RAM	*/
	} as_bfld;
} SEQ_RESET;

/* Sequencer Clocking Mode Register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned still_not_used		: 2,
		screen_off			: 1,		/* YES - */
		shift4				: 1,		/* YES - */
		dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
		shift_load			: 1,		/* NO	*/
		not_used			: 1,		/* NO	*/
		eight_or_nine_dot_clocks	: 1;		/* NO - only for mono display		*/
	} as_bfld;
} CLOCKING_MODE;

/* Sequencer Map Mask (Plane Mask) register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		all_planes			: 4;		/* YES	*/
	} as_bfld;
} MAP_MASK;

/* Sequencer Character Map Select register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 2,
		ch_map_select_b_hi		: 1,		/* YES	*/
		ch_map_select_a_hi		: 1,		/* YES	*/
		character_map_select_b		: 2,		/* YES	*/
		character_map_select_a		: 2;		/* YES	*/
	} as_bfld;
	struct {
		unsigned not_used		: 2,
		map_selects			: 6;		/* YES	*/
	} character;
} CHAR_MAP_SELECT;

/* Sequencer Memory Mode Register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		not_used		: 4,	/* If above 2 not both 1, bank 0 set 2	*/
		chain4			: 1,	/* Chain all planes into 1 */
		not_odd_or_even		: 1,	/* YES (check consistency) */
		extended_memory		: 1,	/* NO - assume full 256K on board	*/
		still_not_used		: 1;
	} as_bfld;
} MEMORY_MODE;

#ifdef V7VGA
/* Sequencer Extensions Control Register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		not_used		: 7,	
		    extension_enable	: 1;	/* YES */
	} as_bfld;
} EXTN_CONTROL;
#endif /* V7VGA */

/* Graphics Controller Set/Reset register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		set_or_reset			: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} SET_OR_RESET;

/* Graphics Controller Enable Set/Reset register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		enable_set_or_reset		: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} ENABLE_SET_OR_RESET;

/* Graphics Controller Colo[u]r Compare register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_compare			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_COMPARE;

/* Graphics Controller Data Rotate register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 3,
		function_select			: 2,	/* YES - write mode 0 only		*/
		rotate_count			: 3;	/* YES - write mode 0 only		*/
	} as_bfld;
} DATA_ROTATE;

/* Graphics Controller Read Map Select register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used	: 6,
		map_select		: 2;	/* YES 	*/
	} as_bfld;
} READ_MAP_SELECT;

/* Graphics Controller Mode Register. Index 5 */
typedef	union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 1,	/* YES */
		shift_register_mode		: 2,	/* YES 	*/
		odd_or_even			: 1,	/* YES (check for consistency)	*/
		read_mode			: 1,	/* YES	*/
		test_condition			: 1,	/* NO	*/
		write_mode			: 2;	/* YES	*/
	} as_bfld;
} MODE;

/* Graphics Controller Miscellaneous register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		memory_map			: 2,	/* YES - location of EGA in M	*/
		odd_or_even			: 1,	/* YES (check consistency)	*/
		graphics_mode			: 1;	/* YES	*/
	} as_bfld;
} MISC_REG;

/* Graphics Controller Colour Don't Care register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_dont_care			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_DONT_CARE;

/* Attribute Controller Mode register. Index 10 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		select_video_bits		: 1,	/* YES	*/
		color_output_assembler		: 1,	/* from 256 colour mode */
		horiz_pan_mode			: 1,	/* NO	*/
		reserved			: 1,
		    background_intensity_or_blink	: 1,	/* NO - never blink			*/
		enable_line_graphics_char_codes: 1,	/* NO mono display only			*/
		display_type			: 1,	/* NO - always colour display		*/
		graphics_mode			: 1;	/* YES - with Sequencer Mode reg	*/
	} as_bfld;
} AC_MODE_CONTROL;


/* Attribute Controller Colour Plane Enable register. Index 12 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used			: 2,
		video_status_mux			: 2,	/* NO	*/
		color_plane_enable			: 4;	/* YES  NB. affects attrs in text mode	*/
	} as_bfld;
} COLOR_PLANE_ENABLE;

/* Attribute Controller Pixel Padding register. Index 14 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_top_bits			: 2,
		color_mid_bits			: 2;
	} as_bfld;
} PIXEL_PAD;

/* External Misc Output register. Address 3cc */
typedef union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned horiz_vert_retrace_polarity	: 2,		/* YES - 200/350/480 lines	*/
		page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?*/
		/* V7VGA - YES - used to select banks */
		not_used			: 1,
		clock_select			: 2,		/* YES - only for switch address	*/
		enable_ram			: 1,		/* YES - writes to display mem ignored	*/
		io_address_select		: 1;		/* NO - only used for mono screens	*/
	} as_bfld;

} MISC_OUTPUT_REG;

typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		reserved			: 2,		/* YES - ignore	*/
		feature_control			: 2;		/* NO - device not supported	*/
	} as_bfld;
} FEAT_CONT_REG;

/* External Input Status Register 0. Address 3c2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned crt_interrupt		: 1,		/* YES - sequence if not timing	*/
		reserved			: 2,		/* YES - all bits 1			*/
		sense_pin			: 1,		/* NO	*/
		not_used			: 4;		/* YES - all bits 1			*/
	} as_bfld;
} INPUT_STAT_REG0;

/* External Input Status Register 1. Address 3da */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		vertical_retrace		: 1,		/* YES - sequence only	*/
		still_not_used			: 2,		/* NO	*/
		display_enable			: 1;		/* YES - sequence only	*/
	} as_bfld;
} INPUT_STAT_REG1;

#endif /* BIT_ORDER1 */

#ifdef BIT_ORDER2
/* CRTC Mode Control Register. Index 0x17 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned compatibility_mode_support	: 1,	/* YES - CGA graphics banks	*/
		select_row_scan_counter		: 1,	/* NO	*/
		horizontal_retrace_select	: 1,	/* NO	*/
		count_by_two			: 1,	/* NO	*/
		not_used			: 1,
		address_wrap			: 1,	/* NO 	*/
		word_or_byte_mode		: 1,	/* YES 	*/
		hardware_reset			: 1;	/* NO	*/
	} as_bfld;
} MODE_CONTROL;

/* CRTC Overflow Register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned vertical_total_bit_8	: 1,	/* NO	*/
		vertical_display_enab_end_bit_8	: 1,	/* YES	*/
		vertical_retrace_start_bit_8	: 1,	/* NO	*/
		start_vertical_blank_bit_8	: 1,	/* NO	*/
		line_compare_bit_8		: 1,	/* YES	*/
		vertical_total_bit_9		: 1,	/* NO	*/
		vertical_display_enab_end_bit_9	: 1,	/* YES	*/
		vertical_retrace_start_bit_9	: 1;	/* NO	*/
	} as_bfld;
} CRTC_OVERFLOW;

/* CRTC Max Scan Line Register. Index 9 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned maximum_scan_line	: 5,	/* YES	*/
		start_vertical_blank_bit_9	: 1,	/* NO	*/
		line_compare_bit_9		: 1,	/* YES	*/
		double_scanning			: 1;	/* pixel height * 2 */
	} as_bfld;
} MAX_SCAN_LINE;

/* CRTC Cursor Start Scan Line Register. Index A */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned cursor_start		: 5,	/* YES	*/
		cursor_off			: 1,	/* YES	*/
		not_used			: 2;
	} as_bfld;
} CURSOR_START;

/* CRTC Cursor End Scan Line Register. Index B */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned cursor_end		: 5,	/* YES	*/
		cursor_skew_control		: 2,	/* NO	*/
		not_used			: 1;
	} as_bfld;
} CURSOR_END;

/* Sequencer Reset Register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned asynchronous_reset	: 1,		/* NO - damages video and font RAM	*/
		synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
		not_used			: 6;
	} as_bfld;
} SEQ_RESET;

/* Sequencer Clocking Mode Register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned eight_or_nine_dot_clocks	: 1,	/* NO - only for mono display	*/
		not_used			: 1,		/* NO	*/
		shift_load			: 1,		/* NO	*/
		dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
		shift4				: 1,		/* YES - */
		screen_off			: 1,		/* YES - */
		still_not_used			: 2;
	} as_bfld;
} CLOCKING_MODE;

/* Sequencer Map Mask (Plane Mask) register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned all_planes		: 4,		/* YES	*/
		not_used			: 4;
	} as_bfld;
} MAP_MASK;

/* Sequencer Character Map Select register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned character_map_select_a	: 2,		/* YES	*/
		character_map_select_b		: 2,		/* YES	*/
		ch_map_select_a_hi		: 1,		/* YES	*/
		ch_map_select_b_hi		: 1,		/* YES	*/
		not_used			: 2;
	} as_bfld;
	struct {
		unsigned map_selects		: 6,		/* YES	*/
		not_used			: 2;
	} character;
} CHAR_MAP_SELECT;

/* Sequencer Memory Mode Register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned still_not_used	: 1,
		extended_memory	: 1,	/* NO - assume full 256K on board	*/
		not_odd_or_even	: 1,	/* YES (check consistency)		*/
		chain4		: 1,	/* Chain all planes into 1 */
		not_used	: 4;	/* If above 2 not both 1, bank 0 set 2	*/
	} as_bfld;
} MEMORY_MODE;

#ifdef V7VGA
/* Sequencer Extensions Control Register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		extension_enable	: 1,	/* YES */
		not_used		: 7;	
	} as_bfld;
} EXTN_CONTROL;
#endif /* V7VGA */

/* Graphics Controller Set/Reset register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned set_or_reset	: 4,	/* YES - write mode 0 only	*/
		not_used		: 4;
	} as_bfld;
} SET_OR_RESET;

/* Graphics Controller Enable Set/Reset register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned enable_set_or_reset	: 4,	/* YES - write mode 0 only	*/
		not_used			: 4;
	} as_bfld;
} ENABLE_SET_OR_RESET;

/* Graphics Controller Colo[u]r Compare register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_compare		: 4,	/* YES - read mode 1 only	*/
		not_used			: 4;
	} as_bfld;
} COLOR_COMPARE;

/* Graphics Controller Data Rotate register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned rotate_count		: 3,	/* YES - write mode 0 only		*/
		function_select			: 2,	/* YES - write mode 0 only		*/
		not_used			: 3;
	} as_bfld;
} DATA_ROTATE;

/* Graphics Controller Read Map Select register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned map_select	: 2,	/* YES - read mode 0 only		*/
		not_used		: 6;
	} as_bfld;
} READ_MAP_SELECT;

/* Graphics Controller Mode Register. Index 5 */
typedef	union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned write_mode		: 2,	/* YES	*/
		test_condition			: 1,	/* NO	*/
		read_mode			: 1,	/* YES	*/
		odd_or_even			: 1,	/* YES (check for consistency)		*/
		shift_register_mode		: 2,	/* YES 	*/
		not_used			: 1;	/* YES 	*/
	} as_bfld;
} MODE;

/* Graphics Controller Miscellaneous register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned graphics_mode		: 1,	/* YES	*/
		odd_or_even			: 1,	/* YES (check consistency)	*/
		memory_map			: 2,	/* YES - location of EGA in M	*/
		not_used			: 4;
	} as_bfld;
} MISC_REG;

/* Graphics Controller Colour Don't Care register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_dont_care	: 4,	/* YES - read mode 1 only	*/
		not_used			: 4;
	} as_bfld;
} COLOR_DONT_CARE;

/* Attribute Controller Mode register. Index 10 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned graphics_mode		: 1,	/* YES - with Sequencer Mode reg	*/
		display_type			: 1,	/* NO - always colour display		*/
		enable_line_graphics_char_codes	: 1,	/* NO mono display only			*/
		background_intensity_or_blink	: 1,	/* NO - never blink			*/
		reserved			: 1,
		horiz_pan_mode			: 1,	/* NO	*/
		color_output_assembler		: 1,	/* from 256 colour mode */
		select_video_bits		: 1;	/* YES	*/
	} as_bfld;
} AC_MODE_CONTROL;

/* Attribute Controller Colour Plane Enable register. Index 12 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_plane_enable		: 4,	/* YES  NB. affects attrs in text mode	*/
		video_status_mux			: 2,	/* NO	*/
		not_used				: 2;
	} as_bfld;
} COLOR_PLANE_ENABLE;

/* Attribute Controller Pixel Padding register. Index 14 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_mid_bits		: 2,
		color_top_bits			: 2,
		not_used			: 4;
	} as_bfld;
} PIXEL_PAD;

/* External Misc Output register. Address 3cc */
typedef union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned io_address_select	: 1,		/* NO - only used for mono screens	*/
		enable_ram			: 1,		/* YES - writes to display mem ignored	*/
		clock_select			: 2,		/* YES - only for switch address	*/
		not_used			: 1,
		page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?	*/
		horiz_vert_retrace_polarity	: 2;		/* YES - 200/350/480 lines	*/
	} as_bfld;
} MISC_OUTPUT_REG;

typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned feature_control	: 2,		/* NO - device not supported	*/
		reserved			: 2,		/* YES - ignore			*/
		not_used			: 4;
	} as_bfld;
} FEAT_CONT_REG;

/* External Input Status Register 0. Address 3c2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,		/* YES - all bits 1	*/
		sense_pin			: 1,		/* NO	*/
		reserved			: 2,		/* YES - all bits 1		*/
		crt_interrupt			: 1;		/* YES - sequence if not timing	*/
	} as_bfld;
} INPUT_STAT_REG0;

/* External Input Status Register 1. Address 3da */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned display_enable		: 1,		/* YES - sequence only	*/
		still_not_used			: 2,		/* NO	*/
		vertical_retrace		: 1,		/* YES - sequence only	*/
		not_used			: 4;
	} as_bfld;
} INPUT_STAT_REG1;
#endif /* BIT_ORDER2 */

/* The Sequencer Registers */
#ifdef BIT_ORDER1
struct sequencer
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned using_extensions	: 1,
			extensions_index		: 4,
			index				: 3;
		} as_bfld;
	} address;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used	: 5,
			index			: 3;
		} as_bfld;
	} address;
#endif /* V7VGA */

	SEQ_RESET		reset;
	CLOCKING_MODE	clocking_mode;
	MAP_MASK		map_mask;
	CHAR_MAP_SELECT	character_map_select;
	MEMORY_MODE		memory_mode;

#ifdef V7VGA
	EXTN_CONTROL		extensions_control;
#endif /* V7VGA */

}; 



/* The CRT Controller Registers */

struct crt_controller
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used	: 2,
			index			: 6;
		} as_bfld;
	} address;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 3,
			index				: 5;
		} as_bfld;
	} address;
#endif /* V7VGA */

	byte horizontal_total;				/* NO - screen trash if wrong value	*/
	byte horizontal_display_end;			/* YES - defines line length!!		*/
	byte start_horizontal_blanking;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used		: 1,
			display_enable_skew_control	: 2,	/* NO	*/
			end_blanking			: 5;	/* NO	*/
		} as_bfld;
	} end_horizontal_blanking;

	byte start_horizontal_retrace;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used			: 1,
			horizontal_retrace_delay		: 2,	/* NO	*/
			end_horizontal_retrace		: 5;	/* NO	*/
		} as_bfld;
	} end_horizontal_retrace;

	byte vertical_total;					/* NO	*/
	CRTC_OVERFLOW	crtc_overflow;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used		: 1,
			horiz_pan_lo			: 2,
			preset_row_scan			: 5;	/* NO	*/
		} as_bfld;
	} preset_row_scan;

	MAX_SCAN_LINE	maximum_scan_line;
	CURSOR_START	cursor_start;
	CURSOR_END		cursor_end;
	byte start_address_high;					/* YES	*/
	byte start_address_low;					/* YES	*/
	byte cursor_location_high;					/* YES	*/
	byte cursor_location_low;					/* YES	*/
	byte vertical_retrace_start;				/* NO	*/
	byte light_pen_high;					/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned 
			crtc_protect			: 1,
			refresh_type			: 1,
			enable_vertical_interrupt		: 1,	/* YES 	*/
			clear_vertical_interrupt		: 1,	/* YES 	*/
			vertical_retrace_end		: 4;	/* NO	*/
		} as_bfld;
	} vertical_retrace_end;

	unsigned short vertical_display_enable_end;			/* YES - defines screen height - 10 bit	*/
	byte offset;						/* ????	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 1,
			doubleword_mode			: 1,	/* YES	*/
			count_by_4				: 1,	/* NO	*/
			underline_location			: 5;	/* NO (mono display only)		*/
		} as_bfld;
	} underline_location;

	byte start_vertical_blanking;				/* NO	*/
	byte end_vertical_blanking;					/* NO	*/
	MODE_CONTROL	mode_control;
	unsigned short line_compare;				/* YES,10 bits*/

} ;



/* The Graphics Controller Registers */

struct graphics_controller
{
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 4,
			index				: 4;
		} as_bfld;
	} address;

	SET_OR_RESET	set_or_reset;
	ENABLE_SET_OR_RESET	enable_set_or_reset;
	COLOR_COMPARE	color_compare;
	DATA_ROTATE		data_rotate;
	READ_MAP_SELECT	read_map_select;
	MODE		mode;
	MISC_REG		miscellaneous;
	COLOR_DONT_CARE	color_dont_care;
	byte bit_mask_register;					/* YES - write modes 0 & 2		*/
}; 



/* The Attribute Controller Registers */

struct attribute_controller
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned index_state			: 1,
			unused						: 1,
			palette_address_source			: 1,
			index				: 5;
		} as_bfld;
	} address;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			color_top_bits		: 2,	/* YES	*/
			secondary_red		: 1,	/* YES	*/
			secondary_green		: 1,	/* YES	*/
			secondary_blue		: 1,	/* YES	*/
			red				: 1,	/* YES	*/
			green				: 1,	/* YES	*/
			blue				: 1;	/* YES	*/
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned unused				: 2,
			palette_address_source			: 1,
			index				: 5;
		} as_bfld;
	} address;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			not_used				: 2,	/* YES	*/
			secondary_red			: 1,	/* YES	*/
			secondary_green			: 1,	/* YES	*/
			secondary_blue			: 1,	/* YES	*/
			red				: 1,	/* YES	*/
			green				: 1,	/* YES	*/
			blue				: 1;	/* YES	*/
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#endif /* V7VGA */

	AC_MODE_CONTROL	mode_control;

#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned color_top_bits	: 2,	/* YES	*/
			secondary_red_border	: 1,	/* YES	*/
			secondary_green_border	: 1,	/* YES	*/
			secondary_blue_border	: 1,	/* YES	*/
			red_border			: 1,	/* YES	*/
			green_border		: 1,	/* YES	*/
			blue_border			: 1;	/* YES 	*/
		} as_bfld;
	} overscan_color;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 2,
			secondary_red_border		: 1,	/* YES	*/
			secondary_green_border		: 1,	/* YES	*/
			secondary_blue_border		: 1,	/* YES	*/
			red_border				: 1,	/* YES	*/
			green_border			: 1,	/* YES	*/
			blue_border			: 1;	/* YES 	*/
		} as_bfld;
	} overscan_color;
#endif /* V7VGA */

	COLOR_PLANE_ENABLE	color_plane_enable;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 4,
			horizontal_pel_panning		: 4;	/* NO	*/
		} as_bfld;
	} horizontal_pel_panning;

	PIXEL_PAD	pixel_padding;
}; 


#ifdef V7VGA
/* The V7VGA Extension Registers */

struct extensions_controller
{
	byte pointer_pattern;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned not_used		: 5,
			ptr_horiz_position	: 3;
		} as_bfld;
	} ptr_horiz_posn_hi;

	byte ptr_horiz_posn_lo;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned not_used		: 6,
			ptr_vert_position		: 2;
		} as_bfld;
	} ptr_vert_posn_hi;

	byte ptr_vert_posn_lo;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned not_used		: 3,
			clock_select		: 1,
			unused			: 4;
		} as_bfld;
	} clock_select;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned pointer_enable	: 1,
			not_used			: 3,
			cursor_mode			: 1,
			unused			: 2,
			cursor_blink_disable	: 1;
		} as_bfld;
	} cursor_attrs;

	union {
		struct {
			unsigned abyte	: 8;
		} as;
		struct {
			unsigned dummy	: 7,
			dac_8_bits	: 1;
		} as_bfld;
	} dac_control;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned emulation_enable	: 1,
			hercules_bit_map			: 1,
			write_prot_2			: 1,
			write_prot_1			: 1,
			write_prot_0			: 1,
			nmi_enable				: 3;
		} as_bfld;
	} emulation_control;

	byte foreground_latch_0;
	byte foreground_latch_1;
	byte foreground_latch_2;
	byte foreground_latch_3;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned not_used			: 2,
			fg_latch_load_state		: 2,
			unused				: 2,
			bg_latch_load_state		: 2;
		} as_bfld;
	} fast_latch_load_state;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 6,
			masked_write_source		: 1,
			masked_write_enable		: 1;
		} as_bfld;
	} masked_write_control;

	byte masked_write_mask;
	byte fg_bg_pattern;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned line_compare_bank_reset	: 1,
			counter_bank_enable			: 1,
			crtc_read_bank_select			: 2,
			cpu_read_bank_select			: 2,
			cpu_write_bank_select			: 2;
		} as_bfld;
	} ram_bank_select;

	byte switch_readback;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned extended_clock_output: 3,
			clock_3_on				: 1,
			external_clock_override		: 1,
			extended_clock_output_source	: 1,
			extended_clock_direction	: 1,
			clock_0_only			: 1;
		} as_bfld;
	} clock_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 7,
			extended_page_select		: 1;
		} as_bfld;
	} page_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 4,
			foreground_color			: 4;
		} as_bfld;
	} foreground_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 4,
			background_color			: 4;
		} as_bfld;
	} background_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned internal_3c3_enable	: 1,
			extended_display_enable_skew	: 1,
			sequential_chain4		: 1,
			sequential_chain			: 1,
			refresh_skew_control		: 1,
			extended_256_color_enable	: 1,
			extended_256_color_mode		: 1,
			extended_attribute_enable	: 1;
		} as_bfld;
	} compatibility_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned graphics_8_dot_timing_state	: 4,
			text_8_dot_timing_state				: 4;
		} as_bfld;
	} timing_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned not_used			: 4,
			fg_bg_mode				: 2,
			fg_bg_source			: 1,
			unused				: 1;
		} as_bfld;
	} fg_bg_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned bus_status	: 1,
			pointer_bank_select		: 2,
			bank_enable			: 1,
			ROM_interface_enable	: 1,
			fast_write_enable			: 1,
			io_interface_enable	: 1,
			mem_interface_enable	: 1;
		} as_bfld;
	} interface_control;
}; 

#endif /* V7VGA */
#endif /* BIT_ORDER1 */

#ifdef BIT_ORDER2
struct sequencer
{
#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                   : 3,
			extensions_index        : 4,
			using_extensions        : 1;
		} as_bfld;
	} address;
#else
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                       : 3,
			not_used                    : 5;
		} as_bfld;
	} address;
#endif /* V7VGA */

	SEQ_RESET           reset;
	CLOCKING_MODE       clocking_mode;
	MAP_MASK            map_mask;
	CHAR_MAP_SELECT     character_map_select;
	MEMORY_MODE         memory_mode;
#ifdef V7VGA
        EXTN_CONTROL        extensions_control;
#endif /* V7VGA */

};


/* The CRT Controller Registers */

struct crt_controller
{
	 
#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index           : 6,
			not_used        : 2;
		} as_bfld;
	} address;
#else
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index       : 5,
			not_used    : 3;
		} as_bfld;
	} address;
#endif /* V7VGA */
												 
	byte horizontal_total;				/* NO - screen trash if wrong value	*/
	byte horizontal_display_end;			/* YES - defines line length!!		*/
	byte start_horizontal_blanking;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned end_blanking		: 5,	/* NO	*/
			display_enable_skew_control	: 2,	/* NO	*/
			not_used			: 1;
		} as_bfld;
	} end_horizontal_blanking;

	byte start_horizontal_retrace;				/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned end_horizontal_retrace		: 5,	/* NO	*/
			horizontal_retrace_delay		: 2,	/* NO	*/
			not_used				: 1;
		} as_bfld;
	} end_horizontal_retrace;

	byte vertical_total;					/* NO	*/
	CRTC_OVERFLOW	crtc_overflow;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned preset_row_scan	: 5,	/* NO	*/
			horiz_pan_lo			: 2,
			not_used			: 1;
		} as_bfld;
	} preset_row_scan;

	MAX_SCAN_LINE	maximum_scan_line;
	CURSOR_START	cursor_start;
	CURSOR_END		cursor_end;
	byte start_address_high;				/* YES	*/
	byte start_address_low;					/* YES	*/
	byte cursor_location_high;				/* YES	*/
	byte cursor_location_low;				/* YES	*/
	byte vertical_retrace_start;				/* NO	*/
	byte light_pen_high;					/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned vertical_retrace_end		: 4,	/* NO	*/
			clear_vertical_interrupt		: 1,	/* YES  */
			enable_vertical_interrupt		: 1,	/* YES	*/
			refresh_type			: 1,
			crtc_protect			: 1;
		} as_bfld;
	} vertical_retrace_end;

	unsigned short vertical_display_enable_end;		/* YES - defines screen height - 10 bit	*/
	byte offset;						/* ????	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned underline_location	: 5,	/* NO (mono display only)		*/
			count_by_4			: 1,	/* NO	*/
			doubleword_mode			: 1,	/* YES	*/
			not_used			: 1;
		} as_bfld;
	} underline_location;

	byte start_vertical_blanking;				/* NO	*/
	byte end_vertical_blanking;				/* NO	*/
	MODE_CONTROL	mode_control;
	byte line_compare;					/* YES	*/

};



/* The Graphics Controller Registers */

struct graphics_controller
{
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned index				: 4,
			not_used				: 4;
		} as_bfld;
	} address;

	SET_OR_RESET	set_or_reset;
	ENABLE_SET_OR_RESET	enable_set_or_reset;
	COLOR_COMPARE	color_compare;
	DATA_ROTATE		data_rotate;
	READ_MAP_SELECT	read_map_select;
	MODE		mode;
	MISC_REG		miscellaneous;
	COLOR_DONT_CARE	color_dont_care;
	byte bit_mask_register;				/* YES - write modes 0 & 2	*/
}; 



/* The Attribute Controller Registers */

struct attribute_controller
{
#ifdef V7VGA
	union
	{    
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                           : 5,
			palette_address_source          : 1,
			unused                          : 1,
			index_state                     : 1;
		} as_bfld;
	} address;

	union
	{    
		struct {
			unsigned abyte : 8;
			} as;
		struct {
			unsigned
			blue                    : 1,    /* YES  */
			green                   : 1,    /* YES  */
			red                     : 1,    /* YES  */
			secondary_blue          : 1,    /* YES  */
			secondary_green         : 1,    /* YES  */
			secondary_red           : 1,    /* YES  */
			color_top_bits          : 2;    /* YES  */
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#else  
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                           : 5,
			palette_address_source		: 1,
			unused                          : 2;
		} as_bfld;
	} address;

	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue                               : 1,    /* YES  */
			green                              : 1,    /* YES  */
			red                                : 1,    /* YES  */
			secondary_blue                     : 1,    /* YES  */
			secondary_green                    : 1,    /* YES  */
			secondary_red                      : 1,    /* YES  */
			not_used                           : 2;    /* YES  */
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#endif /* V7VGA */

	AC_MODE_CONTROL	mode_control;

#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue_border             : 1,    /* YES  */
			green_border            : 1,    /* YES  */
			red_border              : 1,    /* YES  */
			secondary_blue_border   : 1,    /* YES  */
			secondary_green_border  : 1,    /* YES  */
			secondary_red_border    : 1,    /* YES  */
			color_top_bits          : 2;    /* YES  */
		} as_bfld;
	} overscan_color;
#else  
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue_border                     : 1,    /* YES  */
			green_border                    : 1,    /* YES  */
			red_border                      : 1,    /* YES  */
			secondary_blue_border           : 1,    /* YES  */
			secondary_green_border          : 1,    /* YES  */
			secondary_red_border            : 1,    /* YES  */
			not_used                        : 2;
		} as_bfld;
	} overscan_color;
#endif /* V7VGA */

	COLOR_PLANE_ENABLE	color_plane_enable;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned horizontal_pel_panning		: 4,	/* NO	*/
			not_used				: 4;
		} as_bfld;
	} horizontal_pel_panning;

	PIXEL_PAD	pixel_padding;
}; 


#ifdef V7VGA
/* The V7VGA Extension Registers */

struct extensions_controller
{
	byte pointer_pattern;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned 
			ptr_horiz_position	: 3,
			not_used		: 5;
		} as_bfld;
	} ptr_horiz_posn_hi;

	byte ptr_horiz_posn_lo;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned
			ptr_vert_position	: 2,
			not_used		: 6;
		} as_bfld;
	} ptr_vert_posn_hi;

	byte ptr_vert_posn_lo;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			unused			: 4,
			clock_select		: 1,
			not_used		: 3;
		} as_bfld;
	} clock_select;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			cursor_blink_disable	: 1,
			unused			: 2,
			cursor_mode		: 1,
			not_used		: 3,
			pointer_enable		: 1;

		} as_bfld;
	} cursor_attrs;

	union {
		struct {
			unsigned abyte	: 8;
		} as;
		struct {
			unsigned dac_8_bits	: 1,
			dummy			: 7;
		} as_bfld;
	} dac_control;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			nmi_enable			: 3,
			write_prot_0			: 1,
			write_prot_1			: 1,
			write_prot_2			: 1,
			hercules_bit_map		: 1,
			emulation_enable		: 1;
		} as_bfld;
	} emulation_control;

	byte foreground_latch_0;
	byte foreground_latch_1;
	byte foreground_latch_2;
	byte foreground_latch_3;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			bg_latch_load_state		: 2,
			unused				: 2,
			fg_latch_load_state		: 2,
			not_used			: 2;
		} as_bfld;
	} fast_latch_load_state;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			masked_write_enable		: 1,
			masked_write_source		: 1,
			unused				: 6;
		} as_bfld;
	} masked_write_control;

	byte masked_write_mask;
	byte fg_bg_pattern;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			cpu_write_bank_select			: 2,
			cpu_read_bank_select			: 2,
			crtc_read_bank_select			: 2,
			counter_bank_enable			: 1,
			line_compare_bank_reset			: 1;
		} as_bfld;
	} ram_bank_select;

	byte switch_readback;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			clock_0_only			: 1,
			extended_clock_direction	: 1,
			extended_clock_output_source	: 1,
			external_clock_override		: 1,
			clock_3_on			: 1,
			extended_clock_output		: 3;
		} as_bfld;
	} clock_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			extended_page_select	: 1,
			unused			: 7;
		} as_bfld;
	} page_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			foreground_color	: 4,
			unused			: 4;
		} as_bfld;
	} foreground_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			background_color	: 4,
			unused			: 4;
		} as_bfld;
	} background_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			extended_attribute_enable	: 1,
			extended_256_color_mode		: 1,
			extended_256_color_enable	: 1,
			refresh_skew_control		: 1,
			sequential_chain		: 1,
			sequential_chain4		: 1,
			extended_display_enable_skew	: 1,
			internal_3c3_enable		: 1;
		} as_bfld;
	} compatibility_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			text_8_dot_timing_state		: 4,
			graphics_8_dot_timing_state	: 4;
		} as_bfld;
	} timing_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			unused			: 1,
			fg_bg_source		: 1,
			fg_bg_mode		: 2,
			not_used		: 4;
		} as_bfld;
	} fg_bg_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			mem_interface_enable	: 1,
			io_interface_enable	: 1,
			fast_write_enable	: 1,
			ROM_interface_enable	: 1,
			bank_enable		: 1,
			pointer_bank_select	: 2,
			bus_status		: 1;
		} as_bfld;
	} interface_control;
}; 

#endif /* V7VGA */

#endif /* BIT_ORDER2 */

#ifdef V7VGA
#ifdef CPU_40_STYLE
extern void set_v7_fg_latch_byte IPT2(IU8, index, IU8, value);
#define SET_FG_LATCH(n, val)	set_v7_fg_latch_byte(n, val)
#else
#ifdef BIGEND
#define SET_FG_LATCH( n, val )	(*((UTINY *) &fg_latches + (n)) = value )
#endif /* BIGEND */
#ifdef LITTLEND
#define SET_FG_LATCH( n, val )	(*((UTINY *) &fg_latches + (3 - n)) = value )
#endif /* LITTLEND */
#endif	/* CPU_40_STYLE */
#endif /* V7VGA */

#ifdef GISP_SVGA
void mapRealIOPorts IPT0( );
void mapEmulatedIOPorts IPT0( );
#endif		/* GISP_SVGA */
 
/* Global data structures to import into modules
 */
IMPORT MISC_OUTPUT_REG	miscellaneous_output_register;
IMPORT FEAT_CONT_REG	feature_control_register;
IMPORT INPUT_STAT_REG0	input_status_register_zero;
IMPORT INPUT_STAT_REG1	input_status_register_one;

IMPORT VOID init_vga_globals IPT0();
IMPORT VOID ega_mode_init IPT0();
IMPORT VOID enable_gfx_update_routines IPT0();
IMPORT VOID disable_gfx_update_routines IPT0();

#ifndef cursor_changed
IMPORT VOID cursor_changed IPT2(int, x, int, y);
#endif
IMPORT VOID update_shift_count IPT0();

#ifdef V7VGA 
IMPORT struct extensions_controller extensions_controller;
#endif /* V7VGA */ 
IMPORT struct crt_controller		crt_controller;
IMPORT struct sequencer			sequencer;
IMPORT struct attribute_controller	attribute_controller;
IMPORT struct graphics_controller	graphics_controller;

/* 
   31.3.92 MG The video-7 VGA has an undocumented ability to support either
   6 or 8 bits of data in the palette. To support this we store the number`
   of bits in the DAC_data_bits variable so that the routines which stuff
   the data onto the screen know how much to output.
*/

IMPORT	byte	DAC_data_mask;
#ifdef V7VGA
IMPORT	int	DAC_data_bits;
#endif

#endif	/* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\vgastate.h ===
/*[
 *
 *	File		:	vgastate.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	Definition of data types/constants to save and restore the 
 *					(internal) state of a VGA card.
 *
 *	Author		:	Rog
 *	Date		:	25 November 1992
 *
 *	SCCS Gumph	:	@(#)vgastate.h	1.1 08/06/93
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifndef _VGASTATE_H_
#define _VGASTATE_H_

/*(
 *
 *	typedef	:	vgastate structure
 *
 * 	purpose	:	provides storage for all the registers and data associated with
 *				any (S)VGA card
 *
 *	Format	:	The first part of the structure is a header consisting of arrays
 *				for all the standard VGA registers. There is also an array to
 *				hold the values of the IO ports between 0x3b0 and 0x3e0 (a VGA
 *				uses 3ba-3cc)
 *				There is then a set of sizes of and pointers to arrays to hold
 *				data contained in any extra registers added to the standard set
 *				for SVGA cards and a general extra data area.
 *				Finally there is a field for the size of the planes and an array
 *				of pointers to copies of the plane data.
 *
 *				All this data is held starting at the last field in the 
 *				structure (Data[])
 *
 *				Pointers should be NULL if they do not point to valid data
 *
 *				Total size of data will be 
 *					sizeof( VGAState ) + extendSequencerSize + extendCRTSize
 *						+ extendGraphSize + extendAttrSize + extendDACSize
 *							+ miscDataSize + ( 4 * planeSize )
)*/

typedef struct 
{
	unsigned char	ioPorts[ 0x30 ];		/* IO Ports 3B0 - 3E0 */
	unsigned char	sequencerData[ 5 ];		/* Sequencer registers */
	unsigned char	CRTContData[ 24 ];		/* CRT Controller registers */
	unsigned char	graphContData[ 9 ];		/* Graphics controller regs */
	unsigned char	attrContData[ 15 ];		/* Attribute Controller regs */
	unsigned char	DACData[ 3 * 256 ];		/* Data values from PEL Data reg */
	unsigned int	latch;					/* 32 bit data latch register */
	unsigned int	extendSequencerSize;	/* size in bytes of extra sequencer data */
	unsigned char	* extendSequencerData;	/* pointer to extra sequencer regs */
	unsigned int	extendCRTSize;			/* size in bytes of extra CRT data */
	unsigned char	* extendCRTData;		/* Pointer to extra CRT controller regs */
	unsigned int	extendGraphSize;		/* size in bytes of extra graph cont data */
	unsigned char	* extendGraphData;		/* pointer to extra Graph controller data */
	unsigned int	extendAttrSize;			/* size in bytes of extra attr cont data */
	unsigned char	* extendAttrData;		/* pointer to extra attribute cont data */
	unsigned int	extendDACSize;			/* size in bytes of extra sequencer data */
	unsigned char	* extendDACData;		/* Pointer to extra DAC data */
	unsigned int	miscDataSize;			/* Any other random junk */	
	unsigned char	* miscData;
	unsigned int	planeSize;				/* Size in bytes of each plane */
	unsigned char	* planeData[ 4 ];		/* Pointers to copies of plane data */
	unsigned char	data[ 1 ];				/* Data holder */

}	VGAState , *pVGAState;


/* Macros for gettting at the register values in the IoPort array */

#define		miscOutputWrite		ioPorts[ 0x12 ]
#define		miscOutputRead		ioPorts[ 0x1C ]
#define		EGAFeatureContWrite	ioPorts[ 0x2A ]
#define		VGAFeatureContWrite	ioPorts[ 0x0A ]
#define		featureContRead		ioPorts[ 0x1A ]
#define		inputStat0			ioPorts[ 0x12 ]
#define		colourInputStat1	ioPorts[ 0x2A ]
#define		monoInputStat1		ioPorts[ 0x0A ]
#define		sequencerIndex		ioPorts[ 0x14 ]
#define		sequencer			ioPorts[ 0x15 ]
#define		CRTIndexEGA			ioPorts[ 0x24 ]
#define		CRTIndexVGA			ioPorts[ 0x04 ]
#define		graphContIndex		ioPorts[ 0x1E ]
#define		graphCont			ioPorts[ 0x1F ]
#define		attrContIndexWrite	ioPorts[ 0x10 ]
#define		attrContIndexRead	ioPorts[ 0x11 ]
#define		attrCont			ioPorts[ 0x1F ]
#define		PELAddrWriteMode	ioPorts[ 0x18 ]
#define		PELAddrReadMode		ioPorts[ 0x17 ]
#define		PELData				ioPorts[ 0x19 ]
#define		DACState			ioPorts[ 0x17 ]
#define		PELMask				ioPorts[ 0x16 ]

/* Macros for the Sequencer Registers */
#define		seqReset		sequencerData[ 0 ]
#define		seqClockMode	sequencerData[ 1 ]
#define		seqMapMask		sequencerData[ 2 ]
#define		seqCharMapSel	sequencerData[ 3 ]
#define		seqMemMode		sequencerData[ 4 ]

/* Macros for the CRT controller registers */

#define horizTotal			CRTContData[ 0 ]
#define horizDisplayEnd		CRTContData[ 1 ]
#define startHorizBlank		CRTContData[ 2 ]
#define endHorizBlank		CRTContData[ 3 ]
#define startHorizRetrace	CRTContData[ 4 ]
#define endHorizRetrace		CRTContData[ 5 ]
#define vertTotal			CRTContData[ 6 ]
#define overflow			CRTContData[ 7 ]
#define presetRowScan		CRTContData[ 8 ]
#define maxScanLine			CRTContData[ 9 ]
#define cursorStart			CRTContData[ 10 ]
#define startAddressHigh	CRTContData[ 11 ]
#define startAddressLow		CRTContData[ 12 ]
#define cursLocHigh			CRTContData[ 13 ]
#define cursLocLow			CRTContData[ 14 ]
#define vertRetStart		CRTContData[ 15 ]
#define vertRetEnd			CRTContData[ 16 ]
#define vertDisplayEnd		CRTContData[ 17 ]
#define CRToffset			CRTContData[ 18 ]
#define underlineLoc		CRTContData[ 19 ]
#define startVertBlank		CRTContData[ 20 ]
#define endVertBlank		CRTContData[ 21 ]
#define CRTModeControl		CRTContData[ 22 ]
#define lineCompare			CRTContData[ 23 ]

/* Macros for Graphics Controller */

#define setReset		graphContData[ 0 ]
#define enableSetReset	graphContData[ 1 ]
#define colourCompare	graphContData[ 2 ]
#define dataRotate		graphContData[ 3 ]
#define readMapSelect	graphContData[ 4 ]
#define GCmode			graphContData[ 5 ]
#define GCmisc			graphContData[ 6 ]
#define CDC				graphContData[ 7 ]
#define GCBitMask		graphContData[ 8 ]

/* The Attribute controller registers */

#define Palette				AttrContData			/* POINTER ! */
#define AttrModeControl		AttrContData[ 16 ]
#define OverscanColour		AttrContData[ 17 ]
#define ColourPlaneEnable	AttrContData[ 18 ]
#define HorizPixPan			AttrContData[ 19 ]
#define ColourSelect		AttrContData[ 20 ]



/* Numbers of the various Registers in the Standard VGA Emulation */

#define NUM_SEQ_REGS	5
#define	NUM_CRT_REGS	24
#define	NUM_GRAPH_REGS	9
#define NUM_ATT_REGS	15
#define	DAC_ENTRIES		3 * 256

#endif 		/* _VGASTATE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\vga_dac.h ===
/* SccsID = @(#)vga_dac.h	1.4 08/10/92 */

/* this stuff isn't required for the Macintosh */
/* as we load the DACs in individually as required */

#ifndef	macintosh

byte vga_dac[0x300] = {
/* 00  */ 0x00, 0x00, 0x00, 
/* 01  */ 0x00, 0x00, 0x2a, 
/* 02  */ 0x00, 0x2a, 0x00, 
/* 03  */ 0x00, 0x2a, 0x2a, 
/* 04  */ 0x2a, 0x00, 0x00, 
/* 05  */ 0x2a, 0x00, 0x2a, 
/* 06  */ 0x2a, 0x2a, 0x00, 
/* 07  */ 0x2a, 0x2a, 0x2a, 
/* 08  */ 0x00, 0x00, 0x15, 
/* 09  */ 0x00, 0x00, 0x3f, 
/* 10  */ 0x00, 0x2a, 0x15, 
/* 11  */ 0x00, 0x2a, 0x3f, 
/* 12  */ 0x2a, 0x00, 0x15, 
/* 13  */ 0x2a, 0x00, 0x3f, 
/* 14  */ 0x2a, 0x2a, 0x15, 
/* 15  */ 0x2a, 0x2a, 0x3f, 
/* 16  */ 0x00, 0x15, 0x00, 
/* 17  */ 0x00, 0x15, 0x2a, 
/* 18  */ 0x00, 0x3f, 0x00, 
/* 19  */ 0x00, 0x3f, 0x2a, 
/* 20  */ 0x2a, 0x15, 0x00, 
/* 21  */ 0x2a, 0x15, 0x2a, 
/* 22  */ 0x2a, 0x3f, 0x00, 
/* 23  */ 0x2a, 0x3f, 0x2a, 
/* 24  */ 0x00, 0x15, 0x15, 
/* 25  */ 0x00, 0x15, 0x3f, 
/* 26  */ 0x00, 0x3f, 0x15, 
/* 27  */ 0x00, 0x3f, 0x3f, 
/* 28  */ 0x2a, 0x15, 0x15, 
/* 29  */ 0x2a, 0x15, 0x3f, 
/* 30  */ 0x2a, 0x3f, 0x15, 
/* 31  */ 0x2a, 0x3f, 0x3f, 
/* 32  */ 0x15, 0x00, 0x00, 
/* 33  */ 0x15, 0x00, 0x2a, 
/* 34  */ 0x15, 0x2a, 0x00, 
/* 35  */ 0x15, 0x2a, 0x2a, 
/* 36  */ 0x3f, 0x00, 0x00, 
/* 37  */ 0x3f, 0x00, 0x2a, 
/* 38  */ 0x3f, 0x2a, 0x00, 
/* 39  */ 0x3f, 0x2a, 0x2a, 
/* 40  */ 0x15, 0x00, 0x15, 
/* 41  */ 0x15, 0x00, 0x3f, 
/* 42  */ 0x15, 0x2a, 0x15, 
/* 43  */ 0x15, 0x2a, 0x3f, 
/* 44  */ 0x3f, 0x00, 0x15, 
/* 45  */ 0x3f, 0x00, 0x3f, 
/* 46  */ 0x3f, 0x2a, 0x15, 
/* 47  */ 0x3f, 0x2a, 0x3f, 
/* 48  */ 0x15, 0x15, 0x00, 
/* 49  */ 0x15, 0x15, 0x2a, 
/* 50  */ 0x15, 0x3f, 0x00, 
/* 51  */ 0x15, 0x3f, 0x2a, 
/* 52  */ 0x3f, 0x15, 0x00, 
/* 53  */ 0x3f, 0x15, 0x2a, 
/* 54  */ 0x3f, 0x3f, 0x00, 
/* 55  */ 0x3f, 0x3f, 0x2a, 
/* 56  */ 0x15, 0x15, 0x15, 
/* 57  */ 0x15, 0x15, 0x3f, 
/* 58  */ 0x15, 0x3f, 0x15, 
/* 59  */ 0x15, 0x3f, 0x3f, 
/* 60  */ 0x3f, 0x15, 0x15, 
/* 61  */ 0x3f, 0x15, 0x3f, 
/* 62  */ 0x3f, 0x3f, 0x15, 
/* 63  */ 0x3f, 0x3f, 0x3f, 
/* 64  */ 0x3f, 0x1f, 0x1f, 
/* 65  */ 0x3f, 0x27, 0x1f, 
/* 66  */ 0x3f, 0x2f, 0x1f, 
/* 67  */ 0x3f, 0x37, 0x1f, 
/* 68  */ 0x3f, 0x3f, 0x1f, 
/* 69  */ 0x37, 0x3f, 0x1f, 
/* 70  */ 0x2f, 0x3f, 0x1f, 
/* 71  */ 0x27, 0x3f, 0x1f, 
/* 72  */ 0x1f, 0x3f, 0x1f, 
/* 73  */ 0x1f, 0x3f, 0x27, 
/* 74  */ 0x1f, 0x3f, 0x2f, 
/* 75  */ 0x1f, 0x3f, 0x37, 
/* 76  */ 0x1f, 0x3f, 0x3f, 
/* 77  */ 0x1f, 0x37, 0x3f, 
/* 78  */ 0x1f, 0x2f, 0x3f, 
/* 79  */ 0x1f, 0x27, 0x3f, 
/* 80  */ 0x2d, 0x2d, 0x3f, 
/* 81  */ 0x31, 0x2d, 0x3f, 
/* 82  */ 0x36, 0x2d, 0x3f, 
/* 83  */ 0x3a, 0x2d, 0x3f, 
/* 84  */ 0x3f, 0x2d, 0x3f, 
/* 85  */ 0x3f, 0x2d, 0x3a, 
/* 86  */ 0x3f, 0x2d, 0x36, 
/* 87  */ 0x3f, 0x2d, 0x31, 
/* 88  */ 0x3f, 0x2d, 0x2d, 
/* 89  */ 0x3f, 0x31, 0x2d, 
/* 90  */ 0x3f, 0x36, 0x2d, 
/* 91  */ 0x3f, 0x3a, 0x2d, 
/* 92  */ 0x3f, 0x3f, 0x2d, 
/* 93  */ 0x3a, 0x3f, 0x2d, 
/* 94  */ 0x36, 0x3f, 0x2d, 
/* 95  */ 0x31, 0x3f, 0x2d, 
/* 96  */ 0x2d, 0x3f, 0x2d, 
/* 97  */ 0x2d, 0x3f, 0x31, 
/* 98  */ 0x2d, 0x3f, 0x36, 
/* 99  */ 0x2d, 0x3f, 0x3a, 
/* 100  */ 0x2d, 0x3f, 0x3f, 
/* 101  */ 0x2d, 0x3a, 0x3f, 
/* 102  */ 0x2d, 0x36, 0x3f, 
/* 103  */ 0x2d, 0x31, 0x3f, 
/* 104  */ 0x00, 0x00, 0x1c, 
/* 105  */ 0x07, 0x00, 0x1c, 
/* 106  */ 0x0e, 0x00, 0x1c, 
/* 107  */ 0x15, 0x00, 0x1c, 
/* 108  */ 0x1c, 0x00, 0x1c, 
/* 109  */ 0x1c, 0x00, 0x15, 
/* 110  */ 0x1c, 0x00, 0x0e, 
/* 111  */ 0x1c, 0x00, 0x07, 
/* 112  */ 0x1c, 0x00, 0x00, 
/* 113  */ 0x1c, 0x07, 0x00, 
/* 114  */ 0x1c, 0x0e, 0x00, 
/* 115  */ 0x1c, 0x15, 0x00, 
/* 116  */ 0x1c, 0x1c, 0x00, 
/* 117  */ 0x15, 0x1c, 0x00, 
/* 118  */ 0x0e, 0x1c, 0x00, 
/* 119  */ 0x07, 0x1c, 0x00, 
/* 120  */ 0x00, 0x1c, 0x00, 
/* 121  */ 0x00, 0x1c, 0x07, 
/* 122  */ 0x00, 0x1c, 0x0e, 
/* 123  */ 0x00, 0x1c, 0x15, 
/* 124  */ 0x00, 0x1c, 0x1c, 
/* 125  */ 0x00, 0x15, 0x1c, 
/* 126  */ 0x00, 0x0e, 0x1c, 
/* 127  */ 0x00, 0x07, 0x1c, 
/* 128  */ 0x0e, 0x0e, 0x1c, 
/* 129  */ 0x11, 0x0e, 0x1c, 
/* 130  */ 0x15, 0x0e, 0x1c, 
/* 131  */ 0x18, 0x0e, 0x1c, 
/* 132  */ 0x1c, 0x0e, 0x1c, 
/* 133  */ 0x1c, 0x0e, 0x18, 
/* 134  */ 0x1c, 0x0e, 0x15, 
/* 135  */ 0x1c, 0x0e, 0x11, 
/* 136  */ 0x1c, 0x0e, 0x0e, 
/* 137  */ 0x1c, 0x11, 0x0e, 
/* 138  */ 0x1c, 0x15, 0x0e, 
/* 139  */ 0x1c, 0x18, 0x0e, 
/* 140  */ 0x1c, 0x1c, 0x0e, 
/* 141  */ 0x18, 0x1c, 0x0e, 
/* 142  */ 0x15, 0x1c, 0x0e, 
/* 143  */ 0x11, 0x1c, 0x0e, 
/* 144  */ 0x0e, 0x1c, 0x0e, 
/* 145  */ 0x0e, 0x1c, 0x11, 
/* 146  */ 0x0e, 0x1c, 0x15, 
/* 147  */ 0x0e, 0x1c, 0x18, 
/* 148  */ 0x0e, 0x1c, 0x1c, 
/* 149  */ 0x0e, 0x18, 0x1c, 
/* 150  */ 0x0e, 0x15, 0x1c, 
/* 151  */ 0x0e, 0x11, 0x1c, 
/* 152  */ 0x14, 0x14, 0x1c, 
/* 153  */ 0x16, 0x14, 0x1c, 
/* 154  */ 0x18, 0x14, 0x1c, 
/* 155  */ 0x1a, 0x14, 0x1c, 
/* 156  */ 0x1c, 0x14, 0x1c, 
/* 157  */ 0x1c, 0x14, 0x1a, 
/* 158  */ 0x1c, 0x14, 0x18, 
/* 159  */ 0x1c, 0x14, 0x16, 
/* 160  */ 0x1c, 0x14, 0x14, 
/* 161  */ 0x1c, 0x16, 0x14, 
/* 162  */ 0x1c, 0x18, 0x14, 
/* 163  */ 0x1c, 0x1a, 0x14, 
/* 164  */ 0x1c, 0x1c, 0x14, 
/* 165  */ 0x1a, 0x1c, 0x14, 
/* 166  */ 0x18, 0x1c, 0x14, 
/* 167  */ 0x16, 0x1c, 0x14, 
/* 168  */ 0x14, 0x1c, 0x14, 
/* 169  */ 0x14, 0x1c, 0x16, 
/* 170  */ 0x14, 0x1c, 0x18, 
/* 171  */ 0x14, 0x1c, 0x1a, 
/* 172  */ 0x14, 0x1c, 0x1c, 
/* 173  */ 0x14, 0x1a, 0x1c, 
/* 174  */ 0x14, 0x18, 0x1c, 
/* 175  */ 0x14, 0x16, 0x1c, 
/* 176  */ 0x00, 0x00, 0x10, 
/* 177  */ 0x04, 0x00, 0x10, 
/* 178  */ 0x08, 0x00, 0x10, 
/* 179  */ 0x0c, 0x00, 0x10, 
/* 180  */ 0x10, 0x00, 0x10, 
/* 181  */ 0x10, 0x00, 0x0c, 
/* 182  */ 0x10, 0x00, 0x08, 
/* 183  */ 0x10, 0x00, 0x04, 
/* 184  */ 0x10, 0x00, 0x00, 
/* 185  */ 0x10, 0x04, 0x00, 
/* 186  */ 0x10, 0x08, 0x00, 
/* 187  */ 0x10, 0x0c, 0x00, 
/* 188  */ 0x10, 0x10, 0x00, 
/* 189  */ 0x0c, 0x10, 0x00, 
/* 190  */ 0x08, 0x10, 0x00, 
/* 191  */ 0x04, 0x10, 0x00, 
/* 192  */ 0x00, 0x10, 0x00, 
/* 193  */ 0x00, 0x10, 0x04, 
/* 194  */ 0x00, 0x10, 0x08, 
/* 195  */ 0x00, 0x10, 0x0c, 
/* 196  */ 0x00, 0x10, 0x10, 
/* 197  */ 0x00, 0x0c, 0x10, 
/* 198  */ 0x00, 0x08, 0x10, 
/* 199  */ 0x00, 0x04, 0x10, 
/* 200  */ 0x08, 0x08, 0x10, 
/* 201  */ 0x0a, 0x08, 0x10, 
/* 202  */ 0x0c, 0x08, 0x10, 
/* 203  */ 0x0e, 0x08, 0x10, 
/* 204  */ 0x10, 0x08, 0x10, 
/* 205  */ 0x10, 0x08, 0x0e, 
/* 206  */ 0x10, 0x08, 0x0c, 
/* 207  */ 0x10, 0x08, 0x0a, 
/* 208  */ 0x10, 0x08, 0x08, 
/* 209  */ 0x10, 0x0a, 0x08, 
/* 210  */ 0x10, 0x0c, 0x08, 
/* 211  */ 0x10, 0x0e, 0x08, 
/* 212  */ 0x10, 0x10, 0x08, 
/* 213  */ 0x0e, 0x10, 0x08, 
/* 214  */ 0x0c, 0x10, 0x08, 
/* 215  */ 0x0a, 0x10, 0x08, 
/* 216  */ 0x08, 0x10, 0x08, 
/* 217  */ 0x08, 0x10, 0x0a, 
/* 218  */ 0x08, 0x10, 0x0c, 
/* 219  */ 0x08, 0x10, 0x0e, 
/* 220  */ 0x08, 0x10, 0x10, 
/* 221  */ 0x08, 0x0e, 0x10, 
/* 222  */ 0x08, 0x0c, 0x10, 
/* 223  */ 0x08, 0x0a, 0x10, 
/* 224  */ 0x0b, 0x0b, 0x10, 
/* 225  */ 0x0c, 0x0b, 0x10, 
/* 226  */ 0x0d, 0x0b, 0x10, 
/* 227  */ 0x0f, 0x0b, 0x10, 
/* 228  */ 0x10, 0x0b, 0x10, 
/* 229  */ 0x10, 0x0b, 0x0f, 
/* 230  */ 0x10, 0x0b, 0x0d, 
/* 231  */ 0x10, 0x0b, 0x0c, 
/* 232  */ 0x10, 0x0b, 0x0b, 
/* 233  */ 0x10, 0x0c, 0x0b, 
/* 234  */ 0x10, 0x0d, 0x0b, 
/* 235  */ 0x10, 0x0f, 0x0b, 
/* 236  */ 0x10, 0x10, 0x0b, 
/* 237  */ 0x0f, 0x10, 0x0b, 
/* 238  */ 0x0d, 0x10, 0x0b, 
/* 239  */ 0x0c, 0x10, 0x0b, 
/* 240  */ 0x0b, 0x10, 0x0b, 
/* 241  */ 0x0b, 0x10, 0x0c, 
/* 242  */ 0x0b, 0x10, 0x0d, 
/* 243  */ 0x0b, 0x10, 0x0f, 
/* 244  */ 0x0b, 0x10, 0x10, 
/* 245  */ 0x0b, 0x0f, 0x10, 
/* 246  */ 0x0b, 0x0d, 0x10, 
/* 247  */ 0x0b, 0x0c, 0x10, 
/* 248  */ 0x00, 0x00, 0x00, 
/* 249  */ 0x00, 0x00, 0x00, 
/* 250  */ 0x00, 0x00, 0x00, 
/* 251  */ 0x00, 0x00, 0x00, 
/* 252  */ 0x00, 0x00, 0x00, 
/* 253  */ 0x00, 0x00, 0x00, 
/* 254  */ 0x00, 0x00, 0x00, 
/* 255  */ 0x00, 0x00, 0x00, 
};

byte vga_low_dac[0x300] = {
/* 00  */ 0x00, 0x00, 0x00, 
/* 01  */ 0x00, 0x00, 0x2a, 
/* 02  */ 0x00, 0x2a, 0x00, 
/* 03  */ 0x00, 0x2a, 0x2a, 
/* 04  */ 0x2a, 0x00, 0x00, 
/* 05  */ 0x2a, 0x00, 0x2a, 
/* 06  */ 0x2a, 0x15, 0x00, 
/* 07  */ 0x2a, 0x2a, 0x2a, 
/* 08  */ 0x00, 0x00, 0x00, 
/* 09  */ 0x00, 0x00, 0x2a, 
/* 10  */ 0x00, 0x2a, 0x00, 
/* 11  */ 0x00, 0x2a, 0x2a, 
/* 12  */ 0x2a, 0x00, 0x00, 
/* 13  */ 0x2a, 0x00, 0x2a, 
/* 14  */ 0x2a, 0x15, 0x00, 
/* 15  */ 0x2a, 0x2a, 0x2a, 
/* 16  */ 0x15, 0x15, 0x15, 
/* 17  */ 0x15, 0x15, 0x3f, 
/* 18  */ 0x15, 0x3f, 0x15, 
/* 19  */ 0x15, 0x3f, 0x3f, 
/* 20  */ 0x3f, 0x15, 0x15, 
/* 21  */ 0x3f, 0x15, 0x3f, 
/* 22  */ 0x3f, 0x3f, 0x15, 
/* 23  */ 0x3f, 0x3f, 0x3f, 
/* 24  */ 0x15, 0x15, 0x15, 
/* 25  */ 0x15, 0x15, 0x3f, 
/* 26  */ 0x15, 0x3f, 0x15, 
/* 27  */ 0x15, 0x3f, 0x3f, 
/* 28  */ 0x3f, 0x15, 0x15, 
/* 29  */ 0x3f, 0x15, 0x3f, 
/* 30  */ 0x3f, 0x3f, 0x15, 
/* 31  */ 0x3f, 0x3f, 0x3f, 
/* 32  */ 0x00, 0x00, 0x00, 
/* 33  */ 0x00, 0x00, 0x2a, 
/* 34  */ 0x00, 0x2a, 0x00, 
/* 35  */ 0x00, 0x2a, 0x2a, 
/* 36  */ 0x2a, 0x00, 0x00, 
/* 37  */ 0x2a, 0x00, 0x2a, 
/* 38  */ 0x2a, 0x15, 0x00, 
/* 39  */ 0x2a, 0x2a, 0x2a, 
/* 40  */ 0x00, 0x00, 0x00, 
/* 41  */ 0x00, 0x00, 0x2a, 
/* 42  */ 0x00, 0x2a, 0x00, 
/* 43  */ 0x00, 0x2a, 0x2a, 
/* 44  */ 0x2a, 0x00, 0x00, 
/* 45  */ 0x2a, 0x00, 0x2a, 
/* 46  */ 0x2a, 0x15, 0x00, 
/* 47  */ 0x2a, 0x2a, 0x2a, 
/* 48  */ 0x15, 0x15, 0x15, 
/* 49  */ 0x15, 0x15, 0x3f, 
/* 50  */ 0x15, 0x3f, 0x15, 
/* 51  */ 0x15, 0x3f, 0x3f, 
/* 52  */ 0x3f, 0x15, 0x15, 
/* 53  */ 0x3f, 0x15, 0x3f, 
/* 54  */ 0x3f, 0x3f, 0x15, 
/* 55  */ 0x3f, 0x3f, 0x3f, 
/* 56  */ 0x15, 0x15, 0x15, 
/* 57  */ 0x15, 0x15, 0x3f, 
/* 58  */ 0x15, 0x3f, 0x15, 
/* 59  */ 0x15, 0x3f, 0x3f, 
/* 60  */ 0x3f, 0x15, 0x15, 
/* 61  */ 0x3f, 0x15, 0x3f, 
/* 62  */ 0x3f, 0x3f, 0x15, 
/* 63  */ 0x3f, 0x3f, 0x3f, 
/* 64  */ 0x3f, 0x1f, 0x1f, 
/* 65  */ 0x3f, 0x27, 0x1f, 
/* 66  */ 0x3f, 0x2f, 0x1f, 
/* 67  */ 0x3f, 0x37, 0x1f, 
/* 68  */ 0x3f, 0x3f, 0x1f, 
/* 69  */ 0x37, 0x3f, 0x1f, 
/* 70  */ 0x2f, 0x3f, 0x1f, 
/* 71  */ 0x27, 0x3f, 0x1f, 
/* 72  */ 0x1f, 0x3f, 0x1f, 
/* 73  */ 0x1f, 0x3f, 0x27, 
/* 74  */ 0x1f, 0x3f, 0x2f, 
/* 75  */ 0x1f, 0x3f, 0x37, 
/* 76  */ 0x1f, 0x3f, 0x3f, 
/* 77  */ 0x1f, 0x37, 0x3f, 
/* 78  */ 0x1f, 0x2f, 0x3f, 
/* 79  */ 0x1f, 0x27, 0x3f, 
/* 80  */ 0x2d, 0x2d, 0x3f, 
/* 81  */ 0x31, 0x2d, 0x3f, 
/* 82  */ 0x36, 0x2d, 0x3f, 
/* 83  */ 0x3a, 0x2d, 0x3f, 
/* 84  */ 0x3f, 0x2d, 0x3f, 
/* 85  */ 0x3f, 0x2d, 0x3a, 
/* 86  */ 0x3f, 0x2d, 0x36, 
/* 87  */ 0x3f, 0x2d, 0x31, 
/* 88  */ 0x3f, 0x2d, 0x2d, 
/* 89  */ 0x3f, 0x31, 0x2d, 
/* 90  */ 0x3f, 0x36, 0x2d, 
/* 91  */ 0x3f, 0x3a, 0x2d, 
/* 92  */ 0x3f, 0x3f, 0x2d, 
/* 93  */ 0x3a, 0x3f, 0x2d, 
/* 94  */ 0x36, 0x3f, 0x2d, 
/* 95  */ 0x31, 0x3f, 0x2d, 
/* 96  */ 0x2d, 0x3f, 0x2d, 
/* 97  */ 0x2d, 0x3f, 0x31, 
/* 98  */ 0x2d, 0x3f, 0x36, 
/* 99  */ 0x2d, 0x3f, 0x3a, 
/* 100  */ 0x2d, 0x3f, 0x3f, 
/* 101  */ 0x2d, 0x3a, 0x3f, 
/* 102  */ 0x2d, 0x36, 0x3f, 
/* 103  */ 0x2d, 0x31, 0x3f, 
/* 104  */ 0x00, 0x00, 0x1c, 
/* 105  */ 0x07, 0x00, 0x1c, 
/* 106  */ 0x0e, 0x00, 0x1c, 
/* 107  */ 0x15, 0x00, 0x1c, 
/* 108  */ 0x1c, 0x00, 0x1c, 
/* 109  */ 0x1c, 0x00, 0x15, 
/* 110  */ 0x1c, 0x00, 0x0e, 
/* 111  */ 0x1c, 0x00, 0x07, 
/* 112  */ 0x1c, 0x00, 0x00, 
/* 113  */ 0x1c, 0x07, 0x00, 
/* 114  */ 0x1c, 0x0e, 0x00, 
/* 115  */ 0x1c, 0x15, 0x00, 
/* 116  */ 0x1c, 0x1c, 0x00, 
/* 117  */ 0x15, 0x1c, 0x00, 
/* 118  */ 0x0e, 0x1c, 0x00, 
/* 119  */ 0x07, 0x1c, 0x00, 
/* 120  */ 0x00, 0x1c, 0x00, 
/* 121  */ 0x00, 0x1c, 0x07, 
/* 122  */ 0x00, 0x1c, 0x0e, 
/* 123  */ 0x00, 0x1c, 0x15, 
/* 124  */ 0x00, 0x1c, 0x1c, 
/* 125  */ 0x00, 0x15, 0x1c, 
/* 126  */ 0x00, 0x0e, 0x1c, 
/* 127  */ 0x00, 0x07, 0x1c, 
/* 128  */ 0x0e, 0x0e, 0x1c, 
/* 129  */ 0x11, 0x0e, 0x1c, 
/* 130  */ 0x15, 0x0e, 0x1c, 
/* 131  */ 0x18, 0x0e, 0x1c, 
/* 132  */ 0x1c, 0x0e, 0x1c, 
/* 133  */ 0x1c, 0x0e, 0x18, 
/* 134  */ 0x1c, 0x0e, 0x15, 
/* 135  */ 0x1c, 0x0e, 0x11, 
/* 136  */ 0x1c, 0x0e, 0x0e, 
/* 137  */ 0x1c, 0x11, 0x0e, 
/* 138  */ 0x1c, 0x15, 0x0e, 
/* 139  */ 0x1c, 0x18, 0x0e, 
/* 140  */ 0x1c, 0x1c, 0x0e, 
/* 141  */ 0x18, 0x1c, 0x0e, 
/* 142  */ 0x15, 0x1c, 0x0e, 
/* 143  */ 0x11, 0x1c, 0x0e, 
/* 144  */ 0x0e, 0x1c, 0x0e, 
/* 145  */ 0x0e, 0x1c, 0x11, 
/* 146  */ 0x0e, 0x1c, 0x15, 
/* 147  */ 0x0e, 0x1c, 0x18, 
/* 148  */ 0x0e, 0x1c, 0x1c, 
/* 149  */ 0x0e, 0x18, 0x1c, 
/* 150  */ 0x0e, 0x15, 0x1c, 
/* 151  */ 0x0e, 0x11, 0x1c, 
/* 152  */ 0x14, 0x14, 0x1c, 
/* 153  */ 0x16, 0x14, 0x1c, 
/* 154  */ 0x18, 0x14, 0x1c, 
/* 155  */ 0x1a, 0x14, 0x1c, 
/* 156  */ 0x1c, 0x14, 0x1c, 
/* 157  */ 0x1c, 0x14, 0x1a, 
/* 158  */ 0x1c, 0x14, 0x18, 
/* 159  */ 0x1c, 0x14, 0x16, 
/* 160  */ 0x1c, 0x14, 0x14, 
/* 161  */ 0x1c, 0x16, 0x14, 
/* 162  */ 0x1c, 0x18, 0x14, 
/* 163  */ 0x1c, 0x1a, 0x14, 
/* 164  */ 0x1c, 0x1c, 0x14, 
/* 165  */ 0x1a, 0x1c, 0x14, 
/* 166  */ 0x18, 0x1c, 0x14, 
/* 167  */ 0x16, 0x1c, 0x14, 
/* 168  */ 0x14, 0x1c, 0x14, 
/* 169  */ 0x14, 0x1c, 0x16, 
/* 170  */ 0x14, 0x1c, 0x18, 
/* 171  */ 0x14, 0x1c, 0x1a, 
/* 172  */ 0x14, 0x1c, 0x1c, 
/* 173  */ 0x14, 0x1a, 0x1c, 
/* 174  */ 0x14, 0x18, 0x1c, 
/* 175  */ 0x14, 0x16, 0x1c, 
/* 176  */ 0x00, 0x00, 0x10, 
/* 177  */ 0x04, 0x00, 0x10, 
/* 178  */ 0x08, 0x00, 0x10, 
/* 179  */ 0x0c, 0x00, 0x10, 
/* 180  */ 0x10, 0x00, 0x10, 
/* 181  */ 0x10, 0x00, 0x0c, 
/* 182  */ 0x10, 0x00, 0x08, 
/* 183  */ 0x10, 0x00, 0x04, 
/* 184  */ 0x10, 0x00, 0x00, 
/* 185  */ 0x10, 0x04, 0x00, 
/* 186  */ 0x10, 0x08, 0x00, 
/* 187  */ 0x10, 0x0c, 0x00, 
/* 188  */ 0x10, 0x10, 0x00, 
/* 189  */ 0x0c, 0x10, 0x00, 
/* 190  */ 0x08, 0x10, 0x00, 
/* 191  */ 0x04, 0x10, 0x00, 
/* 192  */ 0x00, 0x10, 0x00, 
/* 193  */ 0x00, 0x10, 0x04, 
/* 194  */ 0x00, 0x10, 0x08, 
/* 195  */ 0x00, 0x10, 0x0c, 
/* 196  */ 0x00, 0x10, 0x10, 
/* 197  */ 0x00, 0x0c, 0x10, 
/* 198  */ 0x00, 0x08, 0x10, 
/* 199  */ 0x00, 0x04, 0x10, 
/* 200  */ 0x08, 0x08, 0x10, 
/* 201  */ 0x0a, 0x08, 0x10, 
/* 202  */ 0x0c, 0x08, 0x10, 
/* 203  */ 0x0e, 0x08, 0x10, 
/* 204  */ 0x10, 0x08, 0x10, 
/* 205  */ 0x10, 0x08, 0x0e, 
/* 206  */ 0x10, 0x08, 0x0c, 
/* 207  */ 0x10, 0x08, 0x0a, 
/* 208  */ 0x10, 0x08, 0x08, 
/* 209  */ 0x10, 0x0a, 0x08, 
/* 210  */ 0x10, 0x0c, 0x08, 
/* 211  */ 0x10, 0x0e, 0x08, 
/* 212  */ 0x10, 0x10, 0x08, 
/* 213  */ 0x0e, 0x10, 0x08, 
/* 214  */ 0x0c, 0x10, 0x08, 
/* 215  */ 0x0a, 0x10, 0x08, 
/* 216  */ 0x08, 0x10, 0x08, 
/* 217  */ 0x08, 0x10, 0x0a, 
/* 218  */ 0x08, 0x10, 0x0c, 
/* 219  */ 0x08, 0x10, 0x0e, 
/* 220  */ 0x08, 0x10, 0x10, 
/* 221  */ 0x08, 0x0e, 0x10, 
/* 222  */ 0x08, 0x0c, 0x10, 
/* 223  */ 0x08, 0x0a, 0x10, 
/* 224  */ 0x0b, 0x0b, 0x10, 
/* 225  */ 0x0c, 0x0b, 0x10, 
/* 226  */ 0x0d, 0x0b, 0x10, 
/* 227  */ 0x0f, 0x0b, 0x10, 
/* 228  */ 0x10, 0x0b, 0x10, 
/* 229  */ 0x10, 0x0b, 0x0f, 
/* 230  */ 0x10, 0x0b, 0x0d, 
/* 231  */ 0x10, 0x0b, 0x0c, 
/* 232  */ 0x10, 0x0b, 0x0b, 
/* 233  */ 0x10, 0x0c, 0x0b, 
/* 234  */ 0x10, 0x0d, 0x0b, 
/* 235  */ 0x10, 0x0f, 0x0b, 
/* 236  */ 0x10, 0x10, 0x0b, 
/* 237  */ 0x0f, 0x10, 0x0b, 
/* 238  */ 0x0d, 0x10, 0x0b, 
/* 239  */ 0x0c, 0x10, 0x0b, 
/* 240  */ 0x0b, 0x10, 0x0b, 
/* 241  */ 0x0b, 0x10, 0x0c, 
/* 242  */ 0x0b, 0x10, 0x0d, 
/* 243  */ 0x0b, 0x10, 0x0f, 
/* 244  */ 0x0b, 0x10, 0x10, 
/* 245  */ 0x0b, 0x0f, 0x10, 
/* 246  */ 0x0b, 0x0d, 0x10, 
/* 247  */ 0x0b, 0x0c, 0x10, 
/* 248  */ 0x00, 0x00, 0x00, 
/* 249  */ 0x00, 0x00, 0x00, 
/* 250  */ 0x00, 0x00, 0x00, 
/* 251  */ 0x00, 0x00, 0x00, 
/* 252  */ 0x00, 0x00, 0x00, 
/* 253  */ 0x00, 0x00, 0x00, 
/* 254  */ 0x00, 0x00, 0x00, 
/* 255  */ 0x00, 0x00, 0x00, 
};

byte vga_256_dac[0x300] =
{
/* 00 */ 0x00,0x00,0x00,
/* 01 */ 0x00,0x00,0x2a,
/* 02 */ 0x00,0x2a,0x00,
/* 03 */ 0x00,0x2a,0x2a,
/* 04 */ 0x2a,0x00,0x00,
/* 05 */ 0x2a,0x00,0x2a,
/* 06 */ 0x2a,0x15,0x00,
/* 07 */ 0x2a,0x2a,0x2a,
/* 08 */ 0x15,0x15,0x15,
/* 09 */ 0x15,0x15,0x3f,
/* 10 */ 0x15,0x3f,0x15,
/* 11 */ 0x15,0x3f,0x3f,
/* 12 */ 0x3f,0x15,0x15,
/* 13 */ 0x3f,0x15,0x3f,
/* 14 */ 0x3f,0x3f,0x15,
/* 15 */ 0x3f,0x3f,0x3f,
/* 16 */ 0x00,0x00,0x00,
/* 17 */ 0x05,0x05,0x05,
/* 18 */ 0x08,0x08,0x08,
/* 19 */ 0x0b,0x0b,0x0b,
/* 20 */ 0x0e,0x0e,0x0e,
/* 21 */ 0x11,0x11,0x11,
/* 22 */ 0x14,0x14,0x14,
/* 23 */ 0x18,0x18,0x18,
/* 24 */ 0x1c,0x1c,0x1c,
/* 25 */ 0x20,0x20,0x20,
/* 26 */ 0x24,0x24,0x24,
/* 27 */ 0x28,0x28,0x28,
/* 28 */ 0x2d,0x2d,0x2d,
/* 29 */ 0x32,0x32,0x32,
/* 30 */ 0x38,0x38,0x38,
/* 31 */ 0x3f,0x3f,0x3f,
/* 32 */ 0x00,0x00,0x3f,
/* 33 */ 0x10,0x00,0x3f,
/* 34 */ 0x1f,0x00,0x3f,
/* 35 */ 0x2f,0x00,0x3f,
/* 36 */ 0x3f,0x00,0x3f,
/* 37 */ 0x3f,0x00,0x2f,
/* 38 */ 0x3f,0x00,0x1f,
/* 39 */ 0x3f,0x00,0x10,
/* 40 */ 0x3f,0x00,0x00,
/* 41 */ 0x3f,0x10,0x00,
/* 42 */ 0x3f,0x1f,0x00,
/* 43 */ 0x3f,0x2f,0x00,
/* 44 */ 0x3f,0x3f,0x00,
/* 45 */ 0x2f,0x3f,0x00,
/* 46 */ 0x1f,0x3f,0x00,
/* 47 */ 0x10,0x3f,0x00,
/* 48 */ 0x00,0x3f,0x00,
/* 49 */ 0x00,0x3f,0x10,
/* 50 */ 0x00,0x3f,0x1f,
/* 51 */ 0x00,0x3f,0x2f,
/* 52 */ 0x00,0x3f,0x3f,
/* 53 */ 0x00,0x2f,0x3f,
/* 54 */ 0x00,0x1f,0x3f,
/* 55 */ 0x00,0x10,0x3f,
/* 56 */ 0x1f,0x1f,0x3f,
/* 57 */ 0x27,0x1f,0x3f,
/* 58 */ 0x2f,0x1f,0x3f,
/* 59 */ 0x37,0x1f,0x3f,
/* 60 */ 0x3f,0x1f,0x3f,
/* 61 */ 0x3f,0x1f,0x37,
/* 62 */ 0x3f,0x1f,0x2f,
/* 63 */ 0x3f,0x1f,0x27,
/* 64 */ 0x3f,0x1f,0x1f,
/* 65 */ 0x3f,0x27,0x1f,
/* 66 */ 0x3f,0x2f,0x1f,
/* 67 */ 0x3f,0x37,0x1f,
/* 68 */ 0x3f,0x3f,0x1f,
/* 69 */ 0x37,0x3f,0x1f,
/* 70 */ 0x2f,0x3f,0x1f,
/* 71 */ 0x27,0x3f,0x1f,
/* 72 */ 0x1f,0x3f,0x1f,
/* 73 */ 0x1f,0x3f,0x27,
/* 74 */ 0x1f,0x3f,0x2f,
/* 75 */ 0x1f,0x3f,0x37,
/* 76 */ 0x1f,0x3f,0x3f,
/* 77 */ 0x1f,0x37,0x3f,
/* 78 */ 0x1f,0x2f,0x3f,
/* 79 */ 0x1f,0x27,0x3f,
/* 80 */ 0x2d,0x2d,0x3f,
/* 81 */ 0x31,0x2d,0x3f,
/* 82 */ 0x36,0x2d,0x3f,
/* 83 */ 0x3a,0x2d,0x3f,
/* 84 */ 0x3f,0x2d,0x3f,
/* 85 */ 0x3f,0x2d,0x3a,
/* 86 */ 0x3f,0x2d,0x36,
/* 87 */ 0x3f,0x2d,0x31,
/* 88 */ 0x3f,0x2d,0x2d,
/* 89 */ 0x3f,0x31,0x2d,
/* 90 */ 0x3f,0x36,0x2d,
/* 91 */ 0x3f,0x3a,0x2d,
/* 92 */ 0x3f,0x3f,0x2d,
/* 93 */ 0x3a,0x3f,0x2d,
/* 94 */ 0x36,0x3f,0x2d,
/* 95 */ 0x31,0x3f,0x2d,
/* 96 */ 0x2d,0x3f,0x2d,
/* 97 */ 0x2d,0x3f,0x31,
/* 98 */ 0x2d,0x3f,0x36,
/* 99 */ 0x2d,0x3f,0x3a,
/* 100 */ 0x2d,0x3f,0x3f,
/* 101 */ 0x2d,0x3a,0x3f,
/* 102 */ 0x2d,0x36,0x3f,
/* 103 */ 0x2d,0x31,0x3f,
/* 104 */ 0x00,0x00,0x1c,
/* 105 */ 0x07,0x00,0x1c,
/* 106 */ 0x0e,0x00,0x1c,
/* 107 */ 0x15,0x00,0x1c,
/* 108 */ 0x1c,0x00,0x1c,
/* 109 */ 0x1c,0x00,0x15,
/* 110 */ 0x1c,0x00,0x0e,
/* 111 */ 0x1c,0x00,0x07,
/* 112 */ 0x1c,0x00,0x00,
/* 113 */ 0x1c,0x07,0x00,
/* 114 */ 0x1c,0x0e,0x00,
/* 115 */ 0x1c,0x15,0x00,
/* 116 */ 0x1c,0x1c,0x00,
/* 117 */ 0x15,0x1c,0x00,
/* 118 */ 0x0e,0x1c,0x00,
/* 119 */ 0x07,0x1c,0x00,
/* 120 */ 0x00,0x1c,0x00,
/* 121 */ 0x00,0x1c,0x07,
/* 122 */ 0x00,0x1c,0x0e,
/* 123 */ 0x00,0x1c,0x15,
/* 124 */ 0x00,0x1c,0x1c,
/* 125 */ 0x00,0x15,0x1c,
/* 126 */ 0x00,0x0e,0x1c,
/* 127 */ 0x00,0x07,0x1c,
/* 128 */ 0x0e,0x0e,0x1c,
/* 129 */ 0x11,0x0e,0x1c,
/* 130 */ 0x15,0x0e,0x1c,
/* 131 */ 0x18,0x0e,0x1c,
/* 132 */ 0x1c,0x0e,0x1c,
/* 133 */ 0x1c,0x0e,0x18,
/* 134 */ 0x1c,0x0e,0x15,
/* 135 */ 0x1c,0x0e,0x11,
/* 136 */ 0x1c,0x0e,0x0e,
/* 137 */ 0x1c,0x11,0x0e,
/* 138 */ 0x1c,0x15,0x0e,
/* 139 */ 0x1c,0x18,0x0e,
/* 140 */ 0x1c,0x1c,0x0e,
/* 141 */ 0x18,0x1c,0x0e,
/* 142 */ 0x15,0x1c,0x0e,
/* 143 */ 0x11,0x1c,0x0e,
/* 144 */ 0x0e,0x1c,0x0e,
/* 145 */ 0x0e,0x1c,0x11,
/* 146 */ 0x0e,0x1c,0x15,
/* 147 */ 0x0e,0x1c,0x18,
/* 148 */ 0x0e,0x1c,0x1c,
/* 149 */ 0x0e,0x18,0x1c,
/* 150 */ 0x0e,0x15,0x1c,
/* 151 */ 0x0e,0x11,0x1c,
/* 152 */ 0x14,0x14,0x1c,
/* 153 */ 0x16,0x14,0x1c,
/* 154 */ 0x18,0x14,0x1c,
/* 155 */ 0x1a,0x14,0x1c,
/* 156 */ 0x1c,0x14,0x1c,
/* 157 */ 0x1c,0x14,0x1a,
/* 158 */ 0x1c,0x14,0x18,
/* 159 */ 0x1c,0x14,0x16,
/* 160 */ 0x1c,0x14,0x14,
/* 161 */ 0x1c,0x16,0x14,
/* 162 */ 0x1c,0x18,0x14,
/* 163 */ 0x1c,0x1a,0x14,
/* 164 */ 0x1c,0x1c,0x14,
/* 165 */ 0x1a,0x1c,0x14,
/* 166 */ 0x18,0x1c,0x14,
/* 167 */ 0x16,0x1c,0x14,
/* 168 */ 0x14,0x1c,0x14,
/* 169 */ 0x14,0x1c,0x16,
/* 170 */ 0x14,0x1c,0x18,
/* 171 */ 0x14,0x1c,0x1a,
/* 172 */ 0x14,0x1c,0x1c,
/* 173 */ 0x14,0x1a,0x1c,
/* 174 */ 0x14,0x18,0x1c,
/* 175 */ 0x14,0x16,0x1c,
/* 176 */ 0x00,0x00,0x10,
/* 177 */ 0x04,0x00,0x10,
/* 178 */ 0x08,0x00,0x10,
/* 179 */ 0x0c,0x00,0x10,
/* 180 */ 0x10,0x00,0x10,
/* 181 */ 0x10,0x00,0x0c,
/* 182 */ 0x10,0x00,0x08,
/* 183 */ 0x10,0x00,0x04,
/* 184 */ 0x10,0x00,0x00,
/* 185 */ 0x10,0x04,0x00,
/* 186 */ 0x10,0x08,0x00,
/* 187 */ 0x10,0x0c,0x00,
/* 188 */ 0x10,0x10,0x00,
/* 189 */ 0x0c,0x10,0x00,
/* 190 */ 0x08,0x10,0x00,
/* 191 */ 0x04,0x10,0x00,
/* 192 */ 0x00,0x10,0x00,
/* 193 */ 0x00,0x10,0x04,
/* 194 */ 0x00,0x10,0x08,
/* 195 */ 0x00,0x10,0x0c,
/* 196 */ 0x00,0x10,0x10,
/* 197 */ 0x00,0x0c,0x10,
/* 198 */ 0x00,0x08,0x10,
/* 199 */ 0x00,0x04,0x10,
/* 200 */ 0x08,0x08,0x10,
/* 201 */ 0x0a,0x08,0x10,
/* 202 */ 0x0c,0x08,0x10,
/* 203 */ 0x0e,0x08,0x10,
/* 204 */ 0x10,0x08,0x10,
/* 205 */ 0x10,0x08,0x0e,
/* 206 */ 0x10,0x08,0x0c,
/* 207 */ 0x10,0x08,0x0a,
/* 208 */ 0x10,0x08,0x08,
/* 209 */ 0x10,0x0a,0x08,
/* 210 */ 0x10,0x0c,0x08,
/* 211 */ 0x10,0x0e,0x08,
/* 212 */ 0x10,0x10,0x08,
/* 213 */ 0x0e,0x10,0x08,
/* 214 */ 0x0c,0x10,0x08,
/* 215 */ 0x0a,0x10,0x08,
/* 216 */ 0x08,0x10,0x08,
/* 217 */ 0x08,0x10,0x0a,
/* 218 */ 0x08,0x10,0x0c,
/* 219 */ 0x08,0x10,0x0e,
/* 220 */ 0x08,0x10,0x10,
/* 221 */ 0x08,0x0e,0x10,
/* 222 */ 0x08,0x0c,0x10,
/* 223 */ 0x08,0x0a,0x10,
/* 224 */ 0x0b,0x0b,0x10,
/* 225 */ 0x0c,0x0b,0x10,
/* 226 */ 0x0d,0x0b,0x10,
/* 227 */ 0x0f,0x0b,0x10,
/* 228 */ 0x10,0x0b,0x10,
/* 229 */ 0x10,0x0b,0x0f,
/* 230 */ 0x10,0x0b,0x0d,
/* 231 */ 0x10,0x0b,0x0c,
/* 232 */ 0x10,0x0b,0x0b,
/* 233 */ 0x10,0x0c,0x0b,
/* 234 */ 0x10,0x0d,0x0b,
/* 235 */ 0x10,0x0f,0x0b,
/* 236 */ 0x10,0x10,0x0b,
/* 237 */ 0x0f,0x10,0x0b,
/* 238 */ 0x0d,0x10,0x0b,
/* 239 */ 0x0c,0x10,0x0b,
/* 240 */ 0x0b,0x10,0x0b,
/* 241 */ 0x0b,0x10,0x0c,
/* 242 */ 0x0b,0x10,0x0d,
/* 243 */ 0x0b,0x10,0x0f,
/* 244 */ 0x0b,0x10,0x10,
/* 245 */ 0x0b,0x0f,0x10,
/* 246 */ 0x0b,0x0d,0x10,
/* 247 */ 0x0b,0x0c,0x10,
/* 248 */ 0x00,0x00,0x00,
/* 249 */ 0x00,0x00,0x00,
/* 250 */ 0x00,0x00,0x00,
/* 251 */ 0x00,0x00,0x00,
/* 252 */ 0x00,0x00,0x00,
/* 253 */ 0x00,0x00,0x00,
/* 254 */ 0x00,0x00,0x00,
/* 255 */ 0x00,0x00,0x00
};

#endif	/* ! macintosh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\video.h ===
/* SccsID @(#)video.h	1.24 08/19/94 Copyright Insignia Solutions Inc. */

#ifndef NEC_98
/*
 * M6845 video chip registers
 */

#define R10_CURS_START	        10
#define R11_CURS_END	        11
#define CGA_R12_START_ADDRH	12
#define CGA_R13_START_ADDRL	13
#define R14_CURS_ADDRH	        14
#define R15_CURS_ADDRL	        15

#define M6845_INDEX_REG         (word)(vd_addr_6845)
#define M6845_DATA_REG          (word)(vd_addr_6845 + 1)
#define M6845_MODE_REG          (word)(vd_addr_6845 + 4)

/*
 * The individual colour adaptor registers
 */


/*
 * The clear character defines
 */

#define VD_CLEAR_TEXT 		((7 << 8) | ' ')
#define VD_CLEAR_GRAPHICS 	0


/*
 * 'tidy' define for operations on graphics memory which is stored in two banks:
 * of odd & even scan lines.
 */
#define ODD_OFF		0x2000	/* offset of odd graphics bank from even */
#define SCAN_CHAR_HEIGHT 8	/* no scanlines spanned by graphics char */

/* 4 full scanlines is the (offset/size) of one text line PER bank */
#define ONELINEOFF      320
#endif // !NEC_98


/*
 * The control character defines
 */

#define VD_BS		0x8			/* Backspace	*/
#define VD_CR		0xD			/* Return	*/
#define VD_LF		0xA			/* Line feed	*/
#define VD_BEL		0x7			/* Bell		*/

/*
 * Sound system defines
 */

#define	BEEP_LENGTH	500000L	/* 1/2 second beep */

/*
 * intel memory position defines for data stored in bios variables
 */

#if defined(NEC_98)
IMPORT void keyboard_io IPT0();             /* routed to KB BIOS        */
IMPORT void vd_NEC98_set_mode IPT0();           /* 0ah Set mode             */
IMPORT void vd_NEC98_get_mode IPT0();           /* 0bh Get mode             */
IMPORT void vd_NEC98_start_display IPT0();      /* 0ch Start display        */
IMPORT void vd_NEC98_stop_display IPT0();       /* 0dh Stop display         */
IMPORT void vd_NEC98_single_window IPT0();      /* 0eh Set single window    */
IMPORT void vd_NEC98_multi_window IPT0();       /* 0fh Set multi window     */
IMPORT void vd_NEC98_set_cursor IPT0();         /* 10h Set cursor type      */
IMPORT void vd_NEC98_show_cursor IPT0();        /* 11h Show cursor          */
IMPORT void vd_NEC98_hide_cursor IPT0();        /* 12h Hide cursor          */
IMPORT void vd_NEC98_set_cursorpos IPT0();      /* 13h Set cursor position  */
IMPORT void vd_NEC98_get_font IPT0();           /* 14h Get font             */
IMPORT void vd_NEC98_get_pen IPT0();            /* 15h Get lightpen status  */
IMPORT void vd_NEC98_init_textvram IPT0();      /* 16h Initialize text vram */
IMPORT void vd_NEC98_start_beep IPT0();         /* 17h Start beep sound     */
IMPORT void vd_NEC98_stop_beep IPT0();          /* 18h Stop beep sound      */
IMPORT void vd_NEC98_init_pen IPT0();           /* 19h Initialize lightpen  */
IMPORT void vd_NEC98_set_font IPT0();           /* 1ah Set user font        */
IMPORT void vd_NEC98_set_kcgmode IPT0();        /* 1bh Set KCG access mode  */
IMPORT void vd_NEC98_init_crt IPT0();           /* 1ch Initialize CRT    /H */
IMPORT void vd_NEC98_set_disp_width IPT0();     /* 1dh Set display size  /H */
IMPORT void vd_NEC98_set_cursor_type IPT0();    /* 1eh Set cursor type   /H */
IMPORT void vd_NEC98_get_mswitch IPT0();        /* 21h Get memory switch /H */
IMPORT void vd_NEC98_set_mswitch IPT0();        /* 22h Set memory switch /H */
IMPORT void vd_NEC98_set_beep_rate IPT0();      /* 23h Set beep rate     /H */
IMPORT void vd_NEC98_set_beep_time IPT0();      /* 24h Set beep time&ring/H */
IMPORT void video_init IPT0();

extern BOOL     HIRESO_MODE;

IMPORT void (*video_func_h[]) ();
IMPORT void (*video_func_n[]) ();

/*
 * The following table specifies data for the supported video
 * modes - ie 80x25 A/N and 640x200 APA.  It is indexed via the video
 * mode variable and a value of VD_BAD_MODE indicates that the given
 * video mode is not supported.
 */

typedef struct {
                sys_addr    start_addr;
                sys_addr    end_addr;
                word        clear_char;
                half_word   mode_control_val;
                half_word   mode_screen_cols;
                word        ncols;
                half_word   npages;
               } MODE_ENTRY;

#if 0 ///STREAM_IO codes are disabled now, till Beta-1
#ifdef NTVDM
/* this is the stream io buffer size used on RISC machines.
 * On X86, the size is determined by spckbd.asm
 */
#define STREAM_IO_BUFFER_SIZE_32	82
IMPORT void disable_stream_io(void);
IMPORT void host_enable_stream_io(void);
IMPORT void host_disable_stream_io(void);
IMPORT half_word * stream_io_buffer;
IMPORT word * stream_io_dirty_count_ptr;
IMPORT word stream_io_buffer_size;
IMPORT boolean	stream_io_enabled;
#ifdef MONITOR
IMPORT sys_addr stream_io_bios_busy_sysaddr;
#endif

#endif
#endif // zero
#else  // !NEC_98

#define	vd_video_mode	0x449
#define VID_COLS	0x44A	/* vd_cols_on_screen */
#define	VID_LEN  	0x44C	/* vd_crt_len */
#define	VID_ADDR	0x44E	/* vd_crt_start */
#define	VID_CURPOS	0x450	/* cursor table 8 pages */
#define	VID_CURMOD	0x460	/* vd_cursor_mode */
#define	vd_current_page	0x462
#define VID_INDEX	0x463	/* vd_addr_6845 */
#define	vd_crt_mode	0x465
#define	vd_crt_palette	0x466

#ifdef EGG
#define vd_rows_on_screen 0x484
#else
#define vd_rows_on_screen  24        /* Never changes */
#endif

extern IU8 Video_mode;	/* Shadow copy of BIOS video mode */

/* Where the BIOS thinks the display is in memory */
IMPORT sys_addr video_pc_low_regen,video_pc_high_regen;

/* useful defines to get at the current cursor position */
#define current_cursor_col	VID_CURPOS+2*sas_hw_at_no_check(vd_current_page)
#define current_cursor_row	VID_CURPOS+2*sas_hw_at_no_check(vd_current_page)+1

#define NO_OF_M6845_REGISTERS	16

#define	CHARS_IN_GEN	128	/* length of gen tables */
#define CHAR_MAP_SIZE	8	/* no. of bytes for one character in font */



/*
 * The function jump table for the video routines.  The video_io() function
 * uses this to route calls on the AH register
 */
IMPORT void vd_set_mode IPT0();
IMPORT void vd_set_cursor_mode IPT0();
IMPORT void vd_set_cursor_position IPT0();
IMPORT void vd_get_cursor_position IPT0();
IMPORT void vd_get_light_pen IPT0();
IMPORT void vd_set_active_page IPT0();
IMPORT void vd_scroll_up IPT0(), vd_scroll_down IPT0();
IMPORT void vd_read_attrib_char IPT0(), vd_write_char_attrib IPT0();
IMPORT void vd_write_char IPT0();
IMPORT void vd_set_colour_palette IPT0();
IMPORT void vd_read_dot IPT0(), vd_write_dot IPT0();
IMPORT void vd_write_teletype IPT0();
IMPORT void vd_get_mode IPT0();
IMPORT void vd_write_string IPT0();


IMPORT void video_init IPT0();
IMPORT void ega_video_init IPT0();
IMPORT void ega_video_io IPT0();
IMPORT void ega_graphics_write_char IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_write_dot IPT4(int, i, int, j, int, k, int , l);
IMPORT void ega_sensible_graph_scroll_up IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_sensible_graph_scroll_down IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_read_attrib_char IPT3(int, i, int, j ,int, k);
IMPORT void ega_read_attrib_dot IPT3(int, i, int, j ,int, k);
IMPORT void search_font IPT2(char *, ptr, int, i);

#ifdef VGG
IMPORT void not_imp IPT0();
#endif

#ifdef VGG
IMPORT void vga_disp_comb IPT0();
IMPORT void vga_disp_func IPT0();
IMPORT void vga_int_1C IPT0();
#endif

/* offsets into video_func */
#ifdef VGG
#define EGA_FUNC_SIZE	0x1D
#else
#define EGA_FUNC_SIZE	0x14
#endif
#define CGA_FUNC_SIZE	0x14

#define SET_MODE 0
#ifdef EGG
#define SET_EGA_PALETTE 0x10
#define CHAR_GEN	0x11
#define ALT_SELECT	0x12
#define WRITE_STRING	0x13
#endif

IMPORT void (*video_func[]) ();

/*
 * The following table specifies data for the supported video
 * modes - ie 80x25 A/N and 640x200 APA.  It is indexed via the video
 * mode variable and a value of VD_BAD_MODE indicates that the given
 * video mode is not supported.
 */

typedef struct {
		sys_addr    start_addr;
		sys_addr    end_addr;
		word	    clear_char;
		half_word   mode_control_val;
		half_word   mode_screen_cols;
		word        ncols;
		half_word   npages;
	       } MODE_ENTRY;

#define VD_BAD_MODE     1
#define VIDEO_ENABLE	0x8	/* enable bit in mode byte */

IMPORT MODE_ENTRY vd_mode_table[];
#ifdef V7VGA
IMPORT MODE_ENTRY vd_ext_text_table[];
IMPORT MODE_ENTRY vd_ext_graph_table[];
#endif /* V7VGA */

#ifdef V7VGA
#define VD_MAX_MODE	0x69
#else
#define VD_MAX_MODE	(sizeof(vd_mode_table)/sizeof(MODE_ENTRY))
#endif

/*
 * Mode macros to distinguish between alphanumeric & graphics video modes
 */

#ifdef JAPAN
// mode73h support
#define	alpha_num_mode() \
    ( (sas_hw_at_no_check(vd_video_mode) < 4) || \
      (sas_hw_at_no_check(vd_video_mode) == 7) || \
      (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
#else // !JAPAN
#define	alpha_num_mode()	(sas_hw_at_no_check(vd_video_mode) < 4 || sas_hw_at_no_check(vd_video_mode) == 7)
#endif // !JAPAN
#define	global_alpha_num_mode()	((Video_mode < 4) || (Video_mode == 7))
#ifdef EGG
#ifdef V7VGA
#define ega_mode()	(((sas_hw_at_no_check(vd_video_mode) > 7) && \
	(sas_hw_at_no_check(vd_video_mode) < 19)) || \
	((sas_hw_at_no_check(vd_video_mode) >= 0x14) && \
	(sas_hw_at_no_check(vd_video_mode) < 0x1a)))
#else
#define ega_mode()	((sas_hw_at_no_check(vd_video_mode) > 7) && \
	(sas_hw_at_no_check(vd_video_mode) < 19))
#endif /* V7VGA */
#endif

#ifdef VGG
#ifdef V7VGA
#define vga_256_mode()		(sas_hw_at_no_check(vd_video_mode) == 19 || (sas_hw_at_no_check(vd_video_mode) > 0x19 && sas_hw_at_no_check(vd_video_mode) < 0x1e))
#else
#define vga_256_mode()		(sas_hw_at_no_check(vd_video_mode) == 19)
#endif /* V7VGA */
#endif /* VGG */

/*
 * Macro to check validity of new video mode
 */
IMPORT unsigned char	valid_modes[];

#define NO_MODES	0
#define MDA_MODE	(1<<0)
#define CGA_MODE	(1<<1)
#define CGA_MONO_MODE	(1<<2)
#define EGA_MODE	(1<<3)
#define HERCULES_MODE	(1<<4)
#define VGA_MODE	(1<<5)
#define ALL_MODES	(MDA_MODE|CGA_MODE|CGA_MONO_MODE|EGA_MODE|HERCULES_MODE|VGA_MODE)

#define is_bad_vid_mode(nm)					\
(									       \
  ((nm&0x7F) < 0) ||							       \
  ((nm&0x7F) > 19) ||							       \
  ((video_adapter == MDA)	&& !(valid_modes[(nm&0x7F)]&MDA_MODE)) ||      \
  ((video_adapter == CGA)	&& !(valid_modes[(nm&0x7F)]&CGA_MODE)) ||      \
  ((video_adapter == CGA_MONO)	&& !(valid_modes[(nm&0x7F)]&CGA_MONO_MODE)) || \
  ((video_adapter == EGA)	&& !(valid_modes[(nm&0x7F)]&EGA_MODE)) ||      \
  ((video_adapter == VGA)	&& !(valid_modes[(nm&0x7F)]&VGA_MODE)) ||	\
  ((video_adapter == HERCULES)	&& !(valid_modes[(nm&0x7F)]&HERCULES_MODE))    \
)

#ifdef V7VGA
#define is_v7vga_mode(nm)	((nm >= 0x40 && nm <= 0x45) || (nm >= 0x60 && nm <= 0x69))
#else
#define is_v7vga_mode(nm)	(FALSE)
#endif /* V7VGA */

IMPORT VOID (*bios_ch2_byte_wrt_fn) IPT2(ULONG, ch_attr, ULONG, ch_addr);
IMPORT VOID (*bios_ch2_word_wrt_fn) IPT2(ULONG, ch_attr, ULONG, ch_addr);

IMPORT VOID simple_bios_byte_wrt IPT2(ULONG, ch_attr, ULONG, ch_addr);
IMPORT VOID simple_bios_word_wrt IPT2(ULONG, ch_attr, ULONG, ch_addr);

#ifdef VGG
IMPORT VOID vga_sensible_graph_scroll_up IPT6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr);

IMPORT VOID vga_sensible_graph_scroll_down IPT6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr);

IMPORT VOID vga_graphics_write_char IPT6( LONG, col, LONG, row, LONG, ch, IU8, colour, LONG, page, LONG, nchs);

IMPORT VOID vga_read_attrib_char IPT3(LONG, col, LONG, row, LONG, page);
IMPORT VOID vga_read_dot IPT3(LONG, page, LONG, pixcol, LONG, row);
IMPORT VOID vga_write_dot IPT4(LONG, colour, LONG, page, LONG, pixcol, LONG, row);

#endif

#ifdef NTVDM
/* this is the stream io buffer size used on RISC machines.
 * On X86, the size is determined by spckbd.asm
 */
#define STREAM_IO_BUFFER_SIZE_32    82
IMPORT void disable_stream_io(void);
IMPORT void host_enable_stream_io(void);
IMPORT void host_disable_stream_io(void);
IMPORT half_word * stream_io_buffer;
IMPORT word * stream_io_dirty_count_ptr;
IMPORT word stream_io_buffer_size;
IMPORT boolean  stream_io_enabled;
#ifdef MONITOR
IMPORT sys_addr stream_io_bios_busy_sysaddr;
#endif /* MONITOR */

#endif /* NTVDM */
#if defined(JAPAN) || defined(KOREA)
extern int dbcs_first[];
#define is_dbcs_first( c ) dbcs_first[ 0xff & c ]

extern int BOPFromDispFlag;
extern sys_addr DBCSVectorAddr; // word
extern sys_addr DosvModePtr;    // byte
extern sys_addr DosvVramPtr;
extern int DosvVramSize;

void SetDBCSVector( int CP );
void SetVram( void );
int is_us_mode( void );
void SetModeForIME( void );
#define INT10_NOTCHANGED    0   // RAID #875
#define INT10_SBCS          1
#define INT10_DBCS_LEADING  2
#define INT10_DBCS_TRAILING 4
#define INT10_CHANGED       0x10
extern int  Int10FlagCnt;
extern byte Int10Flag[];
extern byte NtInt10Flag[];
#endif // JAPAN
#endif // NEC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\worm.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: WORM module definitions
 *
 * Description	: Definitions for users of the WORM module
 *
 * Author	: Daniel Hannigan
 *
 * Notes	: None
 */

/* SccsID[]="@(#)worm.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

extern half_word *gen_mode_buf;
extern half_word *mode_page;
extern half_word *vendor_id;
extern word *driver_cmd_ptr;
extern word driver_cmd;
extern half_word *sense_byte_ptr;	/* additional sense byte */
extern word *op_drv_array;		/* drive control blocks */
extern word *flag_word_ptr;


/*
 * taken from Storage Dimensions asm file OBIOS.H
 *
 * the function codes for the optical primitives.
 */
#define OPTO_TEST	0
#define OPTO_REZERO	1
#define OPTO_INIT	2
#define OPTO_RD_ERR	3
#define	OPTO_FMT_DRV	4
#define OPTO_ROM_ID	5
#define	OPTO_READ	8
#define	OPTO_WRITE	0x0a
#define	OPTO_SEEK	0x0b
#define	OPTO_INQUIRY	0x12
#define	OPTO_MOD_SEL	0x15
#define	OPTO_MOD_SENSE	0x1a
#define OPTO_REC_DIAG	0x1c
#define OPTO_SEND_DIAG	0x1d
#define OPTO_MED_REMOVE	0x1e

#define MED_REM_ALLOW	0
#define MED_REM_PREV	1


/*
 * DOS error codes
 */

#define NO_ERR		0xff

#define WRITE_PROTECT	0
#define INVALID_UNIT	1
#define DEV_NOT_READY	2
#define BAD_COMMAND	3
#define CRC_ERROR	4
#define GEN_FAIL	12
#define MEDIA_CHANGE	15
#define SEC_NOT_WRITTEN	26
#define NO_CARTRIDGE	28

/*
 * DOS device driver command codes
 */

#define INIT		0
#define MEDIA_CHECK	1
#define BUILD_BPB	2
#define IOCTL		3

/*
 * more DOS defines
 */

#define NO_ERROR	0
#define FALSE		0

#define DOS_WRITE_PROT	0
#define DOS_UKNWN_UNIT	1
#define DOS_DRIVE_NRDY	2
#define DOS_UKNWN_CMD	3
#define DOS_CRC_ERROR	4
#define DOS_CMD_LENGTH	5
#define DOS_SEEK_ERROR	6
#define DOS_UNKWN_MED	7
#define DOS_SECT_NFND	8
#define	INVALID_SENSE	9
#define DOS_WRITE_FLT	10
#define DOS_READ_FLT	11
#define DOS_GEN_FAIL	12
#define DOS_INVLD_DISK	15

#define BAD_COMMAND	3

/*
 * OP_DRV_BLK - the current state of a mounted drive
 */
#define SIZE_OP_DRV_BLK	59	/* size of OP_DRV_BLK */

#define	OFFSET_OP_DRV_PUN	0	/* phys unit ( 1-4 valid ) */
#define	OFFSET_OP_DRV_FLG	1

#ifdef ANSI
extern void worm_io ();
extern void worm_init ();
extern int enq_worm ();
#else
extern void worm_io ();
extern void worm_init ();
extern int enq_worm ();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\winfiles.h ===
/*
 *	File :		winfiles.h
 *	Used :		Interfaces provided by winfiles.c plus local macros
 *	Author :	Mike Moreton
 *	SccsId  :	@(#)winfiles.h	1.2 05/03/94 (C)1993 Insignia Solutions Ltd.
 */

#ifdef SWIN_HFX

#define FILE_CREATE	0x3c
#define FILE_OPEN	0x3d
#define	FILE_CLOSE	0x3e
#define FILE_READ	0x3f
#define	FILE_WRITE	0x40
#define FILE_DEL	0x41
#define FILE_LSEEK	0x42
#define FILE_DUPH	0x45
#define FILE_FDUPH	0x46
#define CREATE_CHILD_PSP	0x55
#define FILE_DATETIME	0x57
#define FILE_LOCKUNLOCK	0x5c
#define FILE_COMMIT	0x68
#define FILE_EXOPEN	0x6c

/*
 * Bit set in AL during file open to indicate that the open file
 * handle should not be inherited by child processes.
 */

#define NO_INHERIT 0x80

/*
 * seek requests 
 */
#define F_SEEK_START	0x0
#define	F_SEEK_REL		0x1
#define F_SEEK_END		0x2		

extern void SwinHfxReset IPT0();
extern void SwinHfxTaskTerm IPT0();
extern void SwinRedirector IPT0();
extern void SwinFileOpened IPT0();
extern void SwinHugeIo IPT0();
extern void SwinHfxOpen IPT3(sys_addr, sftEa, IU16, date, IU16, time);
extern IBOOL SwinHfxClose IPT3(IU16, fd, IU16 *, date, IU16 *, time);

extern IBOOL SwinHfxActive;
extern IBOOL SwinFilePreOpened;

#endif /* SOFTWIN_HFX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\yoda.h ===
/*
 * VPC-XT Revision 0.1
 *
 * Title	: yoda.h
 *
 * Description	: The force is with you include file
 *		  (ps yoda debugging file)
 *
 * Author	: Henry Nash
 *		  Phil Bousfield
 *
 * Notes	: This file contains the debugger call definitions
 */

/* SccsID[]="@(#)yoda.h	1.6 06/30/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */


/*  
 * If the PROD flag is set then turn the debugger calls into null macros
 * otherwise they are external functions - see yoda.c
 */

#ifdef PROD
#define check_I() 		/*	*/
#define check_D(address, value) /*address, value*/
#define force_yoda() 		/*	*/
#else
extern void check_I();
extern void check_D();
extern void force_yoda();
#endif

/*
 * Interface definitions and enums - non-prod only.
 */

#ifndef PROD

typedef enum {YODA_RETURN, YODA_RETURN_AND_REPEAT, YODA_HELP, YODA_LOOP, YODA_LOOP_AND_REPEAT} YODA_CMD_RETURN;
#define YODA_COMMAND(name) \
	YODA_CMD_RETURN name IFN6(char *, str, char *, com, IS32, cs, \
				LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef MSWDVR_DEBUG
extern YODA_CMD_RETURN do_mswdvr_debug IPT6(char *,str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);
#endif /* MSWDVR_DEBUG */

extern IBOOL AlreadyInYoda;

extern IU32 IntelMsgDest;
#define IM_DST_TRACE	1
#define IM_DST_RING	2

#else /* !PROD */

#endif /* !PROD else*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\virtual.h ===
/*
 *
 * Title	: virtual.h   Virtual Machine support for Windows 3.x.
 *
 */
 
/* SccsID[]="@(#)virtual.h	1.3 05/10/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* Creation and Termination Callback prototypes */
typedef void (*NIDDB_CR_CALLBACK) IPT1(IHP *, orig_handle);
typedef void (*NIDDB_TM_CALLBACK) IPT0();


/*
 * ============================================================================
 * External declarations
 * ============================================================================
 */

/* Allocate per Virtual Machine data area for Device Driver. */
GLOBAL IHP *NIDDB_Allocate_Instance_Data IPT3
   (
   int, size,			/* Size(in bytes) of data area reqd. */
   NIDDB_CR_CALLBACK, create_cb,     /* create callback, 0 if not reqd. */
   NIDDB_TM_CALLBACK, terminate_cb   /* terminate callback, 0 if not reqd. */
   );

/* Deallocate per Virtual Machine data area for Device Driver. */
GLOBAL void NIDDB_Deallocate_Instance_Data IPT1
   (
   IHP *, handle	/* Handle to data area */
   );

/* Inform NIDDB Manager about System reboot */
GLOBAL void NIDDB_System_Reboot IPT0();

/*
   Entry point from Windows 386 Virtual Device Driver (INSIGNIA.386).
   Provide virtualising services as required.
 */
GLOBAL void virtual_device_trap IPT0();

/* Ensure correct instance in place for Device Drivers. */
/* Called by BOP handler(bios.c) for any Device Driver BOP. */
GLOBAL void virtual_swap_instance IPT0();

/* Indicate if NIDDB is active */
GLOBAL IBOOL NIDDB_is_active IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\keyba.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title:       keyba.c
 *
 * Description: AT keyboard Adaptor I/O functions.
 *
 *              kbd_inb(port,val)
 *              int port;
 *              half_word *val;
 *                              provides the next scan code from the
 *                              keyboard controller (8042), or the
 *                              status byte of the controller, depending
 *                              on the port accessed.
 *              kbd_outb(port,val)
 *              int port;
 *              half_word val;
 *                              Sends a byte to the controller or the
 *                              keyboard processor (6805), depending on
 *                              the port accessed.
 *              AT_kbd_init()
 *                              Performs any initialisation of the
 *                              keyboard code necessary.
 *
 *              The system presents an interface to the host environment
 *              which is provided with the calls:
 *
 *              host_key_down(key)
 *              int key;
 *              host_key_up(key)
 *              int key;
 *
 *              These routines provide the keyboard code with information
 *              on the events which occur on the host keyboard. The key codes
 *              are the key numbers as given in the XT286 Technical Manual.
 *
 * Author:      William Charnell
 *
 * Notes:
 *
 */


#ifdef SCCSID
static char SccsID[]="@(#)keyba.c       1.57 06/22/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_PPI.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "ppi.h"
#include "timeval.h"
#include "timer.h"
#include "keyboard.h"
#include "error.h"
#include "config.h"
#include "ica.h"
#include "keyba.h"
#include "quick_ev.h"
#ifdef macintosh
#include "ckmalloc.h"
#endif /* macintosh */

#include "debug.h"


/* <tur 12-Jul-93> BCN 2040
** KBD_CONT_DELAY is the delay time for continuing keyboard interrupts
** when a "sloppy" read of port 0x60 occurs while the keyboard interface
** is enabled. It's the "delay" parameter to add_q_event_t(), and is
** measured in microseconds.
** Perhaps this should be settable in the host; I've allowed for that here
** by defining the delay to be 7 milliseconds unless it's already defined.
** See comments in kbd_inb() below for more details.
*/

#ifndef KBD_CONT_DELAY
#define KBD_CONT_DELAY  7000            /* microseconds */
#endif  /* KBD_CONT_DELAY */


#ifdef NTVDM
#include "idetect.h"
#include "nt_eoi.h"

/* exported for NT host event code */
GLOBAL VOID KbdResume(VOID);
GLOBAL BOOL bPifFastPaste=TRUE;

/* imported from NT host code */
IMPORT ULONG  WaitKbdHdw(ULONG dwTimeOut);
IMPORT ULONG  KbdHdwFull;

IMPORT VOID  HostReleaseKbd(VOID);

/* imported from keybd_io.c */
IMPORT int bios_buffer_size(void);

IMPORT BOOL bBiosOwnsKbdHdw; // our kbd bios code owns the Keyboard Mutex
word KbdInt09Seg;
word KbdInt09Off;

extern void xmsEnableA20Wrapping(void);
extern void xmsDisableA20Wrapping(void);

#undef LOCAL
#define LOCAL

// local state variables for kbd interrupt regulation
VOID KbdIntDelay(VOID);
BOOL bBiosBufferSpace = TRUE;
BOOL bKbdIntHooked = FALSE;
char KbdData = -1;
BOOL bKbdEoiPending = TRUE;   // Kbd interrupts blocked until KbdResume invoked
BOOL bDelayIntPending = FALSE;
BOOL bForceDelayInts = FALSE;
ULONG LastKbdInt=0;

// Support for extended keyboards has been added to the tables in this file:
//
// * THE BRAZILIAN ABNT keyboard has 104 keys, 2 more than 'usual'
//   0x73 ?/ key, to left of right-Shift
//   0x7E Numpad . key, below Numpad + key
//
//                  Scancode values                      Comment tag
//   Key Number   Set 1  Set 2  Set 3   Character        for tables
//   ----------   ------ ------ ------  ---------------  -----------
//    56 (0x38)    0x73   0x51   0x51   / ? Degree Sign    *56
//   107 (0x6B)    0x7E   0x6D   0x7B   NumPad .           *107
//
// * THE ITALIAN BAV keyboard has two 'extra' keys, 0x7C (00) and 0x7E (000)
//   0x7C Numpad 0 key to left of 00/Ins and 000/Del keys.
//   0x7E Numpad Nul key, below Numpad + key
//   (This is an IBM standard 122-key keyboard, it may not be specifically
//   Italian).
//
//                  Scancode values                      Comment tag
//   Key Number   Set 1  Set 2  Set 3   Character        for tables
//   ----------   ------ ------ ------  ---------------  -----------
//    94 (0x5E)    0x7C   0x68   0x68   NumPad 0           *94
//   107 (0x6B)    0x7E   0x6D   0x7B   Nul                *107
//
// See also ..\..\host\src\nt_keycd.c and
//          ..\..\..\dos\v86\cmd\keyb\keybi9c.asm
//
// The changes I made to the tables in this file are tagged on the relevant
// lines by comments (*56), (*94) and/or (*107) as appropriate.
//                                                                - IanJa.

#endif  /* NTVDM */



#define NUM_LOCK_ADD_ARRAY 127
#define L_SHIFT_ADD_ARRAY 128
#define R_SHIFT_ADD_ARRAY 129
#define CASE_4_SHIFTED_ARRAY 130
#define ALT_CASE_4_ARRAY 131
#define CASE_5_CTRLED_ARRAY 132

#define NUM_LOCK_ADD 7
#define L_SHIFT_ADD 8
#define R_SHIFT_ADD 9
#define CASE_4_SHIFTED 10
#define ALT_CASE_4 11
#define CASE_5_CTRLED 12

#define KEYBOARD_INT_ADAPTER 0
#define KEYBOARD_INT_LINE 1
#define BASE_DELAY_UNIT 5
#define DEFAULT_REPEAT_TARGET 1

#define SET_3_KEY_TYPE_SET_SEQUENCE 1
#define SET_STATUS_INDICATORS_SEQUENCE 2
#define SET_RATE_DELAY_SEQUENCE 3
#define SCAN_CODE_CHANGE_SEQUENCE 4

#define WRITE_8042_CMD_BYTE_SEQUENCE 1
#define WRITE_8042_OUTPUT_PORT_SEQUENCE 2

#define KEY_DOWN_EVENT 1
#define KEY_UP_EVENT 2

#if defined(NEC_98)
#define DEFAULT_SCAN_CODE_SET 1
#else    //NEC_98
#define DEFAULT_SCAN_CODE_SET 2
#endif   //NEC_98

#ifdef REAL_KBD
extern void send_to_real_kbd();
extern void wait_for_ack_from_kb();
#endif

/*
 * Globally available function pointers
 */
GLOBAL VOID ( *host_key_down_fn_ptr )();
GLOBAL VOID ( *host_key_up_fn_ptr )();

#ifndef NTVDM
GLOBAL VOID ( *do_key_repeats_fn_ptr )();
#endif  /* NTVDM */



#if defined(KOREA)
extern BOOL bIgnoreExtraKbdDisable; // To fix HaNa spread sheet IME hot key problem
#endif

/*
 * 6805 code buffer:
 *
 * This is a cyclic buffer storing key events that have been accepted from
 * the host operating system, but not yet requested by the keyboard BIOS.
 *
 * It is equivalent to a 16 byte buffer present in the real keyboard hardware
 * on the PC-AT.
 *
 * We make the physical size of the buffer BUFF_6805_PMAX a power of 2
 * so that a mask BUFF_6805_PMASK can be used to wrap array indices quickly.
 *
 * Each character entered at the keyboard results in at least 3 bytes of
 * event data in the keyboard buffer. Thus the PC-AT's 16 byte buffer allows
 * at most 5 characters to be typed ahead. In practice this is never used
 * as the CPU is always active, allowing character data to be moved almost
 * immediately to the BIOS type ahead buffer.
 *
 * On SoftPC, however, the CPU can become inactive for significant periods;
 * at the same time, the keyboard hardware emulation may be forced to
 * process a large number of keyboard events from the host operating system.
 *
 * In order to give a constant amount of type ahead, regardless of where the
 * type ahead information is stored in SoftPC, we make the virtual size
 * of the hardware buffer BUFF_6805_VMAX 48 bytes long (16 characters X
 * 3 bytes of event data per character).
 */

/*
   18.5.92 MG !!! TEMPORARY HACK !!! To fix windows bugs in Notepad and Word,
   set the buffer to 2k. Windows crashes when the keyboard buffer overflows,
   so we delay this for as long as sensible. It will still crash if you type
   too fast for too long.

   It works OK on a real PC, so the real reason it fails on SoftPC needs to
   be determined one day.

   20.5.92 MG - took out the hack - see below.
*/

#ifdef NTVDM    /* JonLe NT Mod */
#define BUFF_6805_VMAX  496
#define BUFF_6805_PMAX  512
#define BUFF_6805_PMASK (BUFF_6805_PMAX - 1)
#else
#define BUFF_6805_VMAX  48
#define BUFF_6805_PMAX  64
#define BUFF_6805_PMASK (BUFF_6805_PMAX - 1)
#endif  /* NTVDM */

#ifndef macintosh
static half_word buff_6805[BUFF_6805_PMAX];
#else
static half_word *buff_6805=NULL;
#endif /* macintosh */
static int buff_6805_in_ptr,buff_6805_out_ptr;

#ifdef NTVDM
static unsigned char key_marker_value = 0;
static unsigned char key_marker_buffer[BUFF_6805_PMAX];
int LastKeyDown= -1;
void Reset6805and8042(void);
#endif

#if defined(IRET_HOOKS) && defined(GISP_CPU)
extern IBOOL HostDelayKbdInt IPT1(char, scancode);
extern IBOOL HostPendingKbdInt IPT1(char *,scancode);
extern void HostResetKdbInts IPT0();

#endif /* IRET_HOOKS && GISP_CPU */

/*
   20.5.92 MG

   Real fix for my temporary hack in the last edition of this file.

   The problem with windows seems to be due to receipt of a huge
   number of overrun characters in a row, so now when we send an overrun
   character we set an 'overrun enable' flag, which is cleared when
   three bytes have been read from the buffer.

   The effect of this is to spread out the overruns, which seems to stop
   the illegal instructions occuring.

   Obviously this may have bad effects on real-mode DOS applications !!!
*/

LOCAL   BOOL    sent_overrun=FALSE;

#ifndef macintosh

#ifndef REAL_KBD
#if defined(NEC_98)
/* make arrays */
static int *make_sizes;
static half_word *make_arrays [144];

/* break arrays */
static int *break_sizes;
static half_word *break_arrays [144];
/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */
static half_word set_3_key_state [144];
#else   //NEC_98
/* make arrays */
static int *make_sizes;
static half_word *make_arrays [134];

/* break arrays */
static int *break_sizes;
static half_word *break_arrays [134];

/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */

static half_word set_3_key_state [127];
#endif    //NEC_98
#endif  /* REAL_KBD */

#if defined(NEC_98)
static int key_down_count [144];
static int key_down_dmy  [144];
       int reset_flag;
static int nt_NEC98_caps_state = 0;
static int nt_NEC98_kana_state = 0;
#else   //NEC_98
static int key_down_count [127];
#endif  //NEC_98

#else   /* macintosh */
/* make arrays */
static int *make_sizes;
static half_word **make_arrays;

/* break arrays */
static int *break_sizes;
static half_word **break_arrays;

/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */

static half_word *set_3_key_state;
static int *key_down_count;

#endif  /* macintosh */

/* anomalous state handling variables */
half_word *anomalous_array;
int anomalous_size, anom_key;
int in_anomalous_state;

/* held events (while doing multiple code 6805 commands) */
#define HELD_EVENT_MAX  16
int held_event_count;
int held_event_key[HELD_EVENT_MAX];
int held_event_type[HELD_EVENT_MAX];

#ifdef NTVDM    /* JonLe NTVDM Mod:remove repeat related vars */
int scan_code_6805_size;
half_word key_set;
int input_port_val;
int waiting_for_next_code, waiting_for_next_8042_code, num_lock_on;
#else
int scan_code_6805_size,repeat_delay_target,repeat_target,repeat_delay_count,repeat_count;
half_word key_set;
int typematic_key, input_port_val;
int typematic_key_valid,waiting_for_next_code, waiting_for_next_8042_code, num_lock_on;
#endif  /* NTVDM */
int shift_on, l_shift_on, r_shift_on;
int ctrl_on, l_ctrl_on, r_ctrl_on;
int alt_on, l_alt_on, r_alt_on;
int waiting_for_upcode;
int next_code_sequence_number, next_8042_code_sequence_number, set_3_key_type_change_dest;
GLOBAL int free_6805_buff_size; /* Must be global for NT VDM */
int translating, keyboard_disabled, int_enabled, output_full;
int pending_8042, keyboard_interface_disabled, scanning_discontinued;
half_word output_contents, pending_8042_value, kbd_status, op_port_remembered_bits, cmd_byte_8042;
half_word *scan_code_6805_array;

#ifdef PM
int gate_a20_status;
#ifndef NTVDM
long reset_was_by_kbd = FALSE;
#endif
#endif

#ifndef NTVDM
LOCAL q_ev_handle       refillDelayedHandle = 0;
#endif

half_word current_light_pattern;

#ifdef macintosh
/*
** The Mac cannot cope with loads of global data. So declare these
** as pointers and load the tables up from a Mac resource.
*/
half_word *scan_codes_temp_area;
half_word *keytypes;
int       *set_1_make_sizes, *set_2_make_sizes, *set_3_make_sizes;
int       *set_1_break_sizes, *set_2_break_sizes, *set_3_break_sizes;
half_word *trans_8042, *set_3_reverse_lookup, *set_3_default_key_state, *most_set_2_make_codes;
half_word *most_set_3_make_codes, *set_1_extra_codes, *set_2_extra_codes, *set_3_extra_codes;
half_word *set_1_extra_bk_codes, *set_2_extra_bk_codes, *set_3_extra_bk_codes, *buff_overrun_6805;
half_word *most_set_1_make_codes;

#else

half_word scan_codes_temp_area[300];

#ifndef REAL_KBD
/* Data Tables */

#if defined(NEC_98)
static half_word keytypes[144] =
{ 0,0,0,0,0,0,0,0,0,0,  /* 0-9 */
  0,0,0,0,0,0,0,0,0,0,  /* 10-19 */
  0,0,0,0,0,0,0,0,0,0,  /* 20-29 */
  0,0,0,0,0,0,0,0,0,0,  /* 30-39 */
  0,0,0,0,0,0,0,0,0,0,  /* 40-49 */
  0,0,0,0,0,0,0,0,0,0,  /* 50-59 */
  0,0,0,0,0,0,0,0,0,0,  /* 60-69 */
  0,0,0,0,0,0,0,0,0,0,  /* 70-79 */
  0,0,0,0,0,0,0,0,0,0,  /* 80-89 */
  0,0,0,0,0,0,0,0,0,0,  /* 90-99 */
  0,0,0,0,0,0,0,0,0,0,  /* 100-109 */
  0,0,0,0,0,0,0,0,0,0,  /* 110-119 */
  0,0,0,0,0,0,0,0,0,0,  /* 120-129 */
  0,0,0,0,0,0,0,0,0,0,  /* 130-139 */
  0,0,0,0               /* 140-143 */
};

static int set_1_make_sizes [13]=
{ 1,1,1,1,1,1,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  1,                    /* Num lock add size */
  1,                    /* Left shift add size */
  1,                    /* Right shift add size */
  1,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  1                     /* Case 5 ctrled size */
};

#else   //NEC_98
/*
 * The meaning of the keytype values as far as I can tell (IanJa) :
 *
 *   1 = extended key (rh Alt, rh Ctrl, Numpad Enter)
 *   2 = grey cursor movement keys (Insert, Home, Delete, up arrow etc.
 *   3 = NumPad /
 *   4 = Print Screen/SysRq
 *   5 = pause/Break
 *   6 = not a key
 */
static half_word keytypes[127] =
{ 0,0,0,0,0,0,0,0,0,0,  /* 0-9 */
  0,0,0,0,6,0,0,0,0,0,  /* 10-19 */
  0,0,0,0,0,0,0,0,0,0,  /* 20-29 */
  0,0,0,0,0,0,0,0,0,0,  /* 30-39 */
  0,0,0,0,0,0,0,0,0,0,  /* 40-49 */
#ifdef  JAPAN
  0,0,0,0,0,0,0,0,0,0,  /* 50-59 */
  0,0,1,6,1,0,0,0,0,0,  /* 60-69 */
#else // !JAPAN
  0,0,0,0,0,0,0,0,0,6,  /* 50-59 (*56) */
  0,0,1,6,1,6,6,6,6,6,  /* 60-69 */
#endif // !JAPAN
  6,6,6,6,6,2,2,6,6,2,  /* 70-79 */
  2,2,6,2,2,2,2,6,6,2,  /* 80-89 */
  0,0,0,0,0,3,0,0,0,0,  /* 90-99 (*94) */
  0,0,0,0,0,0,0,0,1,6,  /* 100-109 (*107) */
  0,6,0,0,0,0,0,0,0,0,  /* 110-119 */
  0,0,0,0,4,0,5         /* 120-126 */
};

static int set_1_make_sizes [13]=
{ 1,2,2,2,4,6,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  2,                    /* Num lock add size */
  2,                    /* Left shift add size */
  2,                    /* Right shift add size */
  2,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  4                     /* Case 5 ctrled size */
};
#endif   //NEC_98

static int set_2_make_sizes [13]=
{ 1,2,2,2,4,8,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  2,                    /* Num lock add size */
  3,                    /* Left shift add size */
  3,                    /* Right shift add size */
  2,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  5                     /* Case 5 ctrled size */
};

static int set_3_make_sizes [13]=
{ 1,1,1,1,1,1,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  0,                    /* Num lock add size */
  0,                    /* Left shift add size */
  0,                    /* Right shift add size */
  1,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  1                     /* Case 5 ctrled size */
};

#if defined(NEC_98)

static int set_1_break_sizes [13]=
{ 1,1,1,1,1,1,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  1,                    /* Num lock add size */
  1,                    /* Left shift add size */
  1,                    /* Right shift add size */
  1,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  1                     /* Case 5 ctrled size */
};

#else    //NEC_98
static int set_1_break_sizes [13]=
{ 1,2,2,2,4,0,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  2,                    /* Num lock add size */
  2,                    /* Left shift add size */
  2,                    /* Right shift add size */
  2,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  0                     /* Case 5 ctrled size */
};
#endif    //NEC_98

static int set_2_break_sizes [13]=
{ 2,3,3,3,6,0,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  3,                    /* Num lock add size */
  2,                    /* Left shift add size */
  2,                    /* Right shift add size */
  3,                    /* Case 4 shifted size */
  2,                    /* Alt Case 4 size */
  0                     /* Case 5 ctrled size */
};

static int set_3_break_sizes [13]=
{ 2,2,2,2,2,0,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  0,                    /* Num lock add size */
  0,                    /* Left shift add size */
  0,                    /* Right shift add size */
  2,                    /* Case 4 shifted size */
  2,                    /* Alt Case 4 size */
  2                     /* Case 5 ctrled size */
};

#endif

/*
 * Map Scancode Set 2 into Scancode Set 1 values: index into this table with
 * a scancode set 2 to get the corresponding scancode set 1 value.
 * Non-existent Set 2 scancodes have entry == Set 2 value (trans_8042[x] == x)
 */
static half_word trans_8042 [256] =
{ 0xff,0x43,0x02,0x3f,0x3d,0x3b,0x3c,0x58,0x64,0x44,0x42,0x40,0x3e,0x0f,0x29,0x59,              /* 00-0f */
  0x65,0x38,0x2a,0x70,0x1d,0x10,0x02,0x5A,0x66,0x71,0x2c,0x1f,0x1e,0x11,0x03,0x5b,              /* 10-1f */
  0x20,0x2e,0x2d,0x20,0x12,0x05,0x04,0x5c,0x68,0x39,0x2f,0x21,0x14,0x13,0x06,0x5d,              /* 20-2f */
  0x69,0x31,0x30,0x23,0x22,0x15,0x07,0x5e,0x6a,0x72,0x32,0x24,0x16,0x08,0x09,0x5f,              /* 30-3f */
  0x6b,0x33,0x25,0x17,0x18,0x0b,0x0a,0x60,0x6c,0x34,0x35,0x26,0x27,0x19,0x0c,0x61,              /* 40-4f */
  0x6d,0x73,0x28,0x74,0x1a,0x0d,0x62,0x6e,0x3a,0x36,0x1c,0x1b,0x75,0x2b,0x6e,0x76,              /* 50-5f */
  0x55,0x56,0x77,0x78,0x79,0x7a,0x0e,0x7b,0x7c,0x4f,0x7d,0x4b,0x47,0x7e,0x7f,0x6f,              /* 60-6f */
  0x52,0x53,0x50,0x4c,0x4d,0x48,0x01,0x45,0x57,0x4e,0x51,0x4a,0x37,0x49,0x46,0x54,              /* 70-7f */
  0x80,0x81,0x82,0x41,0x54,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,              /* 80-8f */
#ifdef  JAPAN
  0x7d,0x5a,0x5b,0x73,0x70,0x79,0x7b,0x77,0x71,0x72,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,              /* 90-9f */
#else // !JAPAN
  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,              /* 90-9f */
#endif // !JAPAN
  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,              /* a0-af */
  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,              /* b0-bf */
  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,              /* c0-cf */
  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,              /* d0-df */
  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,              /* e0-ef */
  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff               /* f0-ff */
};

#ifndef REAL_KBD
/*
 * Index with Scancode Set 3 to get keyboard position number.
 */
static half_word set_3_reverse_lookup [256]=
{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x6e,0x00,0x00,0x00,0x00,0x10,0x01,0x71,              /* 00-0f */
  0x00,0x3a,0x2c,0x2d,0x1e,0x11,0x02,0x72,0x00,0x3c,0x2e,0x20,0x1f,0x12,0x03,0x73,              /* 10-1f */
  0x00,0x30,0x2f,0x21,0x13,0x05,0x04,0x74,0x00,0x3d,0x31,0x22,0x15,0x14,0x06,0x75,              /* 20-2f */
  0x00,0x33,0x32,0x24,0x23,0x16,0x07,0x76,0x00,0x3e,0x34,0x25,0x17,0x08,0x09,0x77,              /* 30-3f */
  0x00,0x35,0x26,0x18,0x19,0x0b,0x0a,0x78,0x00,0x36,0x37,0x27,0x28,0x1a,0x0c,0x79,              /* 40-4f */
  0x00,0x38,0x29,0x2a,0x1b,0x0d,0x7a,0x7c,0x40,0x39,0x2b,0x1c,0x1d,0x00,0x7b,0x7d,              /* 50-5f (*56) */
  0x54,0x4f,0x7e,0x53,0x4c,0x51,0x0f,0x4b,0x5e,0x5d,0x59,0x5c,0x5b,0x56,0x50,0x55,              /* 60-6f (*94) */
  0x63,0x68,0x62,0x61,0x66,0x60,0x5a,0x5f,0x00,0x6c,0x67,0x6b,0x6a,0x65,0x64,0x00,              /* 70-7f (*107) */
  0x00,0x00,0x00,0x00,0x69,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* 80-8f */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* 90-9f */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* a0-af */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* b0-bf */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* c0-cf */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* d0-df */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              /* e0-ef */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00               /* f0-ff */
};

/*
 * index by key number to get default key state:
 *   0 = not a key, 1 = typematic,  2 = make/break,  3 = make only
 */
static half_word set_3_default_key_state [127]=
{ 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,              /* 00-0f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x01,              /* 10-1f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x01,0x01,0x01,              /* 20-2f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x00,0x02,0x01,0x03,0x00,              /* 30-3f (*56) */
  0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01,0x00,0x00,0x01,              /* 40-4f */
  0x03,0x03,0x00,0x01,0x01,0x03,0x03,0x00,0x00,0x01,0x03,0x03,0x03,0x03,0x03,0x03,              /* 50-5f */
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x01,0x01,0x03,0x00,0x03,0x00,              /* 60-6f (*107) */
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03                         /* 70-7d */
};

/*
 * Index by key number, to get scancode set 1 (0 if none)
 */
#if defined(NEC_98)

static half_word most_set_1_make_codes [144]=
{ 0xFF,0x1A,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x26,0x00,0x0E,    /* 00-0f */
  0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1B,0x28,0x00,0x71,0x1D,    /* 10-1f */
  0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x27,0x0C,0x0D,0x1C,0x70,0xFF,0x29,0x2A,    /* 20-2f */
#if 1                                             // for 106 keyboard 950407
  0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0xFF,0x70,0x74,0xFF,0x73,0x34,0x73,0x74,    /* 30-3f */  //BugFix #108131
  0x73,0xFF,0xFF,0xFF,0xFF,0x72,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x39,0xFF,0xFF,0x3B,    /* 40-4f */
#else                                             // for 106 keyboard 950407
  0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0xFF,0xFF,0x74,0xFF,0x73,0x34,0x35,0xFF,    /* 30-3f */
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x39,0xFF,0xFF,0x3B,    /* 40-4f */
#endif                                            // for 106 keyboard 950407
  0x3E,0x3F,0xFF,0x3A,0x3D,0x37,0x36,0xFF,0xFF,0x3C,0xFF,0x42,0x46,0x4A,0xFF,0x41,    /* 50-5f */
  0x43,0x47,0x4B,0x4E,0x45,0x44,0x48,0x4C,0x50,0x40,0x49,0xFF,0x1C,0xFF,0x00,0xFF,    /* 60-6f */
  0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x52,0x53,0x0D,0xFF,0xFF,0x33,    /* 70-7f */
  0x4D,0x51,0x35,0x4F,0x54,0x55,0x56,0x72,0x61,0x60,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF     /* 80-8f */  //BugFix #108131
};

#else    //NEC_98
static half_word most_set_1_make_codes [127]=
{ 0x00,0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x7d,0x0e,              /* 00-0f */
  0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x2b,0x3a,0x1e,              /* 10-1f */
  0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2b,0x1c,0x2a,0x56,0x2c,0x2d,              /* 20-2f */
  0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x73,0x36,0x1d,0x00,0x38,0x39,0x38,0x00,              /* 30-3f (*56) */
  0x1d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x53,0x00,0x00,0x4b,              /* 40-4f */
  0x47,0x4f,0x00,0x48,0x50,0x49,0x51,0x00,0x00,0x4d,0x45,0x47,0x4b,0x4f,0x7c,0x35,              /* 50-5f */
  0x48,0x4c,0x50,0x52,0x37,0x49,0x4d,0x51,0x53,0x4a,0x4e,0x7e,0x1c,0x00,0x01,0x00,              /* 60-6f (*107) */
  0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x57,0x58,0x00,0x46,0x00                    /* 70-7e */
};
#endif    //NEC_98

static half_word most_set_2_make_codes [127]=
{ 0x00,0x0e,0x16,0x1e,0x26,0x25,0x2e,0x36,0x3d,0x3e,0x46,0x45,0x4e,0x55,0x6a,0x66,              /* 00-0f */
  0x0d,0x15,0x1d,0x24,0x2d,0x2c,0x35,0x3c,0x43,0x44,0x4d,0x54,0x5b,0x5d,0x58,0x1c,              /* 10-1f */
#ifdef  JAPAN
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x5d,0x5a,0x12,0x90,0x1a,0x22,              /* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x93,0x59,0x14,0x97,0x11,0x29,0x11,0x00,              /* 30-3f */
  0x14,0x91,0x92,0x95,0x96,0x94,0x00,0x00,0x00,0x00,0x00,0x70,0x71,0x00,0x00,0x6b,              /* 40-4f */
#else // !JAPAN
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x5d,0x5a,0x12,0x61,0x1a,0x22,              /* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x51,0x59,0x14,0x00,0x11,0x29,0x11,0x00,              /* 30-3f (*56) */
  0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x71,0x00,0x00,0x6b,              /* 40-4f */
#endif // !JAPAN
  0x6c,0x69,0x00,0x75,0x72,0x7d,0x7a,0x00,0x00,0x74,0x77,0x6c,0x6b,0x69,0x68,0x4a,              /* 50-5f */
  0x75,0x73,0x72,0x70,0x7c,0x7d,0x74,0x7a,0x71,0x7b,0x79,0x6d,0x5a,0x00,0x76,0x00,              /* 60-6f (*107) */
  0x05,0x06,0x04,0x0c,0x03,0x0b,0x83,0x0a,0x01,0x09,0x78,0x07,0x00,0x7e,0x00                    /* 70-7e */
};

static half_word most_set_3_make_codes [127]=
{ 0x00,0x0e,0x16,0x1e,0x26,0x25,0x2e,0x36,0x3d,0x3e,0x46,0x45,0x4e,0x55,0x5d,0x66,              /* 00-0f */
  0x0d,0x15,0x1d,0x24,0x2d,0x2c,0x35,0x3c,0x43,0x44,0x4d,0x54,0x5b,0x5c,0x14,0x1c,              /* 10-1f */
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x53,0x5a,0x12,0x13,0x1a,0x22,              /* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x51,0x59,0x11,0x00,0x19,0x29,0x39,0x00,              /* 30-3f (*56) */
  0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x67,0x64,0x00,0x00,0x61,              /* 40-4f */
  0x6e,0x65,0x00,0x63,0x60,0x6f,0x6d,0x00,0x00,0x6a,0x76,0x6c,0x6b,0x69,0x68,0x77,              /* 50-5f */
  0x75,0x73,0x72,0x70,0x7e,0x7d,0x74,0x7a,0x71,0x84,0x7c,0x7b,0x79,0x00,0x08,0x00,              /* 60-6f (*107) */
  0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37,0x3f,0x47,0x4f,0x56,0x5e,0x57,0x5f,0x62                    /* 70-7e */
};

static half_word set_1_extra_codes []=
{ 0xe0,0x2a,0xe0,0x37,                          /* Case 4 norm */
  0xe1,0x1d,0x45,0xe1,0x9d,0xc5,                /* Case 5 norm */
                                                /* Error case -non existant (empty) */
  0xe0,0x2a,                                    /* Num lock add sequence */
  0xe0,0xaa,                                    /* Left shift add sequence */
  0xe0,0xb6,                                    /* Right shift add sequence */
  0xe0,0x37,                                    /* case 4 shifted */
  0x54,                                         /* Alt case 4 */
  0xe0,0x46,0xe0,0xc6                           /* Case 5 ctrled */
};

static half_word set_2_extra_codes []=
{ 0xe0,0x12,0xe0,0x7c,                          /* Case 4 norm */
  0xe1,0x14,0x77,0xe1,0xf0,0x14,0xf0,0x77,      /* Case 5 norm */
                                                /* Error case -non existant (empty) */
  0xe0,0x12,                                    /* Num lock add sequence */
  0xe0,0xf0,0x12,                               /* Left shift add sequence */
  0xe0,0xf0,0x59,                               /* Right shift add sequence */
  0xe0,0x7c,                                    /* case 4 shifted */
  0x84,                                         /* Alt case 4 */
  0xe0,0x7e,0xe0,0xf0,0x7e                      /* Case 5 ctrled */
};


static half_word set_3_extra_codes []=
{ 0x57,                                         /* Case 4 norm */
  0x62,                                         /* Case 5 norm */
                                                /* Error case -non existant (empty) */
                                                /* Num lock add sequence (empty) */
                                                /* Left shift add sequence (empty) */
                                                /* Right shift add sequence (empty) */
  0x57,                                         /* case 4 shifted */
  0x57,                                         /* Alt case 4 */
  0x62                                          /* Case 5 ctrled */
};


static half_word set_1_extra_bk_codes []=
{ 0xe0,0xb7,0xe0,0xaa,                          /* Case 4 norm */
                                                /* Case 5 norm (empty) */
                                                /* Error case -non existant (empty) */
  0xe0,0xaa,                                    /* Num lock add sequence */
  0xe0,0x2a,                                    /* Left shift add sequence */
  0xe0,0x36,                                    /* Right shift add sequence */
  0xe0,0xb7,                                    /* case 4 shifted */
  0xd4,                                         /* Alt case 4 */
                                                /* Case 5 ctrled (empty) */
};

static half_word set_2_extra_bk_codes []=
{ 0xe0,0xf0,0x7c,0xe0,0xf0,0x12,                /* Case 4 norm */
                                                /* Case 5 norm (empty) */
                                                /* Error case -non existant (empty) */
  0xe0,0xf0,0x12,                               /* Num lock add sequence */
  0xe0,0x12,                                    /* Left shift add sequence */
  0xe0,0x59,                                    /* Right shift add sequence */
  0xe0,0xf0,0x7c,                               /* case 4 shifted */
  0xf0,0x84                                     /* Alt case 4 */
                                                /* Case 5 ctrled (empty) */
};


static half_word set_3_extra_bk_codes []=
{ 0xf0,0x57,                                    /* Case 4 norm */
                                                /* Case 5 norm (empty) */
                                                /* Error case -non existant (empty) */
                                                /* Num lock add sequence (empty) */
                                                /* Left shift add sequence (empty) */
                                                /* Right shift add sequence (empty) */
  0xf0,0x57,                                    /* case 4 shifted */
  0xf0,0x57,                                    /* Alt case 4 */
  0xf0,0x62                                     /* Case 5 ctrled */
};
#endif

static half_word buff_overrun_6805 [4]=
{
  0,0xff,0,0
};

#endif /* macintosh */

#ifdef SECURE /* { */
/*
 * This table 'secure_keytab' identifies certain characters which
 * need special treatment by Secure SoftWindows.   The table is
 * indexed by keycodes, as used by the ROM routine for the U.S. English
 * keyboard.   These codes are defined in IBM Personal Computer AT
 * Hardware Technical Reference, Section 5 System BIOS Keyboard
 * Encoding and Usage.
 *
 * Characters requiring special treatment include Ctrl-Alt-DEL,
 * Ctrl-C and the others, including keys which modify the Boot.
 * Such keys require different treatment, but can be grouped into
 * about 4 different ActionClasses.
 * Any key which would generate an undesirable code has the action
 * bit set, along with the ActionClass number.   Additionally the
 * modifier keys are also tracked with this table.
 */

#define SEC_ACTCLASS    0x07
/* Action Classes have to be sequential from 0,
 * as they are used as an index into function
 * tables 'down_class' and 'up_class'
 */
#define SEC_CLASS_0     0x00
#define SEC_CLASS_1     0x01
#define SEC_CLASS_2     0x02
#define SEC_CLASS_3     0x03
#define SEC_CLASS_4     0x04
#define SEC_CLASS_5     0x05
#define SEC_CLASS_6     0x06
#define SEC_CLASS_7     0x07
#define SEC_ACTION      0x08
#define SEC_CTRL_L      0x10
#define SEC_CTRL_R      0x20
#define SEC_ALT_L       0x40
#define SEC_ALT_R       0x80
#define SEC_MOD_MASK    (SEC_CTRL_L|SEC_CTRL_R|SEC_ALT_L|SEC_ALT_R)

LOCAL IU8 secure_keytab [] = {
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0-15 */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 16-31 */
        0,0,0,0,0,0,0,0,0,0,0,0,                /* 32-43 */
        SEC_ACTION|SEC_CLASS_3,                 /* 44(LShft) Boot Modifier. */
        0,0,0,                                  /* 45-47 */
        SEC_ACTION|SEC_CLASS_2,                 /* 48("C") Used with Cntrl. */
        0,0,0,0,0,0,0,0,                        /* 49-56 */
        SEC_ACTION|SEC_CLASS_3,                 /* 57(RShft) Boot Modifier. */
        SEC_CTRL_L,0,SEC_ALT_L,0,               /* 58-61 */
        SEC_ALT_R,0,SEC_CTRL_R,                 /* 62-64 */
        0,0,0,0,0,0,0,0,0,0,0,                  /* 65-75 */
        SEC_ACTION|SEC_CLASS_0,                 /* 76(Delete) */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 77-90 */
        SEC_ACTION|SEC_CLASS_1,                 /* 91(KeyPad 7) */
        SEC_ACTION|SEC_CLASS_1,                 /* 92(KeyPad 4) */
        SEC_ACTION|SEC_CLASS_1,                 /* 93(KeyPad 1) */
        0,0,                                    /* 94-95 */
        SEC_ACTION|SEC_CLASS_1,                 /* 96(KeyPad 8) */
        SEC_ACTION|SEC_CLASS_1,                 /* 97(KeyPad 5) */
        SEC_ACTION|SEC_CLASS_1,                 /* 98(KeyPad 2) */
        SEC_ACTION|SEC_CLASS_1,                 /* 99(KeyPad 0) */
        0,                                      /* 100 */
        SEC_ACTION|SEC_CLASS_1,                 /* 101(KeyPad 9) */
        SEC_ACTION|SEC_CLASS_1,                 /* 102(KeyPad 6) */
        SEC_ACTION|SEC_CLASS_1,                 /* 103(KeyPad 3) */
        SEC_ACTION|SEC_CLASS_0,                 /* 104(KeyPad . DEL) */
        0,0,0,0,0,0,0,                          /* 105-111 */
        SEC_ACTION|SEC_CLASS_3,                 /* 112(F1) */
        SEC_ACTION|SEC_CLASS_3,                 /* 113(F2) */
        SEC_ACTION|SEC_CLASS_3,                 /* 114(F3) */
        SEC_ACTION|SEC_CLASS_3,                 /* 115(F4) */
        SEC_ACTION|SEC_CLASS_3,                 /* 116(F5) */
        SEC_ACTION|SEC_CLASS_3,                 /* 117(F6) */
        SEC_ACTION|SEC_CLASS_3,                 /* 118(F7) */
        SEC_ACTION|SEC_CLASS_3,                 /* 119(F8) */
        SEC_ACTION|SEC_CLASS_3,                 /* 120(F9) */
        SEC_ACTION|SEC_CLASS_3,                 /* 121(F10) */
        SEC_ACTION|SEC_CLASS_3,                 /* 122(F11) */
        SEC_ACTION|SEC_CLASS_3,                 /* 123(F12) */
        0,0,                                    /* 124-125 */
        SEC_ACTION|SEC_CLASS_2,                 /* 126(Break) */
        0                                       /* 127 */
};
#endif /* SECURE } */

LOCAL VOID calc_buff_6805_left IPT0();
LOCAL VOID do_host_key_down IPT1( int,key );
LOCAL VOID do_host_key_up IPT1( int,key );
LOCAL VOID codes_to_translate IPT0();
GLOBAL VOID continue_output IPT0();
LOCAL VOID cmd_to_8042 IPT1( half_word,cmd_code );
LOCAL VOID cmd_to_6805 IPT1( half_word,cmd_code );
#ifndef HUNTER
LOCAL INT buffer_status_8042 IPT0();
#endif

#ifdef SECURE /* { */
/* Track the Modifier keys. */
LOCAL IU8 keys_down = 0;

/* Track which key downs have been supressed. */
LOCAL IU8 keys_suppressed [0x80] = {0};

/* Forward declarations keep compiler happy. */
LOCAL VOID filtered_host_key_down IPT1(int,key);
LOCAL VOID filtered_host_key_up IPT1(int,key);

/* Here are the functions for handling special keys. */
LOCAL VOID filt_dwn_reboot IFN1(int, key)
{
        /* The key is only nasty if Cntrl and Alt are down. */
        if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) != 0 &&
            (keys_down & (SEC_ALT_L  | SEC_ALT_R )) != 0 )
        {
                keys_suppressed[key] = 1;
        }
        else
        {
                filtered_host_key_down(key);
        }
}
LOCAL VOID filt_dwn_kpad_numerics IFN1(int, key)
{
        /* The keys are only nasty if Alt is down. */
        if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) == 0 &&
            (keys_down & (SEC_ALT_L  | SEC_ALT_R )) != 0 )
        {
                keys_suppressed[key] = 1;
        }
        else
        {
                filtered_host_key_down(key);
        }
}
LOCAL VOID filt_dwn_breaks IFN1(int, key)
{
        /*
         * The keys are only nasty if Control is down.
         * The upness of the Alt key is not checked as the
         * typematic feature would allow ALT-CTRL-C to be held
         * down, then ALT could be released to deliver a stream
         * of CTRL-C.
         */
        if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) != 0)
        {
                keys_suppressed[key] = 1;
        }
        else
        {
                filtered_host_key_down(key);
        }
}
LOCAL VOID filt_dwn_boot_mods IFN1(int, key)
{
        /* The keys are only nasty if in Boot mode. */
        if (!has_boot_finished())
        {
                keys_suppressed[key] = 1;
        }
        else
        {
                filtered_host_key_down(key);
        }
}
LOCAL VOID filt_dwn_supress_up IFN1(int, key)
{
        if (keys_suppressed[key])
        {
                /* Key down was suppressed, do not forward key-up. */
                keys_suppressed[key] = 0;
        }
        else
        {
                filtered_host_key_up(key);
        }
}

/*
 * The following function table is indexed by the Action Class,
 * as defined in secure_keytab[].
 */
LOCAL VOID (*down_class[]) IPT1(int, key) = {
        filt_dwn_reboot,
        filt_dwn_kpad_numerics,
        filt_dwn_breaks,
        filt_dwn_boot_mods,
        filtered_host_key_down,
        filtered_host_key_down,
        filtered_host_key_down,
        filtered_host_key_down
};
LOCAL VOID (*up_class[]) IPT1(int, key) = {
        filt_dwn_supress_up,
        filt_dwn_supress_up,
        filt_dwn_supress_up,
        filt_dwn_supress_up,
        filtered_host_key_up,
        filtered_host_key_up,
        filtered_host_key_up,
        filtered_host_key_up
};
#endif /* SECURE } */

/*
 * 6805 code buffer access procedures
 */

/*(
=============================== keyba_running ==================================
PURPOSE:
        This access function is used to by other modules to check whether
keyba.c is currently passing on keyboard events, or whether it is buffering
them.  This allows calling functions to avoid filling up keyba's buffers.

INPUT:
None.

OUTPUT:
The return value is true if keystrokes are being passed on.

ALGORITHM:
If the scanning_discontinued flag is set, or if the 6905 buffer is not
empty, FALSE is returned.
================================================================================
)*/
GLOBAL BOOL
keyba_running IFN0()
{
        if (scanning_discontinued || (buff_6805_in_ptr != buff_6805_out_ptr))
                return(FALSE);
        else
                return(TRUE);
}

#define QUEUED_OUTPUT    0
#define IMMEDIATE_OUTPUT 1

LOCAL VOID add_to_6805_buff IFN2(half_word,code,int, immediate)
/* immediate --->   = 0 queue on buffer end,
                    = 1 queue on buffer start */
        {
   /* iff room in buffer */
   if (((buff_6805_out_ptr -1)& BUFF_6805_PMASK) != buff_6805_in_ptr)
      {
      if ( immediate )
         {
         /* queue at start */
         buff_6805_out_ptr = (buff_6805_out_ptr - 1) & BUFF_6805_PMASK;
         buff_6805[buff_6805_out_ptr]=code;
         }
      else
         {
         /* queue at end */
        buff_6805[buff_6805_in_ptr]=code;
        buff_6805_in_ptr = (buff_6805_in_ptr + 1) & BUFF_6805_PMASK;
        }
      }
   calc_buff_6805_left();

#ifdef NTVDM    /* JonLe NTVDM Mod */
   KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;
#endif  /* NTVDM */

   } /* end of add_to_6805_buff */

static half_word remove_from_6805_buff IFN0()
{
half_word ch;

ch=buff_6805[buff_6805_out_ptr];

#ifdef NTVDM
        key_marker_buffer[buff_6805_out_ptr]=0;
#endif

if (buff_6805_out_ptr != buff_6805_in_ptr)
        {
        buff_6805_out_ptr = (buff_6805_out_ptr +1) & BUFF_6805_PMASK;
        }
calc_buff_6805_left();

#ifdef NTVDM
   KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;
#endif  /* NTVDM */

return (ch);
} /* end of remove_from_6805_buff */


LOCAL VOID clear_buff_6805 IFN0()
{
        /* 18/5/92 MG On a macintosh, allocate buffer space so that we're
           not grabbing it from the global allocation. */

#ifdef macintosh
        if (buff_6805==NULL) {
                check_malloc(buff_6805,BUFF_6805_PMAX,half_word);
        }
#endif /* macintosh */

        buff_6805_in_ptr=buff_6805_out_ptr;
        free_6805_buff_size=BUFF_6805_VMAX;

#ifdef NTVDM
    KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;

    /* Clear key marker buffer */
    {
        register int loop = sizeof(key_marker_buffer) / sizeof(unsigned char);
        while(--loop >= 0) key_marker_buffer[loop] = 0;
    }
#endif  /* NTVDM */
}

#ifdef NTVDM

#define ONECHARCODEMASK (0x80)

LOCAL VOID mark_key_codes_6805_buff IFN1(int, start)
{
   static int start_offset;

   /* Room in buffer */
   if(((buff_6805_out_ptr -1)& BUFF_6805_PMASK) != buff_6805_in_ptr)
   {

        /* Bump key start/end marker is start of seq */
        if(start)
        {
            start_offset = buff_6805_in_ptr;
#if defined(NEC_98)
            if(++key_marker_value > 144) key_marker_value = 1;
#else    //NEC_98
            if(++key_marker_value > 127) key_marker_value = 1;
#endif   //NEC_98
        }
        else
        {
            /* End of seq, mark first & last byte */

            if(start_offset != buff_6805_in_ptr)
            {

                key_marker_buffer[start_offset] = key_marker_value;

                if(((buff_6805_in_ptr -1)& BUFF_6805_PMASK) == start_offset)
                {
                key_marker_buffer[(buff_6805_in_ptr -1)& BUFF_6805_PMASK] =
                                  key_marker_value | ONECHARCODEMASK;
                }
                else
                {
                /* mult byte seq */

                key_marker_buffer[(buff_6805_in_ptr -1)& BUFF_6805_PMASK] =
                                  key_marker_value;
                }
            }
        }
   }
}

/*
 * This function returns the number of keys in the 6805 buffers
 * and also clears down these buffers
 */

GLOBAL int keys_in_6805_buff(int *part_key_transferred)
{
    int keys_in_buffer = held_event_count;  /* key to yet processed by adapter */
    int tmp_6805_out_ptr;
    char last_marker = 0;

    *part_key_transferred = FALSE;

    for(tmp_6805_out_ptr = buff_6805_out_ptr;
        tmp_6805_out_ptr != buff_6805_in_ptr;
        tmp_6805_out_ptr = (tmp_6805_out_ptr +1) & BUFF_6805_PMASK)
    {
        if(key_marker_buffer[tmp_6805_out_ptr] != 0)
        {
            if(last_marker == 0)
            {
                /* start of key seq found */
                if(key_marker_buffer[tmp_6805_out_ptr] & ONECHARCODEMASK)
                    keys_in_buffer++; /* one byte seq       else */
                    last_marker = key_marker_buffer[tmp_6805_out_ptr];
            }
            else
            {
                if(key_marker_buffer[tmp_6805_out_ptr] == last_marker)
                {
                    keys_in_buffer++;/* End of key seq found, bump key count */
                    last_marker = 0; /* no longer in middle of key seq */
                }
                else
                {
                    /* Scan terminate early, part key seq found */
                    *part_key_transferred = TRUE;
                    last_marker = key_marker_buffer[tmp_6805_out_ptr];
                }
            }
        }
    }

    /* Terminated scan in middle of key seq ??? */
    if(last_marker) *part_key_transferred = TRUE;


    /* Is there currently a key in the one char 8042 buffer */
    if(output_full)
    {
        keys_in_buffer++;
    }

    Reset6805and8042();

    return(keys_in_buffer);
}

void Reset6805and8042(void)
{
    int key;

    /* Reset 6805 */

    buff_6805_out_ptr=0;
    clear_buff_6805();
    current_light_pattern=0;

    //Removed, function call attempts to push characters back into
    //the keyboard adapter, just as we are trying to reset it.
    //This problem could be fixed by clearing the keyboard interrupt
    //line after the following function call (DAB)
    //host_kb_light_on(7);

#if defined(NEC_98)
    for(key = 0; key < 144; key++)
    {
        set_3_key_state [key] = most_set_1_make_codes[key];
        key_down_dmy[key] = key_down_count[key];
    }
#else    //NEC_98
    for(key = 0; key < 127; key++)
    {
        set_3_key_state [key] = set_3_default_key_state[key];
        key_down_count[key]=0;
    }
#endif  //NEC_98

    waiting_for_next_code=waiting_for_next_8042_code=FALSE;

    shift_on = l_shift_on = r_shift_on = FALSE;
    ctrl_on = l_ctrl_on = r_ctrl_on = FALSE;
    alt_on = l_alt_on = r_alt_on = FALSE;
    waiting_for_upcode = FALSE;

    /* Reset 8042 */

#if defined(NEC_98)
    kbd_status = 0x85;
#else    //NEC_98
    kbd_status = 0x14;
#endif   //NEC_98
    cmd_byte_8042 = 0x45;
    keyboard_disabled = keyboard_interface_disabled = FALSE;
    op_port_remembered_bits = 0xc;

    pending_8042 = output_full = in_anomalous_state = FALSE;
#if defined(NEC_98)
    int_enabled = TRUE;
    translating = FALSE;
#else    //NEC_98
    int_enabled = translating = TRUE;
#endif   //NEC_98
    scanning_discontinued = FALSE;
    held_event_count = 0;

    //Removed by (DAB)
    //host_kb_light_off (5);
    num_lock_on = TRUE;
}

#endif /* NTVDM */

LOCAL VOID calc_buff_6805_left IFN0()
{
free_6805_buff_size = BUFF_6805_VMAX-((buff_6805_in_ptr - buff_6805_out_ptr) & BUFF_6805_PMASK);
if (free_6805_buff_size<0)
        {
        free_6805_buff_size=0;
        sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer full");
        }
} /* end of calc_buff_6805_left */

LOCAL VOID add_codes_to_6805_buff IFN2(int,codes_size,half_word *,codes_buff)
{
int code_index;

if (free_6805_buff_size < codes_size)
        {

/* 20.5.92 MG Don't send the overrun if we only just sent one */

        if (!sent_overrun)
                add_to_6805_buff(buff_overrun_6805[key_set], QUEUED_OUTPUT);
        sent_overrun=TRUE;
        sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
        }
else
        {

/* If some characters have been read out, clear the sent_overrun flag */

        if (free_6805_buff_size>(codes_size+3))
                sent_overrun=FALSE;
        for (code_index=0;code_index<codes_size;code_index++) {
                add_to_6805_buff(codes_buff[code_index], QUEUED_OUTPUT);
                }
        }
} /* end of add_codes_to_6805_buff */


#ifndef REAL_KBD
/* initialisation code */

LOCAL VOID init_key_arrays IFN0()
{
int key;
half_word *next_free, *extra_ptr, *extra_bk_ptr;
#ifdef  JAPAN
int    ntvdm_keytype;
static half_word ax_kanji_key=0x98;
static half_word ax_kana_key =0x99;
#endif // JAPAN

sure_note_trace1(AT_KBD_VERBOSE,"Keyboard key set initialisation: key set %d",key_set);
next_free = scan_codes_temp_area;
switch (key_set)
        {
        case 1:
                make_sizes=set_1_make_sizes;
                break_sizes=set_1_break_sizes;
#if defined(NEC_98)
                for (key=0;key<144;key++) //127-->144
#else   //NEC_98
                for (key=0;key<127;key++)
#endif  //NEC_98
                        {
                        switch (keytypes[key])
                                {
                                case 0:
                                        make_arrays[key]= &(most_set_1_make_codes[key]);
                                        break_arrays[key]=next_free;
                                        *next_free++=(most_set_1_make_codes[key])^0x80;
                                        break;
                                case 1:
                                case 2:
                                case 3:
                                        make_arrays[key]=next_free;
                                        *next_free++ = 0xe0;
                                        *next_free++ = most_set_1_make_codes[key];
                                        break_arrays[key]=next_free;
                                        *next_free++ = 0xe0;
                                        *next_free++ = (most_set_1_make_codes[key]) ^ 0x80;
                                        break;
                                }
                        }
                extra_ptr=set_1_extra_codes;
                extra_bk_ptr=set_1_extra_bk_codes;
                break;
        case 2:
#ifndef NEC_98
#ifdef  JAPAN
                ntvdm_keytype=GetKeyboardType(0);
                if (ntvdm_keytype==7){
                        ntvdm_keytype = GetKeyboardType(1);
                }
                else    ntvdm_keytype = 0;
#endif // JAPAN
#endif    //NEC_98
                make_sizes=set_2_make_sizes;
                break_sizes=set_2_break_sizes;
                for (key=0;key<127;key++)
                        {
#ifndef NEC_98
#ifdef  JAPAN
/*
        AX keyboard KANJI and KANA key setting
        1993.4.6 T.Murakami
*/
                        if(key==62){                                    /* Right ALT */
                                // if((ntvdm_keytype & 0xff00)==0x0100  /* AX keyboard */
                                // ||  ntvdm_keytype==0x0702){          /* 002 keyboard */
                                // keyboard subtype value was changed
                                if(ntvdm_keytype==0x0001                /* AX keyboard */
                                || ntvdm_keytype==0x0003                /* 002 keyboard */
                                || (ntvdm_keytype&0xff00)==0x1200       /* TOSHIBA J3100 keyboard */
                                ){
                                        make_arrays[key]= &ax_kanji_key;
                                        break_arrays[key]=next_free;
                                        *next_free++ = 0xf0;
                                        *next_free++ = ax_kanji_key;
                                        keytypes[key]=0;
                                        continue;
                                }
                                else    keytypes[key]=1;
                        }
                        if(key==64){                                    /* Right CTRL */
                                // if((ntvdm_keytype & 0xff00)==0x0100){        /* AX keyboard */
                                // keyboard subtype value was changed
                                if(ntvdm_keytype==0x0001                /* AX keyboard */
                                || (ntvdm_keytype&0xff00)==0x1200       /* TOSHIBA J3100 keyboard */
                                ){
                                        make_arrays[key]= &ax_kana_key;
                                        break_arrays[key]=next_free;
                                        *next_free++ = 0xf0;
                                        *next_free++ = ax_kana_key;
                                        keytypes[key]=0;
                                        continue;
                                }
                                else    keytypes[key]=1;
                        }
#endif // JAPAN
#endif    //NEC_98
                        switch (keytypes[key])
                                {
                                case 0:
                                        make_arrays[key]= &(most_set_2_make_codes[key]);
                                        break_arrays[key]=next_free;
                                        *next_free++ = 0xf0;
                                        *next_free++ = most_set_2_make_codes[key];
                                        break;
                                case 1:
                                case 2:
                                case 3:
                                        make_arrays[key]=next_free;
                                        *next_free++ = 0xe0;
                                        *next_free++ = most_set_2_make_codes[key];
                                        break_arrays[key]=next_free;
                                        *next_free++ = 0xe0;
                                        *next_free++ = 0xf0;
                                        *next_free++ = most_set_2_make_codes[key];
                                        break;
                                }
                        }
                extra_ptr=set_2_extra_codes;
                extra_bk_ptr=set_2_extra_bk_codes;
                break;
        case 3:
                make_sizes=set_3_make_sizes;
                break_sizes=set_3_break_sizes;
                for (key=0;key<127;key++)
                        {
                        if (keytypes[key] != 6)
                                {
                                make_arrays[key]= &(most_set_3_make_codes[key]);
                                break_arrays[key]=next_free;
                                *next_free++ = 0xf0;
                                *next_free++ = most_set_3_make_codes[key];
                                }
                        }
                extra_ptr=set_3_extra_codes;
                extra_bk_ptr=set_3_extra_bk_codes;
                break;
        } /* end of switch */

#ifndef NEC_98
        make_arrays[124]=extra_ptr;
        extra_ptr+=make_sizes[4];
        make_arrays[126]=extra_ptr;
        extra_ptr+=make_sizes[5];
        extra_ptr+=make_sizes[6];
        make_arrays[NUM_LOCK_ADD_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[7];
        make_arrays[L_SHIFT_ADD_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[8];
        make_arrays[R_SHIFT_ADD_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[9];
        make_arrays[CASE_4_SHIFTED_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[10];
        make_arrays[ALT_CASE_4_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[11];
        make_arrays[CASE_5_CTRLED_ARRAY]=extra_ptr;
        extra_ptr+=make_sizes[12];

        break_arrays[124]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[4];
        break_arrays[126]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[5];
        extra_bk_ptr+=break_sizes[6];
        break_arrays[NUM_LOCK_ADD_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[7];
        break_arrays[L_SHIFT_ADD_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[8];
        break_arrays[R_SHIFT_ADD_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[9];
        break_arrays[CASE_4_SHIFTED_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[10];
        break_arrays[ALT_CASE_4_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[11];
        break_arrays[CASE_5_CTRLED_ARRAY]=extra_bk_ptr;
        extra_bk_ptr+=break_sizes[12];
#endif   //NEC_98
} /* end of init_key_arrays () */


/* Key pressed on host keyboard */

GLOBAL VOID host_key_down IFN1(int,key)
#ifdef SECURE /* { */
{
        IU8 keytab_entry;
        /* Make a note of any modifier bits. */
        keytab_entry = secure_keytab[key];
        keys_down |= keytab_entry;
        /* If any filtering action is required, go do it. */
        if (config_inquire(C_SECURE, NULL) && (keytab_entry & SEC_ACTION) != 0)
        {
                /* The key may need filtering. */
                (*down_class[keytab_entry & SEC_ACTCLASS])(key);
        }
        else
        {
                filtered_host_key_down(key);
        }
}

LOCAL VOID filtered_host_key_down IFN1(int,key)
#endif /* SECURE } */
{
if (scanning_discontinued)
        {
        held_event_type[held_event_count]=KEY_DOWN_EVENT;
        held_event_key[held_event_count++]=key;

        /* check for held event buffer overflow (SHOULD never happen) */
        if (held_event_count >= HELD_EVENT_MAX)
                {
                held_event_count = HELD_EVENT_MAX-1;
                always_trace0("host_key_down held event buffer overflow");
                }
        }
#ifdef NTVDM
else if (!keyboard_disabled) {
       //
       // Ignore contiguous repeat keys if keys are still in the 6805
       // this keeps the apps responsive to the corresponding up key
       // when it comes.
       //
       if (LastKeyDown != key || (KbdHdwFull < 8)) {
           LastKeyDown = key;
           key_down_count[key]++;
           do_host_key_down(key);
           }
    }
#else
else
        {
        do_host_key_down(key);
        }
#endif
}

GLOBAL VOID host_key_up IFN1(int,key)
#ifdef SECURE /* { */
{
        IU8 keytab_entry;
        /* Make a note of any modifier bits. */
        keytab_entry = secure_keytab[key];
        keys_down &= SEC_MOD_MASK ^ keytab_entry;
        /* If any filtering action is required, go do it. */
        if (config_inquire(C_SECURE, NULL) && (keytab_entry & SEC_ACTION) != 0)
        {
                /* The key may need filtering. */
                (*up_class[keytab_entry & SEC_ACTCLASS])(key);
        }
        else
        {
                filtered_host_key_up(key);
        }
}

LOCAL VOID filtered_host_key_up IFN1(int,key)
#endif /* SECURE } */
{
if (scanning_discontinued)
        {
        held_event_type[held_event_count]=KEY_UP_EVENT;
        held_event_key[held_event_count++]=key;

        /* check for held event buffer overflow (SHOULD never happen) */
        if (held_event_count >= HELD_EVENT_MAX)
                {
                held_event_count = HELD_EVENT_MAX-1;
                always_trace0("host_key_up held event buffer overflow");
                }
        }
#ifdef NTVDM
else if (!keyboard_disabled && key_down_count[key]) {
#else
else
        {
#endif
#ifdef NTVDM
       LastKeyDown = -1;
#endif
        do_host_key_up(key);
        }
}

#ifdef NTVDM
GLOBAL VOID RaiseAllDownKeys(VOID)
{
   int i;

   i = sizeof(key_down_count)/sizeof(int);
   while (i--) {
       if (key_down_count[i]) {
           host_key_up(i);
           }
       }
}

GLOBAL int IsKeyDown(int Key)
{
   return  key_down_count[Key];
}


#endif /* NTVDM */

LOCAL VOID do_host_key_down IFN1(int,key)
{
int overrun,keytype;

sure_note_trace1(AT_KBD_VERBOSE,"key down:%d",key);

if (!keyboard_disabled)
        {

#ifdef NTVDM
                mark_key_codes_6805_buff(TRUE);
#else
        key_down_count[key]++;
        if (key_down_count[key]==1)
                {       /* first press */
                repeat_delay_count=0;
                repeat_count=0;
                typematic_key_valid=FALSE;

#endif  /* NTVDM */
                keytype=keytypes[key];
                overrun=FALSE;
                if (in_anomalous_state)
                        {
                        if (anomalous_size > free_6805_buff_size)
                                { overrun=TRUE; }
                        else
                                {
                                scan_code_6805_size = anomalous_size;
                                scan_code_6805_array = anomalous_array;
                                add_codes_to_6805_buff(anomalous_size,anomalous_array);
                                in_anomalous_state=FALSE;
                                }
                        }

                switch (keytype)
                        {
                        case 0:
                        case 1:
                        case 6:
                            scan_code_6805_size=make_sizes[keytype];
                            scan_code_6805_array=make_arrays[key];
                            break;
                        case 2:
                            if (num_lock_on && !shift_on)
                                    {
                                    scan_code_6805_size=make_sizes[NUM_LOCK_ADD];
                                    scan_code_6805_array=make_arrays[NUM_LOCK_ADD_ARRAY];
                                    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
                                            { overrun=TRUE; }
                                    else
                                        {
                                        in_anomalous_state=TRUE;
                                        anom_key=key;
                                        anomalous_array=break_arrays[NUM_LOCK_ADD_ARRAY];
                                        anomalous_size=break_sizes[NUM_LOCK_ADD];
                                        add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                        }
                                    }
                            if (!num_lock_on && shift_on)
                                    {
                                    if (l_shift_on)
                                            {
                                            scan_code_6805_size=make_sizes[L_SHIFT_ADD];
                                            scan_code_6805_array=make_arrays[L_SHIFT_ADD_ARRAY];
                                        in_anomalous_state=TRUE;
                                        anom_key=key;
                                        anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
                                        anomalous_size=break_sizes[L_SHIFT_ADD];
                                            }
                                    else
                                            {
                                            scan_code_6805_size=make_sizes[R_SHIFT_ADD];
                                            scan_code_6805_array=make_arrays[R_SHIFT_ADD_ARRAY];
                                        in_anomalous_state=TRUE;
                                        anom_key=key;
                                        anomalous_array=break_arrays[R_SHIFT_ADD_ARRAY];
                                        anomalous_size=break_sizes[R_SHIFT_ADD];
                                            }
                                    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
                                            {
                                            overrun=TRUE;
                                            in_anomalous_state=FALSE;
                                            }
                                    else
                                            {
                                            add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                            }
                                    }
                            scan_code_6805_size=make_sizes[keytype];
                            scan_code_6805_array=make_arrays[key];
                            break;
                        case 3:
                            if (shift_on)
                                    {
                                    if (l_shift_on)
                                            {
                                            scan_code_6805_size=make_sizes[L_SHIFT_ADD];
                                            scan_code_6805_array=make_arrays[L_SHIFT_ADD_ARRAY];
                                        in_anomalous_state=TRUE;
                                        anom_key=key;
                                        anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
                                        anomalous_size=break_sizes[L_SHIFT_ADD];
                                            }
                                    else
                                            {
                                            scan_code_6805_size=make_sizes[R_SHIFT_ADD];
                                            scan_code_6805_array=make_arrays[R_SHIFT_ADD_ARRAY];
                                        in_anomalous_state=TRUE;
                                        anom_key=key;
                                        anomalous_array=break_arrays[R_SHIFT_ADD_ARRAY];
                                        anomalous_size=break_sizes[R_SHIFT_ADD];
                                            }
                                    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
                                            {
                                            overrun=TRUE;
                                            in_anomalous_state=FALSE;
                                            }
                                    else
                                            {
                                            add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                            }
                                    }
                            scan_code_6805_size=make_sizes[keytype];
                            scan_code_6805_array=make_arrays[key];
                            break;
                        case 4:
                            if (shift_on || ctrl_on || alt_on)
                                    {
                                    if (shift_on || ctrl_on)
                                            {
                                            scan_code_6805_size=make_sizes[CASE_4_SHIFTED];
                                            scan_code_6805_array=make_arrays[CASE_4_SHIFTED_ARRAY];
                                            }
                                    else
                                            {
                                            scan_code_6805_size=make_sizes[ALT_CASE_4];
                                            scan_code_6805_array=make_arrays[ALT_CASE_4_ARRAY];
                                            }
                                    }
                            else
                                    {
                                        in_anomalous_state=TRUE;
                                        anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
                                        anomalous_size=break_sizes[L_SHIFT_ADD];
                                        anom_key=key;
                                    scan_code_6805_size=make_sizes[keytype];
                                    scan_code_6805_array=make_arrays[key];
                                    }
                            break;
                        case 5:
                            if (ctrl_on)
                                    {
                                    scan_code_6805_size=make_sizes[CASE_5_CTRLED];
                                    scan_code_6805_array=make_arrays[CASE_5_CTRLED_ARRAY];
                                    }
                            else
                                    {
                                    scan_code_6805_size=make_sizes[keytype];
                                    scan_code_6805_array=make_arrays[key];
                                    }
                            break;
                            } /* end of switch */
                if (overrun)
                        {
                        if (!sent_overrun)
                                add_to_6805_buff(buff_overrun_6805[key_set],
                                        QUEUED_OUTPUT);
                        sent_overrun=TRUE;

                        sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
                        }
                else
                        {
                        add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                        }
                switch (key)
                    {
                    case 44:
                            l_shift_on =TRUE;
                            shift_on = TRUE;
                            break;
                    case 57:
                            r_shift_on = TRUE;
                            shift_on = TRUE;
                            break;
                    case 58:
                            l_ctrl_on =TRUE;
                            ctrl_on = TRUE;
                            break;
                    case 64:
                            r_ctrl_on = TRUE;
                            ctrl_on = TRUE;
                            break;
                    case 60:
                            l_alt_on =TRUE;
                            alt_on = TRUE;
                            break;
                    case 62:
                            r_alt_on =TRUE;
                            alt_on = TRUE;
                            break;
                    case 90:
                            num_lock_on = !num_lock_on;
                            break;
                    }

#ifndef NTVDM   /* JonLe NTVDM Mod */

#if defined(NEC_98)
//add key!=90(Numlock)KANA
               if ((key!=126)&&(key!=90)) {
#else     //NEC_98
                if (key!=126)
#endif    //NEC_98
                    {
                    if ((key_set != 3) || (set_3_key_state[key] == 1) || (set_3_key_state[key] == 4))
                            {
                            typematic_key = key;
                            typematic_key_valid = TRUE;
                            }
                    }
#else
                mark_key_codes_6805_buff(FALSE);
#endif  /* NTVDM */

                if (free_6805_buff_size < BUFF_6805_VMAX)
                    {
                    codes_to_translate();
                    }

#ifndef NTVDM
                } /* end of if first press */
#endif  /* NTVDM */

        } /* end of if not disabled */
} /* end of do_host_key_down */


/* Key released on host keyboard */
LOCAL VOID do_host_key_up IFN1(int,key)
{
half_word *temp_arr_array;
int temp_arr_size,keytype,overrun;

sure_note_trace1(AT_KBD_VERBOSE,"key up:%d",key);

if (!keyboard_disabled)
        {
#ifdef DEMO_COPY
        host_check_demo_expire ();
#endif
        if( key_down_count[key] == 0){
                /*
                ** This will ignore extra key ups.
                */
#ifndef PROD
                sure_note_trace1( AT_KBD_VERBOSE, "Ignored extra key up:%d", key );
#endif
        }
        else
        {
                key_down_count[key] =  0;

#ifndef NTVDM   /* JonLe NTVDM Mod */
                if ((key==typematic_key) && typematic_key_valid)
                        {
                        typematic_key_valid=FALSE;
                        }
#endif  /* NTVDM */

                keytype=keytypes[key];
                overrun=FALSE;
                if (!(key_set ==3) || (set_3_key_state[key]==2) || (set_3_key_state[key]==4))
                        {
#ifdef NTVDM
                        mark_key_codes_6805_buff(TRUE);
#endif
                        switch (keytype)
                                {
                                case 0:
                                case 1:
                                case 6:
                                        scan_code_6805_size=break_sizes[keytype];
                                        scan_code_6805_array=break_arrays[key];
                                        break;
                                case 2:
                                        temp_arr_size=0;
                                        temp_arr_array=(half_word *) -1;
                                        if (in_anomalous_state && (anom_key == key))
                                                {
                                                in_anomalous_state=FALSE;
                                                if (num_lock_on && !shift_on)
                                                        {
                                                        temp_arr_size=break_sizes[NUM_LOCK_ADD];
                                                        temp_arr_array=break_arrays[NUM_LOCK_ADD_ARRAY];
                                                        }
                                                if (!num_lock_on && shift_on)
                                                        {
                                                        if (l_shift_on)
                                                                {
                                                                temp_arr_size=break_sizes[L_SHIFT_ADD];
                                                                temp_arr_array=break_arrays[L_SHIFT_ADD_ARRAY];
                                                                }
                                                        else
                                                                {
                                                                temp_arr_size=break_sizes[R_SHIFT_ADD];
                                                                temp_arr_array=break_arrays[R_SHIFT_ADD_ARRAY];
                                                                }
                                                        }
                                                }
                                        scan_code_6805_size=break_sizes[keytype];
                                        scan_code_6805_array=break_arrays[key];
                                        if (scan_code_6805_size+temp_arr_size > free_6805_buff_size)
                                                { overrun=TRUE; }
                                        else
                                                {
                                                add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                                }
                                        scan_code_6805_size=temp_arr_size;
                                        scan_code_6805_array=temp_arr_array;
                                        break;

                                case 3:
                                        temp_arr_size=0;
                                        temp_arr_array=(half_word *) -1;
                                        if (in_anomalous_state && (anom_key == key))
                                                {
                                                in_anomalous_state = FALSE;
                                                if (shift_on)
                                                        {
                                                        if (l_shift_on)
                                                                {
                                                                temp_arr_size=break_sizes[L_SHIFT_ADD];
                                                                temp_arr_array=break_arrays[L_SHIFT_ADD_ARRAY];
                                                                }
                                                        else
                                                                {
                                                                temp_arr_size=break_sizes[R_SHIFT_ADD];
                                                                temp_arr_array=break_arrays[R_SHIFT_ADD_ARRAY];
                                                                }
                                                        }
                                                }
                                        scan_code_6805_size=break_sizes[keytype];
                                        scan_code_6805_array=break_arrays[key];
                                        if (scan_code_6805_size+temp_arr_size > free_6805_buff_size)
                                                { overrun=TRUE; }
                                        else
                                                {
                                                add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                                }
                                        scan_code_6805_size=temp_arr_size;
                                        scan_code_6805_array=temp_arr_array;
                                        break;

                                case 4:
                                        if (shift_on || ctrl_on || alt_on)
                                                {
                                                if (shift_on || ctrl_on)
                                                        {
                                                        scan_code_6805_size=break_sizes[CASE_4_SHIFTED];
                                                        scan_code_6805_array=break_arrays[CASE_4_SHIFTED_ARRAY];
                                                        }
                                                else
                                                        {
                                                        scan_code_6805_size=break_sizes[ALT_CASE_4];
                                                        scan_code_6805_array=break_arrays[ALT_CASE_4_ARRAY];
                                                        }
                                                }
                                        else
                                                {
                                                if (in_anomalous_state && (anom_key==key))
                                                        {
                                                        in_anomalous_state=FALSE;
                                                        scan_code_6805_size=break_sizes[keytype];
                                                        scan_code_6805_array=break_arrays[key];
                                                        }
                                                else
                                                        {
                                                        scan_code_6805_size=break_sizes[CASE_4_SHIFTED];
                                                        scan_code_6805_array=break_arrays[CASE_4_SHIFTED_ARRAY];
                                                        }
                                                }
                                        break;
                                case 5:
                                        scan_code_6805_size=0;
                                        break;
                                } /* end of switch */
                        if (overrun)
                                {
                                if (!sent_overrun)
                                        add_to_6805_buff(buff_overrun_6805[key_set], QUEUED_OUTPUT);
                                sent_overrun=TRUE;

                                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
                                }
                        else
                                {
                                add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                                }
#ifdef NTVDM
                        mark_key_codes_6805_buff(FALSE);
#endif
                        } /* end of if not set 3 etc. */
                switch (key)
                        {
                        case 44:
                                l_shift_on =FALSE;
                                if (!r_shift_on) { shift_on = FALSE; }
                                break;
                        case 57:
                                r_shift_on = FALSE;
                                if (!l_shift_on) { shift_on = FALSE; }
                                break;
                        case 58:
                                l_ctrl_on =FALSE;
                                if (!r_ctrl_on) { ctrl_on = FALSE; }
                                break;
                        case 64:
                                r_ctrl_on = FALSE;
                                if (!l_ctrl_on) { ctrl_on = FALSE; }
                                break;
                        case 60:
                                l_alt_on =FALSE;
                                if (!r_alt_on) { alt_on = FALSE; }
                                break;
                        case 62:
                                r_alt_on =FALSE;
                                if (!l_alt_on) { alt_on = FALSE; }
                                break;
                        } /* end of switch */

                if (free_6805_buff_size < BUFF_6805_VMAX)
                        {
                        codes_to_translate();
                        }
                } /* end of if last release */
        } /* end of if not disabled */
} /* end of do_host_key_up */
#endif /* REAL_KBD */

#ifdef NTVDM
        /*
         *  force filling of Kbd data port just like the real kbd
         *  since we no longer clear output_full in the Kbd_inb routine
         */
LOCAL VOID AddTo6805BuffImm IFN1(half_word,code)
{
  add_to_6805_buff(code,IMMEDIATE_OUTPUT);
  output_full = FALSE;
  KbdData = -1;
}
#else
#define  AddTo6805BuffImm(code) add_to_6805_buff(code, IMMEDIATE_OUTPUT);
#endif

LOCAL VOID cmd_to_6805 IFN1(half_word,cmd_code)
{
int i,key_to_change;
half_word change_to;
unsigned int cmd_code_temp; /* Mac MPW3 compiler prefers unsigned ints in switches */

sure_note_trace1(AT_KBD_VERBOSE,"6805 received cmd:0x%x",cmd_code);

#ifndef REAL_KBD

if (waiting_for_next_code)
        {
        switch (next_code_sequence_number)
                {
                case SCAN_CODE_CHANGE_SEQUENCE:
                        if (cmd_code>3 || cmd_code <0)
                                { AddTo6805BuffImm(RESEND_CODE); }
                        else
                                {
                                 if (cmd_code == 0)
                                        {
                                        /* order of reception of scan codes is reverse their order of insertion
                                         * if 'IMMEDIATE_OUTPUT' method of insertion is used
                                         */
                                         AddTo6805BuffImm(key_set);
                                         AddTo6805BuffImm(ACK_CODE);
                                        }
                                 else
                                        {
                                         AddTo6805BuffImm(ACK_CODE);
#ifndef NEC_98
                                         key_set=cmd_code;
                                         init_key_arrays();
#endif   //NEC_98
                                        }
                                }
                        break;
                case SET_3_KEY_TYPE_SET_SEQUENCE:
                        sure_note_trace2(AT_KBD_VERBOSE,"Keyboard key type change: key 0x%x, new type %d",cmd_code,set_3_key_type_change_dest);
                        AddTo6805BuffImm(ACK_CODE);
                        key_to_change=set_3_reverse_lookup[cmd_code];
                        set_3_key_state[key_to_change]=(half_word)set_3_key_type_change_dest;
                        break;
                case SET_STATUS_INDICATORS_SEQUENCE:
                        if ((cmd_code & 0xf8) == 0)
                        {
                        sure_note_trace1(AT_KBD_VERBOSE,"Changing kbd lights to :%x",cmd_code);
                        AddTo6805BuffImm(ACK_CODE);
#ifdef NTVDM
                        host_kb_light_on ((IU8)((cmd_code & 0x07) | 0xf0));
#else
                        cmd_code &= 0x7;
                        host_kb_light_on (cmd_code);
                        host_kb_light_off ((~cmd_code)&0x7);
#endif
                        }
                        break;
                case SET_RATE_DELAY_SEQUENCE:
#ifndef NTVDM   /* JonLe Mod */
                        if ((cmd_code & 0x80)==0)
                        {
                        repeat_delay_target = (1+((cmd_code>>5)&3))*BASE_DELAY_UNIT;
                        cmd_code &= 0x1f;
                        if (cmd_code<0xb) { repeat_target =0; }
                        else { if (cmd_code<0x11) { repeat_target =1; }
                        else { if (cmd_code<0x19) { repeat_target=(cmd_code-0x12)/3 +3;}
                        else { if (cmd_code<0x1e) { repeat_target=(cmd_code-0x1a)/2+6;}
                        else { repeat_target=(cmd_code-0x1e)+8;}}}}
                        AddTo6805BuffImm(ACK_CODE);
                        }
                        sure_note_trace2(AT_KBD_VERBOSE,"Changing kbd rate/delay: rate = %d, dealy=%d ",repeat_target,repeat_delay_target);

#else   /* NTVDM */

                        if ((cmd_code & 0x80)==0)
                        {
                        AddTo6805BuffImm(ACK_CODE);
                        }

#endif  /* NTVDM */
                        break;
                }
                waiting_for_next_code = FALSE;
        }
        else
        {

#endif /* not REAL_KBD */

        /*
        ** Mac MPW3 compiler does not like bytes sized switch
        ** variables if a case matches on 0xff. It seems to
        ** generate dodgy code. Different type seems OK.
        */
        cmd_code_temp = (unsigned int)cmd_code;
        switch ( cmd_code_temp )
        {
#ifndef REAL_KBD
        case 0xf5:
                /* Default Disable */
                clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);
                for (key_to_change=1;key_to_change<127;key_to_change++)
                        {
                        set_3_key_state[key_to_change]=set_3_default_key_state[key_to_change];
                        }

#ifndef NTVDM   /* JonLe NTVDM Mod */
                repeat_delay_target=2*BASE_DELAY_UNIT;
                repeat_target=DEFAULT_REPEAT_TARGET;
                typematic_key_valid=FALSE;
#endif  /* NTVDM */

                keyboard_disabled=TRUE;
                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard disabled");
                break;
        case 0xee:
                /* echo */
                AddTo6805BuffImm(0xee);
                break;
        case 0xf4:
                /* enable */
                clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM   /* JonLe NTVDM Mod */
                typematic_key_valid=FALSE;
#endif  /* NTVDM */

                keyboard_disabled=FALSE;
                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard enabled");
                break;
#endif
        case 0xf2:
                /* Read ID */
                /* order of reception of scan codes is reverse their order of insertion
                 * if 'IMMEDIATE_OUTPUT' method of insertion is used
                 */
                AddTo6805BuffImm(0x83);
                AddTo6805BuffImm(0xab);
                AddTo6805BuffImm(ACK_CODE);
                break;
        case 0xfe:
                /* resend */
                buff_6805_out_ptr=(buff_6805_out_ptr-1) & BUFF_6805_PMASK;
                calc_buff_6805_left();
                break;
#ifndef REAL_KBD
        case 0xff:
                /* reset */
                /* order of reception of scan codes is reverse their order of insertion
                 * if 'IMMEDIATE_OUTPUT' method of insertion is used
                 */
                AddTo6805BuffImm(BAT_COMPLETION_CODE);
                AddTo6805BuffImm(ACK_CODE);
                keyboard_disabled=FALSE;
                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard reset");
                break;
        case 0xf0:
                /* Select Alternate Scan Codes */
                clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM   /* JonLe NTVDM Mod */
                typematic_key_valid=FALSE;
#endif  /* NTVDM */

                next_code_sequence_number=SCAN_CODE_CHANGE_SEQUENCE;
                held_event_count=0;
                scanning_discontinued = waiting_for_next_code=TRUE;
                break;
        case 0xf7:
        case 0xf8:
        case 0xf9:
        case 0xfa:
                /* Set all keys */
                AddTo6805BuffImm(ACK_CODE);
                change_to=cmd_code - 0xf6;
                for (key_to_change=1;key_to_change<127;key_to_change++)
                        {
                        set_3_key_state[key_to_change]=change_to;
                        }
                sure_note_trace1(AT_KBD_VERBOSE,"All keys set to type :0x%x",change_to);
                break;
        case 0xf6:
                /* Set Default */
                clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);
                for (key_to_change=1;key_to_change<127;key_to_change++)
                        {
                        set_3_key_state[key_to_change]=set_3_default_key_state[key_to_change];
                        }

#ifndef NTVDM   /* JonLe NTVDM Mod */
                repeat_delay_target=2*BASE_DELAY_UNIT;
                repeat_target=DEFAULT_REPEAT_TARGET;
                typematic_key_valid=FALSE;
#endif  /* NTVDM */
                keyboard_disabled=FALSE;
                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard set to default (and enabled)");
                break;
        case 0xfb:
        case 0xfc:
        case 0xfd:
                /* Set key type */
                clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM   /* JonLe NTVDM Mod */
                typematic_key_valid=FALSE;
#endif  /* NTVDM */

                next_code_sequence_number=SET_3_KEY_TYPE_SET_SEQUENCE;
                held_event_count=0;
                scanning_discontinued = waiting_for_next_code=TRUE;
                set_3_key_type_change_dest=cmd_code - 0xfa;
                break;
        case 0xed:
                /* Set/Reset Status Indicators */
                AddTo6805BuffImm(ACK_CODE);
                next_code_sequence_number=SET_STATUS_INDICATORS_SEQUENCE;
                held_event_count=0;
                scanning_discontinued = waiting_for_next_code=TRUE;
                break;
        case 0xf3:
                /* Set typematic Rate/Delay */
                AddTo6805BuffImm(ACK_CODE);
                next_code_sequence_number=SET_RATE_DELAY_SEQUENCE;
                held_event_count=0;
                scanning_discontinued = waiting_for_next_code=TRUE;
                break;
        default :
                /* unrecognised code */
#ifdef  JOKER
                AddTo6805BuffImm(ACK_CODE);
#else   /* JOKER */
                AddTo6805BuffImm(RESEND_CODE);
#endif  /* JOKER */
                break;

#else
        default :
                /* cmd to be sent on to real kbd */
                send_to_real_kbd(cmd_code);
#endif
        } /* end of switch */
#ifndef REAL_KBD
}
#else
        waiting_for_next_code=FALSE;
#endif

#ifndef REAL_KBD
if (scanning_discontinued && !waiting_for_next_code)
        {
        if (held_event_count != 0)
                {
                for (i=0;i<held_event_count;i++)
                        {
                        switch (held_event_type[i])
                                {
                                case KEY_DOWN_EVENT:
                                        do_host_key_down(held_event_key[i]);
                                        break;
                                case KEY_UP_EVENT:
                                        do_host_key_up(held_event_key[i]);
                                        break;
                                }
                        }
                }
        scanning_discontinued=FALSE;
        }
#endif

#ifndef NTVDM
if (free_6805_buff_size < BUFF_6805_VMAX)
        {
        codes_to_translate();
        }
#endif

} /* end of cmd_to_6805 */

/* interface to interrupts */

#ifdef NTVDM    /* JonLe NTVDM Mod */



/* KbdIntDelay
 *
 * UNDER ALL CONDITIONS we must provide a SAFE key rate that 16 bit apps
 * can handle. This must be done without looking at the bios buffer,
 * since not all apps use the bios int 9 handler.
 *
 */

LOCAL VOID KbdIntDelay(VOID)
{


       //
       // Wait until the kbd scancode has been read,
       // before invoking the next interrupt.
       //
   if (bKbdEoiPending)
       return;


   if (int_enabled) {
       bKbdEoiPending = TRUE;

       if (!bForceDelayInts) {
#if defined(NEC_98)
           kbd_status |= 0x02;     //Set Redy bit
#else    //NEC_98
           kbd_status |= 1;
#endif   //NEC_98
           ica_hw_interrupt(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE, 1);
           }
       else {
           ULONG ulDelay = 2000;

           if (bKbdIntHooked) {
               ulDelay += 2000;
               }

           if (KbdHdwFull > 8) {
               ulDelay += 4000;
               }

           if (!bBiosBufferSpace) {
               ulDelay += 4000;
               }

           if (!bPifFastPaste) {
               ulDelay <<= 1;
               }

           bDelayIntPending = TRUE;
           host_DelayHwInterrupt(KEYBOARD_INT_LINE,
                                 1,
                                 ulDelay
                                 );
           }

       HostIdleNoActivity();
       }
}


void UpdateScreen(void);

//This function is called by the ICA with the ica lock
void KbdEOIHook(int IrqLine, int CallCount)
{
   static int ScreenUpdateCount = 0;

   if (!bKbdEoiPending)  // sanity
       return;

   if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))  {
       bKbdEoiPending = FALSE;
       return;
       }

   bKbdIntHooked = KbdInt09Off != *(word *)(Start_of_M_area+0x09*4) ||
                   KbdInt09Seg != *(word *)(Start_of_M_area+0x09*4+2);

   bBiosBufferSpace = bBiosOwnsKbdHdw &&
                      (bios_buffer_size() < (bPifFastPaste ? 8 : 2));

   output_full = FALSE;
   bKbdEoiPending = FALSE;

   bForceDelayInts = TRUE;
   continue_output();
   bForceDelayInts = FALSE;

   if (!bBiosOwnsKbdHdw)
        HostReleaseKbd();

   //
   // We try to update the screen on every 2 interrupts.
   //

   if ((ScreenUpdateCount++ & 1) == 0) {
       UpdateScreen();
   }
}




LOCAL VOID do_q_int(char scancode)
{
   output_full = TRUE;
   output_contents = scancode;

   KbdIntDelay();
}

#else   /* NTVDM */

LOCAL VOID do_int IFN1(long,scancode)
{
        output_contents = (char)scancode;
#if defined(NEC_98)
        kbd_status |= 0x02;     //Set Redy bit
#else    //NEC_98
        kbd_status |= 1;                        /* Character now available! */
#endif   //NEC_98
        if (int_enabled)
        {
                sure_note_trace0(AT_KBD_VERBOSE,"keyboard interrupting");
                ica_hw_interrupt(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE, 1);
        }
}

LOCAL VOID do_q_int IFN1(char,scancode)
{
        output_full = TRUE;

#if defined(IRET_HOOKS) && defined(GISP_CPU)
        if (!HostDelayKbdInt(scancode))
        {       /* no host need to delay this kbd int, so generate one now. */
                do_int ((long) scancode);
        }

#else /* !IRET_HOOKS || !GISP_CPU */

#ifdef DELAYED_INTS
        do_int ((long) scancode);
#else
        add_q_event_i( do_int, HOST_KEYBA_INST_DELAY, (long)scancode);
#endif  /* DELAYED_INTS */

#endif /* IRET_HOOKS && GISP_CPU */
}


/* typematic keyboard repeats */

GLOBAL VOID do_key_repeats IFN0()
{
#ifndef REAL_KBD

#ifdef JOKER
        /* If there are characters available, tell Joker... */
        if (kbd_status & 1)
                do_int((long)output_contents);
#endif

if (typematic_key_valid)
        {
        if (repeat_count==repeat_target && repeat_delay_count==repeat_delay_target)
                {
                scan_code_6805_size=make_sizes[keytypes[typematic_key]];
                scan_code_6805_array=make_arrays[typematic_key];
                add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
                codes_to_translate ();
                repeat_count=0;
                }
        else
                {
                if (repeat_delay_count==repeat_delay_target)
                        {
                        repeat_count++;
                        }
                else
                        {
                        repeat_delay_count++;
                        }
                }
        }
#endif

} /* end of do_key_repeats */

#endif  /* NTVDM */


LOCAL VOID cmd_to_8042  IFN1(half_word,cmd_code)
{
int code_to_send,code_to_send_valid;

#if defined(NEC_98)
half_word cmd_code_NEC98;
int       key;
#endif    //NEC_98

sure_note_trace1(AT_KBD_VERBOSE,"8042 received cmd:0x%x",cmd_code);

code_to_send_valid = FALSE;
#if defined(NEC_98)
cmd_code_NEC98 = cmd_code;

/* ***** KBDE ***** */
        if ( (cmd_code_NEC98 & 0x20) == 0x20 )     // Keyboard Disable(Send) ?
               {
               int_enabled=FALSE;
               keyboard_interface_disabled=TRUE;
               }
        else
               {
               int_enabled=TRUE;
               keyboard_interface_disabled=FALSE;
               }
/* ***** ER ***** */
        if ( (cmd_code_NEC98 & 0x10) == 0x10 )     // Reset ERR Flag ?
            {
            kbd_status &= ~(0x38);              //Reset error flag
            }

/* ***** RxE ***** */
        if ( (cmd_code_NEC98 & 0x04) == 0x00 )     // Keyboard Disable(Recive) ?
               {
//             int_enabled=FALSE;
               keyboard_interface_disabled=TRUE;
               }
        else
               {
//             int_enabled=TRUE;
               keyboard_interface_disabled=FALSE;
               }

/* ***** RST ***** */
//printf("reset command \n");

        if ( (cmd_code_NEC98 & 0x03a) == 0x03a )   // Keyboard Reset on ?
            {
             reset_flag = 1;                    // Reset 0 -> 1
            }
        else                                    // Keyboard Reset off !
            {
            if ( (cmd_code_NEC98 & 0x032) == 0x032 )
                    reset_flag = 2;             // Reset 1 -> 0
            }

        if ( (reset_flag == 2) && (int_enabled==TRUE) && (keyboard_interface_disabled==FALSE))

            {
            //_asm{int 3};
            reset_flag=0;
            Reset6805and8042();

            for(key = 0; key < 144; key++)
                {
                if( key_down_dmy[key] > 0x00 )
                        {
//                      printf(" resend key -> %#x\n", key);
//                      add_to_6805_buff(key, IMMEDIATE_OUTPUT);
                        //KbdWaitRead = FALSE;  //NEC 930910 >>940509
                        host_key_down(key);     //NEC 930910
                        }
                }
            }

/* ***** RTY ***** */
        if ( (cmd_code_NEC98 & 0x02) == 0x00 )     // Retry ?
            {
                buff_6805_out_ptr=(buff_6805_out_ptr-1) & BUFF_6805_PMASK;
                calc_buff_6805_left();
            }
#else    //NEC_98
if (waiting_for_next_8042_code)
        {
        switch (next_8042_code_sequence_number)
                {
                case WRITE_8042_CMD_BYTE_SEQUENCE:
                        if ( (kbd_status & 0x8) == 0)
                                {
                                cmd_byte_8042=cmd_code;
                                if ( (cmd_byte_8042 & 0x40) == 0)
                                        {
                                        translating=FALSE;
                                        }
                                else
                                        {
                                        translating=TRUE;
                                        }
                                if ( (cmd_byte_8042 & 0x20) != 0 || (cmd_byte_8042 & 0x10) != 0)
                                        {
                                        keyboard_interface_disabled=TRUE;
                                        }
                                else
                                        {
                                        keyboard_interface_disabled=FALSE;
                                        }
                                kbd_status &= 0xfb;
                                kbd_status |= cmd_byte_8042 & 0x4;
                                if ((cmd_byte_8042 & 1) == 0)
                                        {
                                        int_enabled=FALSE;
                                        }
                                else
                                        {
                                        int_enabled=TRUE;
                                        }
                                }
                        else
                                {
                                waiting_for_next_8042_code=FALSE;
                                }
                        break;
                case WRITE_8042_OUTPUT_PORT_SEQUENCE:
                        if ( (kbd_status & 0x8) == 0)
                                {
#ifndef JOKER           /* Reset and GateA20 done in hardware for JOKER */
                                if ( (cmd_code & 1) == 0)
                                        {
                                        host_error(EG_CONT_RESET,ERR_QUIT | ERR_RESET,NULL);
                                        }
                                if ( (cmd_code & 2) == 2)
                                        {
#ifdef PM
                                   if ( !gate_a20_status )
                                      {
#ifdef NTVDM
                                      /* call xms function to deal with A20 */
                                      xmsDisableA20Wrapping();
#else
                                      sas_disable_20_bit_wrapping();
#endif /* NTVDM */
                                      gate_a20_status = 1;
                                        }
                                   }
                                else
                                   {
                                   if ( gate_a20_status )
                                      {
#ifdef NTVDM
                                      xmsEnableA20Wrapping();
#else
                                      sas_enable_20_bit_wrapping();
#endif /* NTVDM */
                                      gate_a20_status = 0;
                                      }
#else
                                   host_error(EG_GATE_A20,ERR_QUIT | ERR_RESET | ERR_CONT,NULL);
#endif /* PM */
                                   }
#endif /* JOKER */

                                if ( (cmd_code & 0x10) == 0)
                                        {
                                        int_enabled=FALSE;
                                        }
                                else
                                        {
                                        int_enabled=TRUE;
                                        }
#ifdef PM
                                op_port_remembered_bits=cmd_code & 0x2e;
#else
                                op_port_remembered_bits=cmd_code & 0x2c;
#endif /* PM */
                                }
                        else
                                {
                                waiting_for_next_8042_code=FALSE;
                                }
                        break;
                } /* end of switch */
        }

if (!waiting_for_next_8042_code)
        {
        switch (cmd_code)
                {
                case 0x20:
                        /* Read cmd byte */
                        code_to_send=cmd_byte_8042;
                        code_to_send_valid=TRUE;
                        break;
                case 0x60:
                        /* Write cmd byte */
                        waiting_for_next_8042_code=TRUE;
                        next_8042_code_sequence_number=WRITE_8042_CMD_BYTE_SEQUENCE;
                        break;
                case 0xaa:
                        /* Self Test (always returns 'pass') */
                        code_to_send=0x55;
                        code_to_send_valid=TRUE;
                        break;
                case 0xab:
                        /* Interface Test (always returns 'pass') */
                        code_to_send=0x00;
                        code_to_send_valid=TRUE;
                        break;
                case 0xad:
                        /* Disable keyboard interface */
#if defined(KOREA)
                        // To fix HaNa spread sheet IME hot key problem
                        if( bIgnoreExtraKbdDisable )
                            break;
#endif
                        cmd_byte_8042 |= 0x10;
                        keyboard_interface_disabled=TRUE;
                        break;
                case 0xae:
                        /* Enable keyboard interface */
                        cmd_byte_8042 &= 0xef;
                        if ((cmd_byte_8042 & 0x20) == 0)
                                {
                                keyboard_interface_disabled=FALSE;
                                }
                        break;
                case 0xc0:
                        /* Read Input Port */
                        /* But don't cause an interrupt */
                        code_to_send_valid=TRUE;
                        break;
                case 0xd0:
                        /* Read Output Port */
                        code_to_send=0xc1 + op_port_remembered_bits;
                        code_to_send_valid=TRUE;
                        break;
                case 0xd1:
                        /* Write to Output Port */
                        waiting_for_next_8042_code=TRUE;
                        next_8042_code_sequence_number=WRITE_8042_OUTPUT_PORT_SEQUENCE;
                        break;
                case 0xe0:
                        /* Read Test Input */
                        code_to_send=0x02;
                        code_to_send_valid=TRUE;
                        break;

#ifndef JOKER           /* Reset and GateA20 done in hardware for JOKER */
                case 0xf0:
                case 0xf1:
                case 0xf2:
                case 0xf3:
                case 0xf4:
                case 0xf5:
                case 0xf6:
                case 0xf7:
                case 0xf8:
                case 0xf9:
                case 0xfa:
                case 0xfb:
                case 0xfc:
                case 0xfd:
                case 0xfe:
                case 0xff:

#ifndef MONITOR
/*
 *  For reasons which I don't understand the monitor never
 *  did emulate the cpu_interrupt - HW_RESET in pr 1.0.
 *  and still doesn't in 1.0a. although maybe it should
 *  do something. Note this is required for 286 style pm.
 *  06-Dec-1993 Jonle
 *
 */

                        /* Pulse Output Port bits */

                        if ((cmd_code & 1) == 0)
                                {
                                /* pulse the reset line */
#ifdef PM
#ifndef NTVDM
                                reset_was_by_kbd = TRUE;
#endif
#ifdef CPU_30_STYLE
                                cpu_interrupt(CPU_HW_RESET, 0);
#else /* CPU_30_STYLE */
                                cpu_interrupt_map |= CPU_RESET_EXCEPTION_MASK;
                                host_cpu_interrupt();
#endif /* CPU_30_STYLE */
#endif
                                sure_note_trace0(AT_KBD_VERBOSE,"CPU RESET via keyboard");
                                }
#endif /* ! MONITOR */
                        break;
#endif /* JOKER */

                } /* end of switch */
        }
else
        {
        waiting_for_next_8042_code=FALSE;
        }

#endif    //NEC_98

/*Is there a valid code to put in the 8042 output buffer? Values written
  to the 8042 output buffer as a conseqence of a 8042 command do not
        generate an interrupt. Output generated by 8042 commands must be presented to
        the application at the next INB, failure to do so it likely to result in the
  8042 being placed in an unusable state. */

if (code_to_send_valid)
        {
#ifdef NTVDM
        /*
         *  force filling of Kbd data port just like the real kbd
         *  since we no longer clear output_full in the Kbd_inb routine
         */
        output_full = FALSE;
        KbdData = -1;
#else /* NTVDM else */

        /* Transfer 8042 command output to output buffer, overwriting value
           already in the buffer. */

                output_contents = (char)code_to_send;
                kbd_status |= 1;                        /* Character now available! */

#endif /* end of NTVDM else */
        }

} /* end of cmd_to_8042 */




LOCAL half_word translate_6805_8042 IFN0()
{

half_word first_code,code;

/* performs the translation on scan codes which is done by the
   8042 keyboard controller in a real XT286 */

first_code=remove_from_6805_buff();

if (translating)
        {
        sure_note_trace1(AT_KBD_VERBOSE,"translating code %#x",first_code);
        if (first_code==0xf0)
                {
                if (free_6805_buff_size<BUFF_6805_VMAX) {
                        code=remove_from_6805_buff();
                        sure_note_trace1(AT_KBD_VERBOSE,"translating code %#x",code);
                        if ((code != 0xfa) && (code != 0xfe)) {
                                code=trans_8042[code]+0x80;
                        }
                        else {
                                waiting_for_upcode=TRUE;
                        }
                        sure_note_trace1(AT_KBD_VERBOSE,"translated to %#x",code);
                        waiting_for_upcode=FALSE;
                        }
                else {
                        waiting_for_upcode=TRUE;
                        }
                }
        else
                {
                code=trans_8042[first_code];
                if (waiting_for_upcode) {
                        if ((code !=0xfa) &&(code != 0xfe)){
                                code+=0x80;
                                waiting_for_upcode=FALSE;
                        }
                }
                sure_note_trace1(AT_KBD_VERBOSE,"translated to %#x",code);
                }
        }
else
        {
        code=first_code;
        }
return (code);
} /* end of translate_6805_8042 */

#ifdef HUNTER
/*
** Put a scan code into the 8042 single char buffer.
** Called from do_hunter() in hunter.c
*/

#define HUNTER_REJECTED_CODES_LIMIT 100

int hunter_codes_to_translate IFN1( half_word, scan_code )
{
        LOCAL ULONG rejected_scan_codes = 0;

        sure_note_trace1(HUNTER_VERBOSE,"Requesting scan=%d",scan_code);

        if (!pending_8042 && !keyboard_interface_disabled && !output_full)
        {
                do_q_int(scan_code);
                sure_note_trace1( HUNTER_VERBOSE, "Accepted scan=%d", scan_code );

                rejected_scan_codes = 0;

                return( TRUE );
        }
        else
        {
                sure_note_trace0( HUNTER_VERBOSE, "Rejected scan" );

                if( rejected_scan_codes++ > HUNTER_REJECTED_CODES_LIMIT )
                {
                        printf( "Application hung up - not reading scan codes\n" );
                        printf( "Trapper terminating\n" );

                        terminate();
                }

                return( FALSE );
        }
} /* end of hunter_codes_to_translate() */

#endif /* HUNTER */

/*
** Returns number of chars in buffer.
** As buffer is quite small there can either be 1 char or none in it.
*  This needs to be global for HUNTER, but only needs be local otherwise.
*/
#ifdef HUNTER
GLOBAL INT
#else
LOCAL INT
#endif
buffer_status_8042 IFN0()
{
        if (!pending_8042 && !keyboard_interface_disabled && !output_full)
                return( 0 );
        else
                return( 1 );
} /* END 8042_buffer_status() */

LOCAL VOID codes_to_translate  IFN0()
{
        char tempscan;

while (!pending_8042 && (free_6805_buff_size < BUFF_6805_VMAX) && !keyboard_interface_disabled && !output_full)
        {
                tempscan= translate_6805_8042();
                if (!waiting_for_upcode) {
                        do_q_int(tempscan);
                }
        }
} /* end of codes_to_translate */

/* Thanks to Jonathan Lew of MS for code tidyup in this fn */
GLOBAL VOID continue_output IFN0()
{
char tempscan;

#ifdef NTVDM
if (bKbdEoiPending || keyboard_interface_disabled) {
    return;
    }
#endif

if(!output_full)
        {
        if (pending_8042)
                {
                pending_8042=FALSE;
                do_q_int(pending_8042_value);
                }
        else
                {
                if ((free_6805_buff_size < BUFF_6805_VMAX) && (!keyboard_interface_disabled))
                        {
                        tempscan=translate_6805_8042();
                        if (!waiting_for_upcode) {
                                do_q_int(tempscan);
                                }
                        }
                }
        }
#ifdef NTVDM
else
    KbdIntDelay();
#endif

} /* end of continuous_output */


#ifdef NTVDM

/*  NT port:
 *  the host (nt_event.c) calls this to notify that
 *  it is resuming after blocking, to do any reinitialization
 *  necessary
 *
 *  - resets kbd flow regulators
 */
GLOBAL VOID KbdResume(VOID)
{
    WaitKbdHdw(0xffffffff);
    bKbdEoiPending = FALSE;
    bKbdIntHooked = FALSE;
    bBiosBufferSpace = TRUE;
    if (!keyboard_interface_disabled && output_full)
        KbdIntDelay();
    HostReleaseKbd();
}
#endif  /* NTVDM */


#ifndef NTVDM
/* allowRefill -- used in conjunction with the Delayed Quick Event
** below (kbd_inb from port 0x60 while the keyboard interface is
** enabled.) This is called 10ms after a dubious read from port 0x60
** and allows the port to be overwritten with the next scancode.
*/

LOCAL VOID allowRefill IFN1(long, unusedParam)
{
        UNUSED(unusedParam);

        /* Clear "refillDelayedHandle" so we know we're all clear... */

        refillDelayedHandle = 0;

        /* continue with filling the buffer... */
        continue_output();
}
#endif

GLOBAL VOID kbd_inb IFN2(io_addr,port,half_word *,val)
{
        sure_note_trace1(AT_KBD_VERBOSE,"kbd_inb(%#x)...", port);

#ifdef NTVDM    /* JonLe NTVDM Mod */

     if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))  {
         return;
         }


     if (!(DelayIrqLine & 0x2) || KbdData == -1) {
         if (bDelayIntPending) {
             bDelayIntPending = FALSE;
             kbd_status |= 1;
             }
         KbdData = output_contents;

         }
#endif

#if defined(NEC_98)
port &= KEYBD_STATUS_CMD;

    if (port==KEYBD_STATUS_CMD)
        {
        *val=kbd_status;
        }
    else
#else    //NEC_98
        port &= 0x64;

        if (port==0x64)
        {
                *val = kbd_status;
        }
        else                                                                    /* port == 0x60 */
#endif    //NEC_98

#ifdef NTVDM    /* JonLe NTVDM Mod */

        {

        *val=KbdData;
#if defined(NEC_98)
        kbd_status &= 0xfd;
#else    //NEC_98
        kbd_status &= 0xfe;
#endif   //NEC_98
        sure_note_trace1(AT_KBD_VERBOSE,"scan code read:0x%x",*val);


            // Sloppy keyboard fix is not needed for the NT port. An EOI
        // hook is used to control priming of the adapter.

        }

     if (!bBiosOwnsKbdHdw)
         HostReleaseKbd();

#else   /* not NTVDM */

        {
                *val=output_contents;

                output_full = FALSE;

#if defined(NEC_98)
                kbd_status &= 0xfd;
#else    //NEC_98
                kbd_status &= 0xfe;             /* Mask out "char avail" bit */
#endif   //NEC_98

                /* Other ports should really clear this IRQ as well, but... */

#ifdef JOKER
                ica_clear_int(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE);
#endif  /* JOKER */

                /* <tur 06-Jul-93> BCN 2040 Replace previous horrible hack with a better one!
                **
                ** The following is to cope with programs that read this port more than once
                ** expecting the same value each time, while the keyboard interface is ENABLED.
                ** On a real PC, this port is filled via a serial connection, and so there's at
                ** least a few milliseconds before a new char arrives and the port is overwritten.
                ** SoftPC, however, doesn't have this delay; ideally, we'd like to
                ** refill the buffer immediately. However, if the keyboard interface is
                ** enabled, we should delay refilling the buffer for a few ms.
                */

                if (keyboard_interface_disabled) {              /* We're in business */

                        /* NB: We have always assumed that anyone reading this port with the
                        ** Keyboard interface disabled will ONLY READ IT ONCE (like the BIOS.)
                        **
                        ** Since this seems to work, let's just go ahead and refill the buffer.
                        ** (If any problems show up, we'll just have to do a quick event as in
                        ** the keyboard interface enabled case below.)
                        */

                        /* If there is an outstanding sloppy read quick event delete it */
                        if (refillDelayedHandle) {
                                delete_q_event(refillDelayedHandle);
                                refillDelayedHandle = 0;
                        }

                        continue_output();

                }
                else {                                                                  /* keyboard interface is enabled */

                        /* Do not allow port 0x60 to be overwritten for a few milliseconds.
                        ** Even 10 ms isn't as bad as the two whole timer ticks (100ms) which
                        ** is what it was doing previously.
                        ** Keyboard response for some games, including Windows, should now
                        ** be a good bit better.
                        ** The original code continued output after the second read of the port
                        ** with the interface enabled, which seems to imply that no PC apps have
                        ** been found which read the port more than twice while expecing the same
                        ** value. However, we now allow for multipe reads of the port, while enabled.
                        ** Under this circumstance the port will only be re-primed after the quick event
                        ** from the first sloppy read has been processed.
                        */

                        if (!refillDelayedHandle)                       /* if we're not already delaying, delay! */
                                refillDelayedHandle = add_q_event_t(allowRefill, KBD_CONT_DELAY, 0);

                }

        }
#endif  /* NTVDM */

        sure_note_trace2(AT_KBD_VERBOSE,"...kbd_inb(%#x) returns %#x", port, *val);

} /* end of kbd_inb */



GLOBAL VOID kbd_outb IFN2(io_addr,port,half_word,val)
{
        sure_note_trace2(AT_KBD_VERBOSE,"kbd_outb(%#x, %#x)", port, val);

#ifdef NTVDM
     if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))
     {
         return;
     }
#endif  /* NTVDM */

#if defined(NEC_98)
        port &= KEYBD_STATUS_CMD;
        if (port == KEYBD_STATUS_CMD)
                {
                cmd_to_8042(val);
                if (free_6805_buff_size < BUFF_6805_VMAX)
                        codes_to_translate();
                }
#else    //NEC_98
        port &= 0x64;
        if (port == 0x64)
        {
                kbd_status |= 0x08;
                cmd_to_8042(val);
        }
        else
        {
                cmd_byte_8042 &= 0xef;
                if ( !(cmd_byte_8042 & 0x20) )
                        keyboard_interface_disabled=FALSE;

                kbd_status &= 0xf7;
                if (waiting_for_next_8042_code)
                        cmd_to_8042(val);
                else
                        cmd_to_6805(val);
        }
#endif // NEC_98

#ifndef NTVDM   /* JonLe NTVDM Mod */

        if (free_6805_buff_size < BUFF_6805_VMAX)
                codes_to_translate();

#else   /* NTVDM */

    bForceDelayInts = TRUE;
        continue_output();
    bForceDelayInts = FALSE;

        if (!bBiosOwnsKbdHdw)
             HostReleaseKbd();

#endif  /* NTVDM */

} /*end of kbd_outb */

#ifndef NTVDM
/* Nothing seems to call this. I've no idea why it's here ... Simion */
/* I have been assured that these functions are used by sun - gvdl */

GLOBAL int status_6805_buffer IFN0()
{
        int     free_space;

        free_space = BUFF_6805_VMAX-
                ((buff_6805_in_ptr - buff_6805_out_ptr) & BUFF_6805_PMASK);
        if (free_space<0)
        {
                free_space=0;
                sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer full");
        }
        return(free_space);
}

/*
 * Name: read_6805_buffer_variables
 *
 * Purpose:     To allow the host to access the state of the 6805 buffer
 *              This means eg. on Sun that cut/paste can be optimised.
 *
 * Output:      *in_ptr - value of the 6805 start pointer.
 * Output:      *out_ptr - value of the 6805 end pointer.
 * Output:      *buf_size - value of the 6805 buffer size.
 */
GLOBAL void read_6805_buffer_variables IFN3(
int     *, in_ptr,
int     *, out_ptr,
int     *, buf_size)
{
        *in_ptr = buff_6805_in_ptr;
        *out_ptr = buff_6805_out_ptr;
        *buf_size = BUFF_6805_PMASK;
}

GLOBAL VOID insert_code_into_6805_buf IFN1(half_word,code)
{
        sure_note_trace1(AT_KBD_VERBOSE,"got real keyboard scan code : %#x",code);
        add_codes_to_6805_buff(1,&code);
        sure_note_trace1(AT_KBD_VERBOSE,"new free buf size = %#x",free_6805_buff_size);
        if (code != 0xf0) {
                codes_to_translate();
        }
}
#endif /* ! NTVDM */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

GLOBAL VOID AT_kbd_post IFN0()
{
#if defined(NEC_98)
        kbd_status = 0x85;
#else    //NEC_98
        kbd_status = 0x14;
#endif   //NEC_98

#ifndef NTVDM
        /* Clear out any pending keyboard buffer (port 0x60) refill delays */
        refillDelayedHandle = 0;
#endif
}

#if defined(IRET_HOOKS) && defined(GISP_CPU)
/*(
 *======================= KbdHookAgain() ============================
 * KbdHookAgain
 *
 * Purpose
 *      This is the function that we tell the ica to call when a keybd
 *      interrupt service routine IRETs.
 *
 * Input
 *      adapter_id      The adapter id for the line. (Note the caller doesn't
 *                      know what this is, he's just returning something
 *                      we gave him earlier).
 *
 * Outputs
 *      return  TRUE if there are more interrupts to service, FALSE otherwise.
 *
 * Description
 *      Check if we have a delayed scancode, if so then generate the kbd int
 *      and return TRUE, else return FALSE
)*/

GLOBAL IBOOL
KbdHookAgain IFN1(IUM32, adapter)
{       char scancode;

        if (HostPendingKbdInt(&scancode))
        {       /* We have a host delayed scancode, so generate a kdb int. */
                sure_note_trace0(AT_KBD_VERBOSE,"callback with saved code");
                output_full = TRUE;
                do_int ((long) scancode);
                return(TRUE);   /* more to do */
        }
        else
        {
                sure_note_trace0(AT_KBD_VERBOSE,"no saved data after IRET");
                return(FALSE);
        }
}

#endif /* IRET_HOOKS && GISP_CPU */

#ifndef NTVDM

GLOBAL VOID AT_kbd_init IFN0()
{
        int key,i;
        SHORT videoAdapt;

        sure_note_trace0(AT_KBD_VERBOSE,"AT Keyboard initialisation");

#if defined(IRET_HOOKS) && defined(GISP_CPU)
        /*
         * Remove any existing hook call-back, and re-instate it afresh.
         * KbdHookAgain is what gets called on a keyboard int iret.
         */

        Ica_enable_hooking(KEYBOARD_INT_LINE, NULL, KEYBOARD_INT_ADAPTER);
        Ica_enable_hooking(KEYBOARD_INT_LINE, KbdHookAgain, KEYBOARD_INT_ADAPTER);

        /* Host routine to reset any internal data for IRET_HOOK delayed ints. */
        HostResetKdbInts();

#endif /* IRET_HOOKS && GISP_CPU */

#ifdef  macintosh
        if (!make_arrays)
        {
                /* Allocate the world and its mother. Why does something as "simple"
                ** as the keyboard require more global data than the video emulation?
                ** Just wondering.
                */
                make_arrays = (half_word **)host_malloc(134*sizeof(half_word *));
                break_arrays = (half_word **)host_malloc(134*sizeof(half_word *));
                set_3_key_state = (half_word *)host_malloc(127*sizeof(half_word));
                key_down_count = (int *)host_malloc(127*sizeof(int));
                scan_codes_temp_area = (half_word *)host_malloc(300*sizeof(half_word));
        }
#endif  /* macintosh */

#ifndef NEC_98
        videoAdapt = (ULONG) config_inquire(C_GFX_ADAPTER, NULL);
#endif   //NEC_98

        buff_6805_out_ptr=0;
        clear_buff_6805 ();
        key_set=DEFAULT_SCAN_CODE_SET;
        current_light_pattern=0;
#ifdef REAL_KBD
        send_to_real_kbd(0xf6); /* set default */
        wait_for_ack_from_kb();
#endif
        host_kb_light_on (7);

#ifndef REAL_KBD
#if defined(NEC_98)
        for (key=0;key<144;key++)
        {
                set_3_key_state [key] = most_set_1_make_codes [key];
                key_down_count[key]=0;
        }
#else    //NEC_98
        for (key=0;key<127;key++)
        {
                set_3_key_state [key] = set_3_default_key_state [key];
                key_down_count[key]=0;
        }
#endif   //NEC_98
        repeat_delay_target=2*BASE_DELAY_UNIT;
        repeat_target=DEFAULT_REPEAT_TARGET;
#endif
        typematic_key_valid = waiting_for_next_code =
                waiting_for_next_8042_code=FALSE;
        shift_on = l_shift_on = r_shift_on=FALSE;
        ctrl_on = l_ctrl_on = r_ctrl_on=FALSE;
        alt_on = l_alt_on = r_alt_on=FALSE;
        waiting_for_upcode=FALSE;
        input_port_val=0xbf;
#if defined(NEC_98)
        kbd_status = 0x85;
#else    //NEC_98
        if (videoAdapt == MDA || videoAdapt == HERCULES)
                input_port_val |= 0x40;
        kbd_status = 0x10;
#endif   //NEC_98
        cmd_byte_8042=0x45;
        keyboard_disabled = keyboard_interface_disabled=FALSE;
        op_port_remembered_bits=0xc;

#ifdef PM
        if ( gate_a20_status )
        {
                sas_enable_20_bit_wrapping();
                gate_a20_status = 0;
        }
#endif

        pending_8042 = output_full = in_anomalous_state=FALSE;
#if defined(NEC_98)
        int_enabled = TRUE;
        translating = FALSE;
        scanning_discontinued=FALSE;
        held_event_count=0;


        io_define_inb(KEYB_ADAPTOR, kbd_inb);
        io_define_outb(KEYB_ADAPTOR, kbd_outb);

        for (i=KEYBD_PORT_START;i<=KEYBD_PORT_END;i+=2)
                io_connect_port(i, KEYB_ADAPTOR, IO_READ_WRITE);
#else    //NEC_98
        int_enabled = translating=TRUE;
        scanning_discontinued=FALSE;
        held_event_count=0;

        io_define_inb(AT_KEYB_ADAPTOR, kbd_inb);
        io_define_outb(AT_KEYB_ADAPTOR, kbd_outb);

        for (i=KEYBA_PORT_START;i<=KEYBA_PORT_END;i+=2)
                io_connect_port(i, AT_KEYB_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98

#ifndef REAL_KBD
        init_key_arrays();
#endif

        host_kb_light_off (5);
        num_lock_on = TRUE;

        host_key_down_fn_ptr = host_key_down;
        host_key_up_fn_ptr = host_key_up;
        do_key_repeats_fn_ptr = do_key_repeats;

} /* end of AT_kbd_init */

#else   /* NTVDM */

GLOBAL VOID AT_kbd_init()
{
       IU16 i;

       sure_note_trace0(AT_KBD_VERBOSE,"AT Keyboard initialisation");

       clear_buff_6805 ();
#if defined(NEC_98)
       key_set=DEFAULT_SCAN_CODE_SET;
       i = 144;
       while (i--)
          set_3_key_state [i] = most_set_1_make_codes [i];
       input_port_val=0xbf;
       kbd_status = 0x85;
       cmd_byte_8042=0x45;
       op_port_remembered_bits=0xc;
       int_enabled = TRUE;
       translating = FALSE;

       io_define_inb(KEYB_ADAPTOR, kbd_inb);
       io_define_outb(KEYB_ADAPTOR, kbd_outb);

       for (i=KEYBD_PORT_START;i<=KEYBD_PORT_END;i+=2)
                io_connect_port(i, KEYB_ADAPTOR, IO_READ_WRITE);

#else    //NEC_98
       key_set=2;
       i = 127;
       while (i--)
          set_3_key_state [i] = set_3_default_key_state [i];

       input_port_val=0xbf;
       kbd_status = 0x10;
       cmd_byte_8042=0x45;
       op_port_remembered_bits=0xc;

       int_enabled = translating = TRUE;

       io_define_inb(AT_KEYB_ADAPTOR, kbd_inb);
       io_define_outb(AT_KEYB_ADAPTOR, kbd_outb);

       for (i=KEYBA_PORT_START;i<=KEYBA_PORT_END;i+=2)
               io_connect_port(i, AT_KEYB_ADAPTOR, IO_READ_WRITE);
#endif //NEC_98
       init_key_arrays();

       num_lock_on = TRUE;
       host_key_down_fn_ptr = host_key_down;
       host_key_up_fn_ptr = host_key_up;

       /* Register an EOI hook for the keyboard */
       RegisterEOIHook(KEYBOARD_INT_LINE,KbdEOIHook);


} /* end of AT_kbd_init */
#endif  /* NTVDM */

#if defined(NEC_98)
//added to save caps & kana key state.
#define    CAPS_INDEX    0x1E      //970619
#define    KANA_INDEX    0x45      //970619
void nt_NEC98_save_caps_kana_state(void)
{
    nt_NEC98_caps_state = key_down_count[CAPS_INDEX];
    nt_NEC98_kana_state = key_down_count[KANA_INDEX];
    key_down_count[CAPS_INDEX] = 0;
    key_down_count[KANA_INDEX] = 0;
}

void nt_NEC98_restore_caps_kana_state(void)
{
    key_down_count[CAPS_INDEX] = nt_NEC98_caps_state;
    key_down_count[KANA_INDEX] = nt_NEC98_kana_state;
}
#endif    //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\winhelp.h ===
/*(
 * ============================================================================
 *
 *	Name:		WinHelp.h
 *
 *	Derived From:	Bristol's version of this file.  Slightly modified
 *			by Barry McIntosh.
 *
 *	Created:	July 1994
 *
 *	SCCS ID:	@(#)WinHelp.h	1.1 07/13/94
 *
 *	Purpose:	Defines the interface to the WinHelp() function.
 *			Note that non-Insignia types are used, as this is
 *			an interface to a third-party function.
 *
 * ============================================================================
)*/

#ifdef HOST_HELP

/*
**  Bristol Technology Incorporated
**  241 Ethan Allen Highway, Ridgefield, Connecticut 06877
**
**  Copyright (c) 1990,1991,1992,1993 Bristol Technology Inc.
**  Property of Bristol Technology Inc.
**  All rights reserved.
**
**  File:         WinHelp.h
**
**  Description:  Defines for WinHelp.c
**
*/

#ifndef WIN_HELP_INCLUDED
#define WIN_HELP_INCLUDED

/* Commands to pass WinHelp() */
#define HELP_CONTEXT		0x0001	/* Display topic in ulTopic */
#define HELP_QUIT		0x0002	/* Terminate help */
#define HELP_INDEX		0x0003	/* Display index (Kept for compatibility) */
#define HELP_CONTENTS		0x0003	/* Display index */
#define HELP_HELPONHELP		0x0004	/* Display help on using help */
#define HELP_SETINDEX		0x0005	/* Set the current Index for multi index help */
#define HELP_SETCONTENTS	0x0005	/* Set the current Index for multi index help */
#define HELP_CONTEXTPOPUP	0x0008
#define HELP_FORCEFILE		0x0009
#define HELP_KEY		0x0101	/* Display topic for keyword in offabData */
#define HELP_MULTIKEY   	0x0201
#define HELP_COMMAND		0x0102 
#define HELP_PARTIALKEY		0x0105
#define HELP_SETWINPOS 		0x0203

/* bristol extensions */
#define HELP_MINIMIZE		0x1000
#define HELP_MAXIMIZE		0x1001
#define HELP_RESTORE		0x1002

extern void WinHelp IPT4(Display *,	hWnd,
			char *,		lpHelpFile,
			unsigned short,	wCommand,	
			unsigned long,	dwData);

/* 
 * HH comm structs
 */
#define HHATOMNAME   "HyperHelpAtom"

typedef struct _HHInstance {
   int             pid;          /*Parent id*/
   unsigned long   HHWindow;     /*Filled by HH upon invocation*/
   unsigned long   ClientWindow; /*Optional (future HH to client communication link)*/
   int             bServer;      /*Viewer Mode*/
   char            data[1024];
#ifdef dec3000
   unsigned long   filler[2];
   int             filler2[2];
#endif
} HHInstance_t;

#define MAX_HHINSTANCES 5
typedef struct _HHServerData {
   int                  nItems;
   struct _HHInstance   HHInstance[MAX_HHINSTANCES];
} HHServerData_t;

#endif	/*WIN_HELP_INCLUDED*/
#endif	/* HOST_HELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\xt.h ===
#ifndef _XT_H
#define _XT_H
/*[
	Name:		xt.h
	Derived From:	VPC-XT Revision 1.0 (xt.h)
	Author:		Henry Nash
	Created On:	
	Sccs ID:	@(#)xt.h	1.19 05/15/95
	Purpose:	General include file for VPC-XT
	Notes:		This file should be included by all source modules.
			It includes the host specific general include file.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * Useful defines
 */
#define HALF_WORD_SIZE 		sizeof (half_word)
#define WORD_SIZE 		sizeof (word)
#define DOUBLE_WORD_SIZE 	sizeof (double_word)

/*
 * Used for specifying 8, 16 bit or 32 bit sizes.
 */

typedef enum {EIGHT_BIT, SIXTEEN_BIT, THIRTY_TWO_BIT} SIZE_SPECIFIER;


#ifndef TRUE
#define FALSE  	0
#define TRUE   	!FALSE
#endif /* ! TRUE */

#undef SUCCESS
#undef FAILURE
#define SUCCESS 0
#define FAILURE	~SUCCESS

#ifndef	NULL
#define	NULL	0
#endif

#ifndef NULL_STRING
#define NULL_STRING	""
#endif

#ifdef SOFTWINDOWS
#define SPC_PRODUCT_NAME "SoftWindows"
#else
#define SPC_PRODUCT_NAME "SoftPC"
#endif

/***********************************************************************\
* host_gen.h is guarenteed to be included early in every C source file.	*
* It should contain those defines which are common to all versions	*
* built for a given host, to reduce the overhead in the "m" script.	*
* Bod 15/3/89.								*
\***********************************************************************/

#include "host_gen.h"

#ifndef MAXPATHLEN
#define MAXPATHLEN    1024
#endif


/*
 * Effective address calculation stuff
 */

#ifdef CPU_30_STYLE
/* ========================================================== */

/*
   Our model for the data extracted from a decriptor entry.
 */
typedef struct
   {
   double_word base;		/* 32-bit base address */
   double_word limit;		/* 32-bit offset limit */
   word  AR;			/* 16-bit attributes/access rights */
   } DESCR;

extern LIN_ADDR effective_addr IPT2( IU16, seg,  IU32, off);
extern void read_descriptor IPT2( LIN_ADDR, addr, DESCR*, descr);
extern boolean selector_outside_table IPT2( IU16, selector, IU32*, descr_addr);


/* ========================================================== */
#else /* CPU_30_STYLE */
/* ========================================================== */

#ifdef A2CPU

/*
 * Effective address macro
 */

#define effective_addr(seg, offset) (((double_word) seg * 0x10) + offset)

#endif /* A2CPU */

#ifdef CCPU
extern sys_addr effective_addr IPT2( word, seg, word, ofs);
#endif /* CCPU */

/* ========================================================== */
#endif /* CPU_30_STYLE */


#ifdef CCPU
/*
 * CCPU has no descriptor cache - so this should just fail.
 */
#define Cpu_find_dcache_entry(seg, base)	((IBOOL)FALSE)
#else	/* not CCPU */
extern IBOOL Cpu_find_dcache_entry IPT2(word, seg, double_word *, base);
#endif

/*
 * Global Flags and Variables
 */

extern char **pargv;			/* Pointer to argv		*/
extern int *pargc;			/* Pointer to argc		*/
extern int verbose;			/* FALSE => only report errors  */
extern IU32 io_verbose;			/* TRUE => report io errors   	*/
extern IBOOL Running_SoftWindows;	/* Are we SoftWindows?		*/
extern CHAR *SPC_Product_Name;		/* "SoftPC" or "SoftWindows"	*/

/*
 * The Parity Lookup table
 */

#ifndef CPU_30_STYLE

extern half_word pf_table[]; /* shouldn't this be in host_cpu.h ? */

#endif /* CPU_30_STYLE */

/*
 * External function declarations.
 */
 
#ifdef ANSI
extern void applInit(int, char *[]);
extern void applClose(void);
extern void terminate(void);
extern void host_terminate(void);
#else
extern void applInit();
extern void applClose();
extern void terminate();
extern void host_terminate();
#endif /* ANSI */

#ifdef SPC386
extern IBOOL CsIsBig IPT1(IU16, csVal);	/* is this a 32 bit code segment? */
#endif /* SPC386 */

extern void exitswin IPT0();

#endif /* _XT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\keybd_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * File:        : keybd_io.c
 *
 * Title        : Bios Keyboard Interface function
 *
 * Sccs ID      : @(#)keybd_io.c        1.35 06/27/95
 *
 * Description  : This package contains a group of functions that provide
 *                a logical keyboard interface:
 *
 *                keyboard_init()       Initialise the keyboard interface.
 *                keyboard_int()        Deal with a character from the keyboard
 *                                      and place them in the BIOS buffer.
 *                keyboard_io()         User routine to read characters from
 *                                      the BIOS buffer.
 *                bios_buffer_size()    How many chars in the buffer ?
 *
 * Author       : Rod Macgregor / Henry Nash
 *
 * Modified     : Jon Eyre / Jim Hatfield / Uncle Tom Cobbley and all
 *
 * Modfications : This module is now designed to be totally portable, it
 *                represents both the hardware and user interrupt interfaces.
 *                These two functions are provided by the routines
 *                keyboard_int & keyboard_io. The system will initialise
 *                itself by a call to keyboard_init.
 *
 *                The user is expected to supply the following host dependent
 *                routines for this module, tagged as follows:-
 *
 *                [HOSTSPECIFIC]
 *
 *                host_alarm(duration)
 *                long int duration ;
 *                                 - ring the host's bell.
 *
 *                host_kb_init()   - any local initialisations required when
 *                                   keyboard_init is called.
 *
 *                Removed calls to cpu_sw_interrupt and replaced with
 *                host_simulate
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)keybd_io.c    1.35 06/27/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "ppi.h"
#include "keyboard.h"
#include "timeval.h"
#include "timer.h"
#include "keyba.h"
#include "ica.h"
#ifndef PROD
#include "trace.h"
#endif

#include "debug.h"
#include "idetect.h"

extern void host_simulate();

/*
 * ============================================================================
 * External routines
 * ============================================================================
 */

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

#define SHIFT_KEY_SIZE 8
#define ALT_TABLE_SIZE 36

/*
 * lookup table to check if the scan code received is a shift key
 */
static sys_addr shift_keys;

/*
 * corresponding table to 'shift_keys' to set relevant bits in masks when
 * shift scan code received
 */
static sys_addr shift_masks;

/*
 * next two tables give values of chars when control key depressed. First
 * table (ctl_n_table) is for main keyboard values and second (ctl_f_table)
 * is for the function keys and keypad.
 */
static sys_addr ctl_n_table;
static sys_addr ctl_f_table;

/*
 * values of ascii keys dependiing on shift or caps states
 */
static sys_addr lowercase;
static sys_addr uppercase;


/*
 * remapping of some keys when alt key depressed. note 1st ten are for
 * keypad entries.
 */
static sys_addr alt_table;

/* Add variables for all these entry points instead of the previously used
 * defines. This allows modification of these entry points from a loaded
 * driver, when the Insignia bios may not be in the loaded in the default
 * or assumed location.
 */

#if defined(NTVDM) && defined(LOCAL)
/*
 * Make static fns and globals visible to win32 debuggers
 */
#undef LOCAL
#define LOCAL
#endif

#ifndef GISP_SVGA
LOCAL word int15_seg = RCPU_INT15_SEGMENT,
           int15_off = RCPU_INT15_OFFSET;

LOCAL word int1b_seg = KEYBOARD_BREAK_INT_SEGMENT,
           int1b_off = KEYBOARD_BREAK_INT_OFFSET;

LOCAL word int05_seg = PRINT_SCREEN_INT_SEGMENT,
           int05_off =  PRINT_SCREEN_INT_OFFSET;

LOCAL word rcpu_nop_segment = RCPU_NOP_SEGMENT,
           rcpu_nop_offset  = RCPU_NOP_OFFSET;

LOCAL word rcpu_poll_segment = RCPU_POLL_SEGMENT,
           rcpu_poll_offset  = RCPU_POLL_OFFSET;
#else /* GISP_SVGA */
/* If we are GISP_SVGA the segments will be variables anyway */
#define int15_seg  RCPU_INT15_SEGMENT
LOCAL word      int15_off = RCPU_INT15_OFFSET;

#define int1b_seg  KEYBOARD_BREAK_INT_SEGMENT
LOCAL word   int1b_off = KEYBOARD_BREAK_INT_OFFSET;

#define int05_seg  PRINT_SCREEN_INT_SEGMENT
LOCAL word  int05_off = PRINT_SCREEN_INT_OFFSET;

#define rcpu_nop_segment  RCPU_NOP_SEGMENT
LOCAL word  rcpu_nop_offset  = RCPU_NOP_OFFSET;

#define rcpu_poll_segment  RCPU_POLL_SEGMENT
LOCAL word rcpu_poll_offset  = RCPU_POLL_OFFSET;
#endif /* GISP_SVGA */

#if defined(IRET_HOOKS) && defined(GISP_CPU)
IMPORT VOID  HostAllowKbdInt();  /* Allow keybd Ints without an IRET */
#endif /* IRET_HOOKS && GISP_CPU */

#ifdef NTVDM

#include "error.h"

GLOBAL word wait_int_seg = RCPU_WAIT_INT_SEGMENT;
GLOBAL word wait_int_off = RCPU_WAIT_INT_OFFSET;
GLOBAL word dr_type_seg = DR_TYPE_SEGMENT;
GLOBAL word dr_type_off = DR_TYPE_OFFSET;
GLOBAL sys_addr dr_type_addr = DR_TYPE_ADDR;
/* Global var to indicate whether keyboard bios or hardware owns the keyboard mutex. */
GLOBAL BOOL bBiosOwnsKbdHdw;
IMPORT ULONG WaitKbdHdw(ULONG dwTimeOut);
IMPORT VOID  HostReleaseKbd();
IMPORT VOID  HostResetKbdNotFullEvent();
IMPORT VOID  HostSetKbdNotFullEvent();
GLOBAL VOID  TryKbdInt(VOID);
IMPORT VOID  ResumeTimerThread(VOID);
IMPORT VOID  WaitIfIdle(VOID);


#define FREEKBDHDW()    bBiosOwnsKbdHdw = \
                      ( bBiosOwnsKbdHdw ? HostReleaseKbd(), FALSE : FALSE )


/* for optimizing timer hardware interrupt generation defined in timer.c */
extern word TimerInt08Seg;
extern word TimerInt08Off;
extern word TimerInt1CSeg;
extern word TimerInt1COff;
extern word KbdInt09Seg;
extern word KbdInt09Off;
extern BOOL VDMForWOW;

void Keyb16Request(half_word BopFnCode);

/* optimizes 16 bit handler */
extern word *pICounter;
extern word *pCharPollsPerTick;
extern word *pShortIdle;
extern word *pIdleNoActivity;


// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
extern half_word * stream_io_buffer;
extern word * stream_io_dirty_count_ptr;
extern word stream_io_buffer_size;
extern sys_addr stream_io_bios_busy_sysaddr;
#endif // !NEC_98

#else
#define FREEKBDHDW()    /* Nothing for conventional SoftPC */
#endif  /* NTVDM */

/*
 * Mix in global defined data as well.
 */

#ifndef GISP_SVGA
GLOBAL word rcpu_int1C_seg = USER_TIMER_INT_SEGMENT;
GLOBAL word rcpu_int1C_off = USER_TIMER_INT_OFFSET;

GLOBAL word rcpu_int4A_seg = RCPU_INT4A_SEGMENT;
GLOBAL word rcpu_int4A_off = RCPU_INT4A_OFFSET;
#else /* GISP_SVGA */

/* For GISPSVGA the segs will already be variables */
#define rcpu_int1C_seg = USER_TIMER_INT_SEGMENT;
GLOBAL word rcpu_int1C_off = USER_TIMER_INT_OFFSET;

#define rcpu_int4A_seg = RCPU_INT4A_SEGMENT;
GLOBAL word rcpu_int4A_off = RCPU_INT4A_OFFSET;
#endif /* GISP_SVGA */

GLOBAL word dummy_int_seg = 0;
GLOBAL word dummy_int_off = 0;

#ifdef NTVDM
GLOBAL word int13h_vector_off;
GLOBAL word int13h_vector_seg;
GLOBAL word int13h_caller_off;
GLOBAL word int13h_caller_seg;
#endif /* NTVDM */
#if defined(JAPAN) && defined(NTVDM) && !defined(NEC_98)
GLOBAL word int16h_caller_off;
GLOBAL word int16h_caller_seg = 0;
#endif // JAPAN, NTVDM, !NEC_98

#if defined(NTVDM) && defined(MONITOR)
/*
** Microsoft special.
** These variables are set below in kb_setup_vectors(), to addresses
** passed by NTIO.SYS via BOP 5F -> MS_bop_F() -> kb_setup_vectors()
** Tim June 92.
*/
/*
** New ntio.sys variables for video ROM matching. Tim August 92.
*/
GLOBAL word int10_seg=0;
GLOBAL word int10_caller=0;
GLOBAL word int10_vector=0; /* Address of native int 10*/
GLOBAL word useHostInt10=0; /* var that chooses between host video ROM or BOPs */
GLOBAL word babyModeTable=0; /* Address of small mode table lives in ntio.sys */
GLOBAL word changing_mode_flag=0; /* ntio.sys var to indicate vid mode change */
GLOBAL word vga1b_seg = 0;
GLOBAL word vga1b_off = 0;   /* VGA capability table normally in ROM */
GLOBAL word conf_15_off = 0;
GLOBAL word conf_15_seg = 0; /* INT15 config table normally in ROM */

void printer_setup_table(sys_addr table_addr);

#endif /* NTVDM & MONITOR */

BYTE *Dos_Flag_Addr;
extern int soft_reset   ;       /* set for ctl-alt-dels                 */

/*
 * ============================================================================
 * Local macros
 * ============================================================================
 */

LOCAL VOID exit_from_kbd_int IPT0();

/*
 * Function to increment BIOS buffer pointers, returns new one
 */
LOCAL word inc_buffer_ptr IFN1(word, buf_p)
{
        buf_p += 2;
        if (buf_p == sas_w_at_no_check(BIOS_KB_BUFFER_END))
                buf_p = sas_w_at_no_check(BIOS_KB_BUFFER_START);

        return buf_p;
}





/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */


/*
 *      Routine to translate scan code pairs for standard calls
 *      Returns CF set if this scancode/char pair should be thrown away.
 */
LOCAL VOID translate_std IFN0()
{
    IU8 ah, al;
    enum {dontSetCF, setCF0, setCF1} cfSet = dontSetCF;

    ah = getAH();
    al = getAL();

    if ( ah == 0xE0 )                   /* is it keypad enter or /      */
    {
        if ( (al == 0x0D) || (al == 0x0A) )
             setAH( 0x1C );             /* code is enter                */
        else
             setAH( 0x35 );             /* must be keypad ' / '         */

        cfSet = setCF0;
    }
    else
    {
        if ( ah > 0x84 )                /* is it an extended one        */
            cfSet = setCF1;
        else
        {
            if( al == 0xF0 )            /* is it one of the 'fill ins'  */
            {
                if ( ah == 0)           /* AH = 0 special case          */
                    cfSet = setCF0;
                else
                    cfSet = setCF1;     /* Delete me */
            }
            else
            {
                if ( (al == 0xE0) && (ah != 0) )
                    setAL( 0 );         /* convert to compatible output */

                cfSet = setCF0;
            }
        }
    }

    if (cfSet != dontSetCF)
        setCF(cfSet == setCF1);
}


static void translate_ext()
/*
 *      Routine to translate scan code pairs for extended calls
 */
{
   if ( (getAL() == 0xF0 ) && (getAH() != 0) )
        setAL( 0 );
}

/*
 * Send command or data byte to the keyboard and await for the acknowledgemnt
 */

/*
 * Arbitrary retry limits - experiments suggest that we always succeed
 * on the first try in a pure SoftWindows.  A "real keyboard" version may
 * be different.
 */

#define WAIT_RETRY      5
#define RESEND_RETRY    3

LOCAL VOID send_data IFN1(half_word, data)
{
        int resend_retry;
        word CS_save, IP_save;
        half_word var_kb_flag_2;

        note_trace1(BIOS_KB_VERBOSE,"Cmd to kb i/o buff:0x%x",data);

        /*
         * Save  CS:IP before calling a recursive CPU to handle the interrupt
         * from the keyboard
         */

        CS_save = getCS();
        IP_save = getIP();

        /*
         * Set the retry flag ( KB_FE ) to force outb() at least once.  If
         * we have real keyboard hardware this may get set again if the
         * hardware didn't understand the command for some reason e.g.
         * garbled by the serial line.
         */

        var_kb_flag_2 = sas_hw_at(kb_flag_2) | KB_FE;
        resend_retry = RESEND_RETRY;

        do
        {
                IBOOL resend_command;
                int wait_retry;

                resend_command = (var_kb_flag_2 & KB_FE) != 0;
                wait_retry = WAIT_RETRY;

                /* Clear resend, acknowledge and error flags */
                var_kb_flag_2 &= ~(KB_FE + KB_FA + KB_ERR);

                /*
                 * Update Intel memory with cleared down flags *BEFORE*
                 * the outb(), which may set the acknowledge flag, if we
                 * execute enough Intel due to virtualisation.
                 */

                sas_store(kb_flag_2, var_kb_flag_2);

                /* Do the outb if necessary */

                if( resend_command )
                {
                        outb(KEYBA_IO_BUFFERS, data);
                }

                /* Look for one of the flag bits to be set or time out */

                while( !(var_kb_flag_2 & (KB_FA + KB_FE + KB_ERR))
                                                && ( --wait_retry > 0 ))
                {
                        /*
                         * Process interrupt from kb.
                         *
                         * Note for perplexed keyboard debuggers:
                         *   Keyboard interrupts are delayed for a few
                         *   Intel instructions using quick events.  This
                         *   means that the IRR from the above outb() may
                         *   not be raised until we have done the following
                         *   sub-CPU a few times.
                         */

                        setCS(rcpu_nop_segment);
                        setIP(rcpu_nop_offset);
                        host_simulate();

                        /* Re-read flag byte to see if anything has happened */

                        var_kb_flag_2 = sas_hw_at(kb_flag_2);
                }

                /* If we got an acknowledge we've succeeded */

                if (var_kb_flag_2 & KB_FA)
                        break;

                /* Set up error flag (in case this is the last retry) */

                note_trace0(BIOS_KB_VERBOSE,"failed to get ack ... retry");
                var_kb_flag_2 |= KB_ERR;
        }
        while( --resend_retry > 0 );

        if (var_kb_flag_2 & KB_ERR)
        {
                note_trace0(BIOS_KB_VERBOSE,"no more retrys");

                /* Write back flags with error bit set */

                sas_store(kb_flag_2, var_kb_flag_2);
        }

        setCS(CS_save);
        setIP(IP_save);
}



LOCAL VOID check_indicators IFN1(IBOOL, eoi)
                /* end of interrupt flag - if set to non-zero   */
                /* 0x20 is written to port 0x20                 */
{
        half_word indicators ;
        half_word var_kb_flag_2;

        /* move switch indicators to bits 0-2   */

        indicators = (sas_hw_at_no_check(kb_flag) & (CAPS_STATE + NUM_STATE + SCROLL_STATE)) >> 4;

        var_kb_flag_2 = sas_hw_at_no_check(kb_flag_2);
        /* compare with previous setting        */
        if ((indicators ^ var_kb_flag_2) & KB_LEDS)
        {
                /* check if update in progress  */
                if( (var_kb_flag_2 & KB_PR_LED) == 0)
                {
                        /* No update in progress */
                        var_kb_flag_2 |= KB_PR_LED;
                        sas_store_no_check(kb_flag_2, var_kb_flag_2);
                        if (eoi)
                                outb(0x20, 0x20);

#if defined(NTVDM) || defined(GISP_CPU)
        /*
         *  On the NT port we do not update the real kbd lights
         *  so we don't need to do communicate with the kbd hdw (keyba.c)
         *
         *  If this ever changes for the NT port then do not use
         *  send_data which forces us to switch context back to
         *  16 bit and waits for a reply. Do this with a direct
         *  call to the kbd Hdw
         *
         */

        /* set kb flag up with new status       */

        var_kb_flag_2 = (var_kb_flag_2 & 0xf8) | indicators;
        sas_store_no_check(kb_flag_2, var_kb_flag_2);
#ifdef NTVDM
        host_kb_light_on (indicators);
#endif

#ifdef  GISP_CPU
        /*
        ** We do update an emulation of the keyboard lights but we don't
        ** want to do it via send_data and switching back to 16-bit.
        ** We call the host routines directly.
        */
        host_kb_light_on (indicators);
        host_kb_light_off ((~indicators)&0x7);

#endif  /* GISP_CPU */
#else   /* not NTVDM nor GISP_CPU */

                        send_data(LED_CMD);

                        /* set kb flag up with new status       */
                        var_kb_flag_2 = (sas_hw_at_no_check(kb_flag_2) & 0xf8) | indicators;
                        sas_store_no_check(kb_flag_2, var_kb_flag_2);

                        /* check error from previous send_data()        */
                        if( (var_kb_flag_2 & KB_ERR) == 0)
                        {
                                /* No error     */
                                send_data(indicators);

                                /* test for error       */
                                if(sas_hw_at_no_check(kb_flag_2) & KB_ERR) {
                                        /* error!       */
                                        note_trace0(BIOS_KB_VERBOSE,"got error sending change LEDs command");
                                        send_data(KB_ENABLE);
                                }
                        }
                        else
                                /* error!       */
                                send_data(KB_ENABLE);
#endif  /* NTVDM or GISP_CPU */

                        /* turn off update indicator and error flag     */
                        sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) & ~(KB_PR_LED + KB_ERR)));
                }
        }
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

/*
** called from hunter.c:do_hunter()
** tells hunter about the BIOS buffer size so it will not over fill
** the BIOS buffer
** Used in no Time Stamp mode only.
**
** Also useful in host paste code to make sure keys are not pasted in too
** fast.
*/
int bios_buffer_size IPT0()
{
        word buffer_head, buffer_tail;

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        note_trace2( BIOS_KB_VERBOSE, "BIOS kbd buffer head=%d tail=%d",
                                                buffer_head, buffer_tail );
        if( buffer_tail > buffer_head )
                return( buffer_tail - buffer_head );
        else
                return( buffer_head - buffer_tail );
}

LOCAL VOID K26A IFN0()
{
        /* Interrupt Return */
        outb(0x20, 0x20);
        outb(KEYBA_STATUS_CMD, ENA_KBD);
}

LOCAL VOID K26 IFN0()
{
        /* Reset last char H.C. flag */
        sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~(LC_E0 + LC_E1)));

        /* (same as K26A()) */
        outb(0x20, 0x20);
        outb(KEYBA_STATUS_CMD, ENA_KBD);
}


#ifndef NTVDM

LOCAL VOID INT15 IFN0()
{
        word    saveCS, saveIP;

        saveCS = getCS();
        saveIP = getIP();

        setCS(int15_seg);
        setIP(int15_off);

        host_simulate();

        setCS(saveCS);
        setIP(saveIP);
}

#else   /* NTVDM */

void INT15(void);
word sp_int15_handler_seg = 0;
word sp_int15_handler_off = 0;

#endif  /* NTVDM */

#ifndef NTVDM
#define BEEP(message)           always_trace0(message);         \
                                host_alarm(250000L);            \
                                K26A()
#else   /* NTVDM */
/* NTVDM code size is too large, change this often used macro
 * to a function, as the call overhead is not justified
 */
void BEEP(char *message)
{
    note_trace0(BIOS_KB_VERBOSE,message);
    host_alarm(250000L);
    K26A();
}
#endif  /* NTVDM */



/*
** Tell ICA End of Interrupt has happened, the ICA will
** allow interupts to go off again.
** Call INT 15.
** Reenable the Keyboard serial line so Keyboard
** interrupts can go off.
** NOTE:
** this is different to the real BIOS. The real BIOS
** does ICA, Keyboard then INT 15, if we do that Keyboard
** interrupts occur too soon, during the INT 15 and blow the
** DOS stack. We effectively stop Keybd interrupts during the
** INT 15.
**
** <tur 17-Jun-93> Take a leaf outta NTVDM's book and make these
** functions rather than macros. (This reduced the size of keybd_io.c.o
** on the Mac from 38K to 12K!) After all, it isn't as if keyboards are
** highly speed sensitive!
*/
#ifndef NTVDM

LOCAL VOID PutInBufferFunc IFN2(half_word, s, half_word, v)
{
        word    buffer_head, buffer_tail, buffer_ptr;

        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_ptr = inc_buffer_ptr(/* from: */buffer_tail);

        if (buffer_ptr == buffer_head) {
                BEEP("BIOS keyboard buffer overflow");
        }
        else {
                sas_store_no_check(BIOS_VAR_START + buffer_tail, v);
                sas_store_no_check(BIOS_VAR_START + buffer_tail+1, s);
                sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);

                outb(0x20, 0x20);
                setAX(0x9102);
                INT15();

                outb(KEYBA_STATUS_CMD, ENA_KBD);
                sas_store (kb_flag_3, sas_hw_at(kb_flag_3) & ~(LC_E0 + LC_E1));
                setIF(0);
        }

        exit_from_kbd_int();
}


#else   /* NTVDM */


/* <tur> NT's PutInBuffer seems to be slightly different to PutInBufferFunc above. */
/* So I'm Not Touching it! (Is this a good expansion of "NT"? :-) */

/* Our code size is too large, change this often used macro
 * to a function, as the call overhead is not justified
 */

void NtPutInBuffer(half_word s, half_word v)
{
        word    buffer_head, buffer_tail, buffer_ptr;

        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_ptr = inc_buffer_ptr(/* from: */buffer_tail);

        if (buffer_ptr == buffer_head) {
                BEEP("BIOS keyboard buffer overflow");
        }
        else {
                sas_store_no_check(BIOS_VAR_START + buffer_tail, v);
                sas_store_no_check(BIOS_VAR_START + buffer_tail+1, s);
                sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);
                setAX(0x9102);
                INT15();
      K26();
      setIF(0);
        }

   exit_from_kbd_int();
}

#define PUT_IN_BUFFER(s, v) NtPutInBuffer(s,v); return
#endif  /* NTVDM */


/* <tur 17-Jun-93> Eurrgh; macros with embedded "return"s! */

#ifndef NTVDM
#define PUT_IN_BUFFER(s, v)             PutInBufferFunc(s,v); return
#endif  /* !NTVDM */

LOCAL VOID CheckAndPutInBufferFunc IFN2(half_word, s,half_word, v)
{
        if ((s == 0xff) || (v == 0xff)) {
                K26();
                exit_from_kbd_int();
        }
        else {
#ifndef NTVDM
                PutInBufferFunc(s, v);
#else /* NTVDM */
                NtPutInBuffer(s, v);
#endif /* !NTVDM */
        }
}

#define CHECK_AND_PUT_IN_BUFFER(s,v)    CheckAndPutInBufferFunc(s, v); return


LOCAL VOID PAUSE IFN0()
{
        word   CS_save;        /* tmp. store for CS value      */
        word   IP_save;        /* tmp. store for IP value      */

        sas_store_no_check(kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | HOLD_STATE));

        outb(KEYBA_STATUS_CMD, ENA_KBD);
        outb(0x20, 0x20);

        CS_save = getCS();
        IP_save = getIP();

        FREEKBDHDW();

        do {
#if defined(IRET_HOOKS)  && defined(GISP_CPU)
                HostAllowKbdInt();      /* Allow a keypress to generate an interrupt */
#endif /* IRET_HOOKS && GISP_CPU */


#if defined(NTVDM)
                IDLE_waitio();
#endif

                setCS(rcpu_nop_segment);
                setIP(rcpu_nop_offset);
                host_simulate();

        } while (sas_hw_at_no_check(kb_flag_1) & HOLD_STATE);

        setCS(CS_save);
        setIP(IP_save);
        outb(KEYBA_STATUS_CMD, ENA_KBD);
}

#ifndef NTVDM
static int re_entry_level=0;
#endif

/*
** All exits from keyboard_int() call this first.
*/
LOCAL void exit_from_kbd_int IFN0()
{
#ifndef NTVDM
        --re_entry_level;
        if( re_entry_level >= 4 )
                always_trace1("ERROR: KBD INT bad exit level %d", re_entry_level);
#endif
        note_trace0( BIOS_KB_VERBOSE, "KBD BIOS - END" );
        setIF( 0 );
        FREEKBDHDW();   /* JonLe NTVDM Mod */
}

void keyboard_int IFN0()
{
        int                     i;              /* loop counter                 */

        half_word               code,           /* scan code from keyboard      */
                                code_save,      /* tmp variable for above       */
                                chr,            /* ASCII char code              */
                                last_kb_flag_3, /* kb_flag_3 saved              */
                                mask;
#ifdef  NTVDM
        word            IP_save,
                        buffer_head,    /* ptr. to head of kb buffer */
                        buffer_tail;    /* ptr. to tail of kb buffer */
        half_word               BopFnCode;
#endif  /* NTVDM */



        boolean                 upper;          /* flag indicating upper case   */

#ifdef NTVDM
        BopFnCode = getAH();
        if (BopFnCode) {
            Keyb16Request(BopFnCode);
            return;
            }
#endif
#ifndef NTVDM
        ++re_entry_level;
        if( re_entry_level > 4 ){
                always_trace1("ERROR: KBD BIOS re-entered at level %d\n", re_entry_level-1);
        }
#endif
        setIF(0);
        note_trace0(BIOS_KB_VERBOSE,"KBD BIOS start");

#ifdef NTVDM            /* JonLe keyboard mod */
        bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
#endif  /* NTVDM */

        /* disable keyboard     */
        outb(KEYBA_STATUS_CMD, DIS_KBD);

#ifdef NTVDM
          /*
           *  CarbonCopy traces int 9 in order to gain control
           *  over where the kbd data is coming from (the physical kbd
           *  or the serial link) The kbd_inb instruction must be visible
           *  in the 16 bit code via int 1 tracing, for CarbonCopy to work.
           *  interrupts should be kept off.
           */
        if (getTF()) {
            IP_save = getIP();
            setIP((IU16)(IP_save + 4));  /* adavance by 4 bytes, pop ax, jmp iret_com */
            host_simulate();
            setIP(IP_save);
            code = getAL();
            }
        else
#endif
            inb(KEYBA_IO_BUFFERS, &code);                           /* get scan_code        */

        /* call recursive CPU to handle int 15 call     */
        setAH(0x4f);
        setAL(code);
        setCF(1);       /* Default return says scan code NOT consumed - needed by Freelance Plus 3.01 */
        INT15();
        code = getAL(); /* suret int 15 function can change the scan code in AL */


        if(!getCF())                                            /* check CF     */
        {
                K26();
                exit_from_kbd_int();return;
        }

        if ( code == KB_RESEND )                                        /* check for resend     */
        {
                sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) | KB_FE));
                K26();
                exit_from_kbd_int();return;
        }

        if( code == KB_ACK )                                            /* check for acknowledge        */
        {
                sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) | KB_FA));
                K26();
                exit_from_kbd_int();return;
        }

        check_indicators(0);

        if ( code == KB_OVER_RUN )                                      /* test for overrun     */
        {
                BEEP("hardware keyboard buffer overflow");
                exit_from_kbd_int();return;
        }
        last_kb_flag_3 = sas_hw_at_no_check(kb_flag_3);

        /* TEST TO SEE IF A READ_ID IS IN PROGRESS      */
        if ( last_kb_flag_3 & (RD_ID + LC_AB) )
        {
                if ( sas_hw_at_no_check(kb_flag) & RD_ID )      /* is read_id flag on   */
                {
                        if( code == ID_1 )                              /* is this the 1st ID char.     */
                                sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | LC_AB));
                        sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~RD_ID));
                }
                else
                {
                        sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~LC_AB));
                        if( code != ID_2A )                             /* is this the 2nd ID char.     */
                        {
                                if( code == ID_2 )
                                {
                                        /* should we set NUM LOCK       */
                                        if( last_kb_flag_3 & SET_NUM_LK )
                                        {
                                                sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | NUM_STATE));
                                                check_indicators(1);
                                        }
                                }
                                else
                                {
                                        K26();
                                        exit_from_kbd_int();return;
                                }
                        }
                        sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | KBX));     /* enhanced kbd found   */
                }
                K26();
                exit_from_kbd_int();return;
        }

        if( code == MC_E0 )                                             /* general marker code? */
        {
                sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | ( LC_E0 + KBX )));
                K26A();
                exit_from_kbd_int();return;
        }

        if( code == MC_E1 )                                             /* the pause key ?      */
        {
                sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check (kb_flag_3) | ( LC_E1 + KBX )));
                K26A();
                exit_from_kbd_int();return;
        }

        code_save = code;                                               /* turn off break bit   */
        code &= 0x7f;

        if( last_kb_flag_3 & LC_E0)                                     /* last code=E0 marker? */
        {
                /* is it one of the shift keys  */
                if( code == sas_hw_at_no_check(shift_keys+6) || code == sas_hw_at_no_check(shift_keys+7) )
                {
                        K26();
                        exit_from_kbd_int();return;
                }
        }
        else if( last_kb_flag_3 & LC_E1 )                               /* last code=E1 marker? */
        {
                /* is it alt, ctl or one of the shift keys      */
                if( code == sas_hw_at_no_check(shift_keys+4) || code == sas_hw_at_no_check(shift_keys+5) ||
                    code == sas_hw_at_no_check(shift_keys+6) || code == sas_hw_at_no_check(shift_keys+7) )
                {
                        K26A();
                        exit_from_kbd_int();return;
                }
                if( code == NUM_KEY )                                   /* is it the pause key  */
                {
                        /* is it the break or are we paused already     */
                        if( (code_save & 0x80) || (sas_hw_at_no_check(kb_flag_1) & HOLD_STATE) )
                        {
                                K26();
                                exit_from_kbd_int();return;
                        }
                        PAUSE();
                        exit_from_kbd_int();return;
                }
        }
        /* TEST FOR SYSTEM KEY  */
        else if( code == SYS_KEY )
        {
                if( code_save & 0x80 )                                  /* check for break code */
                {
                        sas_store_no_check(kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~SYS_SHIFT));
                        K26A();
                        /* call recursive CPU to call INT 15    */
                        setAX(0x8501);
                        INT15();
                        exit_from_kbd_int();return;
                }
                if( sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT)  /* Sys key held down ?  */
                {
                        K26();
                        exit_from_kbd_int();return;
                }
                sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | SYS_SHIFT));
                K26A();
                /* call recursive CPU to call INT 15    */
                setAX(0x8500);
                INT15();
                exit_from_kbd_int();return;
        }
        /* TEST FOR SHIFT KEYS  */
        for( i=0; i < SHIFT_KEY_SIZE; i++)
                if ( code == sas_hw_at_no_check(shift_keys+i) )
                        break;
        code = code_save;

        if( i < SHIFT_KEY_SIZE )                                        /* is there a match     */
        {
                mask = sas_hw_at_no_check (shift_masks+i);
                if( code & 0x80 )                                       /* test for break key   */
                {
                        if (mask >= SCROLL_SHIFT)                       /* is this a toggle key */
                        {
                                sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~mask));
                                K26();
                                exit_from_kbd_int();return;
                        }

                        sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) & ~mask));       /* turn off shift bit   */
                        if( mask >= CTL_SHIFT)                          /* alt or ctl ?         */
                        {
                                if( sas_hw_at_no_check (kb_flag_3) & LC_E0 )                    /* 2nd alt or ctl ?     */
                                        sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~mask));
                                else
                                        sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~(mask >> 2)));
                                sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | ((((sas_hw_at_no_check(kb_flag) >>2 ) | sas_hw_at(kb_flag_1)) << 2) & (ALT_SHIFT + CTL_SHIFT))));
                        }
                        if(code != (ALT_KEY + 0x80))                    /* alt shift release ?  */
                        {
                                K26();
                                exit_from_kbd_int();return;
                        }

                        code = sas_hw_at_no_check(alt_input);
                        if ( code == 0 )                                /* input == 0 ?         */
                        {
                                K26();
                                exit_from_kbd_int();return;
                        }

                        sas_store_no_check(alt_input, 0);               /* Zero the ALT_INPUT char */
                        /* At this point, the ALT input char (now in "code") should be put in the buffer. */
                        PUT_IN_BUFFER(0, code);
#ifdef NTVDM
                        return;
#endif
                }
                /* SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE    */
                if( mask < SCROLL_SHIFT )
                {
                        sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | mask));
                        if ( mask & (CTL_SHIFT + ALT_SHIFT) )
                        {
                                if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )     /* one of the new keys ?*/
                                        sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | mask));             /* set right, ctl alt   */
                                else
                                        sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | (mask >> 2)));     /* set left, ctl alt    */
                        }
                        K26();
                        exit_from_kbd_int();return;
                }
                /* TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT  */
                if( (sas_hw_at_no_check(kb_flag) & CTL_SHIFT) == 0 )
                {
                        if( code == INS_KEY )
                        {
                                if( sas_hw_at_no_check(kb_flag) & ALT_SHIFT )
                                        goto label1;

                                if( (sas_hw_at_no_check(kb_flag_3) & LC_E0) == 0 )              /* the new insert key ? */
                                {
                                        /* only continue if NUM_STATE flag set OR
                                           one or both of the shift flags       */
                                        if( ((sas_hw_at_no_check(kb_flag) &
                                                (NUM_STATE + LEFT_SHIFT + RIGHT_SHIFT))
                                                == NUM_STATE) ||
                                            (((sas_hw_at_no_check(kb_flag) & NUM_STATE) == 0)
                                                && (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT))) )
                                                goto label1;
                                }
                        }
                        /* shift toggle key hit */
                        if( mask & sas_hw_at_no_check(kb_flag_1) )      /* already depressed ?  */
                        {
                                K26();
                                exit_from_kbd_int();return;
                        }
                        sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | mask));                            /* set and toggle flags */
                        sas_store_no_check ( kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) ^ mask));
                        if( mask & (CAPS_SHIFT + NUM_SHIFT + SCROLL_SHIFT) )
                                check_indicators(1);

                        if( code == INS_KEY )                           /* 1st make of ins key  */
                                goto label2;

                        K26();
                        exit_from_kbd_int();return;
                }
        }
label1: /* TEST FOR HOLD STATE */
        if( code & 0x80 )                                               /* test for break       */
        {
                K26();
                exit_from_kbd_int();return;
        }
        if( sas_hw_at_no_check(kb_flag_1) & HOLD_STATE )                /* in hold state ?      */
        {
                if( code != NUM_KEY )
                        sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~HOLD_STATE));
                K26();
                exit_from_kbd_int();return;
        }
label2: /* NOT IN HOLD STATE    */
        if( code > 88)                                                  /* out of range ?       */
        {
                K26();
                exit_from_kbd_int();return;
        }
        /* are we in alternate shift    */
        if( (sas_hw_at_no_check(kb_flag) & ALT_SHIFT) && ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) ||
                                                        ((sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT) == 0) ) )
        {
                /* TEST FOR RESET KEY SEQUENCE (CTL ALT DEL)    */
                if( (sas_hw_at_no_check(kb_flag) & CTL_SHIFT ) && (code == DEL_KEY) )
                {
#ifndef NTVDM
                        reboot();
#else
                        K26();
#endif
                        exit_from_kbd_int();return;
                }
                /* IN ALTERNATE SHIFT, RESET NOT FOUND  */
                if( code == SPACEBAR )
                {
                        PUT_IN_BUFFER(code, ' ');
                }
                if( code == TAB_KEY )
                {
                        PUT_IN_BUFFER(0xa5, 0 );                /* special code for alt-tab     */
                }
                if( (code == KEY_PAD_MINUS) || (code == KEY_PAD_PLUS) )
                {
                        PUT_IN_BUFFER(code, 0xf0);              /* special ascii code           */
                }
                /* LOOK FOR KEYPAD ENTRY        */
                for (i = 0; i < 10; i++ )
                        if ( code == sas_hw_at_no_check (alt_table+i) )
                                break;
                if( i < 10 )
                {
                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )     /* one of the new keys ?        */
                        {
                                PUT_IN_BUFFER((IU8)(code + 80), 0 );
                        }
                        sas_store_no_check (alt_input, (IU8)(sas_hw_at_no_check(alt_input) * 10 + i));
                        K26();
                        exit_from_kbd_int();return;
                }
                /* LOOK FOR SUPERSHIFT ENTRY    */
                for( i = 10; i < ALT_TABLE_SIZE; i++)
                        if( code == sas_hw_at_no_check (alt_table+i))
                                break;
                if( i < ALT_TABLE_SIZE )
                {
                        PUT_IN_BUFFER(code, 0 );
                }
                /* LOOK FOR TOP ROW OF ALTERNATE SHIFT  */
                if( code < TOP_1_KEY )
                {
                        CHECK_AND_PUT_IN_BUFFER(code, 0xf0);    /* must be escape       */
                }
                if( code < BS_KEY )
                {
                        PUT_IN_BUFFER((IU8)(code + 118), 0);
                }
                /* TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES  */
                if((code == F11_M) || (code == F12_M) )         /* F11 or F12           */
                {
                        PUT_IN_BUFFER((IU8)(code + 52), 0 );
                }
                if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )     /* one of the new keys ?*/
                {
                        if( code == KEY_PAD_ENTER )
                        {
                                PUT_IN_BUFFER(0xa6, 0);
                        }
                        if( code == DEL_KEY )
                        {
                                PUT_IN_BUFFER((IU8)( code + 80), 0 );
                        }
                        if( code == KEY_PAD_SLASH )
                        {
                                PUT_IN_BUFFER(0xa4, 0);
                        }
                        K26();
                        exit_from_kbd_int();return;
                }
                if( code < F1_KEY )
                {
                        CHECK_AND_PUT_IN_BUFFER(code, 0xf0);
                }
                if( code <= F10_KEY )
                {
                        PUT_IN_BUFFER( (IU8)(code + 45), 0 );
                }
                K26();
                exit_from_kbd_int();return;
        }
        /* NOT IN ALTERNATE SHIFT       */
        if(sas_hw_at_no_check(kb_flag) & CTL_SHIFT)                     /* control shift ?      */
        {
                if( (code == SCROLL_KEY) && ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) || (sas_hw_at_no_check(kb_flag_3) & LC_E0) ) )
                {
                        /* reset buffer to empty        */
                        sas_storew_no_check(BIOS_KB_BUFFER_TAIL, sas_w_at_no_check(BIOS_KB_BUFFER_HEAD));

                        sas_store (bios_break, 0x80);                   /* turn on bios brk bit */
                        outb(KEYBA_STATUS_CMD, ENA_KBD);        /* enable keyboard      */

                        FREEKBDHDW();   /* JonLe NTVDM mod */

                        exec_sw_interrupt(int1b_seg, int1b_off);

                        PUT_IN_BUFFER(0, 0);
                }
                /* TEST FOR PAUSE       */
                if( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) && (code == NUM_KEY))
                {
                        PAUSE();
                        exit_from_kbd_int();return;
                }
                /* TEST SPECIAL CASE KEY 55     */
                if( code == PRINT_SCR_KEY )
                {
                        if ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) || (sas_hw_at_no_check(kb_flag_3) &LC_E0) )
                        {
                                PUT_IN_BUFFER(0x72, 0);
                        }
                }
                else
                {
                        if( code != TAB_KEY )
                        {
                                if( (code == KEY_PAD_SLASH) && (sas_hw_at_no_check(kb_flag_3) & LC_E0) )
                                {
                                        PUT_IN_BUFFER(0x95, 0 );
                                }
                                if( code < F1_KEY )             /* is it in char table? */
                                {
                                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(ctl_n_table+code - 1) );
                                        }
                                        else
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(ctl_n_table+code - 1) );
                                        }
                                }
                        }
                }
                chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
                CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(ctl_n_table+code - 1), chr);
        }
        /* NOT IN CONTROL SHIFT */

        if( code <= CAPS_KEY )
        {
                if( code == PRINT_SCR_KEY )
                {
                        if( ((sas_hw_at_no_check(kb_flag_3) & (KBX + LC_E0)) == (KBX + LC_E0)) ||
                        ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) && (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT))) )
                        {
                                /* print screen */
                                outb(KEYBA_STATUS_CMD, ENA_KBD);
                                outb(0x20, 0x20);

                                FREEKBDHDW();   /* JonLe NTVDM Mod */

                                exec_sw_interrupt(int05_seg, int05_off);

                                sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3)& ~(LC_E0 + LC_E1)));
                                exit_from_kbd_int();return;
                        }
                }
                else
                {
                        if( ((sas_hw_at_no_check(kb_flag_3) & LC_E0) == 0) || (code != KEY_PAD_SLASH))
                        {
                                for( i = 10; i < ALT_TABLE_SIZE; i++ )
                                        if(code == sas_hw_at_no_check(alt_table+i))
                                                break;
                                /* did we find one      */
                                upper = FALSE;
                                if( (i < ALT_TABLE_SIZE) && (sas_hw_at_no_check(kb_flag) & CAPS_STATE) )
                                {
                                        if( (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)) == 0 )
                                                upper = TRUE;
                                }
                                else
                                {
                                        if( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
                                                upper = TRUE;
                                }

                                if (upper)
                                {
                                        /* translate to upper case      */
                                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                                        }
                                        else
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check (uppercase+code - 1) );
                                        }
                                }
                        }
                }
                /* translate to lower case      */
                if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                {
                        CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check (lowercase+code - 1) );
                }
                else
                {
                        CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(lowercase+code - 1) );
                }
        }
        /* TEST FOR KEYS F1 - F10       */
        /* 7.10.92 MG AND TEST FOR F11 AND F12 !!!!
           We were shoving the code for shift-F11 or shift-F12 in if
           you pressed unshifted keys. This has been changed so that all the
           function keys are handled the same way, which is the correct
           procedure.
        */

        if( code > F10_KEY && (code != F11_KEY && code != F12_KEY) )
        {
                if( code > DEL_KEY )
                {
                        if (code == WT_KEY )
                        {
                                if ( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
                                {
                                        /* translate to upper case      */
                                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                                        }
                                        else
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(uppercase+code - 1) );
                                         }
                                }
                                else
                                {
                                        /* translate to lower case      */
                                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(lowercase+code - 1) );
                                        }
                                        else
                                        {
                                                CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(lowercase+code - 1) );
                                        }
                                }
                        }
                        else
                        {
                                if( (code == 76) &&  ((sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)) == 0))
                                {
                                        PUT_IN_BUFFER( code, 0xf0);
                                }
                                /* translate for pseudo scan codes      */
                                chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;

                                /* Should this always be upper case ???? */

                                CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check (uppercase+code - 1), chr);
                        }
                }
                if (
                         (code == KEY_PAD_MINUS) ||
                         (code == KEY_PAD_PLUS) ||
                         ( !(sas_hw_at_no_check(kb_flag_3) & LC_E0) &&
                                 (
                                        ((sas_hw_at_no_check(kb_flag) & (NUM_STATE + LEFT_SHIFT + RIGHT_SHIFT)) == NUM_STATE) ||
                                        (((sas_hw_at_no_check(kb_flag) & NUM_STATE) == 0) && (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)))
                                 )
                         )
                   )
                {
                        /* translate to upper case      */
                        if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
                        {
                                CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                        }
                        else
                        {
                                CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(uppercase+code - 1) );
                        }
                }
        }
        else
        {
                if( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
                {
                        /* translate for pseudo scan codes      */
                        chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
                        CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(uppercase+code - 1), chr);
                }
        }
        if ( code == 76 )
        {
                PUT_IN_BUFFER(code, 0xf0 );
        }
        /* translate for pseudo scan codes      */
        chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
        CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(lowercase+code - 1), chr);

} /* end of keyboard_int() AT version */


void kb_idle_poll()
{
        /*
         * this routine is called from bios assembler routines to
         * cause an idle poll to occur.
         */
        IDLE_poll();
}


#ifdef NTVDM
   /*
    *  Ntvdm has a 16-bit int 16 handler
    *  it requires a few services for idle
    *  detection from softpc...
    *
    */
void keyboard_io()
{
#ifdef JAPAN
   /* make sure we are called by OUR int16 handler in ntio.sys because we
    *  have changed the int 16 function semantics. The Japanese very
    *  popular word processor(Ichitaro) does a far call to 0xf000:e82e,
    *  the standard ROM bios int16 handler address which bypasses the
    *  entire int16 hanlder chain. On X86, it goes to ROM bios. On RISC,
    *  the softpc ROM bios bops to here. A function 3(set typematic) would
    *  cause us to flood tons of toggle keys to the application which could
    *  get choked.
    *  So the cure is to do a simulating to our 16bit handler in
    *  the NTIO.SYS.
    */

#ifndef NEC_98
   if (int16h_caller_seg == 0 || getCS() == int16h_caller_seg) {
#endif    //NEC_98
#endif // JAPAN
   switch (getAH()) {
           /*
            * The 16 bit thread has not reached idle status yet
            * but it is polling the kbd, so do some brief waits.
            */
     case 0:
       WaitIfIdle();
#ifndef NTVDM
       if (!WaitKbdHdw(0)) {
           TryKbdInt();
           HostReleaseKbd();
           }
#endif /* NTVDM */
       break;

           /*
            *  App wants to idle, so consult idle algorithm
            */
     case 1:
       IDLE_poll();
       break;

            /*
             * App is starting a waitio
             */
     case 2:
       IDLE_waitio();
       break;

            /*
             *  update the keyboard lights,
             */
     case 3:
       host_kb_light_on (getAL());
       break;
     }
#if defined(JAPAN)  && !defined(NEC_98)
   }
   else {

        word    SaveCS;
        word    SaveIP;

        SaveIP = getIP();
        SaveCS = getCS();
        setCS(int16h_caller_seg);
        setIP(int16h_caller_off);
        host_simulate();
        setCS(SaveCS);
        setIP(SaveIP);
   }
#endif // JAPAN && !NEC_98
}

#else
void keyboard_io()
{
    /*
     * Request to keyboard.  The AH register holds the type of request:
     *
     * AH == 0          Read an character from the queue - wait if no
     *                  character available.  Return character in AL
     *                  and the scan code in AH.
     *
     * AH == 1          Determine if there is a character in the queue.
     *                  Set ZF = 0 if there is a character and return
     *                  it in AX (but leave it in the queue).
     *
     * AH == 2          Return shift state in AL.
     *
     * For AH = 0 to 2, the value returned in AH is zero. This correction
     * made in r2.69.
     *
     * NB : The order of reference/increment of buffer_head is critical to
     *      ensure we do not upset put_in_buffer().
     *
     *
     * XT-SFD BIOS Extended functions:
     *
     * AH == 5          Place ASCII char/scan code pair (CL / CH)
     *                  into tail of keyboard buffer. Return 0 in
     *                  AL if successful, 1 if buffer already full.
     *
     * AH == 0x10       Extended read for enhanced keyboard.
     *
     * AH == 0x11       Extended function 1 for enhanced keyboard.
     *
     * AH == 0x12       Extended shift status. AL contains kb_flag,
     *                  AH has bits for left/right Alt and Ctrl keys
     *                  from kb_flag_1 and kb_flag_3.
     */
    word        buffer_head,    /* local copy of BIOS data area variable*/
                buffer_tail,    /* local copy of BIOS data area variable*/
                buffer_ptr;     /* pointer into BIOS keyboard buffer    */

#define INT16H_DEC  0x12    /* AH decremented by this if invalid command */

    word        CS_save,        /* CS before recursive CPU call         */
                IP_save;        /* IP before recursive CPU call         */
    half_word   data,           /* byte conyaining typamatic data       */
                status1,        /* temp variables used for storing      */
                status2;        /* status in funtion 0x12               */

    INT         func_index;     /* func_index == AH */


    setZF(0);
    func_index = (INT)getAH();

    note_trace1( BIOS_KB_VERBOSE, "Keyboard BIOS func 0x%x", func_index);


    switch (func_index) {

    case  0x00:                 /* Read next char in Kbd buffer */

        /*
         * The AT emulation of the BIOS uses a recursive CPU to handle
         * the HW interrrupts, so there is no need to set the Zero Flag
         * and return to our CPU (see original xt version )
         */
        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        if (buffer_tail == buffer_head)
        {
                IDLE_waitio();

                setAX(0x9002);
                INT15();        /* call int 15h  - wait function        */
        }

        do
        {
                check_indicators(0);    /* see if LED's need updating   */

                buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
                buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

                if (buffer_tail == buffer_head)
                {
                        CS_save = getCS();
                        IP_save = getIP();

                        /* wait for character in buffer         */

                        do {
                                IDLE_poll();

                                setCS(rcpu_poll_segment);
                                setIP(rcpu_poll_offset);
                                host_simulate();
                                buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
                                buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

                        } while (buffer_tail == buffer_head);


                        setCS(CS_save);
                        setIP(IP_save);
                }

                setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

                buffer_head = inc_buffer_ptr(/* from: */buffer_head);
                sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);

                translate_std();        /*translate scan_code pairs                     */
        }
        while (getCF());                /* if CF set throw code away and start again    */

        setIF(1);

        IDLE_init();

        break;


    case 0x01:                          /* Set ZF to reflect char availability in Kbd buffer */

        do
        {
                check_indicators(1);            /* see if LED's need updating           */
                                                /* and issue an   out 20h,20h           */

                buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
                buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

                setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

                if (buffer_tail == buffer_head)
                {
                        /* buffer empty - set flag and return */
                        IDLE_poll();

                        setZF(1);
                        break;
                }
                else
                        IDLE_init();

                translate_std();        /* translate scan_code pairs, returns CF if throwaway */
                if(getCF())
                {
                        /* throw code away by incrementing pointer      */
                        buffer_head = inc_buffer_ptr(/* from: */buffer_head);
                        sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);
                }
        }
        while (getCF());                /* if CF set -  start again     */
        setIF(1);

        break;


    case 0x02:                          /* AL := Current Shift Status (really "kb_flag") */

        setAH(0);
        setAL(sas_hw_at_no_check(kb_flag));

        break;


    case 0x03:                          /* Alter typematic rate */

        /* check for correct values in registers                */
        if( (getAL() == 5) && !(getBX() & 0xfce0) )
        {
                note_trace1(BIOS_KB_VERBOSE, "\talter typematic rate (BX %#x)\n", getBX());

                send_data(KB_TYPA_RD);
                data = (getBH() << 5) | getBL();
                send_data(data);
        }

        break;


    case 0x05:                          /* Place ASCII + ScanCode in Kbd Buffer */

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        /*
         * check for sufficient space - if no set AL
         */

        buffer_ptr = inc_buffer_ptr(/*from:*/buffer_tail);

        if( buffer_head == buffer_ptr )
             setAL( 1 );
        else {
            /*
             * load CX into buffer and update buffer_tail
             */
            sas_storew_no_check(BIOS_VAR_START + buffer_tail, getCX() );
            sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);
            setAL( 0 );
        }
        setAH( 0 );
        setIF(1);

        break;


    case 0x10:                          /* Extended ASCII Read */

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        if (buffer_tail == buffer_head)
        {
                IDLE_waitio();

                setAX(0x9002);
                INT15();        /* call int 15h  - wait function */
        }
        check_indicators(0);    /* see if LED's need updating */

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        if (buffer_tail == buffer_head)
        {
                CS_save = getCS();
                IP_save = getIP();

                /* wait for character in buffer         */
                while (buffer_tail == buffer_head)
                {
                        IDLE_poll();

                        setCS(rcpu_poll_segment);
                        setIP(rcpu_poll_offset);
                        host_simulate();
                        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
                        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
                }

                IDLE_init();

                setCS(CS_save);
                setIP(IP_save);
        }

        setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head)); /* Pickup the "current" scancode/char pair */

        buffer_head = inc_buffer_ptr(/* from: */buffer_head);
        sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);

        translate_ext();                /* translate scan_code pairs    */

        setIF(1);
        break;


    case 0x11:                          /* Extended ASCII Status        */

        check_indicators(1);            /* see if LED's need updating   */
                                        /* and issue an   out 20h,20h   */

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

        if (buffer_tail == buffer_head) /* No keys pressed */
        {
                setZF(1);
                IDLE_poll();
        }
        else                            /* Keystrokes available! */
        {
                translate_ext();        /* translate scan_code pairs    */
                IDLE_init();
        }

        setIF(1);
        break;


    case 0x12:                          /* Extended Shift Status */

        status1 = sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT;    /* only leave SYS KEY   */
        status1 <<= 5;                                          /* move to bit 7        */
        status2 = sas_hw_at_no_check(kb_flag_1) & 0x73;         /* remove SYS_SHIFT, HOLD,
                                                                   STATE and INS_SHIFT  */
        status1 |= status2;                                     /* merge                */
        status2 = sas_hw_at_no_check(kb_flag_3) & 0x0C;         /* remove LC_E0 & LC_E1 */
        status1 |= status2;                                     /* merge                */
        setAH( status1 );
        setAL( sas_hw_at_no_check(kb_flag) );

        break;


    default:
        setAH((func_index - INT16H_DEC));
        break;
    }
}
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void keyboard_post()
{

     /* Set up BIOS keyboard variables */

#if defined(NEC_98)
    word CS_save, IP_save;
    half_word i;
    half_word data;

    if(HIRESO_MODE){  //Hireso mode system aria Initialize

        sas_storew(BIOS_NEC98_KB_BUFFER_ADR, BIOS_NEC98_KB_KEY_BUFFER);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR+2, 0);
        sas_storew(BIOS_NEC98_KB_HEAD_POINTER, BIOS_NEC98_KB_KEY_BUFFER);
        sas_storew(BIOS_NEC98_KB_TAIL_POINTER, BIOS_NEC98_KB_KEY_BUFFER);

        sas_storew(BIOS_NEC98_KB_INT_ADR, 0x0481);
        sas_storew(BIOS_NEC98_KB_INT_ADR+2, 0xf800);

        sas_store(BIOS_NEC98_KB_RETRY_COUNTER, 0);
        sas_store(BIOS_NEC98_KB_BUFFER_COUNTER, 0);
        sas_store(BIOS_NEC98_KB_SHIFT_STS, 0);

        sas_storew(BIOS_NEC98_KB_BUFFER_SIZ, 0x0010);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR, 0x0484);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR+2, 0xf800);

        for (i=0; i<16 ; i++){
            sas_store(BIOS_NEC98_KB_KEY_STS_TBL+i,0);
        }
        sas_store(BIOS_NEC98_KB_SHIFT_COD, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+1, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+2, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+3, 0x74);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+4, 0x73);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+5, 0x72);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+6, 0x71);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+7, 0x70);

        kbd_outb(KEYBD_STATUS_CMD, 0x3a);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x32);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x16);       //SEND NON_RETRY_COMMAND TO 8251A

    }else{  //Normal mode system aria Initialize


        kbd_outb(KEYBD_STATUS_CMD, 0x3a);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x32);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x16);       //SEND NON_RETRY_COMMAND TO 8251A

        sas_storew(BIOS_NEC98_KB_SHFT_TBL, 0x0b3d);     ///Set offset KB_TRTBL
        sas_storew(BIOS_NEC98_KB_BUF_HEAD, BIOS_NEC98_KB_BUF);
        sas_storew(BIOS_NEC98_KB_BUF_TAIL, BIOS_NEC98_KB_BUF);
        for (i=0; i<19 ; i++){
            sas_store(BIOS_NEC98_KB_COUNT+i,0);  //BIOS_NEC98_KB_COUNT,BIOS_NEC98_KB_RETRY
                                             //BIOS_NEC98_KB_KY_STS
        }                                    //BIOS_NEC98_KB_SHFT_STS

        sas_storew(BIOS_NEC98_KB_CODE, 0x0b3d);        ///Set Offset KB_TRTBL
        sas_storew(BIOS_NEC98_KB_CODE+2, 0xfd80);      ///Set Segment KB_TRTBL

    }

#else    //NEC_98

/* Initialize the keyboard table pointers */
        shift_keys = K6;
        shift_masks = K7;
        ctl_n_table = K8;
        ctl_f_table = K9;
        lowercase = K10;
        uppercase = K11;
        alt_table = K30;

    sas_storew_no_check(BIOS_KB_BUFFER_HEAD, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_TAIL, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_START, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_END, BIOS_KB_BUFFER + 2*BIOS_KB_BUFFER_SIZE);

     /* The following are #defines, referring to locations in BIOS */
     /* data area.                                                 */

        sas_store_no_check (kb_flag,NUM_STATE);
        sas_store_no_check (kb_flag_1,0);
        sas_store_no_check (kb_flag_2,2);
        sas_store_no_check (kb_flag_3,KBX);
        sas_store_no_check (alt_input,0);
#endif    //NEC_98
}

void keyboard_init()
{
        /*
        ** host specific keyboard initialisation
        ** is now before AT base keyboard initialisation
        */
        host_kb_init();

#if defined(CPU_40_STYLE) && !defined (NTVDM)
        ica_iret_hook_control(ICA_MASTER, CPU_KB_INT, TRUE);
#endif
}



#ifdef NTVDM

/*:::::::::::::::::::::::::::::::::::::::::::::::: Map in new keyboard tables */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::: Set interrupt vectors */
/*
** The Microsoft NTIO.SYS calls this func via BOP 5F to pass
** interesting addresses to our C BIOS.
*/

#if defined(MONITOR)

IMPORT UTINY getNtScreenState IPT0();
#endif


void kb_setup_vectors(void)
{
   word        KbdSeg, w;
   word       *pkio_table;
   double_word phy_base;


   KbdSeg     = getDS();
   pkio_table = (word *) effective_addr(getCS(), getSI());

      /* IDLE variables */
    sas_loadw((sys_addr)(pkio_table + 12), &w);
    pICounter             = (word *) (Start_of_M_area + ((KbdSeg<<4)+w));
    pCharPollsPerTick     = (word *) (Start_of_M_area + ((KbdSeg<<4)+w+4));
    pMinConsecutiveTicks = (word *)  (Start_of_M_area + ((KbdSeg<<4)+w+8));

#if defined(MONITOR)
   phy_base   = (double_word)KbdSeg << 4;

     /* key tables */
   shift_keys  =  phy_base + *pkio_table++;
   shift_masks =  phy_base + *pkio_table++;
   ctl_n_table =  phy_base + *pkio_table++;
   ctl_f_table =  phy_base + *pkio_table++;
   lowercase   =  phy_base + *pkio_table++;
   uppercase   =  phy_base + *pkio_table++;
   alt_table   =  phy_base + *pkio_table++;

   dummy_int_seg        = KbdSeg;         /* dummy int, iret routine */
   dummy_int_off        = *pkio_table++;
   int05_seg            = KbdSeg;         /* print screen caller */
   int05_off            = *pkio_table++;
   int15_seg            = KbdSeg;         /* int 15 caller */
   int15_off            = *pkio_table++;
   rcpu_nop_segment     = KbdSeg;         /* cpu nop */
   rcpu_nop_offset      = *pkio_table++;
   sp_int15_handler_seg = KbdSeg;         /* int 15 handler */
   sp_int15_handler_off = *pkio_table++;
   pkio_table++;                          /* iDle variables, done above */
   rcpu_int4A_seg       = KbdSeg;
   rcpu_int4A_off       = *pkio_table++;   /* real time clock */

   int1b_seg    = KbdSeg;         /* kbd break handler */
   int1b_off    = *pkio_table++;
   int10_seg    = KbdSeg;
   int10_caller = *pkio_table++;
   int10_vector = *pkio_table++;

   /*
   ** Address of data in keyboard.sys, Tim August 92.
   **
   ** useHostInt10 is a one byte variable. 1 means use host video BIOS,
   ** (ie. full-screen), 0 means use SoftPC video BIOS (ie. windowed).
   ** babyModeTable is a mini version of the table in ROM that contains
   ** all the VGA register values for all the modes. The keyboard.sys
   ** version only has two entries; for 40 column text mode and 80
   ** column text mode.
   */
   useHostInt10  = *pkio_table++;
   sas_store_no_check((sys_addr)(phy_base + useHostInt10), getNtScreenState());
   babyModeTable = (int10_seg << 4) + *pkio_table++;
   changing_mode_flag = *pkio_table++;  /* indicates trying to change vid mode*/

    /* Initialise printer status table. */
   printer_setup_table(effective_addr(KbdSeg, *pkio_table++));
   wait_int_off = *pkio_table++;
   wait_int_seg = KbdSeg;
   dr_type_seg = KbdSeg;
   dr_type_off = *pkio_table++;
   dr_type_addr = (sys_addr)dr_type_seg * 16L + (sys_addr)dr_type_off;
   vga1b_seg = KbdSeg;
   vga1b_off = *pkio_table++; /* VGA capability table (normally lives in ROM) */
   conf_15_seg = KbdSeg;
   conf_15_off = *pkio_table++; /* INT15 config table (normally in ROM) */

   TimerInt08Seg = KbdSeg;
   TimerInt08Off = *pkio_table++;
   int13h_vector_seg = KbdSeg;
   int13h_caller_seg = KbdSeg;

#if defined(JAPAN) && !defined(NEC_98)
   int16h_caller_seg = KbdSeg;
#endif // JAPAN & !NEC_98

   int13h_vector_off = *pkio_table++;
   int13h_caller_off = *pkio_table++;
// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
   stream_io_buffer_size = *pkio_table++;
   stream_io_buffer = (half_word *)effective_addr(*pkio_table++, 0);
   stream_io_dirty_count_ptr = (word *)effective_addr(KbdSeg, *pkio_table++);
   stream_io_bios_busy_sysaddr = effective_addr(KbdSeg, *pkio_table++);
#ifdef JAPAN
   int16h_caller_off = *pkio_table++;
#endif // JAPAN
#endif    //NEC_98
   // Dos_Flag_Addr = (byte *)effective_addr(*plio_table++, *pkio_table++);
   w = *pkio_table++;
   Dos_Flag_Addr = (byte *)effective_addr(w, *pkio_table++);
#ifndef PROD
   if (*pkio_table != getAX()) {
       always_trace0("ERROR: KbdVectorTable!");
       }
#endif
   TimerInt1CSeg = KbdSeg;
   TimerInt1COff = dummy_int_off;

#else    /* ndef MONITOR */

     /* kbd bios callout optimization */
    sas_loadw(0x15*4,     &sp_int15_handler_off);
    sas_loadw(0x15*4 + 2, &sp_int15_handler_seg);

     /* timer hardware interrupt optimizations */
    sas_loadw(0x08*4,     &TimerInt08Off);
    sas_loadw(0x08*4 + 2, &TimerInt08Seg);
    sas_loadw(0x1C*4,     &TimerInt1COff);
    sas_loadw(0x1C*4 + 2, &TimerInt1CSeg);

    sas_loadw(0x13 * 4, &int13h_vector_off);
    sas_loadw(0x13 * 4 + 2, &int13h_vector_seg);
    int13h_caller_seg = KbdSeg;
    dr_type_seg = KbdSeg;
    sas_loadw((sys_addr)(pkio_table + 27), &int13h_caller_off);
    sas_loadw((sys_addr)(pkio_table + 22), &dr_type_off);
    dr_type_addr = effective_addr(dr_type_seg, dr_type_off);
#if defined(JAPAN) && defined(NTVDM) && !defined(NEC_98)
    int16h_caller_seg = KbdSeg;
    sas_loadw((sys_addr)(pkio_table + 32), &int16h_caller_off);
#endif // JAPAN & NTVDM & !NEC_98

#endif /* MONITOR */

    sas_loadw(0x09*4,     &KbdInt09Off);
    sas_loadw(0x09*4 + 2, &KbdInt09Seg);

    ResumeTimerThread();
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Int15 caller */


/*
 *  Gives chance for other parts of NTVDM to
 *  update the kbd i15 kbd callout optimization
 */
void UpdateKbdInt15(word Seg,word Off)
{
    word int15Off, int15Seg;

    /* make sure nobody has hooked since the last time */
    /* we stored the i15 vector */
    sas_loadw(0x15*4 ,    &int15Off);
    sas_loadw(0x15*4 + 2, &int15Seg);
    if(int15Off != sp_int15_handler_off || int15Seg != sp_int15_handler_seg)
      {
#ifndef PROD
       printf("NTVDM: UpdateKbdInt15 Nuking I15 offsets\n");
#endif
       sp_int15_handler_off = sp_int15_handler_seg = 0;
       return;
       }

    sp_int15_handler_off = Off;
    sp_int15_handler_seg = Seg;
}



IMPORT void (*BIOS[])();

void INT15(void)
{
    ULONG ul;
    word CS_save, IP_save;
    word int15Off, int15Seg;

    /*:::::::::::::::::::::::::::::::::: Get location of current 15h handler */
    sas_loadw(0x15*4 ,    &int15Off);
    sas_loadw(0x15*4 + 2, &int15Seg);

    /*:::::::::::::::::::::: Does the 15h vector point to the softpc handler */
    ul = (ULONG)getAH();
    if((ul == 0x4f || ul == 0x91) &&
       int15Off == sp_int15_handler_off &&
       int15Seg == sp_int15_handler_seg)
    {
        (BIOS[0x15])();             /* Call int15 handler defined in base */
    }
    else
    {
        /*::::::::::::::::::::::::::::::::::::::::::::::: Call int15 handler */
        ul = (ULONG)bBiosOwnsKbdHdw;
        if (bBiosOwnsKbdHdw)  {
            bBiosOwnsKbdHdw = FALSE;
            HostReleaseKbd();
            }
        CS_save = getCS();          /* Save current CS,IP settings */
        IP_save = getIP();
        setCS(int15_seg);
        setIP(int15_off);
        host_simulate();            /* Call int15 handler */
        setCS(CS_save);             /* Restore CS,IP */
        setIP(IP_save);
        if (ul)
            bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
    }
}


/*
 *  32 bit services for kb16.com, the international 16 bit
 *  interrupt 9 service handler.
 *
 */
void Keyb16Request(half_word BopFnCode)
{

        /*
         * upon entry to kb16, take ownership of kbd
         *                     disable the kbd
         *                     disable interrupts
         */
    if (BopFnCode == 1) {
        bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
        outb(KEYBA_STATUS_CMD, DIS_KBD);
        setIF(1);
        }

        /* K26A type exit from i9 handler */
    else if (BopFnCode == 2) {
        if (getBH()) {  /* bl == do beep */
            host_alarm(250000L);
            }

        outb(0x20, 0x20);    /* eoi */

        if (getBL()) {       /* got character ? do device post */
            setAX(0x9102);
            INT15();
            }
        outb(KEYBA_STATUS_CMD, ENA_KBD);
        if (bBiosOwnsKbdHdw) {
            bBiosOwnsKbdHdw = FALSE;
            HostReleaseKbd();
            }
        }

        /* K27A exit notify */
    else if (BopFnCode == 3) {
        outb(0x20, 0x20);
        outb(KEYBA_STATUS_CMD, ENA_KBD);
        if (bBiosOwnsKbdHdw) {
            bBiosOwnsKbdHdw = FALSE;
            HostReleaseKbd();
            }
        }

        /* K27A exit notify */
    else if (BopFnCode == 4) {
        outb(KEYBA_STATUS_CMD, ENA_KBD);
        if (bBiosOwnsKbdHdw) {
            bBiosOwnsKbdHdw = FALSE;
            HostReleaseKbd();
            }
        }
}

#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\ppi.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 3.0
 *
 * Title:	ppi.c
 *
 * Description:	Read/Write port on AT System Board.
 *
 * Author:	Leigh Dworkin
 *
 * Notes:	On the XT this used to be controlled by the
 * Programmable Peripheral Interface adapter, hence the nomenclature.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)ppi.c	1.9 08/10/92 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>

/*
 * SoftPC include files
 */
#include "xt.h"
#include "ios.h"
#include "ppi.h"
#include "timer.h"
#ifndef PROD
#include "trace.h"
#endif
#include "debug.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
 * ============================================================================
 * Static data and defines
 * ============================================================================
 */

/*
 * This holds the current state of the io port
 */

static half_word ppi_register;

#define PPI_BIT_MASK	0x3F1

static boolean gate_2_was_low = TRUE;	/* state of timer 2 gate */
#ifndef NTVDM
static boolean SPKRDATA_was_low = TRUE;	/* speaker data for sound */
#endif

/*
 * ============================================================================
 * Internal functions 
 * ============================================================================
 */

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */

void ppi_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	/*
 	 * The bits are assigned as follows:
 	 *
	 * Bit No	Use										Supported
	 * ------	---										---------
	 * 0-3		Value written to output port bits 0-3	yes
	 * 4		Refresh detect toggle					yes
	 * 5 		Timer 2 output level					no
	 * 6		IO channel error status					yes - 0
	 * 7		RAM parity error status					yes - 0
	 *
	 */

    port = port & PPI_BIT_MASK;		/* clear unused bits */
    ppi_register ^= 0x30;
    *value = ppi_register;

    note_trace2(PPI_VERBOSE, "ppi_inb() - port %x, returning val %x", port, *value);
#endif   //NEC_98
}

void ppi_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
    port = port & PPI_BIT_MASK;		/* clear unused bits */

    if (port == PPI_GENERAL)
    {
		ppi_register = value & 0x0f;

        note_trace2(PPI_VERBOSE, "ppi_outb() - port %x, val %x", port, value);
	/*
 	 * The bits are assigned as follows:
 	 *
	 * Bit No	Use							Supported
	 * ------	---							---------
	 * 0		Timer Gate to speaker		Yes 
	 * 1		Speaker Data				Yes
	 * 2 		Enable RAM Parity Check		No need - always OK
	 * 3		Enable I/0 Check			No need - always OK
	 * 4-7		Not used.
	 *
	 */

	/*
	 * Tell sound logic whether sound is enabled or not
	 */

#ifndef NTVDM
		if ( (value & 0x02) && SPKRDATA_was_low)
		{
			host_enable_timer2_sound();
			SPKRDATA_was_low = FALSE;
		}
		else
		if ( !(value & 0x02) && !SPKRDATA_was_low)
		{
			host_disable_timer2_sound();
			SPKRDATA_was_low = TRUE;
		}
#endif

		/*
		 * Now gate the ppi signal to the timer.
		 */
	
		if ( (value & 0x01) && gate_2_was_low)
		{

		    timer_gate(TIMER2_REG, GATE_SIGNAL_RISE); 
		    gate_2_was_low = FALSE;
		}
		else
		if ( !(value & 0x01) && !gate_2_was_low)
	
		{
		    timer_gate(TIMER2_REG, GATE_SIGNAL_LOW); 
		    gate_2_was_low = TRUE;
		}
#ifdef NTVDM
                /*
                 *  Tell the host the full PpiState because this effects
                 *  whether we are playing Timer 2 Freq, Ppi Freq or both.
                 *  Do this after calling timer_gate to avoid playing old
                 *  frequencies.
                 */
                HostPpiState(value);
#endif	
	}
    else
	    note_trace2(PPI_VERBOSE, "ppi_outb() - Value %x to unsupported port %x", value, port);
#endif   //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void ppi_init IFN0()
{
#ifndef NEC_98
    io_addr i;
    io_define_inb(PPI_ADAPTOR, ppi_inb);
    io_define_outb(PPI_ADAPTOR, ppi_outb);

    for(i = PPI_PORT_START+1; i <= PPI_PORT_END; i+=2)
		io_connect_port(i, PPI_ADAPTOR, IO_READ_WRITE);

    ppi_register = 0x00;
#endif   //NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\mouse_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : Mouse Driver Emulation
 *
 * Emulated Version     : 8.00
 *
 *
 * Description  : This module provides an emulation of the Microsoft
 *                Mouse Driver: the module is accessed using the following
 *                BOP calls from the BIOS:
 *
 *              mouse_install1()        | Mouse Driver install
 *              mouse_install2()        | routines
 *
 *              mouse_int1()            | Mouse Driver hardware interrupt
 *              mouse_int2()            | handling routines
 *
 *              mouse_io_interrupt()    | Mouse Driver io function assembler
 *              mouse_io_language()     | and high-level language interfaces
 *
 *              mouse_video_io()        | Intercepts video io function
 *
 *                Since a mouse driver can only be installed AFTER the
 *                operating system has booted, a small Intel program must
 *                run to enable the Insignia Mouse Driver. This program
 *                calls BOP mouse_install2 if an existing mouse driver
 *                is detected; otherwise BOP mouse_install1 is called to
 *                start the Insignia Mouse Driver.
 *
 *                When the Insignia Mouse Driver is enabled, interrupts
 *                are processed as follows
 *
 *              INT 0A (Mouse hardware interrupt)       BOP mouse_int1-2
 *              INT 10 (Video IO interrupt)             BOP mouse_video_io
 *              INT 33 (Mouse IO interrupt)             BOP mouse_io_interrupt
 *
 *                High-level languages can call a mouse io entry point 2 bytes
 *                above the interrupt entry point: this call is handled
 *                using a BOP mouse_io_language.
 *
 * Author       : Ross Beresford
 *
 * Notes        : The functionality of the Mouse Driver was established
 *                from the following sources:
 *                   Microsoft Mouse User's Guide
 *                   IBM PC-XT Technical Reference Manuals
 *                   Microsoft InPort Technical Note
 *
 */

/*
 * static char SccsID[]="07/04/95 @(#)mouse_io.c        1.72 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_MOUSE.seg"
#endif


/*
 *    O/S include files.
 */

#include <stdio.h>
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "ios.h"
#include "bios.h"
#include "sas.h"
#include CpuH
#include "trace.h"
#include "debug.h"
#include "gvi.h"
#include "cga.h"
#ifdef EGG
#include "egacpu.h"
#include "egaports.h"
#include "egavideo.h"
#endif
#include "error.h"
#include "config.h"
#include "mouse_io.h"
#include "ica.h"
#include "video.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "egagraph.h"
#include "vgaports.h"
#include "keyboard.h"
#include "virtual.h"

#ifdef NTVDM
#include "nt_event.h"
#include "nt_mouse.h"

#ifdef MONITOR
/*
 * We're running with real ROMs on the monitor and so all the hard coded ROM
 * addresses defined below don't work. Pick up the real addresses of this stuff
 * which is now resident in the driver and put it into the MOUSE_ tokens which
 * have been magically changed into variables.
 */
#undef MOUSE_INT1_SEGMENT
#undef MOUSE_INT1_OFFSET
#undef MOUSE_INT2_SEGMENT
#undef MOUSE_INT2_OFFSET
#undef MOUSE_IO_INTERRUPT_OFFSET
#undef MOUSE_IO_INTERRUPT_SEGMENT
#undef MOUSE_VIDEO_IO_OFFSET
#undef MOUSE_VIDEO_IO_SEGMENT
#undef MOUSE_COPYRIGHT_SEGMENT
#undef MOUSE_COPYRIGHT_OFFSET
#undef MOUSE_VERSION_SEGMENT
#undef MOUSE_VERSION_OFFSET
#undef VIDEO_IO_SEGMENT
#undef VIDEO_IO_RE_ENTRY

LOCAL word   MOUSE_INT1_SEGMENT, MOUSE_INT1_OFFSET,
             MOUSE_IO_INTERRUPT_OFFSET, MOUSE_IO_INTERRUPT_SEGMENT,
             MOUSE_VIDEO_IO_SEGMENT, MOUSE_VIDEO_IO_OFFSET,
             MOUSE_COPYRIGHT_SEGMENT, MOUSE_COPYRIGHT_OFFSET,
             MOUSE_VERSION_SEGMENT, MOUSE_VERSION_OFFSET,
             MOUSE_INT2_SEGMENT, MOUSE_INT2_OFFSET,
             VIDEO_IO_SEGMENT,  VIDEO_IO_RE_ENTRY;

/* @ACW */
word DRAW_FS_POINTER_OFFSET; /* holds segment:offset for the Intel code which */
word DRAW_FS_POINTER_SEGMENT;/* draws the fullscreen mouse cursor */
word POINTER_ON_OFFSET;
word POINTER_ON_SEGMENT;
word POINTER_OFF_OFFSET;
word POINTER_OFF_SEGMENT;
WORD F0_OFFSET,F0_SEGMENT;
word F9_OFFSET,F9_SEGMENT;
word CP_X_O,CP_Y_O;
word CP_X_S,CP_Y_S;
word savedtextsegment,savedtextoffset;
word button_off,button_seg;
#ifdef JAPAN
sys_addr saved_ac_sysaddr = 0, saved_ac_flag_sysaddr = 0;
#endif // JAPAN

static word mouseINBsegment, mouseINBoffset;
static word mouseOUTBsegment, mouseOUTBoffset;
static word mouseOUTWsegment, mouseOUTWoffset;
sys_addr mouseCFsysaddr;
sys_addr conditional_off_sysaddr;

#endif  /* MONITOR */

extern void host_simulate();

void GLOBAL mouse_ega_mode(int curr_video_mode);

IMPORT void host_m2p_ratio(word *,word *,word *,word *);
IMPORT void host_x_range(word *,word *,word *,word *);
IMPORT void host_y_range(word *,word *,word *,word *);
void   host_show_pointer(void);
void   host_hide_pointer(void);
GLOBAL  VOID    host_os_mouse_pointer(MOUSE_CURSOR_STATUS *,MOUSE_CALL_MASK *,
                                      MOUSE_VECTOR *);

LOCAL word              saved_int71_segment;
LOCAL word              saved_int71_offset;

#endif /* NTVDM */

#include "host_gfx.h"

#ifdef MOUSE_16_BIT
#include HostHwVgaH
#include "hwvga.h"
#include "mouse16b.h"
#endif          /* MOUSE_16_BIT */

/*
 * Tidy define to optimise port accesses, motivated by discovering
 * how bad it is to run out of register windows on the SPARC.
 */

#ifdef CPU_40_STYLE

/* IO virtualisation is essential - no optimisation allowed. */
#define OUTB(port, val) outb(port, val)

#else

IMPORT VOID (**get_outb_ptr())();
#define OUTB(port, val) (**get_outb_ptr(port))(port, val)

#endif /* CPU_40_STYLE */

/*
   Offsets to data buffers held in MOUSE.COM (built from
   base/intel/mouse/uf.mouse.asm).
 */
#define OFF_HOOK_POSN        0x103
#define OFF_ACCL_BUFFER      0x105
#define OFF_MOUSE_INI_BUFFER 0x249

/*
   Data values for mouse functions.
 */
#define MOUSE_M1 (0xffff)
#define MOUSE_M2 (0xfffe)

#define MAX_NR_VIDEO_MODES 0x7F

#ifdef EGG
LOCAL BOOL jap_mouse=FALSE;             /* flag if need to fake text cursor */
IMPORT IU8 Currently_emulated_video_mode; /* as set in ega_set_mode() */
#endif /* EGG */

/*
 *      MOUSE DRIVER LOCAL STATE DATA
 *      =============================
 */

/*
 *      Function Declarations
 */
LOCAL void mouse_reset IPT4(word *,installed_ptr,word *,nbuttons_ptr,word *,junk3,word *,junk4);

LOCAL void mouse_show_cursor IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_hide_cursor IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_get_position IPT4(word *,junk1,MOUSE_STATE *,button_status_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_set_position IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_get_press IPT4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_get_release IPT4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_set_range_x IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_x_ptr,MOUSE_SCALAR *,maximum_x_ptr);

LOCAL void mouse_set_range_y IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_y_ptr,MOUSE_SCALAR *,maximum_y_ptr);

LOCAL void mouse_set_graphics IPT4(word *,junk1,MOUSE_SCALAR *,hot_spot_x_ptr,MOUSE_SCALAR *,hot_spot_y_ptr,word *,bitmap_address);

LOCAL void mouse_set_text IPT4(word *,junk1,MOUSE_STATE *,text_cursor_type_ptr,MOUSE_SCREEN_DATA *,parameter1_ptr,MOUSE_SCREEN_DATA *,parameter2_ptr);

LOCAL void mouse_read_motion IPT4(word *,junk1,word *,junk2,MOUSE_COUNT *,motion_count_x_ptr,MOUSE_COUNT *,motion_count_y_ptr);

LOCAL void mouse_set_subroutine IPT4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address);

LOCAL void mouse_light_pen_on IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_light_pen_off IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_set_ratio IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,ratio_x_ptr,MOUSE_SCALAR *,ratio_y_ptr);

LOCAL void mouse_conditional_off IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,upper_x_ptr,MOUSE_SCALAR *,upper_y_ptr);

LOCAL void mouse_unrecognised IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_double_speed IPT4(word *,junk1,word *,junk2,word *,junk3,word *,threshold_speed);

LOCAL void mouse_get_and_set_subroutine IPT4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address);

LOCAL void mouse_get_state_size IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_save_state IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_restore_state IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_alt_subroutine IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_alt_subroutine IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_sensitivity IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_sensitivity IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_int_rate IPT4(word *,m1,word *,int_rate_ptr,word *,m3,word *,m4);

LOCAL void mouse_set_pointer_page IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_pointer_page IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_driver_disable IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_driver_enable IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_language IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_language IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_info IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_driver_info IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_max_coords IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_masks_and_mickeys IPT4
   (
   MOUSE_SCREEN_DATA *, screen_mask_ptr,        /* aka start line */
   MOUSE_SCREEN_DATA *, cursor_mask_ptr,        /* aka stop line */
   MOUSE_SCALAR *,      raw_horiz_count,
   MOUSE_SCALAR *,      raw_vert_count
   ); /* FUNC 39 */

LOCAL void mouse_set_video_mode IPT4
   (
   word *, m1,
   word *, m2,
   word *, video_mode_ptr,
   word *, font_size_ptr
   ); /* FUNC 40 */

LOCAL void mouse_enumerate_video_modes IPT4
   (
   word *, m1,
   word *, m2,
   word *, video_nr_ptr,
   word *, offset_ptr
   ); /* FUNC 41 */

LOCAL void mouse_get_cursor_hot_spot IPT4
   (
   word *,         fCursor_ptr,
   MOUSE_SCALAR *, hot_spot_x_ptr,
   MOUSE_SCALAR *, hot_spot_y_ptr,
   word *,         mouse_type_ptr
   ); /* FUNC 42 */

LOCAL void mouse_load_acceleration_curves IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 43 */

LOCAL void mouse_read_acceleration_curves IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 44 */

LOCAL void mouse_set_get_active_acceleration_curve IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 45 */

LOCAL void mouse_microsoft_internal IPT4
   (
   word *, m1,
   word *, m2,
   word *, m3,
   word *, m4
   ); /* FUNC 46 */

LOCAL void mouse_hardware_reset IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, m4
   );   /* FUNC 47 */

LOCAL void mouse_set_get_ballpoint_info IPT4
   (
   word *, status_ptr,
   word *, rotation_angle_ptr,
   word *, button_mask_ptr,
   word *, m4
   );   /* FUNC 48 */

LOCAL void mouse_get_min_max_virtual_coords IPT4
   (
   MOUSE_SCALAR *, min_x_ptr,
   MOUSE_SCALAR *, min_y_ptr,
   MOUSE_SCALAR *, max_x_ptr,
   MOUSE_SCALAR *, max_y_ptr
   ); /* FUNC 49 */

LOCAL void mouse_get_active_advanced_functions IPT4
   (
   word *, active_flag1_ptr,
   word *, active_flag2_ptr,
   word *, active_flag3_ptr,
   word *, active_flag4_ptr
   ); /* FUNC 50 */

LOCAL void mouse_get_switch_settings IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, buffer_length_ptr,
   word *, offset_ptr
   ); /* FUNC 51 */

LOCAL void mouse_get_mouse_ini IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, offset_ptr
   ); /* FUNC 52 */

LOCAL void do_mouse_function IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void load_acceleration_curve IPT3
   (
   word, seg,
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve
   );

LOCAL void store_acceleration_curve IPT3
   (
   word, seg,
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve
   );

LOCAL void mouse_EM_move IPT0();

LOCAL void mouse_update IPT1(MOUSE_CALL_MASK, event_mask);

LOCAL void cursor_undisplay IPT0();

LOCAL void cursor_mode_change IPT1(int,new_mode);

LOCAL void inport_get_event IPT1(MOUSE_INPORT_DATA *,event);

LOCAL void cursor_update IPT0();

LOCAL void jump_to_user_subroutine IPT3(MOUSE_CALL_MASK,condition_mask,word,segment,word,offset);

LOCAL void cursor_display IPT0();

LOCAL void inport_reset IPT0();

GLOBAL void software_text_cursor_display IPT0();

GLOBAL void software_text_cursor_undisplay IPT0();

GLOBAL void hardware_text_cursor_display IPT0();

GLOBAL void hardware_text_cursor_undisplay IPT0();

LOCAL void graphics_cursor_display IPT0();

LOCAL void graphics_cursor_undisplay IPT0();

LOCAL void      get_screen_size IPT0();

LOCAL void clean_all_regs IPT0();

LOCAL void dirty_all_regs IPT0();

LOCAL void copy_default_graphics_cursor IPT0();

#ifdef EGG
LOCAL VOID VGA_graphics_cursor_display IPT0();
LOCAL VOID VGA_graphics_cursor_undisplay IPT0();
void LOCAL EGA_graphics_cursor_undisplay IPT0();
void LOCAL EGA_graphics_cursor_display IPT0();
#endif

#ifdef HERC
LOCAL void HERC_graphics_cursor_display IPT0();
LOCAL void HERC_graphics_cursor_undisplay IPT0();
#endif /* HERC */

void (*mouse_int1_action) IPT0();
void (*mouse_int2_action) IPT0();


        /* jump table */
SAVED void (*mouse_function[MOUSE_FUNCTION_MAXIMUM])() =
{
        /*  0 */ mouse_reset,
        /*  1 */ mouse_show_cursor,
        /*  2 */ mouse_hide_cursor,
        /*  3 */ mouse_get_position,
        /*  4 */ mouse_set_position,
        /*  5 */ mouse_get_press,
        /*  6 */ mouse_get_release,
        /*  7 */ mouse_set_range_x,
        /*  8 */ mouse_set_range_y,
        /*  9 */ mouse_set_graphics,
        /* 10 */ mouse_set_text,
        /* 11 */ mouse_read_motion,
        /* 12 */ mouse_set_subroutine,
        /* 13 */ mouse_light_pen_on,
        /* 14 */ mouse_light_pen_off,
        /* 15 */ mouse_set_ratio,
        /* 16 */ mouse_conditional_off,
        /* 17 */ mouse_unrecognised,
        /* 18 */ mouse_unrecognised,
        /* 19 */ mouse_set_double_speed,
        /* 20 */ mouse_get_and_set_subroutine,
        /* 21 */ mouse_get_state_size,
        /* 22 */ mouse_save_state,
        /* 23 */ mouse_restore_state,
        /* 24 */ mouse_set_alt_subroutine,
        /* 25 */ mouse_get_alt_subroutine,
        /* 26 */ mouse_set_sensitivity,
        /* 27 */ mouse_get_sensitivity,
        /* 28 */ mouse_set_int_rate,
        /* 29 */ mouse_set_pointer_page,
        /* 30 */ mouse_get_pointer_page,
        /* 31 */ mouse_driver_disable,
        /* 32 */ mouse_driver_enable,
        /* 33 */ mouse_reset,
        /* 34 */ mouse_set_language,
        /* 35 */ mouse_get_language,
        /* 36 */ mouse_get_info,
        /* 37 */ mouse_get_driver_info,
        /* 38 */ mouse_get_max_coords,
        /* 39 */ mouse_get_masks_and_mickeys,
        /* 40 */ mouse_set_video_mode,
        /* 41 */ mouse_enumerate_video_modes,
        /* 42 */ mouse_get_cursor_hot_spot,
        /* 43 */ mouse_load_acceleration_curves,
        /* 44 */ mouse_read_acceleration_curves,
        /* 45 */ mouse_set_get_active_acceleration_curve,
        /* 46 */ mouse_microsoft_internal,
        /* 47 */ mouse_hardware_reset,
        /* 48 */ mouse_set_get_ballpoint_info,
        /* 49 */ mouse_get_min_max_virtual_coords,
        /* 50 */ mouse_get_active_advanced_functions,
        /* 51 */ mouse_get_switch_settings,
        /* 52 */ mouse_get_mouse_ini,
};


/*
 *      Mickey to Pixel Ratio Declarations
 */

        /* NB all mouse gears are scaled by MOUSE_RATIO_SCALE_FACTOR */
LOCAL MOUSE_VECTOR mouse_gear_default =
{
        MOUSE_RATIO_X_DEFAULT,
        MOUSE_RATIO_Y_DEFAULT
};

/*
 *      Sensitivity declarations
 */

#define mouse_sens_calc_val(sens)                                                                               \
/* This macro converts a sensitivity request (1-100) to a multiplier value */                                   \
        (MOUSE_SCALAR)(                                                                                                 \
         (sens < MOUSE_SENS_DEF) ?                                                                              \
                ((IS32)MOUSE_SENS_MIN_VAL + ( ((IS32)sens - (IS32)MOUSE_SENS_MIN)*(IS32)MOUSE_SENS_MULT *       \
                                        ((IS32)MOUSE_SENS_DEF_VAL - (IS32)MOUSE_SENS_MIN_VAL) /                 \
                                        ((IS32)MOUSE_SENS_DEF     - (IS32)MOUSE_SENS_MIN) ) )                   \
        :                                                                                                       \
                ((IS32)MOUSE_SENS_DEF_VAL + ( ((IS32)sens - (IS32)MOUSE_SENS_DEF)*(IS32)MOUSE_SENS_MULT *       \
                                        ((IS32)MOUSE_SENS_MAX_VAL - (IS32)MOUSE_SENS_DEF_VAL) /                 \
                                        ((IS32)MOUSE_SENS_MAX     - (IS32)MOUSE_SENS_DEF) ) )                   \
        )

/*
 *      Text Cursor Declarations
 */

LOCAL MOUSE_SOFTWARE_TEXT_CURSOR software_text_cursor_default =
{
        MOUSE_TEXT_SCREEN_MASK_DEFAULT,
        MOUSE_TEXT_CURSOR_MASK_DEFAULT
};

/*
 *      Graphics Cursor Declarations
 */
LOCAL MOUSE_GRAPHICS_CURSOR graphics_cursor_default =
{
        {
                MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT,
                MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT
        },
        {
                MOUSE_GRAPHICS_CURSOR_WIDTH,
                MOUSE_GRAPHICS_CURSOR_DEPTH
        },
        MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT,
        MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT
};

        /* grid the cursor must lie on */
LOCAL MOUSE_VECTOR cursor_grids[MOUSE_VIDEO_MODE_MAXIMUM] =
{
        { 16, 8 },      /* mode 0 */
        { 16, 8 },      /* mode 1 */
        {  8, 8 },      /* mode 2 */
        {  8, 8 },      /* mode 3 */
        {  2, 1 },      /* mode 4 */
        {  2, 1 },      /* mode 5 */
        {  1, 1 },      /* mode 6 */
        {  8, 8 },      /* mode 7 */
#ifdef EGG
        {  0, 0 },      /* mode 8, not on EGA */
        {  0, 0 },      /* mode 9, not on EGA */
        {  0, 0 },      /* mode A, not on EGA */
        {  0, 0 },      /* mode B, not on EGA */
        {  0, 0 },      /* mode C, not on EGA */
        {  2, 1 },      /* mode D */
        {  1, 1 },      /* mode E */
        {  1, 1 },      /* mode F */
        {  1, 1 },      /* mode 10 */
#endif
#ifdef VGG
        {  1, 1 },      /* mode 11 */
        {  1, 1 },      /* mode 12 */
        {  2, 1 },      /* mode 13 */
#endif
};
#ifdef V7VGA
LOCAL MOUSE_VECTOR v7text_cursor_grids[6] =
{
        {  8, 8 },      /* mode 40 */
        {  8, 14 },     /* mode 41 */
        {  8, 8 },      /* mode 42 */
        {  8, 8 },      /* mode 43 */
        {  8, 8 },      /* mode 44 */
        {  8, 14 },     /* mode 45 */
};
LOCAL MOUSE_VECTOR v7graph_cursor_grids[10] =
{
        {  1, 1 },      /* mode 60 */
        {  1, 1 },      /* mode 61 */
        {  1, 1 },      /* mode 62 */
        {  1, 1 },      /* mode 63 */
        {  1, 1 },      /* mode 64 */
        {  1, 1 },      /* mode 65 */
        {  1, 1 },      /* mode 66 */
        {  1, 1 },      /* mode 67 */
        {  1, 1 },      /* mode 68 */
        {  1, 1 },      /* mode 69 */
};
#endif /* V7VGA */

        /* grid for light pen response */
LOCAL MOUSE_VECTOR text_grids[MOUSE_VIDEO_MODE_MAXIMUM] =
{
        { 16, 8 },      /* mode 0 */
        { 16, 8 },      /* mode 1 */
        {  8, 8 },      /* mode 2 */
        {  8, 8 },      /* mode 3 */
        { 16, 8 },      /* mode 4 */
        { 16, 8 },      /* mode 5 */
        {  8, 8 },      /* mode 6 */
        {  8, 8 },      /* mode 7 */
#ifdef EGG
        {  0, 0 },      /* mode 8, not on EGA */
        {  0, 0 },      /* mode 9, not on EGA */
        {  0, 0 },      /* mode A, not on EGA */
        {  0, 0 },      /* mode B, not on EGA */
        {  0, 0 },      /* mode C, not on EGA */
        {  8, 8 },      /* mode D */
        {  8, 8 },      /* mode E */
        {  8, 14 },     /* mode F */
        {  8, 14 },     /* mode 10 */
#endif
#ifdef VGG
        {  8, 8 },      /* mode 11 */
        {  8, 8 },      /* mode 12 */
        {  8, 16 },     /* mode 13 */
#endif
};
#ifdef V7VGA
LOCAL MOUSE_VECTOR v7text_text_grids[6] =
{
        {  8, 8 },      /* mode 40 */
        {  8, 14 },     /* mode 41 */
        {  8, 8 },      /* mode 42 */
        {  8, 8 },      /* mode 43 */
        {  8, 8 },      /* mode 44 */
        {  8, 14 },     /* mode 45 */
};
LOCAL MOUSE_VECTOR v7graph_text_grids[10] =
{
        {  8, 8 },      /* mode 60 */
        {  8, 8 },      /* mode 61 */
        {  8, 8 },      /* mode 62 */
        {  8, 8 },      /* mode 63 */
        {  8, 8 },      /* mode 64 */
        {  8, 8 },      /* mode 65 */
        {  8, 16 },     /* mode 66 */
        {  8, 16 },     /* mode 67 */
        {  8, 8 },      /* mode 68 */
        {  8, 8 },      /* mode 69 */
};
#endif /* V7VGA */

/* Default acceleration curve */
LOCAL ACCELERATION_CURVE_DATA default_acceleration_curve =
   {
   /* length */
   {  1,  8, 12, 16 },
   /* mickey counts */
   {{  1, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   5,   9,  13,  17,  21,  25,  29,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   4,   7,  10,  13,  16,  19,  22,
      25,  28,  31,  34, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   3,   5,   7,   9,  11,  13,  15,
      17,  19,  21,  23,  25,  27,  29,  31,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127}},
   /* scale factors */
   {{ 16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      48,  52,  56,  60,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      48,  52,  56,  60,  64,  68,  72,  76,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16}},
   /* names */
   {{'V', 'a', 'n', 'i', 'l', 'l', 'a',   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'S', 'l', 'o', 'w',   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'N', 'o', 'r', 'm', 'a', 'l',   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'F', 'a', 's', 't',   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0}},
   };

#ifndef NEC_98
        /* used to get current video page size */
#define video_page_size() (sas_w_at(VID_LEN))

        /* check if page requested is valid */
#define is_valid_page_number(pg) ((pg) < vd_mode_table[sas_hw_at(vd_video_mode)].npages)
#endif // !NEC_98

/*
 *      Mouse Driver Version
 */

LOCAL half_word mouse_emulated_release  = 0x08;
LOCAL half_word mouse_emulated_version  = 0x00;
LOCAL half_word mouse_io_rev;                   /* Filled in from SCCS ID */
LOCAL half_word mouse_com_rev;                  /* Passed in from MOUSE.COM */

LOCAL char              *mouse_id        = "%s Mouse %d.01 installed\015\012";
LOCAL char              *mouse_installed = "%s Mouse %d.01 already installed\015\012";

/*
 *      Context save stuff
 */
        /* magic cookie for saved context */
LOCAL char mouse_context_magic[] = "ISMMC"; /* Insignia Solutions Mouse Magic Cookie */
#define MOUSE_CONTEXT_MAGIC_SIZE        5
#define MOUSE_CONTEXT_CHECKSUM_SIZE     1

/* size of our context (in bytes) */
#define mouse_context_size (MOUSE_CONTEXT_MAGIC_SIZE + sizeof(MOUSE_CONTEXT) + \
                            MOUSE_CONTEXT_CHECKSUM_SIZE)


LOCAL half_word mouse_interrupt_rate;


/*
   Handle to data instanced for each Virtual Machine.
 */
MM_INSTANCE_DATA_HANDLE mm_handle;

static initial_mouse_screen_mask[MOUSE_GRAPHICS_CURSOR_DEPTH] =
   MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT;

static initial_mouse_cursor_mask[MOUSE_GRAPHICS_CURSOR_DEPTH] =
   MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT;

extern void host_memset(char *, char, int);

/* Initialisation and Termination Procedures */
GLOBAL void mouse_driver_initialisation IFN0()
   {
   int i;

   /* Set up instance memory */
   mm_handle = (MM_INSTANCE_DATA_HANDLE)NIDDB_Allocate_Instance_Data(
                  sizeof(MM_INSTANCE_DATA),
                  (NIDDB_CR_CALLBACK)0,
                  (NIDDB_TM_CALLBACK)0);

   if ( mm_handle == (MM_INSTANCE_DATA_HANDLE)0 )
      {
      host_error(EG_OWNUP, ERR_QUIT,
                 "mouse_io: NIDDB_Allocate_Instance_Data() failed.");
      }

   /* TMM: belt and braces fix, some variables don't get set to zero when perhaps they should */
   host_memset ((char *)(*mm_handle), 0, sizeof(MM_INSTANCE_DATA));

   /* Initialise Variables */
   for ( i = 0; i < MOUSE_BUTTON_MAXIMUM; i++)
      {
      button_transitions[i].press_position.x = 0;
      button_transitions[i].press_position.y = 0;
      button_transitions[i].release_position.x = 0;
      button_transitions[i].release_position.y = 0;
      button_transitions[i].press_count = 0;
      button_transitions[i].release_count = 0;
      }

   mouse_gear.x = MOUSE_RATIO_X_DEFAULT;
   mouse_gear.y = MOUSE_RATIO_Y_DEFAULT;

   mouse_sens.x = MOUSE_SENS_DEF;
   mouse_sens.y = MOUSE_SENS_DEF;

   mouse_sens_val.x = MOUSE_SENS_DEF_VAL;
   mouse_sens_val.y = MOUSE_SENS_DEF_VAL;

   mouse_double_thresh = MOUSE_DOUBLE_DEF;
   text_cursor_type = MOUSE_TEXT_CURSOR_TYPE_SOFTWARE;

   software_text_cursor.screen = MOUSE_TEXT_SCREEN_MASK_DEFAULT;
   software_text_cursor.cursor = MOUSE_TEXT_CURSOR_MASK_DEFAULT;

   graphics_cursor.hot_spot.x = MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT;
   graphics_cursor.hot_spot.y = MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT;
   graphics_cursor.size.x = MOUSE_GRAPHICS_CURSOR_WIDTH;
   graphics_cursor.size.y = MOUSE_GRAPHICS_CURSOR_DEPTH;

   for (i = 0; i < MOUSE_GRAPHICS_CURSOR_DEPTH; i++)
      {
      graphics_cursor.screen[i] = (USHORT)initial_mouse_screen_mask[i];
      graphics_cursor.cursor[i] = (USHORT)initial_mouse_cursor_mask[i];
      }

   user_subroutine_segment = 0;
   user_subroutine_offset = 0;
   user_subroutine_call_mask = 0;

   /* TMM: Flag the alternative user subroutines as not initialised */
   alt_user_subroutines_active = FALSE;
   for (i = 0; i < NUMBER_ALT_SUBROUTINES; i++)
   {
           alt_user_subroutine_segment [i] = 0;
           alt_user_subroutine_offset [i]= 0;
           alt_user_subroutine_call_mask [i] = 0;
   }

   black_hole.top_left.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole.top_left.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;
   black_hole.bottom_right.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole.bottom_right.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;

   double_speed_threshold = MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT;
   cursor_flag = MOUSE_CURSOR_DEFAULT;

   cursor_status.position.x = MOUSE_VIRTUAL_SCREEN_WIDTH / 2;
   cursor_status.position.y = MOUSE_VIRTUAL_SCREEN_DEPTH / 2;
   cursor_status.button_status = 0;

   cursor_window.top_left.x = cursor_window.top_left.y = 0;
   cursor_window.bottom_right.x = cursor_window.bottom_right.y = 0;

   light_pen_mode = TRUE;

   mouse_motion.x = 0;
   mouse_motion.y = 0;
   mouse_raw_motion.x = 0;
   mouse_raw_motion.y = 0;

   /* Reset to default curve */
   active_acceleration_curve = 3;   /* Back to Normal */

   memcpy(&acceleration_curve_data, &default_acceleration_curve,
      sizeof(ACCELERATION_CURVE_DATA));

   next_video_mode = 0;   /* reset video mode enumeration */

   point_set(&cursor_position_default, MOUSE_VIRTUAL_SCREEN_WIDTH / 2,
                                       MOUSE_VIRTUAL_SCREEN_DEPTH / 2);

   point_set(&cursor_position, MOUSE_VIRTUAL_SCREEN_WIDTH / 2,
                               MOUSE_VIRTUAL_SCREEN_DEPTH / 2);

   point_set(&cursor_fractional_position, 0, 0);
   cursor_page = 0;

   mouse_driver_disabled = FALSE;
   text_cursor_background = 0;

   for ( i = 0; i < MOUSE_GRAPHICS_CURSOR_DEPTH; i++)
      graphics_cursor_background[i] = 0;

   save_area_in_use = FALSE;
   point_set(&save_position, 0, 0);

   save_area.top_left.x = save_area.top_left.y = 0;
   save_area.bottom_right.x = save_area.bottom_right.y = 0;

   user_subroutine_critical = FALSE;
   last_condition_mask = 0;

   virtual_screen.top_left.x = MOUSE_VIRTUAL_SCREEN_ORIGIN_X;
   virtual_screen.top_left.y = MOUSE_VIRTUAL_SCREEN_ORIGIN_Y;
   virtual_screen.bottom_right.x = MOUSE_VIRTUAL_SCREEN_WIDTH;
   virtual_screen.bottom_right.y = MOUSE_VIRTUAL_SCREEN_DEPTH;

   cursor_grid.x = 8;
   cursor_grid.y = 8;

   text_grid.x = 8;
   text_grid.y = 8;

   black_hole_default.top_left.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole_default.top_left.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;
   black_hole_default.bottom_right.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole_default.bottom_right.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;

#ifdef HERC
   HERC_graphics_virtual_screen.top_left.x = 0;
   HERC_graphics_virtual_screen.top_left.y = 0;
   HERC_graphics_virtual_screen.bottom_right.x = 720;
   HERC_graphics_virtual_screen.bottom_right.y = 350;
#endif /* HERC */

   cursor_EM_disabled = FALSE;
   }

GLOBAL void mouse_driver_termination IFN0()
   {
   /* Just free up instance memory */
   NIDDB_Deallocate_Instance_Data((IHP *)mm_handle);
   }

/*
 *      MOUSE DRIVER EXTERNAL FUNCTIONS
 *      ===============================
 */

/*
 * Macro to produce an interrupt table location from an interrupt number
 */

#define int_addr(int_no)                (int_no * 4)

void mouse_install1()
{

        /*
         *      This function is called from the Mouse Driver program to
         *      install the Insignia Mouse Driver. The interrupt vector
         *      table is patched to divert all the mouse driver interrupts
         */
        word junk1, junk2, junk3, junk4;
        word hook_offset;
        half_word interrupt_mask_register;
        char    temp[128];
#ifdef NTVDM
    word o,s;
    sys_addr block_offset;
#endif
#ifdef JAPAN
word seg, off;
#endif // JAPAN

        note_trace0(MOUSE_VERBOSE, "mouse_install1:");

#ifdef MONITOR
        /*
         * Get addresses of stuff usually in ROM from driver
         * To minimise changes, MOUSE... tokens are now variables and
         * not defines.
         */

        block_offset = effective_addr(getCS(), getBX());

        sas_loadw(block_offset, &MOUSE_IO_INTERRUPT_OFFSET);
        sas_loadw(block_offset+2, &MOUSE_IO_INTERRUPT_SEGMENT);
        sas_loadw(block_offset+4, &MOUSE_VIDEO_IO_OFFSET);
        sas_loadw(block_offset+6, &MOUSE_VIDEO_IO_SEGMENT);
        sas_loadw(block_offset+8, &MOUSE_INT1_OFFSET);
        sas_loadw(block_offset+10, &MOUSE_INT1_SEGMENT);
        sas_loadw(block_offset+12, &MOUSE_VERSION_OFFSET);
        sas_loadw(block_offset+14, &MOUSE_VERSION_SEGMENT);
        sas_loadw(block_offset+16, &MOUSE_COPYRIGHT_OFFSET);
        sas_loadw(block_offset+18, &MOUSE_COPYRIGHT_SEGMENT);
        sas_loadw(block_offset+20, &VIDEO_IO_RE_ENTRY);
        sas_loadw(block_offset+22, &VIDEO_IO_SEGMENT);
        sas_loadw(block_offset+24, &MOUSE_INT2_OFFSET);
        sas_loadw(block_offset+26, &MOUSE_INT2_SEGMENT);
        sas_loadw(block_offset+28, &DRAW_FS_POINTER_OFFSET);
        sas_loadw(block_offset+30, &DRAW_FS_POINTER_SEGMENT);
        sas_loadw(block_offset+32, &F0_OFFSET);
        sas_loadw(block_offset+34, &F0_SEGMENT);
        sas_loadw(block_offset+36, &POINTER_ON_OFFSET);
        sas_loadw(block_offset+38, &POINTER_ON_SEGMENT);
        sas_loadw(block_offset+40, &POINTER_OFF_OFFSET);
        sas_loadw(block_offset+42, &POINTER_OFF_SEGMENT);
        sas_loadw(block_offset+44, &F9_OFFSET);
        sas_loadw(block_offset+46, &F9_SEGMENT);
        sas_loadw(block_offset+48, &CP_X_O);
        sas_loadw(block_offset+50, &CP_X_S);
        sas_loadw(block_offset+52, &CP_Y_O);
        sas_loadw(block_offset+54, &CP_Y_S);
        sas_loadw(block_offset+56, &mouseINBoffset);
        sas_loadw(block_offset+58, &mouseINBsegment);
        sas_loadw(block_offset+60, &mouseOUTBoffset);
        sas_loadw(block_offset+62, &mouseOUTBsegment);
        sas_loadw(block_offset+64, &mouseOUTWoffset);
        sas_loadw(block_offset+66, &mouseOUTWsegment);
        sas_loadw(block_offset+68, &savedtextoffset);
        sas_loadw(block_offset+70, &savedtextsegment);
        sas_loadw(block_offset+72, &o);
        sas_loadw(block_offset+74, &s);
        sas_loadw(block_offset+76, &button_off);
        sas_loadw(block_offset+78, &button_seg);

#ifdef JAPAN
        sas_loadw(block_offset+84, &off);
        sas_loadw(block_offset+86, &seg);
        saved_ac_sysaddr = effective_addr(seg, off);

        sas_loadw(block_offset+88, &off);
        sas_loadw(block_offset+90, &seg);
        saved_ac_flag_sysaddr = effective_addr(seg, off);
#endif // JAPAN
        mouseCFsysaddr = effective_addr(s,o);
        sas_loadw(block_offset+80, &o);
        sas_loadw(block_offset+82, &s);
        conditional_off_sysaddr = effective_addr(s, o);

#endif /* MONITOR */
        /*
         *      Make sure that old save area does not get re-painted!
         */
        save_area_in_use = FALSE;

        /*
         *      Get rev of MOUSE.COM
         */
        mouse_com_rev = getAL();

        /*
         *      Bus mouse hardware interrupt
         */
#ifdef NTVDM
        sas_loadw (int_addr(0x71) + 0, &saved_int71_offset);
        sas_loadw (int_addr(0x71) + 2, &saved_int71_segment);
        sas_storew(int_addr(0x71), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(0x71) + 2, MOUSE_INT1_SEGMENT);
#else
        sas_loadw (int_addr(MOUSE_VEC) + 0, &saved_int0A_offset);
        sas_loadw (int_addr(MOUSE_VEC) + 2, &saved_int0A_segment);
        sas_storew(int_addr(MOUSE_VEC), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(MOUSE_VEC) + 2, MOUSE_INT1_SEGMENT);

#endif NTVDM

        /*
         *      Enable mouse hardware interrupts in the ica
         */
        inb(ICA1_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << AT_CPU_MOUSE_INT);
        outb(ICA1_PORT_1, interrupt_mask_register);
        inb(ICA0_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << CPU_MOUSE_INT);
        outb(ICA0_PORT_1, interrupt_mask_register);

        /*
         *      Mouse io user interrupt
         */

        sas_loadw (int_addr(0x33) + 0, &saved_int33_offset);
        sas_loadw (int_addr(0x33) + 2, &saved_int33_segment);

#ifdef NTVDM
        sas_storew(int_addr(0x33), MOUSE_IO_INTERRUPT_OFFSET);
        sas_storew(int_addr(0x33) + 2, MOUSE_IO_INTERRUPT_SEGMENT);
#else
        /* Read offset of INT 33 procedure from MOUSE.COM */
        sas_loadw(effective_addr(getCS(), OFF_HOOK_POSN), &hook_offset);

        sas_storew(int_addr(0x33), hook_offset);
        sas_storew(int_addr(0x33) + 2, getCS());
#endif /* NTVDM */

#ifdef MOUSE_16_BIT
        /*
         *      Call 16-bit mouse driver initialisation routine
         */
        mouse16bInstall( );
#endif

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
        /*
         *      Mouse video io user interrupt
         */
        sas_loadw (int_addr(0x10) + 0, &saved_int10_offset);
        sas_loadw (int_addr(0x10) + 2, &saved_int10_segment);
        /*
                Determine if the current int10h vector points to
                our roms. If it points elsewhere then the vector has
                been hooked and we must call the current int10h handler
                at the end of mouse_video_io().
        */
        int10_chained = TRUE;
#ifdef EGG
        if(video_adapter == EGA || video_adapter == VGA)
        {
                if ((saved_int10_segment == EGA_SEG) &&
                        (saved_int10_offset == EGA_ENTRY_OFF))
                        int10_chained = FALSE;
        }
        else
#endif
        {
                if ((saved_int10_segment == VIDEO_IO_SEGMENT) &&
                        (saved_int10_offset == VIDEO_IO_OFFSET))
                        int10_chained = FALSE;
        }
#ifndef MOUSE_16_BIT
        sas_storew(int_addr(0x10), MOUSE_VIDEO_IO_OFFSET);
        sas_storew(int_addr(0x10) + 2, MOUSE_VIDEO_IO_SEGMENT);
#else           /* MOUSE_16_BIT */
        sas_storedw(int_addr(0x10), mouseIOData.mouse_video_io );
#endif          /* MOUSE_16_BIT */

#else
        int10_chained = FALSE;          // make it initialized
#endif      /* if NTVDM && !X86GFX */

        /*
         *      Reset mouse hardware and software
         */
        junk1 = MOUSE_RESET;
        mouse_reset(&junk1, &junk2, &junk3, &junk4);

        /*
         *      Display mouse driver identification string
         */
#ifdef NTVDM
        clear_string();
#endif
        sprintf (temp, mouse_id, SPC_Product_Name, mouse_com_rev);
#ifdef NTVDM
        display_string(temp);
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_install1:return()");
}




void mouse_install2()
{
        /*
         *      This function is called from the Mouse Driver program to
         *      print a message saying that an existing mouse driver
         *      program is already installed
         */
        char    temp[128];

        note_trace0(MOUSE_VERBOSE, "mouse_install2:");

        /*
         *      Make sure that old save area does not get re-painted!
         */
        save_area_in_use = FALSE;

        /*
         *      Display mouse driver identification string
         */
#ifdef NTVDM
        clear_string();
#endif
        sprintf (temp, mouse_installed, SPC_Product_Name, mouse_com_rev);
#ifdef NTVDM
        display_string(temp);
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_install2:return()");
}




void mouse_io_interrupt()
{
        /*
         *      This is the entry point for mouse access via the INT 33H
         *      interface. I/O tracing is provided in each mouse function
         */
        word local_AX, local_BX, local_CX, local_DX;

// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
#ifdef NTVDM
    if(stream_io_enabled) {
        disable_stream_io();
    }
#endif /* NTVDM */
#endif // !NEC_98

        /*
         *      Get the parameters
         */
        local_AX = getAX();
        local_BX = getBX();
        local_CX = getCX();
        local_DX = getDX();

#ifndef NEC_98
#ifdef EGG
        jap_mouse = ((sas_hw_at(vd_video_mode) != Currently_emulated_video_mode) && alpha_num_mode());
        if (jap_mouse)
                note_trace0(MOUSE_VERBOSE, "In Japanese mode - will emulate textmouse");
#endif /* EGG */
#endif // !NEC_98

        note_trace4(MOUSE_VERBOSE,
                    "mouse function %d, position is %d,%d, button state is %d",
                    local_AX, cursor_status.position.x,
                    cursor_status.position.y, cursor_status.button_status);

        /*
         *      Do what you have to do
         */
        do_mouse_function(&local_AX, &local_BX, &local_CX, &local_DX);

        /*
         *      Set the parameters
         */
        setAX(local_AX);
        setBX(local_BX);
        setCX(local_CX);
        setDX(local_DX);
}




void mouse_io_language()
{
        /*
         *      This is the entry point for mouse access via a language.
         *      I/O tracing is provided in each mouse function
         */
        word local_SI = getSI(), local_DI = getDI();
        word m1, m2, m3, m4;
        word offset, data;
        sys_addr stack_addr = effective_addr(getSS(), getSP());

        /*
         *      Retrieve parameters from the caller's stack
         */
        sas_loadw(stack_addr+10, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m1);

        sas_loadw(stack_addr+8, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m2);

        sas_loadw(stack_addr+6, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m3);

        switch(m1)
        {
        case MOUSE_SET_GRAPHICS:
        case MOUSE_SET_SUBROUTINE:
                /*
                 *      The fourth parameter is used directly as the offset
                 */
                sas_loadw(stack_addr+4, &m4);
                break;
        case MOUSE_CONDITIONAL_OFF:
                /*
                 *      The fourth parameter addresses a parameter block
                 *      that contains the data
                 */
                sas_loadw(stack_addr+4, &offset);
                sas_loadw(effective_addr(getDS(), offset), &m3);
                sas_loadw(effective_addr(getDS(), offset+2), &m4);
                sas_loadw(effective_addr(getDS(), offset+4), &data);
                setSI(data);
                sas_loadw(effective_addr(getDS(), offset+6), &data);
                setDI(data);
                break;
        default:
                /*
                 *      The fourth parameter addresses the data to be used
                 */
                sas_loadw(stack_addr+4, &offset);
                sas_loadw(effective_addr(getDS(), offset), &m4);
                break;
        }

        /*
         *      Do what you have to do
         */
        do_mouse_function(&m1, &m2, &m3, &m4);

        /*
         *      Store results back on the stack
         */
        sas_loadw(stack_addr+10, &offset);
        sas_storew(effective_addr(getDS(), offset), m1);

        sas_loadw(stack_addr+8, &offset);
        sas_storew(effective_addr(getDS(), offset), m2);

        sas_loadw(stack_addr+6, &offset);
        sas_storew(effective_addr(getDS(), offset), m3);

        sas_loadw(stack_addr+4, &offset);
        sas_storew(effective_addr(getDS(), offset), m4);

        /*
         *      Restore potentially corrupted registers
         */
        setSI(local_SI);
        setDI(local_DI);
}

#ifdef  MOUSE_16_BIT
/*
 *      function        :       mouse16bCheckConditionalOff
 *
 *      purpose         :       Make the 16 bit driver check the conditional
 *                              off area and either draw or hide the pointer
 *                              appropriately. This function is only called
 *                              when the cursor flag is set to
 *                              MOUSE_CURSOR_DISPLAYED.
 *
 *      inputs          :       none
 *      outputs         :       none
 *      returns         :       void
 *      globals         :       cursor_flag is decremented if the pointer has
 *                              to be hidden
 *
 *
 */
LOCAL void mouse16bCheckConditionalOff IFN0()
{
        /* If the mouse has moved into the conditional
        ** off area (the black hole) then the mouse
        ** must be hidden and the cursor flag
        ** decremented, otherwise the mouse is drawn
        ** in its new position.
        */
        if ((cursor_position.x >=
                black_hole.top_left.x) &&
                (cursor_position.x <=
                black_hole.bottom_right.x) &&
                (cursor_position.y >=
                black_hole.top_left.y) &&
                (cursor_position.y <=
                black_hole.bottom_right.y))
        {
                cursor_flag--;
                mouse16bHidePointer();
        }
        else
                mouse16bDrawPointer( &cursor_status );
}
#endif  /* MOUSE_16_BIT */

LOCAL void get_screen_size IFN0()
{
#ifdef HERC
        if (video_adapter == HERCULES){
                if (get_cga_mode() == GRAPHICS){
                        virtual_screen.bottom_right.x = 720;
                        virtual_screen.bottom_right.y = 348;
                }else{
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 348;
                }
                return;
        }
#endif /* HERC */
        switch(current_video_mode)
        {
        /*==================================================================
        ACW 17/3/93 Some code added to return a different virtual
        coordinate size for the screen if text mode is used NOT in 25 line
        mode. This really emulates the Microsoft Mouse Driver.
        Note: There are 8 x 8 virtual pixels in any character cell.
        ==================================================================*/
                case 0x2:
                case 0x3:
                case 0x7:
                   {
                   half_word no_of_lines;

                   sas_load(0x484, &no_of_lines); /* do a look up in BIOS */
                   no_of_lines &= 0xff;           /* clean up */
                   switch(no_of_lines)
                      {
                      case 24:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 200;
                      break;
                      case 42:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 344;
                      break;
                      case 49:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 400;
                      break;
                      }
                   }
                break;
        /*==================================================================
        End of ACW code
        ==================================================================*/
                case 0xf:
                case 0x10:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 350;
                        break;
                case 0x40:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 344;
                        break;
                case 0x41:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 350;
                        break;
                case 0x42:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 344;
                        break;
                case 0x45:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 392;
                        break;
                case 0x66:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 400;
                        break;
                case 0x11:
                case 0x12:
                case 0x43:
                case 0x67:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 480;
                        break;
                case 0x44:
                        virtual_screen.bottom_right.x = 800;
                        virtual_screen.bottom_right.y = 480;
                        break;
                case 0x60:
                        virtual_screen.bottom_right.x = 752;
                        virtual_screen.bottom_right.y = 410;
                        break;
                case 0x61:
                case 0x68:
                        virtual_screen.bottom_right.x = 720;
                        virtual_screen.bottom_right.y = 540;
                        break;
                case 0x62:
                case 0x69:
                        virtual_screen.bottom_right.x = 800;
                        virtual_screen.bottom_right.y = 600;
                        break;
                case 0x63:
                case 0x64:
                case 0x65:
                        virtual_screen.bottom_right.x = 1024;
                        virtual_screen.bottom_right.y = 768;
                        break;
                default:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 200;
                        break;
        }
}



#ifdef EGG

/*
 * Utility routine to restore EGA defaults to the saved values.
 * If to_hw == TRUE, the restored values are also sent to the EGA.
 */


LOCAL boolean dirty_crtc[EGA_PARMS_CRTC_SIZE], dirty_seq[EGA_PARMS_SEQ_SIZE],
        dirty_graph[EGA_PARMS_GRAPH_SIZE], dirty_attr[EGA_PARMS_ATTR_SIZE];

LOCAL void clean_all_regs()
{
        int i;

        for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                dirty_crtc[i] = 0;
        for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                dirty_seq[i] = 0;
        for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                dirty_graph[i] = 0;
        for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                dirty_attr[i] = 0;
}

LOCAL void dirty_all_regs()
{
        int i;

        for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                dirty_crtc[i] = 1;
        for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                dirty_seq[i] = 1;
        for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                dirty_graph[i] = 1;
        for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                dirty_attr[i] = 1;
}

#if defined(NTVDM) && defined(MONITOR)

#define inb(a,b) doINB(a,b)
#undef  OUTB
#define OUTB(a,b) doOUTB(a,b)
#define outw(a,b) doOUTW(a,b)

static void doINB IFN2(word, port, byte, *value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setCS(mouseINBsegment);
setIP(mouseINBoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
*value=getAL();
setAX(savedAX);
setDX(savedDX);
}

static void doOUTB IFN2(word, port, byte, value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setAL(value);
setCS(mouseOUTBsegment);
setIP(mouseOUTBoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
setAX(savedAX);
setDX(savedDX);
}

static void doOUTW IFN2(word, port, word, value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setAX(value);
setCS(mouseOUTWsegment);
setIP(mouseOUTWoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
setAX(savedAX);
setDX(savedDX);
}

#endif /* NTVDM && MONITOR */

LOCAL void restore_ega_defaults(to_hw)
boolean to_hw;
{
#ifndef NEC_98
        IU8 i;
        half_word temp_word;

        sas_loads(ega_default_crtc,ega_current_crtc,EGA_PARMS_CRTC_SIZE);
        sas_loads(ega_default_seq,ega_current_seq,EGA_PARMS_SEQ_SIZE);
        sas_loads(ega_default_graph,ega_current_graph,EGA_PARMS_GRAPH_SIZE);
        sas_loads(ega_default_attr,ega_current_attr,EGA_PARMS_ATTR_SIZE);

        ega_current_misc = sas_hw_at_no_check(ega_default_misc);

        if(to_hw)
        {
                /* setup Sequencer */

                OUTB( EGA_SEQ_INDEX, 0x0 );
                OUTB( EGA_SEQ_INDEX + 1, 0x1 );

                for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                {
                        if (dirty_seq[i])
                                {
                                OUTB( EGA_SEQ_INDEX,(IU8)(i+1));
                                OUTB( EGA_SEQ_INDEX + 1, sas_hw_at_no_check( ega_default_seq + i ));
                                }
                }

                OUTB( EGA_SEQ_INDEX, 0x0 );
                OUTB( EGA_SEQ_INDEX + 1, 0x3 );

                /* setup Miscellaneous register */

                OUTB( EGA_MISC_REG, sas_hw_at_no_check( ega_default_misc ));

                /* setup CRTC */

                for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                {
                        if (dirty_crtc[i])
                                {
                                OUTB(EGA_CRTC_INDEX,(half_word)i);
                                OUTB( EGA_CRTC_INDEX + 1, sas_hw_at_no_check( ega_default_crtc + i ));
                                }
                }

                /* setup attribute chip - NB need to do an inb() to clear the address */

                inb(EGA_IPSTAT1_REG,&temp_word);

                for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                {
                        if (dirty_attr[i])
                        {
                                OUTB( EGA_AC_INDEX_DATA, i );
                                OUTB( EGA_AC_INDEX_DATA, sas_hw_at_no_check( ega_default_attr + i ));
                        }
                }

                /* setup graphics chips */

                for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                {
                        if (dirty_graph[i])
                        {
                                OUTB( EGA_GC_INDEX, i );
                                OUTB( EGA_GC_INDEX + 1, sas_hw_at_no_check( ega_default_graph + i ));
                        }
                }

                OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
                clean_all_regs();
        }
#endif    //NEC_98
}



void LOCAL mouse_adjust_screen_size()
   {
   /* Alter mouse variables which depend on mode */
   IS32 old_depth = virtual_screen.bottom_right.y;
   IS32 old_width = virtual_screen.bottom_right.x;

   /*
      Height & width of screen in pixels is variable with EGA/(V7)VGA.

      Theoretically, punters can invent their own modes which would
      confuse the issue. However most of SoftPC seems to rely on people
      using standard BIOS modes only, with standard screen heights &
      widths.
    */

   get_screen_size();

   /* Reinitialise things that depend on screen height & width. */

   cursor_position_default.x = virtual_screen.bottom_right.x / 2;
   cursor_position_default.y = virtual_screen.bottom_right.y / 2;

   cursor_position.x = (MOUSE_SCALAR)(((IS32)cursor_position.x *
          (IS32)virtual_screen.bottom_right.x) / old_width);
   cursor_position.y = (MOUSE_SCALAR)(((IS32)cursor_position.y *
          (IS32)virtual_screen.bottom_right.y) / old_depth);

   black_hole.top_left.x = -virtual_screen.bottom_right.x;
   black_hole.top_left.y = -virtual_screen.bottom_right.y;

   black_hole_default.top_left.x = -virtual_screen.bottom_right.x;
   black_hole_default.top_left.y = -virtual_screen.bottom_right.y;

   black_hole.bottom_right.x = -virtual_screen.bottom_right.x;
   black_hole.bottom_right.y = -virtual_screen.bottom_right.y;

   black_hole_default.bottom_right.x = -virtual_screen.bottom_right.x;
   black_hole_default.bottom_right.y = -virtual_screen.bottom_right.y;
   }

#if defined(NTVDM) && !defined(X86GFX)
GLOBAL void mouse_video_mode_changed(int new_mode)
{
    IMPORT word VirtualX, VirtualY;

    current_video_mode = new_mode & 0x7F;
    mouse_ega_mode(current_video_mode);
    VirtualX = virtual_screen.bottom_right.x;
    VirtualY = virtual_screen.bottom_right.y;
}
#endif

void GLOBAL mouse_ega_mode(curr_video_mode)
int curr_video_mode;
{
        sys_addr parms_addr; /* Address of EGA register table for video mode */
        sys_addr temp_word;     /* Bit of storage to pass to inb() */

        UNUSED(curr_video_mode);

        mouse_adjust_screen_size();

        if(video_adapter == EGA || video_adapter == VGA)
        {
#ifdef NTVDM
        parms_addr = find_mode_table(current_video_mode,&temp_word);
#else
#ifdef V7VGA            /* suret */
                if( (getAH()) == 0x6F )
                        parms_addr = find_mode_table(getBL(),&temp_word);
                else
                        parms_addr = find_mode_table(getAL(),&temp_word);
#else
                parms_addr = find_mode_table(getAL(),&temp_word);
#endif
#endif /* NTVDM */
                ega_default_crtc = parms_addr + EGA_PARMS_CRTC;
                ega_default_seq = parms_addr + EGA_PARMS_SEQ;
                ega_default_graph = parms_addr + EGA_PARMS_GRAPH;
                ega_default_attr = parms_addr + EGA_PARMS_ATTR;
                ega_default_misc = parms_addr + EGA_PARMS_MISC;
                restore_ega_defaults(FALSE);    /* Load up current tables, but don't write to EGA!! */
        }
#if defined(NTVDM) && defined(MONITOR)
    sas_store(conditional_off_sysaddr, 0);
#endif

}
#endif

#if defined(NTVDM) && defined(MONITOR)
extern void host_call_bios_mode_change();
#endif

extern void host_check_mouse_buffer(void);

void mouse_video_io()
{
#ifndef NEC_98
        /*
         *      This is the entry point for video accesses via the INT 10H
         *      interface
         */
#ifdef EGG
        half_word temp_word;    /* Bit of storage to pass to inb() */
#endif /* EGG */
        IS32 mouse_video_function = getAH();

        /*
         * Switch to full screen to handle VESA video functions
         *
         */
        if (mouse_video_function == 0x4f) {

            /*
            ** Since host does not support VESA bios emulation, we will let
            ** PC's video bios to handle the vesa int10 call.
            ** For Microsoft NT this is a transition to full-screen ie. the
            ** real PC's video BIOS and graphics board.
            **
            ** After it rturns, host has done the screen switch for us.
            ** We will return to soft int10 handler to invoke the PC's BIOS
            ** vesa function.
            */
            {
                    extern VOID SwitchToFullScreen IPT1(BOOL, Restore);

                    SwitchToFullScreen(TRUE);
                    return;
            }
        }
#ifdef V7VGA
        if (mouse_video_function == MOUSE_VIDEO_SET_MODE || getAX() == MOUSE_V7_VIDEO_SET_MODE)
#else
        if (mouse_video_function == MOUSE_VIDEO_SET_MODE)
#endif /* V7VGA */
        {
                note_trace1(MOUSE_VERBOSE, "mouse_video_io:set_mode(%d)",
                            getAL());


                current_video_mode = getAL() & 0x7f;
#ifdef JAPAN
                if (!is_us_mode() && (current_video_mode == 0x72 || current_video_mode == 0x73)) {
                    /* validate video mode, for Lotus 1-2-3 R2.5J  now temporary fix */
                }
                else {
#endif // JAPAN
#ifdef V7VGA
                if (mouse_video_function == 0x6f)
                        current_video_mode = getBL() & 0x7f;
                else if (current_video_mode > 0x13)
                        current_video_mode += 0x4c;

                if (is_bad_vid_mode(current_video_mode) && !is_v7vga_mode(current_video_mode))
#else
                if (is_bad_vid_mode(current_video_mode))
#endif /* V7VGA */
                {
                        always_trace1("Bad video mode - %d.\n", current_video_mode);
#ifdef V7VGA
                        if (mouse_video_function == 0x6f)
                                setAH( 0x02 );       /* suret */
#endif /* V7VGA */
                        return;
                }

#ifdef JAPAN
                }
#endif // JAPAN
#ifdef EGG
                mouse_ega_mode(current_video_mode);
                dirty_all_regs();
#endif
                /*
                 *      Remove the old cursor from the screen, and hide
                 *      the cursor
                 */
                cursor_undisplay();

                cursor_flag = MOUSE_CURSOR_DEFAULT;

#if defined(NTVDM) && defined(MONITOR)
        sas_store(mouseCFsysaddr,(half_word)MOUSE_CURSOR_DEFAULT);
#endif
                /*
                 *      Deal with the mode change
                 */
                cursor_mode_change(current_video_mode);

#if defined(NTVDM) && defined(MONITOR)
        host_call_bios_mode_change();
#endif

#ifdef  MOUSE_16_BIT
                /* Remember whether in text or graphics mode for
                ** later use.
                */
                is_graphics_mode = ((current_video_mode > 3) &&
                        (current_video_mode != 7));
#endif  /* MOUSE_16_BIT */

                note_trace0(MOUSE_VERBOSE, "mouse_video_io:return()");
        }
        else if (    (mouse_video_function == MOUSE_VIDEO_READ_LIGHT_PEN)
                  && light_pen_mode)
        {
                note_trace0(MOUSE_VERBOSE, "mouse_video_io:read_light_pen()");

                /*
                 *      Set text row and column of "light pen" position
                 */
                setDL((UCHAR)(cursor_status.position.x/text_grid.x));
                setDH((UCHAR)(cursor_status.position.y/text_grid.y));

                /*
                 *      Set pixel column and raster line of "light pen"
                 *      position
                 */
                setBX((UCHAR)(cursor_status.position.x/cursor_grid.x));
                if (sas_hw_at(vd_video_mode)>= 0x04 && sas_hw_at(vd_video_mode)<=0x06){
                        setCH((UCHAR)(cursor_status.position.y));
                }else if (sas_hw_at(vd_video_mode)>= 0x0D && sas_hw_at(vd_video_mode)<=0x13){
                        setCX(cursor_status.position.y);
                }

                /*
                 *      Set the button status
                 */
                setAH((UCHAR)(cursor_status.button_status));

                note_trace5(MOUSE_VERBOSE,
                            "mouse_video_io:return(st=%d,ca=[%d,%d],pa=[%d,%d])",
                            getAH(), getDL(), getDH(), getBX(), cursor_status.position.y);
                return;
        }
#if defined(NTVDM) && defined(MONITOR)
    else if (mouse_video_function == MOUSE_VIDEO_LOAD_FONT)
    {
                note_trace0(MOUSE_VERBOSE, "mouse_video_io:load_font()");

        /*
         * Call the host to tell it to adjust the mouse buffer selected
         * if the number of lines on the screen have changed.
         */
        host_check_mouse_buffer();
    }
#endif /* NTVDM && MONITOR */

        /*
         *      Now do the standard video io processing
         */
        switch (mouse_video_function)
        {
#ifdef EGG
                /* Fancy stuff to access EGA registers */
                case 0xf0:      /* Read a register */
                        switch (getDX())
                        {
                                        case 0:
                                                        setBL(ega_current_crtc[getBL()]);
                                                        break;
                                        case 8:
                                                        setBL(ega_current_seq[getBL()-1]);
                                                        break;
                                        case 0x10:
                                                        setBL(ega_current_graph[getBL()]);
                                                        break;
                                        case 0x18:
                                                        setBL(ega_current_attr[getBL()]);
                                                        break;
                                        case 0x20:
                                                        setBL(ega_current_misc);
                                                        break;
                                        case 0x28:
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
                case 0xf1:      /* Write a register */
                        switch (getDX())
                        {
                                        case 0:
                                                        outw( EGA_CRTC_INDEX, getBX() );
                                                        ega_current_crtc[getBL()] = getBH();
                                                        dirty_crtc[getBL()] = 1;
                                                        break;
                                        case 8:
                                                        outw( EGA_SEQ_INDEX, getBX() );
                                                        if(getBL()>0)
                                                        {
                                                                ega_current_seq[getBL()-1] = getBH();
                                                                dirty_seq[getBL()-1] = 1;
                                                        }
                                                        break;
                                        case 0x10:
                                                        outw( EGA_GC_INDEX, getBX() );
                                                        ega_current_graph[getBL()] = getBH();
                                                        dirty_graph[getBL()] = 1;
                                                        break;
                                        case 0x18:
                                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */

                                                        /* outw( EGA_AC_INDEX_DATA, getBX() );  this is not correct (andyw BCN 1692) */

/*=============================================================================
The attribute controller index register and data register associated
with that index are accessed through the same I/O  port = 03C0h.
The correct procedure is to map the index register to 03C0h by doing
the INB as above. Then OUTB the index of the A.C. register required.
The VGA hardware then maps in the correct data register to which
the application OUTBs the necessary data.
=============================================================================*/
                                                        OUTB( EGA_AC_INDEX_DATA, getBL() ); /* BL contains the index value */
                                                        OUTB( EGA_AC_INDEX_DATA, getBH() ); /* BH contains the data */

/*=== End of BCN 1692 ===*/
                                                        OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
                                                        ega_current_attr[getBL()] = getBH();
                                                        dirty_attr[getBL()] = 1;
                                                        break;
                                        case 0x20:
                                                        OUTB( EGA_MISC_REG, getBL() );
                                                        ega_current_misc = getBL();
                                                        break;
                                        case 0x28:
                                                        OUTB( EGA_FEAT_REG, getBL() );
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
                case 0xf2:      /* read range */
                        switch (getDX())
                        {
                                case 0:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_crtc[getCH()],getCL());
                                        break;
                                case 8:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_seq[getCH()-1],getCL());
                                        break;
                                case 0x10:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_graph[getCH()],getCL());
                                        break;
                                case 0x18:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_attr[getCH()],getCL());
                                        break;
                                default:
                                        break;
                        }
                        break;
                case 0xf3:      /* write range */
                {
                        UCHAR first = getCH(), last = getCH()+getCL();
                        sys_addr sauce = effective_addr(getES(),getBX());
                        switch (getDX())
                        {
                                case 0:
                                        sas_loads(sauce,&ega_current_crtc[getCH()],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_crtc[first] = 1;
                                                outw(EGA_CRTC_INDEX,(WORD)(first+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 8:
                                        sas_loads(sauce,&ega_current_seq[getCH()-1],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_seq[first+1] = 1;
                                                outw(EGA_SEQ_INDEX,(WORD)(first+1+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 0x10:
                                        sas_loads(sauce,&ega_current_graph[getCH()],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_graph[first] = 1;
                                                outw(EGA_GC_INDEX,(WORD)(first+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 0x18:
                                        sas_loads(sauce,&ega_current_attr[getCH()],getCL());
                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */
                                        for(;first<last;first++)
                                        {
                                                dirty_attr[first] = 1;

                                                /* Using 'secret' that attrib. chip responds to it's port+1 */
#ifndef NTVDM
                                                outw(EGA_AC_INDEX_DATA,first+(sas_hw_at(sauce++) << 8));
#else
                        OUTB(EGA_AC_INDEX_DATA,first);
                        OUTB(EGA_AC_INDEX_DATA,sas_hw_at(sauce++));
#endif /* !NTVDM */
                                        }
#ifndef NTVDM
                                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#else
                                        OUTB(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#endif /* NTVDM */
                                        break;
                                default:
                                        break;
                        }
                }
                break;
                case 0xf4:      /* read set */
                {
                        int i =  getCX();
                        sys_addr set_def = effective_addr(getES(),getBX());
                        while(i--)
                        {
                                switch (sas_hw_at(set_def))
                                {
                                        case 0:
                                                        sas_store((set_def+3), ega_current_crtc[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 8:
                                                        sas_store((set_def+3), ega_current_seq[sas_hw_at(set_def+2)-1]);
                                                        break;
                                        case 0x10:
                                                        sas_store((set_def+3), ega_current_graph[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 0x18:
                                                        sas_store((set_def+3), ega_current_attr[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 0x20:
                                                        sas_store((set_def+3), ega_current_misc);
                                                        setBL(ega_current_misc);
                                                        break;
                                        case 0x28:
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                                }
                                set_def += 4;
                        }
                }
                break;
                case 0xf5:      /* write set */
                {
                        int i =  getCX();
                        sys_addr set_def = effective_addr(getES(),getBX());
                        while(i--)
                        {
                                switch (sas_hw_at(set_def))
                                {
                                        case 0:
                                                        outw(EGA_CRTC_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        ega_current_crtc[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_crtc[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 8:
                                                        outw(EGA_SEQ_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        if(sas_hw_at(set_def+2))
                                                                ega_current_seq[sas_hw_at(set_def+2)-1] = sas_hw_at(set_def+3);
                                                        dirty_seq[sas_hw_at(set_def+2)-1] = 1;
                                                        break;
                                        case 0x10:
                                                        outw(EGA_GC_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        ega_current_graph[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_graph[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 0x18:
                                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */
#ifndef NTVDM
                                                        outw(EGA_AC_INDEX_DATA,sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)); /* Using 'secret' that attrib. chip responds to it's port+1 */
                                                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#else

                            OUTB( EGA_AC_INDEX_DATA,sas_hw_at(set_def+2));
                            OUTB( EGA_AC_INDEX_DATA,sas_hw_at(set_def+3));
                            OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
#endif /* !NTVDM */
                                                        ega_current_attr[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_attr[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 0x20:
                                                        outb(EGA_MISC_REG,sas_hw_at(set_def+2));
                                                        ega_current_misc = sas_hw_at(set_def+2);
                                                        break;
                                        case 0x28:
                                                        outb(EGA_FEAT_REG,sas_hw_at(set_def+2));
                                                        break;
                                /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                                }
                                set_def += 4;
                        }
                }
                break;
                case 0xf6:
                        restore_ega_defaults(TRUE);
                        break;
                case 0xf7:
                        dirty_all_regs();
                        switch (getDX())
                        {
                                        case 0:
                                                        ega_default_crtc = effective_addr(getES(),getBX());
                                                        break;
                                        case 8:
                                                        ega_default_seq = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x10:
                                                        ega_default_graph = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x18:
                                                        ega_default_attr = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x20:
                                                        ega_default_misc = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x28: /* Feature Reg not reallt supported */
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
#endif
                case 0xfa:
/*
 * MS word on an EGA uses this call and needs BX != 0 to make its cursor work. Real MS mouse driver returns a pointer in ES:BX
 * aimed at several bytes of unknown significance followed by a "This is Copyright 1984 Microsoft" message, which we don't have.
 * This seems to work with MS word and MS Windows, presumably non MS applications wouldn't use it as it's not documented.
 *
 * We now have a wonderful document - "The Microsoft Mouse Driver", which tells us that ES:BX should
 * point to the EGA Register Interface version number (2 bytes).
 * If BX=0 this means "no mouse driver". So returning 1 seems OK for now. WJG.
 */
                        setBX(1);
                        break;
                case 0x11:
                /*
                 * If we are issuing a TEXT MODE CHARACTER GENERATOR then this will
                 * cause a mode set. Therefore we need to recalc the screen
                 * parameters subsequently as the screen size may differ!!
                 * this occurred in DOSSHELL.
                 */
#if !defined(NTVDM) || !defined(MONITOR)
#ifdef EGG
                        if (video_adapter == EGA || video_adapter == VGA)
                        {
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                ega_video_io();
                                if (!(getAL() & 0x20))
                                        mouse_ega_mode(current_video_mode); /* only for text */
                        }
                        else
#endif
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                video_io();
#endif /* !NTVDM && !MONITOR */
                        break;

                default:
#ifndef X86GFX
                        /* Does the previous int10h vector point to our roms ? */
                        if (int10_chained == FALSE)
                        {
                                /* Yes - call our video handler */
#ifndef GISP_SVGA
#ifdef EGG
                        if (video_adapter == EGA || video_adapter == VGA)
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                ega_video_io();
                        else
#endif
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                video_io();
#else /* GISP_SVGA */
                                /* Video bios chain done from 16 bit */
                                /* NULL */;
#endif /* GISP_SVGA */
        }
                        else
                        {
                                /* No - chain the previous int10h handler       */
                                setCS(saved_int10_segment);
                                setIP(saved_int10_offset);
                        }
#else
                        break;
#endif  /* !X86GFX */
        }
#ifdef GISP_SVGA
        setCF( 1 );
#endif /* GISP_SVGA */

#endif    //NEC_98
}

#if defined(NTVDM) && defined(MONITOR)
#undef inb
#undef OUTB
#undef outw
#endif /* NTVDM && MONITOR */

void mouse_EM_callback()
   {
   note_trace1(MOUSE_VERBOSE,
      "Enhanced Mode Mouse-Support Callback Function(%x).", getAX());

   /* Windows Enhanced Mode Mouse-Support Callback */
   switch ( getAX() )
      {
   case 0x1:   /* Mouse move/Button click */
      mouse_EM_move();
      break;

   case 0x2:   /* Disable Mouse Cursor Drawing */
      if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
         cursor_undisplay();
      cursor_EM_disabled = TRUE;
      break;

   case 0x3:   /* Enable Mouse Cursor Drawing */
      cursor_EM_disabled = FALSE;
      if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
         cursor_display();
      break;

   default:    /* Unknown == Unsupported */
      break;
      }
   }

LOCAL void mouse_EM_move()
   {
   MOUSE_CALL_MASK event_mask;
   MOUSE_STATE button_state;
   MOUSE_SCALAR x_pixel;
   MOUSE_SCALAR y_pixel;
   MOUSE_VECTOR mouse_movement;

   /* Pick up parameters. */
   event_mask = getSI();
   button_state = getDX();
   x_pixel = getBX();
   y_pixel = getCX();

   note_trace4(MOUSE_VERBOSE,
      "Extended Interface: event mask(%x) button_state(%x) posn(%d,%d).",
      event_mask, button_state, x_pixel, y_pixel);

   /* Process mouse events. */
   if ( event_mask & MOUSE_CALL_MASK_LEFT_RELEASE_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].release_position);
      button_transitions[MOUSE_LEFT_BUTTON].release_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_LEFT_PRESS_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].press_position);
      button_transitions[MOUSE_LEFT_BUTTON].press_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_RIGHT_RELEASE_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
      button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_RIGHT_PRESS_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
      button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
      }

   cursor_status.button_status = button_state;

   /* Process any mouse movement. */
   if ( event_mask & MOUSE_CALL_MASK_POSITION_BIT )
      {
      /* Calculate mickeys moved. */
      point_set(&mouse_movement, x_pixel, y_pixel);
      vector_multiply_by_vector(&mouse_movement, &mouse_gear);

      /* Update micky count. */
      point_translate(&mouse_motion, &mouse_movement);

      /* Set up point in pixels, again. */
      point_set(&mouse_movement, x_pixel, y_pixel);

      /* Update raw pixel position, and go grid it. */
        cursor_position.x = x_pixel;
        cursor_position.y = y_pixel;
      cursor_update();
      }

   /* Now handle user subroutine and/or display update. */
   mouse_update(event_mask);
   }

void mouse_int1()
{
        /*
         *      The bus mouse hardware interrupt handler
         */
#ifndef NTVDM
        MOUSE_VECTOR mouse_movement;
        MOUSE_INPORT_DATA inport_event;
#else
    MOUSE_VECTOR mouse_counter = { 0, 0 };
#endif
        MOUSE_CALL_MASK condition_mask;


        note_trace0(MOUSE_VERBOSE, "mouse_int1:");

#ifdef NTVDM


//
// Okay, lets forget that the InPort adapter ever existed!
//

cursor_status.button_status = 0;
condition_mask = 0;

//
// Get the mouse motion counters back from the host side of things.
// Note: The real mouse driver returns the mouse motion counter values
// to the application in two possible ways. First, if the app uses
// int 33h function 11, a counter displacement is returned since the
// last call to this function.
// If a user subroutine is installed, the motion counters are given
// to this callback in SI and DI.
//

host_os_mouse_pointer(&cursor_status,&condition_mask,&mouse_counter);

//
// If movement during the last mouse hardware interrupt has been recorded,
// update the mouse motion counters.
//

mouse_motion.x += mouse_counter.x;
mouse_motion.y += mouse_counter.y;

//
// Update the statistics for an int 33h function 5, if one
// should occur.
// Note: The cases can't be mixed, since only one can occur
// per hardware interrupt - after all each press or release
// causes a hw int.
//

switch(condition_mask & 0x1e) // look at bits 1,2,3 and 4.
   {
   case 0x2: //left button pressed
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].press_position);
      button_transitions[MOUSE_LEFT_BUTTON].press_count++;
      }
   break;
   case 0x4: //left button released
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].release_position);
      button_transitions[MOUSE_LEFT_BUTTON].release_count++;
      }
   break;
   case 0x8: //right button pressed
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
      button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
      }
   break;
   case 0x10: //right button released
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
      button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
      }
   break;
   }

/*==================================================================

The old fashioned stuff

==================================================================*/

#else /* use the SoftPC emulation */
        /*
         *      Terminate the mouse hardware interrupt
         */
        outb(ICA0_PORT_0, END_INTERRUPT);

        /*
         *      Get the mouse InPort input event frame
         */
        inport_get_event(&inport_event);

        note_trace3(MOUSE_VERBOSE,
                    "mouse_int1:InPort status=0x%x,data1=%d,data2=%d",
                    inport_event.status,
                    inport_event.data_x, inport_event.data_y);

        /*
         *      Update button status and transition information and fill in
         *      button bits in the event mask
         */
        cursor_status.button_status = 0;
        condition_mask = 0;

        switch(inport_event.status & MOUSE_INPORT_STATUS_B1_TRANSITION_MASK)
        {
        case MOUSE_INPORT_STATUS_B1_RELEASED:
                condition_mask |= MOUSE_CALL_MASK_LEFT_RELEASE_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_LEFT_BUTTON].release_position);
                button_transitions[MOUSE_LEFT_BUTTON].release_count++;
        case MOUSE_INPORT_STATUS_B1_UP:
                break;

        case MOUSE_INPORT_STATUS_B1_PRESSED:
                condition_mask |= MOUSE_CALL_MASK_LEFT_PRESS_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_LEFT_BUTTON].press_position);
                button_transitions[MOUSE_LEFT_BUTTON].press_count++;
        case MOUSE_INPORT_STATUS_B1_DOWN:
                cursor_status.button_status |= MOUSE_LEFT_BUTTON_DOWN_BIT;
                break;
        }

        switch(inport_event.status & MOUSE_INPORT_STATUS_B3_TRANSITION_MASK)
        {
        case MOUSE_INPORT_STATUS_B3_RELEASED:
                condition_mask |= MOUSE_CALL_MASK_RIGHT_RELEASE_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
                button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
        case MOUSE_INPORT_STATUS_B3_UP:
                break;

        case MOUSE_INPORT_STATUS_B3_PRESSED:
                condition_mask |= MOUSE_CALL_MASK_RIGHT_PRESS_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
                button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
        case MOUSE_INPORT_STATUS_B3_DOWN:
                cursor_status.button_status |= MOUSE_RIGHT_BUTTON_DOWN_BIT;
                break;
        }

        /*
         *      Update position information and fill in position bit in the
         *      event mask
         */
        if (inport_event.data_x != 0 || inport_event.data_y != 0)
        {
                condition_mask |= MOUSE_CALL_MASK_POSITION_BIT;

                        point_set(&mouse_movement,
                                        inport_event.data_x, inport_event.data_y);

                        point_translate(&mouse_raw_motion, &mouse_movement);

                        /*
                         *      Adjust for sensitivity
                         */
                        mouse_movement.x = (MOUSE_SCALAR)(((IS32)mouse_movement.x * (IS32)mouse_sens_val.x) / MOUSE_SENS_MULT);
                        mouse_movement.y = (MOUSE_SCALAR)(((IS32)mouse_movement.y * (IS32)mouse_sens_val.y) / MOUSE_SENS_MULT);

                        /*
                         * NB. !!!
                         * We ought to apply the acceleration curve here
                         * and not the double speed set up. However mouse
                         * interrupts and mouse display are probably not
                         * fast enough anyway to make it worth while adding
                         * the acceleration fine tuning.
                         */

                        /*
                         *      Do speed doubling
                         */
                        if (    (scalar_absolute(mouse_movement.x) > double_speed_threshold)
                             || (scalar_absolute(mouse_movement.y) > double_speed_threshold))
                                vector_scale(&mouse_movement, MOUSE_DOUBLE_SPEED_SCALE);

                        /*
                         *      Update the user mouse motion counters
                         */
                        point_translate(&mouse_motion, &mouse_movement);

                        /*
                         *      Convert the movement from a mouse Mickey count vector
                         *      to a virtual screen coordinate vector, using the
                         *      previous remainder and saving the new remainder
                         */
                        vector_scale(&mouse_movement, MOUSE_RATIO_SCALE_FACTOR);
                        point_translate(&mouse_movement, &cursor_fractional_position);
                        point_copy(&mouse_movement, &cursor_fractional_position);
                        vector_divide_by_vector(&mouse_movement, &mouse_gear);
                        vector_mod_by_vector(&cursor_fractional_position, &mouse_gear);

                /*
                 *      Update the absolute cursor position and the windowed
                 *      and gridded screen cursor position
                 */
                point_translate(&cursor_position, &mouse_movement);
                cursor_update();
        }

#endif /* NTVDM*/

        /* OK mouse variables updated - go handle consequences */
        mouse_update(condition_mask);

        note_trace0(MOUSE_VERBOSE, "mouse_int1:return()");
}

LOCAL void mouse_update IFN1(MOUSE_CALL_MASK, condition_mask)
{
        MOUSE_CALL_MASK key_mask;
        boolean alt_found = FALSE;
        int i;

        note_trace4(MOUSE_VERBOSE,
                    "mouse_update():cursor status = (%d,%d), LEFT %s, RIGHT %s",
                    cursor_status.position.x, cursor_status.position.y,
                    mouse_button_description(cursor_status.button_status & MOUSE_LEFT_BUTTON_DOWN_BIT),
                    mouse_button_description(cursor_status.button_status & MOUSE_RIGHT_BUTTON_DOWN_BIT));

        if (alt_user_subroutines_active){
                /* Get current key states in correct form */
                key_mask = ((sas_hw_at(kb_flag) & LR_SHIFT)  ? MOUSE_CALL_MASK_SHIFT_KEY_BIT : 0) |
                           ((sas_hw_at(kb_flag) & CTL_SHIFT) ? MOUSE_CALL_MASK_CTRL_KEY_BIT  : 0) |
                           ((sas_hw_at(kb_flag) & ALT_SHIFT) ? MOUSE_CALL_MASK_ALT_KEY_BIT   : 0);
                for (i=0; !alt_found && i<NUMBER_ALT_SUBROUTINES; i++){
                        alt_found = (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS) == key_mask;
                }
        }

#ifndef NTVDM

        if (alt_found){
                i--;    /* Adjust for extra inc */
                if (condition_mask & alt_user_subroutine_call_mask[i]){
                        if (!user_subroutine_critical){
                            user_subroutine_critical = TRUE;
                            jump_to_user_subroutine(condition_mask, alt_user_subroutine_segment[i], alt_user_subroutine_offset[i]);
                        }
                        return;
                }
        }else{
                if (condition_mask & user_subroutine_call_mask){
                        if (!user_subroutine_critical){
                                user_subroutine_critical = TRUE;
                                jump_to_user_subroutine(condition_mask, user_subroutine_segment, user_subroutine_offset);
                        }
                        return;
                }
        }

#else   /* NTVDM */


if (alt_found)
   {
   i--; /* Adjust for extra inc */
   if ((condition_mask & alt_user_subroutine_call_mask[i]))
      {
       SuspendMouseInterrupts();
       jump_to_user_subroutine(condition_mask, alt_user_subroutine_segment[i], alt_user_subroutine_offset[i]);
      }
   }
else
   {
   if ((condition_mask & user_subroutine_call_mask))
      {
       SuspendMouseInterrupts();
       jump_to_user_subroutine(condition_mask, user_subroutine_segment, user_subroutine_offset);
      }
   }

outb(ICA1_PORT_0, 0x20 );
outb(ICA0_PORT_0, END_INTERRUPT);
#endif

/*
 * if the OS pointer is NOT being used to supply input,
 * then get SoftPC to draw its own cursor
 */
/*@ACW*/

#ifndef NTVDM
        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (condition_mask & MOUSE_CALL_MASK_POSITION_BIT)
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bCheckConditionalOff();
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
#endif /*NTVDM*/
}


void mouse_int2()
{
        /*
         *      Part 2 of the mouse hardware interrupt service routine. Control
         *      is passed to this routine when the "user subroutine" that may
         *      be called as part of the interrupt service routine completes
         */

        note_trace0(MOUSE_VERBOSE, "mouse_int2:");

#ifndef NTVDM
        user_subroutine_critical = FALSE;
#endif

        setAX(saved_AX);
        setBX(saved_BX);
        setCX(saved_CX);
        setDX(saved_DX);
        setSI(saved_SI);
        setDI(saved_DI);
        setES(saved_ES);
        setBP(saved_BP);
        setDS(saved_DS);

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (last_condition_mask & MOUSE_CALL_MASK_POSITION_BIT)
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                {
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bCheckConditionalOff();
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
                }

        /*
         *      Ensure any changes to the screen image are updated immediately
         *      on the real screen, giving a "smooth" mouse response; the flush
         *      must be done here for applications such as GEM which disable
         *      the mouse driver's graphics capabilities in favour of doing
         *      their own graphics in the user subroutine.
         */
        host_flush_screen();

#ifdef NTVDM
    ResumeMouseInterrupts();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_int2:return()");
}



/*
 *      MOUSE DRIVER LOCAL FUNCTIONS
 *      ============================
 */

LOCAL void do_mouse_function IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This is the mouse function dispatcher
         */
        int function = *m1;

        switch(function)
        {
                /*
                 *      Deal with special undocumented functions
                 */
        case MOUSE_SPECIAL_COPYRIGHT:
                setES(MOUSE_COPYRIGHT_SEGMENT);
                setDI(MOUSE_COPYRIGHT_OFFSET);
                break;
        case MOUSE_SPECIAL_VERSION:
                setES(MOUSE_VERSION_SEGMENT);
                setDI(MOUSE_VERSION_OFFSET);
                break;

                /*
                 *      Deal with special undocumented functions
                 */
        default:
                if (!mouse_function_in_range(function))
                {
                        /*
                         *      Use the unrecognised function
                         */
                        function = MOUSE_UNRECOGNISED;
                }

                (*mouse_function[function])(m1, m2, m3, m4);
                break;
        }
}

LOCAL void mouse_reset IFN4(word *,installed_ptr,word *,nbuttons_ptr,word *,junk3,word *,junk4)
/*
 * *installed_ptr Holds function number on input...
 * Returns installation state.
 */
{
        /*
         *      This function resets the mouse driver, and returns
         *      the installation status of the mouse hardware and software
         */
        boolean soft_reset_only = (*installed_ptr == MOUSE_SOFT_RESET);
        half_word crt_mode;
        int button;

        UNUSED(junk3);
        UNUSED(junk4);

        note_trace1(MOUSE_VERBOSE, "mouse_io:reset(%s)",
                    soft_reset_only ? "SOFT" : "HARD");

        /*
         *      Remove the old cursor from the screen
         */
        cursor_undisplay();

        /*
         *      Set cursor position to the default position, and the button
         *      status to all buttons up
         */
        point_copy(&cursor_position_default, &cursor_position);
        point_set(&cursor_fractional_position, 0, 0);
        cursor_status.button_status = 0;

        if (host_mouse_installed())
                host_mouse_reset();

        /*
         *      Set cursor window to be the whole screen
         */
        area_copy(&virtual_screen, &cursor_window);

        /*
         *      Set cursor flag to default
         */
        cursor_flag = MOUSE_CURSOR_DEFAULT;

#if defined(MONITOR) && defined(NTVDM)
    sas_store(mouseCFsysaddr, MOUSE_CURSOR_DEFAULT);
#endif

        /*
         *      Get current video mode, and update parameters that are
         *      dependent on it
         */
        sas_load(MOUSE_VIDEO_CRT_MODE, &crt_mode);
#if !defined(NTVDM) || (defined(NTVDM) && defined(V7VGA))
        if ((crt_mode == 1) && extensions_controller.foreground_latch_1)
            crt_mode = extensions_controller.foreground_latch_1;
        else if (crt_mode > 0x13)
            crt_mode += 0x4c;
#endif

        cursor_mode_change((int)crt_mode);

        /*
         *      Update dependent cursor status
         */
        cursor_update();

        /*
         *      Set default text cursor type and masks
         */
        text_cursor_type = MOUSE_TEXT_CURSOR_TYPE_DEFAULT;
        software_text_cursor_copy(&software_text_cursor_default,
                                        &software_text_cursor);

        /*
         *      Set default graphics cursor
         */
        graphics_cursor_copy(&graphics_cursor_default, &graphics_cursor);
        copy_default_graphics_cursor();

        /*
         *      Set cursor page to zero
         */
        cursor_page = 0;

        /*
         *      Set light pen emulation mode on
         */
        light_pen_mode = TRUE;

        /*
         *      Set default Mickey to pixel ratios
         */
        point_copy(&mouse_gear_default, &mouse_gear);

        /*
         *      Clear mouse motion counters
         */
        point_set(&mouse_motion, 0, 0);
        point_set(&mouse_raw_motion, 0, 0);

        /* Reset to default acceleration curve */
        active_acceleration_curve = 3;   /* Back to Normal */

        memcpy(&acceleration_curve_data, &default_acceleration_curve,
           sizeof(ACCELERATION_CURVE_DATA));

        next_video_mode = 0;      /* reset video mode enumeration */

        /*
         *      Clear mouse button transition data
         */
        for (button = 0; button < MOUSE_BUTTON_MAXIMUM; button++)
        {
                button_transitions[button].press_position.x = 0;
                button_transitions[button].press_position.y = 0;
                button_transitions[button].release_position.x = 0;
                button_transitions[button].release_position.y = 0;
                button_transitions[button].press_count = 0;
                button_transitions[button].release_count = 0;
        }

        /*
         *      Disable conditional off area
         */
        area_copy(&black_hole_default, &black_hole);

#if defined(MONITOR) && defined(NTVDM)
    sas_store(conditional_off_sysaddr, 0);
#endif

        /*
         *      Set default sensitivity
         */
        vector_set (&mouse_sens,     MOUSE_SENS_DEF,     MOUSE_SENS_DEF);
        vector_set (&mouse_sens_val, MOUSE_SENS_DEF_VAL, MOUSE_SENS_DEF_VAL);
        mouse_double_thresh = MOUSE_DOUBLE_DEF;

        /*
         *      Set double speed threshold to the default
         */
        double_speed_threshold = MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT;

        /*
         *      Clear subroutine call mask
         */
        user_subroutine_call_mask = 0;

        /*
         *      Reset the bus mouse hardware
         */
        if (!soft_reset_only){
                inport_reset();
        }

        /*
         *      Set return values
         */
        *installed_ptr = MOUSE_INSTALLED;
        *nbuttons_ptr = 2;

        note_trace2(MOUSE_VERBOSE, "mouse_io:return(ms=%d,nb=%d)",
                    *installed_ptr, *nbuttons_ptr);
}




LOCAL void mouse_show_cursor IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function is used to display the cursor, based on the
         *      state of the internal cursor flag. If the cursor flag is
         *      already MOUSE_CURSOR_DISPLAYED, then this function does
         *      nothing. If the internal cursor flag becomes
         *      MOUSE_CURSOR_DISPLAYED when incremented by 1, the cursor
         *      is revealed
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:show_cursor()");

#ifndef NTVDM
        /*
         *      Disable conditional off area
         */
        area_copy(&black_hole_default, &black_hole);

        /*
         *      Display the cursor
         */
        if (cursor_flag != MOUSE_CURSOR_DISPLAYED)
                if (++cursor_flag == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bShowPointer(&cursor_status);
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
#endif /* NTVDM */

#if defined(NTVDM) && defined(X86GFX)
    host_show_pointer();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_hide_cursor IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function is used to undisplay the cursor, based on
         *      the state of the internal cursor flag. If the cursor flag
         *      is already not MOUSE_CURSOR_DISPLAYED, then this function
         *      does nothing, otherwise it removes the cursor from the display
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:hide_cursor()");
#ifndef NTVDM
        if (cursor_flag-- == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                if (is_graphics_mode)
                        mouse16bHidePointer();
                else
#endif  /* MOUSE_16_BIT */
                {
                cursor_undisplay();
                }
#endif
#if defined(NTVDM) && defined(X86GFX)
    host_hide_pointer();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_get_position IFN4(word *,junk1,MOUSE_STATE *,button_status_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the state of the left and right mouse
         *      buttons and the gridded position of the cursor on the screen
         */

        UNUSED(junk1);

        note_trace0(MOUSE_VERBOSE, "mouse_io:get_position()");

        *button_status_ptr = cursor_status.button_status;
        *cursor_x_ptr = cursor_status.position.x;
        *cursor_y_ptr = cursor_status.position.y;

        note_trace3(MOUSE_VERBOSE, "mouse_io:return(bs=%d,x=%d,y=%d)",
                    *button_status_ptr, *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_set_position IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function sets the cursor to a new position
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_position(x=%d,y=%d)",
                    *cursor_x_ptr, *cursor_y_ptr);


#if defined(NTVDM)

#ifndef X86GFX
        /*
         * update the cursor position. cc:Mail installtion does
         *  do {
         *     SetMouseCursorPosition(x,y)
         *     GetMouseCursorPosition(&NewX, &NewY);
         *  } while(NewX != x || NewY != y)
         *  If we don't retrun correct cursor position, this application
         *  looks hung
         *
         */
        point_set(&cursor_status.position, *cursor_x_ptr, *cursor_y_ptr);

#endif
        /*
         * For NT, the system pointer is used directly to provide
         * input except for fullscreen graphics where the host code
         * has the dubious pleasure of drawing the pointer through
         * a 16 bit device driver.
         */

         host_mouse_set_position((USHORT)*cursor_x_ptr,(USHORT)*cursor_y_ptr);
         return;  /* let's get out of this mess - FAST! */

#endif /* NTVDM */

        /*
         *      Update the current cursor position, and reflect the change
         *      in the cursor position on the screen
         */
        point_set(&cursor_position, *cursor_x_ptr, *cursor_y_ptr);
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_get_press IFN4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the status of a button, the number of
         *      presses since the last call to this function, and the
         *      coordinates of the cursor at the last button press
         */
        int button = *button_ptr;

        note_trace1(MOUSE_VERBOSE, "mouse_io:get_press(button=%d)", button);

        /* Now and with 1. This is a fix for Norton Editor, but may cause
           problems for programs which use both mouse buttons pressed
           simultaneously, in which case need both bottom bits of button
           preserved, which may break Norton Editor again. sigh. */
        button &= 1;

        if (mouse_button_in_range(button))
        {
                *button_status_ptr = cursor_status.button_status;
                *button_ptr = button_transitions[button].press_count;
                button_transitions[button].press_count = 0;
                *cursor_x_ptr = button_transitions[button].press_position.x;
                *cursor_y_ptr = button_transitions[button].press_position.y;
        }

        note_trace4(MOUSE_VERBOSE, "mouse_io:return(bs=%d,ct=%d,x=%d,y=%d)",
                    *button_status_ptr, *button_ptr,
                    *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_get_release IFN4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the status of a button, the number of
         *      releases since the last call to this function, and the
         *      coordinates of the cursor at the last button release
         */
        int button = *button_ptr;

        note_trace1(MOUSE_VERBOSE, "mouse_io:get_release(button=%d)",
                    *button_ptr);

        /* fix for norton editor, see previous comment */
        button &= 1;

        if (mouse_button_in_range(button))
        {
                *button_status_ptr = cursor_status.button_status;
                *button_ptr = button_transitions[button].release_count;
                button_transitions[button].release_count = 0;
                *cursor_x_ptr = button_transitions[button].release_position.x;
                *cursor_y_ptr = button_transitions[button].release_position.y;
        }

        note_trace4(MOUSE_VERBOSE, "mouse_io:return(bs=%d,ct=%d,x=%d,y=%d)",
                    *button_status_ptr, *button_ptr,
                    *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_set_range_x IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_x_ptr,MOUSE_SCALAR *,maximum_x_ptr)
{
        /*
         *      This function sets the horizontal range within which
         *      movement of the cursor is to be restricted
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_range_x(min=%d,max=%d)",
                    *minimum_x_ptr, *maximum_x_ptr);

        /*
         *      Update the current cursor window, normalise it and validate
         *      it
         */
        cursor_window.top_left.x = *minimum_x_ptr;
        cursor_window.bottom_right.x = *maximum_x_ptr;
        area_normalise(&cursor_window);
#ifdef NTVDM
        /* make host aware of the new range setting because it is the one doing
         * clipping based on video mode setting.
         * Flight Simulator runs on 320x400 256 color mode and set the
         * cursor range to (0-13f, 0-18f). Without notifying the host,
         * the mouse cursor is always contrained to standard video mode
         * resolution which is not what the application wanted.
         */
        host_x_range(NULL, NULL, &cursor_window.top_left.x, &cursor_window.bottom_right.x);
#endif

        /*
         *      Reflect the change in the cursor position on the screen
         */
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_set_range_y IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_y_ptr,MOUSE_SCALAR *,maximum_y_ptr)
{
        /*
         *      This function sets the vertical range within which
         *      movement of the cursor is to be restricted
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_range_y(min=%d,max=%d)",
                    *minimum_y_ptr, *maximum_y_ptr);

        /*
         *      Update the current cursor window, normalise it and validate
         *      it
         */
        cursor_window.top_left.y = *minimum_y_ptr;
        cursor_window.bottom_right.y = *maximum_y_ptr;
        area_normalise(&cursor_window);
#ifdef NTVDM
        /* make host aware of the new range setting because it is the one doing
         * clipping based on video mode setting.
         * Flight Simulator runs on 320x400 256 color mode and set the
         * cursor range to (0-13f, 0-18f). Without notifying the host,
         * the mouse cursor is always contrained to standard video mode
         * resolution which is not what the application wanted.
         */
        host_y_range(NULL, NULL, &cursor_window.top_left.y, &cursor_window.bottom_right.y);
#endif


        /*
         *      Reflect the change in the cursor position on the screen
         */
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


LOCAL void copy_default_graphics_cursor IFN0()
{

                int line;
                UTINY temp;
                IU32 temp2;

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                {
                        temp = (UTINY)((graphics_cursor.screen[line] & 0xff00) >> 8);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_lo[line] = ( temp2 << 16 ) | temp2;

                        temp = (UTINY)(graphics_cursor.screen[line] & 0xff);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_hi[line] = ( temp2 << 16 ) | temp2;

                }

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                {
                        temp = (UTINY)((graphics_cursor.cursor[line] & 0xff00) >> 8);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_lo[line] = ( temp2 << 16 ) | temp2;

                        temp = (UTINY)(graphics_cursor.cursor[line] & 0xff);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_hi[line] = ( temp2 << 16 ) | temp2;

                }

}


LOCAL void mouse_set_graphics IFN4(word *,junk1,MOUSE_SCALAR *,hot_spot_x_ptr,MOUSE_SCALAR *,hot_spot_y_ptr,word *,bitmap_address)
{
        /*
         *      This function defines the shape, colour and hot spot of the
         *      graphics cursor
         */

        UNUSED(junk1);

#ifndef NTVDM

#ifdef MOUSE_16_BIT
        mouse16bSetBitmap( hot_spot_x_ptr , hot_spot_y_ptr , bitmap_address );
#else           /* MOUSE_16_BIT */

        if (host_mouse_installed())
        {
                host_mouse_set_graphics(hot_spot_x_ptr, hot_spot_y_ptr, bitmap_address);
        }
        else
        {
                MOUSE_SCREEN_DATA *mask_address;
                int line;
                UTINY temp;
                IU32 temp2;

                /*
                 *      Set graphics cursor hot spot
                 */
                point_set(&graphics_cursor.hot_spot, *hot_spot_x_ptr, *hot_spot_y_ptr);

                /*
                 *      Set graphics cursor screen and cursor masks
                 */
                mask_address = (MOUSE_SCREEN_DATA *)effective_addr(getES(), *bitmap_address);

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++, mask_address++)
                {
                        sas_load((sys_addr)mask_address + 1, &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_lo[line] = ( temp2 << 16 ) | temp2;

                        sas_load((sys_addr)mask_address , &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_hi[line] = ( temp2 << 16 ) | temp2;

                        graphics_cursor.screen[line] = ( graphics_cursor.screen_hi[line] & 0xff )
                                                                        | ( graphics_cursor.screen_lo[line] << 8 );
                }

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++, mask_address++)
                {
                        sas_load((sys_addr)mask_address + 1, &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_lo[line] = ( temp2 << 16 ) | temp2;

                        sas_load((sys_addr)mask_address , &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_hi[line] = ( temp2 << 16 ) | temp2;

                        graphics_cursor.cursor[line] = ( graphics_cursor.cursor_hi[line] & 0xff )
                                                                        | ( graphics_cursor.cursor_lo[line] << 8 );
                }

        }
#endif /* MOUSE_16_BIT */
#endif /* NTVDM */
        /*
         *      Redisplay cursor if necessary
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();
}




LOCAL void mouse_set_text IFN4(word *,junk1,MOUSE_STATE *,text_cursor_type_ptr,MOUSE_SCREEN_DATA *,parameter1_ptr,MOUSE_SCREEN_DATA *,parameter2_ptr)
{
        /*
         *      This function selects the software or hardware text cursor
         */
        UNUSED(junk1);

#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
        {
                fprintf(trace_file, "mouse_io:set_text(type=%d,",
                        *text_cursor_type_ptr);
                if (*text_cursor_type_ptr == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                        fprintf(trace_file, "screen=0x%x,cursor=0x%x)\n",
                                *parameter1_ptr, *parameter2_ptr);
                else
                        fprintf(trace_file, "start=%d,stop=%d)\n",
                                *parameter1_ptr, *parameter2_ptr);
        }
#endif

        if (mouse_text_cursor_type_in_range(*text_cursor_type_ptr))
        {
                /*
                 *      Remove existing text cursor
                 */
                cursor_undisplay();

                text_cursor_type = *text_cursor_type_ptr;
#ifdef EGG
                if (jap_mouse) {
                  /* we need to emulate the text cursor in the
                   * current graphics mode. Just do a block at present
                   */
                  int line;
                  for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                    {
                      graphics_cursor.cursor[line]=0xff00;
                      graphics_cursor.screen[line]=0xffff;
                    }
                  point_set(&(graphics_cursor.hot_spot),0,0);
                  point_set(&(graphics_cursor.size),MOUSE_GRAPHICS_CURSOR_WIDTH,MOUSE_GRAPHICS_CURSOR_WIDTH);
                  copy_default_graphics_cursor();
                } else
#endif /* EGG */
                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                {
                        /*
                         *      Parameters are the data for the screen
                         *      and cursor masks
                         */
                        software_text_cursor.screen = *parameter1_ptr;
                        software_text_cursor.cursor = *parameter2_ptr;
                }
                else
                {
                        /*
                         *      Parameters are the scan line start and
                         *      stop values
                         */
                        word savedIP = getIP(), savedCS = getCS();

                        setCH((UCHAR)(*parameter1_ptr));
                        setCL((UCHAR)(*parameter2_ptr));
                        setAH(MOUSE_VIDEO_SET_CURSOR);

                        setCS(VIDEO_IO_SEGMENT);
                        setIP(VIDEO_IO_RE_ENTRY);
                        host_simulate();
                        setCS(savedCS);
                        setIP(savedIP);
                }

                /*
                 *      Put new text cursor on screen
                 */
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                        cursor_display();
        }

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_read_motion IFN4(word *,junk1,word *,junk2,MOUSE_COUNT *,motion_count_x_ptr,MOUSE_COUNT *,motion_count_y_ptr)
{
        /*
         *      This function returns the horizontal and vertical mouse
         *      motion counts since the last call; the motion counters
         *      are cleared
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace0(MOUSE_VERBOSE, "mouse_io:read_motion()");

        *motion_count_x_ptr = mouse_motion.x;
        mouse_motion.x = 0;
        *motion_count_y_ptr = mouse_motion.y;
        mouse_motion.y = 0;


        note_trace2(MOUSE_VERBOSE, "mouse_io:return(x=%d,y=%d)",
                    *motion_count_x_ptr, *motion_count_y_ptr);
}




LOCAL void mouse_set_subroutine IFN4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address)
{
        /*
         *      This function sets the call mask and subroutine address
         *      for a user function to be called when a mouse interrupt
         *      occurs
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace3(MOUSE_VERBOSE,
                    "mouse_io:set_subroutine(CS:IP=%x:%x,mask=0x%02x)",
                    getES(), *subroutine_address, *call_mask);

        user_subroutine_segment = getES();
        user_subroutine_offset = *subroutine_address;
        user_subroutine_call_mask = (MOUSE_CALL_MASK)((*call_mask) & MOUSE_CALL_MASK_SIGNIFICANT_BITS);

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


/* unpublished service 20, used by Microsoft Windows */
LOCAL void mouse_get_and_set_subroutine IFN4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address)
{
        /*
        same as set_subroutine (function 12) but also returns previous call mask in cx (m3)
        and user subroutine address in es:dx (es:m4)
        */
        word local_segment, local_offset,  local_call_mask;

        note_trace3(MOUSE_VERBOSE,
                    "mouse_io:get_and_set_subroutine(CS:IP=%x:%x,mask=0x%02x)",
                    getES(), *subroutine_address, *call_mask);

        local_offset = user_subroutine_offset;
        local_segment = user_subroutine_segment;
        local_call_mask = user_subroutine_call_mask;
        /* save previous subroutine data so it can be returned */

        mouse_set_subroutine(junk1,junk2,call_mask,subroutine_address);
        /* set the subroutine stuff with the normal function 12 */
        *call_mask = local_call_mask;
        *subroutine_address = local_offset;
        setES(local_segment);
}



LOCAL void mouse_light_pen_on IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function enables light pen emulation
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:light_pen_on()");

        light_pen_mode = TRUE;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_light_pen_off IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function disables light pen emulation
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:light_pen_off()");

        light_pen_mode = FALSE;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_set_ratio IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,ratio_x_ptr,MOUSE_SCALAR *,ratio_y_ptr)
{
        /*
         *      This function sets the Mickey to Pixel ratio in the
         *      horizontal and vertical directions
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_ratio(x=%d,y=%d)",
                    *ratio_x_ptr, *ratio_y_ptr);

                /*
                 *      Update the Mickey to pixel ratio in force
                 */
                if (mouse_ratio_in_range(*ratio_x_ptr))
                        mouse_gear.x = *ratio_x_ptr;
                if (mouse_ratio_in_range(*ratio_y_ptr))
                        mouse_gear.y = *ratio_y_ptr;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_conditional_off IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,upper_x_ptr,MOUSE_SCALAR *,upper_y_ptr)
{
        /*
         *      This function defines an area of the virtual screen where
         *      the mouse is automatically hidden
         */
        MOUSE_SCALAR lower_x = getSI(), lower_y = getDI();

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace4(MOUSE_VERBOSE,
                    "mouse_io:conditional_off(ux=%d,uy=%d,lx=%d,ly=%d)",
                    *upper_x_ptr, *upper_y_ptr, lower_x, lower_y);

        /*
         *      Update the conditional off area and normalise it: the Microsoft
         *      driver adds a considerable "margin for error" to the left and
         *      above the conditional off area requested - we must do the same
         *      to behave compatibly
         */
        black_hole.top_left.x = (*upper_x_ptr) - MOUSE_CONDITIONAL_OFF_MARGIN_X;
        black_hole.top_left.y = (*upper_y_ptr) - MOUSE_CONDITIONAL_OFF_MARGIN_Y;
        black_hole.bottom_right.x = lower_x + 1;
        black_hole.bottom_right.y = lower_y + 1;
        area_normalise(&black_hole);

        /*
         *      If the cursor is currently displayed, redisplay taking the
         *      conditional off area into account
         */
#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
        {
                if ((cursor_position.x >= black_hole.top_left.x) &&
                        (cursor_position.x <= black_hole.bottom_right.x) &&
                        (cursor_position.y >= black_hole.top_left.y) &&
                        (cursor_position.y <= black_hole.bottom_right.y))
                        if (cursor_flag-- == MOUSE_CURSOR_DISPLAYED)
                                mouse16bHidePointer();
        }
        else
#endif  /* MOUSE_16_BIT */
        {
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();
        }
#if defined (NTVDM) && defined(MONITOR)

    sas_store(conditional_off_sysaddr, 1);
    host_mouse_conditional_off_enabled();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


LOCAL void mouse_get_state_size IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function returns the size of buffer the caller needs to
         *      supply to mouse function 22 (save state)
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_state_size()");

        *m2 = (word)mouse_context_size;

        note_trace1(MOUSE_VERBOSE, "mouse_io: ...size is %d(decimal) bytes.",
                    *m2);
}


LOCAL void mouse_save_state IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function saves the state of the driver in the user-supplied
         *      buffer ready for subsequent passing to mouse function 23 (restore
         *      state)
         *
         *      Note that a magic cookie and checksum are placed in the saved state so that the
         *      restore routine can ignore invalid calls.
         */
        sys_addr                dest;
        IS32                    cs = 0;
#ifdef NTVDM
        IS32                    i;
        IU8*                    ptr;
#ifdef MONITOR

    /* real CF resides in 16 bit code */
    int             saved_cursor_flag = cursor_flag;
    IS8             copyCF;
#endif
#endif
        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);

#if defined(NTVDM) && defined(MONITOR)
    sas_load(mouseCFsysaddr, &copyCF);
    cursor_flag = (int)copyCF;
#endif
        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_save_state()");

        dest = effective_addr (getES(), *m4);

        /* Save Cookie */
        sas_stores(dest, (IU8 *)mouse_context_magic, MOUSE_CONTEXT_MAGIC_SIZE);
        dest += MOUSE_CONTEXT_MAGIC_SIZE;

        /* Save Context Variables */
        sas_stores(dest, (IU8 *)&mouse_context, sizeof(MOUSE_CONTEXT));
        dest += sizeof(MOUSE_CONTEXT);
#ifdef NTVDM
        /* calculate checksum */
        for (i = 0; i < MOUSE_CONTEXT_MAGIC_SIZE; i++)
            cs += (IU8)(mouse_context_magic[i]);
        ptr = (IU8*)&mouse_context;
        for (i = 0; i < sizeof(MOUSE_CONTEXT); i++)
            cs += *ptr++;
#endif
        /* Save Checksum */
        sas_store (dest, (byte)(cs & 0xFF));

#if defined(NTVDM) && defined(MONITOR)
    cursor_flag = saved_cursor_flag;
#endif
}


LOCAL void mouse_restore_state IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifndef NEC_98
        /*
         *      This function restores the state of the driver from the user-supplied
         *      buffer which was set up by a call to mouse function 22.
         *
         *      Note that a magic cookie and checksum were placed in the saved state so this routine
         *      checks for its presence and ignores the call if it is not found.
         */
        sys_addr                src;
        IS32                    i;
        IS32                    cs = 0;
        half_word               b;
        boolean                 valid=TRUE;

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_restore_state()");

        src = effective_addr (getES(), *m4);

        /* Check Cookie */
        for (i=0; valid && i<MOUSE_CONTEXT_MAGIC_SIZE; i++){
                sas_load (src, &b);
                valid = (b == mouse_context_magic[i]);
                src++;
        }

        if (valid){
                /* Cookie was present... check checksum */
                src = effective_addr (getES(), *m4);
                for (i=0; i<MOUSE_CONTEXT_MAGIC_SIZE; i++){
                        sas_load (src, &b);
                        cs += b;
                        src++;
                }
                for (i = 0; i < sizeof(MOUSE_CONTEXT); i++){
                        sas_load (src, &b);
                        cs += b;
                        src++;
                }
                sas_load (src, &b);     /* Pick up saved checksum */
                valid = (b == (half_word)(cs & 0xFF));
        }
        if (valid){
                /* Checksum OK, too.... load up our variables */
                cursor_undisplay();
                src = effective_addr (getES(), *m4) + MOUSE_CONTEXT_MAGIC_SIZE;
                sas_loads(src, (IU8 *)&mouse_context, sizeof(MOUSE_CONTEXT));
#ifdef EGG
                mouse_ega_mode (sas_hw_at(vd_video_mode));
#endif
#if defined(NTVDM) && defined(MONITOR)
        /* real CF resides in 16 Bit code:  */
        sas_store(mouseCFsysaddr, (half_word)cursor_flag);
        if (cursor_flag )
            cursor_flag = MOUSE_CURSOR_DEFAULT;
#endif
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED){
                        cursor_display();
                }
        }else{
                /* Something failed.... ignore the call */
#ifndef PROD
                printf ("mouse_io.c: invalid call to restore context.\n");
#endif
        }
#endif   //NEC_98
}


LOCAL void mouse_set_alt_subroutine IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function sets up to 3 alternate event handlers for mouse
         *      events which occur while various combinations of the Ctrl, Shift
         *      and Alt keys are down.
         */
        boolean found_one=FALSE;
        int i;

        UNUSED(m2);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_alt_subroutine()");

        if (*m3 & MOUSE_CALL_MASK_KEY_BITS){
                /* Search for entry with same key combination */
                for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                        found_one = (*m3 & MOUSE_CALL_MASK_KEY_BITS)==(alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS);
                }

                if (!found_one){
                        /* Does not match existing entry... try to find free slot */
                        for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                                found_one = (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS) == 0;
                        }
                }

                if (found_one){
                        i--;    /* Adjust for final increment */
                        alt_user_subroutine_call_mask[i] = *m3;
                        if (*m3 & MOUSE_CALL_MASK_SIGNIFICANT_BITS){
                                /* New value active */
                                alt_user_subroutines_active = TRUE;
                                alt_user_subroutine_offset[i] = *m4;
                                alt_user_subroutine_segment[i] = getES();
                        }else{
                                /* New value is not active - check if we've disabled the last one */
                                alt_user_subroutines_active = FALSE;
                                for (i=0; !alt_user_subroutines_active && i<NUMBER_ALT_SUBROUTINES; i++){
                                        alt_user_subroutines_active =
                                                (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_SIGNIFICANT_BITS) != 0;
                                }
                        }
                        /* Return success */
                        *m1 = 0;
                }else{
                        /* Request failed - no free slot */
                        *m1 = 0xFFFF;
                }
        }else{
                /* Error - no key bits set in request */
                *m1 = 0xFFFF;
        }
}


LOCAL void mouse_get_alt_subroutine IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function obtains the address of a specific alternate
         *      user event handling subroutine as set up by a previous call
         *      to mouse function 24.
         */
        boolean found_one=FALSE;
        int i;

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_alt_subroutine()");

        if (*m3 & MOUSE_CALL_MASK_KEY_BITS){
                /* Search for entry with same key combination */
                for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                        found_one = (*m3 & MOUSE_CALL_MASK_KEY_BITS)==(alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS);
                }

                if (found_one){
                        i--;    /* Adjust for final increment */
                        *m3 = alt_user_subroutine_call_mask[i];
                        *m2 = alt_user_subroutine_segment[i];
                        *m4 = alt_user_subroutine_offset[i];
                        /* Return success */
                        *m1 = 0;
                }else{
                        /* Request failed - not found */
                        *m1 = 0xFFFF;
                        *m2 = *m3 = *m4 = 0;
                }
        }else{
                /* Error - no key bits set in request */
                *m1 = 0xFFFF;
                *m2 = *m3 = *m4 = 0;
        }
}


LOCAL void mouse_set_sensitivity IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function sets a new value for the mouse sensitivity and
         *      double speed threshold.
         *      The sensitivity value is used before the mickeys per pixel
         *      ratio is applied.
         */

        UNUSED(m1);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_sensitivity()");

                if (mouse_sens_in_range(*m2))
                {
                        mouse_sens_val.x = mouse_sens_calc_val(*m2);
                        mouse_sens.x     = *m2;
                }
                else
                {
                        mouse_sens_val.x = MOUSE_SENS_DEF_VAL;
                        mouse_sens.x     = MOUSE_SENS_DEF;
                }
                if (mouse_sens_in_range(*m3))
                {
                        mouse_sens_val.y = mouse_sens_calc_val(*m3);
                        mouse_sens.y     = *m3;
                }
                else
                {
                        mouse_sens_val.y = MOUSE_SENS_DEF_VAL;
                        mouse_sens.y     = MOUSE_SENS_DEF;
                }
                /*
                 *      m4 has speed double threshold value... still needs to be implemented.
                 */
                if (mouse_sens_in_range(*m4))
                        mouse_double_thresh = *m4;
                else
                        mouse_double_thresh = MOUSE_DOUBLE_DEF;
}


LOCAL void mouse_get_sensitivity IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function returns the current value of the mouse sensitivity.
         */

        UNUSED(m1);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_sensitivity()");

        *m2 = mouse_sens.x;
        *m3 = mouse_sens.y;
        *m4 = mouse_double_thresh;
}


LOCAL void mouse_set_int_rate IFN4
   (
   word *, m1,
   word *, int_rate_ptr,
   word *, m3,
   word *, m4
   )
   {
   /*
      Func 28: Set Mouse Interrupt Rate.
               0 = No interrupts
               1 = 30 interrupte/sec
               2 = 50 interrupte/sec
               3 = 100 interrupte/sec
               4 = 200 interrupte/sec
               >4 = undefined
    */

   UNUSED(m1);
   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE, "mouse_io: set_int_rate(rate=%d)", *int_rate_ptr);

   /* Just remember rate, for later return (Func 51). We don't actually
      action it. */
   mouse_interrupt_rate = (half_word)*int_rate_ptr;

   note_trace0(MOUSE_VERBOSE, "mouse_io: return()");
   }


LOCAL void mouse_set_pointer_page IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifndef NEC_98
        /*
         *      This function sets the current mouse pointer video page.
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_pointer_page()");

        if (is_valid_page_number(*m2)){
                cursor_undisplay();
                cursor_page = *m2;
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED){
                        cursor_display();
                }
        }else{
#ifndef PROD
                fprintf(trace_file, "mouse_io: Bad page requested\n");
#endif
        }
#endif    //NEC_98
}


LOCAL void mouse_get_pointer_page IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function gets the value of the current mouse pointer
         *      video page.
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_pointer_page()");
        *m2 = (word)cursor_page;
}


LOCAL void mouse_driver_disable IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function disables the mouse driver and de-installs the
         *      interrupt vectors (bar INT 33h, whose previous value is
         *      returned to the caller to allow them to use DOS function
         *      25h to completely remove the mouse driver).
         */
        boolean         failed = FALSE;
#ifdef NTVDM
    word        current_int71_offset, current_int71_segment;
#else
        word            current_int0A_offset, current_int0A_segment;
        word            current_int10_offset, current_int10_segment;
#endif
        half_word       interrupt_mask_register;

        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_disable()");
        mouse_driver_disabled = TRUE;

        if (!failed){
#ifdef NTVDM
        sas_loadw (int_addr(0x71) + 0, &current_int71_offset);
        sas_loadw (int_addr(0x71) + 2, &current_int71_segment);
        failed = current_int71_offset  != MOUSE_INT1_OFFSET ||
                 current_int71_segment != MOUSE_INT1_SEGMENT;
#else
                sas_loadw (int_addr(MOUSE_VEC) + 0, &current_int0A_offset);
                sas_loadw (int_addr(MOUSE_VEC) + 2, &current_int0A_segment);
                sas_loadw (int_addr(0x10) + 0, &current_int10_offset);
                sas_loadw (int_addr(0x10) + 2, &current_int10_segment);
                failed = current_int0A_offset  != MOUSE_INT1_OFFSET ||
                         current_int0A_segment != MOUSE_INT1_SEGMENT ||
                         current_int10_offset  != MOUSE_VIDEO_IO_OFFSET ||
                         current_int10_segment != MOUSE_VIDEO_IO_SEGMENT;
#endif
        }
        if (!failed){
                /*
                 *      Disable mouse H/W interrupts
                 */
                inb(ICA1_PORT_1, &interrupt_mask_register);
                interrupt_mask_register |= (1 << AT_CPU_MOUSE_INT);
                outb(ICA1_PORT_1, interrupt_mask_register);
                inb(ICA0_PORT_1, &interrupt_mask_register);
                interrupt_mask_register |= (1 << CPU_MOUSE_INT);
                outb(ICA0_PORT_1, interrupt_mask_register);
                /*
                 *      Restore interrupt vectors
                 */

#ifdef NTVDM
                sas_storew (int_addr(0x71) + 0, saved_int71_offset);
                sas_storew (int_addr(0x71) + 2, saved_int71_segment);
#else
                sas_storew (int_addr(MOUSE_VEC) + 0, saved_int0A_offset);
                sas_storew (int_addr(MOUSE_VEC) + 2, saved_int0A_segment);
                sas_storew (int_addr(0x10) + 0, saved_int10_offset);
                sas_storew (int_addr(0x10) + 2, saved_int10_segment);
#endif
                /*
                 *      Return success status and old INT33h vector
                 */
                *m1 = 0x1F;
                *m2 = saved_int33_offset;
                *m3 = saved_int33_segment;
        }else{
                /*
                 * Return failure
                 */
                *m1 = 0xFFFF;
        }
}


LOCAL void mouse_driver_enable IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function re-enables the mouse driver after a call to
         *      function 31 (disable mouse driver).
         */
        word hook_offset;
        half_word       interrupt_mask_register;

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_driver_enable()");

        /*
         * This prevents an endless loop of calls to mouse_video_io() if an
         * application does a Mouse Driver Enable without first having done
         * a Mouse Driver Disable
         */
        if (!mouse_driver_disabled)
                return;

        mouse_driver_disabled = FALSE;

        /*
         *      Reload bus mouse hardware interrupt
         */

#ifdef NTVDM
    sas_loadw (int_addr(0x71) + 0, &saved_int71_offset);
    sas_loadw (int_addr(0x71) + 2, &saved_int71_segment);
    sas_storew(int_addr(0x71), MOUSE_INT1_OFFSET);
    sas_storew(int_addr(0x71) + 2, MOUSE_INT1_SEGMENT);
#else
        sas_loadw (int_addr(MOUSE_VEC) + 0, &saved_int0A_offset);
        sas_loadw (int_addr(MOUSE_VEC) + 2, &saved_int0A_segment);
        sas_storew(int_addr(MOUSE_VEC), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(MOUSE_VEC) + 2, MOUSE_INT1_SEGMENT);
#endif

        /*
         *      Enable mouse hardware interrupts in the ica
         */
        inb(ICA1_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << AT_CPU_MOUSE_INT);
        outb(ICA1_PORT_1, interrupt_mask_register);
        inb(ICA0_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << CPU_MOUSE_INT);
        outb(ICA0_PORT_1, interrupt_mask_register);

        /*
         *      Mouse io user interrupt
         */

#ifndef NTVDM
        /* Read offset of INT 33 procedure from MOUSE.COM */
        sas_loadw(effective_addr(getCS(), OFF_HOOK_POSN), &hook_offset);

        sas_storew(int_addr(0x33), hook_offset);
        sas_storew(int_addr(0x33) + 2, getCS());

        /*
         *      Mouse video io user interrupt
         */
        sas_loadw (int_addr(0x10) + 0, &saved_int10_offset);
        sas_loadw (int_addr(0x10) + 2, &saved_int10_segment);
        sas_storew(int_addr(0x10), MOUSE_VIDEO_IO_OFFSET);
        sas_storew(int_addr(0x10) + 2, MOUSE_VIDEO_IO_SEGMENT);
#endif /* NTVDM */
}


LOCAL void mouse_set_language IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is only applicable to an international version
         *      of a mouse driver... which this is not! Acts as a NOP.
         */

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_language()");
        /* NOP */
}


LOCAL void mouse_get_language IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is only meaningful on an international version
         *      of a mouse driver... which this is not! Always returns 0
         *      (English).
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_language()");

#ifdef KOREA
        // Korean DOS apps want this bit(e.g. Edit.com, Multi Plan)
        // 10/14/96 bklee
        *m2 = 9;
#else   0 = English
        *m2 = 0;
#endif

        note_trace1(MOUSE_VERBOSE,
                    "mouse_io: mouse_get_language returning m2=0x%04x.", *m2);
}


LOCAL void mouse_get_info IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function obtains certain information about the mouse
         *      driver and hardware.
         */
        UNUSED(m1);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_info()");

        *m2 = ((word)mouse_emulated_release << 8) | (word)mouse_emulated_version;
        *m3 = ((word)MOUSE_TYPE_INPORT << 8)      | (word)CPU_MOUSE_INT;

        note_trace2(MOUSE_VERBOSE,
                    "mouse_io: mouse_get_info returning m2=0x%04x, m3=0x%04x.",
                    *m2, *m3);
}


LOCAL void mouse_get_driver_info IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        *m1 = (current_video_mode > 3 ? 0x2000 : 0) | 0x100;
        /*      bit 15 = 0 for COM v SYS
                bit 14 = 0 for original non-integrated type
                bit 13 is 1 for graphics cursor or 0 for text
                bit 12 = 0 for software cursor
                bits 8-11 are encoded interrupt rate, 1 means 30 Hz
                bits 0-7 used only by integrated driver
        */
        *m2 = 0;        /* fCursorLock, used by driver under OS/2 */
        *m3 = 0;        /* fInMouseCode, flag for current execution path
                        being inside mouse driver under OS/2. Since the
                        driver is in a bop it can't be interrupted */
        *m4 = 0;        /* fMouseBusy, similar to *m3 */
}


LOCAL void mouse_get_max_coords IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifdef NTVDM
IMPORT word VirtualX, VirtualY;
#endif

        UNUSED(m1);

#ifdef NTVDM
    *m3 = VirtualX;
    *m4 = VirtualY;
#endif

        *m2 = mouse_driver_disabled;

#ifndef NTVDM
        get_screen_size();
        *m3 = virtual_screen.bottom_right.x - 1;
        *m4 = virtual_screen.bottom_right.y - 1;
#endif
}

LOCAL void mouse_get_masks_and_mickeys IFN4
   (
   MOUSE_SCREEN_DATA *, screen_mask_ptr,
   MOUSE_SCREEN_DATA *, cursor_mask_ptr,
   MOUSE_SCALAR *,      raw_horiz_count_ptr,
   MOUSE_SCALAR *,      raw_vert_count_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 39: Get Screen/Cursor Masks and Mickey Counts.
    */
   word cursor_mode;

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_masks_and_mickeys");

   /* read and reset counts */
   *raw_horiz_count_ptr = mouse_raw_motion.x;
   *raw_vert_count_ptr = mouse_raw_motion.y;
   mouse_raw_motion.x = mouse_raw_motion.y = 0;

   if ( text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE )
      {
      *screen_mask_ptr = software_text_cursor.screen;
      *cursor_mask_ptr = software_text_cursor.cursor;

      note_trace4(MOUSE_VERBOSE,
         "mouse_io: return(screen=0x%x, mask=0x%x, raw mickeys=(%d,%d))",
         *screen_mask_ptr,
         *cursor_mask_ptr,
         *raw_horiz_count_ptr,
         *raw_vert_count_ptr);
      }
   else
      {
      /* Read BIOS data variable */
      sas_loadw((sys_addr)VID_CURMOD, &cursor_mode);

      /* Then extract start and stop from it */
      *screen_mask_ptr = cursor_mode >> 8;      /* start */
      *cursor_mask_ptr = cursor_mode & 0xff;    /* stop */

      note_trace4(MOUSE_VERBOSE,
         "mouse_io: return(start=%d, stop=%d, raw mickeys=(%d,%d))",
         *screen_mask_ptr,
         *cursor_mask_ptr,
         *raw_horiz_count_ptr,
         *raw_vert_count_ptr);
      }
#endif   //NEC_98
   }

LOCAL void mouse_set_video_mode IFN4
   (
   word *, m1,
   word *, m2,
   word *, video_mode_ptr,
   word *, font_size_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 40 Set Video Mode. NB. This only sets the mouse state to
      match the video mode. Actual changes to the video mode are still
      made by the application calling the BIOS.
    */

   UNUSED(m1);
   UNUSED(m2);

   note_trace2(MOUSE_VERBOSE,
      "mouse_io: set_video_mode(mode=0x%x, font size=0x%x)",
      *video_mode_ptr, *font_size_ptr);

   /* Check validity of mode */
   if ( is_bad_vid_mode(*video_mode_ptr) && !is_v7vga_mode(*video_mode_ptr) )
      {
      /* Bad mode do nothing */
      ;
      }
   else
      {
      /* Update our parameters, as per the given mode */
      current_video_mode = *video_mode_ptr;

      mouse_adjust_screen_size();

      cursor_undisplay();
      cursor_flag = MOUSE_CURSOR_DEFAULT;
      cursor_mode_change(current_video_mode);

#ifdef MOUSE_16_BIT
      /* Remember whether in text or graphics mode for later use. */
      is_graphics_mode = ((current_video_mode > 3) &&
                          (current_video_mode != 7));
#endif /* MOUSE_16_BIT */

      *video_mode_ptr = 0;   /* Indicate success */
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(mode=0x%x)",
      *video_mode_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_enumerate_video_modes IFN4
   (
   word *, m1,
   word *, m2,
   word *, video_nr_ptr,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 41 Enumerate Video Modes.
    */

   UNUSED(m1);
   UNUSED(m2);

   note_trace1(MOUSE_VERBOSE, "mouse_io: enumerate_video_modes(mode=0x%x)", *video_nr_ptr);

   /* Do they want to reset to first entry */
   if ( *video_nr_ptr == 0 )
      {
      next_video_mode = 1;   /* Yes */
      }

   /* Blindly try all possible mode settings */
   while ( next_video_mode <= MAX_NR_VIDEO_MODES )
      {
      if ( is_bad_vid_mode(next_video_mode) && !is_v7vga_mode(next_video_mode) )
         {
         next_video_mode++;   /* keep searching */
         }
      else
         {
         break;   /* stop searching as valid mode has been found */
         }
      }

   /* Action setting found, or end of list */
   if ( next_video_mode > MAX_NR_VIDEO_MODES )
      {
      *video_nr_ptr = 0;
      }
   else
      {
      *video_nr_ptr = (word)next_video_mode;
      next_video_mode++;   /* update for next call */
      }

   /* We don't provide string descriptions */
   setES(0);
   *offset_ptr = 0;

   note_trace3(MOUSE_VERBOSE, "mouse_io: return(mode=0x%x, seg=0x%x, off=0x%x)",
      *video_nr_ptr, getES(), *offset_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_cursor_hot_spot IFN4
   (
   word *,         fCursor_ptr,
   MOUSE_SCALAR *, hot_spot_x_ptr,
   MOUSE_SCALAR *, hot_spot_y_ptr,
   word *,         mouse_type_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 42: Return cursor hot spot location, the type of mouse in
      use, and the internal counter that controls cursor visibility.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_cursor_hot_spot");

   *fCursor_ptr = (word)cursor_flag;

   *hot_spot_x_ptr = graphics_cursor.hot_spot.x;
   *hot_spot_y_ptr = graphics_cursor.hot_spot.y;

   *mouse_type_ptr = MOUSE_TYPE_INPORT;

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(cursor flag = %d, hotspot = (%d,%d), type = %d)",
      *fCursor_ptr,
      *hot_spot_x_ptr, *hot_spot_y_ptr,
      *mouse_type_ptr);
#endif    //NEC_98
   }

/* Load acceleration curve from Intel memory to Host memory */
LOCAL void load_acceleration_curve IFN3
   (
   word, seg,   /* Pointer to Intel Memory */
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve   /* Pointer to Host Memory */
   )
   {
#ifndef NEC_98
   int i, j;

   /* Read lengths */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      hcurve->ac_length[i] = sas_hw_at(effective_addr(seg, off));
      off++;
      }

   /* Read mickey counts */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_MICKEY_COUNTS; j++)
         {
         hcurve->ac_count[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }

   /* Read scale factors */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_SCALE_FACTORS; j++)
         {
         hcurve->ac_scale[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }

   /* Read names */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_NAME_CHARS; j++)
         {
         hcurve->ac_name[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }
#endif    //NEC_98
   }

/* Store acceleration curve from Host memory to Intel memory */
LOCAL void store_acceleration_curve IFN3
   (
   word, seg,   /* Pointer to Intel Memory */
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve   /* Pointer to Host Memory */
   )
   {
#ifndef NEC_98
   int i, j;

   /* Write lengths */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      sas_store(effective_addr(seg, off), hcurve->ac_length[i]);
      off++;
      }

   /* Write mickey counts */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_MICKEY_COUNTS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_count[i][j]);
         off++;
         }
      }

   /* Write scale factors */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_SCALE_FACTORS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_scale[i][j]);
         off++;
         }
      }

   /* Write names */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_NAME_CHARS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_name[i][j]);
         off++;
         }
      }
#endif    //NEC_98
   }

LOCAL void mouse_load_acceleration_curves IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 43: Load Acceleration Curves.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE,
      "mouse_io: load_acceleration_curve(curve=%d)", *curve_ptr);

   /* Check reason for call */
   if ( *curve_ptr == MOUSE_M1 )
      {
      /* Reset to default acceleration curve */
      active_acceleration_curve = 3;   /* Back to Normal */

      memcpy(&acceleration_curve_data, &default_acceleration_curve,
         sizeof(ACCELERATION_CURVE_DATA));

      *success_ptr = 0;   /* Completed OK */
      }
   else
      {
      /* Load new curve */
      if ( *curve_ptr >= 1 && *curve_ptr <= 4 )
         {
         /* Valid curve number - load it. */
         active_acceleration_curve = *curve_ptr;

         c_seg = getES();   /* Pick up pointer to Intel Data */
         c_off = getSI();

         /* INTEL => HOST */
         load_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

         *success_ptr = 0;   /* Completed OK */
         }
      else
         {
         /* Curve number out of range */
         *success_ptr = MOUSE_M1;
         }
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(success=0x%x)", *success_ptr);
#endif  //NEC_98
   }

LOCAL void mouse_read_acceleration_curves IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 44: Read Acceleration Curves.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: read_acceleration_curves");

   *success_ptr = 0;   /* Completed OK */

   *curve_ptr = (word)active_acceleration_curve;

   c_seg = getCS();   /* Set up pointer to Intel Buffer */
   c_off = OFF_ACCL_BUFFER;

   /* INTEL <= HOST */
   store_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

   setES(c_seg);
   setSI(c_off);

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(success=0x%x, curve=%d, seg=0x%x, off=0x%x)",
      *success_ptr, *curve_ptr, getES(), getSI());
#endif //NEC_98
   }

LOCAL void mouse_set_get_active_acceleration_curve IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 45: Set/Get Active Acceleration Curve.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE,
      "mouse_io: set_get_active_acceleration_curve(curve=%d)", *curve_ptr);

   /* Check reason for call */
   if ( *curve_ptr == MOUSE_M1 )
      {
      /* Return currently active curve */
      *curve_ptr = (word)active_acceleration_curve;
      *success_ptr = 0;   /* Completed OK */
      }
   else
      {
      /* Set new active curve */
      if ( *curve_ptr >= 1 && *curve_ptr <= 4 )
         {
         /* Valid curve number - make active */
         active_acceleration_curve = *curve_ptr;
         *success_ptr = 0;   /* Completed OK */
         }
      else
         {
         *curve_ptr = (word)active_acceleration_curve;
         *success_ptr = MOUSE_M2;   /* Failed */
         }
      }

   /* Return name to caller */
   c_seg = getCS();   /* Set up pointer to Intel Buffer */
   c_off = OFF_ACCL_BUFFER;

   /* INTEL <= HOST */
   store_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

   /* adjust pointer to select correct name */
   c_off = c_off + 4 + (4*32) + (4*32);   /* length,count,scale */
   c_off = c_off + ((active_acceleration_curve-1) * 16);

   setES(c_seg);
   setSI(c_off);

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(success=0x%x, curve=%d, seg=0x%x, off=0x%x)",
      *success_ptr, *curve_ptr, getES(), getSI());
#endif //NEC_98
   }

LOCAL void mouse_microsoft_internal IFN4
   (
   word *, m1,
   word *, m2,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 46: Microsoft Internal. We don't support it.
    */

   UNUSED(m1);
   UNUSED(m2);
   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: microsoft_internal NOT SUPPORTED!");
#endif    //NEC_98
   }

LOCAL void mouse_hardware_reset IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 47: Reset the mouse hardware and display variables.
      This is not a full software reset as per Func 0 or Func 33.
    */

   half_word crt_mode;

   UNUSED(m2);
   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: hardware_reset");

   inport_reset();   /* reset hardware */

   /* Update variables which depend on display hardware */
   sas_load(MOUSE_VIDEO_CRT_MODE, &crt_mode);
   cursor_mode_change((int)crt_mode);
   cursor_update();

   if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
      cursor_display();

   *status_ptr = MOUSE_M1;   /* ie success */

   note_trace0(MOUSE_VERBOSE, "mouse_io: return()");
#endif    //NEC_98
   }

LOCAL void mouse_set_get_ballpoint_info IFN4
   (
   word *, status_ptr,
   word *, rotation_angle_ptr,
   word *, button_mask_ptr,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 48: Get/Set Ballpoint Information.
      Note: We do not support a ballpoint device.
    */

   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: set_get_ballpoint_info");

   if ( *button_mask_ptr == 0 ) /* Check command request */
      {
      /* Get Status (Angle and Mask) Command */
      ;
      }
   else
      {
      /* Set Status (Angle and Mask) Command */
      note_trace2(MOUSE_VERBOSE,
         "mouse_io: Rotation Angle = %d, Button Mask = %d",
         *rotation_angle_ptr,
         *button_mask_ptr);
      }

   *status_ptr = MOUSE_M1;   /* ie not supported */
   note_trace0(MOUSE_VERBOSE, "mouse_io: return(NOT_SUPPORTED)");
#endif    //NEC_98
   }

LOCAL void mouse_get_min_max_virtual_coords IFN4
   (
   MOUSE_SCALAR *, min_x_ptr,
   MOUSE_SCALAR *, min_y_ptr,
   MOUSE_SCALAR *, max_x_ptr,
   MOUSE_SCALAR *, max_y_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 49: Return minimum and maximum virtual coordinates for
      current screen mode. The values are those set by Funcs 7 and 8.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_min_max_virtual_coords");

   *min_x_ptr = cursor_window.top_left.x;
   *min_y_ptr = cursor_window.top_left.y;
   *max_x_ptr = cursor_window.bottom_right.x;
   *max_y_ptr = cursor_window.bottom_right.y;

   note_trace4(MOUSE_VERBOSE, "mouse_io: return(min=(%d,%d), max=(%d,%d))",
      *min_x_ptr, *min_y_ptr,
      *max_x_ptr, *max_y_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_active_advanced_functions IFN4
   (
   word *, active_flag1_ptr,
   word *, active_flag2_ptr,
   word *, active_flag3_ptr,
   word *, active_flag4_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 50: Get Active Advanced Functions, ie define which functions
      above or equal to 37 are supported.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_active_advanced_functions");

   *active_flag1_ptr = 0x8000 |   /* Func 37 supported */
                       0x4000 |   /* Func 38 supported */
                       0x2000 |   /* Func 39 supported */
                       0x1000 |   /* Func 40 supported */
                       0x0800 |   /* Func 41 supported */
                       0x0400 |   /* Func 42 supported */
                       0x0200 |   /* Func 43 supported */
                       0x0100 |   /* Func 44 supported */
                       0x0080 |   /* Func 45 supported */
                       0x0000 |   /* Func 46 NOT supported */
                       0x0020 |   /* Func 47 supported */
                       0x0010 |   /* Func 48 supported */
                       0x0008 |   /* Func 49 supported */
                       0x0004 |   /* Func 50 supported */
                       0x0002 |   /* Func 51 supported */
                       0x0001;    /* Func 52 supported */

   /* No other (ie newer) functions are supported */
   *active_flag2_ptr = *active_flag3_ptr = *active_flag4_ptr = 0;

   note_trace4(MOUSE_VERBOSE, "mouse_io: return(active=%04x,%04x,%04x,%04x)",
      *active_flag1_ptr,
      *active_flag2_ptr,
      *active_flag3_ptr,
      *active_flag4_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_switch_settings IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, buffer_length_ptr,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 51: Get switch settings. Returns output buffer (340 bytes)
      with:-

        0       Mouse Type (low nibble)         0-5
                Mouse Port (high nibble)        0-4
        1       Language                        0-8
        2       Horizontal Sensitivity          0-100
        3       Vertical Sensitivity            0-100
        4       Double Threshold                0-100
        5       Ballistic Curve                 1-4
        6       Interrupt Rate                  1-4
        7       Cursor Override Mask            0-255
        8       Laptop Adjustment               0-255
        9       Memory Type                     0-2
        10      Super VGA Support               0-1
        11      Rotation Angle                  0-359
        13      Primary Button                  1-4
        14      Secondary Button                1-4
        15      Click Lock Enabled              0-1
        16      Acceleration Curve Data
    */

   word obuf_seg;
   word obuf_off;
   half_word mem_int_type;

   UNUSED(m2);

   note_trace3(MOUSE_VERBOSE,
      "mouse_io: get_switch_settings(seg=0x%04x,off=0x%04x,len=0x%x)",
      getES(), *offset_ptr, *buffer_length_ptr);

   if ( *buffer_length_ptr == 0 )
      {
      /* Undocumented method of just finding buffer size */
      *buffer_length_ptr = 340;
      }
   else
      {
      *buffer_length_ptr = 340;

      obuf_seg = getES();   /* Pick up pointer to output buffer */
      obuf_off = *offset_ptr;

      /* Store MouseType and MousePort(=0) */
      sas_store(effective_addr(obuf_seg, obuf_off),
         (half_word)MOUSE_TYPE_INPORT);

      /* Store Language (always 0) */
      sas_store(effective_addr(obuf_seg, (obuf_off + 1)),
         (half_word)0);

      /* Store Horizontal and Vertical Sensitivity */
      sas_store(effective_addr(obuf_seg, (obuf_off + 2)),
         (half_word)mouse_sens.x);

      sas_store(effective_addr(obuf_seg, (obuf_off + 3)),
         (half_word)mouse_sens.y);

      /* Store Double Threshold */
      sas_store(effective_addr(obuf_seg, (obuf_off + 4)),
         (half_word)mouse_double_thresh);

      /* Store Ballistic Curve */
      sas_store(effective_addr(obuf_seg, (obuf_off + 5)),
         (half_word)active_acceleration_curve);

      /* Store Interrupt Rate */
      sas_store(effective_addr(obuf_seg, (obuf_off + 6)),
         (half_word)mouse_interrupt_rate);

      /* Store Cursor Override Mask */
      sas_store(effective_addr(obuf_seg, (obuf_off + 7)),
         (half_word)0);   /* Microsoft Specific Feature? */

      /* Store Laptop Adjustment */
      sas_store(effective_addr(obuf_seg, (obuf_off + 8)),
         (half_word)0);   /* What is it? */

      /* Store Memory Type */
      /* NB 0 = Low, 1 = High, 2 = Extended */
      mem_int_type = 0;

      if ( getCS() >= 0xA000 )
         mem_int_type++;

      if ( getCS() == 0xFFFF )
         mem_int_type++;

      sas_store(effective_addr(obuf_seg, (obuf_off + 9)),
         mem_int_type);

      /* Store Super VGA Support. - We don't support fancy hardware cursor */
      sas_store(effective_addr(obuf_seg, (obuf_off + 10)),
         (half_word)0);

      /* Store Rotation Angle */
      sas_storew(effective_addr(obuf_seg, (obuf_off + 11)),
         (half_word)0);

      /* Store Primary Button */
      sas_store(effective_addr(obuf_seg, (obuf_off + 13)),
         (half_word)1);

      /* Store Secondary Button */
      sas_store(effective_addr(obuf_seg, (obuf_off + 14)),
         (half_word)3);

      /* Store Click Lock Enabled */
      sas_store(effective_addr(obuf_seg, (obuf_off + 15)),
         (half_word)0);   /* What is it? */

      /* Store Acceleration Curve Data */
      store_acceleration_curve(obuf_seg, (word)(obuf_off + 16),
         &acceleration_curve_data);
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(bytes_returned=0x%x)",
      *buffer_length_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_mouse_ini IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 52: Return Segment:Offset pointer to full pathname of
      MOUSE.INI.
      NB. As we do not support MOUSE.INI a pointer to a null string is
      returned.
    */

   UNUSED(m2);
   UNUSED(m3);

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_mouse_ini");

   *status_ptr = 0;

   *offset_ptr = OFF_MOUSE_INI_BUFFER;
   setES(getCS());

   note_trace2(MOUSE_VERBOSE, "mouse_io: return(seg=%04x,off=%04x)",
      getES(), *offset_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_unrecognised IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is called when an invalid mouse function
         *      number is found
         */
#ifndef PROD
        int function = *m1;

        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        fprintf(trace_file,
                "mouse_io:unrecognised function(fn=%d)\n", function);
#else
        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);
#endif
}


LOCAL void mouse_set_double_speed IFN4(word *,junk1,word *,junk2,word *,junk3,word *,threshold_speed)
{
        /*
         *      This function sets the threshold speed at which the cursor's
         *      motion on the screen doubles
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);

        note_trace1(MOUSE_VERBOSE, "mouse_io:set_double_speed(speed=%d)",
                    *threshold_speed);

                /*
                 *      Save the double speed threshold value, converting from
                 *      Mickeys per second to a rounded Mickeys per timer interval
                 *      value
                 */
                double_speed_threshold =
                        (*threshold_speed + MOUSE_TIMER_INTERRUPTS_PER_SECOND/2) /
                                                MOUSE_TIMER_INTERRUPTS_PER_SECOND;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




/*
 *      MOUSE DRIVER VIDEO ADAPTER ACCESS FUNCTIONS
 *      ===========================================
 */

LOCAL MOUSE_BYTE_ADDRESS point_as_text_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the byte offset of the character in the text mode regen
         *      buffer corresponding to the virtual screen position
         *      "*point_ptr"
         */
        MOUSE_BYTE_ADDRESS byte_address;
        word crt_start;

        /*
         *      Get pc address for the start of video memory
         */
        sas_loadw(MOUSE_VIDEO_CRT_START, &crt_start);
        byte_address = (MOUSE_BYTE_ADDRESS)crt_start;

        /*
         *      Adjust for current video page
         */
        byte_address += cursor_page * video_page_size();

        /*
         *      Add offset contributions for the cursor's row and column
         */
        byte_address += (2*get_chars_per_line() * (point_ptr->y / cursor_grid.y));
        byte_address += (point_ptr->x / cursor_grid.x) * 2;

        return(byte_address);
#endif    //NEC_98
}

LOCAL MOUSE_BIT_ADDRESS point_as_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer (odd or even) bank corresponding to the virtual screen
         *      position "*point_ptr"
         */
        IS32 bit_address;

        /*
         *      Get offset contributions for the cursor's row and column
         */
        bit_address = ((IS32)MOUSE_GRAPHICS_MODE_PITCH * (point_ptr->y / 2)) + point_ptr->x;

        /*
         *      Adjust for current video page
         */
        bit_address += (IS32)cursor_page * (IS32)video_page_size() * 8L;

        return(bit_address);
#endif    //NEC_98
}

#ifdef HERC
LOCAL MOUSE_BIT_ADDRESS point_as_HERC_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
        IMPORT half_word herc_page;

        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer (0, 1, 2, 3) bank corresponding to the virtual screen
         *      position "*point_ptr"
         */
        IS32 bit_address;

        /*
         *      Get offset contributions for the cursor's row and column
         */
        bit_address = ((IS32)720 * (point_ptr->y / 4)) + point_ptr->x;

        /*
         *      Adjust for current video page - note that for 100% correct emulation,
         *      we should read location 40:49 (the BIOS video mode)... hercules
         *      applications put a 6 here to indicate page 0 and a 5 for page 1.
         *      To avoid a performance penalty the global herc_page is used instead;
         *      this will have the side effect of making application which try to
         *      set the mouse pointer to the non-displayed page not succeed in doing so.
         */
        if (herc_page != 0){
                bit_address += 0x8000L * 8L;
        }

        return(bit_address);
}
#endif /* HERC */

LOCAL MOUSE_BIT_ADDRESS ega_point_as_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer corresponding to the virtual screen position "*point_ptr"
         */
        MOUSE_BIT_ADDRESS bit_address;
        UTINY   video_mode = sas_hw_at(vd_video_mode);

        /*
         *      Get offset contributions for the cursor's row and column
         */
#ifdef V7VGA
        if (video_mode >= 0x40)
                bit_address = (get_bytes_per_line() * 8 * point_ptr->y) + point_ptr->x;
        else
#endif /* V7VGA */
        switch(video_mode)
        {
        case 0xd :
            bit_address = (get_actual_offset_per_line() * 8 * point_ptr->y) + point_ptr->x / 2;
            break;
        case 0x13 :
            bit_address = (get_bytes_per_line() * 1 * point_ptr->y) + point_ptr->x / 2;
            break;
        default:
            bit_address = (get_actual_offset_per_line() * 8 * point_ptr->y) + point_ptr->x;
        }

        /*
         *      Adjust for current video page
         */
        bit_address += cursor_page * video_page_size() * 8;

        return(bit_address);
#endif   //NEC_98
}


LOCAL void cursor_update IFN0()
{
#ifndef NTVDM
        /*
         *      This function is used to update the displayed cursor
         *      position on the screen following a change to the
         *      absolute position of the cursor
         */

        point_coerce_to_area(&cursor_position, &cursor_window);
        point_copy(&cursor_position, &cursor_status.position);
        point_coerce_to_grid(&cursor_status.position, &cursor_grid);

        if (host_mouse_in_use())
                host_mouse_set_position(cursor_status.position.x * mouse_gear.x * mouse_sens.x / 800,
                                                                cursor_status.position.y * mouse_gear.y * mouse_sens.y / 800);

#endif
}




LOCAL void cursor_display IFN0()
{
#ifndef NEC_98
#ifndef NTVDM
        UTINY v_mode;

        /* Check if Enhanced Mode wants to "see" cursor */
        if ( cursor_EM_disabled )
           return;

        /*
         *      Display a representation of the current mouse status on
         *      the screen
         */

        v_mode = sas_hw_at(vd_video_mode);

#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
                return;
#endif  /* MOUSE_16_BIT */

        /*
         *      Remove the old representation of the
         *      cursor from the display
         */
        cursor_undisplay();

#ifdef EGG
        if (jap_mouse) {
        /* So far DOS has had its way, but now we have to map the current
         * cursor position in terms of mode 3 onto a mode 0x12 display.
         * Go direct 'cos the selection process gets confused below...
         */
                EGA_graphics_cursor_display();
        } else
#endif /* EGG */

        if (in_text_mode())
        {
                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                {
                        software_text_cursor_display();
                }
                else
                {
                        hardware_text_cursor_display();
                }
        }
        else
        {
#ifdef MOUSE_16_BIT
        mouse16bShowPointer( );
#else /* MOUSE_16_BIT */
                if (host_mouse_installed())
                {
                        if ( cursor_position.x >= black_hole.top_left.x &&
                                        cursor_position.x <= black_hole.bottom_right.x &&
                                        cursor_position.y >= black_hole.top_left.y &&
                                        cursor_position.y <= black_hole.bottom_right.y )
                                host_mouse_cursor_undisplay();
                        else
                                host_mouse_cursor_display();
                }
                else
                {
#ifdef EGG
                        if ((video_adapter == EGA  || video_adapter == VGA) && (v_mode > 6))
                        {
#ifdef VGG
                                if (v_mode != 0x13)
                                        EGA_graphics_cursor_display();
                                else
                                        VGA_graphics_cursor_display();
#else
                                EGA_graphics_cursor_display();
#endif /* VGG */
                        }
                        else
#endif
#ifdef HERC
                        if (video_adapter == HERCULES)
                                HERC_graphics_cursor_display();
                        else
#endif /* HERC */
                                graphics_cursor_display();
                }
#endif /* MOUSE_16_BIT */
        }

        /*
         *      Ensure the cursor is updated immediately on the real screen:
         *      this gives a "smooth" response to the mouse even on ports that
         *      don't automatically update the screen regularly
         */
        host_flush_screen();
#endif /* !NTVDM */
#endif   //NEC_98
}




LOCAL void cursor_undisplay IFN0()
{
#ifndef NEC_98
#ifndef NTVDM
        UTINY v_mode;

        /* Check if Enhanced Mode wants to "see" cursor */
        if ( cursor_EM_disabled )
           return;

        v_mode = sas_hw_at(vd_video_mode);

#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
                return;
#endif  /* MOUSE_16_BIT */

        /*
         *      Undisplay the representation of the current mouse status on
         *      the screen. This routine tolerates being called when the
         *      cursor isn't actually being displayed
         */
        if (host_mouse_in_use())
        {
                host_mouse_cursor_undisplay();
        }
        else
        {
                if (save_area_in_use)
                {
                        save_area_in_use = FALSE;

#ifdef EGG
        if (jap_mouse) {
                /* If we forced an EGA cursor, we must undisplay the same.
                 * Go direct 'cos the selection process gets confused below...
                 */
                EGA_graphics_cursor_undisplay();
        } else
#endif /* EGG */

                        if (in_text_mode())
                        {
                                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                                {
                                        software_text_cursor_undisplay();
                                }
                                else
                                {
                                        hardware_text_cursor_undisplay();
                                }
                        }
                        else
                        {
#ifdef MOUSE_16_BIT
                                mouse16bHidePointer( );
#else /* MOUSE_16_BIT */
#ifdef EGG
                        if ((video_adapter == EGA  || video_adapter == VGA) && (v_mode > 6))
                        {
#ifdef VGG
                                if (v_mode != 0x13)
                                EGA_graphics_cursor_undisplay();
                                else
                                        VGA_graphics_cursor_undisplay();
#else
                                EGA_graphics_cursor_undisplay();
#endif
                        }
                        else
#endif
#ifdef HERC
                          if (video_adapter == HERCULES)
                            HERC_graphics_cursor_undisplay();
                          else
#endif /* HERC */
                            graphics_cursor_undisplay();
#endif /* MOUSE_16_BIT */
                        }
                }
        }
#endif /* !NTVDM */
#endif   //NEC_98
}




LOCAL void cursor_mode_change IFN1(int,new_mode)
{
        /*
         *      Update parameters that are dependent on the screen mode
         *      in force
         */
#ifdef V7VGA
        if (new_mode >= 0x40)
                if (new_mode >= 0x60)
                {
                        point_copy(&v7graph_cursor_grids[new_mode-0x60], &cursor_grid);
                        point_copy(&v7graph_text_grids[new_mode-0x60], &text_grid);
                }
                else
                {
                        point_copy(&v7text_cursor_grids[new_mode-0x40], &cursor_grid);
                        point_copy(&v7text_text_grids[new_mode-0x40], &text_grid);
                }
        else
#endif /* V7VGA */
        {
                point_copy(&cursor_grids[new_mode], &cursor_grid);
                point_copy(&text_grids[new_mode], &text_grid);
        }
        /*
         *      Always set page to zero
         */
        cursor_page = 0;

        if (host_mouse_in_use())
                host_mouse_cursor_mode_change();
}




GLOBAL void software_text_cursor_display IFN0()
{
#ifndef NEC_98
        /*
         *      Get the area the cursor will occupy on the
         *      screen, and display the cursor if its area
         *      overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        MOUSE_AREA cursor_area;
        MOUSE_BYTE_ADDRESS text_address;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &cursor_area.top_left);
        point_copy(&cursor_status.position, &cursor_area.bottom_right);
        point_translate(&cursor_area.bottom_right, &cursor_grid);

        if (    area_is_intersected_by_area(&virtual_screen, &cursor_area)
            && !area_is_intersected_by_area(&black_hole, &cursor_area))
        {
                /*
                 *      Get new address for text cursor
                 *      Should we look at video mode? Or is 0xb8000 OK?
                 */
                text_address = 0xb8000 + sas_w_at(VID_ADDR) +
                        point_as_text_cell_address(&cursor_area.top_left);

                /*
                 *      Save area text cursor will cover
                 */
                sas_loadw(text_address, &text_cursor_background);
                save_area_in_use = TRUE;
                point_copy(&cursor_area.top_left, &save_position);

                /*
                 *      Stuff masked screen data
                 */
                sas_storew(text_address,
                    (IU16)((text_cursor_background & software_text_cursor.screen) ^
                        software_text_cursor.cursor));
        }
#endif    //NEC_98
}




GLOBAL void software_text_cursor_undisplay IFN0()
{
#ifndef NEC_98
        /*
         *      Remove old text cursor
         *      Should we look at video mode? Or is 0xb8000 OK?
         */
        MOUSE_BYTE_ADDRESS text_address;

        text_address = 0xb8000 + sas_w_at(VID_ADDR) +
                point_as_text_cell_address(&save_position);

        /*
         *      Stuff restored data and alert gvi
         */
        sas_storew(text_address, text_cursor_background);
#endif    //NEC_98
}




GLOBAL void hardware_text_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the hardware text cursor, provided the
         *      cursor overlaps the virtual screen. Since the hardware
         *      cursor display does not corrupt the Intel memory, it
         *      doesn't matter if the hardware cursor lies inside the
         *      conditional off area
         */
        MOUSE_AREA cursor_area;
        MOUSE_BYTE_ADDRESS text_address;
        word card_address;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &cursor_area.top_left);
        point_copy(&cursor_status.position, &cursor_area.bottom_right);
        point_translate(&cursor_area.bottom_right, &cursor_grid);

        if (area_is_intersected_by_area(&virtual_screen, &cursor_area))
        {
                /*
                 *      Get address of the base register on the active display
                 *      adaptor card
                 */
                sas_loadw(MOUSE_VIDEO_CARD_BASE, &card_address);

                /*
                 *      Get word offset of cursor position in the text mode
                 *      regen buffer
                 */
                text_address =
                        point_as_text_cell_address(&cursor_status.position) / 2;

                /*
                 *      Output the cursor address high byte
                 */
                outb(card_address++, MOUSE_CURSOR_HIGH_BYTE);
                outb(card_address--, (IU8)(text_address >> 8));

                /*
                 *      Output the cursor address low byte
                 */
                outb(card_address++, MOUSE_CURSOR_LOW_BYTE);
                outb(card_address--, (IU8)(text_address));
        }
}




GLOBAL void hardware_text_cursor_undisplay IFN0()
{
        /*
         *      Nothing to do
         */
}


#ifdef EGG
void LOCAL EGA_graphics_cursor_display IFN0()

{
#ifndef NEC_98
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - EGA graphics display cursor\n");
#endif /* PROD */
#else
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        MOUSE_BIT_ADDRESS bit_shift;
        MOUSE_BYTE_ADDRESS byte_offset;
        int line, line_max;
        int byte_min, byte_max;
        IU32 strip_lo, strip_mid, strip_hi;
        IU32 mask_lo, mask_hi;

        MOUSE_SCALAR saved_cursor_pos;
        MOUSE_SCALAR saved_bottom_right;

        if (jap_mouse) {
                /* fake up the mode 0x12 cursor position, saving original */
                saved_cursor_pos=cursor_status.position.y;
                saved_bottom_right=virtual_screen.bottom_right.y;

                cursor_status.position.y = saved_cursor_pos * 19 / 8;
                virtual_screen.bottom_right.y = virtual_screen.bottom_right.y * 19 / 8;
        }

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                area_coerce_to_area(&save_area, &virtual_screen);
                point_copy(&save_area.top_left, &save_position);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      regen buffer, and bit shift to apply
                 */
                byte_offset = ega_point_as_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset /=  8;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);
                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else
                        if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                                byte_max -=
                                        (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                if( bit_shift )
                {
                        mask_lo = 0xff >> bit_shift;
                        mask_lo = ( mask_lo << 8 ) | mask_lo;
                        mask_lo = ~(( mask_lo << 16 ) | mask_lo);

                        mask_hi = 0xff >> bit_shift;
                        mask_hi = ( mask_hi << 8 ) | mask_hi;
                        mask_hi = ( mask_hi << 16 ) | mask_hi;
                }

                while (line < line_max)
                {
                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */

                                ega_backgrnd_lo[line] = *( (IU32 *) EGA_planes + byte_offset );
                                ega_backgrnd_mid[line] = *( (IU32 *) EGA_planes + byte_offset + 1 );
                                ega_backgrnd_hi[line] = *( (IU32 *) EGA_planes + byte_offset + 2 );

                                /*
                                 *      Overlay cursor line
                                 */


                                strip_lo = ega_backgrnd_lo[line] & mask_lo;

                                strip_lo |= ~mask_lo & (( ega_backgrnd_lo[line]
                                                        & ( graphics_cursor.screen_lo[line] >> bit_shift ))
                                                        ^ ( graphics_cursor.cursor_lo[line] >> bit_shift ));

                                strip_mid = ~mask_hi & (( ega_backgrnd_mid[line]
                                                        & ( graphics_cursor.screen_lo[line] << (8 - bit_shift) ))
                                                        ^ ( graphics_cursor.cursor_lo[line] << (8 - bit_shift) ));

                                strip_mid |= ~mask_lo & (( ega_backgrnd_mid[line]
                                                        & ( graphics_cursor.screen_hi[line] >> bit_shift ))
                                                        ^ ( graphics_cursor.cursor_hi[line] >> bit_shift ));

                                strip_hi = ega_backgrnd_hi[line] & mask_hi;

                                strip_hi |= ~mask_hi & (( ega_backgrnd_hi[line]
                                                        & ( graphics_cursor.screen_hi[line] << (8 - bit_shift) ))
                                                        ^ ( graphics_cursor.cursor_hi[line] << (8 - bit_shift) ));

                                if (byte_min <= 0 && byte_max >= 0)
                                        *((IU32 *) EGA_planes + byte_offset) = strip_lo;

                                if (byte_min <= 1 && byte_max >= 1)
                                        *((IU32 *) EGA_planes + byte_offset + 1) = strip_mid;

                                if (byte_min <= 2 && byte_max >= 2)
                                        *((IU32 *) EGA_planes + byte_offset + 2) = strip_hi;
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */

                                ega_backgrnd_lo[line] = *( (IU32 *) EGA_planes + byte_offset );
                                ega_backgrnd_hi[line] = *( (IU32 *) EGA_planes + byte_offset + 1 );

                                /*
                                 *      Create overlaid cursor line
                                 */

                                strip_lo = (ega_backgrnd_lo[line] &
                                                    graphics_cursor.screen_lo[line]) ^
                                                    graphics_cursor.cursor_lo[line];

                                strip_hi = (ega_backgrnd_hi[line] &
                                                    graphics_cursor.screen_hi[line]) ^
                                                    graphics_cursor.cursor_hi[line];

                                /*
                                 *      Draw cursor line
                                 */

                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        *((IU32 *) EGA_planes + byte_offset) = strip_lo;
                                }

                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        *((IU32 *) EGA_planes + byte_offset + 1) = strip_hi;
                                }

                        }

                        update_alg.mark_string(byte_offset, byte_offset + 2);
#ifdef V7VGA
                        if (sas_hw_at(vd_video_mode) >= 0x40)
                                byte_offset += get_bytes_per_line();
                        else
#endif /* V7VGA */
                                byte_offset += get_actual_offset_per_line();
                        line++;
                }
                if (jap_mouse) {
                        /* put things back how they should be */
                        cursor_status.position.y = saved_cursor_pos;
                        virtual_screen.bottom_right.y = saved_bottom_right;
                }
        }
#endif /* REAL_VGA */
#endif   //NEC_98
}


void LOCAL EGA_graphics_cursor_undisplay IFN0()

{
#ifndef NEC_98
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - EGA graphics undisplay cursor\n");
#endif /* PROD */
#else
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        MOUSE_BIT_ADDRESS bit_shift;
        MOUSE_BYTE_ADDRESS byte_offset;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        byte_offset = ega_point_as_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset /=  8;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                /*
                 *      Draw saved area
                 */

                if (bit_shift)
                {
                        if (byte_min <= 0 && byte_max >= 0)
                                *((IU32 *) EGA_planes + byte_offset) = ega_backgrnd_lo[line];

                        if (byte_min <= 1 && byte_max >= 1)
                                *((IU32 *) EGA_planes + byte_offset + 1) = ega_backgrnd_mid[line];

                        if (byte_min <= 2 && byte_max >= 2)
                                *((IU32 *) EGA_planes + byte_offset + 2) = ega_backgrnd_hi[line];
                }
                else
                {
                        if (byte_min <= 0 && byte_max >= 0)
                                *((IU32 *) EGA_planes + byte_offset) = ega_backgrnd_lo[line];

                        if (byte_min <= 1 && byte_max >= 1)
                                *((IU32 *) EGA_planes + byte_offset + 1) = ega_backgrnd_hi[line];
                }

                update_alg.mark_string(byte_offset, byte_offset + 2);
#ifdef V7VGA
                if (sas_hw_at(vd_video_mode) >= 0x40)
                        byte_offset += get_bytes_per_line();
                else
#endif /* V7VGA */
                        byte_offset += get_actual_offset_per_line();
                line++;
        }
#endif /* REAL_VGA */
#endif   //NEC_98
}

#endif


#ifdef VGG
LOCAL VOID      VGA_graphics_cursor_display IFN0()
{
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - VGA graphics display cursor\n");
#endif /* PROD */
#else /* REAL_VGA */

        MOUSE_BYTE_ADDRESS byte_offset;
        SHORT line, line_max, index;
        SHORT index_max = MOUSE_GRAPHICS_CURSOR_WIDTH;
        USHORT scr_strip, cur_strip;
        UTINY scr_byte, cur_byte;
        USHORT mask;


        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                area_coerce_to_area(&save_area, &virtual_screen);
                point_copy(&save_area.top_left, &save_position);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      regen buffer, and bit shift to apply
                 */
                byte_offset = ega_point_as_graphics_cell_address(&save_position);
        /*
         *  Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

                if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        index_max = (area_width(&save_area));

                while (line < line_max)
                {
                        mask = 0x8000;

                        for(index=0;index<index_max;index++)
                        {
                                vga_background[line][index] = *(EGA_planes + byte_offset + index);
                                scr_strip = graphics_cursor.screen[line] & mask;
                                cur_strip = graphics_cursor.cursor[line] & mask;
                                if (scr_strip)
                                        scr_byte = 0xff;
                                else
                                        scr_byte = 0x0;

                                if (cur_strip)
                                        cur_byte = 0x0f;
                                else
                                        cur_byte = 0x0;

                                /*
                                 * Draw cursor byte
                                 */
                                *(EGA_planes + byte_offset + index) =
                                        ( vga_background[line][index] & scr_byte) ^ cur_byte;

                                mask >>= 1;
                        }

                        update_alg.mark_string(byte_offset, byte_offset+index);
                        line++;
                        byte_offset += get_bytes_per_line();

                }
        }
#endif /* REAL_VGA */
}

LOCAL VOID      VGA_graphics_cursor_undisplay IFN0()
{
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - VGA graphics undisplay cursor\n");
#endif /* PROD */
#else /* REAL_VGA */

        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        MOUSE_BYTE_ADDRESS byte_offset;
        SHORT index;
        SHORT index_max = MOUSE_GRAPHICS_CURSOR_WIDTH;
        int line, line_max;

        /*
         *      Get cursor byte offset relative to the start of the EGA memory
         */

        byte_offset = ega_point_as_graphics_cell_address(&save_position);

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                index_max = (area_width(&save_area));

        /*
         *      Get range of bytes that need to be displayed
         */
        while (line < line_max)
        {
                for (index=0;index<index_max;index++)
                        *(EGA_planes + byte_offset + index) = vga_background[line][index];


                update_alg.mark_string(byte_offset, byte_offset+index);
                line++;
                byte_offset += get_bytes_per_line();
        }

#endif /* REAL_VGA */
}

#endif /* VGG */


LOCAL void graphics_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        boolean even_scan_line;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                point_copy(&save_area.top_left, &save_position);
                area_coerce_to_area(&save_area, &virtual_screen);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      even or odd bank, and bit shift to apply
                 */
                even_scan_line = ((save_area.top_left.y % 2) == 0);
                byte_offset = point_as_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset >>= 3;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);

                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                while (line < line_max)
                {
                        if (even_scan_line)
                        {
                                even_scan_line = FALSE;
                                byte_address = EVEN_START + byte_offset;
                        }
                        else
                        {
                                even_scan_line = TRUE;
                                byte_address = ODD_START + byte_offset;
                                byte_offset += MOUSE_GRAPHICS_MODE_PITCH / 8;
                        }

                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */
                                strip =  (IU32)sas_hw_at(byte_address) << 16;
                                strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                                strip |= sas_hw_at(byte_address+2);
                                graphics_cursor_background[line] =
                                                (USHORT)(strip >> (8 - bit_shift));

                                /*
                                 *      Overlay cursor line
                                 */
                                strip &= (SHIFT_VAL >> bit_shift);
                                strip |= (IU32)((graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line])
                                                << (8 - bit_shift);

                                /*
                                 *      Stash cursor line
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, (IU8)(strip >> 16));
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, (IU8)(strip >> 8));
                                }
                                if (byte_min <= 2 && byte_max >= 2)
                                {
                                        sas_store(byte_address+2, (IU8)(strip));
                                }
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */
                                graphics_cursor_background[line] = (sas_hw_at(byte_address) << 8) + sas_hw_at(byte_address+1);

                                /*
                                 *      Get overlaid cursor line
                                 */
                                strip = (graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line];

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, (IU8)(strip >> 8));
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, (IU8)(strip));
                                }
                        }
                        line++;
                }
        }
}


#ifdef HERC
LOCAL void HERC_graphics_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        int scan_line_mod;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&HERC_graphics_virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                point_copy(&save_area.top_left, &save_position);
                area_coerce_to_area(&save_area, &HERC_graphics_virtual_screen);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      even or odd bank, and bit shift to apply
                 */
                scan_line_mod = save_area.top_left.y % 4;
                byte_offset = point_as_HERC_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset >>= 3;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);

                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                while (line < line_max)
                {
                        switch (scan_line_mod){
                        case 0:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x0000 + byte_offset;
                                break;
                        case 1:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x2000 + byte_offset;
                                break;
                        case 2:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x4000 + byte_offset;
                                break;
                        case 3:
                                scan_line_mod=0;
                                byte_address = gvi_pc_low_regen + 0x6000 + byte_offset;
                                byte_offset += 720 / 8;
                                break;
                        }

                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */
                                strip =  (IU32)sas_hw_at(byte_address) << 16;
                                strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                                strip |= sas_hw_at(byte_address+2);
                                graphics_cursor_background[line] =
                                                strip >> (8 - bit_shift);

                                /*
                                 *      Overlay cursor line
                                 */
                                strip &= (SHIFT_VAL >> bit_shift);
                                strip |= (IU32)((graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line])
                                                << (8 - bit_shift);

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, strip >> 16);
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, strip >> 8);
                                }
                                if (byte_min <= 2 && byte_max >= 2)
                                {
                                        sas_store(byte_address+2, strip);
                                }
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */
                                graphics_cursor_background[line] = (sas_hw_at(byte_address) << 8) +
                                                                    sas_hw_at(byte_address+1);

                                /*
                                 *      Get overlaid cursor line
                                 */
                                strip = (graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line];

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, strip >> 8);
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, strip);
                                }
                        }
                        line++;
                }
        }
}


#endif /* HERC */


LOCAL void graphics_cursor_undisplay IFN0()
{
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        boolean even_scan_line;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        even_scan_line = ((save_area.top_left.y % 2) == 0);
        byte_offset = point_as_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset >>= 3;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                if (even_scan_line)
                {
                        even_scan_line = FALSE;
                        byte_address = EVEN_START + byte_offset;
                }
                else
                {
                        even_scan_line = TRUE;
                        byte_address = ODD_START + byte_offset;
                        byte_offset += MOUSE_GRAPHICS_MODE_PITCH / 8;
                }

                if (bit_shift)
                {
                        /*
                         *      Get cursor line
                         */
                        strip =  (IU32)sas_hw_at(byte_address) << 16;
                        strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                        strip |= sas_hw_at(byte_address+2);

                        /*
                         *      Overlay save area
                         */
                        strip &= (SHIFT_VAL >> bit_shift);
                        strip |= (IU32)graphics_cursor_background[line]
                                        << (8 - bit_shift);

                        /*
                         *      Stash cursor line and alert gvi
                         */
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, (IU8)(strip >> 16));
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, (IU8)(strip >> 8));
                        }
                        if (byte_min <= 2 && byte_max >= 2)
                        {
                                sas_store(byte_address+2, (IU8)(strip));
                        }
                }
                else
                {
                        /*
                         *      Stash save area and alert gvi
                         */
                        strip = graphics_cursor_background[line];
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, (IU8)(strip >> 8));
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, (IU8)(strip));
                        }
                }
                line++;
        }
}

#ifdef HERC

LOCAL void HERC_graphics_cursor_undisplay IFN0()
{
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        int scan_line_mod;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        scan_line_mod = save_area.top_left.y % 4;
        byte_offset = point_as_HERC_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset >>= 3;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                        switch (scan_line_mod){
                        case 0:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x0000 + byte_offset;
                                break;
                        case 1:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x2000 + byte_offset;
                                break;
                        case 2:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x4000 + byte_offset;
                                break;
                        case 3:
                                scan_line_mod=0;
                                byte_address = gvi_pc_low_regen + 0x6000 + byte_offset;
                                byte_offset += 720 / 8;
                                break;
                        }

                if (bit_shift)
                {
                        /*
                         *      Get cursor line
                         */
                        strip =  (IU32)sas_hw_at(byte_address) << 16;
                        strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                        strip |= sas_hw_at(byte_address+2);

                        /*
                         *      Overlay save area
                         */
                        strip &= (SHIFT_VAL >> bit_shift);
                        strip |= (IU32)graphics_cursor_background[line]
                                        << (8 - bit_shift);

                        /*
                         *      Stash cursor line and alert gvi
                         */
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, strip >> 16);
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, strip >> 8);
                        }
                        if (byte_min <= 2 && byte_max >= 2)
                        {
                                sas_store(byte_address+2, strip);
                        }
                }
                else
                {
                        /*
                         *      Stash save area
                         */
                        strip = graphics_cursor_background[line];
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, strip >> 8);
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, strip);
                        }
                }
                line++;
        }
}
#endif /* HERC */


/*
 *      MOUSE DRIVER INPORT ACCESS FUNCTIONS
 *      ====================================
 */

LOCAL void inport_get_event IFN1(MOUSE_INPORT_DATA *,event)
{
        /*
         *      Get InPort event data from the Bus Mouse hardware following
         *      an interrupt
         */
        half_word inport_mode;

        /*
         *      Set hold bit in InPort mode register to transfer the mouse
         *      event data into the status and data registers
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        inb(MOUSE_INPORT_DATA_REG, &inport_mode);
        outb(MOUSE_INPORT_DATA_REG, (IU8)(inport_mode | MOUSE_INPORT_MODE_HOLD_BIT));

        /*
         *      Retreive the InPort mouse status, data1 and data2 registers
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_STATUS);
        inb(MOUSE_INPORT_DATA_REG, &event->status);
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_DATA1);
        inb(MOUSE_INPORT_DATA_REG, (half_word *)&event->data_x);
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_DATA2);
        inb(MOUSE_INPORT_DATA_REG, (half_word *)&event->data_y);

        /*
         *      Clear hold bit in mode register
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        inb(MOUSE_INPORT_DATA_REG, &inport_mode);
        outb(MOUSE_INPORT_DATA_REG, (IU8)(inport_mode & ~MOUSE_INPORT_MODE_HOLD_BIT));
}




LOCAL void inport_reset IFN0()
{
        /*
         *      Reset the InPort bus mouse hardware
         */

        /*
         *      Set the reset bit in the address register
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_RESET_BIT);

        /*
         *      Select the mode register, and set it to the correct value
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        outb(MOUSE_INPORT_DATA_REG, MOUSE_INPORT_MODE_VALUE);
}




/*
 *      USER SUBROUTINE CALL ACCESS FUNCTIONS
 *      =====================================
 */

LOCAL void jump_to_user_subroutine IFN3(MOUSE_CALL_MASK,condition_mask,word,segment,word,offset)
{
        /*
         *      This routine sets up the CPU registers so that when the CPU
         *      restarts, control will pass to the user subroutine, and when
         *      the user subroutine returns, control will pass to the second
         *      part of the mouse hardware interrupt service routine
         */

        /*
         *      Push address of second part of mouse hardware interrupt service
         *      routine
         */

        setSP((IU16)(getSP() - 2));
        sas_storew(effective_addr(getSS(), getSP()), MOUSE_INT2_SEGMENT);
        setSP((IU16)(getSP() - 2));
        sas_storew(effective_addr(getSS(), getSP()), MOUSE_INT2_OFFSET);

        /*
         *      Set CS:IP to point to the user subroutine. Adjust the IP by
         *       HOST_BOP_IP_FUDGE, since the CPU emulator will increment IP by
         *       HOST_BOP_IP_FUDGE for the BOP instruction before proceeding
         */
        setCS(segment);
#ifdef CPU_30_STYLE
        setIP(offset);
#else /* !CPU_30_STYLE */
        setIP(offset + HOST_BOP_IP_FUDGE);
#endif /* !CPU_30_STYLE */

        /*
         *      Put parameters into the registers, saving the previous contents
         *      to be restored in the second part of the mouse hardware
         *      interrupt service routine
         */
        saved_AX = getAX();
        setAX(condition_mask);
        saved_BX = getBX();
        setBX(cursor_status.button_status);
        saved_CX = getCX();
        setCX(cursor_status.position.x);
        saved_DX = getDX();
        setDX(cursor_status.position.y);
        saved_SI = getSI();
        setSI(mouse_motion.x);
        saved_DI = getDI();
        setDI(mouse_motion.y);
        saved_ES = getES();
        saved_BP = getBP();
        saved_DS = getDS();

        /*
         *      Save the condition mask so that the second part of the mouse
         *      hardware interrupt service routine can determine whether the
         *      cursor has changed position
         */

        last_condition_mask = condition_mask;

        /*
         *      Enable interrupts
         */
        setIF(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\mouse.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Microsoft Bus Mouse Adapter
 *
 * Description	: This package contains a group of functions that provide
 *               an interface between the Microsoft Bus Mouse Card and the cpu.
 *
 *		mouse_init()	Initialise the bus mouse adapter
 *		mouse_inb() 	Supports IN's from ports in the bus mouse range
 *		mouse_outb()	Supports OUT's to ports in the bus mouse range
 *		mouse_send()	Queues data sent from the host mouse
 *
 * Author       : Henry Nash
 *
 * Notes        : See the Microsoft Inport Technical Reference Manual for
 *                further information on the hardware interface.
 *                The Bus Mouse ports are jumper selectable on the real card
 *                between (1) 023C - 023F & (2) 0238 - 023B. We only support
 *                the primary range 023C - 023F.
 *						
 *       (r3.5) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)mouse.c	1.17+ 07/10/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_MOUSE.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "cga.h"
#include "bios.h"
#include "error.h"
#include "ios.h"
#include "ica.h"
#include "trace.h"
#include "video.h"
#include "mouse.h"
#include "mouse_io.h"


/*
 * The following globals are also used by xxx_input.c,
 * where xxx is the host machine name.
 */

int button_left  = 0;	/* Current state of left button */
int button_right = 0;	/* Current state of right button */
int delta_x = 0, delta_y = 0;	/* Current mouse delta moves */

#ifndef PROD
static char buff[132];
#endif

static half_word data1_reg = 0,
		 data2_reg = 0,
		 mouse_status_reg = 0;

#if defined(NEC_98)

static half_word NEC98_data_reg = 0,
                 NEC98_mouse_status_reg = 0,
                 InterruptFlag=0;
                 InitializeFlag=0;              //930914


static word    MouseIoBase;


#endif    //NEC_98
static half_word
		 last_button_left  = 0,
		 last_button_right = 0;

static half_word
                 mouse_mode_reg          = 0, /* mode register 		*/
		 address_reg       = 0; /* address pointer register	*/

static int
		loadsainterrupts = 5;
/* count of how many times we will send bursts of interrupts to please Windows, per reset */


static int mouse_inb_toggle = 0;

void mouse_inb IFN2(io_addr, port, half_word *, value)
{
#if defined(NEC_98)

   if (port == MouseIoBase + MOUSE_PORT_0) { /* Normal:7FD9h,Hireso:0061h */

       *value = NEC98_data_reg;
   }

   if (port == MouseIoBase + MOUSE_PORT_1) { /* Normal:7FDBh,Hireso:0063h */

        /*
         * Internal registers
         */
       //DbgPrint("NEC not Supported: SPDSW,RAMKL bit\n");

   }

   if (port == MouseIoBase + MOUSE_PORT_2) { /* Normal:7FDDh,Hireso:0065h */

        /*
         * Internal registers
         */
       *value = NEC98_mouse_status_reg;

   }

#else   //NEC_98
    if (port == MOUSE_PORT_1) {		/* data register */

	/*
	 * Internal registers
	 */

	switch (address_reg & 0x07) {
	    case 0x00 :  /* mouse status register */
		*value = mouse_status_reg;
		break;
	    case 0x01 : /* data 1 register horizontal */
		*value = data1_reg;
		break;
	    case 0x02 : /* data 2 register vertical */
		*value = data2_reg;
		break;
	    case 0x07 : /* mode register */
		*value = mouse_mode_reg;
		break;
	    default :
#ifndef PROD
		if (io_verbose & MOUSE_VERBOSE) {
			sprintf(buff, "mouse_inb() :  Bad P");
			trace(buff,DUMP_NONE);
		}
#endif
		break;
	}
    }

	/*
	 * ID register, alternates between value 1 and value 2
	 * value 1 is the chip signature: DE hex
	 * value 2 is the chip revision: 1  and version: 0
	 */

    else
    if (port == MOUSE_PORT_2) {
	if (mouse_inb_toggle = 1 - mouse_inb_toggle)
		*value = 0xDE;
	else
		*value = 0x10;
    }

#ifndef PROD
    if (io_verbose & MOUSE_VERBOSE) {
	sprintf(buff, "mouse_inb() : port %x value %x", port, *value);
	trace(buff,DUMP_NONE);
    }
#endif
#endif    //NEC_98
}


void mouse_outb IFN2(io_addr, port, half_word, value)
{
#if defined(NEC_98)

        NEC98_mouse_status_reg = 0xff;           //930914

        if (port == MouseIoBase + MOUSE_PORT_2) { /* Write port C */
                                                  /* Normal:7FDDh,Hireso:0065h */
           NEC98_data_reg = 0;

           switch (value & 0x60) {
             case 0x00 :  /* X Low4bit */
                NEC98_data_reg = delta_x & 0x0f;
                break;

             case 0x20 :  /* X High4bit */
                NEC98_data_reg = (delta_x & 0xf0) >>4;
                break;

             case 0x40 :  /* Y Low4bit */
                NEC98_data_reg = delta_y & 0x0f;
                break;

             case 0x60 :  /* Y High4bit */
                NEC98_data_reg = (delta_y & 0xf0) >>4;
                break;

             default :
                break;

           }
           if(!button_left)
              NEC98_data_reg |= 0x80;
           if(!button_right)
              NEC98_data_reg |= 0x20;

           if(InitializeFlag){                  //930914
              NEC98_mouse_status_reg = value;
           }
        }
        else if(port == MouseIoBase + MOUSE_PORT_3)     /* address pointer register */
        {                                               /* Normal:7FDFh,Hireso:0067h */
           switch (value) {
             case 0x90 :  //
             case 0x91 :  //
             case 0x92 :  // for Z's STAFF Kid98
             case 0x93 :  /* mode set */
             case 0x94 :  //
             case 0x95 :  //
             case 0x96 :  //
             case 0x97 :  //
                InitializeFlag= 1;
                InterruptFlag = 1;              //930914
                if(HIRESO_MODE)  //Hireso mode
                        ica_clear_int(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2);
                else
                        ica_clear_int(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6);
                delta_x = 0;
                delta_y = 0;
                break;

             case 0x08 : /* Mouse interrupt Enable */
                InterruptFlag = 1;
                break;

             case 0x09 : /* Mouse interrupt Disable */
                InterruptFlag = 0;
                break;

             case 0x0E : /* Clear Count(non clear)*/
                break;

             case 0x0F : /* Clear Count(clear) */
                delta_x = 0;
                delta_y = 0;
                break;

             default :
                break;

           }

           if(InitializeFlag){                  //930914
              NEC98_mouse_status_reg = value;
           }

        }

#else    //NEC_98
#ifndef PROD
	if (io_verbose & MOUSE_VERBOSE) {
		if ((port == MOUSE_PORT_0)
		 || (port == MOUSE_PORT_1)
		 || (port == MOUSE_PORT_2))
			sprintf(buff, "mouse_outb() : port %x value %x", port, value);
		else
			sprintf(buff, "mouse_outb() : bad port: %x value %x", port, value);
		trace(buff,DUMP_NONE);
	}
#endif

	/*
	 * Out to an internal register
	 */

	if (port == MOUSE_PORT_1) {	/* data register */

		/*
		 * Out to Mode register
		 */
		if ( (address_reg & 0x07) == INTERNAL_MODE_REG) {

			/*
			 * Check hold bit (5) for 0 to 1 transition
			 * - Data Interrupt Enable bit is set (Mode 0)
			 * - counter values saved in Data1 & Data2 registers (Mode 0)
			 * - counters cleared
			 * - status register updated
			 */

			if ((value & 0x20) && ((mouse_mode_reg & 0x20) == 0)) {
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : hold bit 0 -> 1");
					trace(buff,DUMP_NONE);
				}
#endif
				/* clear the interrupt */
				ica_clear_int(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT);

				/*
				 * read next mouse deltas & buttons
				 * into the inport registers
				 */
				data1_reg = (half_word)delta_x;
				data2_reg = (half_word)delta_y;
				mouse_status_reg = 0;
				mouse_status_reg = (button_left << 2) + (button_right);
				if (delta_x!=0 || delta_y!=0) {
					mouse_status_reg |= MOVEMENT;
				}
				if (last_button_right != button_right) {
					mouse_status_reg |= RIGHT_BUTTON_CHANGE;
					last_button_right = (half_word)button_right;
				}

				if (last_button_left != button_left) {
					mouse_status_reg |= LEFT_BUTTON_CHANGE;
					last_button_left = (half_word)button_left;
				}
				delta_x = delta_y = 0;
			}
			/* 1 -> 0 transition on mode register's hold bit */
			/* ready for next read from queue, so send interrupt */
			else if ((mouse_mode_reg & 0x20) && ((value & 0x20)==0)){
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : hold bit 1 -> 0");
					trace(buff,DUMP_NONE);
				}
#endif
			}
			/*
			 * Check timer select value (bits 210)
			 */

			switch (value & 0x7) {
			case 0x0 :		/* 0 Hz INTR low */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : INTR low"); trace(buff,DUMP_NONE);
				}
#endif
				ica_clear_int(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT);
				break;

	/*
	 * In the following cases the application code is expecting to see
	 * interrupts at the requested rate. However in practice this is only
	 * required during initialisation(mouse_mode_reg = 0), and then a short burst
	 * appears to be sufficient. The 15 interupts generated comes from
	 * tests with the "WINDOWS" package, which receives about 15 during
	 * initialising, but is happy as long as it gets more than 3. The delay
	 * is necessary otherwise the interupts are generated before the
	 * application starts looking for them.

	 * Mark 2 bodge:
	   Windows 1.02 needs the burst of interrupts to occur even when mouse_mode_reg != 0,
	   but Windows 2.03 needs them not to keep happening even when it asks for them.
	   So now there's a counter called loadsainterrupts set to 5 on resets, which is
	   how many bursts will be allowed. This makes both Windows work.
	 */
			case 0x1: /* 30 Hz */
			case 0x2: /* 50 Hz */
			case 0x3: /* 100 Hz */
			case 0x4: /* 200 Hz */
/* used to be if mouse_mode_reg == 0 too, removed to make Windows 1.02 work */
			    if( (value & 0x10) && loadsainterrupts > 0)	
			    {
				loadsainterrupts--;
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : Loadsainterrupts"); trace(buff,DUMP_NONE);
				}
#endif
				/*
				** AT version is asking for a 100 interrupts.
				** The AT ica does not handle delayed ints so
				** the IRET has been modified to not allow an
				** int to go off before the next instruction.
				*/
				ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,100);
			     }
				break;
			case 0x5: /* reserved */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse: reserved"); trace(buff,DUMP_NONE);
					}
#endif
				break;
			case 0x6 :		/* 0 Hz INTR hi */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : INTR hi"); trace(buff,DUMP_NONE);
				}
#endif
				ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
				break;
			case 0x7: /* externally controlled */
				break;
			default:
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff,"mouse_outb() : bad mode");
					trace(buff,DUMP_NONE);
				}
#endif
				break;

			}
		mouse_mode_reg = value;

		/*
	 	 * Interface control register
	 	 */
		}
		else
		if ((address_reg & 0x07) == INTERFACE_CONTROL_REG){
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() :  interface control reg port %x value %x",port,value);
					trace(buff,DUMP_NONE);
				}
#endif
		}

	}
	else if(port == MOUSE_PORT_0)	/* address pointer register */
	{
	    if (value & 0x80)  /* is it  a reset */
	    {
		mouse_mode_reg = 0;
		loadsainterrupts = 5;	/* lets Windows initialise its mouse happily */
		address_reg = value & 0x7F;	/* clear reset bit*/
		ica_clear_int( AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT );
	    }
	    else
		address_reg = value;
	}
#endif    //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INPUT.seg"
#endif

void mouse_send(Delta_x,Delta_y,left,right)
int	Delta_x,Delta_y,left,right;
{
	if(Delta_x != 0 || Delta_y != 0 || button_left != left || button_right != right)
	{
#if defined(NEC_98)
                delta_x = Delta_x;
                delta_y = Delta_y;
#else    //NEC_98
		delta_x += Delta_x;
		delta_y += Delta_y;
#endif   //NEC_98

		/***
		Mouse inport registers can only handle one byte
		***/
		if (delta_x < -128)
			delta_x = -128;
		else if (delta_x > 127)
			delta_x = 127;

		if (delta_y < -128)
			delta_y = -128;
		else if (delta_y > 127)
			delta_y = 127;

		button_left = left;
		button_right = right;
#if defined(NEC_98)
                if(InterruptFlag){
                   if(HIRESO_MODE)      //Hireso mode
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2,1);
                   else
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6,1);
                }

#else    //NEC_98
		ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
#endif   //NEC_98
	}
#if defined(NEC_98)
        else{
             //DbgPrint("NEC Mouse bios:mouse_send not change\n");
                delta_x = 0;
                delta_y = 0;
                if(InterruptFlag){
                   if(HIRESO_MODE)      //Hireso mode
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2,1);
                   else
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6,1);
                }
        }
#endif    //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif


void mouse_init IFN0()
{
    IU16 p;

#ifndef PROD
    if (io_verbose & MOUSE_VERBOSE) {
	sprintf(buff, "mouse_init()");
	trace(buff,DUMP_NONE);
    }
#endif

    mouse_inb_toggle = 0;

    io_define_inb(MOUSE_ADAPTOR, mouse_inb);
    io_define_outb(MOUSE_ADAPTOR, mouse_outb);

#if defined(NEC_98)
    if(HIRESO_MODE)  //Hireso mode
      MouseIoBase = HMODE_BASE;
    else
      MouseIoBase = NMODE_BASE;

    for(p = MouseIoBase + MOUSE_PORT_START; p <= MouseIoBase + MOUSE_PORT_END; p=p+2) {

#else    //NEC_98
    for(p = MOUSE_PORT_START; p <= MOUSE_PORT_END; p++) {
#endif   //NEC_98
	io_connect_port(p, MOUSE_ADAPTOR, (IU8)IO_READ_WRITE);

#ifdef KIPPER
#ifdef CPU_40_STYLE
  /* Enable iret hooks on mouse interrupts */
  ica_iret_hook_control(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT, TRUE);
#endif
#endif

#ifndef PROD
	if (io_verbose & MOUSE_VERBOSE) {
	    sprintf(buff, "Mouse Port connected: %x", p);
	    trace(buff,DUMP_NONE);
	}
#endif
    }
    host_deinstall_host_mouse();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\get_env.c ===
/*[
 *      Name:           get_env.c
 *
 *      Derived From:   FmIit.c
 *
 *      Author:         William Charnell
 *
 *      Created On:     5th May 1995
 *
 *      Sccs ID:        @(#)get_env.c	1.2 06/16/95
 *
 *      Purpose:        Provide easy interface to env vbls
 *
 *      Design document:
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/
#include <insignia.h>
#include <host_def.h>
#include <host_inc.h>

#include  <config.h>
#include  <error.h>
#include  <debug.h>	/* for always_trace macros */

#include <get_env.h>



#ifdef NTVDM

#ifdef LOCAL
#undef LOCAL
#endif

#else
LOCAL IBOOL verboseGetenv;
#endif

#ifndef NTVDM
LOCAL void badGetenv IFN3(char *, name, char *, type_name, char *, value)
{
	printf("Bad getenv(\"%s\") %s value \"%s\"", name, type_name, value);
}


LOCAL void setupVerboseGetenv IFN0()
{
	SAVED IBOOL firstGetenv = TRUE;
	char *env;
	char *how = "Defaulting";

	if (firstGetenv)
	{
#ifdef	PROD
		verboseGetenv = FALSE;
#else	/* PROD */
		verboseGetenv = TRUE;
#endif	/* PROD */
		env = host_getenv("VERBOSE_GETENV");
		if (env)
		{
			if (strcmp(env, "FALSE") == 0)
				verboseGetenv = FALSE;
			else if (strcmp(env, "TRUE") == 0)
				verboseGetenv = TRUE;
			else
				badGetenv("VERBOSE_GETENV", "IBOOL", env);
			how = "Setting";
		}
#ifndef	PROD
		printf("%10s %25s IBOOL value \"%s\"\n",
			      how, "VERBOSE_GETENV", verboseGetenv ? "TRUE": "FALSE");
#endif	/* PROD */
		firstGetenv = FALSE;
	}
}
#endif


GLOBAL IBOOL IBOOLgetenv IFN2(char *, name, IBOOL, default_value)
{
        char *env;
        IBOOL value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
        {
#ifdef NTVDM
            value = _stricmp(env, "TRUE") == 0;
#else
                if (strcmp(env, "FALSE") == 0)
			value = FALSE;
		else if (strcmp(env, "TRUE") == 0)
                        value = TRUE;

		else
                        badGetenv(name, "IBOOL", env);

                how = "Setting";
#endif

        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		printf("%10s %25s IBOOL value \"%s\"\n",
		       how, name, value ? "TRUE": "FALSE");
        }
#endif

	return (value);
}


GLOBAL ISM32 ISM32getenv IFN2(char *, name, ISM32, default_value)
{
        char *env, *ptr;
        ISM32 value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
	{
		value = strtol(env, &ptr, 0);
		if (ptr == env)	/* cannot do conversion */
                        value = default_value;
#ifndef NTVDM
                how = "Setting";
#endif
        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		printf("%10s %25s ISM32 value \"%d\"\n", how, name, value);
        }
#endif
	return (value);
}


GLOBAL char *STRINGgetenv IFN2(char *, name, char *, default_value)
{
        char *env;
        char *value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
	{
                value = env;
#ifndef NTVDM
                how = "Setting";
#endif
        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		if (value)
			printf("%10s %25s char* value \"%s\"\n", how, name, value);
		else
			printf("%10s %25s char* with no value\n", how, name, value);
        }
#endif
	return (value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\keymouse\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=keymouse
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\keyba.c    \
        ..\keybd_io.c \
        ..\mouse.c    \
        ..\ppi.c      \
        ..\mouse_io.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

SOURCES_USED=..\sources.inc

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\ios.c ===
#include "insignia.h"
#include "host_def.h"
/*[
 *	Name:		ios.c
 *
 *	Author:		Wayne Plummer
 *
 *	Created:	7th February 1991
 *
 *	Sccs ID:	@(#)ios.c	1.29 09/27/94
 *
 *	Purpose:	This module provides a routing mechanism for Input and Ouput
 *			requests.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_IOS.seg"
#endif

#include <stdio.h>
#include <stdlib.h>

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "ios.h"
#include "trace.h"
#include "debug.h"
#include "sas.h"
#include MemoryH

#if defined(SPC386) && !defined(GISP_CPU)
#define VIRTUALISATION
#endif

#ifdef NTVDM
#define getIOInAdapter(ioaddr) (Ios_in_adapter_table[ioaddr & (PC_IO_MEM_SIZE-1)])
#define getIOOutAdapter(ioaddr) (Ios_out_adapter_table[ioaddr & (PC_IO_MEM_SIZE-1)])

BOOL HostUndefinedIo(WORD IoAddress);

#endif

/*
 *
 * ============================================================================
 * Global data
 * ============================================================================
 *
 */

/*
 *	Ios_in_adapter_table & Ios_out_adapter_table - These tables give the association
 *	between the IO address used for an IO and the SoftPC adapter ID associated with the
 *	IO subroutines.
 *
 *	Note that there are two tables here to allow for memory mapped IO locations which
 *	have an input functionality which is unrelated to the output functionality...
 *	In these cases, two connect port calls to the same IO address would be made, one with
 *	only the IO_READ flag set, the other with only the IO_WRITE flag set.
 */
#ifdef	MAC68K
GLOBAL char	*Ios_in_adapter_table = NULL;
GLOBAL char	*Ios_out_adapter_table = NULL;
#else
GLOBAL char	Ios_in_adapter_table[PC_IO_MEM_SIZE];
GLOBAL char	Ios_out_adapter_table[PC_IO_MEM_SIZE];
#endif	/* MAC68K */
#ifndef PROD
GLOBAL IU32	*ios_empty_in = (IU32 *)0;
GLOBAL IU32	*ios_empty_out = (IU32 *)0;
#endif /* PROD */

/*
 *	Ios_xxx_function - These tables are indexed by the adapter ID obtained
 *	from the Ios_in_adapter_table or Ios_in_adapter_table to yield a pointer
 *	to the IO routine to call.
 */
typedef	void (*IOS_FUNC_INB)	IPT2(io_addr, io_address, half_word *, value);
typedef	void (*IOS_FUNC_INW)	IPT2(io_addr, io_address, word *, value);
typedef	void (*IOS_FUNC_INSB)	IPT3(io_addr, io_address, half_word *, valarray, word, count);
typedef	void (*IOS_FUNC_INSW)	IPT3(io_addr, io_address, word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTB)	IPT2(io_addr, io_address, half_word, value);
typedef	void (*IOS_FUNC_OUTW)	IPT2(io_addr, io_address, word, value);
typedef	void (*IOS_FUNC_OUTSB)	IPT3(io_addr, io_address, half_word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTSW)	IPT3(io_addr, io_address, word *, valarray, word, count);
#ifdef SPC386
typedef	void (*IOS_FUNC_IND)	IPT2(io_addr, io_address, double_word *, value);
typedef	void (*IOS_FUNC_INSD)	IPT3(io_addr, io_address, double_word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTD)	IPT2(io_addr, io_address, double_word, value);
typedef	void (*IOS_FUNC_OUTSD)	IPT3(io_addr, io_address, double_word *, valarray, word, count);
#endif

LOCAL void generic_inw IPT2(io_addr, io_address, word *, value);
LOCAL void generic_insb IPT3(io_addr, io_address, half_word *, valarray, word, count);
LOCAL void generic_insw IPT3(io_addr, io_address, word *, valarray, word, count);
LOCAL void generic_outw IPT2(io_addr, io_address, word, value);
LOCAL void generic_outsb IPT3(io_addr, io_address, half_word *, valarray, word, count);
LOCAL void generic_outsw IPT3(io_addr, io_address, word *, valarray, word, count);
#ifdef SPC386
LOCAL void generic_ind IPT2(io_addr, io_address, double_word *, value);
LOCAL void generic_insd IPT3(io_addr, io_address, double_word *, valarray, word, count);
LOCAL void generic_outd IPT2(io_addr, io_address, double_word, value);
LOCAL void generic_outsd IPT3(io_addr, io_address, double_word *, valarray, word, count);
#endif

GLOBAL IOS_FUNC_INB 	Ios_inb_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INW	Ios_inw_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSB	Ios_insb_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSW	Ios_insw_function [IO_MAX_NUMBER_ADAPTORS];

GLOBAL IOS_FUNC_OUTB	Ios_outb_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTW	Ios_outw_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSB	Ios_outsb_function[IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSW	Ios_outsw_function[IO_MAX_NUMBER_ADAPTORS];

#ifdef SPC386
GLOBAL IOS_FUNC_IND	Ios_ind_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSD	Ios_insd_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTD	Ios_outd_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSD	Ios_outsd_function[IO_MAX_NUMBER_ADAPTORS];
#endif

/*
 *
 * ============================================================================
 * Local Subroutines
 * ============================================================================
 *
 */

#define BIT_NOT_SET(vector, bit)		\
	((vector == (IU32 *)0) ? FALSE: ((((vector[(bit) >> 5]) >> ((bit) & 0x1f)) & 1) == 0))

#define SET_THE_BIT(vector, bit)					\
	{								\
		 if (vector != (IU32 *)0)				\
		 {							\
			 vector[(bit) >> 5] |= (1 << ((bit) & 0x1f));	\
		 }							\
	}

/*
============================== io_empty_inb ==================================
    PURPOSE:
	To simulate an INB to an empty io_addr.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void io_empty_inb IFN2(io_addr, io_address, half_word *, value)
{
#ifdef PROD
	UNUSED(io_address);

#else
#if defined(NEC_98)
        if(host_getenv("SHOW_IO")){
            printf("Empty Adaptor IN Access ");
            printf("IO_PORT: %x\n", io_address);
        };
#else !NEC_98
	if (BIT_NOT_SET(ios_empty_in, (IU16)io_address))
	{
		/* First time for this port */
		always_trace1 ("INB attempted on empty port 0x%x", io_address);
		SET_THE_BIT(ios_empty_in, (IU16)io_address);
	}
#endif   //NEC_98
#endif /* PROD */

#ifdef NTVDM
    //
    // Check to see if we should load any VDD's
    //
    if (HostUndefinedIo(io_address)) {

        //
        // VDD was loaded, retry operation
        //
		(*Ios_inb_function
			[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
							(io_address, value);

    } else
#endif // NTVDM
    {
        // Nothing dynamically loaded, just use default value
        *value = IO_EMPTY_PORT_BYTE_VALUE;
    }

}

/*
============================== io_empty_outb ==================================
    PURPOSE:
	To simulate an OUTB to an empty io_addr.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void io_empty_outb IFN2(io_addr, io_address, half_word, value)
{
	UNUSED(value);
#ifdef PROD
	UNUSED(io_address);
#else
#if defined(NEC_98)
        if(host_getenv("SHOW_IO") && (io_address != 0x5F)) {
            printf("Empty Adaptor OUT Access ");
            printf("IO_PORT: %x ", io_address);
            printf("DATA: %x\n", value);
        };
#else !NEC_98
	if (BIT_NOT_SET(ios_empty_out, (IU16)io_address))
	{
		/* First time for this port */
		always_trace1 ("OUTB attempted on empty port 0x%x", io_address);
		SET_THE_BIT(ios_empty_out, (IU16)io_address);
	}
#endif   //NEC_98
#endif /* PROD */

#ifdef NTVDM
    //
    // Check to see if we should load any VDD's
    //
    if (HostUndefinedIo(io_address)) {
        //
        // VDD was loaded, retry operation
        //
		(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
				(io_address, value);
    }
#endif
}

/*
=============================== generic_inw ==================================
    PURPOSE:
	To simulate an INW using the appropriate INB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_inw IFN2(io_addr, io_address, word *, value)
{
	reg             temp;

	(*Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, &temp.byte.low);
	io_address++;
	(*Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, &temp.byte.high);
#ifdef LITTLEND
	*((half_word *) value + 0) = temp.byte.low;
	*((half_word *) value + 1) = temp.byte.high;
#endif				/* LITTLEND */

#ifdef BIGEND
	*((half_word *) value + 0) = temp.byte.high;
	*((half_word *) value + 1) = temp.byte.low;
#endif				/* BIGEND */
}

/*
=============================== generic_outw ==================================
    PURPOSE:
	To simulate an OUTW using the appropriate OUTB routine.
    INPUT:
    OUTPUT:
	Notes: GLOBAL for JOKER.
==============================================================================
*/
LOCAL void generic_outw IFN2(io_addr, io_address, word, value)
{
	reg             temp;

	temp.X = value;
	(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
					(io_address, temp.byte.low);
	++io_address;
	(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, temp.byte.high);
}

#ifdef SPC386
/*
=============================== generic_ind ==================================
    PURPOSE:
	To simulate an IND using the appropriate INW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_ind IFN2(io_addr, io_address, double_word *, value)
{
	word low, high;

	(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, &low);
	io_address += 2;
	(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, &high);
#ifdef LITTLEND
	*((word *) value + 0) = low;
	*((word *) value + 1) = high;
#endif				/* LITTLEND */

#ifdef BIGEND
	*((word *) value + 0) = high;
	*((word *) value + 1) = low;
#endif				/* BIGEND */
}
#endif /* SPC386 */

#ifdef SPC386
/*
=============================== generic_outd ==================================
    PURPOSE:
	To simulate an OUTD using the appropriate OUTW routine.
    INPUT:
    OUTPUT:
	Notes: GLOBAL for JOKER.
==============================================================================
*/
LOCAL void generic_outd IFN2(io_addr, io_address, double_word, value)
{
	word low, high;

	low = (word)(value & 0xffff);
	high = (word)((value & 0xffff0000) >> 16);

	(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, low);
	io_address += 2;
	(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, high);
}
#endif /* SPC386 */

/*
=============================== generic_insb ==================================
    PURPOSE:
	To simulate an INSB using the appropriate INB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/

/* MS NT monitor uses these string routines {in,out}s{b,w} string io support */
#if defined(NTVDM) && defined(MONITOR)
#undef LOCAL
#define LOCAL
#endif	/* NTVDM & MONITOR */

LOCAL void generic_insb IFN3(io_addr, io_address, half_word *, valarray,
	word, count)
{
	IOS_FUNC_INB func = Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}

/*
=============================== generic_outsb =================================
    PURPOSE:
	To simulate an OUTSB using the appropriate OUTB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_outsb IFN3(io_addr, io_address, half_word *, valarray, word, count)
{
	IOS_FUNC_OUTB func = Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}

/*
=============================== generic_insw ==================================
    PURPOSE:
	To simulate an INSW using the appropriate INW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_insw IFN3(io_addr, io_address, word *, valarray, word, count)
{
	IOS_FUNC_INW func = Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}

/*
=============================== generic_outsw =================================
    PURPOSE:
	To simulate an OUTSW using the appropriate OUTW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_outsw IFN3(io_addr, io_address, word *, valarray, word, count)
{
	IOS_FUNC_OUTW func = Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}

#ifdef SPC386
/*
=============================== generic_insd ==================================
    PURPOSE:
	To simulate an INSD using the appropriate IND routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL VOID generic_insd IFN3(io_addr, io_address, double_word *, valarray, word, count)
{
	IOS_FUNC_IND func = Ios_ind_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}
#endif

#ifdef SPC386
/*
=============================== generic_outsd =================================
    PURPOSE:
	To simulate an OUTSD using the appropriate OUTD routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL VOID generic_outsd IFN3(io_addr, io_address, double_word *, valarray, word, count)
{
	IOS_FUNC_OUTD func = Ios_outd_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}
#endif

/* ensure any more LOCAL routines remain LOCAL */
#if defined(NTVDM) && defined(MONITOR)
#undef LOCAL
#define LOCAL static
/*
 *  string byte handlers for monitor
 */
VOID insb IFN3(io_addr, io_address, half_word *, valarray, word, count)
{
    (*Ios_insb_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID outsb IFN3(io_addr, io_address, half_word *, valarray,word, count)
{
    (*Ios_outsb_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID insw IFN3(io_addr, io_address, word *, valarray, word, count)
{
    (*Ios_insw_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID outsw IFN3(io_addr, io_address, word *, valarray, word, count)
{
    (*Ios_outsw_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

#endif	/* NTVDM & MONITOR */

/*
 *
 * ============================================================================
 * Global Subroutines
 * ============================================================================
 *
 */

/*(
=================================== inb ======================================
    PURPOSE:
	To perform an INB - i.e. call the appropriate SoftPC adapter's INB
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.

	This also needs to be true of 386 CPU, or you'll get into a very
	nasty virtualisation loop.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	inb IFN2(io_addr, io_address, half_word *, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_inb(io_address);
#endif

#ifdef VIRTUALISATION

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_INB_OFFSET, (sizeof(IU8))))
	{
		*value = (IU8)value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_inb_function
			[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
							(io_address, value);
	}
}

/*(
================================== outb ======================================
    PURPOSE:
	To perform an OUTB - i.e. call the appropriate SoftPC adapter's OUTB
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outb IFN2(io_addr, io_address, half_word, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_outb(io_address, value);
#endif

	sub_note_trace2( IOS_VERBOSE, "outb( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	value32 = value;

	if (IOVirtualised(io_address, &value32, BIOS_OUTB_OFFSET, (sizeof(IU8))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
				(io_address, value);
	}
}

/*(
=================================== inw ======================================
    PURPOSE:
	To perform an INW - i.e. call the appropriate SoftPC adapter's INW
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	inw IFN2(io_addr, io_address, word *, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_inw(io_address);
#endif

#ifdef VIRTUALISATION

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_INW_OFFSET, (sizeof(IU16))))
	{
		*value = (IU16)value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
			(io_address, value);
	}
}

/*(
================================== outw ======================================
    PURPOSE:
	To perform an OUTW - i.e. call the appropriate SoftPC adapter's OUTW
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outw IFN2(io_addr, io_address, word, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= EGA_AC_INDEX_DATA && io_address <= EGA_IPSTAT1_REG)
		dump_outw(io_address, value);
#endif

	sub_note_trace2( IOS_VERBOSE, "outw( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	value32 = value;

	if (IOVirtualised(io_address, &value32, BIOS_OUTW_OFFSET, (sizeof(IU16))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
			(io_address, value);

	}
}

#ifdef SPC386
/*(
=================================== ind ======================================
    PURPOSE:
	To perform an IND - i.e. call the appropriate SoftPC adapter's IND
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	ind IFN2(io_addr, io_address, IU32 *, value)
{
	IU16 temp;

#ifdef VIRTUALISATION
	IU32 value32;

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_IND_OFFSET, (sizeof(IU32))))
	{
		*value = value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		inw(io_address,&temp);
		*value = (IU32)temp;
		io_address +=2;
		inw(io_address,&temp);
		*value |= ((IU32)temp << 16);
	}
}

/*(
================================== outd ======================================
    PURPOSE:
	To perform an OUTD - i.e. call the appropriate SoftPC adapter's OUTD
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outd IFN2(io_addr, io_address, IU32, value)
{
	sub_note_trace2( IOS_VERBOSE, "outd( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	if (IOVirtualised(io_address, &value, BIOS_OUTD_OFFSET, (sizeof(IU32))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		word temp;

		temp = (word)(value & 0xffff);
		outw(io_address,temp);
		io_address +=2;
		temp = (word)((value >> 16));
		outw(io_address,temp);
	}
}

#endif /* SPC386 */
/*(
============================== io_define_inb =================================
    PURPOSE:
	To declare the address of the INB IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void
#ifdef	ANSI
io_define_inb(half_word adapter,
	void (*func) IPT2(io_addr, io_address, half_word *, value))
#else
io_define_inb(adapter, func)
half_word       adapter;
void            (*func) ();
#endif	/* ANSI */
{
	Ios_inb_function[adapter]  = FAST_FUNC_ADDR(func);
	Ios_inw_function[adapter]  = FAST_FUNC_ADDR(generic_inw);
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
#ifdef SPC386
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insd_function[adapter] = generic_insd;
#endif	/* SPC386 */
}

/*(
========================== io_define_in_routines =============================
    PURPOSE:
	To declare the address of the input IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_define_in_routines IFN5(half_word, adapter,
					   IOS_FUNC_INB, inb_func,
					   IOS_FUNC_INW, inw_func,
					   IOS_FUNC_INSB, insb_func,
					   IOS_FUNC_INSW, insw_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_inw_function[adapter]  = FAST_FUNC_ADDR(generic_inw);
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
#ifdef SPC386
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insd_function[adapter] = generic_insd;
#endif	/* SPC386 */

	/*
	 *	Process args into table entries
	 */
	Ios_inb_function[adapter]  = FAST_FUNC_ADDR(inb_func);
	if (inw_func)  Ios_inw_function[adapter]   = FAST_FUNC_ADDR(inw_func);
	if (insb_func) Ios_insb_function[adapter]  = insb_func;
	if (insw_func) Ios_insw_function[adapter]  = insw_func;
}

/*(
============================= io_define_outb =================================
    PURPOSE:
	To declare the address of the OUTB IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_define_outb IFN2(half_word, adapter, IOS_FUNC_OUTB, func)
{
	Ios_outb_function[adapter]  = FAST_FUNC_ADDR(func);
	Ios_outw_function[adapter]  = FAST_FUNC_ADDR(generic_outw);
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
#ifdef SPC386
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsd_function[adapter]  = generic_outsd;
#endif	/* SPC386 */
}

/*(
========================= io_define_out_routines =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/

GLOBAL VOID	io_define_out_routines IFN5(half_word, adapter,
					    IOS_FUNC_OUTB, outb_func,
					    IOS_FUNC_OUTW, outw_func,
					    IOS_FUNC_OUTSB, outsb_func,
					    IOS_FUNC_OUTSW, outsw_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_outw_function[adapter]  = FAST_FUNC_ADDR(generic_outw);
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
#ifdef SPC386
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsd_function[adapter] = generic_outsd;
#endif	/* SPC386 */

	/*
	 *	Process args into table entries
	 */
	Ios_outb_function[adapter]  = FAST_FUNC_ADDR(outb_func);
	if (outw_func)  Ios_outw_function[adapter]   = FAST_FUNC_ADDR(outw_func);
	if (outsb_func) Ios_outsb_function[adapter]  = outsb_func;
	if (outsw_func) Ios_outsw_function[adapter]  = outsw_func;
}

#ifdef SPC386
/*(
========================= io_define_outd_routine =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL VOID	io_define_outd_routine IFN3(half_word, adapter,
					    IOS_FUNC_OUTD, outd_func, IOS_FUNC_OUTSD, outsd_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_outb_function[adapter]  = io_empty_outb;
	Ios_outw_function[adapter]  = generic_outw;
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
	Ios_outsd_function[adapter] = generic_outsd;

	/*
	 *	Process args into table entries
	 */
	if (outd_func)  Ios_outd_function[adapter]   = outd_func;
	if (outsd_func) Ios_outsd_function[adapter]  = outsd_func;
}
#endif	/* SPC386 */

#ifdef SPC386
/*(
========================= io_define_ind_routine =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL VOID	io_define_ind_routine IFN3(half_word, adapter,
					    IOS_FUNC_IND, ind_func, IOS_FUNC_INSD, insd_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_inb_function[adapter]  = io_empty_inb;
	Ios_inw_function[adapter]  = generic_inw;
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
	Ios_insd_function[adapter] = generic_insd;

	/*
	 *	Process args into table entries
	 */
	if (ind_func)  Ios_ind_function[adapter]   = ind_func;
	if (insd_func) Ios_insd_function[adapter]  = insd_func;
}
#endif	/* SPC386 */

/*(
============================= io_connect_port ================================
    PURPOSE:
	To associate a SoftPC IO adapter with the given IO address.
    INPUT:
    OUTPUT:
==============================================================================
)*/
#ifdef NTVDM
GLOBAL IBOOL	io_connect_port IFN3(io_addr, io_address, half_word, adapter,
	half_word, mode)
{
	if (mode & IO_READ){
		Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	if (mode & IO_WRITE){
		Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	return TRUE;
}
#else
GLOBAL void	io_connect_port IFN3(io_addr, io_address, half_word, adapter,
	half_word, mode)
{
	if (mode & IO_READ){
		Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	if (mode & IO_WRITE){
		Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
}
#endif


/*(
=========================== io_disconnect_port ===============================
    PURPOSE:
	To associate the empty adapter with the given IO address.
    INPUT:
    OUTPUT:
==============================================================================
)*/
#ifdef NTVDM
GLOBAL void     io_disconnect_port IFN2(io_addr, io_address, half_word, adapter)
{
        if (adapter != Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] &&
            adapter != Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)])
           {
            return;
           }

        Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = EMPTY_ADAPTOR;
        Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = EMPTY_ADAPTOR;
}
#else
GLOBAL void	io_disconnect_port IFN2(io_addr, io_address, half_word, adapter)
{
	UNUSED(adapter);
	Ios_in_adapter_table[io_address] = EMPTY_ADAPTOR;
	Ios_out_adapter_table[io_address] = EMPTY_ADAPTOR;
}
#endif	/* NTVDM */


/*(
=========================== get_inb_ptr ======================================
    PURPOSE:
	To return address of inb routine for the given port
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL IOS_FUNC_INB *get_inb_ptr IFN1(io_addr, io_address)
{
	return(&Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]);
}

/*(
=========================== get_outb_ptr =====================================
    PURPOSE:
	To return address of outb routine for the given port
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL IOS_FUNC_OUTB *get_outb_ptr IFN1(io_addr, io_address)
{
        return(&Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*(
================================ io_init ===================================
    PURPOSE:
	To initialise the SoftPC IO subsystem.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_init IFN0()
{
	IU32         i;	/* on some ports, PC_IO_MEM_SIZE == 0x10000, so this
			   must be a type with more than 16 bits */

	/*
	 * Set up all IO address ports with the "empty" adapter
	 */
	io_define_inb (EMPTY_ADAPTOR, io_empty_inb);
	io_define_outb(EMPTY_ADAPTOR, io_empty_outb);

#ifdef	MAC68K
	if (Ios_in_adapter_table == NULL) {				/* First time around -- allocate */
		Ios_in_adapter_table = host_malloc(PC_IO_MEM_SIZE);
		Ios_out_adapter_table = host_malloc(PC_IO_MEM_SIZE);
	}
#endif	/* MAC68K */

#ifndef PROD
	if (host_getenv("EMPTY_IO_VERBOSE") != NULL)
	{
		/* User does want empty I/O messages,
		 * so we must allocate bitmaps with one bit for every
		 * possible port number.
		 */
		ios_empty_in = (IU32 *)host_malloc((64*1024)/8);
		ios_empty_out = (IU32 *)host_malloc((64*1024)/8);
		memset((char *)ios_empty_in, 0, (64*1024)/8);
		memset((char *)ios_empty_out, 0, (64*1024)/8);
	}
#endif /* PROD */

	for (i = 0; i < PC_IO_MEM_SIZE; i++){
	    Ios_in_adapter_table[i] = EMPTY_ADAPTOR;
	    Ios_out_adapter_table[i] = EMPTY_ADAPTOR;
	}
}


#ifdef NTVDM
GLOBAL char GetExtIoInAdapter (io_addr ioaddr)
{
#ifndef PROD
    printf("GetExtIoInAdapter(%x) called\n",ioaddr);
#endif
    return EMPTY_ADAPTOR;
}

GLOBAL char GetExtIoOutAdapter (io_addr ioaddr)
{
#ifndef PROD
    printf("GetExtIoOutAdapter(%x) called\n",ioaddr);
#endif
    return EMPTY_ADAPTOR;
}
#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\main.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Main program
 *
 * Description	: Call initialisation functions then call simulate to
 *	 	  do the work.
 *
 * Author	: Rod Macgregor
 *
 * Notes	: The flag -v tells SoftPC to work silently unless
 *		  an error occurs.
 *
 */

/*
 * static char SccsID[]="@(#)main.c	1.49 06/23/95 Copyright Insignia Solutions Ltd.";
 */


/*
 * O/S includes
 */

#include <stdlib.h>
#include <stdio.h>
#include TypesH

/*
 * SoftPC includes
 */

#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "gvi.h"
#include "host.h"
#include "trace.h"
#ifdef SECURE
#include "debug.h"
#endif
#include "gmi.h"
#include "gfx_upd.h"
#include "cmos.h"
#include "gfi.h"
#include "timer.h"
#include "yoda.h"
//#include "host_env.h"

extern	void	host_start_cpu();	/* Start up the Intel emulation */

GLOBAL VOID    mouse_driver_initialisation(void);
GLOBAL void    InitialiseDosEmulation(int, char **);
GLOBAL ULONG   setup_global_data_ptr();

void init_virtual_drivers IPT0();

IMPORT void host_set_yoda_ints IPT0();
IMPORT void host_applClose IPT0();
#if defined(NEC_98)
IMPORT void setup_NEC98_globals IPT0();
#else    //NEC_98
IMPORT void setup_vga_globals IPT0();
#endif   //NEC_98
#ifdef ANSI
extern void host_applInit(int argc, char *argv[]);
#else
extern void host_applInit();
#endif	/* ANSI */

#ifdef REAL_VGA
extern int screen_init;
#endif

/* Have global variables defined here to indicate what product to run as. */

#ifdef SOFTWINDOWS
GLOBAL IBOOL Running_SoftWindows = TRUE;
GLOBAL CHAR *SPC_Product_Name = "SoftWindows";
#else
GLOBAL IBOOL Running_SoftWindows = FALSE;
GLOBAL CHAR *SPC_Product_Name = "SoftPC";
#endif /* SOFTWINDOWS */

GLOBAL char **pargv;	/* Pointer to argv		*/
GLOBAL int *pargc;	/* Pointer to argc		*/

#ifndef NTVDM
#ifndef ProcCommonCommLineArgs
extern VOID ProcCommonCommLineArgs IPT2(LONG, argc, CHAR, *argv[]);
#endif /* ProcCommonCommLineArgs */
#endif /* NTVDM */

/* Does this host need to have a different entry point ? */

#if defined(NTVDM) || defined(host_main)
INT host_main IFN2(INT, argc, CHAR **, argv)
#else   /* host_main */
INT      main IFN2(INT, argc, CHAR **, argv)
#endif  /* host_main */
{

#ifndef	CPU_40_STYLE
  IMPORT ULONG Gdp;
#endif	/* CPU_40_STYLE */

#ifdef SECURE
	char * sys_config_filename;
	ErrData err_data;
#endif

#ifdef	SETUID_ROOT

	/* make sure the real and effective UIDs are OK */
	host_init_uid ();

#endif	/* SETUID_ROOT */

#if !defined(PROD) || defined(HUNTER)

	trace_init();		/* set up the trace file */

#endif /* !PROD || HUNTER */

/***********************************************************************
 *								       *
 * Set up the global pointers to argc and argv for lower functions.    *
 * These must be saved as soon as possible as they are required for    *
 * displaying the error panel for the HP port.  Giving a null pointer  *
 * as the address of argc crashed the X Toolkit.		       *
 *								       *
 ***********************************************************************/

  pargc = &argc;
  pargv = argv;

#if !defined(NTVDM) && !defined(macintosh) && !defined(VMS)
  setupEnv(argc,argv);	/* set up Unix run-time environment */
#endif	/* NTVDM, macintosh, VMS */

#ifndef PROD
  host_set_yoda_ints();
#endif /* !PROD */

#ifdef SECURE
  err_data.string_1 = err_data.string_2 = err_data.string_3 = "";
#endif

#ifndef NTVDM
  ProcCommonCommLineArgs(argc,argv);
#endif /* NTVDM */
  host_applInit(argc,argv);	/* recommended home is host/xxxx_reset.c */

#ifdef SECURE
  /* Now that error panels are available, Validate SoftWindows Integrity. */
  sys_config_filename = host_expand_environment_vars(SYSTEM_CONFIG);
  if (!host_validate_swin_integrity(sys_config_filename))
  {
#ifdef PROD
    err_data.string_3 = sys_config_filename;
    (VOID) host_error_ext(EG_SYS_INSECURE, ERR_QUIT, &err_data);
    exit(1);
#else
    always_trace1("Secure Mode ERROR:\"%s\" is insecure.", sys_config_filename);
#endif
  }
#endif
#if defined(CPU_40_STYLE) && !defined(CCPU)
  {
	extern void parse_lc_options IPT2(int *,pargc, char ***,pargv);

  	parse_lc_options(&argc,&argv);
  }
#endif /* assembler 4.0 cpu */

  verbose = FALSE;

#ifndef PROD
  io_verbose = FALSE;
#endif

  /*
   * Pre-Config Base code initilisation.
   *
   * Setup the initial gfi funtion pointers before going into config
   */
#ifndef NEC_98
  gfi_init();
#endif   //NEC_98

  /*
   * Initialise any Windows 3.x compliant DOS Drivers.
   * We do it here as config (and who knows who else) believe they can
   * access certain driver data at any time. Logically it ought to be done
   * when the driver is loaded under DOS, however historically it used to
   * be done as Static Data initialisation, so we mirror this old method
   * as closely as possible.
   *
   * The mac doesn't use the base config system and so calls init_virtual_drivers()
   * as part of it's host_applInit().
   */

#ifndef	macintosh
  init_virtual_drivers();
#endif

/*
 * Find our configuration
 *------------------------*/

  config();

#if defined(PROFILE) && !defined(CPU_40_STYLE)
/*
 * Stick this after config as Gdp must be set up. 4.0 calls ProfileInit from
 * sas_init() to ensure everything included.
 */
  ProfileInit();
#endif	/*PROFILE*/

#ifndef NEC_98
#if defined(NTVDM) || defined(macintosh)
/* Read the cmos from file to emulate data not being
 * lost between invocations of SoftPC
 *-----------------------------------------------------*/

  cmos_pickup();
#endif	/* defined(NTVDM) || defined(macintosh) */

#if !defined(PROD) || defined(HUNTER)

/******************************************************************
 *								  *
 * Bit of a liberty being taken here.				  *
 * Hunter and noProd versions can set NPX and GFX adapter from	  *
 * environment vars, this can cause the old cmos to disagree	  *
 * with the new config structure.				  *
 * This function call updates the cmos.				  *
 *								  *
 ******************************************************************/

  cmos_equip_update();

#endif
#endif   //NEC_98

/*
 * initialise the cpu
 *----------------------*/

  cpu_init();

#ifndef PROD

  if (host_getenv("YODA") != NULL)
  {
    force_yoda();
  }

/*
 * Look for environment variable TOFF, when set no timer interrupts
 *------------------------------------------------------------------*/

  if( host_getenv("TOFF") != NULL )
    axe_ticks( -1 );		/* lives in base:timer.c */

#endif /* PROD */

#ifdef GISP_SVGA
  /* We have to go here to ensure that config doesn't undo any of the
  lovely patching that we do to the ROMs */
  gispROMInit( );
#endif /* GISP_SVGA */

	/*
	 * Set up the VGA globals before host_init_screen() in
	 * case of graphics activity.
	 *-------------------------------------------------------*/

#ifndef A3CPU
	(VOID) setup_global_data_ptr();
#endif	/* not A3CPU */

#if defined(NEC_98)
        setup_NEC98_globals();
#else    //NEC_98
#ifndef GISP_SVGA
	setup_vga_globals();
#else /* GISP_SVGA */
	setupHwVGAGlobals( );
#endif /* GISP_SVGA */
#endif   //NEC_98

#if defined(NEC_98)
  host_init_screen();
#else   //NEC_98
#ifdef REAL_VGA
	if (screen_init == 0)
	{
#endif /* REAL_VGA */

  host_init_screen();

#ifdef REAL_VGA
	}
#endif /* REAL_VGA */
#endif   //NEC_98

#ifdef IPC
  host_susp_q_init();
#endif

#ifdef NTVDM
/*
 * If you've got Dos Emulation - flaunt it!!
 * Initialise VDDs, Read in the Dos ntio.sys file and arrange for the cpu
 * to start execution at it's initialisation entry point.
 */
    InitialiseDosEmulation(argc, argv);
#endif	/* NTVDM */

/*
 * simulate the Intel 8088/iAPX286 cpu
 *-------------------------------------*/
/*
	Start off the cpu emulation. This will either be software
	emulation of protected mode 286/287 or possibly hardware
	eg 486 on Sparc platform
*/

  host_start_cpu();
  host_applClose();    /* recommended home is host/xxxx_reset.c */

/*
 * We should never get here so return an error status.
 */

  return(-1);

}


/**/

GLOBAL void init_virtual_drivers (void)
{
#ifdef HFX
	hfx_driver_initialisation();
#endif
	mouse_driver_initialisation();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\terminat.c ===
#include "insignia.h"
#include "host_def.h"
/*[
        Name:           terminate.c
        Derived From:   Base 2.0
        Author:         Rod MacGregor
        Created On:     Unknown
        Sccs ID:        @(#)terminate.c 1.23 06/15/94
        Purpose:        We are about to die, put the kernel back the way
                        that it was.

        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#include <stdlib.h>
#include <stdio.h>
#include TypesH

#include "xt.h"
#include "error.h"
#include "config.h"
#include "host_lpt.h"
#include "rs232.h"
#include "host_com.h"
#include "timer.h"
#include "cmos.h"
#include "fdisk.h"
#include "debug.h"
#include "gvi.h"
#include CpuH
#ifdef NOVELL
#include "novell.h"
#endif
#ifdef GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif /* GISP_SVGA */
#ifdef LICENSING
#include "host_lic.h"
#endif
#include "emm.h"
#include "sndblst.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

IMPORT VOID host_applClose IPT0();
IMPORT VOID host_terminate IPT0();

void terminate()
{
        SAVED BOOL already_called_terminate = FALSE;
        UTINY i;

        if (already_called_terminate)
        {
                assert0( NO, "Error: terminate called twice - exiting" );
                exit(0);
        }
        else
                already_called_terminate = TRUE;

#ifdef MSWDVR
        WinTerm();
#endif

#ifdef SWIN_SNDBLST_NULL
        sb_term();
#else
        SbTerminate();
#endif /* SWIN_SNDBLST_NULL */

#ifdef GISP_SVGA
        /* Get back to window if we are full screen */
        if( hostIsFullScreen( ) )
                disableFullScreenVideo( FALSE );
#endif /* GISP_SVGA */

        /* terminate COM and LPT devices */
#ifdef  PC_CONFIG
        /* PC_CONFIG style host_lpt_close() and
        host_com_close() calls should be added
        in here */
#else
        for (i = 0 ; i < NUM_PARALLEL_PORTS; i++)
                config_activate((IU8)(C_LPT1_NAME + i), FALSE);

        for (i = 0 ; i < NUM_SERIAL_PORTS; i++)
                config_activate((IU8)(C_COM1_NAME + i), FALSE);
#endif

        /* Update the cmos.ram file */
        cmos_update();

        host_fdisk_term();

        gvi_term();     /* close down the video adaptor */

#ifndef NTVDM
        host_timer_shutdown(); /* Stop the timer */
#endif

#ifdef LIM
        host_deinitialise_EM(); /* free memory or file used by EM */
#endif

        config_activate(C_FLOPPY_A_DEVICE, FALSE);
#ifdef FLOPPY_B
        config_activate(C_FLOPPY_B_DEVICE, FALSE);
#endif /* FLOPPY_B */
#ifdef SLAVEPC
        config_activate(C_SLAVEPC_DEVICE, FALSE);
#endif /* SLAVEPC */

        /*
         * Do any cpu-specific termination bits.
         */
#ifdef CPU_30_STYLE
        cpu_terminate();
#endif

#ifdef NOVELL
        net_term();     /* Shutdown network */
#endif

#ifdef LICENSING
        (*license_exit)(); /* Shutdown licensing system */
#endif
        /*
         * Do any host-specific termination bits.
         */
        host_applClose();
        host_terminate();

        /*
         * Seppuku.
         */
        exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=support
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=                ..\terminat.c    \
                        ..\time_day.c    \
                        ..\ios.c \
                        ..\main.c \
                        ..\get_env.c \
                        ..\xt.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\xt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Global variable definitions
 *
 * Description	: Contains definitions for registers and general
 *		  variables required by all modules.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

/*
 * static char SccsID[]="@(#)xt.c	1.22 01/23/95 Copyright Insignia Solutions Ltd.";
 */


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
   specific CPU variables.
 */
word  cpu_interrupt_map;                /* Bit map of ints outstanding  */

half_word cpu_int_translate[16];        /* this will go very soon!      */
/*
 *
 * The current usage is:
 *
 *              0       - Hardware interrupt
 *              1-7     - Not Used
 *              8       - Software Int - set by cpu_sw_interrupt() - REMOVED!
 *              9       - Trap
 *              10      - Reset IP after a POP/MOV CS.
 *              11      - Trap flag changed - this has delay.
 *              12-15   - Not Used
 */

word cpu_int_delay;                     /* Delay before pending interrupt */

int trap_delay_count;

/*
 * The lock flag prevents the Interrupt Controller Adapter from being
 * called from a signal handler while it is already active in the mainline.
 */

half_word ica_lock;

/*
 * The actual CCPU registers
 */

#if defined(CCPU) && !defined(CPU_30_STYLE)
#ifndef MAC_LIKE
reg A;		/* Accumulator		*/
reg B;		/* Base			*/
reg C;		/* Count		*/
reg D;		/* Data			*/
reg BP;		/* Base pointer		*/
reg SI;		/* Source Index		*/
reg DI;		/* Destination Index	*/
#endif /* MAC_LIKE */
reg SP;		/* Stack Pointer	*/

reg IP;		/* Instruction Pointer	*/

reg CS;		/* Code Segment		*/
reg DS;		/* Data Segment		*/
reg SS;		/* Stack Segment	*/
reg ES;		/* Extra Segment	*/

/* Code Segment Register */
half_word CS_AR;    /* Access Rights Byte */
sys_addr  CS_base;  /* Base Address */
word      CS_limit; /* Segment 'size' */
int       CPL;      /* Current Privilege Level */

/* Data Segment Register */
half_word DS_AR;    /* Access Rights Byte */
sys_addr  DS_base;  /* Base Address */
word      DS_limit; /* Segment 'size' */

/* Stack Segment Register */
half_word SS_AR;    /* Access Rights Byte */
sys_addr  SS_base;  /* Base Address */
word      SS_limit; /* Segment 'size' */

/* Extra Segment Register */
half_word ES_AR;    /* Access Rights Byte */
sys_addr  ES_base;  /* Base Address */
word      ES_limit; /* Segment 'size' */

/* Global Descriptor Table Register */
sys_addr GDTR_base;  /* Base Address */
word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
sys_addr IDTR_base;  /* Base Address */
word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
reg      LDTR;       /* Selector */
sys_addr LDTR_base;  /* Base Address */
word     LDTR_limit; /* Segment 'size' */

/* Task Register */
reg      TR;       /* Selector */
sys_addr TR_base;  /* Base Address */
word     TR_limit; /* Segment 'size' */

mreg MSW;	/* Machine Status Word */

int STATUS_CF;
int STATUS_SF;
int STATUS_ZF;
int STATUS_AF;
int STATUS_OF;
int STATUS_PF;
int STATUS_TF;
int STATUS_IF;
int STATUS_DF;
int STATUS_NT;
int STATUS_IOPL;
#endif /* defined(CCPU) && !defined(CPU_30_STYLE) */

/*
 * Global Flags and variables
 */

int verbose;			/* TRUE => trace instructions   */

/*
 * Misc. Prot Mode support routines which are independant of CPU type
 *                                  ---------------------------------
 */
#ifdef CPU_30_STYLE
#ifndef GISP_CPU    /* GISP has its own versions of these internal to the CPU */

#define GET_SELECTOR_INDEX_TIMES8(x)  ((x) & 0xfff8)
#define GET_SELECTOR_TI(x)            (((x) & 0x0004) >> 2)

#if defined(CPU_40_STYLE)
#if defined(PROD) && !defined(CCPU)
#undef effective_addr
GLOBAL LIN_ADDR effective_addr IFN2(IU16, seg, IU32, off)
{
	return (*(Cpu.EffectiveAddr))(seg, off);
}
#endif	/* PROD & !CCPU */
#else	/* !CPU_40_STYLE */
#if !(defined(NTVDM) && defined(MONITOR))  /* MS NT monitor has own effective_addr fn */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Calculate effective address.                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL LIN_ADDR effective_addr IFN2(IU16, seg, IU32, off)
{
	LIN_ADDR descr_addr;
	DESCR entry;

	if ((!getPE()) || getVM()) {
		return ((LIN_ADDR)seg << 4) + off;
	} else {
#if defined(SWIN_CPU_OPTS) || defined(CPU_40_STYLE)
		LIN_ADDR base;

		if (Cpu_find_dcache_entry( seg, &base ))
		{
			/* Cache Hit!! */
			return base + off;
		}
#endif /* SWIN_CPU_OPTS or CPU_40_STYLE*/

		if ( selector_outside_table(seg, &descr_addr) == 1 ) {

			/*
			 * This is probably not a major disaster, just a result
			 * of the fact that after protected mode is invoked it
			 * will take say 5-10 instructions for an application
			 * to update all the segment registers. We just
			 * maintain real mode semantics while this error occurs.
			 */

			return ((LIN_ADDR)seg << 4) + off;
		}
		else
		{
			read_descriptor(descr_addr, &entry);
			return entry.base + off;
		}
      	}
}

#endif	/* !(NTVDM & MONITOR) */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Read a decriptor table entry from memory.                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#endif	/* !CPU_40_STYLE */

GLOBAL void read_descriptor IFN2(LIN_ADDR, addr, DESCR *, descr)
{
	IU32 first_dword, second_dword;
	IU32 limit;

	/*
	 * The format of a 286 descriptor is:-
	 *
	 * ===========================
	 * +1 |        LIMIT 15-0       | +0
	 * ===========================
	 * +3 |        BASE 15-0        | +2
	 * ===========================
	 * +5 |     AR     | BASE 23-16 | +4
	 * ===========================
	 * +7 |         RESERVED        | +6
	 * ===========================
	 */
	/*
	 * The format of a 386 descriptor is:-
	 *
	 *    =============================      AR  = Access Rights.
	 * +1 |         LIMIT 15-0        | +0   AVL = Available.
	 *    =============================      D   = Default Operand
	 * +3 |         BASE 15-0         | +2          Size, = 0 16-bit
	 *    =============================                   = 1 32-bit.
	 * +5 |      AR     | BASE 23-16  | +4   G   = Granularity,
	 *    =============================             = 0 byte limit
	 *    |             | | | |A|LIMIT|             = 1 page limit.
	 * +7 | BASE 31-24  |G|D|0|V|19-16| +6
	 *    |             | | | |L|     |
	 *    =============================
	 *
	 */

	/* read in decriptor with minimum interaction with memory */
#if defined(NTVDM) && defined(CPU_40_STYLE)
    /* On NT, this routine can be called from non-CPU threads, so we don't */
    /* want to use SAS at all. Instead, we rely on NtGetPtrToLinAddrByte,  */
    /* which is provided by the CPU and is safe for multi-threading. We are*/
    /* also relying on the fact the NT is always little-endian. */
    {
        IU32 *desc_addr = (IU32 *) NtGetPtrToLinAddrByte(addr);

        first_dword = *desc_addr;
        second_dword = *(desc_addr + 1);
    }
#else
	first_dword = sas_dw_at(addr);
	second_dword = sas_dw_at(addr+4);
#endif

	/* load attributes and access rights */
	descr->AR = (USHORT)((second_dword >> 8) & 0xff);

	/* unpack the base */
	descr->base = (first_dword >> 16) |
#ifdef SPC386
	    (second_dword & 0xff000000) |
#endif
	    (second_dword << 16 & 0xff0000 );

	/* unpack the limit */
#ifndef SPC386
	descr->limit = first_dword & 0xffff;
#else
	limit = (first_dword & 0xffff) | (second_dword & 0x000f0000);

	if ( second_dword & 0x00800000 ) /* check bit 23 */
		{
			/* Granularity Bit Set. Limit is expressed in pages
	 (4k bytes), convert to byte limit */
			limit = limit << 12 | 0xfff;
		}
	descr->limit = limit;
#endif /* ifndef SPC386 else */

}

#if !(defined(NTVDM) && defined(MONITOR))  /* MS NT monitor has own selector_outside_table fn */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check if selector outside bounds of GDT or LDT                     */
/* Return 1 for outside table, 0 for inside table.                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL boolean selector_outside_table IFN2(IU16, selector, LIN_ADDR *, descr_addr)
{
	/* selector		(I) selector to be checked */
	/* descr_addr	(O) address of related descriptor */

	LIN_ADDR offset;

	offset = GET_SELECTOR_INDEX_TIMES8(selector);

	/* choose a table */
	if ( GET_SELECTOR_TI(selector) == 0 )
	{
		/* GDT - trap NULL selector or outside table */
		if ( offset == 0 || offset + 7 > getGDT_LIMIT() )
			return 1;
		*descr_addr = getGDT_BASE() + offset;
	}
	else
	{
		/* LDT - trap invalid LDT or outside table */
		if ( getLDT_SELECTOR() == 0 || offset + 7 > getLDT_LIMIT() )
			return 1;
		*descr_addr = getLDT_BASE() + offset;
	}

	return 0;
}

#endif	/* !(NTVDM & MONITOR) */

#endif /* !GISP_CPU */
#endif /* CPU_30_STYLE */


/*
 * The following is a table lookup for finding parity of a byte
 */

#if !defined(MAC_LIKE) && !defined(CPU_30_STYLE)

half_word pf_table[] = {
	1,	/* 00 */
	0,	/* 01 */
	0,	/* 02 */
	1,	/* 03 */
	0,	/* 04 */
	1,	/* 05 */
	1,	/* 06 */
	0,	/* 07 */
	0,	/* 08 */
	1,	/* 09 */
	1,	/* 0a */
	0,	/* 0b */
	1,	/* 0c */
	0,	/* 0d */
	0,	/* 0e */
	1,	/* 0f */
	0,	/* 10 */
	1,	/* 11 */
	1,	/* 12 */
	0,	/* 13 */
	1,	/* 14 */
	0,	/* 15 */
	0,	/* 16 */
	1,	/* 17 */
	1,	/* 18 */
	0,	/* 19 */
	0,	/* 1a */
	1,	/* 1b */
	0,	/* 1c */
	1,	/* 1d */
	1,	/* 1e */
	0,	/* 1f */
	0,	/* 20 */
	1,	/* 21 */
	1,	/* 22 */
	0,	/* 23 */
	1,	/* 24 */
	0,	/* 25 */
	0,	/* 26 */
	1,	/* 27 */
	1,	/* 28 */
	0,	/* 29 */
	0,	/* 2a */
	1,	/* 2b */
	0,	/* 2c */
	1,	/* 2d */
	1,	/* 2e */
	0,	/* 2f */
	1,	/* 30 */
	0,	/* 31 */
	0,	/* 32 */
	1,	/* 33 */
	0,	/* 34 */
	1,	/* 35 */
	1,	/* 36 */
	0,	/* 37 */
	0,	/* 38 */
	1,	/* 39 */
	1,	/* 3a */
	0,	/* 3b */
	1,	/* 3c */
	0,	/* 3d */
	0,	/* 3e */
	1,	/* 3f */
	0,	/* 40 */
	1,	/* 41 */
	1,	/* 42 */
	0,	/* 43 */
	1,	/* 44 */
	0,	/* 45 */
	0,	/* 46 */
	1,	/* 47 */
	1,	/* 48 */
	0,	/* 49 */
	0,	/* 4a */
	1,	/* 4b */
	0,	/* 4c */
	1,	/* 4d */
	1,	/* 4e */
	0,	/* 4f */
	1,	/* 50 */
	0,	/* 51 */
	0,	/* 52 */
	1,	/* 53 */
	0,	/* 54 */
	1,	/* 55 */
	1,	/* 56 */
	0,	/* 57 */
	0,	/* 58 */
	1,	/* 59 */
	1,	/* 5a */
	0,	/* 5b */
	1,	/* 5c */
	0,	/* 5d */
	0,	/* 5e */
	1,	/* 5f */
	1,	/* 60 */
	0,	/* 61 */
	0,	/* 62 */
	1,	/* 63 */
	0,	/* 64 */
	1,	/* 65 */
	1,	/* 66 */
	0,	/* 67 */
	0,	/* 68 */
	1,	/* 69 */
	1,	/* 6a */
	0,	/* 6b */
	1,	/* 6c */
	0,	/* 6d */
	0,	/* 6e */
	1,	/* 6f */
	0,	/* 70 */
	1,	/* 71 */
	1,	/* 72 */
	0,	/* 73 */
	1,	/* 74 */
	0,	/* 75 */
	0,	/* 76 */
	1,	/* 77 */
	1,	/* 78 */
	0,	/* 79 */
	0,	/* 7a */
	1,	/* 7b */
	0,	/* 7c */
	1,	/* 7d */
	1,	/* 7e */
	0,	/* 7f */
	0,	/* 80 */
	1,	/* 81 */
	1,	/* 82 */
	0,	/* 83 */
	1,	/* 84 */
	0,	/* 85 */
	0,	/* 86 */
	1,	/* 87 */
	1,	/* 88 */
	0,	/* 89 */
	0,	/* 8a */
	1,	/* 8b */
	0,	/* 8c */
	1,	/* 8d */
	1,	/* 8e */
	0,	/* 8f */
	1,	/* 90 */
	0,	/* 91 */
	0,	/* 92 */
	1,	/* 93 */
	0,	/* 94 */
	1,	/* 95 */
	1,	/* 96 */
	0,	/* 97 */
	0,	/* 98 */
	1,	/* 99 */
	1,	/* 9a */
	0,	/* 9b */
	1,	/* 9c */
	0,	/* 9d */
	0,	/* 9e */
	1,	/* 9f */
	1,	/* a0 */
	0,	/* a1 */
	0,	/* a2 */
	1,	/* a3 */
	0,	/* a4 */
	1,	/* a5 */
	1,	/* a6 */
	0,	/* a7 */
	0,	/* a8 */
	1,	/* a9 */
	1,	/* aa */
	0,	/* ab */
	1,	/* ac */
	0,	/* ad */
	0,	/* ae */
	1,	/* af */
	0,	/* b0 */
	1,	/* b1 */
	1,	/* b2 */
	0,	/* b3 */
	1,	/* b4 */
	0,	/* b5 */
	0,	/* b6 */
	1,	/* b7 */
	1,	/* b8 */
	0,	/* b9 */
	0,	/* ba */
	1,	/* bb */
	0,	/* bc */
	1,	/* bd */
	1,	/* be */
	0,	/* bf */
	1,	/* c0 */
	0,	/* c1 */
	0,	/* c2 */
	1,	/* c3 */
	0,	/* c4 */
	1,	/* c5 */
	1,	/* c6 */
	0,	/* c7 */
	0,	/* c8 */
	1,	/* c9 */
	1,	/* ca */
	0,	/* cb */
	1,	/* cc */
	0,	/* cd */
	0,	/* ce */
	1,	/* cf */
	0,	/* d0 */
	1,	/* d1 */
	1,	/* d2 */
	0,	/* d3 */
	1,	/* d4 */
	0,	/* d5 */
	0,	/* d6 */
	1,	/* d7 */
	1,	/* d8 */
	0,	/* d9 */
	0,	/* da */
	1,	/* db */
	0,	/* dc */
	1,	/* dd */
	1,	/* de */
	0,	/* df */
	0,	/* e0 */
	1,	/* e1 */
	1,	/* e2 */
	0,	/* e3 */
	1,	/* e4 */
	0,	/* e5 */
	0,	/* e6 */
	1,	/* e7 */
	1,	/* e8 */
	0,	/* e9 */
	0,	/* ea */
	1,	/* eb */
	0,	/* ec */
	1,	/* ed */
	1,	/* ee */
	0,	/* ef */
	1,	/* f0 */
	0,	/* f1 */
	0,	/* f2 */
	1,	/* f3 */
	0,	/* f4 */
	1,	/* f5 */
	1,	/* f6 */
	0,	/* f7 */
	0,	/* f8 */
	1,	/* f9 */
	1,	/* fa */
	0,	/* fb */
	1,	/* fc */
	0,	/* fd */
	0,	/* fe */
	1	/* ff */
};
#endif /* !defined(MAC_LIKE) && !defined(CPU_30_STYLE) */


/*(
 *========================== CsIsBig ===================================
 * CsIsBig
 *
 * Purpose
 *	This function returns true if the indicated code segment is a 32 bit
 *	one, and false if it isn't.
 *
 * Input
 *	csVal	The selector to check
 *
 * Outputs
 *	None.
 *
 * Description
 *	Look at the descriptor.
)*/

GLOBAL IBOOL
CsIsBig IFN1(IU16, csVal)
{
#ifdef SPC386
	LIN_ADDR base, offset;	/* Of the descriptor to use */

	if(getVM() || !getPE()) {
		return(FALSE);	/* no 32 bit CS in V86 or real modes */
	} else {
		offset = csVal & (~7);	/* remove the RPL and TI gives offset */
		if (csVal & 4) {	/* check TI bit */
			base = getLDT_BASE();
		} else {
			base = getGDT_BASE();
		}

		/*
		 * Return true if the big bit in the descriptor is set.
		 */

		return(sas_hw_at(base + offset + 6) & 0x40);
	}
#else /* SPC386 */
	return (FALSE);
#endif /* SPC386 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\support\time_day.c ===
#if defined(NEC_98)
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#endif   //NEC_98
#include "windows.h"   /* included for Sleep() */



#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * File		: time_day.c
 *
 * Title	: Time of day
 *
 * Sccs ID	: @(#)time_day.c	1.27 4/20/94
 *
 * Description	: Get/Set time of day
 *
 * Author	: Henry Nash
 *
 * Notes	: The PC-XT version has an interrupt 18.203 times a second
 *		  to keep the counter up to date.  We interrupt at a similar
 *		  rate, but because of occasional heavy graphics or disk
 *		  operations we lose ticks. In an attempt to still keep
 *		  good time, we correct the stored time whenever the host
 *		  detects a timer event, using the host time facilities.
 *
 *                Upon reset time_of_day_init() grabs the host system time &
 *                puts it into the BIOS data area variables. Subsequent
 *                time of day accesses are maintained using the host system
 *		  time. This enables well behaved programs to keep good time
 *		  even if ticks are missed.
 *
 * Mods: (r3.4) : Make use of the host time structures host_timeval,
 *                host_timezone, and host_tm, which are equivalent
 *		  to the Unix BSD4.2 structures.
 *
 *		  Removed calls to cpu_sw_interrupt and replaced with
 *		  host_simulate
 */

#ifdef SCCSID
static char SccsID[]="@(#)time_day.c	1.27 4/20/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include TimeH
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include CpuH
#include "bios.h"
#include "fla.h"
#include "host.h"
#include "timeval.h"
#include "timer.h"
#include "error.h"

#include "cmos.h"
#include "cmosbios.h"
#include "ica.h"


/*
 * ===========================================================================
 * Local static data and defines
 * ===========================================================================
 */
#if defined(NEC_98)
LOCAL word bin2bcd();
LOCAL word bcd2bin();
#else   //NEC_98

#ifdef XTSFD
#    define DAY_COUNT	BIOS_VAR_START + 0xCE
#endif


#ifdef NTVDM

BOOL UpDateInProgress(void);
#define UPDATE_IN_PROGRESS      UpDateInProgress()
IMPORT VOID host_init_bda_timer(void);

#else

#define UPDATE_IN_PROGRESS      ( cmos_read(CMOS_REG_A ) & 0x80 )
static sys_addr user_timer_int_vector;
static IVT_ENTRY standard_user_timer_int_vector;
static IVT_ENTRY compatibility_user_timer_int_vector;
#endif

#ifdef ANSI
LOCAL void get_host_timestamp(word *, word *, half_word *);
LOCAL void write_host_timestamp(int, int);
LOCAL void TimeToTicks(int, int, int, word *, word *);
LOCAL void get_host_time(int *, int *, int *);
#else
LOCAL void get_host_timestamp();
LOCAL void write_host_timestamp();
LOCAL void TimeToTicks();
LOCAL void get_host_time();
#endif /* ANSI */
#endif   //NEC_98

#define TICKS_PER_HOUR      65543L
#define TICKS_PER_MIN       1092L
#define TICKS_PER_SEC       18L

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

void time_of_day()
{
#if defined(NEC_98)
    SYSTEMTIME  now;
    DWORD       DataBuffer;
    WORD        tmp;
    NTSTATUS    Status;
    HANDLE      Token;
    BYTE        OldPriv[1024];
    PBYTE       pbOldPriv;
    LUID        LuidPrivilege;
    PTOKEN_PRIVILEGES   NewPrivileges;
    ULONG       cbNeeded;

    switch(getAH()) {
        case 0:
            GetLocalTime(&now);
            DataBuffer = (getES() << 4) + getBX();
            now.wYear = now.wYear - ( now.wYear / 100 ) * 100;
            sas_store(DataBuffer, bin2bcd(now.wYear));
            sas_store(DataBuffer + 1, (now.wMonth << 4) | now.wDayOfWeek);
            sas_store(DataBuffer + 2, bin2bcd(now.wDay));
            sas_store(DataBuffer + 3, bin2bcd(now.wHour));
            sas_store(DataBuffer + 4, bin2bcd(now.wMinute));
            sas_store(DataBuffer + 5, bin2bcd(now.wSecond));
            break;
        case 1:
            tmp = 0;
            DataBuffer = (getES() << 4) + getBX();
            sas_load(DataBuffer, &tmp);
            if(bcd2bin(tmp) > 79)
                now.wYear = bcd2bin(tmp) + 1900;
            else
                now.wYear = bcd2bin(tmp) + 2000;
            sas_load(DataBuffer + 1, &tmp);
            now.wMonth = tmp >> 4;
            now.wDayOfWeek = tmp & 0x0F;
            sas_load(DataBuffer + 2, &tmp);
            now.wDay = bcd2bin(tmp);
            sas_load(DataBuffer + 3, &tmp);
            now.wHour = bcd2bin(tmp);
            sas_load(DataBuffer + 4, &tmp);
            now.wMinute = bcd2bin(tmp);
            sas_load(DataBuffer + 5, &tmp);
            now.wSecond = bcd2bin(tmp);
            now.wMilliseconds = 0;

            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                        &Token
                        );

            if ( !NT_SUCCESS( Status )) {
                break;
            }

            pbOldPriv = OldPriv;

    //
    // Initialize the privilege adjustment structure
    //

//          LuidPrivilege = RtlConvertLongToLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
            LuidPrivilege.LowPart  = SE_SYSTEMTIME_PRIVILEGE;
            LuidPrivilege.HighPart = 0L;

            NewPrivileges = (PTOKEN_PRIVILEGES)malloc(sizeof(TOKEN_PRIVILEGES) +
                (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
            if (NewPrivileges == NULL) {
                CloseHandle(Token);
                break;
            }

            NewPrivileges->PrivilegeCount = 1;
            NewPrivileges->Privileges[0].Luid = LuidPrivilege;
            NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

            cbNeeded = 1024;

            Status = NtAdjustPrivilegesToken (
                Token,
                FALSE,
                NewPrivileges,
                cbNeeded,
                (PTOKEN_PRIVILEGES)pbOldPriv,
                &cbNeeded
                );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                pbOldPriv = malloc(cbNeeded);

                if ( pbOldPriv == NULL ) {
                    CloseHandle(Token);
                    free(NewPrivileges);
                    break;
                }

                Status = NtAdjustPrivilegesToken (
                        Token,
                        FALSE,
                        NewPrivileges,
                        cbNeeded,
                        (PTOKEN_PRIVILEGES)pbOldPriv,
                        &cbNeeded
                        );

            }

    //
    // STATUS_NOT_ALL_ASSIGNED means that the privilege isn't
    // in the token, so we can't proceed.
    //
    // This is a warning level status, so we must check
    // for it explicitly.
    //

            if ( !NT_SUCCESS( Status ) || (Status == STATUS_NOT_ALL_ASSIGNED) ) {

                CloseHandle( Token );
                free(NewPrivileges);
                free(pbOldPriv);
                break;
            }

            SetLocalTime(&now);


            (VOID) NtAdjustPrivilegesToken (
                Token,
                FALSE,
                (PTOKEN_PRIVILEGES)pbOldPriv,
                0,
                NULL,
                NULL
                );

            CloseHandle( Token );
            free(NewPrivileges);
            free(pbOldPriv);
            break;
    }
#else    //NEC_98

    /*
     * BIOS function to return the number of PC interrupts since boot.
     */

    half_word mask;
    word low, high;
    half_word overflow, alarm;


    /*
     * Block the Alarm signal whilst we are looking at the clock timer
     */

#ifdef BSD4_2
    host_block_timer();
#endif

    switch (getAH()) {
	case 0x00:			/* Get time	*/

#ifdef NTVDM
            sas_loadw(TIMER_LOW, &low);
	    setDX(low);

            sas_loadw(TIMER_HIGH, &high);
	    setCX(high);

            sas_load(TIMER_OVFL, &overflow);
 	    setAL(overflow);
            sas_store(TIMER_OVFL, 0);   /* Always write zero after read */

#else   /* ! NTVDM */
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
	    /*
	     * First get the time from the host
	     */

	    get_host_timestamp(&low, &high, &overflow);

	    /*
	     * Use it to return the time AND overwrite the BIOS data
	     */

	    setDX(low);
	    sas_storew(TIMER_LOW, low);

	    setCX(high);
	    sas_storew(TIMER_HIGH, high);

 	    setAL(overflow);
	    sas_store(TIMER_OVFL, 0);	/* Always write zero after read	*/

#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - time of day frozen!\n");
	    }

	    setDX(1);
	    sas_storew(TIMER_LOW, 1);

	    setCX(1);
	    sas_storew(TIMER_HIGH, 1);

 	    setAL(0);
	    sas_store(TIMER_OVFL, 0);	/* Always write zero after read	*/
	}
#endif
#endif /* NTVDM */

	    break;

	case 0x01:			/* Set time	*/
	    /*
	     * Load the BIOS variables
	     */

	    sas_storew(TIMER_LOW, getDX());
	    sas_storew(TIMER_HIGH, getCX());
	    sas_store(TIMER_OVFL, 0);

#ifndef NTVDM
	    /*
	     * Also the host timestamp
	     */

	    write_host_timestamp(getDX(), getCX());
#endif
	    break;
	case 2:	/* read the real time clock	*/

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
#endif
		if( UPDATE_IN_PROGRESS )
			setCF(1);
		else
		{
			setDH( cmos_read( CMOS_SECONDS ) );
			setDL( (UCHAR)(cmos_read( CMOS_REG_B ) & 1) );	/* DSE bit	*/
			setCL( cmos_read( CMOS_MINUTES ) );
			setCH( cmos_read( CMOS_HOURS ) );
			setCF(0);
		}
#ifndef NTVDM
#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - real time clock frozen!\n");
	    }

			setDH( 1 );
			setDL( 0 );	/* DSE bit	*/
			setCL( 1 );
			setCH( 1 );
			setCF(0);
	}
#endif
#endif
		break;

	case 3:	/* Set the real time clock	*/

		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_SECONDS, getDH() );
		cmos_write( CMOS_MINUTES, getCL() );
		cmos_write( CMOS_HOURS, getCH() );
		alarm = ( cmos_read( CMOS_REG_B ) & 0x62 ) | 2;
		alarm |= (getDL() & 1);			/* only use the DSE bit	*/
		cmos_write( CMOS_REG_B, alarm );
		setCF(0);
		break;


	case 4:	/* read the date from the real time clock	*/

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
#endif
		if( UPDATE_IN_PROGRESS )
			setCF(1);
		else
		{
			setDL( cmos_read( CMOS_DAY_MONTH ) );
			setDH( cmos_read( CMOS_MONTH ) );
			setCL( cmos_read( CMOS_YEAR ) );
			setCH( cmos_read( CMOS_CENTURY ) );
			setCF(0);
		}
#ifndef NTVDM
#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - date frozen!\n");
	    }

			setDL( 1 );
			setDH( 4 );
			setCL( 91 );
			setCH( 19 );
			setCF(0);
	}
#endif
#endif
		break;

	case 5:	/* Set the date into the real time clock	*/

		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_DAY_WEEK, 0 );
		cmos_write( CMOS_DAY_MONTH, getDL() );
		cmos_write( CMOS_MONTH, getDH() );
		cmos_write( CMOS_YEAR, getCL() );
		cmos_write( CMOS_CENTURY, getCH() );
		alarm = cmos_read( CMOS_REG_B ) & 0x7f;		/* clear 'set bit'	*/
		cmos_write( CMOS_REG_B, alarm);
		setCF(0);
		break;

	case 6:	/* set the alarm	*/

		if( cmos_read(CMOS_REG_B) & 0x20 )		/* alarm already enabled?	*/
		{
			setCF(1);
#ifdef BSD4_2
			host_release_timer();
#endif
			return;
		}
		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_SEC_ALARM, getDH() );
		cmos_write( CMOS_MIN_ALARM, getCL() );
		cmos_write( CMOS_HR_ALARM, getCH() );
		inb( ICA1_PORT_1, &mask );
		mask &= 0xfe;					/* enable alarm timer int.	*/
		outb( ICA1_PORT_1, mask );
		alarm = cmos_read( CMOS_REG_B ) & 0x7f;		/* ensure set bit turned off	*/
		alarm |= 0x20;					/* turn on alarm enable		*/
		cmos_write( CMOS_REG_B, alarm );
		break;

	case 7:

		alarm = cmos_read( CMOS_REG_B );
		alarm &= 0x57;					/* turn off alarm enable	*/	
		cmos_write( CMOS_REG_B, alarm );
		break;


#ifdef XTSFD
	case 0x0A:
	{
	    word count;

	    sas_loadw(DAY_COUNT, &count);
	    setCX( count );
	    break;
	}
	case 0x0B:
  	    sas_storew(DAY_COUNT, getCX() );
	    break;
	default:
	    setCF( 1 );
#else
        default:
            ; /* Do nothing */
#endif
    }
    setAH( 0 );

#ifdef BSD4_2
    host_release_timer();
#endif
#endif   //NEC_98
}

#if defined(NEC_98)
LOCAL word bin2bcd(word i)
{
    word        bcd_h,bcd_l;

    bcd_h = i / 10;
    bcd_l = i - bcd_h * 10;
    return((bcd_h << 4) + bcd_l);
}

LOCAL word bcd2bin(half_word i)
{
    word        bcd_h,bcd_l;

    bcd_h = (half_word)(i >> 4);
    bcd_l = (half_word)(i & 0x0F);
    return(bcd_h * 10 + bcd_l);
}
#endif   //NEC_98

void time_int()
{
#ifndef NEC_98
    /*
     * NT port does everything in 16 bit int08 handler
     */
#ifndef NTVDM

    /*
     * The BIOS timer interrupt routine.
     */
    word low, high;
    half_word motor_count, motor_flags;

    /*
     * Increment the low portion
     */

    sas_loadw(TIMER_LOW, &low);
    sas_storew(TIMER_LOW, ++low);

    /*
       1.9.92 MG
       We need to actually load the timer high value before doing the 24 hour
       test below here.
    */

    sas_loadw(TIMER_HIGH, &high);

    if (low == 0)
    {
	/*
	 * Timer has wrapped so update the high count
	 */

	sas_storew(TIMER_HIGH, ++high);
    }

    /*
     * Wrap at 24 hrs
     */

    if (high == 0x0018 && low == 0x00b0)
    {
	sas_storew(TIMER_LOW,  0x0000);
	sas_storew(TIMER_HIGH, 0x0000);
	sas_store(TIMER_OVFL,  0x01);
    }

    /*
     *  Decrement motor count
     */

    sas_load(MOTOR_COUNT, &motor_count);
	if(motor_count < 4)
		motor_count = 0;
	else
		motor_count -= 4;
    sas_store(MOTOR_COUNT, motor_count);

    if (motor_count == 0)
    {
	/*
	 * Turn off motor running bits
	 */

	sas_load(MOTOR_STATUS,&motor_flags);
	motor_flags &= 0xF0;
	sas_store(MOTOR_STATUS,motor_flags);


	/*
	 * Provided FLA is not busy, then actually turn the motor off.
	 */

  	if (!fla_busy)
	    outb(DISKETTE_DOR_REG, 0x0C);
    }

    if ( getVM() ||
	 ((standard_user_timer_int_vector.all != sas_dw_at(user_timer_int_vector)) &&
          (compatibility_user_timer_int_vector.all != sas_dw_at(user_timer_int_vector))) )
        /*
	 * There is a user time routine defined - so lets call it
	 */
	{
		exec_sw_interrupt(USER_TIMER_INT_SEGMENT,
				  USER_TIMER_INT_OFFSET);
	}
#endif	/* NTVDM */
#endif   //NEC_98
}

/*
 * ============================================================================
 * Internal Functions
 * ============================================================================
 */

/*
 *  NT's sense of time in the bios data area is always
 *  kept in sync with the real systems tic count
 *  Most of the compensation to readjust tics according
 *  to the time of day stuff is not needed
 */
#ifndef NTVDM
/*
 * The routines get_host_timestamp() and write_host_timestamp() are used to
 * override the BIOS record of time, since timer events are known to be lost.
 * Internally the routines work in seconds and microseconds, using the "timeval"
 * struct provided by 4.2BSD. Since System V does not provide this, we supply a
 * version of the 4.2BSD gettimeofday() function locally, making use of the
 * System V function ticks().
 */

/*
 * Our own timestamp for calculating PC time
 */

static struct host_timeval time_stamp;

LOCAL void get_host_timestamp(low, high, overflow)
word *low, *high;
half_word *overflow;
{
    /*
     * Provide the time in PC interrupts since startup, in the
     * 32-bit value high:low. The parameter overflow is set to 1
     * if a 24-hour boundary has been passed since the last call.
     */

    struct host_timeval now, interval;
    struct host_timezone junk;		/* Not used		*/
    unsigned long ticks;		/* Total ticks elapsed	*/
    long   days;
    SAVED long last_time = 0;
    long hours, mins, secs;

    /*
     * Obtain the current time (since host boot-up)
     */

    host_gettimeofday(&now, &junk);

    /*
     * Calculate how long has passed since the time stamp
     */

    interval.tv_sec  = now.tv_sec  - time_stamp.tv_sec;
    interval.tv_usec = now.tv_usec - time_stamp.tv_usec;

    /*
     * Handle the "borrow" correction
     */

    if (interval.tv_sec > 0 && interval.tv_usec < 0)
    {
	interval.tv_usec += 1000000L;
	interval.tv_sec  -= 1;
    };

    /*
	 * TMM 8/1/92:
	 * -----------
	 *
	 * If someone changes the date forwards by >= 24 hours then we should set
	 * the overflow flag and ensure that we don't return an interval greater
	 * than 24 hours. If the date has changed by >= 48 hours then we will have
	 * lost a day. So we put up a panel to tell the user.
	 *
	 * If some one has set the date backwards and the interval has gone
	 * negative then all we can do is put up an error panel informing
	 * the user and ensure that we don't set the interval to a negative
	 * value.
	 *
	 * Notes:
	 *
	 * 1. Setting the overflow flag causes DOS to add a day onto the current
	 *    date.
	 *
	 * 2. Setting the interval to a value greater than 24 hours causes DOS
	 *    to print a "Divide Overflow" error.
	 *
	 * 3. Setting the interval to a -ve value causes DOS to go into an
	 *    infinite loop printing "Divide Overflow".
     */

	days = interval.tv_sec / (24 * 60 * 60);

	if (days >= 1)
    {
		/*
		 * Someone has set the clock forwards, or we have been frozen for a
		 * couple of days. Ensure that the interval is not more than 24 hours,
		 * adjust the time_stamp to take care of the lost days.
		 */

		interval.tv_sec   %= 24 * 60 * 60;
		time_stamp.tv_sec += days * (24 * 60 * 60);
		
		if (days > 1)
		{
			host_error (EG_DATE_FWD, ERR_CONT | ERR_RESET, "");
		}

		*overflow = 1;
    }
	else if (interval.tv_sec < 0)
	{
		/*
		 * Somebody has set the clock backwards, all we can do is maintain
		 * the same time that we had before the clock went back.
		 */

		time_stamp.tv_sec -= (last_time - now.tv_sec );
		interval.tv_sec = now.tv_sec - time_stamp.tv_sec;
	
		*overflow = 0;
		
		host_error (EG_DATE_BACK, ERR_CONT | ERR_RESET, "");
	}
    else
		*overflow = 0;

    /*
     * Convert seconds to hours/minutes/seconds
     */

    hours = interval.tv_sec / (60L*60L);        /* Hours */
    interval.tv_sec %= (60L*60L);

    mins = interval.tv_sec / 60L;               /* Minutes */
    secs = interval.tv_sec % 60L;               /* Seconds */

    /*
     * Now convert the interval into PC ticks
     * One tick lasts 54925 microseconds.
     */


    ticks = hours * TICKS_PER_HOUR + mins * TICKS_PER_MIN +
            secs * TICKS_PER_SEC + interval.tv_usec/54925 ;

    /*
     * Split the value into two 16-bit quantities and return
     */

    *low  = ticks & 0xffff;
    *high = ticks >> 16;
}


LOCAL void write_host_timestamp(low, high)
int low, high;
{
    /*
     * Update our timestamp so that subsequent calls of get_host_timestamp
     * return the correct value. A call of get_host_timestamp() made immediately
     * after this call must return the values set here, so set the timestamp
     * to be the current time less the value set here.
     */

    struct host_timeval now, interval;
    struct host_timezone junk;          /* Not used             */
    long lowms;

    /*
     * Get the current time.
     */

    host_gettimeofday(&now, &junk);


    interval.tv_sec = high * 3599 + high/2;     /* high ticks to seconds */

    /*
     * The multiply below can overflow, which has the interesting effect
     * of making Softpc 1 hr 12 mins 40 secs (4300 secs, or 2^32 us) slow
     * if booted in the last third of every hour. So compensate by
     * letting the overflow occur and correcting interval by 4300 secs.
     */

    lowms =  (IS32) (low & 0xffff) * 54925 + (low & 0xffff)/2;
    if (low > 39098)
	interval.tv_sec += 4300;

    interval.tv_sec += lowms / 1000000;
    interval.tv_usec = lowms % 1000000;

    /*
     * The timestamp is the current time less this interval
     */

    time_stamp.tv_sec  = now.tv_sec  - interval.tv_sec;
    time_stamp.tv_usec = now.tv_usec - interval.tv_usec;

    /*
     * Handle the "borrow" correction, including negative timestamps
     */

    if (time_stamp.tv_sec > 0 && time_stamp.tv_usec < 0)
    {
        time_stamp.tv_usec += 1000000L;
        time_stamp.tv_sec  -= 1;
    }
    else
    if (time_stamp.tv_sec < 0 && time_stamp.tv_usec > 0)
    {
        time_stamp.tv_usec -= 1000000L;
        time_stamp.tv_sec  += 1;
    }
}


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif


LOCAL void get_host_time( h, m, s )
int *h, *m, *s; /* hours, minutes and secs */
{
    struct host_tm *tp;
    time_t SecsSince1970;

    SecsSince1970 = host_time(NULL);
    tp = host_localtime(&SecsSince1970);
    *h = tp->tm_hour;
    *m = tp->tm_min;
    *s = tp->tm_sec;
}

#ifndef NEC_98
/*
** Take a normal time in hours, minutes and seconds then
** transmutate it into PC ticks since the beginning of the day.
*/
LOCAL void TimeToTicks( hour, minutes, sec, low, hi )
int hour, minutes, sec;	/* inputs */
word *low, *hi;		/* outputs */
{
    unsigned long ticks;                /* Total ticks elapsed  */

    /*
     * Calculate ticks to date
     */


    ticks = hour * TICKS_PER_HOUR + minutes * TICKS_PER_MIN +
            sec * TICKS_PER_SEC;

    /*
     * Split the value into two 16-bit quantities and return
     */

    *low  = ticks & 0xffff;
    *hi = ticks >> 16;
}
#endif   //NEC_98

#endif  /* ifndef NTVDM */


void time_of_day_init()
{
#ifndef NEC_98
#ifndef NTVDM
    int hour, minutes, sec;		/* Current host time */
    word low, hi;		/* Host time in PC ticks */

    /*
     * Initialise the clock timer.
     */

    get_host_time( &hour, &minutes, &sec );	/* get the time from the host */

    TimeToTicks( hour, minutes, sec, &low, &hi );	/* convert to PC time */

    sas_storew(TIMER_LOW, low  );
    sas_storew(TIMER_HIGH, hi );
    sas_store(TIMER_OVFL,0x01);

    /*
     * Initialise the host time stamp
     */

    write_host_timestamp( low, hi );

    /*
     * Build the standard IVT entry for the user timer interrupt(s)
     */

	compatibility_user_timer_int_vector.all = ((double_word)ADDR_COMPATIBILITY_SEGMENT << 16) + ADDR_COMPATIBILITY_OFFSET;
	standard_user_timer_int_vector.all = ((double_word)DUMMY_INT_SEGMENT << 16) + DUMMY_INT_OFFSET;
	
    user_timer_int_vector = BIOS_USER_TIMER_INT * 4;

#endif  /* NTVDM */
#endif   //NEC_98
}



#ifndef NEC_98
#ifdef NTVDM

/*
 *  NTVDM: the rtc is setup so that the UIP bit is set on a cmos
 *  port read if the cmos ports haven't been touched for at least
 *  1 second. The IBM pc bios routine for accessing the clock
 *  polls RegA for UIP bit in a tight loop 600h times before
 *  failing the call. This means that MOST of the time the int1ah
 *  rtc fns almost never fail! To mimic this behaviour we poll
 *  the port until success, since we know that our rtc will clear
 *  UIP bit very quickly.
 */
BOOL UpDateInProgress(void)
{

   while (cmos_read(CMOS_REG_A) & 0x80) {
       Sleep(0);  // give other threads a chance to work
       }

   return FALSE;

}
#endif
#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\cmos.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * Name:		cmos.c
 *
 * Sccs ID:		@(#)cmos.c	1.38 07/11/95
 *
 * Purpose:		Unknown
 * 
 * (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 * 
 */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_CMOS.seg"
#endif


/*
 * O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include StringH
#include TimeH
#include FCntlH

/*
 * SoftPC include files
 */

#include "xt.h"
#include "cmos.h"
#include "cmosbios.h"
#include "ios.h"
#include "spcfile.h"
#include "error.h"
#include "config.h"
#include "timeval.h"
#include "ica.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gfi.h"
#include "sas.h"
#include "debug.h"
#include "quick_ev.h"


/*
 * 
 * ============================================================================
 * Global data
 * ===========================================================================
 * =
 */
static boolean  data_mode_yes;
static          half_word(*bin2bcd) ();
static          half_word(*_24to12) IPT1(half_word, x);
static int      (*bcd2bin) IPT1(int, x);
static int      (*_12to24) ();
static boolean  twenty4_hour_clock;

#if defined(NTVDM) || defined(macintosh)
static boolean  cmos_has_changed = FALSE;
static boolean  cmos_read_in = FALSE;
#endif	/* defined(NTVDM) || defined(macintosh) */

static long     filesize;
static int      cmos_index;
static boolean  reset_alarm = FALSE;
static time_t	user_time = 0;	/* difference between the host and the CMOS
				 * time */
static struct host_tm *ht;	/* The host time */
static IU32 rtc_period_mSeconds = 0;

#if defined(NTVDM) || defined(macintosh)
static half_word cmos[CMOS_SIZE] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* Timing info + alarms */
	REG_A_INIT,
	REG_B_INIT,
	REG_C_INIT,
	REG_D_INIT,
	DIAG_INIT,
	SHUT_INIT,
	FLOP_INIT,
	CMOS_RESVD,
	DISK_INIT,
	CMOS_RESVD,
	EQUIP_INIT,
	BM_LO_INIT, BM_HI_INIT,
	EXP_LO, EXP_HI,
	DISK_EXTEND, DISK2_EXTEND,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1b - 0x1e */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1f - 0x22 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x23 - 0x26 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x27 - 0x2a */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x2b - 0x2d */
	CHK_HI_INIT, CHK_LO_INIT,
	EXT_LO_INIT, EXT_HI_INIT,
	CENT_INIT,
	INFO_128_INIT,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x34 - 0x37 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x38 - 0x3b */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x3c - 0x3f */
};
#else	/* defined(NTVDM) || defined(macintosh) */
static half_word cmos[CMOS_SIZE];
#endif	/* defined(NTVDM) || defined(macintosh) */

static half_word *cmos_register = &cmos[CMOS_SHUT_DOWN];

#ifdef NTVDM
unsigned long   dwTickCount,dwAccumulativeMilSec;
extern unsigned long GetTickCount (VOID);
#endif

#ifdef TEST_HARNESS
unsigned long   io_verbose = 0;
#endif

int             rtc_int_enabled;


/*
 * 
 * ============================================================================
 * Static data and defines
 * ===========================================================================
 * =
 */

/*
 * 
 * ============================================================================
 * Internal functions
 * ===========================================================================
 * =
 */

LOCAL q_ev_handle rtc_periodic_event_handle = (q_ev_handle)0;

LOCAL void rtc_periodic_event IFN1(long, parm)
{
	if (cmos[CMOS_REG_B] & PIE)
	{
		cmos[CMOS_REG_C] |= (C_IRQF | C_PF);
		note_trace2(CMOS_VERBOSE, "INTERRUPT: PIE regC=%02x uS=%d",
			    cmos[CMOS_REG_C], rtc_period_mSeconds);
		ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
		rtc_periodic_event_handle = add_q_event_t(rtc_periodic_event,
							  rtc_period_mSeconds,
							  0);
	}
	else
	{
		rtc_periodic_event_handle = (q_ev_handle)0;
	}
}

LOCAL void change_pie IFN1(IBOOL, newPIE)
{
	if (newPIE && (rtc_period_mSeconds != 0))
	{
		/* Turning on periodic interrupts */

		note_trace1(CMOS_VERBOSE, "Starting periodic interrupts every %d uS", rtc_period_mSeconds);
		rtc_periodic_event_handle = add_q_event_t(rtc_periodic_event,
							  rtc_period_mSeconds,
							  0);
	}
	else
	{
		/* Turning off periodic interrupts */
		note_trace0(CMOS_VERBOSE, "Stopping periodic interrupts");
		delete_q_event( rtc_periodic_event_handle );
	}
}

LOCAL void enable_nmi IFN0()
{
}

LOCAL void disable_nmi IFN0()
{
}

LOCAL void do_checksum IFN0()
{
	int             i;
	word            checksum = 0;

	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	cmos[CMOS_CKSUM_LO] = checksum & 0xff;
	cmos[CMOS_CKSUM_HI] = checksum >> 8;
}

LOCAL half_word yes_bin2bcd IFN1(int, x)
{
	/* converts binary x to bcd */
	half_word       tens, units;

	tens = x / 10;
	units = x - tens * 10;
	return ((tens << 4) + units);
}

LOCAL half_word no_bin2bcd IFN1(int, x)
{
	return ((half_word) x);
}

LOCAL int yes_bcd2bin IFN1(int, x)
{
	/* converts x in bcd format to binary */
	return ((int) ((x & 0x0f) + (x >> 4) * 10));
}

LOCAL int no_bcd2bin IFN1(int, x)
{
	return ((int) (half_word) x);
}

LOCAL int no_12to24 IFN1(int, x)
{
	return (x);
}

LOCAL half_word no_24to12 IFN1(half_word, x)
{
	return (x);
}

LOCAL half_word yes_24to12 IFN1(half_word, x)
{
	/* converts binary or bcd x from 24 to 12 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x > y)
		x = (x - y) | 0x80;
	else if (x == 0)
		x = y | 0x80;
	return (x);
}

LOCAL int yes_12to24 IFN1(int, x)
{
	/* converts binary or bcd x from 12 to 24 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x == (0x80 + y))
		return (0);
	else if (x & 0x80)
		return ((x & 0x7f) + y);
	else
		return (x);
}

LOCAL void rtc_alarm IFN1(long, param)
{
        UNUSED (param);

	note_trace0(CMOS_VERBOSE, "rtc_alarm() gone off");

	cmos[CMOS_REG_C] |= C_AF;

	if (cmos[CMOS_REG_B] & AIE)
	{
		note_trace0(CMOS_VERBOSE, "rtc_alarm() setting IRQF due to AIE");
		cmos[CMOS_REG_C] |= C_IRQF;
		if (rtc_int_enabled)
		{
			note_trace1(CMOS_VERBOSE, "INTERRUPT: AIE regC=%02x", cmos[CMOS_REG_C]);
			ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
		}
	}

	reset_alarm = TRUE;
}

LOCAL void set_alarm IFN0()
{
#ifndef	JOKER

	long            numsecs;
	long            alarm_secs, now_secs;
	long            num_pc_ticks;
	static word     handle;

	if (cmos[CMOS_HR_ALARM] & DONT_CARE)
	{
		if (cmos[CMOS_MIN_ALARM] & DONT_CARE)
		{
			if (cmos[CMOS_SEC_ALARM] & DONT_CARE)
				numsecs = 1;
			else
				numsecs = 60;
		} else
			numsecs = 3600;
	} else
	{
		alarm_secs = (*bcd2bin) (cmos[CMOS_SEC_ALARM]) +
			((*bcd2bin) (cmos[CMOS_MIN_ALARM]) * 60) +
			((*_12to24) ((*bcd2bin) (cmos[CMOS_HR_ALARM])) * 3600);
		now_secs = ht->tm_sec + 60 * ht->tm_min + 3600 * ht->tm_hour;
		numsecs = alarm_secs - now_secs;
		if (numsecs < 0)
			numsecs += 24 * 3600;
	}

	/* As close as we can to 18.2 Hz */
	num_pc_ticks = 18 * numsecs;

	note_trace1(CMOS_VERBOSE, "set_alarm() requesting alarm in %d ticks", num_pc_ticks);
	if (handle > 0)
		delete_tic_event(handle);
	handle = add_tic_event(rtc_alarm, num_pc_ticks, 0);

#endif	/* JOKER */

}

LOCAL int verify_equip_byte IFN1(half_word *, equip)
{
	static half_word display_mask[] = 
	{
		MDA_PRINTER,	CGA_80_COLUMN,	CGA_80_COLUMN,
		OWN_BIOS,	MDA_PRINTER
	};
	int equip_err;
	int num_flops;
	SHORT adapter;

	/* Check the Equipment Byte */
	*equip = 0;
	adapter = (ULONG) config_inquire(C_GFX_ADAPTER, NULL);
	if(adapter != -1)
		*equip |= display_mask[adapter];

	if( host_runtime_inquire(C_NPX_ENABLED) )
		*equip |= CO_PROCESSOR_PRESENT;

#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		num_flops =
			(*(CHAR *) config_inquire(C_SLAVEPC_DEVICE, NULL))
			? 1:0;
	}
	else
#endif /* SLAVEPC */
	{
		num_flops  =
			(*(CHAR *) config_inquire(C_FLOPPY_A_DEVICE, NULL))
			? 1:0;
#ifdef FLOPPY_B
		num_flops +=
			(*(CHAR *) config_inquire(C_FLOPPY_B_DEVICE, NULL))
			? 1:0;
#endif
	}

	if (num_flops == 2)
		*equip |= TWO_DRIVES;
	if (num_flops)
		*equip |= DISKETTE_PRESENT;

	equip_err = (*equip ^ cmos[CMOS_EQUIP]);
	return equip_err;
}

/*
 * =========================================================================
 *  External functions
 * =========================================================================
 */

GLOBAL void cmos_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NTVDM
IMPORT ADAPTER_STATE adapter_state[2];
#else
IMPORT VDMVIRTUALICA VirtualIca[];
#define ADAPTER_STATE VDMVIRTUALICA
#define adapter_state VirtualIca
#endif /* !NTVDM */

#ifdef NTVDM
	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port==0x78 )
	{
		*value = 0;
		return;
	}
#endif
	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	if (port == CMOS_DATA)
	{
		*value = *cmos_register;

		/*
		 * We clear the UIP bit every time we read register A, (whether
		 * it was set or not) as previously we had it set for a whole
		 * timer tick, which could fool a DOS retry.
		 */
		 
		if (cmos_index == CMOS_REG_A) {
			cmos[CMOS_REG_A] &= ~UIP;
		
		} else 	if (cmos_index == CMOS_REG_C) {
			/* 
			 * Reading Register C clears it.
		 	 */
			*cmos_register = C_CLEAR;
		}
		else if (cmos_index < CMOS_REG_A)
		{
#ifndef NTVDM
#ifndef PROD
			if (host_getenv("TIME_OF_DAY_FRIG") == NULL)
			{
#endif /* !PROD */
#endif /* !NTVDM */

				switch (cmos_index)
				{
				case CMOS_SECONDS:
					*cmos_register = (*bin2bcd) (ht->tm_sec);
					break;
				case CMOS_MINUTES:
					*cmos_register = (*bin2bcd) (ht->tm_min);
					break;
				case CMOS_HOURS:
					*cmos_register = (*_24to12) ((*bin2bcd) (ht->tm_hour));
					break;
				case CMOS_DAY_WEEK:
					/* Sunday = 1 on RTC, 0 in structure */
					*cmos_register = (*bin2bcd) (ht->tm_wday + 1);
					break;
				case CMOS_DAY_MONTH:
					*cmos_register = (*bin2bcd) (ht->tm_mday);
					break;
				case CMOS_MONTH:
					/* [1-12] on RTC, [0-11] in structure */
					*cmos_register = (*bin2bcd) (ht->tm_mon + 1);
					break;
				case CMOS_YEAR:
					*cmos_register = (*bin2bcd) (ht->tm_year);
					break;
				default:
					break;
				}
#ifndef NTVDM
#ifndef PROD
			} else
			{
				static int      first = 1;

				if (first)
				{
					first = 0;
					printf("FRIG ALERT!!!! - cmos clock frozen!");
				}
				*cmos_register = 1;
			}
#endif /* !PROD */
#endif /* !NTVDM */

			*value = *cmos_register;
		}
	}
	note_trace2(CMOS_VERBOSE, "cmos_inb() - port %x, returning val %x",
		    port, *value);
}


GLOBAL void cmos_outb IFN2(io_addr, port, half_word, value)
{
	static IU32 pirUsec[] = {
		     0,
		  3906,
		  7812,
		   122,
		   244,
		   488,
		   976,
		  1953,
		  3906,
		  7812,
		 15625,
		 31250,
		 62500,
		125000,
		250000,
		500000
	};

#ifdef NTVDM
	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port == 0x78 )
	    return;
#endif /* NTVDM */

	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	note_trace2(CMOS_VERBOSE, "cmos_outb() - port %x, val %x", port, value);

	if (port == CMOS_PORT)
	{
		if (value & NMI_DISABLE)
			disable_nmi();
		else
			enable_nmi();

		cmos_register = &cmos[cmos_index = (value & CMOS_ADDR_MASK)];
	} else if (port == CMOS_DATA)
	{
		switch (cmos_index)
		{
		case CMOS_REG_C:
		case CMOS_REG_D:
			/* These two registers are read only */
			break;
		case CMOS_REG_B:
			if (value & DM)
			{
				if (data_mode_yes)
				{
					bin2bcd = no_bin2bcd;
					bcd2bin = no_bcd2bin;
					data_mode_yes = FALSE;
				}
			} else
			{
				if (!data_mode_yes)
				{
					bin2bcd = yes_bin2bcd;
					bcd2bin = yes_bcd2bin;
					data_mode_yes = TRUE;
				}
			}
			if (value & _24_HR)
			{
				if (!twenty4_hour_clock)
				{
					_24to12 = no_24to12;
					_12to24 = no_12to24;
					twenty4_hour_clock = TRUE;
				}
			} else
			{
				if (twenty4_hour_clock)
				{
					_24to12 = yes_24to12;
					_12to24 = yes_12to24;
					twenty4_hour_clock = FALSE;
				}
			}

			if (*cmos_register != value)
			{
#if defined(NTVDM) || defined(macintosh)
				cmos_has_changed = TRUE;
#endif
				if ((*cmos_register ^ value) & PIE)
				{
					change_pie((value & PIE) != 0);
				}
				*cmos_register = value;
			}
			break;
		case CMOS_REG_A:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
			rtc_period_mSeconds = pirUsec[*cmos_register & (RS3 | RS2 | RS1 | RS0)];
			if ((*cmos_register & 0x70) != 0x20)
			{
				/* Internal divider is set to non-standard rate. */
				note_trace1(CMOS_VERBOSE,
					    "Cmos unsuported divider rate 0x%02x ignored",
					    *cmos_register & 0x70);
			}
#if defined(NTVDM) || defined(macintosh)
			cmos_has_changed = TRUE;
#endif
			break;
		case CMOS_SECONDS:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
			user_time += (*bcd2bin) (value) - ht->tm_sec;
			reset_alarm = TRUE;
			break;
		case CMOS_MINUTES:
			user_time += ((*bcd2bin) (value) - ht->tm_min) * 60;
			*cmos_register = value;
			reset_alarm = TRUE;
			break;
		case CMOS_HOURS:
			user_time += ((*_12to24) ((*bcd2bin) (value)) - ht->tm_hour) * 60 * 60;
			*cmos_register = value;
			reset_alarm = TRUE;
			break;
		case CMOS_DAY_WEEK:
			/* this being changed doesn't change the time */
			*cmos_register = value;
			break;
		case CMOS_DAY_MONTH:
			user_time += ((*bcd2bin) (value) - ht->tm_mday) * 60 * 60 * 24;
			*cmos_register = value;
			break;
		case CMOS_MONTH:
			user_time += ((*bcd2bin) (value) - 1 - ht->tm_mon) * 60 * 60 * 24 * 30;
			*cmos_register = value;
			break;
		case CMOS_YEAR:
			user_time += ((*bcd2bin) (value) - ht->tm_year) * 60 * 60 * 24 * 30 * 12;
			*cmos_register = value;
			break;
		case CMOS_SEC_ALARM:
		case CMOS_MIN_ALARM:
		case CMOS_HR_ALARM:
			reset_alarm = TRUE;
			/* falling through */
		default:
			*cmos_register = value;
#if defined(NTVDM) || defined(macintosh)
			cmos_has_changed = TRUE;
#endif
			break;
		}
	} else
	{
		note_trace2(CMOS_VERBOSE,
			    "cmos_outb() - Value %x to unsupported port %x", value, port);
	}
}

static int      cmos_count = 0;

GLOBAL void rtc_tick IFN0()
{
	switch (cmos_count)
	{
	case 0:
		if (cmos[CMOS_REG_B] & UIE)
		{
			cmos[CMOS_REG_C] |= C_IRQF;
			note_trace0(CMOS_VERBOSE, "rtc_tick() setting IRQF due to UIE");
			if (rtc_int_enabled)
			{
				note_trace1(CMOS_VERBOSE, "INTERRUPT: UIE regC=%02x", cmos[CMOS_REG_C]);
				ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
			}
		}

		/*
		 * Set the C_UF and UIP bits until the next timer tick.
		 * We also clear the UIP bit if register A is read, so that
		 * it doesn't stay on to long (done elsewhere).
		 */
		 
		cmos[CMOS_REG_C] ^= C_UF;
#ifndef NTVDM
		cmos[CMOS_REG_A] |= UIP;	/* Set the bit */
#endif
		break;

	case 1:
		cmos[CMOS_REG_C] ^= C_UF;
#ifndef NTVDM
		cmos[CMOS_REG_A] &= ~UIP;	/* Clear it again */
#endif
		break;

	case 17:
		/* update the time at some suitable point in cycle */
		if (cmos[CMOS_REG_B] & SET)
		{
			/* User is updating user_time */
		} else
		{
#ifdef NTVDM
        /* sudeepb 08-Jul-1993 Old code assumed rtc-tick will be called */
        /* 20 times a second. This is not true under NTVDM. So we have  */
        /* to keep track of time seperately and add to the cmos time.   */
unsigned long dwTemp;
                    dwTemp =  GetTickCount();
                    dwAccumulativeMilSec += (dwTemp - dwTickCount);
                    dwTickCount = dwTemp;
                    ht->tm_sec = (ULONG) ht->tm_sec +
                                        (dwAccumulativeMilSec / 1000);
                    dwAccumulativeMilSec = dwAccumulativeMilSec % 1000;
                    if (ht->tm_sec >= 60)
                    {
                            ht->tm_min += (ht->tm_sec / 60);
                            ht->tm_sec = (ht->tm_sec % 60);
                            if (ht->tm_min >= 60)
                            {
                                    ht->tm_hour++;
                                    ht->tm_min -= 60;
                                    if (ht->tm_hour == 25)
                                    {
                                            ht->tm_hour = 0;
                                            ht->tm_mday++;
                                            /* Kop out at this point */
                                    }
                            }
                    }
#else /* NTVDM */
			/* simple update - add 1 second to time */
			ht->tm_sec++;
			if (ht->tm_sec == 60)
			{
				ht->tm_sec = 0;
				ht->tm_min++;
				if (ht->tm_min == 60)
				{
					ht->tm_min = 0;
					ht->tm_hour++;
					if (ht->tm_hour == 25)
					{
						ht->tm_hour = 0;
						ht->tm_mday++;
						/* Kop out at this point */
					}
				}
			}
#endif /* NTVDM */
		}
		break;

	default:
		break;
	}

	/* As close as we can to 18.2 Hz */
	cmos_count = (++cmos_count) % 18;

	if ((rtc_periodic_event_handle == (q_ev_handle)0)
	    && ((cmos[CMOS_REG_B] & PIE) == 0))
	{
		/* There is no period interrupt being generated by quick event,
		 * and periodic interrupts are not enabled, so waggle the status
		 * bit in case something is polling.
		 */
		cmos[CMOS_REG_C] ^= C_PF;
	}
	if (reset_alarm)
	{
		reset_alarm = FALSE;
		set_alarm();
	}
}

GLOBAL void  cmos_equip_update IFN0()
{
	half_word       equip;

	if (verify_equip_byte(&equip))
	{
		note_trace0(CMOS_VERBOSE, "updating the equip byte silently");
		cmos[CMOS_EQUIP] = equip;
		/* correct the checksum */
		do_checksum();
	}
}

/*
 * * General function to change the specified cmos byte to the specified
 * value
 */
GLOBAL int cmos_write_byte IFN2(int, cmos_byte, half_word, new_value)
{
	note_trace2(CMOS_VERBOSE, "cmos_write_byte() byte=%x value=%x",
		    cmos_byte, new_value);
	if (cmos_byte >= 0 && cmos_byte <= 64)
	{
		cmos[cmos_byte] = new_value;
		do_checksum();
		return (0);
	} else
	{
		always_trace2("ERROR: cmos write request: byte=%x value=%x",
			      cmos_byte, new_value);
		return (1);
	}
}
/*
 * * General fuunction to read specified cmos byte.
 */
GLOBAL int cmos_read_byte IFN2(int, cmos_byte, half_word *, value)
{
	if (cmos_byte >= 0 && cmos_byte <= 64)
	{
		*value = cmos[cmos_byte];
		note_trace2(CMOS_VERBOSE, "cmos_read_byte() byte=%x value=%x",
			    cmos_byte, value);
		return (0);
	} else
	{
		always_trace1("ERROR: cmos read request: byte=%x", cmos_byte);
		return (1);
	}
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NTVDM) || defined(macintosh)
LOCAL void read_cmos IFN0() 
{
	filesize = host_read_resource(CMOS_REZ_ID, CMOS_FILE_NAME,
				      cmos, sizeof(cmos), SILENT);

	/* Set a flag to say we've tried to read the CMOS file */
	cmos_read_in = TRUE;
}
#endif	/* defined(NTVDM) || defined(macintosh) */

#if defined(NTVDM) || defined(macintosh)
LOCAL void write_cmos IFN0()
{
	/* terminate might be called before reset */
	if (cmos_read_in && cmos_has_changed)
	{
		host_write_resource(CMOS_REZ_ID, CMOS_FILE_NAME,
				    cmos, sizeof(cmos));
	}
}
#endif	/* defined(NTVDM) || defined(macintosh) */

LOCAL void cmos_error IFN6(int, err, half_word, diag, half_word, equip,
	int, equip_err, half_word, floppy, half_word, disk)
{
	char            err_string[256];

	if (err & BAD_SHUT_DOWN)
	{
		strcpy(err_string, "shut ");
		note_trace0(CMOS_VERBOSE, "eek! someone's furtling with the shutdown byte");
	} else
		strcpy(err_string, "");

	if (err & BAD_REG_D)
	{
		strcat(err_string, "power ");
		note_trace0(CMOS_VERBOSE, " The battery is dead - this shouldn't happen!");
	}
	if (err & BAD_DIAG)
	{
		strcat(err_string, "diag ");
		if (diag & BAD_BAT)
			note_trace0(CMOS_VERBOSE, "bad battery");
		if (diag & BAD_CONFIG)
			note_trace0(CMOS_VERBOSE, "bad config");
		if (diag & BAD_CKSUM)
			note_trace0(CMOS_VERBOSE, "bad chksum");
		if (diag & W_MEM_SIZE)
			note_trace0(CMOS_VERBOSE, "memory size != configuration");
		if (diag & HF_FAIL)
			note_trace0(CMOS_VERBOSE, "fixed disk failure on init");
		if (diag & CMOS_CLK_FAIL)
			note_trace0(CMOS_VERBOSE, "cmos clock not updating or invalid");
	}
	if (err & BAD_EQUIP)
	{
		strcat(err_string, "equip ");

		if (equip_err)
		{
			if (equip_err & DRIVE_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect diskette - resetting");
			if (equip_err & DISPLAY_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect display - resetting");
			if (equip_err & NPX_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect npx - resetting CMOS");
			if (equip_err & RESVD_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect reserved bytes - resetting");
		}
	}
	if (err & BAD_FLOPPY)
	{
		strcat(err_string, "flop ");
		note_trace0(CMOS_VERBOSE, "incorrect diskette type - resetting");
	}
	if (err & BAD_DISK)
	{
		strcat(err_string, "disk ");
		note_trace0(CMOS_VERBOSE, "incorrect disk type - resetting");
	}
	if (err & BAD_BMS)
	{
		strcat(err_string, "bms ");
		note_trace0(CMOS_VERBOSE, "bad base memory - resetting");
	}
	if (err & BAD_XMS)
	{
		strcat(err_string, "extended memory ");
		note_trace0(CMOS_VERBOSE, "bad extended memory CMOS entry - resetting");
	}
	if (err & BAD_CHECKSUM)
	{
		strcat(err_string, "cksum ");
		note_trace0(CMOS_VERBOSE, "bad Checksum - resetting");
	}
#ifndef PROD
	if (!filesize)
		always_trace1("Incorrect CMOS entries %s", err_string);
#endif

	if (err & BAD_SHUT_DOWN)
		cmos[CMOS_SHUT_DOWN] = SHUT_INIT;
	if (err & BAD_REG_D)
		cmos[CMOS_REG_D] = REG_D_INIT;
	if (err & BAD_DIAG)
		cmos[CMOS_DIAG] = DIAG_INIT;
	if (err & BAD_EQUIP)
		cmos[CMOS_EQUIP] = equip;
	if (err & BAD_FLOPPY)
		cmos[CMOS_DISKETTE] = floppy;
	if (err & BAD_DISK)
		cmos[CMOS_DISK] = disk;
	if (err & BAD_BMS)
	{
		cmos[CMOS_B_M_S_LO] = BM_LO_INIT;
		cmos[CMOS_B_M_S_HI] = BM_HI_INIT;
	}
	if (err & BAD_XMS)
	{
		cmos[CMOS_E_M_S_LO] =
			((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff;
		cmos[CMOS_E_M_S_HI] =
			((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff;
	}
	/* Reset the Checksum if there is any error */
	if (err)
	{
		/* Do the Checksum */
		do_checksum();
	}
}

GLOBAL void cmos_init IFN0()
{
#ifndef TEST_HARNESS
	cmos_io_attach();
#endif

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL)
#endif	/* PROD */
#endif	/* NTVDM */
		rtc_int_enabled = TRUE;
#ifndef NTVDM
#ifndef PROD
	else
		rtc_int_enabled = FALSE;
#endif	/* PROD */
#endif	/* NTVDM */

	rtc_init();
}

#if defined(NTVDM) || defined(macintosh)
GLOBAL void cmos_pickup IFN0()
{
	read_cmos();
}
#endif	/* defined(NTVDM) || defined(macintosh) */

GLOBAL void cmos_io_attach IFN0()
{
	io_addr         i;

	io_define_inb(CMOS_ADAPTOR, cmos_inb);
	io_define_outb(CMOS_ADAPTOR, cmos_outb);

	for (i = CMOS_PORT_START; i <= CMOS_PORT_END; i++)
		io_connect_port(i, CMOS_ADAPTOR, IO_READ_WRITE);
}

GLOBAL void cmos_post IFN0()
{
	/*
	 * The IBM POST checks the current settings in the CMOS with the
	 * equipment determined by writing to the hardware. Any discrepencies
	 * cause a bad config bit to be set and the user is then requested to
	 * run the Setup utility. Here we check the CMOS against the current
	 * settings in the config structure. If there is a discrepency we
	 * correct the CMOS silently.
	 */
	int             cmos_err, equip_err;
	half_word       diag, equip, floppy, disk;
	word            checksum = 0;
	int             i;


	cmos_err = 0;

	/* Check the Shutdown Byte */
	if (cmos[CMOS_SHUT_DOWN])
		cmos_err |= BAD_SHUT_DOWN;

	/* Check The Power */
	if (!(cmos[CMOS_REG_D] & VRT))
		cmos_err |= BAD_REG_D;

	/* Check The Diagnostic Status Byte */
	if (diag = cmos[CMOS_DIAG])
		cmos_err |= BAD_DIAG;

	/* Check the Equipment Byte */
	if (equip_err = verify_equip_byte(&equip))
		cmos_err |= BAD_EQUIP;

	/* Check the Floppy Byte */
	floppy = gfi_drive_type(1) | (gfi_drive_type(0) << 4);
	if (floppy != cmos[CMOS_DISKETTE])
		cmos_err |= BAD_FLOPPY;

	/* Check the Fixed Disk Type */
	 disk = 0x30;         /* Drive C type always 3 - then <<4 */
	 /* check whether D drive exists */
	 if ( *((CHAR *) config_inquire(C_HARD_DISK2_NAME, NULL)))
		 disk = 0x34;         /* 3 << 4 | 4 */
	if (disk != cmos[CMOS_DISK])
		cmos_err |= BAD_DISK;

	/* Check the Base Memory */
	if ((cmos[CMOS_B_M_S_LO] != BM_LO_INIT) || (cmos[CMOS_B_M_S_HI] != BM_HI_INIT))
		cmos_err |= BAD_BMS;

	/* Check the extended memory */
	if ((cmos[CMOS_E_M_S_LO] !=
	     ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff) ||
	    (cmos[CMOS_E_M_S_HI] !=
	     ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff))
		cmos_err |= BAD_XMS;

	/* Ignore the Contents of the Drive C and Drive D extended bytes */

	/* Do the Checksum */
	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	/* If the CMOS is OK test the checksum */
	/* If not, we will have to change it anyway */
	if (!cmos_err)
	{
		if ((checksum & 0xff) != cmos[CMOS_CKSUM_LO])
		{
			cmos_err |= BAD_CHECKSUM;
		}
		if ((checksum >> 8) != cmos[CMOS_CKSUM_HI])
		{
			cmos_err |= BAD_CHECKSUM;
		}
	}
	if (cmos_err)
		cmos_error(cmos_err, diag, equip, equip_err, floppy, disk);

	cmos[CMOS_REG_A] = REG_A_INIT;

#if	!defined(JOKER) && !defined(NTVDM)
	set_tod();
#endif	/* JOKER */

	/* Check the Extended Memory */
	cmos[CMOS_U_M_S_LO] = ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff;
	cmos[CMOS_U_M_S_HI] = ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff;

	/* Set up the default cmos location */
	cmos_register = &cmos[cmos_index = CMOS_SHUT_DOWN];

#if defined(NTVDM) || defined(macintosh)
	cmos_has_changed = FALSE;
#endif
}

GLOBAL void cmos_update IFN0()
{
#if defined(NTVDM) || defined(macintosh)
#ifndef PROD
	int             i;
#endif				/* nPROD */
#else	/* defined(NTVDM) || defined(macintosh) */
	ConfigValues *value;
	char *strPtr;
	int i;
#endif	/* defined(NTVDM) || defined(macintosh) */

#if defined(NTVDM) || defined(macintosh)
	write_cmos();
#else	/* defined(NTVDM) || defined(macintosh) */
	cmos_equip_update();
	config_get(C_CMOS,&value);
	strPtr = value->string;

	for (i = 0; i < CMOS_SIZE; ++i)
		strPtr += sprintf(strPtr,"%02x ",cmos[i]);

	config_put(C_CMOS,NULL);
#endif	/* defined(NTVDM) || defined(macintosh) */

#ifndef PROD
	if (io_verbose & CMOS_VERBOSE)
	{
		for (i = 0; i < 64; i++)
			fprintf(trace_file, "%02x ", cmos[i]);
		fprintf(trace_file, "\n");
		fflush(trace_file);
	}
#endif
}

#ifdef NTVDM
/* NTVDM build does rtc recalibration on rtc_tick */
GLOBAL void  rtc_init IFN0()
{
	long            bintim;

	cmos_count = 0;
	bintim = host_time((long *) 0);
        ht = host_localtime(&bintim);
#ifdef NTVDM
        dwTickCount = GetTickCount ();
        dwAccumulativeMilSec = 0;
#endif

	/* Set Up the cmos time bytes to be in BCD by default */
	bin2bcd = yes_bin2bcd;
	bcd2bin = yes_bcd2bin;
	data_mode_yes = TRUE;

	/* Set Up the cmos hour bytes to be 24 hour by default */
	_24to12 = no_24to12;
	_12to24 = no_12to24;
	twenty4_hour_clock = TRUE;

	cmos[CMOS_SECONDS] = (*bin2bcd) (ht->tm_sec);
        cmos[CMOS_MINUTES] = (*bin2bcd) (ht->tm_min);
	cmos[CMOS_HOURS] = (*_24to12) ((*bin2bcd) (ht->tm_hour));
	cmos[CMOS_DAY_WEEK] = (*bin2bcd) (ht->tm_wday + 1);
	cmos[CMOS_MONTH] = (*bin2bcd) (ht->tm_mon + 1);
	cmos[CMOS_YEAR] = (*bin2bcd) (ht->tm_year);
	cmos[CMOS_CENTURY] = (*bin2bcd) (19);

	set_alarm();
}





#else

LOCAL void
sync_rtc_to_host_time IFN1( long, param )
{
	time_t bintim;

	UNUSED( param );

	cmos_count = 0;
	bintim = host_time(NULL);
	ht = host_localtime(&bintim);

	cmos[CMOS_SECONDS] = (*bin2bcd) (ht->tm_sec);
	cmos[CMOS_MINUTES] = (*bin2bcd) (ht->tm_min);
	cmos[CMOS_HOURS] = (*_24to12) ((*bin2bcd) (ht->tm_hour));
	cmos[CMOS_DAY_WEEK] = (*bin2bcd) (ht->tm_wday + 1);
	cmos[CMOS_MONTH] = (*bin2bcd) (ht->tm_mon + 1);
	cmos[CMOS_YEAR] = (*bin2bcd) (ht->tm_year);
	cmos[CMOS_CENTURY] = (*bin2bcd) (19);

	/*
	 * Re-sync every 200 ticks ( ca. 11 seconds ). This stops
	 * the RTC from running slow on a loaded machine ( which
	 * loses host heartbeat events ( SIGALRM on Unix )).
	 * 200 ticks is not too often as to be a performance impact
	 * but should be often enough to be useful.
	 */

	(void) add_tic_event( sync_rtc_to_host_time, 200, 0 );
}

GLOBAL void  rtc_init IFN0()
{
#ifdef NTVDM
        dwTickCount = GetTickCount ();
        dwAccumulativeMilSec = 0;
#endif

	/* Set Up the cmos time bytes to be in BCD by default */
	bin2bcd = yes_bin2bcd;
	bcd2bin = yes_bcd2bin;
	data_mode_yes = TRUE;

	/* Set Up the cmos hour bytes to be 24 hour by default */
	_24to12 = no_24to12;
	_12to24 = no_12to24;
	twenty4_hour_clock = TRUE;

	sync_rtc_to_host_time( 0 );

	set_alarm();
}

#endif	/* NTVDM */

/*(
========================= cmos_clear_shutdown_byte ============================
PURPOSE:
	To clear the "shutdown" byte in the CMOS which indicates that the
	next reset is not a "soft" one. (e.g. it is a CTRL-ALT-DEL or panel
	reset). This routine is needed (rather than just doung cmos_outb()
	since the processor might currently be in enhanced mode with io to CMOS
	virtualised.
INPUT:
OUTPUT:
===============================================================================
)*/

GLOBAL void cmos_clear_shutdown_byte IFN0()
{
	cmos[CMOS_SHUT_DOWN] = 0;
}


#if !defined(NTVDM) && !defined(macintosh)
/*(
=============================== ValidateCmos ==================================
PURPOSE:
	Initialise CMOS array from values in configuration file.
INPUT:
	hostID - I.D. number of CMOS configuration entry
	vals - Value of CMOS configuration entry
	table - Not used
OUTPUT:
	errString - Error string.
	
	Returns C_CONFIG_OP_OK if CMOS configuration value OK, EG_BAD_VALUE if
	bad value.
===============================================================================
)*/

GLOBAL SHORT ValidateCmos IFN4(
    UTINY, hostID, 
    ConfigValues *, vals,
    NameTable *, table,
    CHAR *, errString
) {
    int i, nItems, value, nChars;
    char *strPtr = vals->string;

    for (i = 0; i < CMOS_SIZE; ++i) {
        nItems = sscanf(strPtr," %x%n",&value,&nChars); 
        if (nItems != 1 || value > 0xff) {
	    *errString = '\0';
            return EG_BAD_VALUE;
        }
        cmos[i] = (half_word)value;
        strPtr += nChars;
    }

    return C_CONFIG_OP_OK;
}
#endif	/* !defined(NTVDM) && !defined(macintosh) */



#ifdef TEST_HARNESS
main()
{
	int             i;
	half_word       j;

	cmos_init();

	printf("\n");
	for (i = 0; i < CMOS_SIZE; i++)
	{
		cmos_outb(CMOS_PORT, i);
		cmos_inb(CMOS_DATA, &j);
		printf("%c", j);
	}
	printf("\n");
	for (i = 0; i < CMOS_SIZE; i++)
	{
		cmos_outb(CMOS_PORT, i);
		cmos_outb(CMOS_DATA, (i + 0x30));
		printf("%c", cmos[i]);
	}
	printf("\n");

	cmos_update();
}
#endif				/* TEST_HARNESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\at_dma.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC-AT Revision 3.0
 *
 * Title        : IBM PC-AT DMA Adaptor Functions
 *
 * Description  : This module contains functions that can be used to
 *                access the DMA Adaptor emulation
 *
 * Author       : Ross Beresford
 *
 * Notes        : The external interface to these functions is defined
 *                in the associated header file
 *
 */

/*
 * static char SccsID[]="@(#)at_dma.c   1.15 12/17/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "AT_STUFF.seg"
#endif

/*
 *      System include files
 */
#include <stdio.h>
#include StringH
#include TypesH

/*
 *      SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include "gmi.h"
#include CpuH
#include "trace.h"
#include "dma.h"
#include "debug.h"
#include "sndblst.h"

#if defined(NEC_98)
#ifdef ROM_START
#undef ROM_START
#endif
#define ROM_START       0xC0000
#endif   //NEC_98
/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* the DMA adaptor state */
GLOBAL DMA_ADAPT adaptor = { 0 };

/* local function to do the actual transfer of data */
LOCAL void do_transfer  IPT6(int, type, int, decrement,
        sys_addr, dma_addr, char *, hw_buffer, unsigned long, length,
        unsigned long, size);

LOCAL   void bwd_dest_copy_to_M IPT3(host_addr, s, sys_addr, d, sys_addr, l);

LOCAL   void bwd_dest_copy_from_M       IPT3(sys_addr, s, host_addr, d,
        sys_addr, l);

#ifdef LIM
        static int lim_active = 0;
#endif /* LIM */


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

#ifdef LIM
/*
** Called from do_transfer() and from init_struc.c in delta
** for the 800 port.
** lim_active is a static int
*/
GLOBAL  int get_lim_setup       IFN0()
{
        return( lim_active );
}
#endif /* LIM */

#ifdef LIM
/*
** called from emm_funcs.c
*/
GLOBAL  void dma_lim_setup      IFN0()
{
        lim_active = 1;
}
#endif /* LIM */

GLOBAL  void dma_post   IFN0()
{
        unsigned int chan, cntrl;

        /*
         *      Reset the DMA Adaptor
         */

        for (cntrl = 0; cntrl < DMA_ADAPTOR_CONTROLLERS; cntrl++)
        {
                adaptor.controller[cntrl].command.all = 0;
                adaptor.controller[cntrl].status.all = 0;
                adaptor.controller[cntrl].request = 0;
                adaptor.controller[cntrl].temporary = 0;
                adaptor.controller[cntrl].mask = ~0;

                adaptor.controller[cntrl].first_last = 0;
        }

        /*
         *      Set the DMA Adaptor channel modes
         */

        for (cntrl = 0; cntrl < DMA_ADAPTOR_CONTROLLERS; cntrl++)
        {
                for (chan = 0; chan < DMA_CONTROLLER_CHANNELS; chan++)
                {
                        adaptor.controller[cntrl].mode[chan].all = 0;
                        /* put the channels into their correct mode */
#if defined(NEC_98)
                        adaptor.controller[cntrl].mode[chan].bits.mode = DMA_SINGLE_MODE;
                        adaptor.controller[cntrl].bank_mode[chan].bits.incrementmode = DMA_64K_MODE;
#else    //NEC_98
                        if (dma_logical_channel(cntrl, chan) == DMA_CASCADE_CHANNEL)
                                adaptor.controller[cntrl].mode[chan].bits.mode = DMA_CASCADE_MODE;
                        else
                                adaptor.controller[cntrl].mode[chan].bits.mode = DMA_SINGLE_MODE;
#endif   //NEC_98
                }
        }
}

GLOBAL  void dma_inb    IFN2(io_addr, port, half_word *, value)
{
        register DMA_CNTRL *dcp;

        note_trace0_no_nl(DMA_VERBOSE, "dma_inb() ");

        /*
         * Get a pointer to the controller and mask out the port's
         * redundant bits.
         * The first check is commented out as DMA_PORT_START is zero,
         * so the check on an unsigned variable is unnecessary.
         */
#ifndef NEC_98
        if (/*port >= DMA_PORT_START &&*/ port <= DMA_PORT_END)
        {
#endif   //NEC_98
                dcp = &adaptor.controller[DMA_CONTROLLER];
                port &= ~DMA_REDUNDANT_BITS;
#ifndef NEC_98
        }
        else
        {
                dcp = &adaptor.controller[DMA1_CONTROLLER];
                port &= ~DMA1_REDUNDANT_BITS;
        }
#endif   //NEC_98

        /*
         *      When the current address and word count are read, the
         *      first/last flip-flop for the controller is used to
         *      determine which byte is accessed, and is then toggled.
         */
        switch (port)
        {
                        /* read channel current address on controller 0 */
        case    DMA_CH0_ADDRESS:
        case    DMA_CH1_ADDRESS:
        case    DMA_CH2_ADDRESS:
        case    DMA_CH3_ADDRESS:
                if (port == SbDmaChannel && dcp->first_last == 0) {
                    SbGetDMAPosition();
                }
#if defined(NEC_98)
                *value = dcp->current_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                *value = dcp->current_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current address on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_ADDRESS:
        case    DMA_CH5_ADDRESS:
        case    DMA_CH6_ADDRESS:
        case    DMA_CH7_ADDRESS:
                *value = dcp->current_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current word count on controller 0 */
        case    DMA_CH0_COUNT:
        case    DMA_CH1_COUNT:
        case    DMA_CH2_COUNT:
        case    DMA_CH3_COUNT:
                if (port == (SbDmaChannel + 2) && dcp->first_last == 0) {
                    SbGetDMAPosition();
                }
#if defined(NEC_98)
                *value = dcp->current_count[(port-DMA_CH0_COUNT)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                *value = dcp->current_count[(port-DMA_CH0_COUNT)/2][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current word count on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_COUNT:
        case    DMA_CH5_COUNT:
        case    DMA_CH6_COUNT:
        case    DMA_CH7_COUNT:
                *value = dcp->current_count[(port-DMA_CH4_COUNT)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read status register - clears terminal counts */
        case    DMA_SHARED_REG_A:
#ifndef NEC_98
        case    DMA1_SHARED_REG_A:
#endif   //NEC_98
                *value = dcp->status.all;
                dcp->status.bits.terminal_count = 0;
                break;

                        /* read temporary register */
        case    DMA_SHARED_REG_B:
#ifndef NEC_98
        case    DMA1_SHARED_REG_B:
#endif   //NEC_98
                *value = dcp->temporary;
                break;

        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal read>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, returning 0x%02x", port,
                    *value);
}

GLOBAL  void dma_outb   IFN2(io_addr, port, half_word, value)
{
        register DMA_CNTRL *dcp;

        note_trace0_no_nl(DMA_VERBOSE, "dma_outb() ");

        /*
         * Get a pointer to the controller and mask out the port's
         * redundant bits.
         * The first check is commented out as DMA_PORT_START is zero,
         * so the check on an unsigned variable is unnecessary.
         */
#if defined(NEC_98)
        dcp = &adaptor.controller[DMA_CONTROLLER];
#else    //NEC_98
        if (/*port >= DMA_PORT_START &&*/  port <= DMA_PORT_END)
        {
                dcp = &adaptor.controller[DMA_CONTROLLER];
                port &= ~DMA_REDUNDANT_BITS;
        }
        else
        {
                dcp = &adaptor.controller[DMA1_CONTROLLER];
                port &= ~DMA1_REDUNDANT_BITS;
        }
#endif   //NEC_98

        /*
         *      When the current address and word count are written, the
         *      first/last flip-flop for the controller is used to
         *      determine which byte is accessed, and is then toggled.
         */
        switch (port)
        {
                        /* write channel addresseess on controller 0 */
        case    DMA_CH0_ADDRESS:
        case    DMA_CH1_ADDRESS:
        case    DMA_CH2_ADDRESS:
        case    DMA_CH3_ADDRESS:
#if defined(NEC_98)
                dcp->current_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                dcp->current_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel addresses on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_ADDRESS:
        case    DMA_CH5_ADDRESS:
        case    DMA_CH6_ADDRESS:
        case    DMA_CH7_ADDRESS:
                dcp->current_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel word counts on controller 0 */
        case    DMA_CH0_COUNT:
        case    DMA_CH1_COUNT:
        case    DMA_CH2_COUNT:
        case    DMA_CH3_COUNT:
#if defined(NEC_98)
                dcp->current_count[(port-DMA_CH0_COUNT)/4][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH0_COUNT)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                dcp->current_count[(port-DMA_CH0_COUNT)/2][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH0_COUNT)/2][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel word counts on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_COUNT:
        case    DMA_CH5_COUNT:
        case    DMA_CH6_COUNT:
        case    DMA_CH7_COUNT:
                dcp->current_count[(port-DMA_CH4_COUNT)/4][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH4_COUNT)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write command register */
        case    DMA_SHARED_REG_A:
#ifndef NEC_98
        case    DMA1_SHARED_REG_A:
#endif   //NEC_98
                dcp->command.all = value;
                break;

                        /* write request register */
        case    DMA_WRITE_REQUEST_REG:
#ifndef NEC_98
        case    DMA1_WRITE_REQUEST_REG:
#endif   //NEC_98
                /* this feature is not supported */
                note_trace0_no_nl(DMA_VERBOSE, "<software DMA request>");
                break;

                        /* write single mask register bit */
        case    DMA_WRITE_ONE_MASK_BIT:
#ifndef NEC_98
        case    DMA1_WRITE_ONE_MASK_BIT:
#endif   //NEC_98
                if (value & 0x4)
                {
                        /* set mask bit */
                        dcp->mask |= (1 << (value & 0x3));
                }
                else
                {
                        /* clear mask bit */
                        dcp->mask &= ~(1 << (value & 0x3));
                }
                break;

                        /* write mode register */
        case    DMA_WRITE_MODE_REG:
#ifndef NEC_98
        case    DMA1_WRITE_MODE_REG:
#endif   //NEC_98
                /* note that the bottom 2 bits of value disappear into
                   the mode padding */
                dcp->mode[(value & 0x3)].all = value;
                break;

                        /* clear first/last flip-flop */
        case    DMA_CLEAR_FLIP_FLOP:
#ifndef NEC_98
        case    DMA1_CLEAR_FLIP_FLOP:
#endif   //NEC_98
                dcp->first_last = 0;
                break;

                        /* write master clear */
        case    DMA_SHARED_REG_B:
#ifndef NEC_98
        case    DMA1_SHARED_REG_B:
#endif   //NEC_98
                dcp->command.all = 0;
                dcp->status.all = 0;
                dcp->request = 0;
                dcp->temporary = 0;
                dcp->mask = ~0;

                dcp->first_last = 0;
                break;

                        /* clear mask register */
        case    DMA_CLEAR_MASK:
#ifndef NEC_98
        case    DMA1_CLEAR_MASK:
#endif   //NEC_98
                dcp->mask = 0;
                break;

                        /* write all mask register bits */
        case    DMA_WRITE_ALL_MASK_BITS:
#ifndef NEC_98
        case    DMA1_WRITE_ALL_MASK_BITS:
#endif   //NEC_98
                dcp->mask = value;

        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal write>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, value 0x%02x", port, value);
}

GLOBAL  void dma_page_inb       IFN2(io_addr, port, half_word *, value)
{
        note_trace0_no_nl(DMA_VERBOSE, "dma_page_inb() ");

#ifndef NEC_98
        /* mask out the port's redundant bits */
        port &= ~DMA_PAGE_REDUNDANT_BITS;
#endif  //NEC_98

        /*
         *      Read the value from the appropriate page register.
         *      Unfortunately there does not seem to be any logical
         *      mapping between port numbers and channel numbers so
         *      we use a big switch again.
         */
        switch(port)
        {
        case    DMA_CH0_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_0];
                break;
#if defined(NEC_98)
        case    DMA_CH1_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_1];
                break;
        case    DMA_CH2_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_2];
                break;
        case    DMA_CH3_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_3];
                break;
#else    //NEC_98
        case    DMA_CH1_PAGE_REG:
                *value = adaptor.pages.page[DMA_SDLC_CHANNEL];
                break;
        case    DMA_FLA_PAGE_REG:
                *value = adaptor.pages.page[DMA_DISKETTE_CHANNEL];
                break;
        case    DMA_HDA_PAGE_REG:
                *value = adaptor.pages.page[DMA_DISK_CHANNEL];
                break;
        case    DMA_CH5_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_5];
                break;
        case    DMA_CH6_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_6];
                break;
        case    DMA_CH7_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_7];
                break;
        case    DMA_REFRESH_PAGE_REG:
                *value = adaptor.pages.page[DMA_REFRESH_CHANNEL];
                break;
        case    DMA_FAKE1_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_1];
                break;
        case    DMA_FAKE2_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_2];
                break;
        case    DMA_FAKE3_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_3];
                break;
        case    DMA_FAKE4_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_4];
                break;
        case    DMA_FAKE5_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_5];
                break;
        case    DMA_FAKE6_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_6];
                break;
        case    DMA_FAKE7_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_7];
                break;
#endif   //NEC_98
        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal read>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, returning 0x%02x", port,
                    *value);
}

GLOBAL  void dma_page_outb      IFN2(io_addr, port, half_word, value)
{
        note_trace0_no_nl(DMA_VERBOSE, "dma_page_outb() ");

        /* mask out the port's redundant bits */
#ifndef NEC_98
        port &= ~DMA_PAGE_REDUNDANT_BITS;
#endif   //NEC_98

        /*
         *      Write the value into the appropriate page register.
         *      Unfortunately there does not seem to be any logical
         *      mapping between port numbers and channel numbers so
         *      we use a big switch again.
         */
        switch(port)
        {
        case    DMA_CH0_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_0] = value;
                break;
#if defined(NEC_98)
        case    DMA_CH1_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_1] = value;
                break;
        case    DMA_CH2_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_2] = value;
                break;
        case    DMA_CH3_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_3] = value;
                break;
        case    DMA_MODE_REG:
                if (((value >> 2) & 3) != 2)
                        adaptor.controller[DMA_CONTROLLER].bank_mode[(value & 0x3)].bits.incrementmode = (value >> 2) & 3;
                break;
#else    //NEC_98
        case    DMA_CH1_PAGE_REG:
                adaptor.pages.page[DMA_SDLC_CHANNEL] = value;
                break;
        case    DMA_FLA_PAGE_REG:
                adaptor.pages.page[DMA_DISKETTE_CHANNEL] = value;
                break;
        case    DMA_HDA_PAGE_REG:
                adaptor.pages.page[DMA_DISK_CHANNEL] = value;
                break;
        case    DMA_CH5_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_5] = value;
                break;
        case    DMA_CH6_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_6] = value;
                break;
        case    DMA_CH7_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_7] = value;
                break;
        case    DMA_REFRESH_PAGE_REG:
                adaptor.pages.page[DMA_REFRESH_CHANNEL] = value;
                /* this feature is supported */
                note_trace0_no_nl(DMA_VERBOSE, "<refresh>");
                break;
        case    MFG_PORT:
                /* Manufacturing port */
                /* Meaningless 'checkpoint' debug removed from here STF 11/92 */
                break;
        case    DMA_FAKE1_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_1] = value;
                break;
        case    DMA_FAKE2_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_2] = value;
                break;
        case    DMA_FAKE3_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_3] = value;
                break;
        case    DMA_FAKE4_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_4] = value;
                break;
        case    DMA_FAKE5_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_5] = value;
                break;
        case    DMA_FAKE6_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_6] = value;
                break;
        case    DMA_FAKE7_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_7] = value;
                break;
#endif   //NEC_98
        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal write>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, value 0x%02x", port, value);
}

GLOBAL  int     dma_request     IFN3(half_word, channel, char *, hw_buffer,
        word, length)
{
        DMA_CNTRL *dcp;
        unsigned int chan;
        word offset, count;
        sys_addr munch, split_munch1, split_munch2, address;
        unsigned int size;
        int result = TRUE;

        note_trace3(DMA_VERBOSE,
                    "dma_request() channel %d, hw_buffer 0x%08x+%04x",
                    channel, hw_buffer, length);

        /* get a pointer to the controller, the physical channel
           number, and the unit size for the channel */
        dcp = &adaptor.controller[dma_physical_controller(channel)];
        chan = dma_physical_channel(channel);
        size = dma_unit_size(channel);

        /* get out if the whole DMA controller is disabled or if DMA
           requests are disabled for the channel */
        if (    (dcp->command.bits.controller_disable == 0)
             && ((dcp->mask & (1 << chan)) == 0) )
        {
                /* get the working copies of the DMA offset and count */
                offset = (   ( (unsigned int)dcp->current_address[chan][1] << 8)
                           | (dcp->current_address[chan][0] << 0) );
                count  = (   ( (unsigned int)dcp->current_count[chan][1] << 8)
                           | (dcp->current_count[chan][0] << 0) );

                /* get the DMA munch size; it is the count programmed
                   into the registers, up to the limit available in the
                   device's buffer; NB for a count of n, n+1 units will
                   actually be transferred */
                munch = (sys_addr)count + 1;
                if (munch > length)
                        munch = length;

                /* get the base address for the DMA transfer in
                   system address space */
                address = dma_system_address(channel,
                                adaptor.pages.page[channel], offset);
                if (dcp->mode[chan].bits.address_dec == 0)
                {
                        /* increment memory case - check for address wrapping */
                        if ((sys_addr)offset + munch > 0x10000L)
                        {
                                /* transfer must be split */
                                split_munch1 = 0x10000L - (sys_addr)offset;
                                split_munch2 = munch - split_munch1;

                                /* do the first transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch1,
                                size
                                );

                                /* get addresses for second transfer */
                                address = dma_system_address(channel,
                                        adaptor.pages.page[channel], 0);
                                hw_buffer += split_munch1*size;

                                /* do the second transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch2,
                                size
                                );
                        }
                        else
                        {
                                /* no wrap - do the transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                munch,
                                size
                                );
                        }

                        /* get the final offset */
                        offset += (word)munch;
                        count  -= (word)munch;
                }
                else
                {
                        /* decrement memory case - check for address wrapping */
                        if ((sys_addr)offset < munch)
                        {
                                /* transfer must be split */
                                split_munch1 = (sys_addr)offset;
                                split_munch2 = munch - split_munch1;

                                /* do the first transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch1,
                                size
                                );

                                /* get addresses for second transfer */
                                address = dma_system_address(channel,
                                        adaptor.pages.page[channel], 0xffff);
                                hw_buffer += split_munch1*size;

                                /* do the second transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch2,
                                size
                                );
                        }
                        else
                        {
                                /* no wrap - do the transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                munch,
                                size
                                );
                        }

                        /* get the final offset and count */
                        offset -= (word)munch;
                        count -= (word)munch;
                }

                /* restore the DMA offset and count from the working copies */
                dcp->current_address[chan][1] = offset >> 8;
                dcp->current_address[chan][0] = (UCHAR)offset;
                dcp->current_count[chan][1] = count >> 8;
                dcp->current_count[chan][0] = (UCHAR)count;

                if (count == 0xffff)
                {
                        /*
                         *      Terminal count has been reached
                         */

                        /* no more transfers are required */
                        result = FALSE;

                        /* update the status register */
                        dcp->status.bits.terminal_count |= (1 << chan);
                        dcp->status.bits.request &= ~(1 << chan);

                        /* if autoinitialization is enabled, then reset
                           the channel and wait for a new request */
                        if (dcp->mode[chan].bits.auto_init != 0)
                        {
                                dcp->current_count[chan][0] =
                                        dcp->base_count[chan][0];
                                dcp->current_count[chan][1] =
                                        dcp->base_count[chan][1];

                                dcp->current_address[chan][0] =
                                        dcp->base_address[chan][0];
                                dcp->current_address[chan][1] =
                                        dcp->base_address[chan][1];
                        }
                        else
                        {
                                /* set the mask bit for the channel */
                                dcp->mask |= (1 << chan);
                        }
                }
        }

        return(result);
}

GLOBAL  void dma_enquire        IFN3(half_word, channel,
        sys_addr *, address, word *, length)
{
        register DMA_CNTRL *dcp;
        register unsigned int chan;

        note_trace0_no_nl(DMA_VERBOSE, "dma_enquire() ");

        /* get a pointer to the controller and the physical channel
           number */
        dcp = &adaptor.controller[dma_physical_controller(channel)];
        chan = dma_physical_channel(channel);

        /* build the address */
        *address = dma_system_address(channel,
                        adaptor.pages.page[channel],
                        (   ( (unsigned int)dcp->current_address[chan][1] << 8)
                          | ( dcp->current_address[chan][0] << 0) ) );

        /* build the count */
        *length = (   ((unsigned int)dcp->current_count[chan][1] << 8)
                    | (dcp->current_count[chan][0] << 0) );

        note_trace3(DMA_VERBOSE, " channel %d, returning 0x%08x+%04x",
                    channel, *address, *length);
}

#ifdef NTVDM
/*
 * BOOL dmaGetAdaptor
 *
 * Used by MS for third party Vdds to retrieve current DMA settings
 *
 * entry: void
 * exit : DMA_ADAPT * , pointer to the DMA_ADAPT structure
 *
 */
DMA_ADAPT *dmaGetAdaptor(void)
{
  return &adaptor;
}
#endif  /* NTVDM */


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

LOCAL void do_transfer  IFN6(int, type, int, decrement,
        sys_addr, dma_addr, char *, hw_buffer, unsigned long, length,
        unsigned long, size)
{
        /*
         *      This function moves the data for a DMA transfer.
         *
         *      The value of "type" may be:
         *              DMA_WRITE_TRANSFER - data is moved from the I/O
         *              device's memory space to system address space;
         *              DMA_READ_TRANSFER - data is moved from system
         *              address space to the I/O device's memory space
         *              DMA_VERIFY_TRANSFER - no data is required to be
         *              moved at all.
         *
         *      If "decrement" is TRUE, the pointer to system address
         *      space is decremented during the DMA transfer; otherwise
         *      the pointer is incremented. The pointer to the I/O
         *      device's memory space is always incremented.
         *
         *      "dma_addr" is the offset in system address space where
         *      the DMA transfer will start; "hw_buffer" is the address
         *      of the buffer in the I/O device's memory space where
         *      the DMA transfer will start.
         *
         *      "length" is the number of units of "size" bytes each
         *      that must be transferred.
         */

        /* convert the length to bytes */
        length *= size;

        /* do the transfer */
        switch(type)
        {
        case    DMA_WRITE_TRANSFER:
                if (!decrement)
                {
#ifndef PM
#ifdef LIM
                        if( !get_lim_setup() ){
                                if( dma_addr >= ROM_START ){
                                        if( dma_addr >= ROM_START )
                                                break;
                                        length = ROM_START - dma_addr - 1;
                                }
                        }
#else
                        /* increment case - check for writing to ROM */
                        if ((dma_addr + length) >= ROM_START)
                        {
                                if (dma_addr >= ROM_START)
                                        break;
                                length = ROM_START - dma_addr - 1;
                        }
#endif /* LIM */
#endif /* nPM */
                        sas_PWS(dma_addr, (host_addr) hw_buffer, length);

                }
                else
                {
                        /*  decrement case - check for writing to ROM */
#ifndef PM
#ifdef LIM
                        if( !get_lim_setup() ){
                                if (dma_addr >= ROM_START) {
                                        if (dma_addr-length >= ROM_START)
                                                break;
                                        length = dma_addr-ROM_START+length-1;
                                        dma_addr = ROM_START - 1;
                                }
                        }
#else
                        if (dma_addr >= ROM_START)
                        {
                                if (dma_addr-length >= ROM_START)
                                        break;
                                length = dma_addr - ROM_START + length - 1;
                                dma_addr = ROM_START - 1;
                        }
#endif /* LIM */
#endif /* nPM */
                        bwd_dest_copy_to_M((half_word *)hw_buffer, dma_addr, length);

                }
                break;

        case    DMA_READ_TRANSFER:
                if (!decrement)
                        /* increment case */
                        sas_PRS(dma_addr, (host_addr) hw_buffer, length);
                else
                        /* decrement case */
                        bwd_dest_copy_from_M(dma_addr, (half_word *)hw_buffer, length);
                break;

        case    DMA_VERIFY_TRANSFER:
                break;

        default:
                note_trace0(DMA_VERBOSE, "dma_request() illegal transfer");
                break;
        }
}

/*
 * backward copy routines - these used to be
 * in the host but there seemed to be little point
 */

LOCAL   void    bwd_dest_copy_to_M      IFN3(host_addr, s, sys_addr, d,
        sys_addr, l)
{
        while (l-- > 0)
                sas_PW8(d--, *s++);
}

LOCAL   void    bwd_dest_copy_from_M    IFN3(sys_addr, s, host_addr, d,
        sys_addr, l)
{
        while (l-- > 0)
                *d-- = sas_PR8(s++);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

GLOBAL  void dma_init   IFN0()
{
        io_addr port;

        note_trace0(DMA_VERBOSE, "dma_init() called");

#ifdef LIM
        lim_active = 0;
#endif

        /*
         * Connect the DMA Adaptor chips to the I/O bus
         */

        /* establish the DMA Controller I/O functions that will be used */
        io_define_inb(DMA_ADAPTOR, dma_inb);
        io_define_outb(DMA_ADAPTOR, dma_outb);

        /* connect the DMA Controller chips to the I/O bus */
#if defined(NEC_98)
        for (port = DMA_PORT_START; port <= DMA_PORT_END; port += 2)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
#else    //NEC_98
        for (port = DMA_PORT_START; port <= DMA_PORT_END; port++)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
        for (port = DMA1_PORT_START; port <= DMA1_PORT_END; port++)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98

        /* establish the DMA Page Register I/O functions that will be used */
        io_define_inb(DMA_PAGE_ADAPTOR, dma_page_inb);
        io_define_outb(DMA_PAGE_ADAPTOR, dma_page_outb);

        /* connect the DMA Page Register chip to the I/O bus */
#if defined(NEC_98)
        for (port = DMA_PAGE_PORT_START; port <= DMA_PAGE_PORT_END; port += 2)
                io_connect_port(port, DMA_PAGE_ADAPTOR, IO_READ_WRITE);
#else     //NEC_98
        for (port = DMA_PAGE_PORT_START; port <= DMA_PAGE_PORT_END; port++)
                io_connect_port(port, DMA_PAGE_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\cmosnt.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
/*
 * Name:		cmos.c
 *
 * Sccs ID:		@(#)cmos.c	1.38 07/11/95
 *
 * Purpose:		Unknown
 *
 * (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 */

/*
 * O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>

/*
 * SoftPC include files
 */

#include "xt.h"
#include "cmos.h"
#include "cmosbios.h"
#include "ios.h"
#include "spcfile.h"
#include "error.h"
#include "config.h"
#include "timeval.h"
#include "ica.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gfi.h"
#include "sas.h"
#include "debug.h"
#include "quick_ev.h"

#include <nt_eoi.h>


half_word(*bin2bcd)(int x);
half_word(*_24to12)(half_word x);
int (*bcd2bin)(int x);
int (*_12to24)(int x);

boolean  data_mode_yes;
boolean  twenty4_hour_clock;
int cmos_index = 0;


typedef struct _HOST_TIME{
   int Year;
   int Month;
   int Day;
   int Hour;
   int Minute;
   int Second;
   int WeekDay;
} HOSTTIME, *PHOSTTIME;

HOSTTIME   HostTime;      /* The host time */
PHOSTTIME  ht = &HostTime;


IU32 rtc_period_mSeconds = 976;

half_word cmos[CMOS_SIZE] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* Timing info + alarms */
	REG_A_INIT,
	REG_B_INIT,
	REG_C_INIT,
	REG_D_INIT,
	DIAG_INIT,
	SHUT_INIT,
	FLOP_INIT,
        DISK_INIT,
	DISK_INIT,
	CMOS_RESVD,
	EQUIP_INIT,
	BM_LO_INIT, BM_HI_INIT,
	EXP_LO, EXP_HI,
	DISK_EXTEND, DISK2_EXTEND,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1b - 0x1e */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1f - 0x22 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x23 - 0x26 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x27 - 0x2a */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x2b - 0x2d */
	CHK_HI_INIT, CHK_LO_INIT,
	EXT_LO_INIT, EXT_HI_INIT,
	CENT_INIT,
	INFO_128_INIT,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x34 - 0x37 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x38 - 0x3b */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x3c - 0x3f */
};

half_word *cmos_register = &cmos[CMOS_SHUT_DOWN];


int RtcLastAlarm;
int RtcAlarmTime;
int RtcHostUpdateTime;
BOOL RtcEoiPending;
int  RtcUpdateCycle=-1;
unsigned char TogglePfCount;
unsigned char PendingCReg = 0;
struct host_timeval RtcTickTime = {0,0};


/*
 *
 * ===========================================================================
 * Internal functions
 * ===========================================================================
 *
 */




/*
 *  Calculates next AlarmTime in seconds based on RtcTickTime.
 *  Assumes that RtcHostUpdateTime == RtcTickTime->tv_sec
 */
void ResetAlarm(void)
{
   int HourDue;
   int MinDue;
   int SecDue;
   int SecondsTillDue;


   if (RtcLastAlarm) {
       return;
       }

   if (!(cmos[CMOS_REG_B] & AIE) || (cmos[CMOS_REG_B] & SET)) {
       RtcAlarmTime = 0;
       return;
       }


   /*
    * Determine hour, min, and sec when Next Alarm is due.
    *
    */

   HourDue = cmos[CMOS_HR_ALARM] >= DONT_CARE
                 ? ht->Hour
                 : (*_12to24)((*bcd2bin)(cmos[CMOS_HR_ALARM]));

   MinDue = cmos[CMOS_MIN_ALARM] >= DONT_CARE
                 ? ht->Minute
                 : (*bcd2bin)(cmos[CMOS_MIN_ALARM]);

   SecDue = cmos[CMOS_SEC_ALARM] >= DONT_CARE
                 ? ht->Second + 1
                 : (*bcd2bin)(cmos[CMOS_SEC_ALARM]);


   /*
    * Determine Seconds until Next alarm due. NEVER schedule alarms
    * for the current update cycle, as this will cause multiple alarms
    * to occur because alarm interrupts are queued in RtcTick(). ie
    * assume CurrTime is 1 sec in the future.
    *
    * AlarmSecs = SecDue + MinDue * 60 + HourDue * 3600;
    * CurrSecs  = ht->Second + 1 + ht->Minute * 60 + ht->Hour * 3600;
    * SecondsTillDue = AlarmSecs - CurrSecs - 1;
    *
    */

   SecondsTillDue = (HourDue - ht->Hour) * 3600 +
                    (MinDue -  ht->Minute)  * 60 +
                    SecDue - ht->Second - 1;

   if (SecondsTillDue < 0) {
       SecondsTillDue += 24 *3600;
       }

   SecondsTillDue++;

   /*
    *  The Next AlarmTime is RtcTickTime + SecondsTillDue;
    */
   RtcAlarmTime = RtcTickTime.tv_sec + SecondsTillDue;

}





/*
 *  Function to change Host Time where the the Day might change.
 *  (ie past midnight!).
 */
BOOL
HostTimeAdjust(
    int Seconds
    )
{
    TIME_FIELDS    tf;
    LARGE_INTEGER  liTime;

    tf.Milliseconds = 0;
    tf.Second     = (SHORT)ht->Second;
    tf.Minute     = (SHORT)ht->Minute;
    tf.Hour       = (SHORT)ht->Hour;
    tf.Day        = (SHORT)ht->Day;
    tf.Month      = (SHORT)ht->Month;
    tf.Year       = (SHORT)ht->Year;

    if (!RtlTimeFieldsToTime(&tf, &liTime)) {
        return FALSE;
        }

    liTime.QuadPart += Int32x32To64(Seconds, 10000000);

    RtlTimeToTimeFields(&liTime, &tf);

    ht->Second    = tf.Second;
    ht->Minute    = tf.Minute;
    ht->Hour      = tf.Hour;
    ht->Day       = tf.Day;
    ht->Month     = tf.Month;
    ht->Year      = tf.Year;
    ht->WeekDay   = tf.Weekday;

    return TRUE;
}




void
UpdateCmosTime(
   void
   )
{
   ULONG CurrTic;
   int SecsElapsed;


   if ((cmos[CMOS_REG_B] & SET)) {
       return;
       }

   TogglePfCount++;


   SecsElapsed = RtcTickTime.tv_sec - RtcHostUpdateTime;

   if (SecsElapsed > 0) {
       RtcHostUpdateTime = RtcTickTime.tv_sec;
       cmos[CMOS_REG_A] |= UIP;
       RtcUpdateCycle = 3;

       ht->Second += SecsElapsed;
       if (ht->Second >= 60) {
           ht->Minute += (ht->Second / 60);
           ht->Second = ht->Second % 60;
           if (ht->Minute >= 60) {
               ht->Hour += ht->Minute / 60;
               ht->Minute  = ht->Minute % 60;

                   /*
                    * To increment Time past midnight is hard
                    * because we don't have a calender. Let Nt
                    * deal with it.
                    */
               if (ht->Hour >= 24) {
                   int Seconds;

                   Seconds = (ht->Hour - 23) * 60 * 60;
                   ht->Hour = 23;
                   if (!HostTimeAdjust(Seconds)) {
                       ht->Hour = 0;
                       }
                   }
               }
           }
       }


}




void
QueueRtcInterrupt(
    unsigned char CRegFlag,
    BOOL  InEoi
    )
{
    unsigned long Delay;

    PendingCReg |= CRegFlag;

    if (RtcEoiPending || !PendingCReg) {
        return;
        }

    RtcEoiPending = TRUE;

    if (PendingCReg & C_PF) {
        Delay = rtc_period_mSeconds;
        }
    else if (InEoi) {
        Delay = 10000;
        }
    else {
        Delay = 0;
        }

    cmos[CMOS_REG_C] |= PendingCReg | C_IRQF;

    if (Delay) {
        host_DelayHwInterrupt(8,   // ICA_SLAVE, CPU_RTC_INT
                              1,
                              Delay
                              );
        }
    else {
        ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
        }

    PendingCReg = 0;
}



void
RtcIntEoiHook(int IrqLine, int CallCount)
{
     RtcEoiPending = FALSE;

     if (RtcLastAlarm) {
         RtcLastAlarm = 0;
         UpdateCmosTime();
         ResetAlarm();
         }

     QueueRtcInterrupt((half_word)((cmos[CMOS_REG_B] & PIE) &&  rtc_period_mSeconds ? C_PF : 0),
                       TRUE
                       );
}



void do_checksum IFN0()
{
	int             i;
	word            checksum = 0;

	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	cmos[CMOS_CKSUM_LO] = checksum & 0xff;
	cmos[CMOS_CKSUM_HI] = checksum >> 8;
}

half_word yes_bin2bcd IFN1(int, x)
{
	/* converts binary x to bcd */
	half_word       tens, units;

	tens = x / 10;
	units = x - tens * 10;
	return ((tens << 4) + units);
}

half_word no_bin2bcd IFN1(int, x)
{
	return ((half_word) x);
}

int yes_bcd2bin IFN1(int, x)
{
	/* converts x in bcd format to binary */
	return ((int) ((x & 0x0f) + (x >> 4) * 10));
}

int no_bcd2bin IFN1(int, x)
{
	return ((int) (half_word) x);
}

int no_12to24 IFN1(int, x)
{
	return (x);
}

half_word no_24to12 IFN1(half_word, x)
{
	return (x);
}

half_word yes_24to12 IFN1(half_word, x)
{
	/* converts binary or bcd x from 24 to 12 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x > y)
		x = (x - y) | 0x80;
	else if (x == 0)
		x = y | 0x80;
	return (x);
}

int yes_12to24 IFN1(int, x)
{
	/* converts binary or bcd x from 12 to 24 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x == (0x80 + y))
		return (0);
	else if (x & 0x80)
		return ((x & 0x7f) + y);
	else
		return (x);
}

int verify_equip_byte IFN1(half_word *, equip)
{
	static half_word display_mask[] =
	{
		MDA_PRINTER,	CGA_80_COLUMN,	CGA_80_COLUMN,
		OWN_BIOS,	MDA_PRINTER
	};
	int equip_err;
	int num_flops;
	SHORT adapter;

	/* Check the Equipment Byte */
	*equip = 0;
        adapter = (SHORT) config_inquire(C_GFX_ADAPTER, NULL);
	if(adapter != -1)
		*equip |= display_mask[adapter];

	if( host_runtime_inquire(C_NPX_ENABLED) )
		*equip |= CO_PROCESSOR_PRESENT;

#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		num_flops =
			(*(CHAR *) config_inquire(C_SLAVEPC_DEVICE, NULL))
			? 1:0;
	}
	else
#endif /* SLAVEPC */
	{
		num_flops  =
			(*(CHAR *) config_inquire(C_FLOPPY_A_DEVICE, NULL))
			? 1:0;
#ifdef FLOPPY_B
		num_flops +=
			(*(CHAR *) config_inquire(C_FLOPPY_B_DEVICE, NULL))
			? 1:0;
#endif
	}

	if (num_flops == 2)
		*equip |= TWO_DRIVES;
	if (num_flops)
		*equip |= DISKETTE_PRESENT;

	equip_err = (*equip ^ cmos[CMOS_EQUIP]);
	return equip_err;
}

/*
 * =========================================================================
 *  External functions
 * =========================================================================
 */

GLOBAL void cmos_inb IFN2(io_addr, port, half_word *, value)
{
        /*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port==0x78 )
	{
		*value = 0;
		return;
	}

	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	if (port == CMOS_DATA)
        {
            host_ica_lock();

            UpdateCmosTime();

            switch (cmos_index) {
                case CMOS_REG_A:
                      *value = *cmos_register;

                      /*
                       *  If app polling RegA and Update Cycle pending,
                       *  complete it.
                       */
                      if (RtcUpdateCycle > 0 && !--RtcUpdateCycle) {
                          cmos[CMOS_REG_A] &= ~UIP;
                          if (cmos[CMOS_REG_B] & UIE) {
                              QueueRtcInterrupt(C_UF, FALSE);
                              }
                          else {
                              cmos[CMOS_REG_C] |= C_UF;
                              }
                          }

                      break;

                case CMOS_REG_C:
                      *value = *cmos_register;

                      /*
                       * Reading Register C on real rtc clears all bits.
                       * However, Need to toggle PF bit when PIE is
                       * not enabled for polling apps.
                       */
                      cmos[CMOS_REG_C] = C_CLEAR;
                      if (!(cmos[CMOS_REG_B] & PIE) && rtc_period_mSeconds) {
                          if (!(*value & C_PF) || (TogglePfCount & 0x8)) {
                              cmos[CMOS_REG_C]  |= C_PF;
                              }
                          }

                      break;

                case CMOS_SECONDS:
                      *value = (*bin2bcd) (ht->Second);
                      break;

                case CMOS_MINUTES:
                      *value = (*bin2bcd) (ht->Minute);
                      break;

                case CMOS_HOURS:
                      *value = (*_24to12) ((*bin2bcd) (ht->Hour));
                      break;

                case CMOS_DAY_WEEK:
                      /* Sunday = 1 on RTC, 0 in HOSTTIME */
                      *value = (*bin2bcd) (ht->WeekDay + 1);
                      break;

                case CMOS_DAY_MONTH:
                      *value = (*bin2bcd) (ht->Day);
                      break;

                case CMOS_MONTH:
                      /* [1-12] on RTC, [1-12] in HOSTTIME */
                      *value = (*bin2bcd) (ht->Month);
                      break;

                case CMOS_YEAR:
                      *value = (*bin2bcd) (ht->Year % 100);
                      break;

                case CMOS_CENTURY:
                      *value = (*bin2bcd) (ht->Year / 100);
                      break;

                default:
                      *value = *cmos_register;
                      break;
                }

            host_ica_unlock();

	}
	note_trace2(CMOS_VERBOSE, "cmos_inb() - port %x, returning val %x",
		    port, *value);
}


GLOBAL void cmos_outb IFN2(io_addr, port, half_word, value)
{
	static IU32 pirUsec[] = {
		     0,
		  3906,
		  7812,
		   122,
		   244,
		   488,
		   976,
		  1953,
		  3906,
		  7812,
		 15625,
		 31250,
		 62500,
		125000,
		250000,
		500000
	};


	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port == 0x78 )
	    return;


	port = port & CMOS_BIT_MASK;	/* clear unused bits */

        note_trace2(CMOS_VERBOSE, "cmos_outb() - port %x, val %x", port, value);


        host_ica_lock();
        UpdateCmosTime();


        if (port == CMOS_PORT)
        {
                cmos_register = &cmos[cmos_index = (value & CMOS_ADDR_MASK)];

	} else if (port == CMOS_DATA)
        {
                switch (cmos_index)
		{
		case CMOS_REG_C:
		case CMOS_REG_D:
			/* These two registers are read only */
                        break;

                case CMOS_REG_B:

                        if (value & DM)
			{
				if (data_mode_yes)
				{
					bin2bcd = no_bin2bcd;
					bcd2bin = no_bcd2bin;
					data_mode_yes = FALSE;
				}
			} else
			{
				if (!data_mode_yes)
				{
					bin2bcd = yes_bin2bcd;
					bcd2bin = yes_bcd2bin;
					data_mode_yes = TRUE;
				}
			}
			if (value & _24_HR)
			{
				if (!twenty4_hour_clock)
				{
					_24to12 = no_24to12;
					_12to24 = no_12to24;
					twenty4_hour_clock = TRUE;
				}
			} else
			{
				if (twenty4_hour_clock)
				{
					_24to12 = yes_24to12;
					_12to24 = yes_12to24;
					twenty4_hour_clock = FALSE;
				}
                        }

                        if (value & SET) {
                            value  &= ~UIE;
                            }


                        if (*cmos_register != value) {

                            unsigned char ChangedBits;

                            ChangedBits = *cmos_register ^ value;
                            *cmos_register = value;

                            if (ChangedBits & PIE) {
                                if ((value & PIE) && rtc_period_mSeconds) {
                                    QueueRtcInterrupt(C_PF, FALSE);
                                    }
                                }

                            if (ChangedBits & (AIE | SET)) {
                                if (ChangedBits & SET) {
                                    RtcUpdateCycle = -1;
                                    cmos[CMOS_REG_A] &= ~UIP;
                                    RtcHostUpdateTime = RtcTickTime.tv_sec;
                                    }
                                ResetAlarm();
                                }
                            }

                        break;


		case CMOS_REG_A:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
                        rtc_period_mSeconds = pirUsec[*cmos_register & (RS3 | RS2 | RS1 | RS0)];

                        if ((*cmos_register & 0x70) != 0x20)
			{

                             note_trace1(CMOS_VERBOSE,
                                         "Cmos unsuported divider rate 0x%02x ignored",
                                         *cmos_register & 0x70);
                        }

                        break;


                case CMOS_SECONDS:
                        ht->Second = (*bcd2bin)(value);
                        break;

                case CMOS_MINUTES:
                        ht->Minute = (*bcd2bin)(value);
                        break;

                case CMOS_HOURS:
                        ht->Hour = (*_12to24)((*bcd2bin)(value));
                        break;

                case CMOS_DAY_WEEK:
                        /* Sunday = 1 on RTC, 0 in HOSTTIME */
                        ht->WeekDay  = (*bcd2bin)(value) - 1;
                        break;

                case CMOS_DAY_MONTH:
                        ht->Day = (*bcd2bin)(value);
                        break;

                case CMOS_MONTH:
                        /* [1-12] on RTC, [1-12] in HOSTTIME */
                        ht->Month = (*bcd2bin)(value);
                        break;

                case CMOS_YEAR:
                        ht->Year -=  ht->Year % 100;
                        ht->Year += (*bcd2bin)(value);
                        break;

                case CMOS_CENTURY:
                        ht->Year  %= 100;
                        ht->Year  += (*bcd2bin)(value) * 100;
                        break;

                default:
                        *cmos_register = value;
                        break;
                }



                /*
                 *  if one of the time fields changed Reset the alarm
                 */
                if (cmos_index <= CMOS_HR_ALARM) {
                    ResetAlarm();
                    }

        } else
	{
		note_trace2(CMOS_VERBOSE,
			    "cmos_outb() - Value %x to unsupported port %x", value, port);
        }

        host_ica_unlock();

}




GLOBAL void  cmos_equip_update IFN0()
{
	half_word       equip;

        host_ica_lock();

	if (verify_equip_byte(&equip))
	{
		note_trace0(CMOS_VERBOSE, "updating the equip byte silently");
		cmos[CMOS_EQUIP] = equip;
		/* correct the checksum */
		do_checksum();
        }

        host_ica_unlock();
}

/*
 * * General function to change the specified cmos byte to the specified
 * value
 *
 * MUST NOT BE USED FOR TIME. 14-Nov-1995 Jonle
 */
GLOBAL int cmos_write_byte IFN2(int, cmos_byte, half_word, new_value)
{
        if (cmos_byte >= 0 && cmos_byte <= 64)
        {

                note_trace2(CMOS_VERBOSE, "cmos_write_byte() byte=%x value=%x",
                            cmos_byte, new_value);

                host_ica_lock();
		cmos[cmos_byte] = new_value;
                do_checksum();
                host_ica_unlock();

                return (0);
	} else
	{
		always_trace2("ERROR: cmos write request: byte=%x value=%x",
			      cmos_byte, new_value);
		return (1);
        }

}
/*
 * * General fuunction to read specified cmos byte.
 *
 * MUST NOT BE USED FOR TIME. 14-Nov-1995 Jonle
 *
 */
GLOBAL int cmos_read_byte IFN2(int, cmos_byte, half_word *, value)
{

        if (cmos_byte >= 0 && cmos_byte <= 64)
        {
                host_ica_lock();
                *value = cmos[cmos_byte];
                host_ica_unlock();

		note_trace2(CMOS_VERBOSE, "cmos_read_byte() byte=%x value=%x",
			    cmos_byte, value);
		return (0);
	} else
	{
		always_trace1("ERROR: cmos read request: byte=%x", cmos_byte);
		return (1);
        }

}


void cmos_error IFN6(int, err, half_word, diag, half_word, equip,
	int, equip_err, half_word, floppy, half_word, disk)
{
	char            err_string[256];

	if (err & BAD_SHUT_DOWN)
	{
		strcpy(err_string, "shut ");
		note_trace0(CMOS_VERBOSE, "eek! someone's furtling with the shutdown byte");
	} else
		strcpy(err_string, "");

	if (err & BAD_REG_D)
	{
		strcat(err_string, "power ");
		note_trace0(CMOS_VERBOSE, " The battery is dead - this shouldn't happen!");
	}
	if (err & BAD_DIAG)
	{
		strcat(err_string, "diag ");
		if (diag & BAD_BAT)
			note_trace0(CMOS_VERBOSE, "bad battery");
		if (diag & BAD_CONFIG)
			note_trace0(CMOS_VERBOSE, "bad config");
		if (diag & BAD_CKSUM)
			note_trace0(CMOS_VERBOSE, "bad chksum");
		if (diag & W_MEM_SIZE)
			note_trace0(CMOS_VERBOSE, "memory size != configuration");
		if (diag & HF_FAIL)
			note_trace0(CMOS_VERBOSE, "fixed disk failure on init");
		if (diag & CMOS_CLK_FAIL)
			note_trace0(CMOS_VERBOSE, "cmos clock not updating or invalid");
	}
	if (err & BAD_EQUIP)
	{
		strcat(err_string, "equip ");

		if (equip_err)
		{
			if (equip_err & DRIVE_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect diskette - resetting");
			if (equip_err & DISPLAY_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect display - resetting");
			if (equip_err & NPX_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect npx - resetting CMOS");
			if (equip_err & RESVD_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect reserved bytes - resetting");
		}
	}
	if (err & BAD_FLOPPY)
	{
		strcat(err_string, "flop ");
		note_trace0(CMOS_VERBOSE, "incorrect diskette type - resetting");
	}
	if (err & BAD_DISK)
	{
		strcat(err_string, "disk ");
		note_trace0(CMOS_VERBOSE, "incorrect disk type - resetting");
	}
	if (err & BAD_BMS)
	{
		strcat(err_string, "bms ");
		note_trace0(CMOS_VERBOSE, "bad base memory - resetting");
	}
	if (err & BAD_XMS)
	{
		strcat(err_string, "extended memory ");
		note_trace0(CMOS_VERBOSE, "bad extended memory CMOS entry - resetting");
	}
	if (err & BAD_CHECKSUM)
	{
		strcat(err_string, "cksum ");
		note_trace0(CMOS_VERBOSE, "bad Checksum - resetting");
        }

        if (err & BAD_SHUT_DOWN)
		cmos[CMOS_SHUT_DOWN] = SHUT_INIT;
	if (err & BAD_REG_D)
		cmos[CMOS_REG_D] = REG_D_INIT;
	if (err & BAD_DIAG)
		cmos[CMOS_DIAG] = DIAG_INIT;
	if (err & BAD_EQUIP)
		cmos[CMOS_EQUIP] = equip;
	if (err & BAD_FLOPPY)
		cmos[CMOS_DISKETTE] = floppy;
	if (err & BAD_DISK)
		cmos[CMOS_DISK] = disk;
	if (err & BAD_BMS)
	{
		cmos[CMOS_B_M_S_LO] = BM_LO_INIT;
		cmos[CMOS_B_M_S_HI] = BM_HI_INIT;
	}
	if (err & BAD_XMS)
	{
                cmos[CMOS_E_M_S_LO] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10);
                cmos[CMOS_E_M_S_HI] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18);
	}
	/* Reset the Checksum if there is any error */
	if (err)
	{
		/* Do the Checksum */
		do_checksum();
	}
}


/*  rtc_nit
 *  Assumes Caller holds Ica lock
 */

GLOBAL void rtc_init(void)
{
     SYSTEMTIME st;

     RtcAlarmTime = 0;
     RtcLastAlarm = 0;
     RtcEoiPending  = FALSE;

     GetLocalTime(&st);
     ht->Second    = st.wSecond;
     ht->Minute    = st.wMinute;
     ht->Hour      = st.wHour;
     ht->Day       = st.wDay;
     ht->Month     = st.wMonth;
     ht->Year      = st.wYear;
     ht->WeekDay   = st.wDayOfWeek;

     host_GetSysTime(&RtcTickTime);
     RtcHostUpdateTime = RtcTickTime.tv_sec;

     ResetAlarm();
}



/*  RtcTick
 *  Assumes caller is holding Ica lock
 *
 *  WARNING: this routine is invoked by the hi-priority heartbeat
 *  thread at a rate of 18.2 time per sec with minimal variance.
 *  It is a polling routine, and because of the hi-freq and hi-priority
 *  it must be mean and lean, so don't do anything which could be
 *  done elsewhere.
 */

GLOBAL void RtcTick(struct host_timeval *time)
{
    /*
     *  Save away the RtcTick time stamp
     */
    RtcTickTime = *time;

    /*
     *  Check if time for Alarm interrupt
     */
    if (RtcAlarmTime && RtcAlarmTime <= RtcTickTime.tv_sec) {
        RtcLastAlarm = RtcTickTime.tv_sec;
        RtcAlarmTime = 0;
        QueueRtcInterrupt(C_AF, FALSE);
        }


    /*
     *  If we are in an update cycle complete it.
     *
     */

    if (RtcUpdateCycle >= 0) {
        RtcUpdateCycle = -1;
        cmos[CMOS_REG_A] &= ~UIP;
        if (cmos[CMOS_REG_B] & UIE) {
            QueueRtcInterrupt(C_UF, FALSE);
            }
        }

     /*
      *  If UIE active, then we have to keep HostTime in
      *  sync so we know when to do the Update End Interrupt.
      */
    else if (cmos[CMOS_REG_B] & UIE) {
        UpdateCmosTime();
        }

}



GLOBAL void cmos_init IFN0()
{
      io_addr         i;

      /* Set Up the cmos time bytes to be in BCD by default */
      bin2bcd = yes_bin2bcd;
      bcd2bin = yes_bcd2bin;
      data_mode_yes = TRUE;

      /* Set Up the cmos hour bytes to be 24 hour by default */
      _24to12 = no_24to12;
      _12to24 = no_12to24;
      twenty4_hour_clock = TRUE;


      /* attach the ports */
      io_define_inb(CMOS_ADAPTOR, cmos_inb);
      io_define_outb(CMOS_ADAPTOR, cmos_outb);

      for (i = CMOS_PORT_START; i <= CMOS_PORT_END; i++)
           io_connect_port(i, CMOS_ADAPTOR, IO_READ_WRITE);


      RegisterEOIHook(8,   // ICA_SLAVE, CPU_RTC_INT
                      RtcIntEoiHook
                      );
      rtc_init();
}


GLOBAL void cmos_pickup IFN0()
{
      /*
       *  Static init plus post is used instead of external files
       */
}


GLOBAL void cmos_post IFN0()
{
	/*
	 * The IBM POST checks the current settings in the CMOS with the
	 * equipment determined by writing to the hardware. Any discrepencies
	 * cause a bad config bit to be set and the user is then requested to
	 * run the Setup utility. Here we check the CMOS against the current
	 * settings in the config structure. If there is a discrepency we
	 * correct the CMOS silently.
	 */
	int             cmos_err, equip_err;
	half_word       diag, equip, floppy, disk;
	word            checksum = 0;
	int             i;


	cmos_err = 0;

	/* Check the Shutdown Byte */
	if (cmos[CMOS_SHUT_DOWN])
		cmos_err |= BAD_SHUT_DOWN;

	/* Check The Power */
	if (!(cmos[CMOS_REG_D] & VRT))
		cmos_err |= BAD_REG_D;

	/* Check The Diagnostic Status Byte */
	if (diag = cmos[CMOS_DIAG])
		cmos_err |= BAD_DIAG;

	/* Check the Equipment Byte */
	if (equip_err = verify_equip_byte(&equip))
		cmos_err |= BAD_EQUIP;

	/* Check the Floppy Byte */
	floppy = gfi_drive_type(1) | (gfi_drive_type(0) << 4);
	if (floppy != cmos[CMOS_DISKETTE])
		cmos_err |= BAD_FLOPPY;

	/* Check the Fixed Disk Type */
	 disk = 0x30;         /* Drive C type always 3 - then <<4 */
	 /* check whether D drive exists */
	 if ( *((CHAR *) config_inquire(C_HARD_DISK2_NAME, NULL)))
		 disk = 0x34;         /* 3 << 4 | 4 */
	if (disk != cmos[CMOS_DISK])
		cmos_err |= BAD_DISK;

	/* Check the Base Memory */
	if ((cmos[CMOS_B_M_S_LO] != BM_LO_INIT) || (cmos[CMOS_B_M_S_HI] != BM_HI_INIT))
		cmos_err |= BAD_BMS;

	/* Check the extended memory */
	if ((cmos[CMOS_E_M_S_LO] !=
	     (((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff)) ||
	    (cmos[CMOS_E_M_S_HI] !=
	     (((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff)))
		cmos_err |= BAD_XMS;

	/* Ignore the Contents of the Drive C and Drive D extended bytes */

	/* Do the Checksum */
	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	/* If the CMOS is OK test the checksum */
	/* If not, we will have to change it anyway */
	if (!cmos_err)
	{
		if ((checksum & 0xff) != cmos[CMOS_CKSUM_LO])
		{
			cmos_err |= BAD_CHECKSUM;
		}
		if ((checksum >> 8) != cmos[CMOS_CKSUM_HI])
		{
			cmos_err |= BAD_CHECKSUM;
		}
	}
	if (cmos_err)
            cmos_error(cmos_err, diag, equip, equip_err, floppy, disk);

	cmos[CMOS_REG_A] = REG_A_INIT;

        /* Check the Extended Memory */
        cmos[CMOS_U_M_S_LO] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10);
        cmos[CMOS_U_M_S_HI] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18);

	/* Set up the default cmos location */
	cmos_register = &cmos[cmos_index = CMOS_SHUT_DOWN];

}



/*
 *  WE DON'T EVER read or write a central cmos
 */
GLOBAL void cmos_update IFN0()
{
    ; /* do nothing */
}



/*(
========================= cmos_clear_shutdown_byte ============================
PURPOSE:
	To clear the "shutdown" byte in the CMOS which indicates that the
	next reset is not a "soft" one. (e.g. it is a CTRL-ALT-DEL or panel
	reset). This routine is needed (rather than just doung cmos_outb()
	since the processor might currently be in enhanced mode with io to CMOS
	virtualised.
INPUT:
OUTPUT:
===============================================================================
)*/

GLOBAL void cmos_clear_shutdown_byte IFN0()
{
        host_ica_lock();

        cmos[CMOS_SHUT_DOWN] = 0;

        host_ica_unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\dummy_nt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC Version 1.0
 *
 * Title         : dummy_int.c
 *
 * Decription    : Provide a function which emulates the dummy interrupt
 *                 within the IBM PC BIOS.
 *
 * Author        :
 *
 * Notes         :
 */

#ifdef SCCSID
static char SccsID[]="@(#)dummy_int.c	1.4 08/10/92 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif

void dummy_int()
{
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\ica.c ===
#include "insignia.h"
#include "host_def.h"

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC Revision 2.0
 *
 * Title        : ica.c
 *
 * Description  : Interrupt Controller Adapter
 *
 * Author       : Jim Hatfield
 *                (Upgraded to Rev. 2 by David Rees)
 *
 * Notes        : The ICA is responsible for maintaining a mapping
 *                between an Interrupt Request line and a vector
 *                number defining an entry in the Interrupt Vector
 *                table. On reciept of a hardware interrupt, it
 *                passes the appropriate vector number to the cpu.
 *
 *                The following functions are provided:
 *
 *                ica0_init()   - Initialise the first ICA (0 = Master)
 *                ica1_init()   - Initialise the first ICA (1 = Slave)
 *                ica_inb()     - Read a byte from an ICA register
 *                ica_outb()    - Write a command (byte) to the ICA
 *
 *                ica_hw_interrupt()    - Raise a hardware interrupt line
 *                ica_clear_int()       - Drop an interrupt line
 *                ica_intack()          - Acknowledge an interrupt
 *
 *                If DEBUG is defined, the following function
 *                is provided:
 *
 *                ica_dump()    - printd out contents of one element
 *                                of adapter_state[]
 *
 * Restrictions : This software emulates an Intel 8259A Priority Interrupt
 *                controller as defined in the Intel Specification pp 2-95 to
 *                2-112 and pp 2-114 to 2-181, except for the following:
 *
 *                1) Cascade mode is not supported at all. This mode requires
 *                   that there is more than one 8259A in a system, whereas
 *                   the PC/XT has only one.
 *
 *                2) 8080/8085 mode is not supported at all. In this mode the
 *                   8259A requires three INTA pulses from the CPU, and an 8088
 *                   only gives two. This would cause the device to lock up and
 *                   cease to function.
 *
 *                3) Level triggered mode is not supported. The device is
 *                   assumed to operate in edge triggered mode. A call of
 *                   ica_hw_interrupt by another adapter will cause a bit to
 *                   be latched into the Interrupt Request Register. A subsequent
 *                   call of ica_clear_int will cause the bit to be unlatched.
 *
 *                4) Buffered mode has no meaning in a software emulation and
 *                   so is ignored.
 *
 *                5) An enhancement is provided such that an adapter may raise
 *                   more than one interrupt in one call of ica_hw_interrupt.
 *                   The effect of this is that as soon as an INTACK is called
 *                   another interrupt is requested. If the chip is in Automatic
 *                   EOI mode then all of the interrupts will be generated in
 *                   one burst.
 *
 *                5a) A further enhancement is provided such that a delay
 *                   (a number of Intel instructions) can be requested before
 *                   the interrupt takes effect. This delay applies to every
 *                   interrupt if more than one is requested.
 *
 *                6) Special Fully Nested mode is not supported, since it is
 *                   a submode of Cascade Mode.
 *
 *                7) Polling is not completely implemented. When a Poll is
 *                   received and there was an interrupt request, the CPU INT
 *                   line (which must have been high) is pulled low. This
 *                   software does NOT reset the jump table address since there
 *                   may be a software interrupt outstanding. However it does
 *                   remove the evidence of a hardware interrupt, which will
 *                   cause the CPU to reset the table address itself.
 *
 *                When an unsupported mode is set, it is remembered for
 *                diagnostic purposes, even though it is not acted upon.
 *
 * Modifications for Revision 2.0 :
 *                1) Restrictions 1 and 6 are lifted. The PC-AT contains two
 *                   8259A interrupt controllers. The first (ICA 0) is in Master
 *                   mode, and the second (ICA 1) is in slave mode, and its
 *                   interrupts are directed to IR2 on the master chip. Hence
 *                   cascade mode must be supported to the extent necessary
 *                   to emulate this situation. Also, Special Fully Nested
 *                   Mode must work too. NB. The AT BIOS does NOT initialise
 *                   the Master 8259A to use Special Fully Nested Mode.
 *
 *                2) Restriction 5a (which is an enhancement) has been
 *                   eliminated. Apparently this never really achieved
 *                   its aim.
 *
 *                3) All the static variables declared in this module
 *                   have been placed within a structure, ADAPTER_STATE,
 *                   which is used as the type for a two-element array.
 *                   This allows the code to emulate two 8259As.
 *
 *                4) The routine ica_standard_vector_address() has been
 *                   eliminated, because it is not used anymore.
 *
 *                5) The function ica_init() has been split into two:
 *                   ica0_init() and ica1_init(). The initialization
 *                   via ICWs will now be done by a BIOS POST routine.
 *
 *                6) In the PC-AT, an 8259A determines its Master/Slave
 *                   state by examining the state of the SP/EN pin. We
 *                   simulate this by setting a flag 'ica_master' to
 *                   the appropriate value in the ica_init() routines.
 *
 *                7) The guts of the exported function ica_intack()
 *                   have been placed in an internal routine,
 *                   ica_accept(). This change allows for the INTAs
 *                   to work for both the master and slave 8259As.
 *
 *                8) Added debug function (ica_dump) to allow module
 *                   testing.
 *
 */

#ifdef SCCSID
LOCAL char SccsID[]="@(#)ica.c  1.38 10/19/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ICA.seg"
#endif

/* these ports have iret hooks enabled automatically - others will have to
 * define hooked_irets as parts of their configuration
 */
#if !defined(NTVDM)
#if defined(CPU_40_STYLE) || defined(GISP_CPU)
#define HOOKED_IRETS    /* switch on IRET hooks */
#endif
#endif

/*
 * SoftPC include files
 */
#include "xt.h"
#include "trace.h"
#include "ios.h"
#include CpuH
#include "ica.h"
#include "host.h"
#include "yoda.h"
#include "debug.h"

#ifdef NOVELL
extern void host_sigio_event IPT0();
#endif /* NOVELL */

/*
 * ============================================================================
 * Local Data
 * ============================================================================
 */

#if !defined(NTVDM)
/*
 *  Table of function pointers to access PIC routines
 */
void (*ica_inb_func) IPT2(io_addr, port, IU8 *, value);
void (*ica_outb_func) IPT2(io_addr, port, IU8, value);
void (*ica_hw_interrupt_func) IPT3(IU32, adapter, IU32, line_no,
        IS32, call_count);
void (*ica_clear_int_func) IPT2(IU32, adapter, IU32, line_no);
#endif

#if defined (CPU_40_STYLE) || defined (NTVDM)
#define ICA_INTACK_REJECT       -1
#endif

#ifndef PROD
char icamsgbuf[132];    /* Text buffer for debug messages */
#endif

/*
 * ============================================================================
 * Data relating to 8259A is replicated in two element array.
 * ============================================================================
 */

#ifdef NTVDM

#include <nt_eoi.h>

/*
 *  Risc 486 ntvdm does not use iret hooks
 *  x86 ntvdm (monitor) uses iret hooks only on comms
 *  and does not require protect mode enable\disable
 *  control over selectors, as app code cannot switch to
 *  protect mode without going thru dpmi.
 *
 *
 *  NTVDM has to export ICA definition for host and for X86 kernel.
 *  To make the namings of these externally referenced type/var more
 *  sensible but leaving the code substantially as the SoftPC base,
 *  use macros to 'edit' the adapter_state variable and type.
 *
 */
VDMVIRTUALICA VirtualIca[2];
#define adapter_state VirtualIca
#define ADAPTER_STATE VDMVIRTUALICA
#define EOI_HOOKS       /* switch on EOI hooks */





/*
 * for ntvdm and x86 build, this variable is shared between ntvdm and
 * the kernel(the kernel dispatches h/w interrupt and handles iret
 * hook inside kernel)
 */

#ifdef MONITOR
extern  ULONG iretHookMask;
extern  ULONG iretHookActive;
#endif


/*
 * noop the ica_lock_set fns, since ntvdm uses a real critical section
 */

#define ica_lock_set(x)
#define ica_lock_inc()
#define ica_lock_dec()


/*
 *  noop the swpic fnptrs
 */

#define SWPIC_inb          ica_inb
#define SWPIC_outb         ica_outb
#define SWPIC_hw_interrupt ica_hw_interrupt
#define SWPIC_clear_int    ica_clear_int


//
// to be removed:
//
// ica_hw_interrupt_func is referenced by emulator libs, so depsite the
// fact that we have removed the swpic function ptrs, we still
// have to provide a fn ptr for the emulator.
//
void
(*ica_hw_interrupt_func)(
    IU32 adapter,
    IU32 line_no,
    IS32 call_count
    )
    = ica_hw_interrupt;



#else   /* !NTVDM */

/* regular SoftPC definitions for ica */
ADAPTER_STATE adapter_state[2];

/* iret hook related defines */
#ifdef PROD
#define host_valid_iret_hook()  (TRUE)
#else           /* allow disabling of iret hooks whilst debugging */
#define host_valid_iret_hook()  (iretHooksEnabled)
#endif
#define host_bop_style_iret_hooks()     (FALSE)
#define host_iret_bop_table_addr(line)  (0)

/* crit section style locks only available on NT */
#define host_ica_lock()
#define host_ica_unlock()
#define host_ica_real_locks() (FALSE)

/* macro'ise simplistic ica lock scheme */

LOCAL IUM8      ica_lock;

#define ica_lock_set(x) ica_lock = x
#define ica_lock_inc()  ica_lock++
#define ica_lock_dec()  ica_lock--

#endif  /* NTVDM */

#ifdef HOOKED_IRETS             /* iret hook related variables */
LOCAL IBOOL  iretHooksEnabled = FALSE;
LOCAL IU16 iretHookMask = 0;    /* No interrupts hooked by default */
LOCAL IU16 iretHookActive = 0;
#endif /* HOOKED_IRETS */


/*
 * ============================================================================
 * Local defines
 * ============================================================================
 */

#define ICA_BASE_MASK   0xf8    /* Mask to get relevant bits out        */

/*
 * The following defines describe the usage of the mode bits
 */

#define ICA_IC4         0x0001  /* 0 -> no ICW4, 1 -> ICW4 will be sent */
#define ICA_SINGL       0x0002  /* 0 -> cascade, 1 -> single mode       */
#define ICA_ADI         0x0004  /* 0 -> 8 byte,  1 -> 4 byte interval   */
#define ICA_LTIM        0x0008  /* 0 -> edge,    1 -> level trigger     */
#define ICA_ICW1_MASK   0x000f  /* Mask to select above bits in mode    */

#define ICA_MPM         0x0010  /* 0 -> 8080,    1 -> 8086/8088 mode    */
#define ICA_AEOI        0x0020  /* 1 -> Automatic End-Of-Int Mode is on */
#define ICA_MS          0x0040  /* 0 -> slave,   1 -> master mode       */
#define ICA_BUF         0x0080  /* 1 -> Buffered Mode is on             */
#define ICA_SFNM        0x0100  /* 1 -> Special Fully Nested Mode is on */
#define ICA_ICW4_MASK   0x01f0  /* Mask to select above bits in mode    */

#define ICA_SMM         0x0200  /* 1 -> Special Mask Mode is on         */
#define ICA_RAEOI       0x0400  /* 1 -> Rotate on Auto EOI Mode is on   */
#define ICA_RIS         0x0800  /* 0 -> deliver IRR, 1 -> deliver ISR   */
#define ICA_POLL        0x1000  /* 1 -> Polling is now in progress      */

/*
 * ============================================================================
 * Macros
 * ============================================================================
 */
#define ICA_PORT_0                                                      \
        (adapter ? ICA1_PORT_0 : ICA0_PORT_0)

#define ICA_PORT_1                                                      \
        (adapter ? ICA1_PORT_1 : ICA0_PORT_1)

#define adapter_for_port(port)                                          \
        ((port >= ICA0_PORT_START && port <= ICA0_PORT_END)             \
                ? ICA_MASTER                                            \
                : ICA_SLAVE                                             \
        )

/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

IS32 ica_accept IPT1(IU32, adapter);

#ifdef HOOKED_IRETS
extern IU32 ica_iret_hook_needed IPT1(IU32, line);
#endif

#if !defined (NTVDM)
void
SWPIC_init_funcptrs IFN0()
{
        /*
         *  initialize PIC access functions for SW [emulated] PIC
         */
        ica_inb_func                    = SWPIC_inb;
        ica_outb_func                   = SWPIC_outb;
        ica_hw_interrupt_func           = SWPIC_hw_interrupt;
        ica_clear_int_func              = SWPIC_clear_int;
}
#endif

/*
 *      Please note that ica_eoi is called by SUN_VA code and thus needs to
 *      be global.
 */

GLOBAL void
ica_eoi IFN3(IU32, adapter, IS32 *, line, IBOOL, rotate)
{
    /*
     * End Of Interrupt. If *line is -1, this is a non-specific EOI
     * otherwise it is the number of the line to clear. If rotate is
     * TRUE, then set the selected line to lowest priority.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IS32 i, j;
    IU8 bit;
    IS32 EoiLineNo = -1;        /* if EOI_HOOKS defined this is used otherwise */
                                /* rely on compiler elimination as not read */

    if (*line == -1)            /* non specific EOI */
    {
        /*
         * Clear the highest priority bit in the ISR
         */
        for(i = 0; i < 8; i++)
        {
            j = (asp->ica_hipri + i) & 7;
            bit = (1 << j);
            if (asp->ica_isr & bit)
            {
                asp->ica_isr &= ~bit;
                *line = j;
                EoiLineNo = (IS32)*line;
                break;
            }
        }
    }
    else                        /* EOI on specific line */
    {
        bit = 1 << *line;
        if (asp->ica_isr & bit)
                EoiLineNo = *line;
        asp->ica_isr &= ~bit;
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
        sprintf(icamsgbuf, "**** CPU END-OF-INT %c (%d) ****", (adapter == ICA_MASTER? 'M': 'S'), *line);
        trace(icamsgbuf, DUMP_NONE);
    }
#endif

    if (rotate && (*line >= 0))
        asp->ica_hipri = (USHORT)((*line + 1) & 0x07);

#ifdef EOI_HOOKS
    /*
     * CallOut to device registered EOI Hooks
     */
    if (EoiLineNo != -1)
        host_EOI_hook(EoiLineNo + (adapter << 3), asp->ica_count[EoiLineNo]);
#endif /* EOI_HOOKS */

    /*
     * There may be a lower priority interrupt pending, so check
     */
    if ((i = ica_scan_irr(adapter)) & 0x80)
           ica_interrupt_cpu(adapter, i & 0x07);

}

GLOBAL IU8
ica_scan_irr IFN1(IU32, adapter)
{
    /*
     * This is the routine which will decide whether an interrupt should
     * be generated. It scans the IRR, the IMR and the ISR to determine
     * whether one is possible. It is also called when the processor has
     * accepted the interrupt to see which one to deliver.
     *
     * A bit set in the IRR will generate an interrupt if:
     *
     * 1) The corresponding bit in the IMR is clear
     *    AND
     * 2) The corresponding bit and all higher priority bits in the ISR are
     *     clear (unless Special Mask Mode, in which case ISR is ignored)
     *
     * The highest priority set bit which meets the above conditions (if any)
     * will be returned with an indicator bit (in the style needed by a Poll)
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU32 i, j;
    IUM8 bit, irr_and_not_imr, active_isr;
    IUM8 iret_hook_mask;

#if defined (NTVDM)

#ifdef MONITOR
    iret_hook_mask = (IU8)((iretHookActive | DelayIrqLine) >> (adapter << 3));
#else
    iret_hook_mask = (IU8)(DelayIrqLine >> (adapter << 3));
#endif

#else  /* !NTVDM */
    /* if iret hooks are not being used, iretHookActive will always be 0 */
    iret_hook_mask = (IU8)(iretHookActive >> (adapter << 3));
#endif

    /*
     * A bit can only cause an int if it is set in the IRR
     * and clear in the IMR. Generate a set of such bits
     */

    irr_and_not_imr = asp->ica_irr & ~(asp->ica_imr | iret_hook_mask);

    /*
     * Does the current mode require the ica to prevent
     * interrupts if that line is still active (i.e. in the isr)?
     */
    if (asp->ica_mode & (ICA_SMM|ICA_SFNM))
    {
        /* Neither Special Mask Mode nor Special Fully Nested Mode
         * block interrupts using bits in the isr.
         *
         * SMM is the mode used by Windows95 and Win3.1/E
         *
         * Note that "Undocumented PC" says SFNM is not used by PCs and
         * is only intended for larger systems with > 2 ICAs
         */
        active_isr = 0;
    }
    else
    {
        /* Normal Case: Used by DOS and Win3.1/S
         * In this mode the isr prevents interrupts.
         */
        active_isr = asp->ica_isr;
    }

    /*
     * Check the trivial case first: no bits set
     */

    if (irr_and_not_imr == 0)
        return(7);

    for(i = 0; i < 8; i++)
    {
        j = (asp->ica_hipri + i) & 7;
        bit = (1 << j);
        if (active_isr & bit)
            return(7);          /* No nested interrupt possible */

        if (irr_and_not_imr & bit)
            return((IU8)(0x80 + j));   /* Return line no. + indicator */
    }
    /* Strange. We should not have got here.  */
    return(7);
}


IS32 ica_accept IFN1(IU32, adapter)
{
    /*
     * NOTE: There is no need to set the lock here, since we are called
     *       either from the cpu interrupt code, or from ica_inb, both of
     *       which will have set it for us.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU32        line1;
    IS32        line2;
    IU8         bit;

    /*
     * Drop the INT line
     */

    asp->ica_cpu_int = FALSE;

    /*
     * Scan the IRR to find the line which we will use.
     * There should be one set, but check anyway
     * It there isn't, use line 7.
     */

    if (!((line1 = (IU32)ica_scan_irr(adapter)) & 0x80))
    {
        note_trace1(ICA_VERBOSE, "ica_int_accept(%c): No interrupt found!!", (adapter == ICA_MASTER? 'M': 'S'));

        /* we should really return a spurious interrupt - ie interrupt
         * on line 7, but this is not neccessary and can cause problems
         * for some programs (eg DOOM with a mouse)
         */
#if 0
        line1 = 7;
#endif

        /* Skip spurious ints. These are any that are caused by clearing an
         * int when the cpu has already registered that there is an int to
         * service.
         *
         * This used to be "#if defined(NTVDM) && defined(MONITOR)"
         * and tried to remove the performance impact on the monitor.
         */
        return(-1);

    }
    else
    {
        line1 &= 0x07;

#if defined(CPU_40_STYLE) && !defined (NTVDM)
        /* allow some recursion within hooked ISRs */
        if (asp->isr_depth[line1] >= MAX_ISR_DEPTH)
        {
                /* disable further interrupts on this line */
                iretHookActive |= 1 << ((adapter << 3) + line1);

                /* reached maximum ISR recursion - don't do interrupt */
                return((IS32)-1);
        }
#endif /* CPU_40_STYLE */

        bit = (1 << line1);
        asp->ica_isr |= bit;

        if (--(asp->ica_count[line1]) <= 0)
        {                               /* If count exhausted for this line */
            asp->ica_irr &= ~bit;       /* Then finally clear IRR bit   */
            asp->ica_count[line1] = 0;          /* Just in case         */
        }
    }

    /*
     * If we are in Automatic EOI mode, then issue a non-specific EOI
     */

    if (asp->ica_mode & ICA_AEOI)
    {
        line2 = -1;
        ica_eoi(adapter, &line2, (asp->ica_mode & ICA_RAEOI) == ICA_RAEOI);
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
        sprintf(icamsgbuf, "**** CPU INTACK %c (%d) ****", (adapter == ICA_MASTER? 'M': 'S'), line1 + asp->ica_base);
        trace(icamsgbuf, DUMP_NONE);
    }
#endif

    return((IS32)line1);
}

GLOBAL void
ica_interrupt_cpu IFN2(IU32, adapter, IU32, line)
{
    /*
     * This routine actually interrupts the CPU. The method it does this
     * is host specific, and is done in host_cpu_interrupt().
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];

    /*
     * If the INT line is already high, do nothing.
     */

    if (asp->ica_cpu_int)
    {
#ifndef PROD
        if ((io_verbose & ICA_VERBOSE) && ((IU32)(asp->ica_int_line) != line))
        {
            sprintf(icamsgbuf,"******* INT LINE ALREADY HIGH %c line=%d ****", (adapter == ICA_MASTER? 'M': 'S'), asp->ica_int_line);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
        asp->ica_int_line = line;

        return;
    }

    /*
     * Set the ICA internal flags
     */

    asp->ica_int_line = line;
    asp->ica_cpu_int = TRUE;

    if (asp->ica_master)                /* If ICA is Master */
    {
#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "**** CPU INTERRUPT (%x) ****", line);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif

        /*
         *  Set the 'hardware interrupt' bit in cpu_interrupt_map
         */

#ifndef CPU_40_STYLE    /* No globals in the 4.0 I/F! */
        cpu_int_delay = 0;
#endif

        host_set_hw_int();

#ifdef A2CPU
        host_cpu_interrupt();
#endif

#ifdef NTVDM
        /* call wow routine to check for application unable to service ints */
        WOWIdle(FALSE);
#endif

    }
    else
    {                           /* If ICA is Slave */
#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "**** SLAVE ICA INTERRUPT (%x) ****", line);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
        /*
         * Signal the Master ICA.
         * NB. A kludge is used here. We know that we have
         *     been called from ica_hw_interrupt(), and
         *     therefore ica_lock will be at least 1. To
         *     get the effect we want, it is necessary to
         *     reduce the value of ica_lock for the duration
         *     of the call to ica_hw_interrupt.
         *
         * If the host has implemented critical section style locking
         * then the above kludge does not apply.
         */

        ica_lock_dec();

        ica_hw_interrupt(ICA_MASTER, asp->ica_ssr, 1);

        ica_lock_inc();
    }
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */
void SWPIC_inb IFN2(io_addr, port, IU8 *, value)
{
#ifndef PROD
    char *reg_name;
#endif /* nPROD */
    IU32 adapter       = adapter_for_port(port);
    ADAPTER_STATE *asp = &adapter_state[adapter];

    /*
     * First check the validity of the port
     */

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
        if ((port != ICA_PORT_0) && (port != ICA_PORT_1))
        {
            sprintf(icamsgbuf, "ica_inb: bad port (%x)", port);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif

    /*
     * If we are in the middle of a Poll command, then respond to it
     */

    if (asp->ica_mode & ICA_POLL)
    {
        ica_lock_set(1);                        /* Lock out signal handlers */
        host_ica_lock();                        /* real lock if supported */

        asp->ica_mode &= ~ICA_POLL;

        if ((*value = ica_scan_irr(adapter)) & 0x80) /* See if there is one */
        {
            (void) ica_accept(adapter);         /* Acknowledge it       */
            host_clear_hw_int();
            /*  cpu_int_call_count[0] = 0;         Not used anymore     */
        }

        ica_lock_set(0);
        host_ica_unlock();                      /* free lock if supported */

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "ica_inb: responding to Poll with %x", *value);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
    }

    /*
     * If the address is ICA_PORT_0, then deliver either the IRR or the ISR,
     * depending on the setting of mode bit ICA_RIS. If the address is
     * ICA_PORT_1, then deliver the IMR
     */

    else
    {
        if (port == ICA_PORT_0)
            if (asp->ica_mode & ICA_RIS)
            {
                *value = asp->ica_isr;
#ifndef PROD
                reg_name = "ISR";
#endif /* nPROD */
            }
            else
            {
                *value = asp->ica_irr;
#ifndef PROD
                reg_name = "IRR";
#endif /* nPROD */
            }
        else
        {
            *value = asp->ica_imr;
#ifndef PROD
            reg_name = "IMR";
#endif /* nPROD */
        }

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "ica_inb: delivered %s value %x", reg_name, *value);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
    }
}

void SWPIC_outb IFN2(io_addr, port, IU8, value)
{

    /*
     * Data sent may either be ICWs or OCWs. All of the OCWs are recognisable
     * individually, but only ICW1 may be recognised directly. It will always
     * be followed by ICW2, and optionally by ICW3 and/or ICW4, depending upon
     * exactly what sort of ICW1 was sent. We use a sequence variable to track
     * this and make sure we interpret the data correctly. After power-on, we
     * ignore everything until we get an ICW1.
     */

    /*
     * Some defines to detect command types
     */
#define ICA_SMM_CMD     0x40
#define ICA_POLL_CMD    0x04
#define ICA_RR_CMD      0x02

    /*
     * Local variables
     */
    IU32 adapter               = adapter_for_port(port);
    ADAPTER_STATE *asp = &adapter_state[adapter];

    SAVED IS32 sequence[2]      /* -1 -> power is on but no ICWs received */
                  = { -1, -1 }; /*  0 -> fully initialised, OK to proceed */
                                /*  2 -> ICW1 received, awaiting ICW2     */
                                /*  3 -> ICW2 received, awaiting ICW3     */
                                /*  4 -> awaiting ICW4                    */

    IU32 i;             /* Counter                                */
    IS32 line;                  /* Interrupt line number                  */

    /*
     * First check the validity of the port
     */

#if defined(NEC_98)
    if ((port & 0xfffc) != ICA_PORT_0)
#else    //NEC_98
    if ((port & 0xfffe) != ICA_PORT_0)
#endif   //NEC_98
    {
#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "ica_outb: bad port (%x)", port);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
        return;
    }

    /*
     * If we get an ICW1 then we are into initialisation
     */

#if defined(NEC_98)
    if (((port & 2) == 0) && (value & 0x10))
#else    //NEC_98
    if (((port & 1) == 0) && (value & 0x10))            /****  ICW1  ****/
#endif   //NEC_98
    {
        asp->ica_irr  = 0;      /* Clear all pending interrupts         */
        asp->ica_isr  = 0;      /* Clear all in-progress interrupts     */
        asp->ica_imr  = 0;      /* Clear the mask register              */
        asp->ica_ssr  = 0;      /* No slaves selected                   */
        asp->ica_base = 0;      /* No base address                      */

        asp->ica_hipri = 0;     /* Line 0 is highest priority           */

        asp->ica_mode = value & ICA_ICW1_MASK;
                                /* Set supplied mode bits from ICW1     */

        for(i = 0; i < 8; i++)
            asp->ica_count[i] = 0;      /* Clear IRR extension          */

        asp->ica_cpu_int = FALSE;       /* No CPU INT outstanding       */
        sequence[adapter] = 2;          /* Prepare for the rest of the sequence */

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
            trace("ica_outb: ICW1 detected, initialisation begins", DUMP_NONE);
#endif
        return;
    }

/**/

    /*
     * Lock out calls from signal handlers
     */

    ica_lock_set(1);
    host_ica_lock();                    /* real lock if supported */

    /*
     * It wasn't an ICW1, so use the sequence variable to direct our activities
     */

    switch(sequence[adapter])
    {
    case  0:                    /* We are expecting an OCW      */
#if defined(NEC_98)
        if (port & 2)           /* Odd address -> OCW1          */
#else    //NEC_98
        if (port & 1)           /* Odd address -> OCW1          */
#endif   //NEC_98
        {
            asp->ica_imr = value & 0xff;
#ifndef PROD
            if (io_verbose & ICA_VERBOSE)
            {
                sprintf(icamsgbuf, "ica_outb: new %c IMR: %x", (adapter == ICA_MASTER? 'M': 'S'), value);
                trace(icamsgbuf, DUMP_NONE);
            }
#endif
            if (asp->ica_cpu_int)
            {
                /* We might have masked out a pending interrupt */
                if (asp->ica_imr & (1 << asp->ica_int_line))
                {
                        asp->ica_cpu_int = FALSE;       /* No CPU INT outstanding       */
                        if (asp->ica_master)
                                host_clear_hw_int();
                        else
                                ica_clear_int(ICA_MASTER,asp->ica_ssr);
                }
            }
            /*
             * We might have unmasked a pending interrupt
             */
            if (!asp->ica_cpu_int && (line = ica_scan_irr(adapter)) & 0x80)
                ica_interrupt_cpu(adapter, line & 0x07); /* Generate interrupt */
        }
        else
/**/
        if ((value & 8) == 0)   /* Bit 3 unset -> OCW2          */
        {
            switch ((value >> 5) & 0x07)
            {
            case 0:             /* Clear rotate in auto EOI     */
                asp->ica_mode &= ~ICA_RAEOI;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    trace("ica_outb: Clear Rotate in Auto EOI",DUMP_NONE);
#endif
                break;

            case 1:             /* Non-specific EOI             */
                line = -1;      /* -1 -> highest priority       */
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    trace("ica_outb: Non-specific EOI", DUMP_NONE);
#endif
                ica_eoi(adapter, &line, FALSE);
                break;

            case 2:             /* No operation                 */
                break;

            case 3:             /* Specific EOI command         */
                line  = value & 0x07;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                {
                    sprintf(icamsgbuf, "ica_outb: Specific EOI, line %d", line);
                    trace(icamsgbuf, DUMP_NONE);
                }
#endif
                ica_eoi(adapter, &line, FALSE);
                break;

            case 4:             /* Set rotate in auto EOI mode  */
                asp->ica_mode |= ICA_RAEOI;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    trace("ica_outb: Set Rotate in Auto EOI",DUMP_NONE);
#endif
                break;

            case 5:             /* Rotate on non-specific EOI   */
                line = -1;      /* -1 -> non specific           */
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    trace("ica_outb: Rotate on Non-specific EOI",DUMP_NONE);
#endif
                ica_eoi(adapter, &line, TRUE);
                break;

            case 6:             /* Set priority                 */
                asp->ica_hipri = (value + 1) & 0x07;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                {
                    sprintf(icamsgbuf, "ica_outb: Set Priority, line %d", value & 0x07);
                    trace(icamsgbuf, DUMP_NONE);
                }
#endif
                break;

            case 7:             /* Rotate on specific EOI       */
                line  = value & 0x07;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                {
                    sprintf(icamsgbuf, "ica_outb: Rotate on specific EOI, line %d", line);
                    trace(icamsgbuf, DUMP_NONE);
                }
#endif
                ica_eoi(adapter, &line, TRUE);
                break;
            }
        }
/**/
        else                    /* Bit 3 set -> OCW3            */
        {
            if (value & ICA_SMM_CMD)    /* Set/unset SMM        */
            {
                asp->ica_mode = (asp->ica_mode & ~ICA_SMM) | (((IU16)value << 4) & ICA_SMM);
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    if (asp->ica_mode & ICA_SMM)
                        trace("ica_outb: Special Mask Mode set", DUMP_NONE);
                    else
                        trace("ica_outb: Special Mask Mode unset", DUMP_NONE);
#endif
            }

            if (value & ICA_POLL_CMD)   /* We are being polled  */
            {
                asp->ica_mode |= ICA_POLL;
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    trace("ica_outb: Poll detected!", DUMP_NONE);
#endif
            }
            else
            if (value & ICA_RR_CMD)     /* Select IRR or ISR    */
            {
                asp->ica_mode = (asp->ica_mode & ~ICA_RIS) | (((IU16)value << 11) & ICA_RIS);
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                    if (asp->ica_mode & ICA_RIS)
                        trace("ica_outb: ISR selected", DUMP_NONE);
                    else
                        trace("ica_outb: IRR selected", DUMP_NONE);
#endif
            }
        }
        break;

/**/
    case  2:                    /* We are expecting a ICW2              */
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
        {
#ifndef PROD
            sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW2",
                         (unsigned)port);
            trace(icamsgbuf, DUMP_NONE);
#endif
        }
        else
        {
            asp->ica_base = value & ICA_BASE_MASK;
#ifndef PROD
            if (io_verbose & ICA_VERBOSE)
            {
                sprintf(icamsgbuf, "ica_outb: vector base set to %x", asp->ica_base);
                trace(icamsgbuf, DUMP_NONE);
            }
#endif
            if (!(asp->ica_mode & ICA_SINGL))
                sequence[adapter] = 3;
            else
            if (asp->ica_mode & ICA_IC4)
                sequence[adapter] = 4;
            else
                sequence[adapter] = 0;
        }
        break;

/**/
    case  3:                    /* We are expecting a ICW3              */
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
        {
#ifndef PROD
            sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW3",
                         (unsigned)port);
            trace(icamsgbuf, DUMP_NONE);
#endif
        }
        else
        {
            asp->ica_ssr = value & 0xff;
#ifndef PROD
            if (io_verbose & ICA_VERBOSE)
            {
                sprintf(icamsgbuf, "ica_outb: slave register set to %x", asp->ica_ssr);
                trace(icamsgbuf, DUMP_NONE);
            }
#endif
            if (asp->ica_mode & ICA_IC4)
                sequence[adapter] = 4;
            else
                sequence[adapter] = 0;
        }
        break;

/**/
    case  4:                    /* We are expecting a ICW4              */
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
        {
#ifndef PROD
            sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW4",
                         (unsigned)port);
            trace(icamsgbuf, DUMP_NONE);
#endif
        }
        else
        {
            asp->ica_mode = (asp->ica_mode & ~ICA_ICW4_MASK)
                           | (((IU16)value << 4) &  ICA_ICW4_MASK);
#ifndef PROD
            if (io_verbose & ICA_VERBOSE)
            {
                sprintf(icamsgbuf, "ica_outb: IC4 value %x", value);
                trace(icamsgbuf, DUMP_NONE);
            }
            /*
             * Check the mode bits for sensible values
             */
            if (!(asp->ica_mode & ICA_MPM))
                trace("ica_outb: attempt to set up 8080 mode!", DUMP_NONE);

            if ((asp->ica_mode & ICA_BUF) && !(asp->ica_mode & ICA_MS)
                                     && !(asp->ica_mode & ICA_SINGL))
                trace("ica_outb: attempt to set up slave mode!", DUMP_NONE);
#endif
        }
        sequence[adapter] = 0;
        break;

    case -1:            /* Power on but so far uninitialised    */
#ifndef PROD
        sprintf(icamsgbuf, "ica_outb: bad port/value (%x/%x) while awaiting ICW1",
                     (unsigned)port, value);
        trace(icamsgbuf, DUMP_NONE);
#endif
        break;

    default:            /* This cannot happen                   */;
#ifndef PROD
        trace("ica_outb: impossible error, programmer brain-dead", DUMP_NONE);
#endif
    }

    ica_lock_set(0);
    host_ica_unlock();                  /* free lock if supported */
}


void SWPIC_hw_interrupt IFN3(IU32, adapter, IU32, line_no, IS32, call_count)
{
    /*
     * This routine is called by an adapter to raise an interrupt line.
     * It may or may not interrupt the CPU. The CPU may or may not take
     * any notice.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU8 bit;
    IU32 line;
#ifdef CPU_40_STYLE
    IS32 depth, *progress;
#endif  /* CPU_40_STYLE */

#ifndef PROD
#if defined(NEC_98)
    SAVED char *linename[2][8] =
    {
        {
            "TIMER",
            "KEYBOARD",
            "CRTV",
            "INT0",
            "COM1",
            "INT1",
            "INT2",
            "reserved"
        },
        {
            "PRINTER",
            "INT3",
            "INT41",
            "INT42",
            "INT5",
            "INT6",
            "NDP",
            "reserved"
        }
    };
#else    //NEC_98
    SAVED char *linename[2][8] =
    {
        {
            "IRQ  0 TIMER",
            "IRQ  1 KEYBOARD",
            "IRQ  2 SLAVE_ICA",
            "IRQ  3 COM2",
            "IRQ  4 COM1",
            "IRQ  5 PARALLEL2",
            "IRQ  6 DISKETTE",
            "IRQ  7 PARALLEL1"
        },
        {
            "IRQ  8 REALTIME CLOCK",
            "IRQ  9 MOUSE",
            "IRQ 10 SOUND DRIVER",
            "IRQ 11 SOFTNODE",
            "IRQ 12 ASPI",
            "IRQ 13 COPROCESSOR",
            "IRQ 14 FIXED DISK",
            "IRQ 15 reserved"
        }
    };
#endif   //NEC_98
#endif

    /*
     * vddsvc.h defines the NTVDM exported call to this function as:
     *    call_ica_hw_interrupt(int, BYTE, int);
     * So, the line_no, being defined here as IU32 is not compatible with
     * VDD's or other DLL's which call through here. Rather than change
     * all the references to it in the source, I'm just going to AND off
     * the potential garbage here.
     */
    line_no &= 0xff;

    host_ica_lock();

#ifndef PROD
    if (io_verbose & ICA_VERBOSE_LOCK)
    {
        if(adapter>1 || line_no>7)
                printf("**** H/W INTERRUPT (%sx%d) [%d:%d] ****\n",
                       linename[adapter][line_no], call_count,adapter,line_no);
    }
#endif

    /*
     * If there is a request already outstanding on this line, then leave
     * the IRR alone, but make a pass through anyway to action previously
     * received but locked calls (see below for details).
     */

    bit = (1 << line_no);
    if (!(asp->ica_irr & bit))
    {
        asp->ica_irr |= bit;            /* Pray we don't get a signal here! */

    }
    asp->ica_count[line_no] += call_count;      /* Add the further requests */

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
        sprintf(icamsgbuf, "**** H/W INTERRUPT (%sx%d) ****",
                         linename[adapter][line_no], call_count);
        trace(icamsgbuf, DUMP_NONE);
    }
#endif

    /*
     * Check the lock flag. If it is set, then this routine is being called
     * from a signal handler while something else is going on. We can't just
     * ignore the call since we might lose a keyboard interrupt. What we do
     * is to set ica_irr and ica_count as normal (ie code above), then return.
     * The next interrupt which gets through this test will cause the stored
     * interrupt to be processed. This means that any code which plays around
     * with ica_irr and ica_count should take a copy first to prevent problems.
     *
     * If the host supports real (critical section style) locks, then we won't
     * get here in the above situation, so eliminate the following test. That
     * leaves both primitive & real lock styles intact.
     */

#ifndef NTVDM
    if (!host_ica_real_locks())
    {
        if (ica_lock_inc())
        {
#ifndef PROD
                if (io_verbose & ICA_VERBOSE_LOCK)
                {
                        sprintf(icamsgbuf, "*");
                        trace(icamsgbuf, DUMP_NONE);
                }
#endif
                ica_lock_dec();
                return;
        }
    }
#endif

#if defined (CPU_40_STYLE) && !defined(NTVDM)
    depth = asp->isr_depth[line_no];
    if (depth > 0)
    {
        progress = &asp->isr_progress[line_no][depth];
        *progress += 1;         /* move progress along */
        if ((*progress - *(progress - 1)) > MAX_INTR_DELTA_FOR_LOST_HOOK)
        {
                asp->isr_time_decay[line_no][asp->isr_depth[line_no]] = 0;
                --asp->isr_depth[line_no];      /* reduce depth */

                /* clear CPU side stack */
                if (!host_bop_style_iret_hooks())
                        PurgeLostIretHookLine(((adapter << 3) + line_no) + 1, depth - 1);
                /* permit intrs on this line */
                iretHookActive &= ~(1 << ((adapter << 3) + line_no));
        }
    }
#endif  /* CPU_40_STYLE */

    /*
     * Now scan the IRR to see if we can raise a CPU interrupt.
     */

    if ((line = ica_scan_irr(adapter)) & 0x80)
        ica_interrupt_cpu(adapter, line & 0x07);

    ica_lock_set(0);
    host_ica_unlock();
}

void SWPIC_clear_int IFN2(IU32, adapter, IU32, line_no)
{
    /*
     * This routine is called by an adapter to lower an input line.
     * The line will then not interrupt the CPU, unless of course
     * it has already done so.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU8 bit, irr_check;

    host_ica_lock();
    /*
     * Decrement the call count and if zero clear the bit in the IRR
     */

    bit = (1 << line_no);
    if (--(asp->ica_count[line_no]) <= 0)
    {
        irr_check = asp->ica_irr;
        asp->ica_irr &= ~bit;
        asp->ica_count[line_no] = 0;            /* Just in case */
        if ((!asp->ica_master) && (ica_scan_irr(adapter)==7))
                {
                asp->ica_cpu_int=FALSE;
                ica_clear_int(ICA_MASTER,asp->ica_ssr);
                }
#ifdef EOI_HOOKS
        /*
        // If the line has a pending interrupt, call the eoi hook
        // to release any device waiting for an EoiHook.
        */
        if ((irr_check & bit) != 0)
                host_EOI_hook(line_no + (adapter << 3), -1);
#endif  /* EOI_HOOKS */
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
        sprintf(icamsgbuf, "**** ICA_CLEAR_INT, line %d ****", line_no);
        trace(icamsgbuf, DUMP_NONE);
    }
#endif

    host_ica_unlock();
}

/*
 * The emulation code associated with this interrupt line has decided it
 * doesn't want to generate any more interrupts, even though the ICA may not
 * have got through all the interrupts previously requested.
 * Simply clear the corresponding interrupt count.
 */
void ica_hw_interrupt_cancel IFN2(IU32, adapter, IU32, line_no)
{
        host_ica_lock();
        adapter_state[adapter].ica_count[line_no] = 0;
        host_ica_unlock();
        ica_clear_int(adapter, line_no);
}

#if defined(HOOKED_IRETS) || defined(NTVDM)
GLOBAL IS32
ica_intack IFN1(IU32 *, hook_address)
#else
GLOBAL IS32
ica_intack IFN0()
#endif  /* HOOKED_IRETS */
{
    /*
     * This routine is called by the CPU when it wishes to acknowledge
     * an interrupt. It is equivalent to the INTA pulses from the real
     * device. The interrupt number is delivered.
     * It can also be called from ica_inb as a Poll.
     *
     * Modification for Rev. 2:
     *
     * It is now necessary to detect whether a slave interrupt controller
     * is attached to a particular interrupt request line on the master
     * ICA. If a slave exists, it must be accessed to discover the
     * interrupt vector.
     */
    IS32 line;          /* the IRQ line */
    IU8 bit;            /* bitmask for 'line' */
    IS32 int_no;        /* The interrupt number to return, 0-255 */
    ADAPTER_STATE *asp; /* working pointer to adapter */

    host_ica_lock();    /* real lock if supported */

    line = ica_accept(ICA_MASTER);

#if defined (CPU_40_STYLE) || defined (NTVDM)
    if (line == -1)     /* skip any spurious ints */
    {
        host_ica_unlock();
        return ICA_INTACK_REJECT;
    }
#endif  /* CPU_40_STYLE */

    bit  = (1 << line);
    if (adapter_state[ICA_MASTER].ica_ssr & bit)
    {
        line = ica_accept(ICA_SLAVE);
        int_no = line + adapter_state[ICA_SLAVE].ica_base;

#if defined (CPU_40_STYLE) || defined (NTVDM)
        if (line == -1) /* skip any spurious ints */
        {
            adapter_state[ICA_MASTER].ica_isr &= ~bit;
            host_ica_unlock();
            return ICA_INTACK_REJECT;
        }
#endif  /* CPU_40_STYLE */

#if defined(CPU_40_STYLE) && !defined(NTVDM)
        /* do callback processing for action interrupt */
        asp = &adapter_state[ICA_SLAVE];
        if (asp->callback_fn[line] != NO_ICA_CALLBACK)
        {
            /* invoke callback function */
            (*asp->callback_fn[line])(asp->callback_parm[line]);
            /* clear callback state reject intack call */
            asp->callback_fn[line] = NO_ICA_CALLBACK;
            host_ica_unlock();
            return ICA_INTACK_REJECT;
        }
#endif  /* CPU_40_STYLE */

        line += 8;      /* make in range 8 - 15 for iret hook */

    }
    else
    {
        asp = &adapter_state[ICA_MASTER];       /* also excuse to use asp */

#if defined(CPU_40_STYLE) &&  !defined(NTVDM)
        /* do callback processing for action interrupt */
        if (asp->callback_fn[line] != NO_ICA_CALLBACK)
        {
            /* invoke callback function */
            (*asp->callback_fn[line])(asp->callback_parm[line]);
            /* clear callback state & return reject */
            asp->callback_fn[line] = NO_ICA_CALLBACK;
            host_ica_unlock();
            return ICA_INTACK_REJECT;
        }
#endif  /* CPU_40_STYLE */

        int_no = line + asp->ica_base;
    }


#if defined (NTVDM)

#ifdef MONITOR
    *hook_address = host_iret_bop_table_addr(line);
    if (*hook_address) {
        iretHookActive |= 1 << line;
        }
#else
    *hook_address = 0;
#endif


#else
#ifdef HOOKED_IRETS
    /* check whether IRET Hook required for interrupt on this line.
     * If IRET trapping mechanism is via bops on stack then this may
     * also be conditional on the current state of the emulated hardware.
     * This is checked via a host call (or define).
     */
    if (host_valid_iret_hook())
    {
        *hook_address = ica_iret_hook_needed(line);

#ifdef CPU_40_STYLE
        if (*hook_address != 0)
        {
                        IU32 al = line >= 8 ? line - 8 : line; /* line no. within adapter */

            /* about to do iret hooked interrupt so increase depth */
            asp->isr_depth[al]++;
            asp->isr_progress[al][asp->isr_depth[al]] = asp->isr_progress[al][asp->isr_depth[al]-1];
        }
#endif  /* CPU_40_STYLE */
    }
#endif  /* HOOKED_IRETS */
#endif  /* !NTVDM */

    host_ica_unlock();          /* real lock if supported */

    return(int_no);
}


#ifndef NTVDM
#ifdef CPU_40_STYLE

/*(
 ======================= Asynchronous Access to the ICA ==========================

        Potential asynchronous interrupt sources, in descending order of priority
        so that the higher priority interrupt gets raised first (saves a bit of work)
        These things will share the CPU_SIGIO_EVENT callback from the CPU, and may have
        their own specific routine to be called (which presumably includes ica_hw_interrupt,
        but doesn't need to do so).

=========================================================================
)*/
typedef struct {
        IU32    adapter;
        IU32    line_no;
        void    (*interrupt) IPT0();
        IBOOL   pending;
} ICA_ASYNC_HANDLER;

#define ICA_IMPOSSIBLE_LINE     100

/* Make this a GLOBAL variable so that the C compilers can't optimise
 * accesses to it.
 */
GLOBAL ICA_ASYNC_HANDLER async_handlers[] = {

#ifdef NOVELL
        { ICA_SLAVE,    NETWORK_INT,    host_sigio_event },
#endif /* NOVELL */

#ifdef SWIN_HAW
        { ICA_SLAVE,    SWIN_HAW_INT,   0 },
#endif /* SWIN_HAW */

#ifdef ASPI
        { ICA_SLAVE,    ASPI_INT,       0 },
#endif /* ASPI */

        { 0, ICA_IMPOSSIBLE_LINE, 0}
};

/*(
======================= ica_async_hw_interrupt ==========================

PURPOSE: Simplified interface to replace ica_hw_interrupt() when triggered
        by truly asynchronous host facilties such as signal handlers. This
        routine remembers the need for an interrupt on the appropriate line,
        notifies the CPU that a SIGIO event has occurred, and issues the
        necessary ica_hw_interrupt calls during the ica_sigio_event callback.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line interrupt will appear on.
       call_count: IU32. number of interrupts (must be 1).

=========================================================================
)*/

GLOBAL void ica_async_hw_interrupt IFN3(IU32, adapter, IU32, line_no, IS32, call_count)
{
        ICA_ASYNC_HANDLER *iahp;

#ifndef PROD
        if (call_count != 1) {
                always_trace3("ica_async_interrupt(%s, %d, %d): call_count must be 1",
                        adapter? "MASTER":"SLAVE", line_no, call_count);
        }
#endif /* !PROD */

        for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
                if (iahp->adapter == adapter && iahp->line_no == line_no) {

                        /* This is as near to an atomic action as we can easily arrange,
                         * though there is a minute possibility of missing an interrupt
                         * if it is called between the test and the store in the ica_sigio_event
                         * handler below.
                         */
                        if (!iahp->pending) {
                                iahp->pending = TRUE;                           /* set the flag */
                                cpu_interrupt(CPU_SIGIO_EVENT, 0);      /* inform the CPU */
                        }
                        return;
                }
        }
        always_trace2("Unexpected ica_async_interrupt(%d, %d)", adapter, line_no);
}

/*(
 ========================== ica_sigio_event ==========================

PURPOSE: Called by the CPU in response to cpu_interrupt(CPU_SIGIO_EVENT,0)
        at a point when it is possible to make calls to the ICA hardware
        emulation without suffering from race conditions etc.

=========================================================================
)*/

GLOBAL void ica_sigio_event IFN0()
{
        ICA_ASYNC_HANDLER *iahp;

        for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
                /* This is as near to an atomic action as we can easily arrange,
                 * though there is a minute possibility of missing an interrupt...
                 */
                if (iahp->pending) {
                        iahp->pending = FALSE;                  /* clear the flag */
                        if (iahp->interrupt) {
                                (*(iahp->interrupt))();         /* call special handler */
                        } else {
                                ica_hw_interrupt(iahp->adapter, iahp->line_no, 1);
                        }
                }
        }

}

LOCAL void ica_sigio_init IFN0()
{
        ICA_ASYNC_HANDLER *iahp;

        for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
                iahp->pending = FALSE;
        }
}

/*(
 =========================== action_interrupt ==========================

PURPOSE: Associate an action with an interrupt on the line. When the CPU
         is next able to process an interrupt on the requested line, the
         callback function will be executed. That callback can then call
         the relevant hardware interrupt interface once it has performed
         the rest of the associated emulation.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line interrupt will appear on.
       func: callback function address to callback when line available.
       parm: IU32. parameter to pass to above fn.

OUTPUT: Returns false (failure) if action_int already pending on that line
        otherwise true (success).

=========================================================================
)*/
GLOBAL IBOOL
action_interrupt IFN4(IU32, adapter, IU32, line, ICA_CALLBACK, func, IU32, parm)
{
        ADAPTER_STATE *asp = &adapter_state[adapter];

        host_ica_lock();        /* real lock if available */

        line &= 7;

        /* check if callback already outstanding on this line */
        if (asp->callback_fn[line] != NO_ICA_CALLBACK)
        {
#ifndef PROD
                if (io_verbose & ICA_VERBOSE)
                {
                        sprintf(icamsgbuf, "action_interrupt called before line %d cleared", line);
                        trace(icamsgbuf, DUMP_NONE);
                }
#endif  /* PROD */
                host_ica_unlock();      /* real unlock if available */
                return(FALSE);
        }

        /* store callback information */
        asp->callback_fn[line] = func;
        asp->callback_parm[line] = parm;

        /* set interrupt request bit */
        asp->ica_irr |= (1 << line);
        asp->ica_count[line]++;

        /* make apparent interrupt visible to apps */
        asp->ica_isr |= (1 << line);

        /* get cpu attention for this int. (i.e. get intack called a.s.a.p) */
        host_set_hw_int();

        host_ica_unlock();      /* real unlock */
}

/*(
 ======================== cancel_action_interrupt =======================

PURPOSE: Associate an action with an interrupt on the line. When the CPU
         is next able to process an interrupt on the requested line, the
         callback function will be executed. That callback can then call
         the relevant hardware interrupt interface once it has performed
         the rest of the associated emulation.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line to cancel interrupt action

OUTPUT: None.

=========================================================================
)*/
GLOBAL void
cancel_action_interrupt IFN2(IU32, adapter, IU32, line)
{
        ADAPTER_STATE *asp = &adapter_state[adapter];

        host_ica_lock();        /* real lock if available */

        /* remove visibility of interrupt request. */
        asp->ica_isr &= ~(1 << line);

        /* irr & count should be cleared by intack, but possible this fn.
         * has been called before the callback has been executed.
         */
        if (asp->callback_fn[line] != NO_ICA_CALLBACK)
        {
                asp->ica_irr &= ~(1 << line);
                asp->ica_count[line] = 0;
        }

        /* clear callback information */
        asp->callback_fn[line] = NO_ICA_CALLBACK;
        asp->callback_parm[line] = 0;

        host_ica_unlock();      /* remove real lock */

}
#endif  /* CPU_40_STYLE */

#endif  /* !NTVDM */



#if defined(NTVDM)

#ifdef MONITOR
/*
 *  Assumes caller has ica lock
 */

GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
     int i;
     IU32 adapter = abs_line >> 3;

     iretHookActive &= ~(1 << abs_line);
     if ((i = ica_scan_irr(adapter)) & 0x80)
          ica_interrupt_cpu(adapter, i & 0x07);
}


GLOBAL void
ica_iret_hook_control IFN3(IU32, adapter, IU32, line, IBOOL, enable)
{
      int mask = 1 << (line + (adapter << 3));

      host_ica_lock();

      if (enable)
          iretHookMask |= mask;
      else
          iretHookMask &= ~mask;

      host_ica_unlock();
}
#else

/*
 *  obsolete, to be removed... but the current ntvdm emulator libs ref
 * */

GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
    return; // do nothing!
}
#endif

#endif   /* NTVDM */


#ifdef HOOKED_IRETS
#ifndef  GISP_CPU           /* GISP has own version of this routine */

GLOBAL IU32 ica_iret_hook_needed IFN1(IU32, line)
{
        IU16 ireq_mask = 1 << line;

#ifndef PROD
        if (line < 0 || line > 15)
        {
                /* Line is out of range */
                sprintf(icamsgbuf, "**** ICA IRET HOOK IMPOSSIBLE line %d ****", line);
                trace(icamsgbuf, DUMP_NONE);
                return 0;
        }
#endif

        /* does this line require iret hooks */
        if (!(iretHookMask & ireq_mask))
                /* Line not hooked. */
                return 0;

        /* if iret hooks implemented via bops, check bop table addresses ok */
        if (host_bop_style_iret_hooks()) {
            iretHookActive |= ireq_mask;
            return(host_iret_bop_table_addr(line));
            }
        else  {
            return(line + 1);
            }
}
#endif  /* GISP_CPU */

GLOBAL void
ica_iret_hook_control IFN3(IU32, adapter, IU32, line, IBOOL, enable)
{
        int mask = 1 << (line + (adapter << 3));

        if (enable)
                iretHookMask |= mask;
        else
                iretHookMask &= ~mask;
}


GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
        ADAPTER_STATE *asp;
        IU32 adapter = abs_line >> 3;
        IU32 line = abs_line - (adapter <<3);
        IU8 i;

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
                sprintf(icamsgbuf, "**** ICA IRET HOOK, line %d ****", line);
                trace(icamsgbuf, DUMP_NONE);
        }
#endif

#ifdef CPU_40_STYLE
        asp = &adapter_state[adapter];
        asp->isr_time_decay[line][asp->isr_depth[line]] = 0;
        asp->isr_depth[line]--;

        /* back to base stack level so restart first level recursion counter */
        if (asp->isr_depth[line] == 0)
                asp->isr_progress[line][1] = 0;

        /* enable interrupts on this line */
        if (asp->isr_depth[line] < MAX_ISR_DEPTH)
                iretHookActive &= ~(1 << abs_line);
#else
        UNUSED(asp);    /* anti warning */
        iretHookActive &= ~(1 << abs_line);
#endif  /* CPU_40_STYLE */


        if ((i = ica_scan_irr(adapter)) & 0x80)
                ica_interrupt_cpu(adapter, i & 0x07);
}


#if defined(CPU_40_STYLE)
#define HOWOFTEN        18      /* approx once per second */
#define MAXAGE          8       /* passes before purge */
GLOBAL void
ica_check_stale_iret_hook IFN0()
{
        SAVED int howoften = 18;
        int line, depth, loop;
        ADAPTER_STATE *asp;
        IS32 *cpdelay;

        howoften --;
        if (howoften == 0)
        {
                howoften = 18;

                host_ica_lock();
                asp = &adapter_state[0];
                for (line = 0; line < 8; line++)
                {
                    if (iretHookMask & (1 << line))
                    {
                        for (depth = 0; depth < asp->isr_depth[line]; depth++)
                        {
                                asp->isr_time_decay[line][depth]++;
                                if (asp->isr_time_decay[line][depth] == MAXAGE)
                                {
                                        asp->isr_time_decay[line][depth] = 0;
                                        if (depth == 0 && asp->ica_count[line] == 0)
                                                continue;       /* line idle */

                                        cpdelay = &asp->isr_time_decay[line][depth];
                                        /* lose hook data for this depth */
                                        loop = depth;
                                        while(loop <= asp->isr_depth[line])
                                        {
                                                loop ++;
                                                *cpdelay = *(cpdelay + 1);
                                                cpdelay++;
                                        }
                                        asp->isr_depth[line]--;

                                        /* fix cpu side */
                                        PurgeLostIretHookLine(line + 1, depth);

                                        /* permit intrs on this line */
                                        iretHookActive &= ~(1 << line);

                                        break;  /* one hook at a time */
                                }
                        }
                    }
                }
                asp = &adapter_state[1];
                for (line = 0; line < 8; line++)
                {
                    if (iretHookMask & (0x10 << line))
                    {
                        for (depth = 0; depth < asp->isr_depth[line]; depth++)
                        {
                                asp->isr_time_decay[line][depth]++;
                                if (asp->isr_time_decay[line][depth] == MAXAGE)
                                {
                                        asp->isr_time_decay[line][depth] = 0;
                                        if (depth == 0 && asp->ica_count[line] == 0)
                                                continue;       /* line idle */

                                        cpdelay = &asp->isr_time_decay[line][depth];
                                        /* lose hook data for this depth */
                                        loop = depth;
                                        while(loop <= asp->isr_depth[line])
                                        {
                                                loop ++;
                                                *cpdelay = *(cpdelay + 1);
                                                cpdelay++;
                                        }
                                        asp->isr_depth[line]--;

                                        /* fix cpu side */
                                        PurgeLostIretHookLine(line + 9, depth);

                                        /* permit intrs on this line */
                                        iretHookActive &= ~(1 << (8 + line));

                                        break;  /* one hook at a time */
                                }
                        }
                    }
                }
                host_ica_unlock();
        }
}
#endif  /* CPU_40_STYLE */
#endif  /* HOOKED_IRETS */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#define INIT0_ICW1      (IU8)0x11
#define INIT0_ICW2      (IU8)0x08
#if defined(NEC_98)
#define INIT0_ICW3      (IU8)0x80
#define INIT0_ICW4      (IU8)0x1d

#define INIT0_OCW1      (IU8)0x01
#else     //NEC_98
#define INIT0_ICW3      (IU8)0x04
#define INIT0_ICW4      (IU8)0x01

#ifdef NTVDM
#define INIT0_OCW1      (IU8)0x0

#else

/* POST leaves some int lines masked out (including comms and lpt lines) */
/* The setting of the bits is spread out throughout the real POST code
 * but is collected into one place here. I think that this will not cause
 * any problems but it is conceivable that it will harm other OS's than
 * DOS (eg OS/2 or coherent etc.)
 */
#define INIT0_OCW1      (IU8)0xb8
#endif /* NTVDM */
#endif   //NEC_98

void ica0_post IFN0()
{
    ica_outb(ICA0_PORT_0, INIT0_ICW1);
    ica_outb(ICA0_PORT_1, INIT0_ICW2);
    ica_outb(ICA0_PORT_1, INIT0_ICW3);
    ica_outb(ICA0_PORT_1, INIT0_ICW4);
    ica_outb(ICA0_PORT_1, INIT0_OCW1);
}

void ica0_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for adapter 0. (Master).
     */

#ifdef NTVDM
    io_define_inb(ICA0_ADAPTOR, ica_inb);
    io_define_outb(ICA0_ADAPTOR, ica_outb);
#else
    io_define_inb(ICA0_ADAPTOR, ica_inb_func);
    io_define_outb(ICA0_ADAPTOR, ica_outb_func);
#endif

#if defined(NEC_98)
    for(i = ICA0_PORT_START; i <= ICA0_PORT_END; i += 2)
#else    //NEC_98
    for(i = ICA0_PORT_START; i <= ICA0_PORT_END; i++)
#endif   //NEC_98
        io_connect_port(i, ICA0_ADAPTOR, IO_READ_WRITE);

    adapter_state[ICA_MASTER].ica_master = TRUE;


#ifndef NTVDM

#ifdef CPU_40_STYLE
    for (i = 0; i < 8; i++)
    {
        adapter_state[ICA_MASTER].callback_fn[i] = NO_ICA_CALLBACK;
        adapter_state[ICA_MASTER].isr_depth[i] = 0;
    }

    ica_sigio_init();

#endif  /* CPU_40_STYLE */


#ifdef HOOKED_IRETS
    /* on iret-hooked, non NT ports, enable iret hooks */
    iretHooksEnabled = TRUE;
#endif

#endif  /* !NTVDM */

}


#define INIT1_ICW1      (IU8)0x11
#if defined(NEC_98)
#define INIT1_ICW2      (IU8)0x10
#define INIT1_ICW3      (IU8)0x07
#define INIT1_ICW4      (IU8)0x09

#define INIT1_OCW1      (IU8)0x20
#else     //NEC_98
#define INIT1_ICW2      (IU8)0x70
#define INIT1_ICW3      (IU8)0x02
#define INIT1_ICW4      (IU8)0x01

#ifdef NTVDM
#define INIT1_OCW1      (IU8)0x0


/* POST leaves some int lines masked out (reserved lines and RTC) */
/* see the comment on POST setting mask bits for master ica */
#elif ASPI
#define INIT1_OCW1      (IU8)0x8d
#else /* ASPI */
#define INIT1_OCW1      (IU8)0x9d
#endif /* ASPI */
#endif   //NEC_98




void ica1_post IFN0()
{
    ica_outb(ICA1_PORT_0, INIT1_ICW1);
    ica_outb(ICA1_PORT_1, INIT1_ICW2);
    ica_outb(ICA1_PORT_1, INIT1_ICW3);
    ica_outb(ICA1_PORT_1, INIT1_ICW4);
    ica_outb(ICA1_PORT_1, INIT1_OCW1);
}

void ica1_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for adapter 1. (Slave).
     */

#ifdef NTVDM
    io_define_inb(ICA1_ADAPTOR, ica_inb);
    io_define_outb(ICA1_ADAPTOR, ica_outb);
#else
    io_define_inb(ICA1_ADAPTOR, ica_inb_func);
    io_define_outb(ICA1_ADAPTOR, ica_outb_func);
#endif

#if defined(NEC_98)
    for(i = ICA1_PORT_START; i <= ICA1_PORT_END; i += 2)
#else    //NEC_98
    for(i = ICA1_PORT_START; i <= ICA1_PORT_END; i++)
#endif   //NEC_98
        io_connect_port(i, ICA1_ADAPTOR, IO_READ_WRITE);

    adapter_state[ICA_SLAVE].ica_master = FALSE;

#if defined(CPU_40_STYLE) && !defined(NTVDM)
    for (i = 0; i < 8; i++)
    {
        adapter_state[ICA_SLAVE].callback_fn[i] = NO_ICA_CALLBACK;
        adapter_state[ICA_SLAVE].isr_depth[i] = 0;
    }
#endif  /* CPU_40_STYLE */

}


#if !defined(PROD)
/*
 * The following functions are used for DEBUG purposes only.
 */
LOCAL void
ica_print_int IFN2(char *, str, IS32, val)
{
    printf("%-20s 0x%02X\n", str, val);
}

LOCAL void
ica_print_str IFN2(char *, str, char *, val)
{
    printf("%-20s %s\n", str, val);
}

GLOBAL void
ica_dump IFN1(IU32, adapter)
{
    ADAPTER_STATE *asp = &adapter_state[adapter];
    char buff[80];
    int i;

    if (adapter == ICA_MASTER)
        printf("MASTER 8259A State:\n\n");
    else
        printf("SLAVE  8259A State:\n\n");

    ica_print_str("ica_master", (asp->ica_master ? "Master" : "Slave"));
    ica_print_int("ica_irr", asp->ica_irr);
    ica_print_int("ica_isr", asp->ica_isr);
    ica_print_int("ica_imr", asp->ica_imr);
    ica_print_int("ica_ssr", asp->ica_ssr);
    ica_print_int("ica_base", asp->ica_base);
    ica_print_int("ica_hipri", asp->ica_hipri);
    ica_print_int("ica_mode", asp->ica_mode);
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "ica_count",
                asp->ica_count[0], asp->ica_count[1], asp->ica_count[2], asp->ica_count[3],
                asp->ica_count[4], asp->ica_count[5], asp->ica_count[6], asp->ica_count[7]);
    ica_print_int("ica_int_line", asp->ica_int_line);
    ica_print_str("ica_cpu_int", (asp->ica_cpu_int ? "TRUE" : "FALSE"));

#if defined(CPU_40_STYLE) && !defined(NTVDM)
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "callback_parm",
                asp->callback_parm[0], asp->callback_parm[1], asp->callback_parm[2], asp->callback_parm[3],
                asp->callback_parm[4], asp->callback_parm[5], asp->callback_parm[6], asp->callback_parm[7]);
    printf("%-20s %8p%8p%8p%8p%8p%8p%8p%8p\n", "callback_fn",
                asp->callback_fn[0], asp->callback_fn[1], asp->callback_fn[2], asp->callback_fn[3],
                asp->callback_fn[4], asp->callback_fn[5], asp->callback_fn[6], asp->callback_fn[7]);
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "isr_depth",
                asp->isr_depth[0], asp->isr_depth[1], asp->isr_depth[2], asp->isr_depth[3],
                asp->isr_depth[4], asp->isr_depth[5], asp->isr_depth[6], asp->isr_depth[7]);
    for (i=0; i<(MAX_ISR_DEPTH + 1); i++)
    {
            int j;
            int progress[8];
            IBOOL some_progress = FALSE;

            for (j = 0; j < 8; j++)
            {
                    if (asp->isr_depth[j] >= i)
                    {
                            some_progress = TRUE;
                            progress[j] = asp->isr_progress[j][i];
                    }
                    else
                    {
                            progress[j] = 0;
                    }
            }
            sprintf (buff, "isr_progress[%d]", i);
            printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", buff,
                   progress[0], progress[1], progress[2], progress[3],
                   progress[4], progress[5], progress[6], progress[7]);
            if (!some_progress)
                    break;
    }
    for (i=0; i<MAX_ISR_DEPTH; i++)
    {
            int j;
            int decay[8];
            IBOOL some_decay = FALSE;

            for (j = 0; j < 8; j++)
            {
                    if (asp->isr_depth[j] >= i)
                    {
                            decay[j] = asp->isr_time_decay[j][i];
                            some_decay = TRUE;
                    }
                    else
                    {
                            decay[j] = 0;
                    }
            }
            sprintf (buff, "isr_time_decay[%d]", i);
            printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", buff,
                   decay[0], decay[1], decay[2], decay[3],
                   decay[4], decay[5], decay[6], decay[7]);
            if (!some_decay)
                    break;
    }
#endif /* CPU_40_STYLE && !NTVDM */

    printf("\n\n");
}
#endif /* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\illegalp.c ===
#include "insignia.h"
#include "host_def.h"
/*[
	Name:		illegal_op.c
	Derived From:	Base 2.0
	Author:		William Gulland
	Created On:	Unknown
	Sccs ID:	@(#)illegal_op.c	1.19 07/04/95
	Notes:		Called from the CPU.
	Purpose:	The CPU has encountered an illegal op code.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "bios.h"
#include "error.h"
#include "config.h"
#include "debug.h"
#include "yoda.h"

#ifndef PROD
IU32	IntelMsgDest = IM_DST_TRACE;
#endif

/* Routine to produce human readable form of where an illegal instruction occured */
LOCAL VOID where IFN3(CHAR *, string, word, cs, LIN_ADDR, ip)
{
	double_word ea = effective_addr(cs, ip);

	sprintf(string,
#ifdef	PROD
		"CS:%04x IP:%04x OP:%02x %02x %02x %02x %02x",
#else	/* PROD */
		"CS:IP %04x:%04x OP:%02x %02x %02x %02x %02x",
#endif	/* PROD */
		cs, ip,
		sas_hw_at(ea), sas_hw_at(ea+1), sas_hw_at(ea+2),
		sas_hw_at(ea+3),sas_hw_at(ea+4));
}

#if defined(NTVDM) && defined(MONITOR)
#define GetInstructionPointer()     getEIP()
#endif


void illegal_op()
{
#ifndef	PROD
	CHAR string[100];

	where(string, getCS(), GetInstructionPointer());
	host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#endif
}

void illegal_op_int()
{
	CHAR string[100];
	word cs, ip;

#ifdef NTVDM
        UCHAR opcode;
        double_word ea;
#endif

	/* the cs and ip of the faulting instruction should be on the top of the stack */
	sys_addr stack;

	stack=effective_addr(getSS(),getESP());

	ip = sas_hw_at(stack) + (sas_hw_at(stack+1)<<8);
	cs = sas_hw_at(stack+2) + (sas_hw_at(stack+3)<<8);

	where(string, cs, ip);

#ifndef NTVDM
#ifdef PROD
	host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#else  /* PROD */
	assert1( NO, "Illegal instruction\n%s\n", string );
	force_yoda();
#endif /* PROD */

#else /* NTVDM */
#ifdef PROD
#if defined(MONITOR) || defined(CPU_40_STYLE)
        host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#else
        ea = effective_addr(cs, ip);
        opcode = sas_hw_at(ea);
        if (opcode == 0x66 || opcode == 0x67)
            host_error(EG_BAD_OP386, ERR_QU_CO_RE, string);
        else
            host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#endif /* MONITOR */
#endif /* PROD */
#endif /* NTVDM */



	/* the user has requested a `continue` */
	/* we don't know how many bytes this instr should be, so guess 1 */
	if (ip == 0xffff) {
		cs ++;
		sas_store (stack+2, (IU8)(cs & 0xff));
		sas_store (stack+3, (IU8)((cs >> 8) & 0xff));
	}
	ip ++;
	sas_store (stack , (IU8)(ip & 0xff));
	sas_store (stack+1, (IU8)((ip >> 8) & 0xff));
	unexpected_int();
}


void illegal_dvr_bop IFN0()
{
#ifndef NTVDM
	sys_addr bop_addr;
	CHAR buf[256];

	/* This is called when an Insignia Intel driver decides that
	 * this (old) SoftWindows is not compatible.
	 *
	 * We should:
	 * a) Put up a localised panel complaining that
	 *    the named driver CS:[eIP] with decimal
	 *    version AX is incompatible with the SoftWindows.
	 *    N.B. The most compatible way to pass the
	 *    name of the driver is by embedded bytes just
	 *    after the BOP. The problem is caused by the
	 *    fact that the driver may be either 16-bit RM
	 *    or a 32-bit flat VxD so the address of the
	 *    string can be either 16/32 bits, and we
	 *    need to be able to execute (and do nothing)
	 *    on the shipping SoftPC 1.xx which prevents
	 *    us doing anything with 32-bit registers!
	 *
	 *	BOP	driver_incompat
	 *	jmp	SHORT over_name
	 *	db	'somename.drv', 0
	 * over_name:
	 *
	 * b) setCF(0)
	 */

	buf[0] = '\0';
	bop_addr = effective_addr(getCS(), GetInstructionPointer());
	if (sas_hw_at(bop_addr) == 0xEB)
	{
		IU8 data;
		char *p;

		p = buf;
		bop_addr += 2;	/* Skip the xEB xXX */
		do {
			data = sas_hw_at(bop_addr++);
			*p++ = data;
		} while (data != 0);
		sprintf(p-1, " v%d.%02d", getAX() / 100, getAX() % 100);
	}
	host_error(EG_DRIVER_MISMATCH, ERR_CONT, buf);
	setCF(0);
#endif /* ! NTVDM */
}


#ifndef PROD
LOCAL void print_msg IPT1( IU32, ofs );

void dvr_bop_trace IFN0()
{
	sys_addr bop_addr;

	 /*
	 *	BOP	driver_incompat
	 *	jmp	SHORT over_name
	 *	db	'somename.drv', 0
	 * over_name:
	 *
	 */

	bop_addr = effective_addr(getCS(), GetInstructionPointer());
	if (sas_hw_at(bop_addr) == 0xEB)
	{
		print_msg(bop_addr+2); /* Skip the xEB xXX */
	}
}

GLOBAL void trace_msg_bop IFN0()
{
	sys_addr ea, ofs;

	/*
	Stack frame expected:
	N.B. VxDs lives in a flat segment, (mostly) protected mode world!
	This code expects the address to have been converted to a base-0
	linear address already.

		|            |
		--------------
		|  4 byte    |
	ESP-->	| eff. addr  |
		--------------
	*/

	if (sas_hw_at(BIOS_VIRTUALISING_BYTE) != 0)
		fprintf(trace_file, "** WARNING ** Virtual byte non-zero\n");

	ea = getESP();
	ea = effective_addr(getSS(), ea);
	ofs = sas_dw_at_no_check(ea);
	print_msg(ofs);
}

LOCAL void print_msg IFN1( IU32, ofs )
{
	SAVED IBOOL start_buffer = TRUE;
	SAVED char string[164], *p = NULL;
	char finalStr[180];
	IU32 res, width;

	if (start_buffer)
	{
		memset(string, 0, sizeof(string));
		p = string;
		start_buffer = FALSE;
	}

	do
	{
		/* do things which must be done at the start of a line. */
		*p = sas_hw_at(ofs++);
		if (*p == '#')
		{
			/* found poss reg. sequence in string */

			p++;
			p[0] = sas_hw_at(ofs);
			if (('A' <= p[0]) && (p[0] <= 'Z'))
				p[0] += 'a' - 'A';
			p[1] = sas_hw_at(ofs+1);
			if (('A' <= p[1]) && (p[1] <= 'Z'))
				p[1] += 'a' - 'A';
			if (p[0] == 'e')
			{
				/* may be esp, esi, eax, etc... */

				p[2] = sas_hw_at(ofs+2);
				if (('A' <= p[2]) && (p[2] <= 'Z'))
					p[2] += 'a' - 'A';
				p[3] = '\0';
				width = 8;
			}
			else
			{
				/* If not eXX then can only be two letters long */
				p[2] = '\0';
				width = 4;
			}

			if (strcmp(p, "al") == 0)
			{	res = getAL(); width = 2;	}
			else if (strcmp(p, "ah") == 0)
			{	res = getAH(); width = 2;	}
			else if (strcmp(p, "bl") == 0)
			{	res = getBL(); width = 2;	}
			else if (strcmp(p, "bh") == 0)
			{	res = getBH(); width = 2;	}
			else if (strcmp(p, "cl") == 0)
			{	res = getCL(); width = 2;	}
			else if (strcmp(p, "ch") == 0)
			{	res = getCH(); width = 2;	}
			else if (strcmp(p, "dl") == 0)
			{	res = getDL(); width = 2;	}
			else if (strcmp(p, "dh") == 0)
			{	res = getDH(); width = 2;	}
			else if (strcmp(p, "ax") == 0)
				res = getAX();
			else if (strcmp(p, "bx") == 0)
				res = getBX();
			else if (strcmp(p, "cx") == 0)
				res = getCX();
			else if (strcmp(p, "dx") == 0)
				res = getDX();
			else if (strcmp(p, "si") == 0)
				res = getSI();
			else if (strcmp(p, "di") == 0)
				res = getDI();
			else if (strcmp(p, "sp") == 0)
				res = getSP();
			else if (strcmp(p, "bp") == 0)
				res = getBP();
			else if (strcmp(p, "eax") == 0)
				res = getEAX();
			else if (strcmp(p, "ebx") == 0)
				res = getEBX();
			else if (strcmp(p, "ecx") == 0)
				res = getECX();
			else if (strcmp(p, "edx") == 0)
				res = getEDX();
			else if (strcmp(p, "esi") == 0)
				res = getESI();
			else if (strcmp(p, "edi") == 0)
				res = getEDI();
			else if (strcmp(p, "esp") == 0)
				res = getESP();
			else if (strcmp(p, "ebp") == 0)
				res = getEBP();
			else if (strcmp(p, "cs") == 0)
				res = getCS();
			else if (strcmp(p, "ds") == 0)
				res = getDS();
			else if (strncmp(p, "es", 2) == 0)
			{	res = getES(); width = 4; p[2] = '\0';	}
			else if (strcmp(p, "fs") == 0)
				res = getFS();
			else if (strcmp(p, "gs") == 0)
				res = getGS();
			else if (strcmp(p, "fl") == 0)
				res = getFLAGS();
			else if (strcmp(p, "efl") == 0)
				res = getEFLAGS();
			else
				*p = '\0';	/* else just write the '#' */
			if (*p)
			{
				/* Overwrite the "#xx" with it's value */

				ofs += (p[2] ? 3: 2);
				p--;
				if (width == 8)
					sprintf(p, "%08x", res);
				else if (width == 4)
					sprintf(p, "%04x", res);
				else
					sprintf(p, "%02x", res);
				p += strlen(p);
			}
		}
		else if (*p != '\r')	/* ignore CR's */
		{
			if (*p == '\n' || (p - string >= (sizeof(string) - 4)))
			{
				p[1] = '\0';
				sprintf(finalStr, "intel msg at %04x:%04x : %s",
						getCS(), GetInstructionPointer(), string);
#ifdef CPU_40_STYLE
				if (IntelMsgDest & IM_DST_TRACE)
				{
					fprintf(trace_file, finalStr);
				}
#ifndef	CCPU
				if (IntelMsgDest & IM_DST_RING)
				{
					AddToTraceXBuffer( ((GLOBAL_TraceVectorSize - 2) << 4) + 0,
				  		finalStr );
				}
#endif	/* CCPU */
#else	/* CPU_40_STYLE */
				fprintf(trace_file, finalStr);
#endif	/* CPU_40_STYLE */
				memset(string, 0, sizeof(string));
				p = string;
			}
			else if (*p == '\0')	/* no more - stop */
				break;
			else
				p++;
		}
	} while ((p - string) < sizeof(string) - 4);
}
#endif /* ! PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\idetect.c ===
#include "insignia.h"
#include "host_def.h"

/*                      INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

	(see /vpc/1.0/Master/src/hdrREADME for help)

DOCUMENT                : name and number

RELATED DOCS            : include all relevant references

DESIGNER                : Phil Bousfield & Jerry Kramskoy

REVISION HISTORY        :
First version           : 31-Aug-89, simplified Phil's idea, and
			  produced an interface.

SUBMODULE NAME          :

SOURCE FILE NAME        : idetect.c

PURPOSE                 : provide idle detect for SoftPC, so it goes into
			  hibernation on detecting consecutive time periods
			  of unsuccessful keyboard polling at a HIGH RATE
			  with no graphics activity. Idling cannot occur
			  if polling occurs at too low a rate.

SccsID = @(#)idetect.c  1.11 10/11/93 Copyright Insignia Solutions Ltd.


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : idetect.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :  idle_ctl((int)flag)
			idetect((int)event)
			idle_set(int)minpoll, (int)minperiod)

	DATA         :  int idle_no_video/disk/comlpt

---------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
---------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
	host_release_timeslice()  -     block process until interesting
					system activity occurs (such as
					time tick, I/O etc)
---------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]
	none

[1.4.2 EXPORTED OBJECTS]
=====================================================================
GLOBAL                  int idle_no_video

PURPOSE                 cleared by gvi layer, and video bios ;
			set by this interface every time tick.
			keeps track of video activity.

GLOBAL                  int idle_no_disk

PURPOSE                 cleared by disk bios ;
			set by this interface every time tick.
			keeps track of video activity.

GLOBAL                  int idle_no_comlpt

PURPOSE                 cleared by com/lpt layer,
			set by this interface every time tick.
			keeps track of com/lpt port activity



=====================================================================
PROCEDURE         :     void idle_ctl((int)flag)

PURPOSE           :     enable/disable idle detect.
		
PARAMETERS

	flag      :     0       - disable
			other   - enable.

DESCRIPTION       :     all idetect() calls ignored if disabled ..
			can't idle in this case.

ERROR INDICATIONS :     none
=====================================================================
PROCEDURE         :     void idetect((int)event)

PURPOSE           :     idle detect interface.
		
PARAMETERS

	event     :     IDLE_INIT       - initialise (clears all
					  counters)
			IDLE_KYBD_POLL  _ report an unsucessful keyboard
					  poll made by application
			IDLE_TICK       - check activity during last
					  time tick
			IDLE_WAITIO     - application has demanded i/p
					  and none is available. idle.

GLOBALS           :     idle_no_video/disk/comlpt is read for IDLE_TICK, and
			reset.

DESCRIPTION       :     keeps track of when application appears to be
			idling.

ERROR INDICATIONS :     none

ERROR RECOVERY    :     bad 'event' value ignored.
=====================================================================
PROCEDURE         :     void idle_set((int)minpoll, (int)minperiod)

PURPOSE           :     configure parameters for idling.
		
PARAMETERS

	minpoll   :     0       - don't change
			other   - specify minimum #.of unsuccessful kybd
				  polls to be made in 1 time tick
				  to qualify as an idle time period.
	minperiod :     0       - don't change
			other   - specify minimum #.of consecutive idle
				  time periods to elapse before going
				  idle. (e.g; 3 = 3 time ticks)

DESCRIPTION       :     controls sensitivity for idle detection.

ERROR INDICATIONS :     none

ERROR RECOVERY    :     bad values ignored.
=====================================================================


=====================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=====================================================================

[3.1 INTERMODULE IMPORTS]                                               */

/* [3.1.1 #INCLUDES]                                                */
/* [3.1.2 DECLARATIONS]                                             */
#include "xt.h"
#include "timer.h"

#ifdef NTVDM
/* NT configuration flag showing user request for idle support */
IMPORT BOOL IdleDisabledFromPIF;
IMPORT BOOL ExternalWaitRequest;
IMPORT BOOL VDMForWOW;
IMPORT void WaitIfIdle(void);
IMPORT VOID PrioWaitIfIdle(half_word);
#endif  /* NTVDM */

/* [3.2 INTERMODULE EXPORTS]                                            */
#include "idetect.h"

/*
5.MODULE INTERNALS   : (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

/* [5.1.1 #DEFINES]                                                     */

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */


/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */
#ifdef NTVDM
void idle_kybd_poll();
void idle_tick();
#else
        LOCAL void idle_kybd_poll();
        LOCAL void idle_tick();
#endif


/* -------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

#ifndef NTVDM
int idle_no_video;
int idle_no_comlpt;
int idle_no_disk;

static int i_counter = 0;
static int nCharPollsPerTick = 0;
static int ienabled = 0;
static int minConsecutiveTicks = 12;
static int minFailedPolls = 10;


#else
#include "vdm.h"

/*  NTVDM
 *  Some of our static global variables are located in 16 bit memory area
 *  so we reference as pointers, inititializaed by kb_setup_vectors
 */
#if defined(NEC_98)
word pICounterwork = 0;
word CharPollsPerTickwork = 0;
word MinConsecutiveTickswork =0;
#endif   //NEC_98
word minFailedPolls = 8;
word ienabled = 0;
word ShortIdle=0;
word IdleNoActivity = 0;


#if defined(NEC_98)
word *pICounter = &pICounterwork;
#else    //NEC_98
word *pICounter;
#endif   //NEC_98
#define i_counter (*pICounter)

#if defined(NEC_98)
word *pCharPollsPerTick = &CharPollsPerTickwork;
#else    //NEC_98
word *pCharPollsPerTick;
#endif   //NEC_98
#define nCharPollsPerTick (*pCharPollsPerTick)

#if defined(NEC_98)
word *pMinConsecutiveTicks = &MinConsecutiveTickswork ;
#else    //NEC_98
word *pMinConsecutiveTicks;
#endif   //NEC_98
#define minConsecutiveTicks (*pMinConsecutiveTicks)

#endif  /* NTVDM */

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */

/*
======================================================================
FUNCTION        :       idle_kybd_poll()
PURPOSE         :       called from keyboard BIOS as result of
			application polling kybd unsuccessfully.
======================================================================
*/


#ifndef NTVDM
#ifdef SMEG
#include "smeg_head.h"

GLOBAL LONG dummy_long_1, dummy_long_2;
GLOBAL BOOL system_has_idled = FALSE;
#endif


LOCAL void my_host_release_timeslice()
{
#ifdef SMEG
    /*
     * Set marker and waste time (SIGPROF screws up
     * host_release_timeslice)
     */

    LONG i;

    smeg_set(SMEG_IN_IDLE);

    system_has_idled = TRUE;

    for (i = 0; i < 100000; i++)
		dummy_long_1 += dummy_long_2;

    smeg_clear(SMEG_IN_IDLE);
#else
    host_release_timeslice();
#endif

    /* re-count polls in next tick */
    nCharPollsPerTick = 0;
}
#endif  /* NTVDM */

#ifdef NTVDM
/*
 * NT uses a slightly modified algorithum to attempt to catch screen updating
 * apps. It also supports Idling calls from VDDs and thus must test which
 * thread requests the idle.
 */
void idle_kybd_poll(void)
{

	/*
	 *  We don't support wow apps reading the kbd
	 *  if a wow app comes here we must prevent them
	 *  from hogging the CPU, so we will always do
	 *  and idle no matter what.
	 */
	if (VDMForWOW) {
	    host_release_timeslice();
	    return;
	    }

	/* go idle if enough consecutive PC timer interrupts
	 * have elapsed during which time unsuccessful polling has
	 * occurred at a large enough rate for each tick.
	 */

        if (i_counter >= minConsecutiveTicks)
        {
            host_release_timeslice();
            }

	/* another unsuccessful poll ! */
	nCharPollsPerTick++;
}
#else
LOCAL void idle_kybd_poll()
{
	/* go idle if enough consecutive PC timer interrupts
	 * have elapsed during which time unsuccessful polling has
	 * occurred at a large enough rate for each tick.
	 */
	if (i_counter >= minConsecutiveTicks)
	{
		my_host_release_timeslice();
	}

	/* another unsuccessful poll ! */
	nCharPollsPerTick++;
}
#endif

/*
======================================================================
FUNCTION        :       idle_tick()
PURPOSE         :       check polling activity and graphics activity
			that's occurred during last tick. If no video
			memory writes, and high enough keyboard poll
			rate (when no i/p available) increment counter
			for triggering going idle. Otherwise reset
			counter.
======================================================================
*/

#ifdef NTVDM
void idle_tick(void)
{
        /* Has another thread asked us to idle? */
	if (ExternalWaitRequest)
	{
	    WaitIfIdle();
	    ExternalWaitRequest = FALSE;
	}
#ifdef MONITOR
    if(*pNtVDMState & VDM_IDLEACTIVITY)
       {
       *pNtVDMState &= ~ VDM_IDLEACTIVITY;
       IdleNoActivity = 0;
       }
#endif
        if (IdleNoActivity)
        {
            /* no graphics or comms/lpt activity has occurred...
	     * see whether enough polling of kybd has occurred
	     * to kick off the idling counter.
	     */
	    if (nCharPollsPerTick >= minFailedPolls) {
		i_counter++;
		if (ShortIdle) {
		    PrioWaitIfIdle(94);
		}
	    }
	}
	else
        {


            /*
             *  Check for apps which cheat idle detection by updating
             *  clocks on the screen causing video activity.
             */
            ShortIdle = nCharPollsPerTick >= minFailedPolls && i_counter >= 8;

            /* invalidate all accumulated ticks */
            i_counter = 0;
            IdleNoActivity = 1;
	}

        nCharPollsPerTick = 0;
}

#else  /* NTVDM */
LOCAL void idle_tick()
{
	if (idle_no_video && idle_no_disk && idle_no_comlpt)
	{
		/* no graphics or comms/lpt activity has occurred...
		 * see whether enough polling of kybd has occurred
		 * to kick off the idling counter.
		 */
		if (nCharPollsPerTick >= minFailedPolls)
			i_counter++;
	}
	else
	{
		i_counter = 0;
	}

	/* set flags and zero poll counter for next time period
	 */
	idle_no_video = 1;
	idle_no_disk = 1;
	idle_no_comlpt = 1;

	nCharPollsPerTick = 0;
}
#endif

/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]                              */



/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */

void idetect (event)
int event;
{
#ifndef NTVDM
	if (!ienabled)
            return;
#endif

	switch (event)
	{
	/* application waiting for input - go idle */
	case IDLE_WAITIO:
#ifdef NTVDM
#ifdef MONITOR
		*pNtVDMState &= ~VDM_IDLEACTIVITY;
#endif
		IdleNoActivity = 1;
                PrioWaitIfIdle(10);
		break;
#else
		my_host_release_timeslice();
#endif
		/* fall thru to idle init */

	/* initialise flags and counter */
	case IDLE_INIT:
		nCharPollsPerTick = 0;
		i_counter = 0;
#ifdef NTVDM
                IdleNoActivity = 1;
#else
		idle_no_video = 1;
		idle_no_disk = 1;
		idle_no_comlpt = 1;
#endif
		break;

	/* application polling for keyboard input */
	case IDLE_KYBD_POLL:
		idle_kybd_poll();
		break;

	case IDLE_TIME_TICK:
		idle_tick();
		break;

	}
}

void idle_set (minpoll, minperiod)
int minpoll, minperiod;
{
	if (minperiod > 0)
		minConsecutiveTicks = (word)minperiod;

	if (minpoll > 0)
		minFailedPolls = (word)minpoll;
}

void idle_ctl (flag)
int flag;
{
#ifdef NTVDM
#ifdef PIG
    ienabled = 0;
#else
    if (IdleDisabledFromPIF)    /* configured setting overrides normal control*/
	ienabled = 0;
    else
	ienabled = (word)flag;
#endif /* PIG */
#else
	ienabled = flag;
#endif  /* NTVDM */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\rom.c ===
#include "insignia.h"
#include "host_def.h"
/*
* SoftPC Revision 3.0
*
* Title	: ROM init functions
*
* Author	: Ade Brownlow	
*
* NB : These functions are used by BOTH the c and assembler cpus.
*		also note that host_read_resource now returns a long.
*
* SCCS ID:	@(#)rom.c	1.53 06/16/95
*
* (C) Copyright Insignia Solutions Ltd, 1994.
*/

#include <stdio.h>
#include <malloc.h>

#include TypesH
#include MemoryH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "rom.h"
#include "debug.h"
#include "ckmalloc.h"
#include "yoda.h"
#include "gispsvga.h"

#ifdef	CPU_40_STYLE
#ifdef CCPU
#include "ccpusas4.h"
#else	/* ! CCPU */
#include "Cpu_c.h"
#endif	/* ! CCPU */
#endif	/* CPU_40_STYLE */

#if defined(NEC_98)

#ifndef BIOSNROM_FILENAME
#define BIOSNROM_FILENAME       "biosn.rom"
#endif /* BIOSNROM_FILENAME */

#ifndef BIOSNWROM_FILENAME
#define BIOSNWROM_FILENAME      "biosnw.rom"
#endif /* BIOSNWROM_FILENAME */

#ifndef RS232CEXROM_FILENAME
#define RS232CEXROM_FILENAME    "rs232cex.rom"
#endif
#else    //NEC_98

#ifndef BIOS1ROM_FILENAME
#define	BIOS1ROM_FILENAME	"bios1.rom"
#endif /* BIOS1ROM_FILENAME */

#ifndef BIOS2ROM_FILENAME
#if defined(CPU_40_STYLE) || defined(ARCX86)
#define	BIOS2ROM_FILENAME	"bios4.rom"
#else	/* CPU_40_STYLE */
#define	BIOS2ROM_FILENAME	"bios2.rom"
#endif	/* CPU_40_STYLE */
#endif /* BIOS2ROM_FILENAME */

#ifndef EGAROM_FILENAME
#define	EGAROM_FILENAME		"ega.rom"
#endif /* EGAROM_FILENAME */

#ifndef VGAROM_FILENAME
#define	VGAROM_FILENAME		"vga.rom"
#endif /* VGAROM_FILENAME */

#ifndef V7VGAROM_FILENAME
#define	V7VGAROM_FILENAME	"v7vga.rom"
#endif /* V7VGAROM_FILENAME */

#endif   //NEC_98

#ifdef 	GISP_SVGA
#define	GISP_VGAROM_FILENAME         "hwvga.rom"
#define	GISP_BIOS1ROM_FILENAME       "hwbios1.rom"
#define	GISP_BIOS2ROM_FILENAME       BIOS2ROM_FILENAME
#endif

#ifndef ADAPTOR_ROM_START
#define ADAPTOR_ROM_START	0xc8000
#endif	/* ADAPTOR_ROM_START */

#ifndef ADAPTOR_ROM_END
#define ADAPTOR_ROM_END		0xe0000
#endif	/* ADAPTOR_ROM_END */

#define ADAPTOR_ROM_INCREMENT	0x800

#ifndef EXPANSION_ROM_START
#define EXPANSION_ROM_START	0xe0000
#endif	/* EXPANSION_ROM_START */

#ifndef EXPANSION_ROM_END
#define EXPANSION_ROM_END	0xf0000
#endif	/* EXPANSION_ROM_END */

#define EXPANSION_ROM_INCREMENT	0x10000

#define	ROM_SIGNATURE		0xaa55

#if defined(NEC_98)
#define SIXTY_FOUR_K 1024*64
#define NINETY_SIX_K 1024*96
#endif   //NEC_98

/* Current SoftPC verion number */
#define MAJOR_VER	0x03
#define MINOR_VER	0x00

#if defined(macintosh) && defined(A2CPU)
	/* Buffer is temporarily allocted  - no bigger than needed. */
#define ROM_BUFFER_SIZE 1024*25
#else
	/* Using sas_scratch_buffer - will get 64K anyway. */
#define ROM_BUFFER_SIZE 1024*64
#endif

LOCAL LONG read_rom IPT2(char *, name, sys_addr, address);
LOCAL	half_word	do_rom_checksum IPT1(sys_addr, addr);

#ifdef ANSI
extern long host_read_resource (int, char *, host_addr, int ,int);
#else
extern long host_read_resource ();
#endif

extern void host_simulate();

#if defined(NEC_98)
VOID setup_memory_switch(VOID);
extern GLOBAL BOOL HIRESO_MODE;
extern sys_addr host_check_rs232cex();
extern BOOL video_emu_mode;
#endif   //NEC_98

/*(
 *=========================== patchCheckSum ================================
 * patchCheckSum
 *
 * Purpose
 *	This function calculates the check-sum for the indicated ROM,
 *	and patches it in at the indicated offset into the ROM.
 *
 *	It also checks that the ROM has the correct signature, and length,
 *	and rounds the size up to a multiple of 512 bytes.
 *
 *	Note this routine should not be called once paging is turned on.
 *
 * Input
 *	start	Physical address of start of ROM
 *	length	length of ROM in bytes
 *	offset	Checksum byte offset from start.
 *
 * Outputs
 *	None.
 *
 * Description
 *	We round the size-up to a multiple of 512 bytes, check the
 *	signature, then patch-in the checksum.
)*/

LOCAL void
patchCheckSum IFN3(PHY_ADDR, start, PHY_ADDR, length, PHY_ADDR, offset)
{
	PHY_ADDR roundedLength;
	IU16 signature;
	IU8 checksum;
	IU8 *buffer;
	PHY_ADDR currByte;
	PHY_ADDR indicatedLength;
	

	roundedLength = (length + 511) & (~511);
	sas_connect_memory(start, start + roundedLength - 1, SAS_RAM);

#ifndef PROD
	if (roundedLength != length) {
		always_trace3("ROM at 0x%.5lx length rounded up from 0x%.8lx to 0x%.8lx", start, length, roundedLength);
	}

	if (roundedLength > (128 * 1024)) {
		always_trace2("ROM at 0x%.5lx has a length of 0x%.8lx which is more than 128K", start, roundedLength);
		force_yoda();
		return;
	}

	if ((roundedLength <= offset) || (roundedLength < 4)) {
		always_trace1("ROM at 0x%.5lx is too short!", start);
		force_yoda();
		return;
	}
#endif

	signature = sas_PR16(start);
	if (signature != 0xaa55) {
		always_trace2("ROM at 0x%.5lx has an invalid signature 0x%.4x (should be aa55)", start, signature);
		sas_PW16(start, 0xaa55);
	}

	indicatedLength = sas_PR8(start + 2) * 512;
	if (indicatedLength != roundedLength) {
		always_trace3("ROM at 0x%.5lx has incorrect length 0x%.8lx (actually 0x%.8lx)", start, indicatedLength, roundedLength);
		sas_PW8(start + 2, (IU8)(roundedLength / 512));
	}


	check_malloc(buffer, roundedLength, IU8);

	sas_loads((LIN_ADDR)start, buffer, roundedLength);

	checksum = 0;
	for (currByte = 0; currByte < roundedLength; currByte++) {
		checksum += buffer[currByte];
	}
	host_free(buffer);

	if (checksum != 0) {
		always_trace2("ROM at 0x%.8lx has incorrect checksum 0x%.2x",
			start, checksum);
		sas_PW8(start + offset,
			(IU8)((IS8)sas_PR8(start + offset) - checksum));
	}
	sas_connect_memory(start, start + roundedLength - 1, SAS_ROM);

}


/*(
=============================== read_video_rom ============================
PURPOSE:	Load the appropriate video rom file.
INPUT:		None.
OUTPUT:		None.
===========================================================================
)*/
GLOBAL void read_video_rom IFN0()
{
#ifndef NEC_98
#ifdef REAL_VGA
	read_rom (VGAROM_FILENAME, EGA_ROM_START);
#else /* REAL_VGA */
	PHY_ADDR romLength = 0;

	switch ((ULONG) config_inquire(C_GFX_ADAPTER, NULL))
	{
#ifndef GISP_SVGA
#ifdef	VGG
	case VGA:
#ifdef V7VGA
		romLength = read_rom (V7VGAROM_FILENAME, EGA_ROM_START);
#else	/* V7VGA */
#ifdef ARCX86
        if (UseEmulationROM)
            romLength = read_rom (V7VGAROM_FILENAME, EGA_ROM_START);
        else
            romLength = read_rom (VGAROM_FILENAME, EGA_ROM_START);
#else  /* ARCX86 */
		romLength = read_rom (VGAROM_FILENAME, EGA_ROM_START);
#endif /* ARCX86 */
#endif  /* V7VGA */
		break;
#endif	/* VGG */

#ifdef	EGG
	case EGA:
		romLength = read_rom (EGAROM_FILENAME, EGA_ROM_START);
		break;
#endif	/* EGG */

	default:
		/* No rom required */
		break;

#else			/* GISP_SVGA */

	/* GISP_SVGA - only have the gisp vga roms or, none for CGA boot */
	case VGA:
		romLength = read_rom (GISP_VGAROM_FILENAME, EGA_ROM_START);
	default:
		break;

#endif		/* GISP_SVGA */	

	}

	if (romLength != 0)
	{
		/* There is a problem with emm386 and Windows start up, which
		 * is cured by setting the video bios rom internal length
		 * to 32Kb.
		 * Is seems that the V86 manager (or emm386) incorrectly
		 * maps C6000..C7FFF during initialisation.
		 * We round up the video ROM to 32Kb to avoid this problem,
		 * which reduces the amount of "upper memory" RAM available to
		 * dos extenders by 12K.
		 */
		if (romLength < (32*1024))
			romLength = (32*1024);
		patchCheckSum(EGA_ROM_START, romLength, 5);
	}
#endif	/* not REAL_VGA */
#endif   //NEC_98
}

GLOBAL void rom_init IFN0()
{
#if defined(NEC_98)
    sys_addr    rs232cex_rom_addr;

    sas_fills( ROM_START, BAD_OP, PC_MEM_SIZE - ROM_START);
//  if(HIRESO_MODE){
//      read_rom (BIOSHROM_FILENAME, BIOSH_START);
//      sas_connect_memory (BIOSH_START, 0xFFFFFL,SAS_ROM);
//  }else{
        rs232cex_rom_addr = host_check_rs232cex();
        if(rs232cex_rom_addr){
            read_rom (RS232CEXROM_FILENAME, rs232cex_rom_addr);
            sas_connect_memory (rs232cex_rom_addr, rs232cex_rom_addr + 0x4000, SAS_ROM);
        }
        if(!video_emu_mode)
            read_rom (BIOSNROM_FILENAME, BIOSN_START);
        else
            read_rom (BIOSNWROM_FILENAME, BIOSN_START);
        sas_connect_memory (BIOSN_START, 0xFFFFFL,SAS_ROM);
//  }
    setup_memory_switch();
#else    //NEC_98

#if !defined(NTVDM) || ( defined(NTVDM) && !defined(X86GFX) )
	 /*
     * Fill up all of ROM (Intel C0000 upwards) with bad op-codes.
     * This is the Expansion ROM and the BIOS ROM.
     * This will enable the CPU to trap any calls to ROM that are not made at a
     * valid entry point.
     */

#ifdef GISP_SVGA
	mapHostROMs( );
#else		/* GISP_SVGA */
#if	defined(macintosh) && defined(A2CPU)
	/* not macintosh 2.0 cpus - they have sparse M */
#else
	sas_fills( ROM_START, BAD_OP, PC_MEM_SIZE - ROM_START);
#endif		/* macintosh && A2CPU */
#endif		/* GISP_SVGA */

	/*
	 * emm386 needs a hole to put it's page frame in.
	 */
#if defined(SPC386) && !defined(GISP_CPU)
	sas_connect_memory(0xc0000, 0xfffff, SAS_ROM);
#endif

	/* Load the video rom. */
	read_video_rom();

	/* load the rom bios */
#ifdef GISP_SVGA
	if ((ULONG) config_inquire(C_GFX_ADAPTER, NULL) == CGA )
	{
		read_rom (BIOS1ROM_FILENAME, BIOS_START);
		read_rom (BIOS2ROM_FILENAME, BIOS2_START);
	}
	else
	{
		read_rom (GISP_BIOS1ROM_FILENAME, BIOS_START);
		read_rom (GISP_BIOS2ROM_FILENAME, BIOS2_START);
	}

#else		/* GISP_SVGA */

	read_rom (BIOS1ROM_FILENAME, BIOS_START);
	read_rom (BIOS2ROM_FILENAME, BIOS2_START);

#endif		/* GISP_SVGA */

#else	/* !NTVDM | (NTVDM & !X86GFX) */

#ifdef ARCX86
    if (UseEmulationROM) {
        sas_fills( EGA_ROM_START, BAD_OP, 0x8000);
        sas_fills( BIOS_START, BAD_OP, PC_MEM_SIZE - BIOS_START);
        read_video_rom();
        read_rom (BIOS1ROM_FILENAME, BIOS_START);
        read_rom (BIOS2ROM_FILENAME, BIOS2_START);
    } else {
        sas_connect_memory (BIOS_START, 0xFFFFFL, SAS_ROM);
    }
#else  /* ARCX86 */
	/*
	 * Now tell the CPU what it's not allowed to write over...
	 *
	 * These used to be done for everyone, but now they're only done for NT
	 * as everyone else should have done it inside read_rom.
	 */
	sas_connect_memory (BIOS_START, 0xFFFFFL, SAS_ROM);
#endif /* ARCX86 */

#ifdef EGG
	sas_connect_memory (EGA_ROM_START, EGA_ROM_END-1, SAS_ROM);
#endif
#endif /* !NTVDM | (NTVDM & !X86GFX) */

	host_rom_init();
#endif   //NEC_98
}

LOCAL LONG read_rom IFN2(char *, name, sys_addr, address)
{
#if defined(NEC_98)
    host_addr tmp;
    long size = 0;
    if(HIRESO_MODE) {
       if (!(tmp = (host_addr)sas_scratch_address(SIXTY_FOUR_K)))
       {
           host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
           return(0);
       }
       if (size = host_read_resource(ROMS_REZ_ID, name, tmp, SIXTY_FOUR_K, TRUE))
       {
           sas_connect_memory( address, address+size, SAS_RAM);
           sas_stores (address, tmp, size);
           sas_connect_memory( address, address+size, SAS_ROM);
       }
    } else {
       if (!(tmp = (host_addr)sas_scratch_address(NINETY_SIX_K)))
       {
           host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
           return(0);
       }
       if (size = host_read_resource(ROMS_REZ_ID, name, tmp, NINETY_SIX_K, TRUE))
       {
           sas_connect_memory( address, address+size, SAS_RAM);
           sas_stores (address, tmp, size);
           sas_connect_memory( address, address+size, SAS_ROM);
       }
    }
   return( size );
#else    //NEC_98

#if !(defined(NTVDM) && defined(MONITOR))
	host_addr tmp;
	long size = 0;

    /* do a rom load - use the sas_io buffer to get it the right way round 	*/
    /* BIOS rom first. 														*/
	/* Mac on 2.0 cpu doesn't want to use sas scratch buffer. 				*/
#if defined(macintosh) && defined(A2CPU)
    tmp = (host_addr)host_malloc(ROM_BUFFER_SIZE);
#else
	tmp = (host_addr)sas_scratch_address(ROM_BUFFER_SIZE);
#endif

    if (!tmp)
    {
	host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
	return(0);
    }
    if (size = host_read_resource(ROMS_REZ_ID, name, tmp, ROM_BUFFER_SIZE, TRUE))
    {
	sas_connect_memory( address, address+size, SAS_RAM);
        sas_stores (address, tmp, size);
	sas_connect_memory( address, address+size, SAS_ROM);
    }

#if defined(macintosh) && defined(A2CPU)
	host_free((char *)tmp);
#endif

    return( size );
#else

#ifdef ARCX86
    if (UseEmulationROM) {
        host_addr tmp;
        long size = 0;

        tmp = (host_addr)sas_scratch_address(ROM_BUFFER_SIZE);
        if (!tmp)
        {
            host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
            return(0);
        }
        if (size = host_read_resource(ROMS_REZ_ID, name, tmp, ROM_BUFFER_SIZE, TRUE))
        {
            sas_connect_memory( address, address+size, SAS_RAM);
            sas_stores (address, tmp, size);
            sas_connect_memory( address, address+size, SAS_ROM);
        }
        return( size );
    } else {
        return ( 0L );
    }
#else  /* ARCX86 */
    return ( 0L );
#endif /* ARCX86 */

#endif	/* !(NTVDM && MONITOR) */
#endif   //NEC_98
}

#if defined(NEC_98)

static byte memory_sw_n[32] = {0xE1,0x00,0x48,0x00,0xE1,0x00,0x05,0x00,
                               0xE1,0x00,0x04,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x01,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x00,0x00,0xE1,0x00,0x93,0x00};
static byte memory_sw_h[32] = {0xE1,0x00,0x48,0x00,0xE1,0x00,0x05,0x00,
                               0xE1,0x00,0x05,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x41,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x00,0x00,0xE1,0x00,0x92,0x00};

VOID setup_memory_switch(VOID)
{
        int i;

        if(HIRESO_MODE){
           for (i=0;i<32;i++)
           {
           sas_PW8((MEMORY_SWITCH_START_H+i),memory_sw_h[i]);
           }
        } else {
           for (i=0;i<32;i++)
           {
           sas_PW8((MEMORY_SWITCH_START_N+i),memory_sw_n[i]);
           }
        }
}
#endif   //NEC_98

LOCAL	half_word	do_rom_checksum IFN1(sys_addr, addr)
{
	LONG	sum = 0;
	sys_addr	last_byte_addr;

	last_byte_addr = addr + (sas_hw_at(addr+2)*512);

	for (; addr<last_byte_addr; addr++)
		sum += sas_hw_at(addr);

	return( (half_word)(sum % 0x100) );
}

LOCAL	VOID	do_search_for_roms IFN3(sys_addr, start_addr,
	sys_addr, end_addr, unsigned long, increment)
{
	word	signature;
	half_word	checksum;
	sys_addr	addr;
	word		savedCS;
	word		savedIP;

	for ( addr = start_addr; addr < end_addr; addr += increment )
	{
		if ((signature = sas_w_at(addr)) == ROM_SIGNATURE)
		{
			if ((checksum = do_rom_checksum(addr)) == 0)
			{
			/*
				Now point at address of init code.
			*/
				addr += 3;
			/*
				Fake a CALLF by pushing a return CS:IP.
				This points at a BOP FE in the bios to
				get us back into 'c'
			*/
				push_word( 0xfe00 );
				push_word( 0x95a );
				savedCS = getCS();
				savedIP = getIP();
				setCS((UCHAR)((addr & 0xf0000) >> 4));
				setIP((USHORT)((addr & 0xffff)));
				host_simulate();
				setCS(savedCS);
				setIP(savedIP);
				assert1(NO, "Additional ROM located and initialised at 0x%x ", addr-3);
			}
			else
			{
				assert2(NO, "Bad additonal ROM located at 0x%x, checksum = 0x%x\n", addr, checksum);
			}
		}
	}
}

GLOBAL void search_for_roms IFN0()
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
#ifndef GISP_SVGA
/*
        First search for adaptor ROM modules
*/
    do_search_for_roms(ADAPTOR_ROM_START,
                                ADAPTOR_ROM_END, ADAPTOR_ROM_INCREMENT);

/*
        Now search for expansion ROM modules
*/
    do_search_for_roms(EXPANSION_ROM_START,
                                EXPANSION_ROM_END, EXPANSION_ROM_INCREMENT);
#endif 		/* GISP_SVGA */
#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}


GLOBAL void rom_checksum IFN0()
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
	patchCheckSum(BIOS_START, PC_MEM_SIZE - BIOS_START,
				0xfffff - BIOS_START);
#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}

GLOBAL VOID patch_rom IFN2(sys_addr, addr, half_word, val)
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
	UTINY	old_val;

	/*
	 * 4.0 style CPUs don't export this variable, and if sas hasn't been
	 * inited, then the sas_connect will drop out to yoda.
	 */

#ifdef CPU_40_STYLE

	IU8	*hostPtr;

	/* TMM 14/2/95
	 * -----------
	 * What we are doing here is replacing the sas_connect() method of writing to ROM
	 * with the new approach of poking the values directly in there. See display_string()
	 * below for a more detiled discussion of the why's and wherefores.
	 */

#ifdef macintosh

	/* The Mac config system wants to call this routine before the
	 * CPU exists, so we'd better invent a Mac-specific IBOOL to
	 * make the symptom non-fatal - finding and fixing the cause
	 * is too hard.
	 */
	{
		extern IBOOL SafeToCallSas;

		if (!SafeToCallSas)
			return;	
	}

#endif /* macintosh */

	/* The page might not be present (Arrggghhhh!!!!!)
	** so we can't do anything sensible and must give
	** up. We print an error though.
	*/
	hostPtr = getPtrToPhysAddrByte (addr);
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}

	old_val = *hostPtr;

	/* Optimisation - don't upset the world if the value is unchanged.
	 */
	if (old_val == val)
		return;

	*hostPtr = val;

/*
 *	Adjust the checksum value by new - old.
 *	val is now difference between new and old value.
 *	We don't do this for GISP_SVGA because the checksums are already
 *	screwed, and attempting to write to the real host system ROM would
 *	only make things worse!
 */

#ifndef GISP_SVGA
	/* Now get the checksum at the end of the ROM */
	hostPtr = getPtrToPhysAddrByte (0xFFFFFL);
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}
	
	/* Now set the checksum to the difference between the old and new values */
	*hostPtr -= (val - old_val);
	
#endif /* GISP_SVGA */

#else	/* CPU_40_STYLE */

	/*
	 * 4.0 style CPUs don't export this variable, and if sas hasn't been
	 * inited, then the sas_connect will drop out to yoda.
	 */

	if (Length_of_M_area == 0)
		return;

	old_val = sas_hw_at( addr );

	/* Optimisation - don't upset the world if the value is unchanged.
	 */
	if (old_val == val)
		return;

	sas_connect_memory (addr, addr, SAS_RAM);
	sas_store (addr,val);
	sas_connect_memory (addr, addr, SAS_ROM);
/*
 *	Adjust the checksum value by new - old.
 *	val is now difference between new and old value.
 *	We don't do this for GISP_SVGA because the checksums are already
 *	screwed, and attempting to write to the real host system ROM would
 *	only make things worse!
 */

#ifndef GISP_SVGA
	val -= old_val;
	old_val = sas_hw_at( 0xFFFFFL );

	old_val -= val;
	sas_connect_memory (0xFFFFFL, 0xFFFFFL, SAS_RAM);
	sas_store (0xFFFFFL, old_val);
	sas_connect_memory (0xFFFFFL, 0xFFFFFL, SAS_ROM);
#endif /* GISP_SVGA */

#endif	/* CPU_40_STYLE */

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}

#ifndef GISP_SVGA

/*
 * These routines were used by 2.0 CPUs which performed
 * post-write checks. Since all 3.0 and later CPUs do
 * pre-write checks they're no longer needed.
 */

#if !(defined(NTVDM) & defined(MONITOR))
void update_romcopy IFN1(long, addr)
{
	UNUSED( addr );
}
#endif

GLOBAL void copyROM IFN0()
{
}

#endif		/* GISP_SVGA */

/*
 * To enable our drivers to output messages generated from
 * our bops we use a scratch area inside our rom.
 */
#ifndef GISP_SVGA
LOCAL sys_addr  cur_loc = DOS_SCRATCH_PAD;
#else		/* GISP_SVGA */
/* For GISP svga builds, we initialise from gispROMInit() */
sys_addr  cur_loc;
#endif		/* GISP_SVGA */

GLOBAL void display_string IFN1(char *, string_ptr)
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) ) || defined(ARCX86)
#ifdef ARCX86
  if (UseEmulationROM)
#endif
  {
	/*
	 * Put the message "*string_ptr" in the ROM
	 * scratch area where the drivers know where
	 * to output it from.
	 */

#ifdef CPU_40_STYLE

	IU8	*hostPtr;
	IU16	count;
	IU32	endLinAddr;

	/* In a paging environment, we must be careful as a
	** the ROM area could have been copied and/or mapped
	** as read only. We must alter the memory which is
	** currently at the linear address of the ROM (whether
	** that is actually our rom or a RAM copy of it). We
	** must force this alteration despite any protection
	** placed on the page by the Intel page tables.
	*/

	/* get a host pointer to the memory behind the required
	** linear address.
	*/
	hostPtr = getPtrToLinAddrByte(cur_loc);

	/* The page might not be present (Arrggghhhh!!!!!)
	** so we can't do anything sensible and must give
	** up. We print an error though.
	*/
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}

	/* the area to be patched must lie entirely in one intel page for
	** this method to be sure to work. So check it.
	*/
	endLinAddr = (cur_loc + strlen(string_ptr) + 2);
	if (((endLinAddr ^ DOS_SCRATCH_PAD) > 0xfff) || (endLinAddr > DOS_SCRATCH_PAD_END))
	{
#ifndef PROD
		fprintf(trace_file, "*** Warning ***: patch string into ROM too long; tuncating string '%s'", string_ptr);
#endif
		if ((DOS_SCRATCH_PAD_END ^ DOS_SCRATCH_PAD) > 0xfff)
		{
			/* The defined DOS scratch pad crosses a page
			** boundary. must truncate to the page boundary,
			** allowing for the '$' and terminating zero
			*/
			string_ptr[0xffd - (DOS_SCRATCH_PAD & 0xfff)] = '\0';
		}
		else
		{
			/* The string overflows the DOS scratch pad. We
			** must truncate to the scrtach pad boundary,
			** allowing for the '$' and terminating zero
			*/
			string_ptr[cur_loc - DOS_SCRATCH_PAD - 2] = '\0';
		}
	}
	for (count = 0; count < strlen(string_ptr); count++)
	{
		*IncCpuPtrLS8(hostPtr) = string_ptr[count];
	}
	/* Terminate the string */
	*IncCpuPtrLS8(hostPtr) = '$';
	*IncCpuPtrLS8(hostPtr) = '\0';
#else /* CPU_40_STYLE */
	sas_connect_memory(DOS_SCRATCH_PAD, DOS_SCRATCH_PAD_END, SAS_RAM);
	sas_stores(cur_loc, (host_addr)string_ptr, strlen(string_ptr));
	cur_loc += strlen(string_ptr);

	/* Terminate the string */
	sas_store(cur_loc, '$');
	sas_store(cur_loc + 1, '\0');
	sas_disconnect_memory(DOS_SCRATCH_PAD, DOS_SCRATCH_PAD_END);
	cur_loc -= strlen(string_ptr);
#endif /* CPU_40_STYLE */
  }
#endif	/* !NTVDM | !MONITOR | ARCX86 */
	cur_loc+=strlen(string_ptr);
}

GLOBAL void clear_string IFN0()
{
        cur_loc = DOS_SCRATCH_PAD;  /* Need to reset this pointer to start of **
                                    ** scratch area to prevent messages being **
                                    ** repeatedly displayed.                  */
	display_string ("");
}

/* Returns the SoftPC version to our device drivers */

GLOBAL void softpc_version IFN0()
{
	setAH(MAJOR_VER);
	setAL(MINOR_VER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\qevnt.c ===
/*
 *
 *  NTVDM specific version of Quick event dispatcher.
 *
 *  See quick_ev.c for current insignia compatibility level, and full
 *  documentation. Functionally compatible with:
 *
 *  "quick_ev.c 1.43 07/04/95 Copyright Insignia Solutions Ltd"
 *
 *  Quick Events are fully supported on Risc platforms.
 *  Quick Events are stubbed to dispatch immediatley on x86 platforms.
 *  Tick events are not supported on any platform, (no longer used)
 *  All Global quick event interfaces use the host_ica_lock for
 *  synchronization.
 *
 *  11-Dec-1995 Jonle
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include TypesH
#include MemoryH
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "debug.h"
#include "timer.h"
#include "host_hfx.h"
#include "quick_ev.h"
#include "timestmp.h"
#include "ica.h"
#include "nt_eoi.h"



/*
 *  The Quick event structure
 */
typedef struct _QuickEventEntry {
     LIST_ENTRY    qevListEntry;
     LARGE_INTEGER DueTimeStamp;
     ULONG         DelayTime;
     Q_CALLBACK_FN qevCallBack;
     long          Param;
     ULONG         QuickEventId;
} QEV_ENTRY, *PQEV_ENTRY;


/*  Quick event handle structure. externally its defined
 *  as a LONGLONG, internally we manipulate as a QEVHANDLE union
 *  giving us a simple and 99% effective algorithm for verifying
 *  qevent handles.
 *
 *  CAVEAT: the QEVHANDLE union MUST not be larger than a LONGLONG.
 */
typedef union _QuickEventHandle {
    struct {
        PVOID pvQuickEvent;
        ULONG QuickEventId;
        };
    LONGLONG Handle;
} QEVHANDLE, PQEVHANDLE;


LIST_ENTRY QuickEventListHead = {&QuickEventListHead,&QuickEventListHead};
ULONG qevNextHandleId=0;
LARGE_INTEGER qevNextDueTime = {0,0};

extern void host_TimeStamp(PLARGE_INTEGER pliTime); // nt_timer.c


/*
 *  Calibration variables
 */
#define DEFAULT_IJCTIME 10
#define CALIBCYCLE16    16  // CALIBCYCLE16 must be 16, because hard coded
                            // shift operations are used to avoid division.


void quick_tick_recalibrate(void);
GLOBAL IBOOL DisableQuickTickRecal = FALSE;
ULONG qevJumpRestart = 100;
ULONG qevUsecPerIJC = 0;
ULONG qevCalibUsecPerIJC;
int  qevCalibCycle=0;

BOOL QevInitialized = FALSE;

LARGE_INTEGER qevCalibCount={0,0};
LARGE_INTEGER qevCalibTime={0,0};
LARGE_INTEGER qevPeriodTime={0,0};

VOID
q_event_init(
      void
      )
{
#ifndef MONITOR
     PLIST_ENTRY Next;
     PQEV_ENTRY pqevEntry;


#if DBG
     if (sizeof(QEVHANDLE) > sizeof(ULONGLONG)) {
         DbgPrint("sizeof(QEVHANDLE) > sizeof(ULONGLONG)\n");
         DbgBreakPoint();
         }
#endif

     host_ica_lock();

     //
     // do first time initialization, this must be done before ANY
     // devices access the quick event interface.
     //
     if (!QevInitialized ) {
         qevJumpRestart = host_get_jump_restart();
         qevUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         qevCalibUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         qevPeriodTime.QuadPart = 100000 * 16; // tick every 100 ms, cycle =16
         QevInitialized = TRUE;
         }

     if (IsListEmpty(&QuickEventListHead)) {
         host_q_ev_set_count(0);
         qevNextDueTime.QuadPart = 0;
         }

     qevCalibCycle=0;
     qevCalibCount.QuadPart = 0;
     host_TimeStamp(&qevCalibTime);

     host_ica_unlock();
#endif
}


#ifndef MONITOR

/*
 *  Caller must hold ica lock
 */
void
ResetCpuQevCount(
     PLARGE_INTEGER CurrTime
     )
{
     LARGE_INTEGER DiffTime;
     PQEV_ENTRY  pqevEntry;
     ULONG DelayTime;

     if (IsListEmpty(&QuickEventListHead)) {
         host_q_ev_set_count(0);
         qevNextDueTime.QuadPart = 0;
         return;
         }

     pqevEntry = CONTAINING_RECORD(QuickEventListHead.Flink,
                                   QEV_ENTRY,
                                   qevListEntry
                                   );

     DiffTime.QuadPart = pqevEntry->DueTimeStamp.QuadPart - CurrTime->QuadPart;

        /*
         *  If behind schedule use a reduced delay time to speed up
         *  dispatching of events. Can't go too fast or quick events will
         *  batch up.
         */
     if (DiffTime.QuadPart < 0) {
         DelayTime = (pqevEntry->DelayTime >> 1) + 1;
         }
     else {
         DelayTime = DiffTime.LowPart;    /* ignore overflow! */
         }

     qevNextDueTime.QuadPart = CurrTime->QuadPart + DelayTime;
     host_q_ev_set_count(host_calc_q_ev_inst_for_time(DelayTime));
}
#endif



/*
 * add_q_event_t - add event to do in n usecs
 *
 *
 */

q_ev_handle
add_q_event_t(
      Q_CALLBACK_FN func,
      unsigned long Time,
      long param
      )
{

#ifdef MONITOR
        /*
         *  On X86 dispatch immediately, as x86 has no efficient way
         *  to acheive usec granularity.
         */

        (*func)(param);

        return (q_ev_handle)1;


#else  /* MONITOR */

        QEVHANDLE   qevHandle;
        PLIST_ENTRY Next;
        PQEV_ENTRY  NewEntry;
        PQEV_ENTRY  EarlierEntry;
        PQEV_ENTRY  pqevEntry;
        LARGE_INTEGER CurrTime;


        host_ica_lock();

        NewEntry = qevHandle.pvQuickEvent = malloc(sizeof(QEV_ENTRY));
        if (!NewEntry) {
            host_ica_unlock();
            return (q_ev_handle)1;
            }

        host_TimeStamp(&CurrTime);

        NewEntry->DueTimeStamp.QuadPart = CurrTime.QuadPart + Time;
        NewEntry->qevCallBack = func;
        NewEntry->Param = param;
        NewEntry->QuickEventId = qevNextHandleId++;
        qevHandle.QuickEventId = NewEntry->QuickEventId;

        /*
         *  The Quick event list is sorted in ascending order
         *  by DueTimeStamp, insert in sorted order.
         */
        EarlierEntry = NULL;
        Next = QuickEventListHead.Blink;
        while (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            if (NewEntry->DueTimeStamp.QuadPart >
                pqevEntry->DueTimeStamp.QuadPart)
              {
                EarlierEntry = pqevEntry;
                break;
                }
            Next= Next->Blink;
            }

        /*
         *  If Earlier Entry found, chain the new entry in after
         *  the earlier entry, and set the DelayTimes.
         */
        if (EarlierEntry) {
            Next = EarlierEntry->qevListEntry.Flink;
            NewEntry->qevListEntry.Flink = Next;
            NewEntry->qevListEntry.Blink = &EarlierEntry->qevListEntry;
            EarlierEntry->qevListEntry.Flink = &NewEntry->qevListEntry;
            NewEntry->DelayTime = (ULONG)(NewEntry->DueTimeStamp.QuadPart -
                                          EarlierEntry->DueTimeStamp.QuadPart);

            if (Next == &QuickEventListHead) {
                QuickEventListHead.Blink = &NewEntry->qevListEntry;
                }
            else {
                pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
                pqevEntry->qevListEntry.Blink = &NewEntry->qevListEntry;
                pqevEntry->DelayTime = (ULONG)(pqevEntry->DueTimeStamp.QuadPart -
                                               NewEntry->DueTimeStamp.QuadPart);
                }
            }

        /*
         *  Earlier Entry not found insert at head of list,
         *  reset the cpu count and real expected due time.
         */
        else {
            InsertHeadList(&QuickEventListHead, &NewEntry->qevListEntry);
            NewEntry->DelayTime = Time;
            ResetCpuQevCount(&CurrTime);
            }

        host_ica_unlock();

        return qevHandle.Handle;


#endif
}




/*
 * add_q_event_i - add event to do in n number of instructions.
 *
 * HOWEVER, instructions is interpreted as time with (1 instr\1 usec).
 * It is not Instruction Jump Counts (IJC).
 *
 */
q_ev_handle
add_q_event_i(
        Q_CALLBACK_FN func,
        unsigned long instrs,
        long param
        )
{
        return add_q_event_t(func, instrs, param);
}


/*
 * Called from the cpu when a count of zero is reached
 */
VOID
dispatch_q_event(
    void
    )
{
#ifndef MONITOR
        PQEV_ENTRY  pqevEntry;
        LARGE_INTEGER CurrTime;
        Q_CALLBACK_FN qevCallBack = NULL;
        long          Param;


        host_ica_lock();

        if (!IsListEmpty(&QuickEventListHead)) {
            pqevEntry = CONTAINING_RECORD(QuickEventListHead.Flink,
                                          QEV_ENTRY,
                                          qevListEntry
                                          );

            qevCallBack = pqevEntry->qevCallBack;
            Param       = pqevEntry->Param;

            RemoveEntryList(&pqevEntry->qevListEntry);
            free(pqevEntry);
            }

        if (IsListEmpty(&QuickEventListHead)) {
            host_q_ev_set_count(0);
            qevNextDueTime.QuadPart = 0;
            }
        else {
            host_TimeStamp(&CurrTime);
            ResetCpuQevCount(&CurrTime);
            }

        host_ica_unlock();

        if (qevCallBack) {
            (*qevCallBack)(Param);
            }
#endif
}


VOID
delete_q_event(
        q_ev_handle Handle
        )
{
#ifndef MONITOR
        QEVHANDLE   qevHandle;
        PLIST_ENTRY Next;
        LARGE_INTEGER CurrTime;
        PQEV_ENTRY pqevEntry;
        PQEV_ENTRY EntryFound;


        qevHandle.Handle = Handle;

        host_ica_lock();

        //
        // Search the qev list for the entry to ensure
        // that the qevHandle exists.
        //
        EntryFound = NULL;
        Next = QuickEventListHead.Flink;
        while (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            Next = Next->Flink;
            if (pqevEntry == qevHandle.pvQuickEvent &&
                pqevEntry->QuickEventId == qevHandle.QuickEventId)
               {
                EntryFound = pqevEntry;
                break;
                }
            }

        if (!EntryFound) {
            host_ica_unlock();
            return;
            }

        //
        // Adjust the Next entry's DelayTime.
        //
        if (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            pqevEntry->DelayTime += EntryFound->DelayTime;
            }

        //
        // If the entry being removed was at the head of the list
        // Get curr time and remember that head has changed.
        //
        if (EntryFound->qevListEntry.Blink == &QuickEventListHead) {
            host_TimeStamp(&CurrTime);
            }
        else {
            CurrTime.QuadPart = 0;
            }

        //
        // Remove the entry found, and reset Cpu qev count
        // if head has changed
        //
        RemoveEntryList(&EntryFound->qevListEntry);
        free(EntryFound);

        //
        // if head of list changed, reset the Cpu quick event count
        //
        if (CurrTime.QuadPart) {
            ResetCpuQevCount(&CurrTime);
            }


        host_ica_unlock();
#endif
}



#ifndef MONITOR

/*
 * The QuickEvent list stores time in usecs. The CPU quick event counter
 * uses Instruction Jump Counts (IJC) which tracks progress in emulated
 * code as opposed to time. The following calibration code attempts to
 * relate the two.
 */

/*
 *   Convert time in usecs to Instruction Jump Counts (IJC)
 */

IU32
calc_q_inst_for_time(
     IU32 Usecs
     )
{
     ULONG InstrJumpCounts;

     InstrJumpCounts = (Usecs * qevJumpRestart)/qevUsecPerIJC;
     if (!InstrJumpCounts) {
         InstrJumpCounts = 1;
         }

     return InstrJumpCounts;
}


/*
 *   Convert Instruction Jump Counts (IJC) to time in usecs
 */
IU32
calc_q_time_for_inst(
     IU32 InstrJumpCounts
     )
{
     ULONG Usecs;

     Usecs = InstrJumpCounts * qevUsecPerIJC / qevJumpRestart;
     if (!Usecs) {
         Usecs = 1;
         }


     return Usecs;
}





/*
 *  Calibration of quick events.
 *
 *  quick_tick_recalibrate is invoked on each timer event. Its purpose is
 *  to align progress in emulated code with real time. Progress in emulated
 *  code is tracked by the cpu with Instruction Jump Counts (IJC).
 *  Real Time is tracked by the NT performance counter, with resolution
 *  in usecs (via host_TimeStamp).
 *
 *  On each call to quick_tick_rcalibrate we retrieve the cpu's IJC, and
 *  the current time, giving us a Usec to Instruction Jump Count ratio.
 *  A running average of the UsecPerIJC ratio is used to convert between
 *  real time and IJC's to set the cpu's quick event counter. An averageing
 *  method was chosen because:
 *
 *   - avoidance of unusual code fragments which may give artificial ratios.
 *
 *   - The cpu emulator only increments the Instruction Jump Counter when it
 *     is emulating code, extended durations out of the emulator produces
 *     unrealistically high UsecPerIJC ratios.
 *
 *   - performance overhead of updating the ratio.
 *
 */

void
quick_tick_recalibrate(void)
{
     LARGE_INTEGER CurrTime, PeriodTime;
     ULONG usecPerIJC;
     ULONG CalibCount;

#ifndef PROD
     if (DisableQuickTickRecal) {
         qevUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         return;
         }
#endif

     host_ica_lock();

     CalibCount = host_get_q_calib_val();
     if (!CalibCount) {
         host_ica_unlock();
         return;
         }

     qevCalibCount.QuadPart += CalibCount;


     if (++qevCalibCycle == CALIBCYCLE16) {
         host_TimeStamp(&CurrTime);
         PeriodTime.QuadPart = CurrTime.QuadPart - qevCalibTime.QuadPart;
         qevCalibTime = CurrTime;
         qevPeriodTime.QuadPart = (qevPeriodTime.QuadPart + PeriodTime.QuadPart) >> 1;
         qevCalibCycle = 0;
         }
     else {
         //
         // Use an estimate of elapsed time, to avoid calling system on
         // every timer event.
         //
         PeriodTime.QuadPart = (qevPeriodTime.QuadPart >> 4) * qevCalibCycle;
         CurrTime.QuadPart = qevCalibTime.QuadPart + qevPeriodTime.QuadPart;
         }

     //
     // Calculate usecPerIJC for this period, ensuring that its not too
     // large, which is caused by app spending most of its time outside
     // of the emulator (Idle, network etc.).
     //
     usecPerIJC = (ULONG)((PeriodTime.QuadPart * qevJumpRestart)/qevCalibCount.QuadPart);
     if (usecPerIJC > 10000) {  // max at 100 usec PerIJC
         usecPerIJC = 10000;
         }
     else if (usecPerIJC < 100 ) { // min at 1 usec Per IJC
         usecPerIJC = 100;
         }


     //
     // Add it into the averaged usecPerIJC, with 25% weight
     //
     qevUsecPerIJC = (usecPerIJC + qevUsecPerIJC + (qevCalibUsecPerIJC << 1)) >> 2;


     if (!qevCalibCycle) {
         qevCalibUsecPerIJC = qevUsecPerIJC;
         qevCalibCount.QuadPart = 0;
         }


     //
     // Check the quick event list for late events. If more than a msec
     // behind, reduce the delay, and inform the emulator so it
     // will dispatch soon.
     //
     if (qevNextDueTime.QuadPart &&
         qevNextDueTime.QuadPart < CurrTime.QuadPart - 1000)
        {
         ULONG InstrJumpCounts;

         InstrJumpCounts = (host_q_ev_get_count() >> 1) + 1;
         host_q_ev_set_count(InstrJumpCounts);
         }

     host_ica_unlock();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\quick_ev.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * Title	:	Quick event dispatcher
 *
 * Desription	:	This module contains those function calls necessary to
 *			interface to the quick event dispatcher
 *
 *                      Public functions:
 *                      q_event_init()	: initialise conditions
 *                      add_q_event_i()	: do an event after a given number of
 *					  instructions
 *			add_q_event_t()	: do an event after a given number of
 *					  microseconds
 *			delete_q_event(): delete an entry from the event queue
 *
 * Author	:	WTG Charnell
 *
 * Notes	:
 *
 *	This is what I (Mike) think happens in this module (before
 *	CPU_40_STYLE).
 * 
 *	This module handles two types of events - quick events, and tick events
 *	which are similar in most ways.  The module contains functions to
 *	add events, delete events and dispatch events (action them) for both
 *	types.  The only significant difference (apart from the fact that
 *	they're held in different (but similar) data structures, is that
 *	the quick event dispatch function is called from the CPU when the
 *	next quick event must be dispatched, while the tic event dispatch
 *	function is called on every timer tick, and only causes dispatch
 *	of an event when enough calls have taken place to reach the next event.
 *
 *	The impression the module gives is that tic events were added as an
 *	after thought...
 *
 *	The most important data structure is the Q_EVENT structure, from
 *	which most other structures are built.  This has the following
 *	elements:-
 *
 *	func	-	the action function to be called when the event goes
 *			off.
 *	time_from_last	Contains the delta time from the previous entry
 *			in the time ordered chain of events (see below).
 *	handle	-	Unique handle to identify an event.
 *	param	-	Paramter passed to the action function when it's
 *			called.
 *	next,previous - pointers for a time ordered list of events.
 *	next_free -	Dual purpose - link free structures together, or
 *			form a hash chain for a table hashed on handle.
 *
 *	q_list_head & q_list_tail (and their equivalents tic_list_head & 
 *	tic_list_tail) are used to keep a time-ordered dual linked list
 *	(yes, you guessed it, it was written by wtgc) of events.
 */
 
#ifdef SCCSID
LOCAL char SccsID[]="@(#)quick_ev.c	1.43 07/04/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_QUICKEV.seg"
#endif

/*
** Normal UNIX includes
*/
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include TypesH
#include MemoryH

/*
** SoftPC includes
*/
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "debug.h"
#include "timer.h"

#ifdef SFELLOW
#include "malloc.h"
#else
/* for host_malloc & host_free */
#include "host_hfx.h" 
#endif	/* SFELLOW */

#include "quick_ev.h"

#if defined(CPU_40_STYLE) && !defined (SFELLOW)
#include "timestmp.h"	/* for timestamp definitions */
#endif

#ifdef NTVDM
#include "ica.h"
#endif


#define HASH_SIZE	16
#define HASH_MASK	0xf

#ifdef CPU_40_STYLE
/* defines for calibration mechanism */
#define Q_RATIO_HISTORY_SHIFT	3	/* power of two selection */
#define Q_RATIO_HISTORY_SIZE	(1 << Q_RATIO_HISTORY_SHIFT)	/* corresponding size */
#define Q_RATIO_WRAP_MASK	(Q_RATIO_HISTORY_SIZE - 1)
#define Q_RATIO_DEFAULT	1
#endif	/* CPU_40_STYLE */

typedef enum { EVENT_TIME, EVENT_INSTRUCTIONS, EVENT_TICK } EVENTTYPE;

/*
 *	Structure for event list elements
 */

struct Q_EVENT
{
	void	(* func)();
	unsigned long	time_from_last;
	unsigned long	original_time;
	q_ev_handle	handle;
	long	param;
	EVENTTYPE event_type;
	struct Q_EVENT *next;
	struct Q_EVENT *previous;
	struct Q_EVENT *next_free;
};

typedef struct Q_EVENT t_q_event;
typedef t_q_event *TQ_TABLE[];

typedef void (*VOID_FUNC)();
typedef ULONG (*ULONG_FUNC)();

/*
** our static vars.
*/
#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL struct {
	IU32 jc_ms;
	IU32 time_ms;
} q_ratio_history[Q_RATIO_HISTORY_SIZE];
LOCAL IUM32 q_ratio_head = 0L;
LOCAL IBOOL q_ratio_initialised = FALSE;
LOCAL QTIMESTAMP previous_tstamp;
LOCAL IU32 ideal_q_rate = 1, real_q_rate = 1;
#endif	/* CPU_40_STYLE && !SFELLOW */

LOCAL t_q_event *q_free_list_head = NULL;
LOCAL t_q_event *q_list_head = NULL;
LOCAL t_q_event *q_list_tail = NULL;

LOCAL t_q_event *q_ev_hash_table[HASH_SIZE];
LOCAL q_ev_handle next_free_handle = 1;

/*
	Separate list for events on timer ticks
*/
#if defined(SFELLOW)
/*
 * a single, shared free list (both tic and quick events
 * use the same structs)
 */
#define	tic_free_list_head	q_free_list_head
#else
LOCAL t_q_event *tic_free_list_head = NULL;
#endif	/* SFELLOW */
LOCAL t_q_event *tic_list_head = NULL;
LOCAL t_q_event *tic_list_tail = NULL;

LOCAL t_q_event *tic_ev_hash_table[HASH_SIZE];
LOCAL q_ev_handle tic_next_free_handle = 1;
LOCAL ULONG tic_event_count = 0;

#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL void init_q_ratio IPT0();
LOCAL void add_new_q_ratio IPT2(IU32, jumps_ms, IU32, time_ms);
LOCAL void q_weighted_ratio IPT2(IU32 *, mant, IU32 *, divis);
void quick_tick_recalibrate IPT0();

#else
#define	init_q_ratio()
#endif	/* CPU_40_STYLE && !SFELLOW */

LOCAL ULONG calc_q_ev_time_for_inst IPT1(ULONG, inst);

LOCAL q_ev_handle gen_add_q_event IPT4(Q_CALLBACK_FN, func, unsigned long, time, long, param, EVENTTYPE, event_type);

/*
 * Global vars
 */
#if defined(CPU_40_STYLE) && !defined(SFELLOW)
GLOBAL IBOOL DisableQuickTickRecal = FALSE;
#endif


#if defined NTVDM && !defined MONITOR
/*  NTVDM
 *
 *  The Timer hardware emulation for NT is multithreaded
 *  So we use the ica critsect to synchronize access to the following
 *  quick event functions:
 *
 *   q_event_init()
 *   add_q_event_i()
 *   add_q_event_t()
 *   delete_q_event()
 *   dispatch_q_event()
 *
 *  tic events are not affected
 *  On x86 platforms (MONITOR) the quick event mechanism
 *  is to call the func directly so synchronization is not needed.
 *
 */

#endif


/*
 *	initialise linked list etc
 */

#ifdef ANSI
LOCAL void  q_event_init_structs(t_q_event **head, t_q_event **tail,
				 t_q_event **free_ptr, t_q_event *table[],
				 q_ev_handle *free_handle)
#else
LOCAL void  q_event_init_structs(head, tail, free_ptr, table, free_handle)
t_q_event **head;
t_q_event **tail;
t_q_event **free_ptr;
t_q_event *table[];
q_ev_handle *free_handle;
#endif	/* ANSI */
{
	int i;
	t_q_event *ptr;

	while (*head != NULL) {
		ptr = *head;
		*head = (*head)->next;
#ifdef SFELLOW
		ptr->next_free = *free_ptr;
		*free_ptr = ptr;
	}
	*head = *tail = NULL;
#else	/* SFELLOW */
		host_free(ptr);
	}
	while (*free_ptr != NULL) {
		ptr = *free_ptr;
		*free_ptr = (*free_ptr)->next_free;
		host_free(ptr);
	}
	*head = *tail = *free_ptr=NULL;
#endif	/* SFELLOW */

	*free_handle = 1;
	for (i = 0; i < HASH_SIZE; i++){
		table[i] = NULL;
	}
}

LOCAL t_q_event* makeSomeFreeEvents IPT0()
{
	t_q_event *nptr;
#ifdef SFELLOW
	IUH	count;

	nptr = SFMalloc(4096,TRUE);
	for (count=0; count< (4096/sizeof(t_q_event)); count++)
	{
		nptr->next_free = q_free_list_head;
		q_free_list_head = nptr;
		nptr++;
	}
	nptr = q_free_list_head;
	q_free_list_head = nptr->next_free;
#else
	nptr = (t_q_event *)host_malloc(sizeof(t_q_event));
#endif
	return nptr;
}

VOID q_event_init IFN0()
{
	
#if defined NTVDM && !defined MONITOR
     host_ica_lock();
#endif


	host_q_ev_set_count(0);
	q_event_init_structs(&q_list_head, &q_list_tail, &q_free_list_head, 
		q_ev_hash_table, &next_free_handle);
	sure_sub_note_trace0(Q_EVENT_VERBOSE,"q_event_init called");

	init_q_ratio();

#if defined NTVDM && !defined MONITOR
     host_ica_unlock();
#endif
}

LOCAL VOID
tic_ev_set_count IFN1(ULONG, x )
{
	tic_event_count = x;
}

LOCAL ULONG
tic_ev_get_count IFN0()
{
	return(tic_event_count);
}

VOID tic_event_init IFN0()
{
	tic_ev_set_count(0);
	q_event_init_structs(&tic_list_head, &tic_list_tail, &tic_free_list_head, 
		tic_ev_hash_table, &tic_next_free_handle);
	sure_sub_note_trace0(Q_EVENT_VERBOSE,"tic_event_init called");
}

/*
 *	add item to list of quick events to do
 */
LOCAL q_ev_handle
add_event IFN10(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
	       t_q_event **, table, q_ev_handle *, free_handle, Q_CALLBACK_FN, func,
	       unsigned long, time, long,  param, unsigned long, time_to_next_trigger,
	       EVENTTYPE, event_type )
{

	t_q_event *ptr, *nptr, *pp, *hptr;
	int finished;
	unsigned long run_time;
	q_ev_handle handle;

	if (*head != NULL)
	{
		(*head)->time_from_last = time_to_next_trigger;
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"add_event changes current list head to %d",
				(*head)->time_from_last);

	}

	if (time==0)
	{
		/* do func immediately */
		sure_sub_note_trace0(Q_EVENT_VERBOSE, "add_event doing func immediately");
		(*func)(param);
		return 0;
	}

	/* get a structure element to hold the event */
	if (*free == NULL)
	{
		/* we have no free list elements, so we must create one */
#if defined(SFELLOW)
		if ((nptr = (t_q_event *)makeSomeFreeEvents()) ==
#else
		if ((nptr = (t_q_event *)host_malloc(sizeof(t_q_event))) ==
#endif	/* SFELLOW */
			(t_q_event *)0 )
		{
			always_trace0("ARRGHH! malloc failed in add_q_event");
#if defined(SFELLOW)
			return 0;
#else
			return 0xffff;
#endif	/* SFELLOW */
		}
	}
	else
	{
		/* use the first free element */
		nptr = *free;
		*free = nptr->next_free;
	}

	handle = (*free_handle)++;
	if ((handle == 0) || (handle == 0xffff))
	{
		handle = 1;
		*free_handle=2;
	}
	nptr->handle = handle;
	nptr->param = param;
	nptr->event_type = event_type;

	/* now put the new event into the hash table structure */
	hptr=table[handle & HASH_MASK];
	if (hptr == NULL)
	{
		/* the event has hashed to a previously unused hash */
		table[handle & HASH_MASK] = nptr;
	}
	else
	{
		/* find the end of the list of events that hash to this
		** hash number
		*/
		while ((hptr->next_free) != NULL)
		{
			hptr = hptr->next_free;
		}
		hptr->next_free = nptr;
	}
	nptr -> next_free = NULL;

	/* fill the rest of the element */
	nptr->func=func;

	/* find the place in the list (sorted in time order) where
	   the new event must go */
	ptr = *head;
	run_time = 0;
	finished = FALSE;
	while (!finished)
	{
		if (ptr == NULL)
		{
			finished=TRUE;
		}
		else
		{
			run_time += ptr->time_from_last;
			if (time < run_time)
			{
				finished=TRUE;
			}
			else
			{
				ptr=ptr->next;
			}
		}
	}

	/* ptr points to the event which should follow the new event in the
	** list, so if it is NULL the new event goes at the end of the list.
	*/	
	if (ptr == NULL)
	{
		/* must add on to the end of the list */
		if (*tail==NULL)
		{
			/* list is empty */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,
				"linked list was empty");
			*head = *tail = nptr;
			nptr->next = NULL;
			nptr->previous=NULL;
			nptr->time_from_last = time;
			nptr->original_time = time;
		}
		else
		{
			(*tail)->next = nptr;
			nptr->time_from_last = time-run_time;
			nptr->original_time = nptr->time_from_last;
			nptr->previous = *tail;
			*tail = nptr;
			nptr->next = NULL;
			sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"adding event to the end of the list, diff from previous = %d",
				nptr->time_from_last);
		}
	} 
	else 
	{
		/* event is not on the end of the list */
		if (ptr->previous == NULL)
		{
			/* must be at head of (non empty) list */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,
				"adding event to the head of the list");
			*head=nptr;
			ptr->previous = nptr;
			nptr->time_from_last = time;
			nptr->original_time = time;
			ptr->time_from_last -= time;
			nptr->next = ptr;
			nptr->previous = NULL;
		}
		else
		{
			/* the event is in the middle of the list */
			pp = ptr->previous;
			pp->next = nptr;
			ptr->previous = nptr;
			nptr->next = ptr;
			nptr->previous = pp;
			nptr->time_from_last = time -
				(run_time-(ptr->time_from_last));
			nptr->original_time = nptr->time_from_last;
			ptr->time_from_last -= nptr->time_from_last;
			sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"adding event to the middle of the list, diff from previous = %d",
				nptr->time_from_last);
		}
	}

	return(handle);
}

GLOBAL q_ev_handle add_q_event_i IFN3(Q_CALLBACK_FN, func,
				 unsigned long, instrs,
			         long, param)
{
	return(gen_add_q_event(func, instrs, param, EVENT_INSTRUCTIONS));
}

LOCAL q_ev_handle gen_add_q_event IFN4(Q_CALLBACK_FN, func,
				 unsigned long, event_value,
			         long, param,
				 EVENTTYPE, event_type)
{
	q_ev_handle handle;
	unsigned long	jumps_remaining_to_count_down;
	unsigned long	time_remaining_to_next_trigger;
	unsigned long	jumps_till_trigger;
	unsigned long	event_time;

#if (defined(NTVDM) && defined(MONITOR)) || defined(GISP_CPU)	/* No quick events - just call func */
    (*func)(param);
    return(1);
#endif	/* NTVDM & MONITOR */

#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	jumps_remaining_to_count_down = (unsigned long)host_q_ev_get_count();

#if defined(CPU_40_STYLE)
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"jumps remaining to count down in cpu = %d",
		jumps_remaining_to_count_down);

	time_remaining_to_next_trigger =
		host_calc_q_ev_time_for_inst( jumps_remaining_to_count_down );
#else
	time_remaining_to_next_trigger = jumps_remaining_to_count_down;
#endif

	if( event_type == EVENT_TIME )
	{
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
			"got request to do func in %d usecs", event_value);

		/* 1 usec -> 1 usec */
		event_time = event_value;
	}
	else
	{
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
			"got request to do func in %d instructions", event_value);
		
		/* 1 million instrs/sec -> 1 instr takes 1 usec */
		event_time = event_value;
	}

	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"time remaining to next trigger = %d", time_remaining_to_next_trigger);

	handle = add_event( &q_list_head, &q_list_tail, &q_free_list_head, 
		q_ev_hash_table, &next_free_handle, func, event_time, param,
		time_remaining_to_next_trigger, event_type );

	/* set up the counter */
	if (q_list_head)
	{
#ifdef CPU_40_STYLE

		if (q_list_head->time_from_last > q_list_head->original_time)
		{
			jumps_till_trigger = 1;
		}
		else
		{
			jumps_till_trigger = host_calc_q_ev_inst_for_time(
						q_list_head->time_from_last);

			if (jumps_till_trigger == 0)
			{
				jumps_till_trigger = 1;
			}
		}
		host_q_ev_set_count(jumps_till_trigger);

		sure_sub_note_trace1( Q_EVENT_VERBOSE,
			"setting CPU counter to %d", jumps_till_trigger );

#else	/* CPU_40_STYLE */

		host_q_ev_set_count(q_list_head->time_from_last);
#endif	/* CPU_40_STYLE */
	}
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"q_event returning handle %d",handle);

        /*
         * Notify host of event iff we are really queueing it. This is
         * to support CPUs that don't drive qevents (Sun HW)
         */
        host_note_queue_added(event_value);

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif

	return(	(q_ev_handle)handle );
}

q_ev_handle add_tic_event IFN3(Q_CALLBACK_FN, func, unsigned long, time, long, param)
{
	q_ev_handle handle;
	unsigned long	cur_count_val;

	cur_count_val = (unsigned long)tic_ev_get_count();
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"got request to do func in %d ticks", time);
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"current tick delay count = %d", cur_count_val);

	handle = 
		add_event( &tic_list_head, &tic_list_tail, &tic_free_list_head, 
		tic_ev_hash_table, &tic_next_free_handle, func, time, param,
		cur_count_val, EVENT_TICK );
	/* set up the counter */
	if (tic_list_head)
		tic_ev_set_count(tic_list_head->time_from_last);
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"tic_event returning handle %d",handle);
	return(	handle );
}

GLOBAL q_ev_handle add_q_event_t IFN3(Q_CALLBACK_FN, func, unsigned long, time,
				 long, param)
{
#ifdef CPU_40_STYLE
	return (gen_add_q_event(func, time, param, EVENT_TIME));
#else
	return (gen_add_q_event(func, host_calc_q_ev_inst_for_time(time),param, EVENT_TIME));
#endif
}

/*
 * Called from the cpu when a count of zero is reached
 */

LOCAL VOID
dispatch_event IFN6(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
			  TQ_TABLE, table, VOID_FUNC, set_count, ULONG_FUNC, get_count )
{
	/* now is the time to do the event at the head of the list */
	int finished, finished2;
	q_ev_handle handle;
	t_q_event *ptr, *hptr, *last_hptr;

	UNUSED(get_count);
	
	finished = FALSE;
	while (!finished) {
		/* first adjust the lists */
		ptr = *head;
		if (ptr == NULL)	/* firewall */
		{
    			finished = TRUE;
    			continue;
		}
		*head = ptr->next;
		if (*head != NULL) {

			IU32 jumps;

			(*head)->previous = NULL;
			/* adjust counter to time to new head item */

			jumps = host_calc_q_ev_inst_for_time(
					(*head)->time_from_last);

			/* A quick event delay of zero means ignore */

			if( jumps == 0 )
			{
				/* Convert to a small but actionable delay */

				jumps = 1;
			}

			switch( (*head)->event_type )
			{
				case EVENT_TIME:

					sure_sub_note_trace2( Q_EVENT_VERBOSE,
						"set new time delay %d usecs -> %d jumps",
						(*head)->time_from_last,
						jumps );

					(*set_count)( jumps );
					
					break;

				case EVENT_INSTRUCTIONS:
#ifdef CPU_40_STYLE
					sure_sub_note_trace2( Q_EVENT_VERBOSE,
						"set new inst delay %d usecs -> %d jumps",
						(*head)->time_from_last,
						jumps );

					(*set_count)( jumps );

#else
					sure_sub_note_trace1(Q_EVENT_VERBOSE,
						"set new inst delay %d",
						(*head)->time_from_last );

					(*set_count)((*head)->time_from_last);
#endif
					break;

				case EVENT_TICK:
					sure_sub_note_trace1(Q_EVENT_VERBOSE,
						"set new tick delay %d",
						(*head)->time_from_last );

					(*set_count)((*head)->time_from_last);

					break;

				default:
#ifndef PROD
					always_trace1( "Invalid quick event type %d",
								(*head)->event_type );
					assert( FALSE );
#endif
					break;
			}
			
		} else {
			/* the queue is now empty */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,"list is now empty");
			*tail = NULL;
		}
		/* find the event in the hash structure */
		handle = ptr->handle;
		finished2 = FALSE;
		hptr=table[handle & HASH_MASK];
		last_hptr = hptr;
		while (!finished2) {
			if (hptr == NULL) {
				finished2 = TRUE;
				always_trace0("quick event being done but not in hash list!!");
			} else {
				if (hptr->handle == handle) {
					/* found it! */
					finished2 = TRUE;
					if (last_hptr == hptr) {
						/* it was the first in the list for that hash */
						table[handle & HASH_MASK] = hptr->next_free;
					} else {
						last_hptr->next_free = hptr->next_free;
					}
				} else {
					last_hptr = hptr;
					hptr = hptr->next_free;
				}
			}
		}
		/* link the newly free element into the free list */
		ptr->next_free = *free;
		*free = ptr;

		sure_sub_note_trace1(Q_EVENT_VERBOSE,"performing event (handle = %d)", handle);

		(* (ptr->func))(ptr->param); /* do event */

		if (*head == NULL) {
			finished = TRUE;
		} else {
			if ((*head) -> time_from_last != 0) {
				/* not another event to dispatch */
				finished=TRUE;
			} else {
				sure_sub_note_trace0(Q_EVENT_VERBOSE,"another event to dispatch at this time, so do it now..");
			}
		}
	}
}

VOID    user_dispatch_q_event (user_set_count,user_get_count)

VOID    (*user_set_count)();
ULONG   (*user_get_count)();

{
        dispatch_event(&q_list_head,
                        &q_list_tail,
                        &q_free_list_head,
                        q_ev_hash_table,
                        user_set_count,
                        user_get_count);
}

VOID	dispatch_tic_event IFN0()
{
	ULONG	count;

	if ( (count = tic_ev_get_count()) > 0 )
	{
		tic_ev_set_count( --count );
		if (!count)
			dispatch_event( &tic_list_head, &tic_list_tail, 
				&tic_free_list_head, tic_ev_hash_table,
				tic_ev_set_count, tic_ev_get_count );
	}
}

VOID	dispatch_q_event IFN0()
{
#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	dispatch_event( &q_list_head, &q_list_tail, &q_free_list_head,
			q_ev_hash_table, host_q_ev_set_count,
			host_q_ev_get_count );

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif
}

/*
 * delete a previuosly queued event by handle
 */

LOCAL ULONG
unit_scaler IFN1
(
	IU32,	val
)
{
	return val;
}

LOCAL VOID
delete_event IFN7(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
			TQ_TABLE, table, q_ev_handle, handle, VOID_FUNC, set_count,
			ULONG_FUNC, get_count )
{
	int time_counted_down, finished, cur_counter, handle_found, time_to_next_trigger;
	t_q_event *ptr, *pptr, *last_ptr;
	ULONG_FUNC scale_func, unscale_func;

	if (handle == 0)
	{
		sure_sub_note_trace0(Q_EVENT_VERBOSE," zero handle");
		return;
	}
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"deleting event, handle=%d",handle);
	ptr = table[handle & HASH_MASK];

	handle_found = FALSE;
	finished = FALSE;
	last_ptr = ptr;

	/* find and remove event from hash structure */
	while (!finished) {
		if (ptr == NULL) {
			/* we can't find the handle in the hash structure */
			finished = TRUE;
		} else {
			if (ptr->handle == handle) {
				/* found it ! */
				if (last_ptr == ptr) {
					/* it was the first in the list */
					table[handle & HASH_MASK] = ptr->next_free;
				} else {
					last_ptr->next_free = ptr->next_free;
				}
				finished = TRUE;
				handle_found = TRUE;
			} else {
				last_ptr = ptr;
				ptr = ptr->next_free;
			}
		}
	}
	if (handle_found) {
		pptr = ptr->previous;
		if (pptr != NULL) {
			pptr->next = ptr->next;
		}
		pptr = ptr->next;
		if (pptr != NULL) {
			pptr->previous = ptr->previous;
			pptr->time_from_last += ptr->time_from_last;
		}
		if (ptr == *tail) {
			*tail = ptr->previous;
		}
		ptr->next_free = *free;
		*free = ptr;
		if (ptr == *head) {
			/* this is the event currently
				being counted down to, so
				we need to alter the counter */

			switch( (*head)->event_type )
			{
				case EVENT_TIME:
				case EVENT_INSTRUCTIONS:
#if defined(CPU_40_STYLE)
					scale_func = host_calc_q_ev_inst_for_time;
#else
					scale_func = unit_scaler;
#endif
					unscale_func = host_calc_q_ev_time_for_inst;
					break;

				case EVENT_TICK:
					sure_sub_note_trace0( Q_EVENT_VERBOSE,
							"deleting tick event" );
					scale_func = unit_scaler;
					unscale_func = unit_scaler;

					break;

				default:
#ifndef PROD
					always_trace1( "Invalid quick event type %d",
								(*head)->event_type );
					assert( FALSE );
#endif
					break;
			}

			cur_counter = (*get_count)();

#ifdef CPU_40_STYLE
			/*
			 * We are deleting an unexpired event at the
			 * the head of the queue. In the EDL CPU it is
			 * impossible for this event to still be in the
			 * queue and cur_counter to be negative.
			 * This is also true of the tick event counter
			 * mechanism ( see dispatch_tic_event() ).
			 */

#ifndef PROD
			if( cur_counter < 0 )
			{
				always_trace1( "cur_counter is negative (%d)",
								cur_counter );
				FmDebug(0);
			}
#endif
#endif

			time_to_next_trigger = (*scale_func)(cur_counter);
			time_counted_down = ptr->time_from_last - time_to_next_trigger;

			*head = ptr->next;
			pptr = ptr->next;
			if (pptr != NULL) {
				/*
				 * pptr->time_from_last was adjusted above to include
				 * the time_from_last of the event we are deleting
				 */

				if (pptr->time_from_last <= time_counted_down)
				{
					/* enough elapsed to dispatch next */
					dispatch_q_event();
				}
				else
				{
					/* set countdown from new head */
					pptr->time_from_last -= time_counted_down;
					(*set_count)(
						(*unscale_func)( pptr->time_from_last ));
				}
			}else {
				/* event list is now empty */
				(*set_count)(0);
			}
		} 
		sure_sub_note_trace0(Q_EVENT_VERBOSE,"event deleted");
	} else {
		sure_sub_note_trace0(Q_EVENT_VERBOSE,"handle not found");
	}
}

VOID delete_q_event IFN1(q_ev_handle, handle )
{
#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	delete_event( &q_list_head, &q_list_tail, &q_free_list_head,
		q_ev_hash_table, handle, host_q_ev_set_count,
		host_q_ev_get_count );

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif
}

VOID delete_tic_event IFN1(q_ev_handle,  handle )
{
	delete_event( &tic_list_head, &tic_list_tail, &tic_free_list_head,
		tic_ev_hash_table, handle, tic_ev_set_count,
		tic_ev_get_count );
}

#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL void
init_q_ratio IFN0()
{
	ISH loop;

#ifdef CCPU
	/* CCPU doesn't support recalibrating quick evs */
	DisableQuickTickRecal = TRUE;
#endif
	if (host_getenv("DisableQuickTickRecal") != (char *)0)
		DisableQuickTickRecal = TRUE;

	/* initialise q_ratio buffer */
	for (loop = 0; loop < Q_RATIO_HISTORY_SIZE; loop++)
	{
		q_ratio_history[loop].jc_ms = Q_RATIO_DEFAULT;
		q_ratio_history[loop].time_ms = Q_RATIO_DEFAULT;
	}
	ideal_q_rate = 1;
	real_q_rate = 1;
	/* write 'first' timestamp */
	host_q_write_timestamp(&previous_tstamp);
	q_ratio_initialised = TRUE;
}

LOCAL void
add_new_q_ratio IFN2(IU32, jumps_ms, IU32, time_ms)
{
	/* add new value & update circular buffer index */
	q_ratio_history[q_ratio_head].jc_ms = jumps_ms;
	q_ratio_history[q_ratio_head].time_ms = time_ms;
	q_ratio_head = (q_ratio_head + 1) & Q_RATIO_WRAP_MASK;
}

LOCAL void
q_weighted_ratio IFN2(IU32 *, mant, IU32 *, divis)
{
	IUM32 index;
	IU32 jsum, jmin = (IU32)-1, jmax = 0;
	IU32 tsum, tmin = (IU32)-1, tmax = 0;

	index = q_ratio_head;	/* start at 'oldest' (next to be overwritten) */
	tsum = jsum = 0;
	/* take sum of history ratios */
	do {
		/* update sum of jumps + max & min */
		if (q_ratio_history[index].jc_ms < jmin)
			jmin = q_ratio_history[index].jc_ms;
		if (q_ratio_history[index].jc_ms > jmax)
			jmax = q_ratio_history[index].jc_ms;
		jsum += q_ratio_history[index].jc_ms;

		/* update sum of time + max & min */
		if (q_ratio_history[index].time_ms < tmin)
			tmin = q_ratio_history[index].time_ms;
		if (q_ratio_history[index].time_ms > tmax)
			tmax = q_ratio_history[index].time_ms;
		tsum += q_ratio_history[index].time_ms;

		index = (index + 1) & Q_RATIO_WRAP_MASK;

	} while(index != q_ratio_head);

	/* remove extreme values */
	jsum -= jmin;
	jsum -= jmax;

	tsum -= tmin;
	tsum -= tmax;

	jsum /= Q_RATIO_HISTORY_SIZE - 2;
	tsum /= Q_RATIO_HISTORY_SIZE - 2;

	*mant = jsum;
	*divis = tsum;
}

/***********************************************************************
	Recalibration:

ijc == InitialJumpCounter
measure minimum counter period - ijc->0 counters. (usecPerIJC)

1 tick = 54945us

so 1 tick 'should' take 54945/usecPerIJC = N (ijc) jumps.

per tick:
	get time delta.  (approx 54945)
	divide by usecPerIJC to get # of ijc's. (numijc)
	multiply by ijc to get theoretical jumpcal for delta. (idealjc)
	get real jumpcal for delta. 	(realjc)

tick adjust ratio is therefore   realjc * requestime / idealjc

****************************************************************************/

/* calculate a number for number of pig-synchs per microsecond for a 33Mhz processor:
** Assume a synch on average every 5 Intel instructions, and each intel
** instruction takes about 2 cycles on average. The proper answer comes out as
** 3.3, but this has to be an integer, so round it down to 3
*/
#define SYNCS_PER_USEC		3

static IU32 jumpRestart = (IU32)-1;
static IU32 usecPerIJC = (IU32)-1;

/*
 * host_calc_q_ev_inst_for_time for CPU_40_STYLE ports. See above for
 * recalibration vars used to scale time->jumps
 */

IU32
calc_q_inst_for_time IFN1(IU32, time)
{
#ifdef SYNCH_TIMERS
	return (time * SYNCS_PER_USEC);
#else
	IU32 inst, jumps;

	/* be crude before initialisation */
	if (usecPerIJC == (IU32)-1)
		return(time / 10);	/* CCPU style! */
	
	/* first adjust us -> jumps */
	jumps = (time * jumpRestart) / usecPerIJC;

	/* now fine adjust jumps for recent period */
	inst = (jumps * real_q_rate) / (ideal_q_rate);

	return(inst);
#endif /* SYNCH_TIMERS */
}

/*
 * Time quick events are held internally with time unscaled. CPU reports
 * current elapsed time as scaled - convert from scaled->unscaled.
 * This routine implements the mathematical inverse of the above routine
 * except for the boundary condition checking.
 */

IU32
calc_q_time_for_inst IFN1(IU32, inst)
{
#ifdef SYNCH_TIMERS
	return (inst / SYNCS_PER_USEC);
#else
	IU32 time, jumps;

	/* be crude before initialisation */
	if (usecPerIJC == (IU32)-1)
		return(inst * 10);	/* CCPU style! */
	
	/* remove fine scaling */
	jumps = (inst * ideal_q_rate) / real_q_rate;

	/* now usec/jump adjustment */
	time = (jumps * usecPerIJC) / jumpRestart;

	/* allow for rounding to 0 on small numbers */
	if (time == 0 && inst != 0)
		return(inst);
	else
		return(time);
#endif /* SYNCH_TIMERS */
}

#define FIRSTFEW 33
#define IJCPERIOD 91

GLOBAL void
quick_tick_recalibrate IFN0()
{
	QTIMESTAMP now;
	IU32 idealrate, realrate;
	IUH tdiff;
	extern int soft_reset;
	static int firstfew = FIRSTFEW;
	static QTIMESTAMP ijc_tstamp;
	static IU32 ijc_recount, ijc_calib;

#if defined(CCPU) || !defined(PROD)
	/* allow dev disabling of quick tick recal. Yoda 'qrecal {on|off}' */
	if (DisableQuickTickRecal)
	{
		ideal_q_rate = Q_RATIO_DEFAULT;
		real_q_rate = Q_RATIO_DEFAULT;
		return;
	}
#endif	/* PROD */

	/* Boot time introduces some unrealistic time intervals - avoid them */
	if (!soft_reset)
		return;

	/* quick event initialisation only on warm boot */
	if (!q_ratio_initialised)
	{
		init_q_ratio();
		return;
	}

	if (firstfew)
	{
		switch (firstfew)
		{
		case FIRSTFEW:	/* first tick after reset */
			host_q_write_timestamp(&previous_tstamp);
			jumpRestart = host_get_jump_restart();
			break;

		case 1:		/* last tick of 'firstfew' */
			host_q_write_timestamp(&now);
			/* get real elapsed time of firstfew ticks */
			tdiff = host_q_timestamp_diff(&previous_tstamp, &now);

			/* get CPU activity rate in the period */
			realrate = host_get_q_calib_val();

			usecPerIJC = (tdiff * jumpRestart) / realrate;

			sure_sub_note_trace4(Q_EVENT_VERBOSE,
				"Baseline time for ijc = %d us (%d*%d)/%d",
				usecPerIJC, tdiff,
				jumpRestart, realrate);
			host_q_write_timestamp(&previous_tstamp);
			ijc_tstamp.data[0] = previous_tstamp.data[0];
			ijc_tstamp.data[1] = previous_tstamp.data[1];
			ijc_recount = IJCPERIOD;
			ijc_calib = 1;
			break;
		}
		firstfew --;
		return;
	}
	else	/* periodic update of usecPerIJC value */
	{
		ijc_recount--;
		if (ijc_recount == 0)
		{
			if (ijc_calib > 50000)	/* questimate value 1% of us */
			{
				host_q_write_timestamp(&now);
				tdiff = host_q_timestamp_diff(&ijc_tstamp, &now);
				usecPerIJC = (tdiff * jumpRestart) / ijc_calib;
				sure_sub_note_trace4(Q_EVENT_VERBOSE,
					"New usecPerIJC %d us (%d*%d)/%d",
					usecPerIJC, tdiff,
					jumpRestart, ijc_calib);
				ijc_recount = IJCPERIOD;
				ijc_tstamp.data[0] = now.data[0];
				ijc_tstamp.data[1] = now.data[1];
				ijc_calib = 1;
			}
			else	/* too small (idling?) - keep current value for now */
			{
				sure_sub_note_trace1(Q_EVENT_VERBOSE,
					"No new usecPerIJC as calib too small (%d)", ijc_calib);
				host_q_write_timestamp(&ijc_tstamp);
				ijc_calib = 1;
				ijc_recount = IJCPERIOD;
			}
		}
	}

	/* make ratio of code progress to elapsed time period */
	host_q_write_timestamp(&now);
	tdiff = host_q_timestamp_diff(&previous_tstamp, &now);

	/*
 	* The recalibration must be done by the 'slow' ticker. If the
 	* heartbeat is running too quickly for some reason, ignore
 	* recal requests until approx correct period is achieved. (This
 	* definition of 'correct' allows for signal waywardness).
 	*/
	if (tdiff < 5000)
		return;

	/* idle, graphics, net waits all can spoil recalibrations day... */
	if (tdiff > 5*54945)	/* 54945 is 1000000us/18.2 */
	{
		/* skip this attempt, try again when more settled */
		host_q_write_timestamp(&previous_tstamp);
		return;
	}

	idealrate = (tdiff * jumpRestart) / usecPerIJC;

	if (idealrate == 0)
		return;		/* usecPerIJC too high - idling or stuck in C */

	realrate = host_get_q_calib_val();

	if (realrate == 0)	/* must be idling or stuck in C */
		return;		/* try again when actually moving */

	ijc_calib += realrate;

#ifdef AVERAGED	/* not for the moment */
	/* add new value to buffer */
	add_new_q_ratio(idealrate, realrate);

	/* ... and get average of accumulated ratios */
	q_weighted_ratio(&ideal_q_rate, &real_q_rate);
#else
	ideal_q_rate = idealrate;
	real_q_rate = realrate;
#endif

	/* timestamp for next recalc period */
	host_q_write_timestamp(&previous_tstamp);
}




#ifndef NTVDM

/* functions required to implement the add_q_ev_int_action interface */
LOCAL Q_INT_ACT_REQ int_act_qhead;
IS32 int_act_qident = 0;

/*(
 =========================== add_new_int_action ==========================
PURPOSE: add to the add_q_ev_int_action queue.
INPUT:  func, adapter, line, parm - as add_q_ev_int_action
OUTPUT: queue identifier or -1 failure
=========================================================================
)*/
LOCAL IU32
add_new_int_action IFN4(Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, parm)
{
	Q_INT_ACT_REQ_PTR qptr, prev;	/* list walkers */
	SAVED IBOOL firstcall = TRUE;

	if (firstcall)	/* ensure head node setup on first call */
	{
		firstcall = FALSE;
		int_act_qhead.ident = 0;
		int_act_qhead.next = Q_INT_ACT_NULL;
	}

	/* maintain permanent head node for efficiency */

	/* check whether head used (ident == 0 means unused) */
	if (int_act_qhead.ident == 0)
	{
		/* copy parameters to head node */
		int_act_qhead.func = func;
		int_act_qhead.adapter = adapter;
		int_act_qhead.line = line;
		int_act_qhead.param = parm;

		/* get identifier for node */
		int_act_qident ++;
		/* cope with (eventual) wrap */
		if (int_act_qident > 0)
			int_act_qhead.ident = int_act_qident;
		else
			int_act_qhead.ident = int_act_qident = 1;
	}
	else	/* find end of queue */
	{
		/* start where head node points */
		qptr = int_act_qhead.next;
		prev = &int_act_qhead;

		while (qptr != Q_INT_ACT_NULL)
		{
			prev = qptr;
			qptr = qptr->next;
		}
		/* add new node */
		prev->next = (Q_INT_ACT_REQ_PTR)host_malloc(sizeof(Q_INT_ACT_REQ));
		/* malloc ok? */
		if (prev->next == Q_INT_ACT_NULL)
			return((IU32)-1);

		/* initialise node */
		qptr = prev->next;
		qptr->next = Q_INT_ACT_NULL;
		qptr->func = func;
		qptr->adapter = adapter;
		qptr->line = line;
		qptr->param = parm;

		/* get identifier for node */
		int_act_qident ++;
		/* cope with (eventual) wrap */
		if (int_act_qident > 0)
			qptr->ident = int_act_qident;
		else
			qptr->ident = int_act_qident = 1;
	}

	sure_sub_note_trace2(Q_EVENT_VERBOSE,"add_new_q_int_action added fn %#x as id %d", (IHPE)func, int_act_qident);
}

/*(
 =========================== select_int_action ==========================
PURPOSE: choose from the q'ed add_q_ev_int_action requests which delay has
	 expired. Call action_interrupt with the appropriate parameters. Remove
	 request from queue.
INPUT:  long: identifier of request 
OUTPUT: None.
=========================================================================
)*/
LOCAL void
select_int_action IFN1(long, identifier)
{
	Q_INT_ACT_REQ_PTR qptr, prev;	/* list walkers */

	/* check permanent head node first */
	if (int_act_qhead.ident == (IS32)identifier)
	{
		action_interrupt(int_act_qhead.adapter, int_act_qhead.line,
				int_act_qhead.func, int_act_qhead.param);
		int_act_qhead.ident = 0;	/* mark unused */
	}
	else	/* search list */
	{
		/* start search beyond head */
		qptr = int_act_qhead.next;
		prev = &int_act_qhead;

		while (qptr != Q_INT_ACT_NULL && qptr->ident != (IS32)identifier)
		{
			prev = qptr;
			qptr = qptr->next;
		}
		
		/* if node found, dispatch action_int */
		if (qptr != Q_INT_ACT_NULL)
		{
			action_interrupt(qptr->adapter, qptr->line, qptr->func, qptr->param);
			/* and remove node */
			prev->next = qptr->next;	/* connect around node */
			host_free(qptr);		/* chuck back on heap */
		}
		else	/* odd - identifier not found! */
		{
			assert1(FALSE, "select_int_action: id %d not found",identifier);
		}
	}
}

/*(
 =========================== add_q_ev_int_action ==========================
PURPOSE: Prepare to call a hardware interrupt after a quick event managed 
	 delay. The interrupt must be called from the passed callback
	 function at the same time as any associated emulation. The callback
	 will be called once the delay has expired and the cpu is ready to
	 receive interrupts on the passed line. See also ica.c:action_interrupt()

INPUT:  time: unsigned long - us of delay before calling action_interrupt
	func: callback function address to callback when line available.
	adapter: IU32. master/slave.
	line: IU32. IRQ line interrupt will appear on.
	parm: IU32. parameter to pass to above fn.

OUTPUT: Returns q_ev_handle associated with quick event delay
=========================================================================
)*/
GLOBAL q_ev_handle
add_q_ev_int_action IFN5(unsigned long, time, Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, parm)
{
	IU32 action_id;		/* int_action list id */

	/* store action_int parameters in internal list */
	action_id = add_new_int_action(func, adapter, line, parm);

	/* check for failure */
	if (action_id == -1)
		return((q_ev_handle)-1);

	/* set quick event up to call selection func on expiry */
	return( add_q_event_t(select_int_action, time, (long)action_id) );
}

#endif

#endif /* CPU_40_STYLE && !SFELLOW */

#ifdef QEVENT_TESTER

/*
 * The routine qevent_tester() below can be called from a BOP, which
 * in turn can be called from a .BAT file using bop.com in a loop.
 * This doesn't test the quick event system exhaustively but puts it
 * under a bit more pressure.
 */

LOCAL q_ev_handle handles[256];
LOCAL IU8 deleter = 1;

LOCAL void
tester_func IFN1
(
	IU32,	param
)
{
	SAVED IU8 do_delete = 0;

	handles[param] = 0;

	if( handles[deleter] && (( do_delete++ & 0x1 ) == 0 ))
	{
		delete_q_event( handles[deleter] );
	}

	deleter += 7;
}

GLOBAL void
qevent_tester IFN0()
{
	SAVED IU8 indx = 0;

	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 100, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 300, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 1000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 3000, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 10000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 30000, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 100000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 300000, indx );
}
#endif /* QEVENT_TESTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\system.c ===
#if defined(NEC_98)

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "insignia.h"
#include "host_def.h"
#include <stdio.h>
#include "xt.h"
#include "ios.h"
#include "bios.h"
#include "sas.h"
#include "trace.h"
#include "debug.h"


#define GDC_5MHz                0x00
#define GDC_2MHz                0x80
#define FIXED_DISK_OFF          0x00
#define FIXED_DISK_ON           0x20
#define MEMORY_SWITCH_HOLD      0x00
#define MEMORY_SWITCH_UNHOLD    0x10
#define DISPLAY_LOW_25          0x00
#define DISPLAY_LOW_20          0x08
#define DISPLAY_COL_80          0x00
#define DISPLAY_COL_40          0x04
#define TERMINAL_MODE           0x00
#define BASIC_MODE              0x02
#define DIP_SWITCH_2    ( 0x41 | FIXED_DISK_ON | MEMORY_SWITCH_HOLD | DISPLAY_LOW_25 | DISPLAY_COL_80 | BASIC_MODE )
#define HIRESO_CRT              0x08

#define MODE_SET_8255           0x92
#define RXRE                    0x00
#define TXEE                    0x02
#define TXRE                    0x04
#define SPEEKER                 0x06
#define MEMORY_CHECK            0x08
#define SHUT1                   0x0A
#define PSTB_MASK               0x0C
#define SHUT0                   0x0E

struct  sysporttag
{
        half_word       speeker;
        half_word       memorycheck;
        half_word       shut0;
        half_word       shut1;
        half_word       pstbmask;
};

struct  sysporttag      sysport;

half_word cal_register[48+1];
half_word cal_cmd_reg;
half_word cal_ex_cmd_reg;
half_word cal_ex_cmd_reg_tmp;
half_word cal_stb;
half_word cal_clk;
int cal_reg_no;
int cal_ex_cmd_cur_no;

#define STB_MASK 0x08
#define CLK_MASK 0x10
#define DI_MASK 0x20
#define CMD_MASK 0x07

#define EX_MODE                         7

#define EX_REGISTER_HOLD                0
#define EX_REGISTER_SHIFT               1
#define EX_TIMESET_COUNTER_HOLD         2
#define EX_TIME_READ                    3

extern GLOBAL UCHAR Configuration_Data[1192];
extern void com_inb(io_addr, half_word *);
extern void com_outb(io_addr, half_word *);
extern BOOL VDMForWOW;
extern VOID host_enable_timer2_sound();
extern VOID host_disable_timer2_sound();
extern void NEC98_in_port_35();
extern void NEC98_out_port_35();
extern void NEC98_out_port_37();
void sys_port_inb();
void sys_port_outb();
void cpu_port_inb();
void cpu_port_outb();

void call_com_inb IFN2(io_addr, port, half_word *, value)
{
    if(VDMForWOW)
        wow_com_inb(port, value);
    else
        com_inb(port, value);
}

void call_com_outb IFN2(io_addr, port, half_word, value)
{
    if(VDMForWOW)
        wow_com_outb(port, value);
    else
        com_outb(port, value);
}

void sys_port_init IFN0()
{
    io_define_inb(SYSTEM_PORT, sys_port_inb);
    io_define_outb(SYSTEM_PORT, sys_port_outb);

    io_connect_port(SYSTEM_READ_PORT_A, SYSTEM_PORT, IO_READ);
    io_connect_port(SYSTEM_READ_PORT_B, SYSTEM_PORT, IO_READ_WRITE);
    io_connect_port(SYSTEM_READ_PORT_C, SYSTEM_PORT, IO_READ_WRITE);
    io_connect_port(SYSTEM_WRITE_MODE, SYSTEM_PORT, IO_READ_WRITE);
}

void sys_port_post IFN0()
{
    sysport.speeker = 1;
    sysport.memorycheck = 0;
    sysport.shut0 = 0;
    sysport.shut1 = 0;
    sysport.pstbmask = 1;
}

void sys_port_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port){
        case SYSTEM_READ_PORT_A:
            *value = DIP_SWITCH_2;
            if(!(Configuration_Data[40+BIOS_NEC98_PRXDUPD-0x400] & 0x20))
                *value |= GDC_2MHz;
            break;

        case SYSTEM_READ_PORT_B:
            call_com_inb(port, value);
            *value &= 0xE0;
            *value |= HIRESO_CRT;
            *value |= (cal_register[cal_reg_no/8] >> (cal_reg_no % 8)) & 1;
            break;

        case SYSTEM_READ_PORT_C:
            call_com_inb(port,value);
            NEC98_in_port_35(value);
            break;

        case SYSTEM_WRITE_MODE:
            com_inb(port,value);
            break;
    }
}

void sys_port_outb IFN2(io_addr, port, half_word, value)
{
    half_word   flag;
    half_word   command;

    switch(port){
        case SYSTEM_READ_PORT_B:
            call_com_outb(port, value);
            break;

        case SYSTEM_READ_PORT_C:
            call_com_outb(port, value);
            NEC98_out_port_35(value);
            break;

        case SYSTEM_WRITE_MODE:
            command = value & 0xFE;
            flag =  value & 0x01;

            switch(command){
                case MODE_SET_8255:
                    break;

                case RXRE:
                case TXRE:
                case TXEE:
                    call_com_outb(port, value);
                    break;

                case SPEEKER:
                    if(!flag) {
                        if(sysport.speeker)
                            host_enable_timer2_sound();
                    } else {
                        if(!sysport.speeker)
                            host_disable_timer2_sound();
                    }
                    sysport.speeker = flag;
                    break;

                case MEMORY_CHECK:
                    sysport.memorycheck = flag;
                    break;

                case SHUT1:
                    sysport.shut1 = flag;
                    break;

                case PSTB_MASK:
                    sysport.pstbmask = flag;
                    NEC98_out_port_37(value);
                    break;

                case SHUT0:
                    sysport.shut0 = flag;
                    break;

            }
            break;
    }
}

void cpu_port_init IFN0()
{
    io_define_inb(CPU_PORT, cpu_port_inb);
    io_define_outb(CPU_PORT, cpu_port_outb);

    io_connect_port(CPU_PORT_START + 0, CPU_PORT, IO_READ_WRITE);
    io_connect_port(CPU_PORT_START + 2, CPU_PORT, IO_WRITE);
    io_connect_port(CPU_PORT_START + 4, CPU_PORT, IO_READ_WRITE);
    io_connect_port(CPU_PORT_START + 6, CPU_PORT, IO_READ_WRITE);
}

void cpu_port_post IFN0()
{
}

void cpu_port_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port){
        case 0xF0:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
        case 0xF4:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
        case 0xF6:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
    }
}

void cpu_port_outb IFN2(io_addr, port, half_word, value)
{
    switch(port){
        case 0xF0:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
        case 0xF2:
#ifndef PROD
            printf("NTVDM: A20 line enable!!\n");
#endif
            if (sas_twenty_bit_wrapping_enabled())
                xmsDisableA20Wrapping();
            break;
        case 0xF4:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
        case 0xF6:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
    }
}

LOCAL word bin2bcd(word i)
{
    word        bcd_h,bcd_l;

    bcd_h = i / 10;
    bcd_l = i - bcd_h * 10;
    return((bcd_h << 4) + bcd_l);
}

void calender_load IFN0()
{
    SYSTEMTIME  now;
    cal_reg_no = 0;
    GetLocalTime(&now);
    cal_register[0] = bin2bcd(now.wSecond);
    cal_register[1] = bin2bcd(now.wMinute);
    cal_register[2] = bin2bcd(now.wHour);
    cal_register[3] = bin2bcd(now.wDay);
    cal_register[4] = bin2bcd((now.wMonth << 4) | now.wDayOfWeek);
    cal_register[5] = bin2bcd(now.wYear % 100);
}

void set_cal_command IFN0()
{
    switch(cal_cmd_reg) {
        case EX_MODE:
            cal_ex_cmd_reg = cal_ex_cmd_reg_tmp;
            switch(cal_ex_cmd_reg) {
                case EX_TIME_READ:
                    calender_load();
                    break;
                case EX_REGISTER_SHIFT:
                    break;
                default:
#ifndef PROD
                    printf("NTVDM: Illegal Calender mode!!\n");
#endif
                    break;
            }
            break;
        default:
#ifndef PROD
            printf("NTVDM: Illegal Calender mode!!\n");
#endif
            break;
    }
}

void calender_outb IFN2(io_addr, port, half_word, value)
{
    if(value & CLK_MASK) {
        if(cal_cmd_reg == EX_MODE && cal_ex_cmd_reg == EX_REGISTER_SHIFT && cal_reg_no < 48) {
            cal_reg_no++;
        } else {
            if(value & DI_MASK)
                cal_ex_cmd_reg_tmp |= (1 << cal_ex_cmd_cur_no++);
            else
                cal_ex_cmd_reg_tmp &= ~(1 << cal_ex_cmd_cur_no++);
            cal_ex_cmd_cur_no &= 3;
        }
    }
    else if(value & STB_MASK) {
        cal_cmd_reg = value & CMD_MASK;
        set_cal_command();
    }
}

void calender_init IFN0()
{
    io_define_outb(CALENDER_PORT, calender_outb);
    io_connect_port(CALENDAR_SET_REG, CALENDER_PORT, IO_WRITE);
}

void calender_post IFN0()
{
    int i;

    for(i=0;i<48;i++)
        cal_register[i] = 0;
    cal_cmd_reg = 0;
    cal_ex_cmd_reg = 0;
    cal_ex_cmd_reg_tmp = 0;
    cal_stb = 0;
    cal_clk = 0;
    cal_reg_no = 0;
    cal_ex_cmd_cur_no = 0;
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=system
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\at_dma.c      \
        ..\cmosnt.c      \
        ..\ica.c         \
        ..\idetect.c     \
        ..\illegalp.c    \
        ..\qevnt.c       \
        ..\rom.c         \
        ..\timer.c       \
        ..\timestrb.c    \
        ..\dummy_nt.c    \
        ..\system.c      \
        ..\unexp_nt.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\timestrb.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 3.0
 *
 * Title	: Time Strobe
 *
 * Description	: This is the central base routine that is called from the
 *		  host alarm (approx 20 times a second). It replaces the 
 *		  previous time_tick() routine in the timer module which now
 *		  is called from this module's timer_strobe() and just deals
 *		  with the periodic updates required for the timer.
 *
 * Author	: Leigh Dworkin
 *
 * Notes	 :
 * 		  Code has been added to time_tick() to spot
 *                that video has been disabled for a period. If this is
 *                so, clear the screen. Refresh when video is enabled
 *                again.
 *                Modified 21/6/89 by J.D.R. to allow another alarm call
 *                to be made. This is used by the autoflush mechanism.
 *
 */

/*
 * static char SccsID[]="@(#)timestrobe.c	1.12 11/01/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */

/*
 * SoftPC include files
 */
#include "xt.h"
#include "cmos.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "host_qev.h"

#ifdef HUNTER
#include <stdio.h>
#include "hunter.h"
#endif

#include "host_gfx.h"

static void dummy_alarm()
{
}

/**************************************************************************************/
/*                                 External Functions                                  */
/**************************************************************************************/
void time_strobe()
{

#define VIDEO_COUNT_LIMIT    19    /* One second, plus a bit */
    static   int       video_count = 0;
    static   boolean   video_off   = FALSE;

#if !defined(REAL_TIMER) && !defined(NTVDM)
	time_tick();
#endif

#ifdef HUNTER
        do_hunter();
#endif    


#ifndef NTVDM
#ifndef	REAL_TIMER
	/* Update the real time clock */
#ifndef NEC_98
        rtc_tick();
#endif   //NEC_98
#endif	/* REAL_TIMER */

        dispatch_tic_event();

#if defined(CPU_40_STYLE)
	ica_check_stale_iret_hook();
#endif
#endif

        /*
         * Check to see if the screen is currently enabled.
         */
        if (timer_video_enabled) {
            if (video_off) {
                screen_refresh_required();
                video_off = FALSE;
            }
            video_count = 0;
        }
        else {
            video_count++;
            if (video_count == VIDEO_COUNT_LIMIT) {
                host_clear_screen();
                video_off = TRUE;
            }
        }
#ifdef	EGA_DUMP
	dump_tick();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\cg.c ===
#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "debug.h"
#include "cg.h"

extern unsigned short cg_font_load ();
extern void mapping_init();
extern void host_sleep();
extern BOOL cg_lock;
void cg_write_2nd IPT1(half_word,value);
void cg_write_1st IPT1(half_word,value);
void cg_write_count IPT1(half_word,value);
void cg_write_pattern IPT1(half_word,value);
void cg_read_pattern IPT1(half_word *,value);
CG_GLOBS cgglobs;

BOOL half_access;

void cg_write_2nd IFN1(half_word,value) {
        unsigned short  src,dst;
//      if ((value == 0) || ((value >= 0x21) && (value <= 0x7E))) {
                src = (unsigned short) value;
                dst = cgglobs.code;
                cgglobs.code = src |(dst & 0xFF00);
                cg_font_load(cgglobs.code,(unsigned char *) NULL);
//      }
}

void cg_write_1st IFN1(half_word,value) {
        unsigned short  src,dst;
        src = (unsigned short) value;
        dst = cgglobs.code;
        cgglobs.code = (src << 8) | (dst & 0x00FF);
        cg_font_load(cgglobs.code,(unsigned char *) NULL);
}

void cg_write_count IFN1(half_word,value) {
        cgglobs.counter = value;
        if (half_access && !((cgglobs.code & 0x00FF) == 0))
                cg_font_load(cgglobs.code,(unsigned char *) NULL);
}

void cg_write_pattern IFN1(half_word,value) {
        unsigned short count_pos;
        count_pos = ((cgglobs.counter & 0x0F)<<1);
        if (cgglobs.counter & 0x20) {
                cgglobs.cgwindow_ptr[count_pos+33] = value;
        } else {
                cgglobs.cgwindow_ptr[count_pos+1] = value;
        }
}

void cg_read_pattern IFN1(half_word *,value) {
        unsigned short count_pos;
        count_pos = ((cgglobs.counter & 0x0F)<<1);
        if (half_access) {
                if (cgglobs.counter & 0x20) {
                        *value = cgglobs.cgwindow_ptr[count_pos+33];
                } else {
                        *value = cgglobs.cgwindow_ptr[count_pos+1];
                }
        } else {
                if (cgglobs.counter & 0x20) {
                        *value = cgglobs.cgwindow_ptr[count_pos+32];
                } else {
                        *value = cgglobs.cgwindow_ptr[count_pos+1];
                }
        }
}

GLOBAL void cg_inb IFN2(io_addr, port, half_word *, value) {
        switch(port) {
                case CG_READ_PATTERN:
                        cg_read_pattern(value);
                        break;
                default:
                        assert1(FALSE,"NEC98:Illegal Port %#x",port);
        }
}

GLOBAL void cg_outb IFN2(io_addr, port, half_word *, value) {

        while(cg_lock)
                host_sleep(10);
        cg_lock = TRUE;

        switch(port) {
                case CG_WRITE_SECOND:
                        cg_write_2nd(value);
                        break;
                case CG_WRITE_FIRST:
                        cg_write_1st(value);
                        break;
                case CG_WRITE_COUNTER:
                        cg_write_count(value);
                        break;
                case CG_WRITE_PATTERN:
                        cg_write_pattern(value);
                        break;
                default:
                        assert1(FALSE,"NEC98:Illegal Port %#x",port);
        }
        cg_lock = FALSE;
}

GLOBAL void cg_init IFN0() {
    io_define_inb(CG_ADAPTOR,cg_inb);
    io_define_outb(CG_ADAPTOR,cg_outb);
        io_connect_port(CG_WRITE_SECOND,CG_ADAPTOR,IO_WRITE);
        io_connect_port(CG_WRITE_FIRST,CG_ADAPTOR,IO_WRITE);
    io_connect_port(CG_WRITE_COUNTER,CG_ADAPTOR, IO_WRITE);
        io_connect_port(CG_WRITE_PATTERN,CG_ADAPTOR,IO_READ_WRITE);
        cgglobs.cgwindow_ptr = CG_WINDOW_OFF;
        mapping_init();
}

GLOBAL void cg_post IFN0() {
        cg_outb(CG_WRITE_SECOND,0x00);
        cg_outb(CG_WRITE_FIRST,0xFF);
        cg_outb(CG_WRITE_COUNTER,0x00);
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\timer.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC version 2.0
 *
 * Title        : Time Handler
 *
 * Description  : Emulate the 8253 3-channel timer; invoke 'BIOS
 *                sytem timer interrupt code', cursor flash, repeat
 *                key processing etc.
 *
 * Author       : Jerry Kramskoy
 *
 * Notes        : There is only one real time timer per process, this
 *                module counts clock ticks and distributes calls
 *                to the appropriate functions as required.
 *
 *                This module is host independent - see xxxx_timer.c
 *                where xxxx is a machine type for host dependent stuff.
 *
 * Mods: (r3.2) : (SCR 257). Code has been added to time_tick() to spot
 *                that video has been disabled for a period. If this is
 *                so, clear the screen. Refresh when video is enabled
 *                again.
 *
 *       (r3.4) : Make use of the host time structures host_timeval,
 *                host_timezone, and host_tm, which are equivalent
 *                to the Unix BSD4.2 structures.
 *                Also convert references to gettimeofday() to
 *                host_getIdealTime().
 */

#ifdef SCCSID
static char SccsID[]="@(#)timer.c       1.41 05/31/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */

#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "ica.h"
#include "trace.h"
#include "bios.h"
#include "host.h"
#include "timer.h"
#include "timeval.h"
#include "idetect.h"
#include "debug.h"
#include "quick_ev.h"

#ifndef PROD
#include <stdlib.h>
#endif

#ifdef HUNTER
#include "hunter.h"
#endif

#ifdef NTVDM
#include "fla.h"
#include "nt_eoi.h"
#include "nt_reset.h"
#include "nt_pif.h"
#include "vdm.h"
#undef LOCAL
#define LOCAL
#endif

/* Imports */


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* 'idealtime' gets initialised to be the host system's current
 * time value (timer_init()), and thereafter gets incremented by
 * the value 'idealInterval' every time that time_tick() gets called
 * which gives the illusion of a 100% accurate signal delivery
 */

static struct host_timeval idealtime;
static unsigned long idealInterval;
#ifdef NTVDM
ULONG timer_delay_size= HOST_IDEAL_ALARM >> 1; // usecs
ULONG EoiPending=0;
ULONG EoiIntsPending=0;
ULONG EoiDelayInUse=0;
int ticks_blocked = 0;
#else /* NTVDM */
static unsigned long ticksPerIdealInterval;
static  int     ticks_blocked = 0;
#endif /* NTVDM */

#ifndef PROD
static char buf[80];  /* Used for tracing messages */
#endif

#ifdef HUNTER                   /* Only needed for HUNTER */
word timer_batch_count;         /* Batch update when PC tick occurs */
#endif
int timer_int_enabled;          /* Whether Bios timer ints are required */


/* control word format */

/* Values in D54 of control word - number of bytes to read/load into counter */
#define LATCH                   0
#define RL_LSB                  1
#define RL_MSB                  2
#define RL_LMSB                 3

/* Values in D321 of control word - the counter mode. */
#define INT_ON_TERMINALCOUNT    0
#define PROG_ONESHOT                    1
#define RATE_GEN                                2
#define SQUAREWAVE_GEN                  3
#define SW_TRIG_STROBE                  4
#define HW_TRIG_STROBE                  5
/* NB. 6 = RATE_GEN, 7 = SQUAREWAVE_GEN */

/* Values in D0 of control word - whether prog wants to read/write binary or BCD to counter */
#define BINARY                  0
#define BCD                             1

#define INDEFINITE              (ULONG)-1
#define STARTLO                 0
#define STARTHI                 1
#define NOREPEAT                0
#define REPEAT                  ~NOREPEAT

#define WRITE_SIGNAL     1
#define GATE_SIGNAL      2

#define UNLOCKED 0
#define LOCKED ~UNLOCKED

#define STATE_FUNCTION void
#define UNBLOCK_FUNCTION void
#define GATENABLED_FUNCTION void
#define UPDATECOUNTER_FUNCTION void

/*
 * Timer read state
 */
#define UNREAD                  0       /* Timer is in normal state */
#define READMSB                 1       /* First byte of LMSB mode read, but not second yet */
#define READSTATUS              2       /* Status latched, will read it first */

/*
 * These two figures give a timer frequency of 1.193 MHz (which is
 * how fast the 8235 is clocked. This means that the timer will wrap round
 * every 1/18.2th of a second... the same amount of time as the PC tick
 * rate. This is not surprizing, as the PC tick rate is controlled by
 * timer 0. Every time timer 0 wraps, the PC is interrupted by the timer.
 */

#define TIMER_CLOCK_NUMER       1000
#if defined(NEC_98)
#define TIMER_CLOCK_DENOM_10    2458
#define TIMER_CLOCK_DENOM_8     1997
#else    //NEC_98
#define TIMER_CLOCK_DENOM       1193
#endif   //NEC_98

typedef half_word TSIGNAL;

/* the following structure defines an output waveform from a
 * timer channel. The waveform consists of 'n' clocks at one
 * logic level, and 'm' ticks at the other logic level.
 * Which level starts the waveform is given by 'startLogicLevel'.
 *      e.g; the following waveform ...
 */

typedef struct {
        long clocksAtLoLogicLevel;
        long clocksAtHiLogicLevel;
        long period;
        long startLogicLevel;
        long repeatWaveForm;
} WAVEFORM;

/*      __ __ __ __ __ __        __ __ __ __ __ __        __ __ __ __ __ __
 *                      |        |               |        |                |
 *                      |__ __ __|               |__ __ __|                |
 *
 * would be described by
 *      clocksAtLoLogicLevel = 3
 *      clocksAtHiLogicLevel = 6
 *      startLogicLevel = STARTHI
 *      repeatWaveForm = TRUE;
 *
 *
 * The overall state of a counter is represented by the following
 * structure. Its contents are described below.
 */

typedef enum trigCond_ {LEVEL, EDGE} trigCond;
typedef enum countload_ {AVAILABLE, USED} countload;

typedef struct {
        int                     m;
        int                     bcd;
        int                     rl;

        STATE_FUNCTION  (*state) IPT2(int, signal, half_word, value);
        STATE_FUNCTION  (*statePriorWt) IPT2(int, signal, half_word, value);
        STATE_FUNCTION  (*stateOnGate) IPT2(int, signal, half_word, value);
        UNBLOCK_FUNCTION        (*actionOnWtComplete) IPT0();
        UNBLOCK_FUNCTION        (*actionOnGateEnabled) IPT0();
        void            (*getTime) IPT1(struct host_timeval *, t);

        unsigned char   outblsb;
        unsigned char   outbmsb;
        unsigned        long initialCount;
        int                     readState;
        int                     countlatched;
        unsigned char   latchvaluelsb;
        unsigned char   latchvaluemsb;
        unsigned char   latchstatus;
        word            Count;
        countload       newCount;
        word            tickadjust;
        struct host_timeval activationTime;
        int             tc;
        int             freezeCounter;

#ifndef NTVDM
        unsigned long lastTicks;
        long            microtick;
        long            timeFrig;
        word            saveCount;
        int             guessesPerHostTick;     /* How often per host tick are we forced to guess? */
        int             guessesSoFar;           /* How many times have we guessed so far? */
#endif

        unsigned int    delay;

        trigCond        trigger;
        TSIGNAL         gate;
        TSIGNAL         clk;
        WAVEFORM        out;
} COUNTER_UNIT;

/*
 * When the counter is programmed, the 8253 receives a control word.
 * (see pg 6-266 of manual). The counter being programmed is specified
 * within this word. Provided 'rl' is non-zero, then this counter is
 * being reprogrammed, and we remember the values of m (mode), rl
 * (control of which bytes are involved in a read or load sequence)
 * and bcd (whether the counter is in binary or bcd mode).
 * Based on rl, the counter then must receive one or two bytes via
 * outb's. Two states are used to accept 'outblsb' or
 * 'outbmsb', or both. When the full byte complement has been received,
 * 'initialCount' gets set to the value specified by 'outblsb' and 'outbmsb',
 * taking account of BCD etc., along with 'Count'.
 * 'Count' gets adjusted by the value of 'timeadjust'.
 * 'timeadjust' is initialised to zero every time a new mode
 * word (non-zero) is received. For certain modes of the counter,
 * if they are sent a new count, without receiving a new mode, then
 * this will cause the counter to start counting from this new count
 * at some stage (based on mode and gate values). SInce we are not
 * maintaining the counters continually (rather we prod them as a
 * result of io or gate activity) then there is a good chance we
 * will be late at resetting a counter for counting again. Hence
 * 'timeadjust' is calculated for this lateness, and used as a
 * correction factor.

 * If a 'latch counter' command ('rl'=0 in command word) is issued, then
 * the current counter value is latched into 'latchvaluelsb' and
 * 'latchvaluemsb', and the flag 'countlatched' is set non-zero.
 * If this flag is non-zero during a counter read, then these latched
 * bytes are returned, and upon completion of the read sequence, the
 * flag is cleared. If this flag is zero, then the current counter value
 * is read, and returned. 'donate' is used to point at the appropriate
 * byte to be delivered to the 'inb'.

 * when a counter activates (i.e; count begins or continues after
 * a gate signal change) a time stamp is taken, to enable a time delta
 * to be calculated whenever the counter is read .. this is stored in
 * 'activationTime'.

 * A state function (state), representing the current state
 * of the counter, gets called whenever inb,outb accesses occur, or when
 * the ppi's signal TIM2GATESPK changes. reading/writing of the counters
 * (as opposed to the control word register) always 'blocks' the current
 * state,and puts the counter into a temporary state which handles reading or
 * loading the counter. The blocked state is remembered in 'statePriorWt'.
 * Once the counter has been loaded or read (as specified by its 'rl'
 * parameter) then 'actionOnWtComplete' gets called. Typically this in turn
 * reverts the counter back to the state it was in before it became
 * blocked.

 * If a counter is read, then the function 'updateCounter' gets called to
 * determine what the current counter value is.
 * If the counter's gate signal is disabling counting, and the counter
 * has been fully programmed (and hence able to count), then the counter
 * will be in the state 'awaitingGate'. When the appropriate gate signal
 * appears (via a ppi call), the counter activates by calling the
 * function 'actionOnGateEnabled'. This will take some sort of action, and then
 * place the counter into the state 'stateOnGate'.
 *
 * sending a new count to a counter in modes 2 or 3 will not take
 * effect until the end of the current period ... hence 'delay'
 * is used as an indicator (for sound logic emulation only) of
 * this. If the counter has say 10 clocks left to count down to
 * the end of the period when it receives new waveform parameters,
 * this information is passed onto the sound logic, with a 'delay'
 * of 10. Otherwise 'delay' is not used.
 *
 * On some operating systems, the real time clock may well have to
 * coarse a granularity. If the 8253 is read to quickly, there is a
 * very good chance that the OS clock will still be reading the same.
 * To cater for this, a frig factor 'microsecs' has been introduced.
 * This gets incremented every time the above condition is detected,
 * and used as part of the counter update calculations. Whenever
 * the OS actually says something sensible, it gets cleared again.
 */

static COUNTER_UNIT timers[3], *pcu;

LOCAL STATE_FUNCTION uninit IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION awaitingGate IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION waitingFor1stWrite IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION waitingFor2ndWrite IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting0 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting_4_5 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting1 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting_2_3 IPT2(int, signal, half_word, value);
LOCAL UNBLOCK_FUNCTION resumeCounting_1_5 IPT0();
LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4 IPT0();
LOCAL void resumeAwaitGate IPT0();
LOCAL UNBLOCK_FUNCTION CounterBufferLoaded IPT0();
LOCAL UNBLOCK_FUNCTION timererror IPT0();
LOCAL GATENABLED_FUNCTION runCount IPT0();
LOCAL void controlWordReg IPT1(half_word, cwd);
LOCAL void latchStatusValue IPT0();
LOCAL void readCounter IPT0();
LOCAL void timestamp IPT0();
LOCAL void outputWaveForm IPT5(unsigned int, delay, unsigned long, lowclocks,
        unsigned long, hiclocks, int, lohi, int, repeat);
LOCAL void outputHigh IPT0();
LOCAL void outputLow IPT0();
LOCAL void setOutputAfterMode IPT0();
LOCAL void loadCounter IPT0();
LOCAL void updateCounter IPT0();
LOCAL void startCounting IPT0();

#ifdef NTVDM
unsigned long updateCount(void);
#else
LOCAL void updateCount IPT3(unsigned long, ticks, unsigned long *, wrap,
        struct host_timeval *, now);
#endif
LOCAL unsigned  short bin_to_bcd IPT1(unsigned long, val);
LOCAL word bcd_to_bin IPT1(word, val);
LOCAL void emu_8253 IPT3(io_addr, port, int, signal, half_word, value);
LOCAL void Timer_init IPT0();
LOCAL unsigned long timer_conv IPT1(word, count);
LOCAL void issueIREQ0 IPT1(unsigned int, n);
#ifndef NTVDM
LOCAL unsigned long guess IPT0();
LOCAL void throwaway IPT0();
#endif
#ifdef SYNCH_TIMERS
GLOBAL void IdealTimeInit IPT0();
#else
LOCAL void IdealTimeInit IPT0();
#endif
LOCAL void updateIdealTime IPT0();
LOCAL void getIdealTime IPT1(struct host_timeval *, t);
#ifndef NTVDM
LOCAL void getHostSysTime IPT1(struct host_timeval *, t);
LOCAL void checktimelock IPT0();
#endif
LOCAL void setTriggerCond IPT0();
LOCAL void WtComplete IPT0();
LOCAL void counter_init IPT1(COUNTER_UNIT *, p);
#ifndef NTVDM
LOCAL void setLastWrap IPT2(unsigned int, nclocks, struct host_timeval *, now);
LOCAL void timer_generate_int IPT1(long, n);
LOCAL void timer_multiple_ints IPT1(long, n);

#define MAX_BACK_SECS 15
LOCAL IU32 max_backlog = 0;     /* max # of ints allowed to queue up */
IBOOL active_int_event = FALSE; /* current quick_event for timer queue */
IU32 more_timer_mult = 0;       /* additions to timer int queue */
IU32 timer_multiple_delay = 0;  /* us delay to next timer queue elem */
#endif

#if defined(NTVDM)

void timer_generate_int(void);
unsigned long clocksSinceCounterUpdate(struct host_timeval *pCuurTime,
                                       struct host_timeval *pLastTime,
                                       word                *pCounter);
void ReinitIdealTime IPT1(struct host_timeval *, t);
void host_GetSysTime(struct host_timeval *time);
void InitPerfCounter(void);

/* holds real time values for counter zero */
struct host_timeval LastTimeCounterZero;
word                RealTimeCountCounterZero;


#ifndef PROD
ULONG NtTicTesting = 0;   /* tracing specific to NT port */
ULONG TicsGenerated;
ULONG TicsReceived;
#endif

    /* for optimizing timer hardware interrupt generation */
word TimerInt08Seg = TIMER_INT_SEGMENT;
word TimerInt08Off = TIMER_INT_OFFSET;
word TimerInt1CSeg;
word TimerInt1COff;



#else

static int timelock;            /* locks out time_tick if set */
static int needtick;            /* causes time_tick() to be called if set */

/*
 * Data for the hack to make sure that windows in standard mode doesn't get two timer
 * ticks too close together.
 */

LOCAL BOOL      hack_active=FALSE;                      /* This boolean indicates that we are spacing
                                                           timer interrupts out by discarding timer ticks.
                                                           It is set when we see a protected mode tick */
LOCAL BOOL      too_soon_after_previous=FALSE;          /* This boolean is set on when an interrupt is
                                                           generated... a quick event is requested to
                                                           clear it again after a "fixed" number of
                                                           instructions */
LOCAL BOOL      ticks_lost_this_time=FALSE;             /* This boolean is set if any interrupts were
                                                           required to be generated while too_soon_after_previous
                                                           was TRUE - if it's TRUE when too_soon_after_previous
                                                           is being set to FALSE, we generate an immediate
                                                           interrupt to get the best responsiveness */
LOCAL ULONG     real_mode_ticks_in_a_row = 0;           /* A count of the number of real mode ticks in a row...
                                                           this is used to disable the hack again when we have
                                                           left protected mode for a good while */
LOCAL ULONG     instrs_per_tick = 37000;                /* Nominal (as timed on the reference machine - a SPARC 1+) */
LOCAL ULONG     adj_instrs_per_tick = 0;                /* The estimated number of Intel instructions being emulated
                                                           each 20th of a second */
LOCAL ULONG     n_rm_instrs_before_full_speed = 3000000;/* Nominal number of instructions to be emulated in real mode
                                                           before we're convinced that we're staying back in real mode */
LOCAL ULONG     adj_n_real_mode_ticks_before_full_speed = 0;/* The value which real_mode_ticks_in_a_row must reach
                                                           before the hack is disabled */
#ifndef PROD
LOCAL ULONG     ticks_ignored = 0;                      /* For information purposes only. */
#endif

#endif /* NTVDM */

#ifndef PROD    /* Specific Timer change tracing that isn't timer_verbose */


GLOBAL int DoTimerChangeTracing = 0;
#endif

#if !defined(NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
extern IBOOL HostDelayTimerInt IPT1(int, numberInts);
extern IBOOL HostPendingTimerInt IPT0();
extern void HostResetTimerInts IPT0();

#endif /* IRET_HOOKS && GISP_CPU */
#endif

#if defined(NTVDM)
#ifndef MONITOR
#define pNtVDMState ((PULONG)(Start_of_M_area + FIXED_NTVDMSTATE_LINEAR))
#endif
#endif

/*
 * ============================================================================
 * External variables
 * ============================================================================
 */

boolean timer_video_enabled;

/*
 *  Table of function pointers to access TIMER routines
 */
void (*timer_inb_func) IPT2(io_addr, port, half_word *, value);
void (*timer_outb_func) IPT2(io_addr, port, half_word, value);
void (*timer_gate_func) IPT2(io_addr, port, half_word, value);
void (*timer_tick_func) IPT0();

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */
#if defined(NEC_98)
extern void SetRSBaud();
extern void SetBeepFrequency();
unsigned short RSBaud = 0;
#endif   //NEC_98

void
SWTMR_init_funcptrs IFN0()
{
        /*
         *  initialize access functions for SW [emulated] TIMER
         */
        timer_inb_func                  = SWTMR_inb;
        timer_outb_func                 = SWTMR_outb;
        timer_gate_func                 = SWTMR_gate;
        timer_tick_func                 = SWTMR_time_tick;

#ifndef NTVDM
        /*
         * initialise stuff for PM timer hack
         */
        too_soon_after_previous         = FALSE;
        if (adj_n_real_mode_ticks_before_full_speed == 0){
                HOST_TIMER_DELAY_SIZE=25000;
                adj_instrs_per_tick = host_speed (instrs_per_tick);
                adj_n_real_mode_ticks_before_full_speed = n_rm_instrs_before_full_speed / adj_instrs_per_tick;
        }
#endif
}

void
SWTMR_time_tick IFN0()
{

    /*
     * Give the idle detector a chance to see if we are really idle.
     */
#ifndef NTVDM
    /* this is done in Nt's host heartbeat */
    IDLE_tick();
#endif

    /*
     * Interrupt routine - called from time_strobe event/signal handler.
     * That is called from host_timer_event
     */

#ifndef NTVDM
    /* protect ourselves from shafting a timer-channel in midst-program
     * ... the lock is controlled by timer_inb(),_outb() and _gate()
     */

    if (timelock == LOCKED)
    {
        needtick = ~0;
        return;
    }
#endif

    /* ideal time goes up by the number of timer clocks
     * equivalent to the interval between calls to 'time_tick'
     * (we assume these calls appear at perfectly spaced intervals ...
     * thus ignoring fluctuations on the host system)
     * The idea is to give an illusion of constant ticks here
     */

    updateIdealTime();

    pcu = &timers[0];
    updateCounter();

    /*
     * Counter 2 is only used for sound, or for timing very short
     * times. For timing short times (~100ms) we need accurate time
     * all the time.
     */

#if defined(NEC_98)
    pcu = &timers[1];
#else    //NEC_98
    pcu = &timers[2];
#endif   //NEC_98
    updateCounter();
}


/*
 * The timer low I/O functions that support the Intel 8253 Counter chip.
 *
 * The Counters are used by the PC in the following ways:
 *
 *      Counter 0  -  Bios time of day function
 *      Counter 1  -  Handler memory refresh
 *      Counter 2  -  Drive Speaker Interface (plus input on PPI)
 *
 */

/*
 * These control the timer chip. they are the interface between the
 * CPU and the timer chip.
 */

void SWTMR_gate IFN2(io_addr, port, half_word, value)
{
#ifdef  NTVDM
    host_ica_lock();
#else
    timelock = LOCKED;
#endif

    emu_8253 (port, GATE_SIGNAL, value);
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_gate() - sending %d to port 0x%x", value, port);
        trace(buf, DUMP_REG);
    }
#endif

#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif
}


void SWTMR_inb IFN2(io_addr, port, half_word *, value)
{
#ifdef NTVDM
    host_ica_lock();
#else
    timelock = LOCKED;
#endif


#if defined(NEC_98)
    pcu = &timers[(port & 7) >> 1];
#else    //NEC_98
    pcu = &timers[port & 3];
#endif   //NEC_98
        if (!pcu->countlatched)
                readCounter();
        switch (pcu->readState)
        {
                case UNREAD:
                        switch (pcu->rl)
                        {
                        case RL_LSB:
                                *value = pcu->latchvaluelsb;
                                pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                                break;
                        case RL_LMSB:
                                *value = pcu->latchvaluelsb;
                                pcu->readState = READMSB;       /* Read LSB, next in read MSB. */
                                break;
                        case RL_MSB:
                                *value = pcu->latchvaluemsb;
                                pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                                break;
                        }
                        break;
                case READMSB:
                        *value = pcu->latchvaluemsb;
                        pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                        pcu->readState = UNREAD;        /* Read MSB, back to unread state. */
                        break;
                case READSTATUS:
                        *value = pcu->latchstatus;
                        pcu->readState = UNREAD;
                        break;
        }
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_inb() - Returning %d(0x%x) for port 0x%x", *value, *value, port);
        trace(buf, DUMP_REG);
    }
#endif
#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif

}


void SWTMR_outb IFN2(io_addr, port, half_word, value)
{
#if defined(NTVDM) || defined(GISP_SVGA)
#ifndef NEC_98
    if (port == 0x4f)   /* dead port used by PS/2 XGA bios for DAC delays */
        return;
#endif   //NEC_98
#ifdef NTVDM
    host_ica_lock();
#endif
#else
    timelock = LOCKED;
#endif

#if defined(NEC_98)
        if(port == 0x77 || port == 0x3fdf)
#else    //NEC_98
    port = port & TIMER_BIT_MASK;
        if(port == 0x43)
#endif   //NEC_98
                controlWordReg(value);
        else
            emu_8253 (port, WRITE_SIGNAL, value);
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_outb() - Value %d to port 0x%x", value, port);
        trace(buf, DUMP_REG);
    }
#endif

#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif

#if defined(NEC_98)
    if( RSBaud ) {
        SetRSBaud( RSBaud );
        RSBaud = 0;
    }
#endif   //NEC_98
}


/* --------------------------------------------------------------------------- */
/*                                                                             */
/*              Return the current DOS tick value based on Timer 0             */
/*                                                                             */
/* --------------------------------------------------------------------------- */

#ifndef NTVDM
GLOBAL ULONG get_DOS_ticks IFN0()
{
        return( timers[0].Count );
}
#endif /* NTVDM */

#ifdef NTVDM
/*
 *  called by host to update the current ideal time
 *  after a block and resume.
 */
void ReinitIdealTime IFN1(struct host_timeval *, t)
{

    /*
     *  Currently these are all time stamped by the same thing!
     */
   LastTimeCounterZero      =
   timers[2].activationTime =
   timers[1].activationTime =
   timers[0].activationTime =
                  idealtime = *t;
   /*
    * Clear out extra pending interrupts
    */
   if (EoiPending) {
       EoiPending = 1;
       }

   EoiIntsPending = 0;

}
#endif




/* **************************************************************************** */
/* **************************************************************************** */
/* **************************************************************************** */

#ifndef NTVDM
/* check whether a time lock (set while application io is being serviced)
 * has blocked out an alarm signal ... call time_tick() to catch up if so
 * ... (time_tick() sets timelock = ~0, and just returns, if it sees the time
 * lock set
 */

LOCAL void checktimelock IFN0()
{
        timelock = UNLOCKED;
        if (needtick)
        {
                needtick = 0;
                time_tick();
        }
}
#endif

/*
 *      emulate the 8253 chip.
 *
 *      emu_8253(port,signal,value)
 *
 *      port    -       port address being accessed
 *                      (port & 3) gives A0,A1 lines
 *
 *      signal  -       WRITE_SIGNAL (outb) or
 *                      GATE_SIGNAL (ppi TIM2GATESPK change)
 *
 *      value   -
 *                      for WRITE_SIGNAL, value = byte being written to chip
 *                      for GATE_SIGNAL,  value = GATE_SIGNAL_LOW or
 *                                                GATE_SIGNAL_RISE
 */


LOCAL void emu_8253 IFN3(io_addr, port, int, signal, half_word, value)
{

        int A0A1;

        /* get address lines A0 and A1 */
#if defined(NEC_98)
        A0A1 = (port & 7) >> 1;
#else    //NEC_98
        A0A1 = port & 3;
#endif   //NEC_98

        /* handle the access */
                pcu = &timers[A0A1];
                (pcu->state)(signal,value);
}


/* if a timer channel is unitialised, this is its associated
 * state function ... simply ignore all accesses in this state
 * A state transition from this state is only possible via
 * the procedure controlReg()
 */



/* handle write access to the control word register.
 * The documentation does not specify what happens if a mode
 * setting control word is issued while a counter is active.
 * In this model, we assume it resets the operation back to
 * the start of a new counter programming sequence
 */

/*ADE*/
#define SELECT_0 0x00
#define SELECT_1 0x01
#define SELECT_2 0x02
#define READ_BACK 0x03

LOCAL void controlWordReg IFN1(half_word, cwd)
{
        int rl,m,channel;
        half_word select_bits;

        /* decode control word */
        channel = (cwd & 0xc0) >> 6;
        if(channel == READ_BACK)
        {
                /* decode read back command */
                select_bits = (cwd & 0xe) >> 1;
                /* first look for counters to latch */
                if (!(cwd & 0x20))
                {
                        /* count bit low so latch selected counters */
                        if (select_bits & 0x01)
                        {
                                /* counter 0 */
                                pcu = &timers[0];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                        if (select_bits & 0x02)
                        {
                                /* counter 1 */
                                pcu = &timers[1];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                        if (select_bits & 0x04)
                        {
                                /* counter 2 */
                                pcu = &timers[2];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                }

                /* now look for the status latch */
                if (!(cwd & 0x10))
                {
                        /* status bit low - status to be latched */
                        if (select_bits & 0x01)
                        {
                                /* counter 0 */
                                pcu = &timers[0];
                                latchStatusValue();
                        }
                        if (select_bits & 0x02)
                        {
                                /* counter 1 */
                                pcu = &timers[1];
                                latchStatusValue();
                        }
                        if (select_bits & 0x04)
                        {
                                /* counter 2 */
                                pcu = &timers[2];
                                latchStatusValue();
                        }
                }
        }
        else
        {
                pcu = &timers[channel];
                rl = (cwd & 0x30) >> 4;


                /* are we simply latching the present count value, or are
                 * programming up a new mode ??
                 */
                if (rl == LATCH)
                {       /* latching present count value */
                        readCounter();
                        pcu->countlatched = 1;
                        return;
                }
                else
                {       /* new mode */
                        if (pcu == &timers[0])
                                timer_int_enabled = FALSE;
                        pcu->countlatched = 0;
                        pcu->tc = 0;
                        pcu->tickadjust = 0;
#ifndef NTVDM
                        pcu->microtick = 0;
                        pcu->saveCount = 0;
#endif

                        m  = (cwd & 0xe)  >> 1;
                        if(m > 5)m -= 4; /* Modes 6 and 7 don't exist - they are intepreted as modes 2 and 3 */
                        pcu->m = m;
                        setTriggerCond();
                        setOutputAfterMode();
                        pcu->bcd = cwd & 1;
                        pcu->rl = rl;
                        pcu->actionOnWtComplete = CounterBufferLoaded;
                        pcu->actionOnGateEnabled = CounterBufferLoaded;
                        pcu->statePriorWt = pcu->state;
                        pcu->state = waitingFor1stWrite;
                }
        }
}

/* latch status ready for reading */
LOCAL void latchStatusValue IFN0()
{
        /*
        *       Status byte is of format :
        *
        *       |OUT|Null Count|RW1|RW0|M2|M1|M0|BCD|
        *
        */

        /* NULL COUNT still only approximated. Who cares? */
        pcu->latchstatus = (unsigned char)(
                  (pcu->out.startLogicLevel<<7)
                | (pcu->newCount == AVAILABLE ? (1<<6) : 0)
                | (pcu->rl<<4)
                | (pcu->m<<1) | (pcu->bcd));
        pcu->readState = READSTATUS;
}

/* set up flag establishing type of trigger condition for
 * counter bassed on its mode
 */

LOCAL void setTriggerCond IFN0()
{
        switch (pcu->m)
        {
        case RATE_GEN:
        case SQUAREWAVE_GEN:
        case SW_TRIG_STROBE:
        case INT_ON_TERMINALCOUNT:
                pcu->trigger = LEVEL;
                return;
        case PROG_ONESHOT:
        case HW_TRIG_STROBE:
                pcu->trigger = EDGE;
                return;
        }
}


/* transfer count buffer into counter */

LOCAL void loadCounter IFN0()
{
        unsigned long modulo;
#ifndef NTVDM
        IU32 maxback;
#endif

        /* set counter */
        /* get correct modulo to use for counter calculations */
        modulo = (pcu->outbmsb << 8) | pcu->outblsb;
        if (pcu->bcd == BCD)
        {
                if(modulo)
                        modulo = bcd_to_bin((word)modulo);
                else
                        modulo = 10000L;
        }
        else
                if(!modulo)modulo = 0x10000L;

        /* Beware - Count and initialCount are different sizes, so don't merge the next two lines!! */
        pcu->initialCount = modulo;
        pcu->Count = (word)modulo;

        /*
         * not at terminal count anymore, so reflect this fact by resetting
         * tc (which I think means "reached terminal count"
         */
        pcu->tc = 0;
        pcu->newCount = USED;
        if(pcu == &timers[0])
        {
            /* Get rid of pending interrupts - these may no longer me appropriate - eg. in Sailing */
            ica_hw_interrupt_cancel(ICA_MASTER,CPU_TIMER_INT);
#ifdef NTVDM
            RealTimeCountCounterZero = pcu->Count;
#endif

#ifndef NTVDM
                /* how many interrupts in MAX_BACK_SECS seconds? */
                maxback = (1193180 * MAX_BACK_SECS) / modulo;

                if (maxback > max_backlog)
                {
#ifndef PROD
                        fprintf(trace_file, "setting max backlog to %d\n", maxback);
#endif
                        max_backlog = maxback;
                }
#endif

        }

#if defined(NTVDM) && !defined(PROD)
        if (NtTicTesting)  {
            printf("Timer %d modulo=%lu %dHz\n",
                    pcu-timers, modulo, 1193180/modulo);
            }
#endif /*NTVDM & !PROD*/
}

/* read counter into latch, ready for next read */

LOCAL void readCounter IFN0()
{
        int countread;

        updateCounter();

#ifdef NTVDM
           /*
            *  Timer Zero is a special case, as it is maintaned
            *  by IdealInterval, and not RealTime. We must give
            *  real time granularity
            */
        countread = pcu == &timers[0] ? RealTimeCountCounterZero
                                      : pcu->Count;

        if (pcu->bcd == BCD)
            countread = bin_to_bcd(countread);

#else
        if(pcu->bcd == BCD)
                countread = bin_to_bcd(pcu->Count);
        else
                countread = pcu->Count;
#endif

        pcu->latchvaluemsb = countread >> 8;
        pcu->latchvaluelsb = countread & 0xff;
        sure_note_trace1(TIMER_VERBOSE,"reading count %d",pcu->Count);
}

/* active counter (mode 0) lost its gate ... gate has now
 * reappeared. Either continue 'active' counting (pre terminal count)
 * or continue decrementing, but with OUT signal at high indefinitely.
 */
LOCAL GATENABLED_FUNCTION resumeCounting0onGate IFN0()
{
        if (pcu->freezeCounter)
        {
                pcu->freezeCounter = 0;
                timestamp();
        }
        if (pcu->newCount == AVAILABLE)
                loadCounter();
        if (!pcu->tc)
        {
                timestamp();
                pcu->stateOnGate = Counting0;
                runCount();
        }
        else
                pcu->state = Counting0;
}

LOCAL GATENABLED_FUNCTION resumeCounting0 IFN0()
{
        int doadjust = 0;
        if (pcu->freezeCounter)
        {
                pcu->freezeCounter = 0;
                timestamp();
        }
        if (pcu->newCount == AVAILABLE)
        {
                doadjust = 1;
                loadCounter();
        }
        if (!pcu->tc)
        {
                pcu->stateOnGate = Counting0;
                runCount();
        }
        else
        {
                pcu->state = Counting0;
                if (doadjust)
                        pcu->Count -= pcu->tickadjust;
        }
}

LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4_onGate IFN0()
{
        /* for modes 2 and 3, ought to wait until counter
         * completes its current period, but we cant be as accurate
         * as that
         */
        if (pcu->newCount == AVAILABLE)
                loadCounter();
        if (pcu->m == RATE_GEN || pcu->m == SQUAREWAVE_GEN)
                pcu->stateOnGate = Counting_2_3;
        else
                pcu->stateOnGate = Counting_4_5;
        timestamp();
        runCount();
}

LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4 IFN0()
{
        /* for modes 2 and 3, ought to wait until counter
         * completes its current period, but we cant be as accurate
         * as that
         */
        if (pcu->newCount == AVAILABLE)
        {
                pcu->delay = pcu->Count;
                loadCounter();
        }
        if (pcu->m == RATE_GEN || pcu->m == SQUAREWAVE_GEN)
                pcu->stateOnGate = Counting_2_3;
        else
                pcu->stateOnGate = Counting_4_5;
        runCount();
}


LOCAL GATENABLED_FUNCTION runCount IFN0()
{
        unsigned long lowticks, hiticks;
        unsigned long adjustedCount;    /* For count = 0 and BCD */

        adjustedCount = timer_conv(pcu->Count);
        pcu->state = pcu->stateOnGate;
        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
                outputWaveForm(pcu->delay,adjustedCount,
                        INDEFINITE,STARTLO,NOREPEAT);
                return;
        case PROG_ONESHOT:
                loadCounter();
                outputWaveForm(pcu->delay,adjustedCount,
                        INDEFINITE,STARTLO,NOREPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case RATE_GEN:
                loadCounter();
                outputWaveForm(pcu->delay,1,
                        adjustedCount-1,STARTHI,REPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case SQUAREWAVE_GEN:
                loadCounter();
                if (!(pcu->Count & 1))
                        lowticks = hiticks = adjustedCount >> 1;
                else
                {
                        lowticks = (adjustedCount - 1) >> 1;
                        hiticks = (adjustedCount + 1) >> 1;
                }
                outputWaveForm(pcu->delay,lowticks, hiticks,STARTHI,REPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case SW_TRIG_STROBE:
                outputWaveForm(pcu->delay,1, adjustedCount,STARTHI,NOREPEAT);
                return;
        case HW_TRIG_STROBE:
                loadCounter();
                outputWaveForm(pcu->delay,1, adjustedCount,STARTHI,NOREPEAT);
                return;
        }
}


/* return to state waiting for gate signal */

LOCAL void resumeAwaitGate IFN0()
{
        pcu->actionOnWtComplete = timererror;
        pcu->state = awaitingGate;
        awaitingGate(GATE_SIGNAL,pcu->gate);
}



/* ========================= OUTPUT SIGNAL UTILITIES ====================== */
/* ========================= OUTPUT SIGNAL UTILITIES ====================== */
/* ========================= OUTPUT SIGNAL UTILITIES ====================== */

/* set state of output signal after a mode command has
 * been programmed (see pages 6-266 - 6-268 of Intel manual 231306-001)
 */

LOCAL void setOutputAfterMode IFN0()
{
        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
                outputLow( /*INDEFINITE*/ );
                return;
        case PROG_ONESHOT:
        case RATE_GEN:
        case SQUAREWAVE_GEN:
        case SW_TRIG_STROBE:
        case HW_TRIG_STROBE:
                outputHigh( /*INDEFINITE*/ );
                return;
        }
}


/* set output state low ... inform sound chip emulation if
 * channel 2
 */

LOCAL void outputLow IFN0()
{
        outputWaveForm(0,INDEFINITE,0,STARTLO,NOREPEAT);
}


/* set output state high ... inform sound chip emulation if
 * channel 2
 */

LOCAL void outputHigh IFN0()
{
        outputWaveForm(0,0,INDEFINITE,STARTHI,NOREPEAT);
}


/* when the wave form is deterministic, tell the sound emulation about it.
 *      delay           -       if <>0, don't start this waveform for
 *                              this number of counter clocks.
 *      lowclocks       -       the #.counter clocks to stay low for
 *      hiclocks        -       the #.counter clocks to stay high for
 *      (either parameter may be INDEFINITE duration)
 *      lohi            -       0 ==> start at low logic level
 *                      -     <>0 ==> start at high logic level
 *      repeat          -       0 ==> don't
 *                            <>0 ==> repeat.
 *
 *      (n.b; 1 counter clock period = 1.19318 usecs)
 */

LOCAL void outputWaveForm IFN5(unsigned int, delay, unsigned long, lowclocks,
        unsigned long, hiclocks, int, lohi, int, repeat)
{
#ifdef DOCUMENTATION
        int ch;
#endif /* DOCUMENTATION */
        pcu->out.startLogicLevel = lohi;
        pcu->out.repeatWaveForm = repeat;
        pcu->out.clocksAtLoLogicLevel = lowclocks;
        pcu->out.clocksAtHiLogicLevel = hiclocks;
        if (repeat == REPEAT)
                pcu->out.period = lowclocks + hiclocks;
#if defined(NEC_98)
        if (pcu == &timers[1])
#else    //NEC_98
        if (pcu == &timers[2])
#endif   //NEC_98
        {
                host_timer2_waveform(delay,lowclocks,hiclocks,lohi,repeat);
        }
        pcu->delay = 0;

#ifdef DOCUMENTATION
        if (pcu==&timers[0])
                ch = 0;
        if (pcu==&timers[1])
                ch = 1;
        if (pcu==&timers[2])
                ch = 2;
        sprintf(buf,"ch.%d waveform:delay %d lo %d hi %d lohi %d repeat %d\n",
                ch,delay,lowclocks,hiclocks,lohi,repeat);
        trace(buf,0);
#endif /* DOCUMENTATION */
}

/* time stamp the counter unit ... it is counting from this time
 */

LOCAL void timestamp IFN0()
{
#ifdef NTVDM
       /* update counter zero time stamp */
       if (pcu == &timers[0]) {
           host_GetSysTime(&LastTimeCounterZero);
           }
#else
        /* Initialise lastTicks before referencing it in updateCount() */
        /* Makes Norton SYSINFO version 5.0 work on fast (HP) machines */
        pcu->lastTicks = 0 ;
#endif
        /* Go and get the time since it was activated */
        (*pcu->getTime)(&pcu->activationTime);
}

LOCAL UNBLOCK_FUNCTION timererror IFN0()
{
        always_trace0("time error!!!!");
}

/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/
/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/
/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/


/* ************************ STATE FUNCTIONS ********************************* */
/* ************************ STATE FUNCTIONS ********************************* */
/* ************************ STATE FUNCTIONS ********************************* */

/*
 * STATE_FUNCTION uninit();
 * STATE_FUNCTION awaitingGate();
 * STATE_FUNCTION waitingFor1stWrite();
 * STATE_FUNCTION waitingFor2ndWrite();
 * STATE_FUNCTION Counting0();
 * STATE_FUNCTION Counting_4_5();
 * STATE_FUNCTION Counting1();
 * STATE_FUNCTION Counting_2_3();
 */

LOCAL STATE_FUNCTION uninit IFN2(int, signal, half_word, value)
{
        if (signal == GATE_SIGNAL)
                pcu->gate = value;
}

LOCAL STATE_FUNCTION awaitingGate IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                pcu->gate = value;
                if (value == GATE_SIGNAL_LOW)
                        return;

                /* this is pathological ... should never have to
                 * wait for gate for channel 0
                 */
                if (pcu == &timers[0])
                        timer_int_enabled = TRUE;

                (pcu->actionOnGateEnabled)();
                return;
        case WRITE_SIGNAL:
                pcu->actionOnWtComplete = resumeAwaitGate;
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/*
 * Perform first of (probably) 2 writes.
 * This is either called directly when some other state is
 * written to, or set up as the current state when the timer mode is changed.
 * If the timer is in 'read/write 2 bytes' mode, set the timer state
 * to 'waiting for second byte'.
 */

LOCAL STATE_FUNCTION waitingFor1stWrite IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                /* remember gate signal state */
                pcu->gate = value;
                return;
        case WRITE_SIGNAL:
                switch (pcu->rl)
                {
                case RL_LSB:
                        pcu->outblsb = value;
                        /* Zero the most signifcant byte. */
                        pcu->outbmsb = 0;
                        pcu->newCount = AVAILABLE;
                        WtComplete();
                        return;
                case RL_LMSB:
                        pcu->outblsb = value;
                        pcu->state = waitingFor2ndWrite;
                        return;
                case RL_MSB:
                        pcu->outbmsb = value;
                        /* Zero the least signifcant byte. */
                        pcu->outblsb = 0;
                        pcu->newCount = AVAILABLE;
                        WtComplete();
                        return;
                }
        }
}

/*
 * Write second byte to timer and unblock it.
 */

LOCAL STATE_FUNCTION waitingFor2ndWrite IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                /* remember gate signal state */
                pcu->gate = value;
                return;
        case WRITE_SIGNAL:
                pcu->newCount = AVAILABLE;
                pcu->outbmsb = value;
                WtComplete();
                return;
        }
}


/*
 * the full complement of bytes has been read/loaded. During this
 * phase, the gate signal might have been removed ... if so,
 * change state to wait for an enabling gate signal. Otherwise
 * take appropriate action to get back to previous state
 */

LOCAL void WtComplete IFN0()
{
        if (pcu->gate == GATE_SIGNAL_LOW && pcu->trigger == LEVEL)
        {
                pcu->state = awaitingGate;
                awaitingGate(GATE_SIGNAL, pcu->gate);
        }
        else
                (pcu->actionOnWtComplete)();
}

/* active counter (Interrupt on Terminal Count)
 * if the gate is lost, then
 *      set the output indefinitely high if at terminal count, or
 *      indefinitely low if still counting (i.e; extend current low
 *      level signal duration).
 *      if count reprogrammed during this time, this new count will be
 *      used on next trigger (gate).
 * else
 *      if new count programmed, stop counter on receiving 1st byte.
 *      start new count on second byte. (done by resumeCounting0())
 */

LOCAL STATE_FUNCTION Counting0 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting0onGate;
        pcu->actionOnWtComplete = resumeCounting0;

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                if (pcu->tc)
                        outputHigh();
                else
                        outputLow();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->freezeCounter = 1;
                updateCounter();
                if (pcu->tc)
                        outputHigh();
                else
                        outputLow();
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/* active counter (programmable One-Shot)
 * if cvounter loses its gate, then simply wait for retrigger
 * to start off count again.
 */

LOCAL STATE_FUNCTION Counting1 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = startCounting;
        pcu->actionOnWtComplete = resumeCounting_1_5;

        switch (signal)
        {
        case GATE_SIGNAL:
                /* ignore transition to low on trigger.
                 * any rising edge retriggers the counter.
                 */
                if (value == GATE_SIGNAL_LOW)
                        return;
                pcu->gate = GATE_SIGNAL_HIGH;
                pcu->stateOnGate = Counting1;
                timestamp();
                runCount();
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

LOCAL UNBLOCK_FUNCTION resumeCounting_1_5 IFN0()
{
        /* if terminal count has been reached, wait for the next
         * trigger ... any new count value programmed will be used
         * then.
         * Otherwise, even if new count is available, it still won't
         * be used until next trigger
         */
        if (pcu->gate == GATE_SIGNAL_RISE)
        {
                pcu->state = Counting1;
                if (pcu->m == HW_TRIG_STROBE)
                        pcu->state = Counting_4_5;
                return;
        }

        if (pcu->tc)
                pcu->state = awaitingGate;
        else
        {
                pcu->state = Counting1;
                if (pcu->m == HW_TRIG_STROBE)
                        pcu->state = Counting_4_5;
        }
}

LOCAL STATE_FUNCTION Counting_2_3 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting_2_3_4_onGate;
        pcu->actionOnWtComplete = resumeCounting_2_3_4;

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                outputHigh();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

LOCAL STATE_FUNCTION Counting_4_5 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting_2_3_4_onGate;
        pcu->actionOnWtComplete = resumeCounting_2_3_4;
        if (pcu->m == HW_TRIG_STROBE)
        {
                pcu->actionOnGateEnabled = resumeCounting_1_5;
                pcu->actionOnWtComplete = resumeCounting_1_5;
        }

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                outputHigh();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/* ****************** UNBLOCK FUNCTIONS ************************************* */
/* ****************** UNBLOCK FUNCTIONS ************************************* */
/* ****************** UNBLOCK FUNCTIONS ************************************* */

/* upon reaching this state, the timer's count register can be
 * loaded (as per 'rl') ... and it can potentially start counting
 * depending upon the state of its gate signal.
 * If it can begin counting, then setup the output waveform that will
 * appear at the timer channel's OUT signal.
 * (If this channel is for sound, the waveform is exactly known)
 */

LOCAL UNBLOCK_FUNCTION CounterBufferLoaded IFN0()
{
        unsigned long lowticks, hiticks, adjustedCount;
        pcu->actionOnWtComplete = timererror;
        loadCounter();

#ifdef DOCUMENTATION
        /*
         * Output state of timer if tracing.
         * Currently dumpCounter has no effect, so just leave this in
         * case anyone wants to implement it properly.
         */

        if (io_verbose & TIMER_VERBOSE)
        {
                dumpCounter();
        }
#endif /* DOCUMENTATION */

        if (pcu->gate != GATE_SIGNAL_LOW)
        {
#if defined(NEC_98)
                if (pcu == &timers[2])
//                  SetRSBaud( pcu->outblsb + (pcu->outbmsb) * 0x100 );
                    RSBaud = pcu->outblsb + (pcu->outbmsb) * 0x100;
                if (pcu == &timers[1])
                    SetBeepFrequency( (DWORD)pcu->outblsb + (pcu->outbmsb) * 0x100) ;
#endif   //NEC_98
                if (pcu == &timers[0])
                        timer_int_enabled = TRUE;
                timestamp();
                adjustedCount = timer_conv(pcu->Count);
                switch (pcu->m)
                {
                case INT_ON_TERMINALCOUNT:
                        outputWaveForm(pcu->delay,adjustedCount,
                                INDEFINITE,STARTLO,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting0;
                        return;
                case PROG_ONESHOT:
                        outputWaveForm(pcu->delay,adjustedCount,
                                INDEFINITE,STARTLO,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting1;
                        return;
                case RATE_GEN:
                        outputWaveForm(pcu->delay,1,
                                adjustedCount-1,STARTHI,REPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_2_3;
                        return;
                case SQUAREWAVE_GEN:
                        if (!(pcu->Count & 1))
                                lowticks = hiticks = adjustedCount >> 1;
                        else
                        {
                                lowticks = (adjustedCount - 1) >> 1;
                                hiticks = (adjustedCount + 1) >> 1;
                        }
                        outputWaveForm(pcu->delay,lowticks,
                                hiticks,STARTHI,REPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_2_3;
                        return;
                case SW_TRIG_STROBE:
                case HW_TRIG_STROBE:
                        outputWaveForm(pcu->delay,1,
                                adjustedCount,STARTHI,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_4_5;
                        return;
                }
        }
        else
                if (pcu == &timers[0])
                        timer_int_enabled = FALSE;
                pcu->state = awaitingGate;
                pcu->actionOnGateEnabled = startCounting;
                switch (pcu->m)
                {
                case INT_ON_TERMINALCOUNT:
                        pcu->stateOnGate = Counting0;
                        return;
                case PROG_ONESHOT:
                        pcu->stateOnGate = Counting1;
                        return;
                case RATE_GEN:
                case SQUAREWAVE_GEN:
                        pcu->stateOnGate = Counting_2_3;
                        return;
                case SW_TRIG_STROBE:
                case HW_TRIG_STROBE:
                        pcu->stateOnGate = Counting_4_5;
                        return;
                }
}

LOCAL void startCounting IFN0()
{
        timestamp();
        runCount();
}

#ifndef NTVDM
/* calculate the number of 8253 clocks elapsed since counter was last
 * activated
 */

LOCAL unsigned long clocksSinceCounterActivated IFN1(struct host_timeval *, now)
{
    struct host_timeval *first;
    register unsigned long usec_val, nclocks;
    register unsigned int secs;
#if defined(NEC_98)
    unsigned short bios_flag;
#endif   //NEC_98

    first = &pcu->activationTime;
    (*pcu->getTime)(now);

    /* calculate #.usecs elapsed */

    secs = (int)(now->tv_sec - first->tv_sec);
    switch (secs)
    {
    case 0:  usec_val = now->tv_usec - first->tv_usec;
#ifndef PROD
            if (io_verbose & TIMER_VERBOSE)
                    if ( usec_val == 0 )
                        trace("clocksSinceCounterActivated() == 0 !", 0);
#endif
#if defined(NEC_98)
            sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
            if(bios_flag & 0x8000)
                nclocks = (usec_val * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
            else
                nclocks = (usec_val * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#else    //NEC_98
             nclocks  = (usec_val * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif   //NEC_98
             break;

    case 1:  usec_val = 1000000L + now->tv_usec - first->tv_usec;
#if defined(NEC_98)
            sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
            if(bios_flag & 0x8000)
                nclocks = (usec_val * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
            else
                nclocks = (usec_val * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#else    //NEC_98
             nclocks  = (usec_val * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif   //NEC_98
             break;

    default:
             nclocks   = ((now->tv_usec - first->tv_usec) * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
             nclocks  += secs * (1000000L * TIMER_CLOCK_DENOM / TIMER_CLOCK_NUMER);
#ifndef PROD
            if (io_verbose & TIMER_VERBOSE) {
                sprintf(buf, "timer[%d]: %d seconds have passed!", pcu-timers, secs);
                trace(buf, DUMP_NONE);
            }
#endif
             break;
    }
    return nclocks;
}

#endif


LOCAL void updateCounter IFN0()
{
#ifndef NTVDM
    unsigned long nticks;
    struct host_timeval now;
#endif /* NTVDM */
    unsigned long wrap;
#if defined(NEC_98)
    int         save_tc;
#endif   //NEC_98

        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
        case RATE_GEN:
        case SQUAREWAVE_GEN:
                if (pcu->gate == GATE_SIGNAL_LOW)
                        return;
#ifdef NTVDM
                wrap = updateCount();
#else
                nticks = clocksSinceCounterActivated(&now);
                updateCount(nticks, &wrap,&now);
#endif
                if (wrap)
                        pcu->tickadjust = pcu->Count;
                if (pcu->m == INT_ON_TERMINALCOUNT && wrap)
#if defined(NEC_98)
                        save_tc = pcu->tc;
#else   //NEC_98
                        pcu->tc = 1;
#endif   //NEC_98
                if (pcu == &timers[0] && wrap){
                        if (pcu->m != INT_ON_TERMINALCOUNT)
                                issueIREQ0((unsigned int)wrap);
                        else
                                issueIREQ0(1);
#ifdef HUNTER
                        timer_batch_count = wrap;
#endif

                }
                return;
        case PROG_ONESHOT:
        case SW_TRIG_STROBE:
        case HW_TRIG_STROBE:
                if (pcu->tc)
                        return;
#ifdef NTVDM
                wrap = updateCount();
#else
                nticks = clocksSinceCounterActivated(&now);
                updateCount(nticks, &wrap,&now);
#endif
                if (wrap)
                {
                        pcu->Count = 0;
                        pcu->tc = 1;
#ifdef NTVDM
                        RealTimeCountCounterZero = 0;
#endif

                }
#ifdef HUNTER
                if (pcu == &timers[0]){
                        timer_batch_count = wrap;
                }
#endif
                return;
        }
}


#ifndef NTVDM
#ifndef DELAYED_INTS
/*
 *      timer_no_longer_too_soon() - this is the function invoked by the quick event manager
 *      "HOST_TIMER_TOOLONG_DELAY" instructions after a hardware interrupt is generated. It
 *      clears the variable "too_soon_after_previous" to allow more interrupts to be
 *      generated and kicks off an immediate one if any have been suppressed this time.
 */
LOCAL void timer_no_longer_too_soon IFN1(long, dummy)
{
        UNUSED(dummy);

        too_soon_after_previous = FALSE;
        if (ticks_lost_this_time){
                /* At least one tick was suppressed... so send another one immediately */
                timer_generate_int (1);
        }
}

/*
 *      timer_generate_int() -The routine to generate a single timer hardware interrupt (and to
 *      schedule a quick event timer call on itself to have the remaining pending interrupts
 *      generated at a later time).
 *
 */
LOCAL void timer_generate_int IFN1(long, n)
{
#if !(defined(GISP_CPU) || defined(CPU_40_STYLE))
        if (getPE()){
                /* Prot mode tick... */
#ifndef PROD
                if (!hack_active){
                        SAVED BOOL first=TRUE;

                        always_trace0 ("PM timer Hack activated.");
                        if (first){
                                always_trace1 ("Min # instrs between interrupts = %d", HOST_TIMER_TOOLONG_DELAY);
                                always_trace1 ("        Nominal instrs_per_tick = %d", instrs_per_tick);
                                always_trace1 ("       adjusted instrs_per_tick = %d", adj_instrs_per_tick);
                                always_trace1 ("  # rm instrs before full speed = %d", n_rm_instrs_before_full_speed);
                                always_trace1 ("     rm ticks before full speed = %d", adj_n_real_mode_ticks_before_full_speed);
                                first = FALSE;
                        }
                }
#endif
                hack_active = TRUE;
                real_mode_ticks_in_a_row = 0;

        }else{
                /* Real Mode Tick... */
                if (hack_active){
                        real_mode_ticks_in_a_row++;
                        if (real_mode_ticks_in_a_row >= adj_n_real_mode_ticks_before_full_speed){
                                hack_active = FALSE;
                                always_trace0 ("PM timer Hack deactivated.");
                        }
                }
        }
#endif  /* ! (GISP_CPU||CPU_40_STYLE) */

        if (hack_active){
                if (!too_soon_after_previous){
                        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                        too_soon_after_previous = TRUE;
                        ticks_lost_this_time = FALSE;
                        add_q_event_i(timer_no_longer_too_soon,HOST_TIMER_TOOLONG_DELAY,0);
                }else{
                        ticks_lost_this_time = TRUE;
#ifndef PROD
                        ticks_ignored++;
                        if (!(ticks_ignored & 0xFF)){
                                always_trace0 ("another 256 ticks lost!");
                        }
#endif
                }
        }else{
#ifndef GISP_CPU
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
        }
}
#else /* GISP_CPU */
#if defined(IRET_HOOKS)
                if (!HostDelayTimerInt(n))
                {       /* no host need to delay this timer int, so generate one now. */
                        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                }

#else /* !IRET_HOOKS */
                /* GISP_CPU doesn't use quick events so use ica_hw_interrupt(,,n). */
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
#endif /* IRET_HOOKS */
        }
}
#endif /* GISP_CPU */

#endif /* DELAYED_INTS */

#else   /* NTVDM */


/*
 *  TimerGenerateMultipleInterrupts
 *
 */
void TimerGenerateMultipleInterrupts(long n)
{


    if (!EoiPending) {
        EoiPending += n;
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
        }
    else {
        if (n > 5 && (dwWNTPifFlags & COMPAT_TIMERTIC)) {
            n = 5;
            }

        if (EoiIntsPending/n < 19) {   // less than a second behind ?
            EoiIntsPending += n;
            }
        else {
            EoiIntsPending++;
            }
#if defined(NEC_98)
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
#endif   //NEC_98
        }
}


#ifndef MONITOR

/* On RISC ports, it is dangerous to call getIF from a non-CPU thread,
   so we replace the call with a peek at the global 'EFLAGS' variable
   until the CPU emulator getIF is made safe.
*/

#undef getIF
#define getIF() (GLOBAL_EFLAGS & 0x200)

#endif /* !MONITOR */


/*  timer_generate_int NTVDM
 *
 */
void timer_generate_int (void)
{
    word lo, hi, wrap;

      /*
       *  For Nt port see if we really need to generate
       *  an int, checking if an app has hooked real-mode
       *  or protect-mode vectors.
       *
       *  If we don't need to do it, then update the bios
       *  Data tic count directly.
       *
       *  WARNING according to sfrost it is not safe to
       *          use sas, because of multithreading.
       */


#if defined(NEC_98)
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
#else   //NEC_98

    hi = * (word *)(Start_of_M_area+0x1c*4+2);
    lo = * (word *)(Start_of_M_area+0x1c*4);
    wrap = (word) *(half_word *)(Start_of_M_area + ((ULONG)hi << 4) + lo);
    if (!getIF() || ((hi != TimerInt1CSeg || lo != TimerInt1COff) && wrap != 0xcf) ||
        *(word *)(Start_of_M_area+0x08*4+2) != TimerInt08Seg ||
        *(word *)(Start_of_M_area+0x08*4)   != TimerInt08Off ||
        (*pNtVDMState & VDM_INT_HOOK_IN_PM))
       {
        TimerGenerateMultipleInterrupts(1);
        }
    else {  /* update Bios Data Area directly */
        ++(*(double_word *)(Start_of_M_area + TIMER_LOW));

            /* Wrap at 24 hours ? */
        if (*(double_word *)(Start_of_M_area + TIMER_LOW) == 0x1800b0)
           {
            *(word *)(Start_of_M_area + TIMER_LOW)  = 0;
            *(word *)(Start_of_M_area + TIMER_HIGH) = 0;
            *(half_word *)(Start_of_M_area+TIMER_OVFL)=1;
           }

            /* decr motor count */
        --(*(half_word *)(Start_of_M_area + MOTOR_COUNT));

            /*  if motor count went to zero turn off the motor */
        if (!*(half_word *)(Start_of_M_area + MOTOR_COUNT))
           {
            *(half_word *)(Start_of_M_area + MOTOR_STATUS) &= 0xF0;
            fla_outb(DISKETTE_DOR_REG, 0x0C);
            }

        if (EoiDelayInUse && !(--EoiDelayInUse))  {
            host_DelayHwInterrupt(CPU_TIMER_INT, 0, 0xFFFFFFFF);
            }
        }
#endif   //NEC_98
}



/*  TimerEoiHook
 *
 *  EoiHook for the timer interrupt used to regulate the flow of
 *  timer interrupts to ensure that ints are not generated too
 *  close together. This routine is invoked by the ica EoiHook
 *  callbacks.
 *
 */
void TimerEoiHook(int IrqLine, int CallCount)
{
    if (EoiPending)
        --EoiPending;

    if (CallCount < 0) {       // interrupts were canceled
        EoiIntsPending = 0;
        EoiPending = 0;
        }
    else if (CallCount) {
#if defined(NEC_98)
        EoiDelayInUse = 2;
#else    //NEC_98
        EoiDelayInUse = 100;
#endif   //NEC_98
        host_DelayHwInterrupt(CPU_TIMER_INT,
                              0,
                              timer_delay_size
                              );
        }
    else if (EoiIntsPending) {
#if defined(NEC_98)
        EoiDelayInUse = 2;
#else    //NEC_98
        EoiDelayInUse = 100;
#endif   //NEC_98
        if (host_DelayHwInterrupt(CPU_TIMER_INT,
                                  EoiIntsPending,
                                  timer_delay_size
                                  ))
           {
            EoiPending = EoiIntsPending;
            }
        EoiIntsPending = 0;
        }
    else {
        if (EoiDelayInUse && !(--EoiDelayInUse))  {
            host_DelayHwInterrupt(CPU_TIMER_INT, 0, 0xFFFFFFFF);
            }
        }

}

#endif /* NTVDM */


#ifndef NTVDM
/*
 * Handle a cranked up timer where multiple interrupts are
 * required per tick. Schedule 'n' ints over a tick. Period
 * stored in quick event argument rather than in global.
 */
LOCAL void timer_multiple_ints IFN1(long, num_ints)
{
        /* generate timer int */
        timer_generate_int(1);

        /* one less to do */
        num_ints --;

        /* any more arrived whilst we were q_ expiring? */
        num_ints += more_timer_mult;
        more_timer_mult = 0;

        /* throw away ints that are going to take more than MAX_BACK_SECS
         * to clear up. (!!!!)
         */
        if (num_ints > max_backlog)
        {
                num_ints = max_backlog;
        }

        /* schedule next int (if required) */
        if (num_ints == 0)
        {
                active_int_event = FALSE;
                 /* 1.193180 usecs per clock */
                max_backlog = (1193180 * MAX_BACK_SECS) / timers[0].initialCount;
        }
        else    /* more work to do */
        {
                /* set new quick_ev off - delay determined by timer wrap rate */
                add_q_event_t(timer_multiple_ints, timer_multiple_delay, num_ints);
        }

}
#endif


LOCAL void issueIREQ0 IFN1(unsigned int, n)
{
        IU16 int_delay; /* delay before handling wrapped int */

#ifndef PROD
static  pig_factor  = 0;
static  time_factor = 0;
#endif

#ifdef PIG
extern  IBOOL ccpu_pig_enabled;
#endif

#ifndef PROD
    if ( time_factor == 0 )
    {
        char *env;

        env = host_getenv("TIMER_FACTOR");
        if ( env )
                time_factor = atoi(env);
        if ( time_factor == 0 )
                time_factor = 1;
#ifdef PIG
        if ( pig_factor == 0 )
        {
                env = host_getenv("PIG_TIMER_FACTOR");
                if ( env )
                        pig_factor = atoi(env);
                if ( pig_factor == 0 )
                        pig_factor = 10;
        }
#else
        pig_factor = 1;
#endif
    }
#endif

    if (ticks_blocked == 0)
    {
#ifndef PROD
#ifdef PIG
                if ( ccpu_pig_enabled ) {
                        ticks_blocked = pig_factor-1;
                } else
#endif
                        ticks_blocked = time_factor-1;
#endif
                if (timer_int_enabled)
                {
#ifdef DELAYED_INTS
                        ica_hw_interrupt_delay(ICA_MASTER,CPU_TIMER_INT, n,
                                HOST_TIMER_INT_DELAY);
#else /* !DELAYED_INTS */

#ifdef NTVDM
                        if (n > 0) {
                            if (n <= 4) {
                                timer_delay_size= (HOST_IDEAL_ALARM) / (n+1);
                            } else {
                                timer_delay_size= (HOST_IDEAL_ALARM - (HOST_IDEAL_ALARM >> 2)) / (n+1);
                            }
                        }


                        if (n == 1) {
                            timer_generate_int();
                            }
                        else if (n > 1){
                            TimerGenerateMultipleInterrupts(n);
                            }
#else /* !NTVDM */


                        /* if we've got a quick event running, add to its workload */
                        if (active_int_event)
                        {
                                /* spread interrupts through system tick */
                                int_delay = SYSTEM_TICK_INTV / (n + 1);
                                if (int_delay < timer_multiple_delay)
                                        timer_multiple_delay = int_delay;
                                more_timer_mult += n;
                        }
                        else
                        {
                                /* ensure multiple delay restarts at sensible speed */
                                timer_multiple_delay = SYSTEM_TICK_INTV >> 1;
                                if (n == 1)
                                {
                                        timer_generate_int(1);
                                }
                                else
                                {
                                        /* spread interrupts through system tick */
                                        timer_generate_int(1);
                                        timer_multiple_delay = SYSTEM_TICK_INTV / n;
                                        active_int_event = TRUE;
                                        add_q_event_t(timer_multiple_ints, timer_multiple_delay, n-1);
                                }
                        }

#endif /* !NTVDM */
#endif /* !DELAYED_INTS */
                }
    }
    else if (ticks_blocked > 0)
    {
                ticks_blocked--;
    }
}



#ifdef NTVDM
unsigned long clocksSinceCounterUpdate(struct host_timeval *pCurrTime,
                                       struct host_timeval *pLastTime,
                                       word                *pCounter  )
{
     unsigned long clocks, wrap, usecs;
#if defined(NEC_98)
     unsigned long nclocks;
     unsigned short bios_flag;
#endif   //NEC_98


         /*  Calculate usecs elapsed and clocks elapsed since last update
          *
          *  For NT port timer zero's IdealInterval is exact to a modulo
          *  of 65536, for efficiency and accuracy we stick with the exact
          *  number of clocks between IdealIntervals.
          */
     if (pCounter == &timers[0].Count)  { /* update quick way for IdealTime */
        if (pCurrTime->tv_sec  != pLastTime->tv_sec ||
            pCurrTime->tv_usec != pLastTime->tv_usec  )
           {
            *pLastTime = *pCurrTime;
            return 65536/pcu->initialCount;
            }
        else {
            usecs = clocks = 0;
            }
        }
    else {              /* calc diff in usecs and clocks elapsed */
        usecs =  (unsigned long)(pCurrTime->tv_sec - pLastTime->tv_sec);
        if (!usecs) {
            usecs = pCurrTime->tv_usec - pLastTime->tv_usec;
            }
        else if (usecs == 1) {
            usecs = 1000000L - pLastTime->tv_usec + pCurrTime->tv_usec;
            }
        else {
            usecs = pCurrTime->tv_usec - pLastTime->tv_usec +
                    (pCurrTime->tv_sec - pLastTime->tv_sec) * 1000000L;
            }

         /* ... clocks elapsed 1.193180 usecs per clock
          *
          * However, app time is not real time so round down
          * a teency bit by truncating the "180"
          *
          * clocks = (usecs * 1193)/1000  + (usecs * 180)/1000000;
          */

#if defined(NEC_98)
        sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
        if(bios_flag & 0x8000)
            nclocks = TIMER_CLOCK_DENOM_8;
        else
            nclocks = TIMER_CLOCK_DENOM_10;
        clocks =  (usecs * nclocks)/1000;
#else    //NEC_98
        clocks =  (usecs * 1193)/1000;
#endif   //NEC_98
        }

         /* how many times did counter wrap ? */
    wrap = clocks/pcu->initialCount;

         /* calc ticks from elapsed clocks */
    clocks = clocks && pcu->initialCount ? clocks % pcu->initialCount : 0;
    *pCounter = (word) (pcu->initialCount - clocks);

       /* if the count wrapped reset Last Update time stamp */
    if (wrap)  {
        *pLastTime = *pCurrTime;

        if ((ULONG)pLastTime->tv_usec < usecs)  {
            pLastTime->tv_sec--;
            pLastTime->tv_usec = 1000000L + pLastTime->tv_usec - usecs;
            }
        else  {
            pLastTime->tv_usec -= usecs;
            }
        }

    return wrap;
}


unsigned long updateCount(void)
{
     unsigned long wrap;
     struct host_timeval curr;


         /*
          * For timer zero, update real time count, time stamp
          */
     if (pcu == &timers[0]) {
         host_GetSysTime(&curr);
         clocksSinceCounterUpdate(&curr,
                                  &LastTimeCounterZero,
                                  &RealTimeCountCounterZero);
         }

          /*
           *  Update the pcu count, time stamps
           */
     (*pcu->getTime)(&curr);
     wrap = clocksSinceCounterUpdate(&curr,
                                     &pcu->activationTime,
                                     &pcu->Count);

     return wrap;
}


unsigned short GetLastTimer0Count(void)
{
    return RealTimeCountCounterZero;
}

unsigned short LatchAndGetTimer0Count(void)
{
    controlWordReg(0);
    return RealTimeCountCounterZero;
}

unsigned long GetTimer0InitialCount(void)
{
    return timers[0].initialCount;
}



#else
LOCAL void updateCount IFN3(unsigned long, ticks, unsigned long *, wrap,
        struct host_timeval *, now)
{
        unsigned long modulo = pcu->initialCount;

        /*
         * PCLABS version 4.2 uses counter 2 (the sound channel) to
         * time around 45 ms on a 8MHz 286. On SoftPC we cannot
         * guarantee to go that fast, and so we must wind the tick
         * rate down to ensure that the counter does not wrap. How much
         * we wind down the tick rate is host dependent. The object is
         * to get the test finishing in less than
         * host_timer_2_frig_factor/18 secs.
         *
         * host_timer_2_frig_factor is now redundant. 28/4/93 niall.
         */

#if defined(NEC_98)
        if (pcu == &timers[1]) {
#else    //NEC_98
        if (pcu == &timers[2]) {
#endif   //NEC_98
                /*
                 * PMINFO uses ~counter, so one tick becomes 0.
                 * 2 ticks is just as good. Avoid guessing (frig_factor!).
                 */
                if ((ticks - pcu->lastTicks) == 0)
                        ticks = 2;
        }

        /* if the counter has been read too quickly after its last
         * access, then the host may not show any visible change in
         * host time ... in which case we just guess at a suitable
         * number of elapsed ticks.
         */

        if ((long)(ticks - pcu->lastTicks) <= 0){
                ticks = guess();
        }else{
                throwaway();
                pcu->lastTicks = ticks;
        }

        /* the counter holds some count down value ...
         * if the number of 8253 clocks elapsed exceeds this amount
         * then the counter must have wrapped
         */

        if ( ticks < modulo ) {
                *wrap = 0;
        } else {
                *wrap = 1;
                ticks -= modulo;

                if ( pcu->m == INT_ON_TERMINALCOUNT )
                        modulo = 0x10000L;

                if ( ticks >= modulo ) {
                        *wrap += ticks/modulo;
                        ticks %= modulo;

#ifndef PROD
                        if (io_verbose & TIMER_VERBOSE)
                            if ( pcu->m == INT_ON_TERMINALCOUNT ) {
                                sprintf(buf, "%lx wraps for timer[%d]", *wrap, pcu-timers);
                                trace(buf, DUMP_NONE);
                        }
#endif
                }
        }

        /* calculate new counter value */
        pcu->Count = (word)(modulo-ticks);

        /* calculate time at which last wrap point occurred, and
         * use this to stamp the counter
         */

        if (*wrap)
                setLastWrap((unsigned int)(modulo-pcu->Count),now);

}



/* calculate time for last wrap around of counter, and use this
 * to mark counter activation time.
 */

LOCAL void setLastWrap IFN2(unsigned int, nclocks, struct host_timeval *, now)
{
        struct host_timeval *stamp;
        unsigned long usecs;
#if defined(NEC_98)
        unsigned short bios_flag;
#endif   //NEC_98

        stamp  = &pcu->activationTime;
        *stamp = *now;
#if defined(NEC_98)
        sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
        if(bios_flag & 0x8000)
            usecs = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM_8;
        else
            usecs = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM_10;
#else    //NEC_98
        usecs  = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM;
#endif   //NEC_98

        if (stamp->tv_usec < usecs)
        {
                stamp->tv_sec--;
                stamp->tv_usec += 1000000L;
        }
        stamp->tv_usec -= usecs;

        pcu->lastTicks = nclocks;
}

#endif  /* NTVDM*/



#ifndef NTVDM
/*
 * If the host timer gives the same result as last time it was called,
 * we must give the illusion that time has passed.
 * The algorithm uesd is to keep track of how often we have to guess
 * between host timer ticks, and to assume that guesses should be evenly
 * distributed between host ticks, ie. the time between two guesses should be:
 *      Guess ticks = hosttickinterval/nguesses
 * If we find that the total guessed time is getting dangerously near to being the time
 * between two host ticks, we start reducing the guess tick interval so as to avoid
 * guessing a total time that is too large.
 *
 * From observation, applications use the timer in both coarse and fine 'modes'.
 * The coarse mode is the hardware interrupt handler and then in between
 * interrupts, the timer is polled to detect time passing (hence guess below).
 * The fine mode polling does not commence until some portion of the tick time
 * has elapsed - probably as the coarse int handler will consume some of the
 * time. If guess() bases its timefrig over the whole tick, then given the
 * above behaviour, a polling counter can reach tick end time before the int
 * is delivered. This can fool applications (e.g. Win 3.1 VTD) into having
 * time pass at the wrong rate (approx double for Win 3.1). By calculating
 * the timefrig on most (7/8) of the tick period, this problem is avoided.
 */

LOCAL unsigned long guess IFN0()
{
        if (!pcu->microtick)
        {
                pcu->saveCount = pcu->Count;
                pcu->timeFrig = ((ticksPerIdealInterval * 7) >> 3) / pcu->guessesPerHostTick;      /* guesses over 7/8 of tick */
#ifndef PROD
                if (io_verbose & TIMER_VERBOSE) {
                        sprintf(buf, "guess init timer[%d]: timeFrig = %lx", pcu-timers, pcu->timeFrig);
                        trace(buf, DUMP_NONE);
                }
#endif
        }
        if(pcu->guessesSoFar++ > pcu->guessesPerHostTick)
        {
        /*
         * PC Program is reading the timer more often than in the last timer tick, so need to
         * decay timeFrig to avoid too much 'time' passing between host ticks
         */
                pcu->timeFrig = (pcu->timeFrig >> 1) + 1;
#ifndef PROD
                if (io_verbose & TIMER_VERBOSE) {
                        sprintf(buf, "guess decay: timeFrig = %lx", pcu->timeFrig);
                        trace(buf, DUMP_NONE);
                }
#endif
        }
        pcu->microtick += pcu->timeFrig;
        return (pcu->microtick + pcu->lastTicks);
}


/*
 * After a few (maybe none) guesses, the host timer has finally ticked.
 * Try and work out a good frig factor for the next few guesses, based
 * on the number of guesses we had to make.
 */
LOCAL void throwaway IFN0()
{
        pcu->guessesPerHostTick = (pcu->guessesPerHostTick + pcu->guessesSoFar)>>1;
        pcu->guessesSoFar = 2;          /* Handy to count from 2! */
        if (!pcu->microtick)
                return;
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "throwaway: guessesPerHostTick = %d", (int)pcu->guessesPerHostTick);
        trace(buf, DUMP_NONE);
    }
#endif
        pcu->Count = pcu->saveCount;
        pcu->microtick = 0;
}

#endif  /* ndef NTVDM */

LOCAL unsigned  short bin_to_bcd IFN1(unsigned long, val)
{
    register unsigned  short m, bcd, i;

    m = (short)(val % 10000L);
    bcd = 0;
    for (i=0; i<4; i++)
    {
         bcd = bcd | ((m % 10) << (i << 2));
         m /= 10;
    }
    return(bcd);
}

/*
 * convert 4 decade bcd value to binary
 */
LOCAL word bcd_to_bin IFN1(word, val)
{
    register word bin, i, mul;
    bin = 0;
    mul = 1;
    for (i=0; i<4; i++)
    {
        bin += (val & 0xf) * mul;
        mul *= 10;
        val = val >> 4;
    }
    return (bin);
}

/*
 * this routine returns the number of timer clocks equivalent
 * to the input count, allowing for timer mode and down count.
 */

LOCAL unsigned long timer_conv IFN1(word, count)
{
        if (!count)
        {
                if (pcu->bcd == BCD)
                        return 10000L;
                else
                        return 0x10000L;
        }
        else
                return (unsigned long)count;
}


/* this routine returns the current ideal time value ...
 * this is a very coarse resolution time ... it only changes
 * per call to time_tick(). It does however represent what the
 * system time would be given 100% accurate time signal
 * ... this routine gets used for time-stamping if time_tick()
 * is active, otherwise time-stamping is done using
 * getHostSysTime() ... see below.
 */

LOCAL void getIdealTime IFN1(struct host_timeval *, t)
{
        t->tv_sec = idealtime.tv_sec;
        t->tv_usec = idealtime.tv_usec;
}

/* update our ideal time by the period (in usecs) between timer signals
 * from the host as though these were delivered 100% accurately
 */

LOCAL void updateIdealTime IFN0()
{
        idealtime.tv_usec += idealInterval;
        if (idealtime.tv_usec > 1000000L)
        {
                idealtime.tv_usec -=1000000L;
                idealtime.tv_sec++;
        }
}

#ifndef NTVDM

/* get current host system time ... used for time-stamping and
 * querying during io from Intel application
 */

LOCAL void getHostSysTime IFN1(struct host_timeval *, t)
{
        struct host_timezone dummy;
        host_gettimeofday(t, &dummy);

        /*
         * check that we haven't gone back in time.
         */

        if (t->tv_sec < idealtime.tv_sec ||
         (t->tv_usec < idealtime.tv_usec && t->tv_sec == idealtime.tv_sec))
        {
                /*
                 * The real time has fallen behind the ideal time.
                 * This should never happen... If it does we must
                 * stay at the ideal time.
                 */

#ifndef PROD
#ifndef PIG
                sprintf(buf,"TIME WARP!!");
                trace(buf,0);
#endif
#endif
                *t = idealtime;
        }
}
#endif /* !NTVDM */


/*
 * Used to temporarily stop the timer interrupts. PCLABS bench29
 * causes this to be called iff a 80287 is being used.
 */

void    axe_ticks IFN1(int, ticks)
{
#ifndef PROD
        /*
         * No need to axe ticks if timers are disabled by toff2 (if
         * ticks_blocked is negative)
         */
        if (ticks_blocked >=0)
#endif  /* PROD */
                ticks_blocked = ticks;
}

/*
 * Initialization code
 */
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NEC_98)
GLOBAL void IdealTimeInit IFN0()
{
    unsigned short bios_flag;

    idealInterval = HOST_IDEAL_ALARM;
#ifndef NTVDM
    getHostSysTime(&idealtime);
    sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
    if(bios_flag & 0x8000)
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
    else
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#endif
}
#else    //NEC_98
#ifdef SYNCH_TIMERS

GLOBAL void IdealTimeInit IFN0()
{

    extern IU32 Q_timer_restart_val;

    idealInterval = Q_timer_restart_val;

#else

LOCAL void IdealTimeInit IFN0()
{
    idealInterval = HOST_IDEAL_ALARM;

#endif

#ifndef NTVDM
    getHostSysTime(&idealtime);
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif
}
#endif   //NEC_98

LOCAL void Timer_init IFN0()
{
        int i;
        for (i=0; i<3; i++)
                counter_init(&timers[i]);
#ifdef NTVDM
        timers[0].getTime = getIdealTime;       /* Use the 'ideal' time for timer 0, ie. calls to time_tick */
        timers[1].getTime = host_GetSysTime;    /* We don't really expect anyone to use timer 1 */
        timers[2].getTime = host_GetSysTime;    /* Use real host time for timer 2 */
#else
        timers[0].getTime = getIdealTime;       /* Use the 'ideal' time for timer 0, ie. calls to time_tick */
        timers[1].getTime = getHostSysTime;     /* We don't really expect anyone to use timer 1 */
        timers[2].getTime = getHostSysTime;     /* Use real host time for timer 2 */
#endif
}

LOCAL void counter_init IFN1(COUNTER_UNIT *, p)
{
        p->state = uninit;
        p->initialCount = 0x10000L;     /* Avoid dividing by zero in updateCount()! */
#ifndef NTVDM
        p->guessesPerHostTick = p->guessesSoFar = 2;            /* Handy to count from 2! */
        p->timeFrig = ticksPerIdealInterval / p->guessesPerHostTick;
#endif
}

#if !defined (NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
/*(
 *======================= TimerHookAgain() ============================
 * TimerHookAgain
 *
 * Purpose
 *      This is the function that we tell the ica to call when a timer
 *      interrupt service routine IRETs.
 *
 * Input
 *      adapter_id      The adapter id for the line. (Note the caller doesn't
 *                      know what this is, he's just returning something
 *                      we gave him earlier).
 *
 * Outputs
 *      return  TRUE if there are more interrupts to service, FALSE otherwise.
 *
 * Description
 *      Check if we have a delayed interrupt, if so then generate the timer int
 *      and return TRUE, else return FALSE
)*/

GLOBAL IBOOL
TimerHookAgain IFN1(IUM32, adapter)
{       char scancode;

        if (HostPendingTimerInt())
        {       /* We have a host delayed interrupt, so generate a timer int. */
                sure_note_trace0(TIMER_VERBOSE,"callback with delayed timer int.");
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                return(TRUE);   /* more to do */
        }
        else
        {
                return(FALSE);
        }
}

#endif /* IRET_HOOKS && GISP_CPU */
#endif /* !NTVDM */

void timer_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for this adaptor
     */

    io_define_inb(TIMER_ADAPTOR, timer_inb_func);
    io_define_outb(TIMER_ADAPTOR, timer_outb_func);

#if defined(NEC_98)
    for(i = TIMER_PORT_START; i < TIMER_PORT_END; i += 2)
        {
                if( (i & 7) == 7 )
#else    //NEC_98
    for(i = TIMER_PORT_START; i < TIMER_PORT_END; i++)
        {
                if( (i & 3) == 3 )
#endif   //NEC_98
                        io_connect_port(i, TIMER_ADAPTOR, IO_WRITE);            /* Control port - write only */
                else
                io_connect_port(i, TIMER_ADAPTOR, IO_READ_WRITE);       /* Timer port - read/write */
        }

#if defined(NEC_98)
    io_connect_port(0x3fdb, TIMER_ADAPTOR, IO_READ_WRITE);
    io_connect_port(0x3fdf, TIMER_ADAPTOR, IO_WRITE);
#endif   //NEC_98
    IdealTimeInit();

    Timer_init();

#ifndef NTVDM
    timelock = UNLOCKED;
    needtick = 0;
#else
    RegisterEOIHook(CPU_TIMER_INT, TimerEoiHook);
#endif

        /*
         * Start up the host alarm system
         */

        host_timer_init();

#if !defined(NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
        /*
         * Remove any existing hook call-back, and re-instate it afresh.
         * TimerHookAgain is what gets called on a timer int iret.
         */

        Ica_enable_hooking(CPU_TIMER_INT, NULL, ICA_MASTER);
        Ica_enable_hooking(CPU_TIMER_INT, TimerHookAgain, ICA_MASTER);

        /* Host routine to reset any internal data for IRET_HOOK delayed ints. */
        HostResetTimerInts();

#endif /* IRET_HOOKS && GISP_CPU */


        active_int_event = FALSE; /* clear any cranked timer state */
        more_timer_mult = 0;

#if defined(CPU_40_STYLE)
        ica_iret_hook_control(ICA_MASTER, CPU_TIMER_INT, TRUE);
#endif
#endif /* !NTVDM */
}

void    timer_post IFN0()
{
#if defined(NEC_98)
    unsigned short bios_flag;
#endif   //NEC_98
    /* enable gates on all timer channels */
    timer_gate(TIMER0_REG,GATE_SIGNAL_RISE);    /* start timer 1 going... */
    timer_gate(TIMER1_REG,GATE_SIGNAL_RISE);
    timer_gate(TIMER2_REG,GATE_SIGNAL_RISE);

#if defined(NEC_98)
    timer_outb(TIMER_MODE_REG,0x30);
    timer_outb(TIMER0_REG,0);
    timer_outb(TIMER0_REG,0);

    timer_outb(TIMER_MODE_REG,0x76);
    sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
    if(bios_flag & 0x8000) {
        timer_outb(TIMER1_REG,0xE6);
        timer_outb(TIMER1_REG,0x03);
    } else {
        timer_outb(TIMER1_REG,0xcd);
        timer_outb(TIMER1_REG,0x04);
    }

    timer_outb(TIMER_MODE_REG,0xb6);
    timer_outb(TIMER2_REG,0x01);
    timer_outb(TIMER2_REG,0x01);
#else    //NEC_98
    timer_outb(TIMER_MODE_REG,0x36);
    timer_outb(TIMER0_REG,0);
    timer_outb(TIMER0_REG,0);

    timer_outb(TIMER_MODE_REG,0x54);
    timer_outb(TIMER1_REG,17);

    timer_outb(TIMER_MODE_REG,0xb6);
    timer_outb(TIMER2_REG,0x68);
    timer_outb(TIMER2_REG,0x04);
#endif   //NEC_98
}

#ifdef DOCUMENTATION
#ifndef PROD

/*
 * Debugging code....
 * This code has no effect.  It is left here in case anyone wants to
 * expand it in future.
 */

dumpCounter IFN0()
{
        static char *modes[] =
        {       "int on tc",
                "prog one shot",
                "rate gen",
                "squarewave gen",
                "sw trig strobe",
                "hw trig strobe"
        };

        static char *as[] =
        {       "binary",
                "bcd"
        };

        char *p, *q;

        p = modes[pcu->m];
        q = as[pcu->bcd];
}
#endif /* nPROD */
#endif /* DOCUMENTATION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\crtc.c ===
/*      CRTC Emulation File                                                   */
/*                                                            NEC     NEC98    */

#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "crtc.h"
#include "debug.h"
#include "gvi.h"

extern BOOL HIRESO_MODE;
extern BOOL     video_emu_mode;

CRTC_GLOBS crtcglobs;

GLOBAL void crtc_outb IFN2(io_addr, port, half_word, value) {
        if (!HIRESO_MODE) {
                switch(port) {
                        case CRTC_SET_PL:
                        case CRTC_SET_BL:
                                if(port==CRTC_SET_PL){
                                        crtcglobs.regpl = value;
                                }else{
                                        crtcglobs.regbl = value;
                                }
//                              if( video_emu_mode ){
                                        if( (crtcglobs.regpl==0x1E) &&
                                                (crtcglobs.regbl==0x11) )
                                        {
                                                set_char_height(20);
                                                set_mode_change_required(TRUE);
                                        }
                                        else if( (crtcglobs.regpl == 0x00) &&
                                                 (crtcglobs.regbl == 0x0F) )
                                        {
                                                set_char_height(16);
                                                set_mode_change_required(TRUE);
                                        }
//                              }
                                break;
                        case CRTC_SET_CL:
                                crtcglobs.regcl = value;
                                break;
                        case CRTC_SET_SSL:
                                crtcglobs.regssl = value;
                                break;
                        case CRTC_SET_SUR:
                                crtcglobs.regsur = value;
                                break;
                        case CRTC_SET_SDR:
                                crtcglobs.regsdr = value;
                                break;
                        default:
                                assert1(FALSE,"NEC98:Illegal Port %#x",value);
        }
        }
}

GLOBAL void crtc_init IFN0() {
        if (!HIRESO_MODE) {
            io_define_outb(LINE_COUNTER,crtc_outb);
                io_connect_port(CRTC_SET_PL,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_BL,LINE_COUNTER,IO_WRITE);
        io_connect_port(CRTC_SET_CL,LINE_COUNTER, IO_WRITE);
                io_connect_port(CRTC_SET_SSL,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_SUR,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_SDR,LINE_COUNTER,IO_WRITE);
        }
}

GLOBAL void crtc_post IFN0() {
        if (!HIRESO_MODE) {
                crtc_outb(CRTC_SET_PL,0);
                crtc_outb(CRTC_SET_BL,0x0F);
                crtc_outb(CRTC_SET_CL,0x10);
                crtc_outb(CRTC_SET_SSL,0);
                crtc_outb(CRTC_SET_SUR,1);
                crtc_outb(CRTC_SET_SDR,0);
        }
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\cga.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SoftPC Revision 3.0
 *
 * Title        : IBM Colour/Graphics Adapter simulator
 *
 * Description  : Simulates the IBM CGA.
 *
 * Author       : Rod MacGregor / Henry Nash
 *
 * Notes        : The earlier versions of this module could run on an ADM 3E,
 *                a dumb ANSI standard terminal, in debug mode  or in a Sun
 *                Window. In the interests of sanity and as the versions other
 *                than the Sun were not fully developed, they were removed. if
 *                interested in the workings of these implementations they are
 *                available in the SCCS file before version 2.36.
 *
 *                The supported functions are:
 *
 *                      cga_init             Initialise the subsystem
 *                      cga_term             Terminate the subsystem
 *                      cga_inb              I/P a byte from the MC6845 chip
 *                      cga_outb             O/P a byte to the MC6845 chip
 *
 * In the new EGA world, we use screen start instead of screen base.
 * This is also a WORD address if the adapter is in text mode.
 * (Thats how the EGA works!)
 * So we don't have to double it now. Ho Hum.
 *
 * Mods: (r2.71): In the real 6845 chip, the pointer which addresses the
 *                base of the screen is a WORD ptr. We've just discovered
 *                this; all usage of the variable 'screen_base' assumes
 *                that it is a BYTE ptr. Hence in cga_outb() we now
 *                double the value in screen_base when it is set.
 *
 *       (r3.2) : (SCR 258). cur_offset now declared as static.
 *
 *       (r3.3) : (SCR 257). Set timer_video_enabled when the bit in
 *                the M6845 mode register which controls the video
 *                display is changed. Also neatened the indentation
 *                for outb().
 *
 */

/*
 * static char SccsID[]="@(#)cga.c	1.36 05/05/95 Copyright Insignia Solutions Ltd.";
 */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_CGA.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include <malloc.h>
#include TypesH
#include StringH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "timeval.h"
#include "timer.h"
#include CpuH
#include "ios.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "gvi.h"
#include "sas.h"
#include "cga.h"
#include "error.h"
#include "config.h"
#include "host.h"
#include "trace.h"
#include "debug.h"
#include "cpu_vid.h"
#ifdef  EGG
#include "egacpu.h"
#endif  /* EGG */
#include "video.h"
#include "ckmalloc.h"

#ifdef REAL_VGA
#include "avm361.h"
#else
#include "host_gfx.h"
#endif


/*
 *============================================================================
 *              Local Defines, Macros & Declarations
 *============================================================================
 */

#define CURSOR_NON_DISPLAY_BIT  (1 << 5)
				/* Bit in Cursor Start Register which
				   makes the cursor invisible */
#define CURSOR_USED_BITS        0x1f
				/* Mask to clear out unused bits */

static int current_mode = -1;   /* Value of Mode Select at last call    */

/*
 * MC6845 Registers
 */

#ifdef HUNTER
half_word MC6845[MC6845_REGS];  /* The current values of the MC6845 registers */
half_word mode_reg;             /* The value of the mode control register */
#endif

static half_word index_reg = 00 ;       /* Index register        */

/*
 * 6845 Register variables
 */
static half_word R0_horizontal_total;
static half_word R1_horizontal_displayed = 80;
static half_word R2_horizontal_sync_pos;
static half_word R3_horizontal_sync_width;
static half_word R4_vertical_total;
static half_word R5_vertical_total_adjust;
static half_word R6_vertical_displayed   = 25;
static half_word R7_vertical_sync;
static half_word R9_max_scan_line_addr   = 7;
static half_word R8_interlace;
static half_word Ra_cursor_start = 0;
static half_word Rb_cursor_end = 0;
static half_word Re_cursor_loc_high = 0;
static half_word Rf_cursor_loc_low = 0;

/*
 * global variables peculiar to the cga
 */

CGA_GLOBS       CGA_GLOBALS;

GLOBAL VOID (*bios_ch2_byte_wrt_fn)();
GLOBAL VOID (*bios_ch2_word_wrt_fn)();

GLOBAL IU8 *cga_screen_buf = 0;

/*
 * Globals used in various functions to synchronise the display
 */

int cursor_over_screen = FALSE; /* When set to TRUE the cursor is over the    */
				/* screen areas and the cursor should flash   */

/*
 * Static forward declarations.
 */

static void set_cga_palette     IPT2(int, screen_mode, int, res);
static void update_cursor_shape IPT0();


#ifdef A3CPU
IMPORT WRT_POINTERS Glue_writes;
#else
IMPORT MEM_HANDLERS Glue_writes;
#endif /* A3CPU */
IMPORT WRT_POINTERS simple_writes;
IMPORT READ_POINTERS Glue_reads;
IMPORT READ_POINTERS read_glue_ptrs;
IMPORT READ_POINTERS simple_reads;

#ifdef  A2CPU
LOCAL ULONG dummy_read IFN1(ULONG, offset)
{
	UNUSED(offset);
	return 0;
}

LOCAL void dummy_str_read IFN3(UTINY *, dest, ULONG, offset, ULONG, count)
{
	UNUSED(dest);
	UNUSED(offset);
	UNUSED(count);
}

LOCAL READ_POINTERS     dummy_reads =
{
	dummy_read,
	dummy_read
#ifndef NO_STRING_OPERATIONS
	,
	dummy_str_read
#endif  /* NO_STRING_OPERATIONS */
};
#endif  /* A2CPU */

/*
 *==========================================================================
 *      Global Functions
 *==========================================================================
 */

/*
 ********** Functions that operate on the I/O Address Space ********************
 */

/*
 * Global variables
 */

half_word bg_col_mask = 0x70;
reg regen_start;                /* Regen start address                   */

void cga_inb    IFN2(io_addr, address, half_word *, value)
{

#ifndef NEC_98
static int cga_state = 0;       /* current cga status state */
static long state_count = 1;    /* position in that state */
static int sub_state = 0;       /* sub state for cga state 2 */
static unsigned long gmfudge = 17; /* Random number seed for pseudo-random
				      bitstream generator to give the state
				      lengths below that 'genuine' hardware
				      feel to progs that require it! */
register unsigned long h;

/*
 * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
 */
static int s_lengths[] = { 8, 18, 8, 6 };

/*
 * Read from MC6845 Register
 */

if ( address == 0x3DA ) {

    /*
     * Status register, simulated adapter has
     *
     *  bit                     setting
     *  ---                     -------
     *  Display enable             1/0 Toggling each inb
     *  Light Pen                  0
     *  Light Pen                  0
     *  Vertical Sync              1/0 Toggling each inb
     *  4-7 Unused                 0,0,0,0
     *
     * The upper nibble of the byte is always set.
     * Some programs synchronise with the display by waiting for the
     * next vertical retrace.
     *
     * We attempt to follow the following waveform
     *
     *    --                                                     ----------
     * VS  |_____________________________________________________|        |____
     *
     *
     *    -------------  -   -                           ------------------
     * DE             |__||__||__ ... about 180         _|
     *
     *State|--- 0 ----|-------------- 1 -----------------|-- 3 --|-- 4 --|
     *
     * We do this with a 4 state machine. Each state has a count associated
     * with it to represent the relative time spent in each state. When this
     * count is exhausted the machine moves into the next state. One Inb
     * equals 1 count. The states are as follows:
     *     0: VS low, DE high.
     *     1: VS low, DE toggles. This works via an internal state.
     *     3: VS low, DE high.
     *     4: VS high,DE high.
     *
     */

    state_count --;                     /* attempt relative 'timings' */
    switch (cga_state) {

    case 0:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[1] + (gmfudge & 3);
	    cga_state = 1;
	}
	*value = 0xf1;
	break;

    case 1:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[2] + (gmfudge & 3);
	    cga_state = 2;
	    sub_state = 2;
	}
	switch (sub_state) {            /* cycle through 0,0,1 sequence */
	case 0:                         /* to represent DE toggling */
	    *value = 0xf0;
	    sub_state = 1;
	    break;
	case 1:
	    *value = 0xf0;
	    sub_state = 2;
	    break;
	case 2:
	    *value = 0xf1;
	    sub_state = 0;
	    break;
	}
	break;

    case 2:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[3] + (gmfudge & 3);
	    cga_state = 3;
	}
	*value = 0xf1;
	break;

    case 3:
	if (state_count == 0) {         /* wrap back to first state */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[0] + (gmfudge & 3);
	    cga_state = 0;
	}
	*value = 0xf9;
	break;
    }
}
else if ( (address & 0xFFF9) == 0x3D1)
	{

	    /*
	     * Internal data register, the only supported internal
	     * registers are E and F the cursor address registers.
	     */

	    switch (index_reg) {

	    case 0xE:
		*value = (get_cur_y() * get_chars_per_line() + get_cur_x() ) >> 8;
		break;
	    case 0xF:
		*value = (get_cur_y() * get_chars_per_line() + get_cur_x()) & 0xff;
		break;
	    case 0x10: case 0x11:
		*value = 0;
		break;
	    default:
		note_trace1(CGA_VERBOSE,
			    "Read from unsupported MC6845 internal reg %x",
			    index_reg);
	    }
	}
else
	/*
	 * Read from a write only register
	 */

	*value = 0x00;
#endif   //NEC_98
}


void cga_outb   IFN2(io_addr, address, half_word, value)
{

/*
 * Output to a 6845 register
 */

word      cur_offset;                   /* The cursor position registers */
static half_word last_mode  = -1;
static half_word last_screen_length  = 25;
static half_word video_mode;
/*
 * Variable used to see if text character height has changed, so that
 * unnecessary calls to host_change_mode can be avoided.
 */
static half_word last_max_scan_line = 7;

/*
 * Masks for testing the input byte. The MODE_MASK hides the (unsupported)
 * blink bit and the video enable bit to ascertain whether any mode specific
 * variables need to be changed. The BLINK_MASK hides the blink bit for storing
 * the current_mode between changes.
 */

#define RESET           0x00
#define ALPHA_80x25     0x01
#define GRAPH           0x02
#define BW_ENABLE       0x04
#define GRAPH_640x200   0x10
#define MODE_MASK       0x17
#define BLINK_MASK      0x1F
#define COLOR_MASK      0x3F

    note_trace2(CGA_VERBOSE, "cga_outb: port %x value %x", address, value);

switch (address) {
    case 0x3D0:
    case 0x3D2:
    case 0x3D4:
    case 0x3D6:

	/*
	 * Index Register
	 */
	index_reg = value;
	break;

    case 0x3D1:
    case 0x3D3:
    case 0x3D5:
    case 0x3D7:
#ifdef HUNTER
	MC6845[index_reg] = value;
#endif

/*
 * This is the data register, the function to be performed depends on the
 * value in the index register
 *
 * The various registers affect the position and size of the screen and the
 * image on it. The screen can be logically divided into two halves: the
 * displayed text and the rest which is the border. The border colour can
 * be changed by programming the 3D9 register.
 * NB. Currently SoftPC does not obey positioning & display sizing
 * information - the display remains constant.
 * The first 8 registers (R0-R7) affect the size & position of the display;
 * their effects are as follows:
 * R0 - R3 control the horizontal display aspects & R4 - R7 the vertical.
 *
 * The diagram below attempts to show how each is related to the screen
 * size & shape.
 *
 *    (Shaded Area - border)
 *   ________________________________________________________ <-------------
 *   |......................................................|  |  | R5  |
 *   |..|-----------------------------------------------|...|  | <----  |
 *   |..|                                               |...|  |     |  |
 *   |..|c>                                             |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  R     R  R
 *   |..|                                               |...|  4     6  7
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|_______________________________________________|...|  | <-------
 *   |......................................................|  |
 *   -------------------------------------------------------- <------------
 *   ^                                                      ^
 *   |-----------------------R0-----------------------------|
 *   |  ^                                                   |
 *   |R3|                                                   |
 *   |  |                                                ^  |
 *   |  |--------------------R1--------------------------|
 *   |                                                   |
 *   |-----------------------R2--------------------------|
 *
 *   The reason for having 4 registers to handle the full range of values
 *   is because they are actually used to control the horizontal & vertical
 *   traces on the screen hence:
 *        R0 - total time of scan
 *        R1 - active display - scan on
 *        R2 - time sync for scan off/on/off
 *        R3 - time to scan on
 *
 *               R1
 *      -------------------------------------------------
 *      |                                               |
 *      |                                               |
 *   R3 |                                               |
 *   ----                                               ---
 *   <---------------------R2-------------------------->
 *   <---------------------R0----------------------------->
 *
 *  The veritcal registers organise an analagous trace. The two traces are
 *  synchronised by Register 8.
 *
 *  This is why altering these values on the PC will move the display or
 *  more likely cause garbaging of the image!
 */

	switch ( index_reg ) {
	    case 0x00:
		/*
		 * total horizontal display (inc border)
		 */
		R0_horizontal_total = value;
		break;

	    case 0x01:
		/*
		 * Specify the number of characters per row
		 */
		if (value > 80) {
		    always_trace1("cga_outb: trying to set width %d", value);
		    value = 80;
		}
		R1_horizontal_displayed = value;
		set_horiz_total(value);
		break;

	    case 0x02:
		/*
		 * Right hand edge of displayed text
		 * affect left_border(?), right_border(?)
		 */
		R2_horizontal_sync_pos = value;
		break;

	    case 0x03:
		/*
		 * Left hand edge of displayed text
		 * affect left_border, right_border
		 */
		R3_horizontal_sync_width = value;
		break;

	    case 0x04:
		/*
		 * total vertical display (inc border)
		 */
		R4_vertical_total = value;
		break;

	    case 0x05:
		/*
		 * Top edge of displayed text
		 * affect top_border, bottom_border
		 */
		R5_vertical_total_adjust = value;
		break;

	    case 0x06:
		/*
		 * If the screen length is 0, this effectively means
		 * don't display anything.
		 */
		if(value == 0)
		{
		    host_clear_screen();
		    set_display_disabled(TRUE);
		    last_screen_length = 0;
		}
		else
		{
		    /*
		     * Specify the screen length - in our
		     * implementation used only in text mode.
		     * affect top_border, bottom_border
		     */
		    R6_vertical_displayed = value;
		    set_screen_length( R1_horizontal_displayed * R6_vertical_displayed * 2 );
		}
		/*
		 * check if we are resetting the screen to
		 * display again
		 */
		if((value != 0) && (last_screen_length == 0))
		{
		    set_display_disabled(FALSE);
		    host_flush_screen();
		    last_screen_length = value;
		}


		break;

	    case 0x07:
		/*
		 * bottom of displayed text
		 * affect top_border(?), bottom_border(?)
		 */
		R7_vertical_sync = value;
		break;

	    case 0x08:
		/*
		 * interlace of traces - hold constant
		 */
		R8_interlace = 2;
		break;

	    case 0x09:
		/*
		 * Specify the character height - in our
		 * implementation used only in text mode.
		 * The actual number of pixels is one
		 * more than this value.
		 */
		R9_max_scan_line_addr = value;
		set_char_height_recal(R9_max_scan_line_addr + 1);
		set_screen_height_recal( R6_vertical_displayed*(R9_max_scan_line_addr+1) - 1);
		flag_mode_change_required();
		screen_refresh_required();
		break;

	    /*
	     * A defines the cursor start scan line
	     * B defines the cursor stop scan line
	     */
	    case 0x0A:
		/* bypass redundant updates */
		if (Ra_cursor_start != value)
		{
		    Ra_cursor_start = value;
#ifdef REAL_VGA
		    CRTC_REG(0xa, value);
#endif
		    update_cursor_shape();
		}
		break;
	    case 0x0B:
		/* bypass redundant updates */
		if (Rb_cursor_end != (value & CURSOR_USED_BITS))
		{
		    Rb_cursor_end = (value & CURSOR_USED_BITS);
#ifdef REAL_VGA
		    CRTC_REG(0xb, value);
#endif
		    update_cursor_shape();
		}
		break;

	    /*
	     * C & D define the start of the regen buffer
	     */
	    case 0x0C:
		/*
		 * High byte
		 */
		if (value != regen_start.byte.high)
		{
			regen_start.byte.high = value;
			host_screen_address_changed(regen_start.byte.high,
							regen_start.byte.low);
			set_screen_start(regen_start.X  % (short)(CGA_REGEN_LENGTH/2) );
			screen_refresh_required();
		}
#ifdef REAL_VGA
		CRTC_REG(0xc, value);
#endif
		break;

	    case 0x0D:
		/*
		 * low byte
		 */
		if (value != regen_start.byte.low)
		{
			regen_start.byte.low = value;
			host_screen_address_changed(regen_start.byte.high,
							regen_start.byte.low);
			set_screen_start(regen_start.X  % (short)(CGA_REGEN_LENGTH/2));
			screen_refresh_required();
		}
#ifdef REAL_VGA
		CRTC_REG(0xd, value);
#endif
		break;

	    /*
	     * E and F define the cursor coordinates in characters
	     */
	    case 0x0E:
		/*
		 * High byte
		 */
		if (Re_cursor_loc_high != value)
		{
		    Re_cursor_loc_high = value;

		    if(get_cga_mode() == TEXT)
			host_cga_cursor_has_moved(get_cur_x(), get_cur_y());
		    cur_offset = (value << 8) | Rf_cursor_loc_low;
		    cur_offset -= (word) get_screen_start();
		    set_cur_y( cur_offset / get_chars_per_line() );
		    set_cur_x( cur_offset % get_chars_per_line() );

		}
		break;

	    case 0x0F:
		/*
		 * low byte
		 */
		if (Rf_cursor_loc_low != value)
		{
		    Rf_cursor_loc_low = value;

		    if(get_cga_mode() == TEXT)
			host_cga_cursor_has_moved(get_cur_x(), get_cur_y());
		    cur_offset =  (Re_cursor_loc_high << 8) | value;
		    cur_offset -= (word) get_screen_start();
		    set_cur_y( cur_offset / get_chars_per_line());
		    set_cur_x( cur_offset % get_chars_per_line());

		}
		break;

	    default:
		note_trace2(CGA_VERBOSE, "Unsupported 6845 reg %x=%x(write)",
			    index_reg, value);
	}
	break;

    case 0x3D8:
	/*
	 * Mode control register.  The first
	 * six bits are encoded as follows:
	 *
	 * BIT      Function            Status
	 * ---       --------            ------
	 *  0      A/N 80x25 mode        Supported
	 *  1      Graphics Select        Supported
	 *  2      B/W Select            Supported
	 *  3      Enable Video            Supported
	 *  4      640x200 B/W mode        Supported
	 *  5      Change B/G intensity to blink Not Supported
	 *  6,7      Unused
	 */

#ifdef HUNTER
	mode_reg = value;
#endif
	timer_video_enabled = (boolean) (value & VIDEO_ENABLE);

	if (value != current_mode) {

	    if (value == RESET)
		set_display_disabled(TRUE);     /* Chip reset - do nothing */
	    else {
		/*
		 * Take note whether color or B/W
		 */

		set_cga_color_select( !(value & BW_ENABLE) );

		/*
		 * Set up for graphics or text
		 */
		if (value & GRAPH) {
		    set_chars_per_line(R1_horizontal_displayed<<1);
		    set_cursor_visible(FALSE);
		    set_cga_mode(GRAPHICS);
		    host_set_border_colour(0);
		    set_word_addressing(FALSE); /* bytes per line = chars per line */
		    set_cga_resolution( (value & GRAPH_640x200 ? HIGH : MEDIUM) );
		    if (get_cga_resolution() == HIGH) {
			video_mode = 6;
			set_pix_width(1);
		    }
		    else {
			video_mode = (get_cga_color_select() ? 4 : 5);
			set_pix_width(2);
		    }
		    if (video_mode != last_mode)
		    {
			host_change_mode();
			set_cga_palette(get_cga_mode(),get_cga_resolution());
		    }
		}
		else {    /* Text, presumably */
		    set_chars_per_line(R1_horizontal_displayed);
		    set_cga_mode(TEXT);
		    set_cursor_visible(TRUE);
		    set_word_addressing_recal(TRUE);    /* so that bytes per line is twice chars per line */

		    if (value & 0x20)
			/* blinking - not supported */
			bg_col_mask = 0x70;
		    else
			/* using blink bit to provide 16 background colours */
			bg_col_mask = 0xf0;

		    if (value & ALPHA_80x25)
		    {
			video_mode = (get_cga_color_select() ? 3 : 2);
			set_pix_width(1);
			set_pix_char_width(8);
		    }
		    else
		    {
			video_mode = (get_cga_color_select() ? 1 : 0);
			set_pix_width(2);
			set_pix_char_width(16);
		    }


/*
 * Avoid mode changes with disabled screen.
 *
 * Text mode changes are also needed if the character height changes.  The
 * character height is set here rather than when that register is set.  This
 * avoids unnecessary mode changes, as the character height is set before we
 * know if a graphics or text mode is to be entered.
 */
		if ( (value & VIDEO_ENABLE) && ((video_mode != last_mode) ||
		     (last_max_scan_line != R9_max_scan_line_addr)))
		    {
			last_max_scan_line = R9_max_scan_line_addr;
			host_change_mode();        /* redo fonts etc */
			set_cga_palette(get_cga_mode(),get_cga_resolution());
		    }
		}
		set_bytes_per_line(R1_horizontal_displayed<<1);
		set_offset_per_line(get_bytes_per_line());

		if (video_mode != last_mode) {
		    if (value & VIDEO_ENABLE) {
			set_display_disabled(FALSE);
			screen_refresh_required();
			last_mode = video_mode; /* Do this here so when screen display is re-enabled we do 'pending' mode change */
		    }
		    else
			set_display_disabled(TRUE);
		}
		else if ((value & VIDEO_ENABLE)
		  != (current_mode & VIDEO_ENABLE)) {
		    if (value & VIDEO_ENABLE) {
			set_display_disabled(FALSE);
			host_flush_screen();
		    }
		    else
			set_display_disabled(TRUE);
		}
	    }

	}

	current_mode = value;
	break;

    case 0x3D9:
	/*
	 * The Color Select Register. Just save this into a
	 * variable so the machine-specific graphics s/w can
	 * see it, then call a host specific routine to act on it.
	 */

	if ((value & COLOR_MASK) != get_cga_colormask() ) {
	    set_cga_colormask(value & COLOR_MASK);
	    set_cga_palette(get_cga_mode(),get_cga_resolution());
	}
	break;

    default:
	/*
	 * Write to an unsupported 6845 internal register
	 */

	note_trace2(CGA_VERBOSE, "Write to unsupported 6845 reg %x=%x",
			 address,value);
	break;

    }
}


/*
 * Set up the host palette & border for the current CGA screen mode and resolution
 */

static void set_cga_palette     IFN2(int, screen_mode, int, res)
{
#ifndef NEC_98
    /*
     * palette for color text - 16 colors for FG and BG
     * These tables are also used to set some graphic mode palette entries
     * since they represent a 'standard' set of colors.
     */

    static PC_palette cga_text_palette[] =
    {
	0x00, 0x00, 0x00,               /* Black        */
	0x22, 0x22, 0xBB,               /* Blue         */
	0x00, 0xAA, 0x00,               /* Green        */
	0x00, 0xAA, 0xAA,               /* Cyan         */
	0xAA, 0x00, 0x00,               /* Red          */
	0xAA, 0x00, 0xAA,               /* Magenta      */
	0xAA, 0x88, 0x00,               /* Brown        */
	0xCC, 0xCC, 0xCC,               /* White        */
	0x55, 0x55, 0x55,               /* Grey         */
	0x22, 0x22, 0xEE,               /* Light Blue   */
	0x00, 0xEE, 0x00,               /* Light Green  */
	0x00, 0xEE, 0xEE,               /* Light Cyan   */
	0xEE, 0x00, 0x00,               /* Light Red    */
	0xEE, 0x00, 0xEE,               /* Light Magenta*/
	0xEE, 0xEE, 0x00,               /* Yellow       */
	0xFF, 0xFF, 0xFF                /* Bright White */
    };


    /*
     * NOTE: The medium resolution graphics colors below have their first
     *       and second indices reversed, due to a "feature" in the supplied
     *       graphics system library routines. We are trying to persuade IBM
     *       to change the spec of the CGA accordingly.
     */


    /*
     * Medium resolution graphics, color set 1 (Green, Red, Brown)
     */

    static PC_palette cga_graph_m1l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0x00,               /* Green                */
	0xAA, 0x00, 0x00,               /* Red                  */
	0xAA, 0x88, 0x00                /* Brown                */
    };

    /*
     * As above but with high intensity bit on
     */

    static PC_palette cga_graph_m1h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0x00,               /* Green (alt Red)      */
	0xEE, 0x00, 0x00,               /* Red (alt Green)      */
	0xEE, 0xEE, 0x00                /* Yellow               */
    };

    /*
     * Medium resolution graphics, color set 2 (Cyan, Magenta, White)
     */

    static PC_palette cga_graph_m2l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0xAA,               /* Magenta (alt Cyan)   */
	0xAA, 0x00, 0xAA,               /* Cyan (alt Magenta)   */
	0xCC, 0xCC, 0xCC                /* White                */
    };


    /*
     * As above but with high intensity bit on
     */

    static PC_palette cga_graph_m2h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0xEE,               /* Magenta (alt Cyan)   */
	0xEE, 0x00, 0xEE,               /* Cyan (alt Magenta)   */
	0xFF, 0xFF, 0xFF                /* White                */
    };

    /*
     * Medium resolution graphics, color set 3 (Cyan, Red, White)
     * This is what you get when the "Black & White" bit is on!!!
     */

    static PC_palette cga_graph_m3l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0xAA,               /* Cyan (alt Red)       */
	0xAA, 0x00, 0x00,               /* Red (alt Cyan)       */
	0xCC, 0xCC, 0xCC                /* White                */
    };

    /*
     * As above but with high intensity on
     */

    static PC_palette cga_graph_m3h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0xEE,               /* Cyan (alt Red)       */
	0xEE, 0x00, 0x00,               /* Red (alt Cyan)       */
	0xFF, 0xFF, 0xFF                /* White                */
    };


    /*
     * High resolution graphics
     */

    static PC_palette cga_graph_high[] =
    {
	0x00, 0x00, 0x00,               /* Black                */
	0x00, 0x00, 0x00                /* Set dynamically      */
    };


    /*
     * Local variables
     */

    PC_palette *cga_graph_med;
    int ind;

    /*
     * If the mode is TEXT use cga_text_palette
     */

    if (screen_mode == TEXT)
    {
	host_set_palette(cga_text_palette, 16);
	host_set_border_colour(get_cga_colormask() &0xf);
    }

    else        /* Mode must be GRAPHICS */
    if (res == MEDIUM)
    {
	/*
	 * Select the appropriate slot array, then fill in the background.
	 *
	 * Note:  1) On a CGA driving an IBM Color Monitor, the intensity
	 *           of these three colors (but NOT the background color)
	 *           is affected by bit 4 of the Color Register.
	 *
	 *        2) The documentation says that bit 5 of the Color
	 *           register selects one of two color sets. On a CGA
	 *           driving an IBM Color Monitor, this is true UNLESS
	 *           the B/W Enable bit in the Mode Set register is on,
	 *           in which case you get a third set unaffected by
	 *           bit 5 of the Color Register.
	 */

	if (!get_cga_color_select() )                           /* Set 3 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m3h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m3l;
	else
	if (get_cga_colormask() & 0x20)                 /* Set 2 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m2h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m2l;
	else                                    /* Set 1 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m1h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m1l;

	/*
	 * Load the background color from the TEXT palette
	 */

	ind = get_cga_colormask() & 15;         /* Lower 4 bits select color */
	cga_graph_med->red   = cga_text_palette[ind].red;
	cga_graph_med->green = cga_text_palette[ind].green;
	cga_graph_med->blue  = cga_text_palette[ind].blue;

	/*
	 * Load it
	 */
	host_set_palette(cga_graph_med,4);

    }
    else        /* Must be high resolution graphics */
    {
	/*
	 * The background is BLACK, and the foreground is selected
	 * from the lower 4 bits of the Color Register
	 */

	ind = (get_cga_colormask() & 15);
	cga_graph_high[1].red   = cga_text_palette[ind].red;
	cga_graph_high[1].green = cga_text_palette[ind].green;
	cga_graph_high[1].blue  = cga_text_palette[ind].blue;

	host_set_palette(cga_graph_high,2);
    }
#endif   //NEC_98
}

static void update_cursor_shape IFN0()
{
#ifndef NEC_98
	/*
	 *      This function actions a change to the cursor shape
	 *      when either the cursor start or cursor end registers
	 *      are updated with DIFFERENT values.
	 */
	half_word temp_start;


	set_cursor_height1(0);
	set_cursor_start1(0);

	if ( (Ra_cursor_start & CURSOR_NON_DISPLAY_BIT)
	    || ( Ra_cursor_start > CGA_CURS_START)) {
	    /*
	     * Either of these conditions causes the
	     * cursor to disappear on the real PC
	     */
	    set_cursor_height(0);
	    set_cursor_visible(FALSE);
	}
	else {
	    temp_start = Ra_cursor_start & CURSOR_USED_BITS;
	    set_cursor_visible(TRUE);
	    if (Rb_cursor_end > CGA_CURS_START) {  /* block */
		set_cursor_height(CGA_CURS_START);
		set_cursor_start(0);
	    }
	    else if (temp_start <= Rb_cursor_end) {     /* 'normal' */
		set_cursor_start(temp_start);
		set_cursor_height(Rb_cursor_end - temp_start + 1);
	    }
	    else {      /* wrap */
		set_cursor_start(0);
		set_cursor_height(Rb_cursor_end);
		set_cursor_start1(temp_start);
		set_cursor_height1(get_char_height() - temp_start);
	    }
	}
	base_cursor_shape_changed();


	host_cursor_size_changed(Ra_cursor_start, Rb_cursor_end);

#endif   //NEC_98
}

#if !defined(EGG) && !defined(A3CPU) && !defined(A2CPU) && !defined(C_VID) && !defined(A_VID)

/*
	The following functions are MEM_HANDLER functions for the CGA-only
	build with no C_VID (no a common build). They are unused for most
	variants of SoftPC.
*/

#define INTEL_SRC       0
#define HOST_SRC        1

/*
======================== cga_only_simple_handler =========================
PURPOSE:        This function provides a stub for the unused MEM_HANDLER
		functions. This function probably shouldn't be called hence
		the trace statement.
INPUT:          None.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_simple_handler IFN0()
{
#ifndef NEC_98
	always_trace0("cga_only_simple_handler called");
	setVideodirty_total(getVideodirty_total() + 1);
#endif   //NEC_98
}

/*
=========================== cga_only_b_write =============================
PURPOSE:        Byte write function. Puts the value at the given address
		and increments dirty_flag.
INPUT:          Address (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_b_write IFN2(UTINY *, addr, ULONG, val)
{
#ifndef NEC_98
	host_addr       ptr;
	ULONG           offs;
	
	offs = (ULONG) (addr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	*ptr = val & 0xff;
	setVideodirty_total(getVideodirty_total() + 1);
#endif   //NEC_98
}

/*
=========================== cga_only_w_write =============================
PURPOSE:        Word write function. Puts the value at the given address
		and increments dirty_flag.
INPUT:          Address (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_w_write IFN2(UTINY *, addr, ULONG, val)
{
#ifndef NEC_98
	host_addr       ptr;
	ULONG           offs;
	
	offs = (ULONG) (addr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	*ptr++ = val & 0xff;
	*ptr = (val >> 8) & 0xff;
	setVideodirty_total(getVideodirty_total() + 2);
#endif   //NEC_98
}

/*
=========================== cga_only_b_fill ==============================
PURPOSE:        Byte fill function. Fills the given address range with the
		value and increments dirty_flag.
INPUT:          Address range (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_b_fill IFN3(UTINY *, laddr, UTINY *, haddr, ULONG, val )
{
#ifndef NEC_98
	host_addr       ptr;
	IS32            len;
	ULONG           offs;
		
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	for (len = (haddr - laddr); len > 0; len--)
		*ptr++ = val;
#endif   //NEC_98
}

/*
=========================== cga_only_w_fill ==============================
PURPOSE:        Word fill function. Fills the given address range with the
		value and increments dirty_flag.
INPUT:          Address range (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_w_fill IFN3(UTINY *, laddr, UTINY *, haddr, ULONG, val )
{
#ifndef NEC_98
	host_addr       ptr;
	IS32            len;
	IU8             lo;
	IU8             hi;
	ULONG           offs;
	
	lo = val & 0xff;
	hi = (val >> 8) & 0xff;
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	for (len = (haddr - laddr) >> 1; len > 0; len--)
	{
		*ptr++ = lo;
		*ptr++ = hi;
	}
#endif   //NEC_98
}

LOCAL void cga_only_b_move IFN4(UTINY *, laddr, UTINY *, haddr, UTINY *, src,
	UTINY, src_type)
{
#ifndef NEC_98
	host_addr       src_ptr;
	host_addr       dst_ptr;
	IS32            len;
	ULONG           offs;
	BOOL            move_bwds = getDF();
	
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	dst_ptr = get_screen_ptr(offs);
	len = haddr - laddr;
	if ((src_type == HOST_SRC) || (src < (UTINY *)gvi_pc_low_regen) ||
		((UTINY *)gvi_pc_high_regen < src))
	{
		/* Ram source */
		if (src_type == INTEL_SRC)
			src_ptr = get_byte_addr(src);
		else
			src_ptr = src;
		
		/* Ram to video move - video is always forwards, ram
		** depends on BACK_M.
		*/
		if (move_bwds)
		{
			dst_ptr += len;
#ifdef  BACK_M
			src_ptr -= len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(++src_ptr);
#else
			src_ptr += len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(--src_ptr);
#endif  /* BACK_M */
		}
		else
		{
#ifdef  BACK_M
			for ( ; len > 0; len--)
				*dst_ptr++ = *src_ptr--;
#else
			memcpy(dst_ptr, src_ptr, len);
#endif  /* BACK_M */
		}
	}
	else
	{
		/* Video source */
		offs = (ULONG) (src - gvi_pc_low_regen);
		src_ptr = get_screen_ptr(offs);
		
		/* Video to video move - both sets of memory are always
		** forwards.
		*/
		if (move_bwds)
		{
			dst_ptr += len;
			src_ptr += len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(--src_ptr);
		}
		else
			memcpy(dst_ptr, src_ptr, len);
	}
#endif   //NEC_98
}

LOCAL MEM_HANDLERS cga_only_handlers =
{
	cga_only_b_write,
	cga_only_w_write,
	cga_only_b_fill,
	cga_only_w_fill,
	cga_only_b_move,
	cga_only_simple_handler         /* word move - not used? */
};

#endif /* not EGG or A3CPU or A2CPU or C_VID or A_VID */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void cga_init()
{
#ifndef NEC_98
IMPORT void Glue_set_vid_rd_ptrs IPT1(READ_POINTERS *, handler );
IMPORT void Glue_set_vid_wrt_ptrs IPT1(WRT_POINTERS *, handler );

io_addr i;

#ifdef HUNTER
for (i = 0; i < MC6845_REGS; i++)
    MC6845[i] = 0;
#endif


/*
 * Set up the IO chip select logic for this adaptor
 */

io_define_inb(CGA_ADAPTOR, cga_inb);
io_define_outb(CGA_ADAPTOR, cga_outb);

for(i = CGA_PORT_START; i <= CGA_PORT_END; i++)
    io_connect_port(i, CGA_ADAPTOR, IO_READ_WRITE);

/*
 * Initialise the adapter, assume Alpha numeric 80x25 as start up state
 * with active page of zero & default cursor
 */

	gvi_pc_low_regen  = CGA_REGEN_START;
	gvi_pc_high_regen = CGA_REGEN_END;
	set_cursor_start(8-CGA_CURS_HEIGHT);
	set_cursor_height(CGA_CURS_HEIGHT);
	set_cga_color_select(FALSE);            /* B/W at switch-on */
	set_cga_colormask(0);                   /* Will be set by BIOS */

#ifndef GISP_CPU
/* GISP CPU physically cannot perform read and/or write checks */

#ifdef  JOKER

	/* gmi_define_mem(SAS_VIDEO, &Glue_writes); */
	Glue_set_vid_wrt_ptrs(&simple_writes);
	Glue_set_vid_rd_ptrs(&simple_reads);

#else   /* not JOKER */


#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_wrt_ptrs( &Glue_writes );
	Cpu_set_vid_rd_ptrs( &Glue_reads );
	Glue_set_vid_wrt_ptrs( &simple_writes );
	Glue_set_vid_rd_ptrs( &simple_reads );
#else
	Cpu_set_vid_wrt_ptrs( &simple_writes );
	Cpu_set_vid_rd_ptrs( &simple_reads );
#endif  /* C_VID */
#else   /* not A3CPU */
#ifdef A2CPU
	gmi_define_mem(SAS_VIDEO, &vid_handlers);
	read_pointers = dummy_reads;
#else
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
	gmi_define_mem(SAS_VIDEO, &cga_only_handlers);
#else
	gmi_define_mem(SAS_VIDEO, &Glue_writes);
	read_pointers = Glue_reads;
	Glue_set_vid_wrt_ptrs( &simple_writes );
	Glue_set_vid_rd_ptrs( &simple_reads );
#endif /* not EGG or C_VID or A_VID */
#endif /* A2CPU */
#endif /* A3CPU */

#endif /* JOKER */
#endif /* GISP_CPU */

#ifdef CPU_40_STYLE
	setVideochain(3);
	SetWritePointers();
	SetReadPointers(3);
#endif  /* CPU_40_STYLE */

	sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

	current_mode = -1;                              /* Only used by outb  */

	set_char_height(8);
	set_pc_pix_height(1);
	set_host_pix_height(2);
	set_word_addressing(TRUE);
	set_screen_height(199);
	set_screen_limit(0x4000);
	set_horiz_total(80);                    /* calculate screen params from this val, and prev 2 */
	set_pix_width(1);
	set_pix_char_width(8);

	set_cga_mode(TEXT);
	set_cursor_height(CGA_CURS_HEIGHT);
	set_cursor_start(8-CGA_CURS_HEIGHT);
	set_screen_start(0);

	check_malloc(cga_screen_buf, CGA_REGEN_LENGTH, IU8);
	set_screen_ptr(cga_screen_buf);
	setVideoscreen_ptr(get_screen_ptr(0));

	sas_fillsw(CGA_REGEN_START, (7 << 8)| ' ', CGA_REGEN_LENGTH >> 1);
						/* Fill with blanks      */

	bios_ch2_byte_wrt_fn = simple_bios_byte_wrt;
	bios_ch2_word_wrt_fn = simple_bios_word_wrt;
#endif   //NEC_98
}

void cga_term   IFN0()
{
#ifndef NEC_98
    io_addr i;

    /*
     * Disconnect the IO chip select logic for this adapter
     */

    for(i = CGA_PORT_START; i <= CGA_PORT_END; i++)
	io_disconnect_port(i, CGA_ADAPTOR);
    /*
     * Disconnect RAM from the adaptor
     */
    sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

    if (cga_screen_buf != 0)
    {
	host_free(cga_screen_buf);
	cga_screen_buf = 0;
    }
#endif   //NEC_98
}


#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)

GLOBAL CGA_ONLY_GLOBS *VGLOBS = NULL;
LOCAL CGA_ONLY_GLOBS CgaOnlyGlobs;
/*(
============================ setup_vga_globals =============================
PURPOSE:        This function is provided for CGA-only builds to set up a
		dummy VGLOBS structure which avoids the need to ifdef all
		references to VGLOBS->dirty_flag and VGLOBS->screen_ptr.
INPUT:          None.
OUTPUT:         None.
============================================================================
)*/
GLOBAL void setup_vga_globals IFN0()
{
#ifndef NEC_98
#ifndef CPU_40_STYLE    /* Evid interface */
	VGLOBS = &CgaOnlyGlobs;
#endif
#endif   //NEC_98
}
#endif  /* not EGG or C_VID or A_VID */
#endif  /* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\egawrtm0.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		: P. Jadeja

REVISION HISTORY	:
First version		: P. Jadeja, SoftPC 2.0, 10-Aug-88
Second version		: John Shanly, SoftPC 3.0, 9 April 1991

SUBMODULE NAME		: write mode 0

SOURCE FILE NAME	: ega_write_mode0.c

PURPOSE			: purpose of this submodule

SccsID = "@(#)ega_wrtm0.c	1.31 11/01/94 Copyright Insignia Solutions Ltd."
		

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : xxx.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	ega_mode0_chn_b_write();
			ega_mode0_chn_w_write();
			ega_mode0_chn_b_fill();
			ega_mode0_chn_w_fill();
			ega_mode0_chn_b_move();
			ega_mode0_chn_w_move();

			ega_copy_b_write();
			ega_copy_w_write();
			ega_copy_b_fill();
			ega_copy_w_fill();
			ega_copy_b_move();
			ega_copy_w_move();

			ega_copy_all_b_write();
	DATA 	     :	give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() : 	give name, and source module name

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	specify in following procedure descriptions
			how these are accessed (read/modified)

FILES ACCESSED    :	list all files, how they are accessed,
			how file data is interpreted, etc. if relevant
			(else omit)

DEVICES ACCESSED  :	list all devices accessed, special modes used
			(e.g; termio structure). if relevant (else
			omit)

SIGNALS CAUGHT	  :	list any signals caught if relevant (else omit)

SIGNALS ISSUED	  :	list any signals sent if relevant (else omit)


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	  : 	

PURPOSE		  :
		
PARAMETERS	

	name	  : 	describe contents, and legal values
			for output parameters, indicate by "(o/p)"
			at start of description

GLOBALS		  :	describe what exported data objects are
			accessed and how. Likewise for imported
			data objects.

ACCESS		  :	specify if signal or interrupt handler
			if relevant (else omit)

ABNORMAL RETURN	  :	specify if exit() or longjmp() etc.
			can be called if relevant (else omit)

RETURNED VALUE	  : 	meaning of function return values

DESCRIPTION	  : 	describe what (not how) function does

ERROR INDICATIONS :	describe how errors are returned to caller

ERROR RECOVERY	  :	describe how procedure reacts to errors
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */

IMPORT VOID fill_alternate_bytes IPT3( IS8 *, start, IS8 *, end, IS8, value);
IMPORT VOID fill_both_bytes IPT3( IU16, data, IU16 *, dest, ULONG, len );

#ifdef EGG

#include TypesH
#include "xt.h"
#include CpuH
#include "debug.h"
#include "gmi.h"
#include "sas.h"
#include "egacpu.h"
#include "egaports.h"
#include "cpu_vid.h"
#include "gfx_upd.h"
#include "host.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/


/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#ifdef PROD
#include "SOFTPC_EGA.seg"
#else
#include "SOFTPC_EGA_WRITE.seg"
#endif
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

typedef	union {
	unsigned short	as_word;
	struct {
#ifdef	BIGEND
		unsigned char	hi_byte;
		unsigned char	lo_byte;
#else
		unsigned char	lo_byte;
		unsigned char	hi_byte;
#endif
	} as_bytes;
	struct {
		unsigned char	first_byte;
		unsigned char	second_byte;
	} as_array;
} TWO_BYTES;

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

/*
7.INTERMODULE INTERFACE IMPLEMENTATION :
*/

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

#ifdef A_VID
IMPORT VOID	_ch2_copy_byte_write();
IMPORT VOID	_ch2_copy_word_write();
IMPORT VOID	_ch2_copy_byte_fill_glue();
IMPORT VOID	_ch2_copy_word_fill_glue();
IMPORT VOID	_ch2_copy_byte_move_glue();
IMPORT VOID	_ch2_copy_word_move_glue();
IMPORT VOID	_ch2_copy_byte_move_glue_fwd();
IMPORT VOID	_ch2_copy_word_move_glue_fwd();
IMPORT VOID	_ch2_copy_byte_move_glue_bwd();
IMPORT VOID	_ch2_copy_word_move_glue_bwd();

IMPORT VOID	_ch2_mode0_chn_byte_write_glue();
IMPORT VOID	_ch2_mode0_chn_word_write_glue();
IMPORT VOID	_ch2_mode0_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode0_chn_word_fill_glue();
IMPORT VOID	_ch2_mode0_chn_byte_move_glue();
IMPORT VOID	_ch2_mode0_chn_word_move_glue();

WRT_POINTERS mode0_copy_handlers =
{
	_ch2_copy_byte_write,
	_ch2_copy_word_write

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_copy_byte_fill_glue,
	_ch2_copy_word_fill_glue,
	_ch2_copy_byte_move_glue_fwd,
	_ch2_copy_byte_move_glue_bwd,
	_ch2_copy_word_move_glue_fwd,
	_ch2_copy_word_move_glue_bwd

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS mode0_gen_handlers =
{
	_ch2_mode0_chn_byte_write_glue,
	_ch2_mode0_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode0_chn_byte_fill_glue,
	_ch2_mode0_chn_word_fill_glue,
	_ch2_mode0_chn_byte_move_glue,
	_ch2_mode0_chn_byte_move_glue,
	_ch2_mode0_chn_word_move_glue,
	_ch2_mode0_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */

};
#else
VOID  ega_copy_b_write(ULONG, ULONG);
VOID  ega_copy_w_write(ULONG, ULONG);
VOID  ega_copy_b_fill(ULONG, ULONG, ULONG);
VOID  ega_copy_w_fill(ULONG, ULONG, ULONG);
VOID  ega_copy_b_move_fwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_b_move_bwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_w_move_fwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_w_move_bwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
			

VOID  ega_mode0_chn_b_write(ULONG, ULONG);
VOID  ega_mode0_chn_w_write(ULONG, ULONG);
VOID  ega_mode0_chn_b_fill(ULONG, ULONG, ULONG);
VOID  ega_mode0_chn_w_fill(ULONG, ULONG, ULONG);
VOID  ega_mode0_chn_b_move_fwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_b_move_bwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_w_move_fwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_w_move_bwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );


WRT_POINTERS mode0_copy_handlers =
{
      ega_copy_b_write,
      ega_copy_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_copy_b_fill,
      ega_copy_w_fill,
      ega_copy_b_move_fwd,
      ega_copy_b_move_bwd,
      ega_copy_w_move_fwd,
      ega_copy_w_move_bwd,

#endif	/* NO_STRING_OPERATIONS */
};

WRT_POINTERS mode0_gen_handlers =
{
      ega_mode0_chn_b_write,
      ega_mode0_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode0_chn_b_fill,
      ega_mode0_chn_w_fill,
      ega_mode0_chn_b_move_fwd,
      ega_mode0_chn_b_move_bwd,
      ega_mode0_chn_w_move_fwd,
      ega_mode0_chn_w_move_bwd,

#endif	/* NO_STRING_OPERATIONS */
};
#endif /* A_VID */

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/

byte rotate IFN2(byte, value, int, nobits)
{
	/*
	 * Rotate a byte right by nobits. Do this by making a copy of
	 * the byte into the msbyte of the word, and then shifting the
	 * word by the required amount, and then returning the resulting low byte.
	 */

	TWO_BYTES	double_num;

	double_num.as_bytes.lo_byte = double_num.as_bytes.hi_byte = value;
	double_num.as_word >>= nobits;
	return double_num.as_bytes.lo_byte;
}

#ifndef NEC_98
VOID
ega_copy_b_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;
	note_entrance0("ega_copy_b_write");

	(*update_alg.mark_byte)( offset );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	*(IU8 *)(getVideowplane() + offset) = (IU8)value;
}

VOID
ega_copy_w_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;
	UTINY *planes;

	note_entrance0("ega_copy_w_write");

	(*update_alg.mark_word)( offset );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;
	planes = getVideowplane() + offset;

	if( lsb )
	{
		*(planes + 1) = (UTINY)value;
		*(planes + 4) = (UTINY)(value >> 8);
	}
	else
	{
		*planes = (UTINY)value;
		*(planes + 1) = (UTINY)(value >> 8);
	}
}

VOID
ega_copy_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
    ULONG lsb;
    ULONG inc;
    UTINY *planes;

	note_entrance0("ega_copy_b_fill");

	(*update_alg.mark_fill)( offset, offset + count - 1 );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;

    planes = getVideowplane() + offset;

    if( lsb )
    {
		planes += 1;
		inc = 3;
    }
    else
		inc = 1;

	while( count-- )
	{
		*planes = (UTINY) value;
		planes += inc;
		inc ^= 2;
	}
}
#endif  //NEC_98

#ifdef  BIGEND
#define first_half(wd)      (((wd) & 0xff00) >> 8)
#define sec_half(wd)        ((wd) & 0xff)
#else
#define first_half(wd)      ((wd) & 0xff)
#define sec_half(wd)        (((wd) & 0xff00) >> 8)
#endif

#ifndef NEC_98
VOID
ega_copy_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
    ULONG lsb;
    USHORT *planes;

	note_entrance0("ega_copy_w_fill");

#ifdef BIGEND
	value = ((value >> 8) & 0xff) | ((value << 8) & 0xff00);
#endif

    count >>= 1;

	/* the 3rd parameter is needed by GORE */
	(*update_alg.mark_wfill)( offset, offset + count - 1, 0 );

    lsb = offset & 0x1;
    offset = (offset >> 1) << 2;

    planes = (USHORT *) (getVideowplane() + offset);

    if( lsb )
    {
        word swapped = (word)(((value >> 8) & 0xff) | ((value << 8) & 0xff00));

        *((UTINY *) planes + 1) = (UTINY) first_half(value);

        count--;
        planes += 2;

        while( count-- )
        {
            *planes = swapped;
            planes += 2;
        }

        *((UTINY *) planes) = (UTINY) sec_half(value);
    }
    else
    {
        while( count-- )
        {
            *planes = (USHORT)value;
            planes += 2;
        }
    }
}

LOCAL VOID
ega_copy_move IFN6(UTINY *, dst, UTINY *, eas, ULONG, count, ULONG, src_flag,
	ULONG, w, IBOOL, forward )
{
	ULONG lsbeas, lsbdst;
	ULONG easinc, dstinc;
	ULONG easoff, dstoff;
	UTINY *planes;

	note_entrance0("ega_copy_move");

	(*update_alg.mark_string)( (ULONG) dst, (ULONG) dst + count - 1);

	planes = (UTINY *) getVideowplane();

	if( src_flag == 1 )
	{
		if(!forward)
		{
			eas += w;
			dst += w;
		}

		lsbeas = (ULONG) eas & 0x1;
		lsbdst = (ULONG) dst & 0x1;

		if(forward)
		{
			easinc = lsbeas ? 3 : 1;
			dstinc = lsbdst ? 3 : 1;
		}
		else
		{
			easinc = lsbeas ? -1 : -3;
			dstinc = lsbdst ? -1 : -3;
		}

		easoff = (( (ULONG) eas >> 1 ) << 2 ) | lsbeas;
		dstoff = (( (ULONG) dst >> 1 ) << 2 ) | lsbdst;

		while( count-- )
		{
			*(planes + dstoff) = *(planes + easoff);

			dstoff += dstinc;
			easoff += easinc;
			dstinc ^= 0x2;
			easinc ^= 0x2;
		}
	}
	else
	{
		if(!forward)
		{
			dst += w;
#ifdef BACK_M
			eas -= w;
#else
			eas += w;
#endif
		}

		lsbdst = (ULONG) dst & 0x1;

		if(forward)
		{
#ifdef BACK_M
			easinc = -1;
#else
			easinc = 1;
#endif
			dstinc = lsbdst ? 3 : 1;
		}
		else
		{
#ifdef BACK_M
			easinc = 1;
#else
			easinc = -1;
#endif
			dstinc = lsbdst ? -1 : -3;
		}

		dstoff = (((ULONG) dst >> 1 ) << 2 ) | lsbdst;

		while( count-- )
		{
			*(planes + dstoff) = *eas;

			dstoff += dstinc;
			eas += easinc;
			dstinc ^= 0x2;
		}
	}
}


VOID
ega_copy_b_move IFN4(UTINY *,  offset, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move(offset, eas, count, src_flag, 0, getDF() ? FALSE : TRUE);
}

VOID
ega_copy_b_move_fwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count, src_flag, 0, TRUE );
}

VOID
ega_copy_b_move_bwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count, src_flag, 0, FALSE );
}

VOID
ega_copy_w_move IFN4(UTINY *,  offset, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move(offset, eas, count << 1, src_flag, 1, getDF() ? FALSE : TRUE);
}

VOID
ega_copy_w_move_fwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count << 1, src_flag, 1, TRUE );
}

VOID
ega_copy_w_move_bwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count << 1, src_flag, 1, FALSE );
}

VOID
ega_mode0_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;

	note_entrance0("ega_mode0_chn_b_write");

   (*update_alg.mark_byte)( offset );

	lsb = offset & 0x1;
    offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, in plane 1 or 3  */
	{
		offset |= 0x1;

		/*
		 * check if plane1 enabled
		 */

		if( getVideoplane_enable() & 2 )
		{
			/*
			 * check if set/reset function enable for this plane
			 */

			if( EGA_CPU.sr_enable & 2 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 1);
				value = do_logicals( value, get_latch1 );
				EGA_plane01[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane01[offset] = (byte) do_logicals( value, get_latch1 );
			}
		}

		/*
		 * check if plane3 enabled
		 */

		if( getVideoplane_enable() & 8 )
		{
			/*
			 * check if set/reset function enable for this plane
			 */

			if( EGA_CPU.sr_enable & 8 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 3);
				value = do_logicals( value, get_latch3 );
				EGA_plane23[offset] = (byte)value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane23[offset] = (byte) do_logicals( value, get_latch3 );
			}
		}
	}
	else
	{	/* even address, in plane 0 or 2 */
		/*
		 * check if plane0 enabled
		 */

		if( getVideoplane_enable() & 1 )
		{

			/*
			 * check if set/reset function enable for this plane
			 */

			if(( EGA_CPU.sr_enable & 1 ))
			{
				value = *((UTINY *) &EGA_CPU.sr_value);
				value = do_logicals( value, get_latch0 );
				EGA_plane01[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte)value, getVideorotate() );

				EGA_plane01[offset] = (byte) do_logicals( value, get_latch0 );
			}
		}

		/*
		 * check if plane2 enabled
		 */

		if( getVideoplane_enable() & 4 )
		{

			/*
			 * check if set/reset function enable for this plane
			 */

			if(( EGA_CPU.sr_enable & 4 ))
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 2);
				value = do_logicals( value, get_latch2 );
				EGA_plane23[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane23[offset] = (byte) do_logicals( value, get_latch2 );
			}
		}
	}
}

VOID
ega_mode0_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
	ULONG high_offset;
	UTINY value1, value2;

	note_entrance0("ega_mode0_chn_b_fill");

	/*
	 *	Starting on an odd address is inconvenient - go forward one
	 */

	if(( (ULONG) offset & 1) && count )
	{
		ega_mode0_chn_b_write( value, offset++ );
		count--;
	}

	/*
	 *	Ending on an even address is inconvenient - go back one
	 */

	if(( (ULONG) ( offset + count - 1 ) & 1) == 0 && count )
	{
		ega_mode0_chn_b_write( value, offset + count - 1 );
		count--;
	}

	high_offset = offset + count - 1;

	(*update_alg.mark_fill)( offset, high_offset );

	offset = (offset >> 1) << 2;
	high_offset = (high_offset >> 1) << 2;

	switch( getVideoplane_enable() & 0x3 )
	{
		case 0x1:	/* just plane 0 ie even addresses to be written */
			if (EGA_CPU.sr_enable & 1)
			{
				value = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch0 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value);
			break;

		case 0x2:	/* just plane 1 ie odd addresses to be written */
			if (EGA_CPU.sr_enable & 2)
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch1 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset + 1],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value);
			break;

		case 0x3:	/* sensible case is to have both chained planes write enabled */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = rotate( (byte) value, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 2)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value2 = rotate((byte) value,getVideorotate());
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch01 );
			value = (value << 8) | (value >> 8);

			fill_both_bytes( (IU16) value, (USHORT *)&EGA_plane01[offset], count >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )
	{
		case 0x4:
			if( EGA_CPU.sr_enable & 4 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch2 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value );
			break;

		case 0x8:
			if( EGA_CPU.sr_enable & 8 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch3 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset + 1],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value );
			break;

		case 0xc:
			if (EGA_CPU.sr_enable & 4)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = rotate( (byte) value, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 8)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = rotate( (byte) value, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch23 );
			value = (value << 8) | (value >> 8);

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );
			break;
	}
}


VOID
ega_mode0_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
	ULONG high_offset;
	UTINY value1, value2;
	IBOOL odd = FALSE;

	note_entrance0("ega_mode0_chn_w_fill");

	/*
	 *	Starting on an odd address is inconvenient - go forward one -
	 *	and take the even address write off the top as well.
	 */

	if(( (ULONG) offset & 1) && count )
	{
		odd = TRUE;
		ega_mode0_chn_b_write( value, offset++ );
		count -= 2;
		ega_mode0_chn_b_write( value >> 8, offset + count );
	}

	high_offset = offset + count - 1;

	/* the 3rd parameter is needed by GORE */
	(*update_alg.mark_wfill)( offset, high_offset, 0 );

	offset = (offset >> 1) << 2;
	high_offset = (high_offset >> 1) << 2;

	switch( getVideoplane_enable() & 0x3 )
	{
		case 0x1:	/* just plane 0 ie even addresses to be written */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY) do_logicals( value1, get_latch0 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value1 );

			break;

		case 0x2:	/* just plane 1 ie odd addresses to be written */
			if (EGA_CPU.sr_enable & 2)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value1 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY)(do_logicals( value1, get_latch1 ));
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset + 1],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value1 );

			break;

		case 0x3:	/* sensible case is to have both chained planes write enabled */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 2)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch01 );

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );

			break;

	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )
	{
		case 0x4:
			if( EGA_CPU.sr_enable & 4 )
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY) do_logicals( value1, get_latch2 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value1 );

			break;

		case 0x8:
			if( EGA_CPU.sr_enable & 8 )
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value2 = (UTINY) do_logicals( value2, get_latch3 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset + 1],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value2 );

			break;

		case 0xc:
			if (EGA_CPU.sr_enable & 4)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 8)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch23 );

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );

			break;
	}
}

LOCAL VOID
ega_mode0_chn_move_ram_src IFN5(UTINY *, eas, LONG, count, UTINY *, ead,
	UTINY *, EGA_plane, ULONG, plane )
{
	ULONG	offset;
	UTINY *src_offset;
	UTINY value;
	ULONG lsb, srcinc;

	src_offset = (UTINY *) eas;
	offset = (ULONG) ead;

	if(( offset & 1 ) != ( plane & 1 ))
	{
#ifdef BACK_M
		src_offset--;
#else
		src_offset++;
#endif
		offset++;
		count--;
	}

#ifdef BACK_M
	srcinc = -2;
#else
	srcinc = 2;
#endif

	lsb = offset & 1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	/*
	 * check if set/reset function enable for this plane
	 */

	if( EGA_CPU.sr_enable & ( 1 << plane ))
	{
		value = *((UTINY *) &EGA_CPU.sr_value + plane );

		while( count > 0 )
		{
			count -= 2;

			EGA_plane[offset] = (byte) do_logicals( value, get_latch(plane) );
			offset += 4;
		}
	}
	else
	{
		while( count > 0 )
		{
			value = *src_offset;
			src_offset += srcinc;
			count -= 2;

			/*
			 * set/reset not enabled so here we go
			 */

			if( getVideorotate() > 0 )
				value = rotate( value, getVideorotate() );

			value = (UTINY) do_logicals( value, get_latch(plane) );
			EGA_plane[offset] = value;
			offset += 4;
		}
	}
}

LOCAL VOID
ega_mode0_chn_move_vid_src IFN7(UTINY *, eas, LONG, count, UTINY *, ead,
	UTINY *, EGA_plane, UTINY *, scratch, ULONG, plane, ULONG, w )
{
	ULONG	offset;
	ULONG src_offset;
	UTINY *source;
	UTINY value;
	UTINY valsrc;
	ULONG lsb, inc, srcinc;

	offset = (ULONG ) ead;

	if(( offset & 1 ) != ( plane & 1 ))
	{
		eas++;
#ifdef BACK_M
		scratch--;
#else
		scratch++;
#endif
		offset++;
		count--;
	}

	src_offset = (ULONG) eas;

#ifdef BACK_M
	srcinc = -2;
#else
	srcinc = 2;
#endif
	inc = 4;

	lsb = offset & 1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	lsb = src_offset & 1;
	src_offset = (src_offset >> 1) << 2;
	src_offset |= lsb;

	source = &EGA_plane[src_offset] + (w << 2);

	/*
	 * check if set/reset function enable for this plane
	 */

	if( EGA_CPU.sr_enable & ( 1 << plane ))
	{
		value = *((UTINY *) &EGA_CPU.sr_value + plane );

		while( count > 0 )
		{
			count -= 2;
			valsrc = *source;
			source += inc;
			EGA_plane[offset] = (byte) do_logicals( value, valsrc );
			offset += inc;
		}
	}
	else
	{
		while( count > 0 )
		{
			count -= 2;

			value = *(UTINY *) scratch;
			scratch += srcinc;

			valsrc = *source;
			source += inc;

			/*
			 * set/reset not enabled so here we go
			 */

			if( getVideorotate() > 0 )
				value = rotate( value, getVideorotate() );

			value = (UTINY) do_logicals( value, valsrc );
			EGA_plane[offset] = value;
			offset += inc;
		}
	}
}

#pragma warning(disable:4146)       // unary minus operator applied to unsigned type

VOID
ega_mode0_chn_move IFN6(UTINY, w, UTINY *, ead, UTINY *, eas, ULONG, count,
	ULONG, src_flag, IBOOL, forwards )
{
	UTINY *scratch;
	IMPORT VOID (*string_read_ptr)();

	note_entrance0("ega_mode0_chn_move");

	if( src_flag == 1 )
	{
		/*
		 *	Source is in EGA, latches will change with each byte moved. We
		 *	restore CPU's view of source in regen, and use it to update planes
		 *	with the aid of the SAS scratch area.
		 */

#ifdef BACK_M
		scratch = getVideoscratch() + 0x10000 - 1;
#else
		scratch = getVideoscratch();
#endif

		if( !forwards )
		{
			eas += - count + 1 + w;
			ead += - count + 1 + w;
		}

		(*string_read_ptr)( scratch, eas, count );

		if( getVideoplane_enable() & 1 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane01, scratch, 0, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane01, scratch, 1, w );

		if( getVideoplane_enable() & 4 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane23, scratch, 2, 0 );

		if( getVideoplane_enable() & 8 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane23, scratch, 3, w );
	}
	else
	{
		if( !forwards )
		{
#ifdef BACK_M
			eas += count - 1 - w;
#else
			eas += - count + 1 + w;
#endif
			ead += - count + 1 + w;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane23, 3 );
	}

	(*update_alg.mark_string)( (ULONG) ead, (ULONG) ead + count );
}


VOID
ega_mode0_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, getDF() ? FALSE : TRUE);
}

VOID
ega_mode0_chn_b_move_fwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, TRUE );
}

VOID
ega_mode0_chn_b_move_bwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, FALSE );
}

VOID
ega_mode0_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
	ega_mode0_chn_move(1, (UTINY *)ead, (UTINY *)eas, count << 1, src_flag, getDF() ? FALSE : TRUE);
}

VOID
ega_mode0_chn_w_move_fwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move(1,(UTINY *)ead, (UTINY *)eas, count << 1, src_flag, TRUE );
}

VOID
ega_mode0_chn_w_move_bwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move(1,(UTINY *)ead, (UTINY *)eas, count << 1, src_flag, FALSE );
}

VOID
ega_mode0_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
   note_entrance0("ega_mode0_chn_w_write");

   ega_mode0_chn_b_write( value, offset );
   ega_mode0_chn_b_write( value >> 8, offset + 1 );
}

#endif  //NEC_98
#endif

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_dmmy.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SccsID = "@(#)ega_dummy.c	1.6 8/25/93 Copyright Insignia Solutions Ltd."
 */


#ifdef EGG

/*  Dummy routines for EGA */

#include	"xt.h"
#include	"sas.h"
#include	"ios.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"debug.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"gfx_upd.h"
#include	"egagraph.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

/* dummy stuff to keep linker happy */
#define def_dummy(type,name,res) \
type name() { note_entrance0("name");res; }

def_dummy(int,get_ega_switch_setting,return 0)


/*-----------dummy write handlers -------------------------*/

/*-----------end of dummy stuff ---------------------------*/
#endif /* EGG */

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\system\unexp_nt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Unexpected interrupt routine
 *
 * Description	: This function is called for those interrupt vectors
 *		  which should not occur.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)unexp_int.c	1.8 06/15/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif


/*
 *    O/S include files.
 */
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "ica.h"
#include "ios.h"
#include "sas.h"
#include "debug.h"

#define INTR_FLAG 0x6b
#define EOI 0x20

void unexpected_int()
{
   half_word m_isr, m_imr, s_isr, s_imr;

   /* Read ica registers to determine interrupt reason */

   outb(ICA0_PORT_0, 0x0b);
   inb(ICA0_PORT_0, &m_isr);

   /* HW or SW ? */

   if ( m_isr == 0 )
      {
      /* Non hardware interrupt(= software) */
      m_isr = 0xFF;
      always_trace0("Non hardware interrupt(= software)");
      }
   else
      {
      /* Hardware interrupt */
      inb(ICA0_PORT_1, &m_imr);
      if ((m_imr & 0xfb) != 0)
	always_trace1("hardware interrupt master isr %02x", m_isr);
      m_imr |= m_isr;
      m_imr &= 0xfb;	/* avoid masking line 2 as it's the other ica */

      /* check second ICA too */
      outb(ICA1_PORT_0, 0x0b);
      inb(ICA1_PORT_0, &s_isr);
      if (s_isr != 0)	/* ie hardware int on second ica */
	{
	  always_trace1("hardware interrupt slave isr %02x", s_isr);
          inb(ICA1_PORT_1, &s_imr);	/* get interrupt mask */
	  s_imr |= s_isr;		/* add the one that wasn't expected */
          outb(ICA1_PORT_1, s_imr);	/* and mask out */
          outb(ICA1_PORT_0, EOI);
	}

      /* now wind down main ica */
      outb(ICA0_PORT_1, m_imr);
      outb(ICA0_PORT_0, EOI);
      }

   /* Set Bios data area up with interrupt cause */
   sas_store(BIOS_VAR_START + INTR_FLAG, m_isr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_prts.c ===
#include "insignia.h"
#include "host_def.h"
/*                      INSIGNIA (SUB)MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT                : name and number

RELATED DOCS            : include all relevant references

DESIGNER                :

REVISION HISTORY        :
First version           : 13 July 1988, J.Roper

SUBMODULE NAME          : ega

SOURCE FILE NAME        : ega_ports.c

PURPOSE                 : emulation of EGA registers (ports).
                          Calls lower levels of the EGA emulation to do the real work.

static char SccsID[]="@(#)ega_ports.c   1.54 07/18/94 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

        INCLUDE FILE : ega_ports.gi

[1.1    INTERMODULE EXPORTS]

        PROCEDURES() :
                        void ega_init()
                        void ega_term()
                        int ega_get_line_compare()      (* hunter only *)
                        int ega_get_max_scan_lines()    (* hunter only *)

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

        PROCEDURES() :
                        io_define_inb
                        io_define_outb
                        io_connect_port
                        io_disconnect_port

        DATA         :  give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS      :     specify in following procedure descriptions
                        how these are accessed (read/modified)

FILES ACCESSED    :     NONE

DEVICES ACCESSED  :     NONE

SIGNALS CAUGHT    :     NONE

SIGNALS ISSUED    :     NONE


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE         :     ega_init

PURPOSE           :     initialize EGA.

PARAMETERS        :     none

GLOBALS           :     none

DESCRIPTION       :     establish ega ports.
                        initialize ega code to sensible state.

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_term

PURPOSE           :     terminate EGA.

PARAMETERS        :     none

GLOBALS           :     none

DESCRIPTION       :     remove ega ports.
                        free up allocated memory etc.

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_seq_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the sequencer chip's ports, and pass
                        appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_crtc_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the sequencer chip's ports, and pass
                        appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_crtc_inb((io_addr) port, (half_word) *value)

PURPOSE           :     deal with an attempt to read a byte from one of the crtc's register ports,
                        and gets info from appropriate ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     pointer to memory byte where value read from port should go.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_gc_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the graphics controller chip's ports,
                        and pass appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_ac_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the attribute controller chip's ports, and pass
                        appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_misc_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the miscellaneous register's port, and pass
                        appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_feat_outb((io_addr) port, (half_word) value)

PURPOSE           :     deal with bytes written to the Feature Control register's port, and pass
                        appropriate info to ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     the byte written to the port.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_ipstat0_inb((io_addr) port, (half_word) *value)

PURPOSE           :     deal with an attempt to read a byte from the input status register 0 port,
                        and gets info from appropriate ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     pointer to memory byte where value read from port should go.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     ega_ipstat1_inb((io_addr) port, (half_word) *value)

PURPOSE           :     deal with an attempt to read a byte from the input status register 1 port,
                        and gets info from appropriate ega sub-modules.

PARAMETERS
        port      :     port address written to.
        value     :     pointer to memory byte where value read from port should go.

GLOBALS           :     none

DESCRIPTION       :

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================
PROCEDURE         :     int ega_get_line_compare()

PURPOSE           :     Hunter only - returns the line compare value
                        from the crtc registers structure

PARAMETERS        :     none

GLOBALS           :     none

DESCRIPTION       :     Obtains the line compare value from bit 4 of the
                        overflow register (0x7) and the line compare
                        register (0x18).

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================

=========================================================================

PROCEDURE         :     int ega_get_max_scan_lines()

PURPOSE           :     Hunter only - returns the maximum scan lines value
                        from the crtc registers structure

PARAMETERS        :     none

GLOBALS           :     none

DESCRIPTION       :     Obtains the max scan lines value from the max scan
                        lines register (0x9).

ERROR INDICATIONS :     none.

ERROR RECOVERY    :     none.
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                                               */

/* [3.1.1 #INCLUDES]                                                    */


#ifndef REAL_VGA        /* ega port handling moved to host for REAL_VGA */
    #ifdef EGG

        #include        "xt.h"
        #include        CpuH
        #include        "debug.h"
        #include        "timer.h"
        #include        "sas.h"
        #include        "gmi.h"
        #include        "gvi.h"
        #include        "ios.h"
        #include        "ica.h"
        #include        "gfx_upd.h"
        #include        "egacpu.h"
        #include        "egagraph.h"
        #include        "egaread.h"
        #include        "egamode.h"
        #include        "error.h"
        #include        "config.h"

        #include        "host_gfx.h"
        #include        "egaports.h"

        #ifdef GORE
            #include  "gore.h"
        #endif /* GORE */

        #include  "ga_mark.h"
        #include  "ga_defs.h"

/* [3.2 INTERMODULE EXPORTS]                                            */


/* [3.1.2 DECLARATIONS]                                                 */

IMPORT  void    ega_mode_init IPT0();
IMPORT  int     get_ega_switch_setting IPT0();
IMPORT void v7_get_banks IPT2(UTINY *, rd_bank, UTINY *, wrt_bank );
        #ifndef cursor_changed
IMPORT void cursor_changed IPT2(int, x, int, y);
        #endif /* cursor_changed */
IMPORT void update_shift_count IPT0();

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

LOCAL   void    vote_ega_mode IPT0();
LOCAL void      ega_seq_outb_index IPT2(io_addr, port, half_word, value);
LOCAL void      ega_crtc_outb IPT2(io_addr, port, half_word, value);
LOCAL void      ega_crtc_inb IPT2(io_addr, port, half_word *, value);
LOCAL void      ega_ac_outb IPT2(io_addr, port, half_word, value);
LOCAL void      ega_misc_outb IPT2(io_addr, port, half_word, value);
LOCAL void      ega_feat_outb IPT2(io_addr, port, half_word, value);
LOCAL void      ega_ipstat0_inb IPT2(io_addr, port, half_word *, value);
LOCAL void      ega_ipstat1_inb IPT2(io_addr, port, half_word *, value);


/* [5.1.1 #DEFINES]                                                     */
        #ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
            #include "SOFTPC_EGA.seg"
        #endif

GLOBAL VOID ega_gc_outw IPT2(io_addr, port, word, outval);

/*
 * EGA_PLANE_DISP_SIZE is already declared in egaports.h. However if V7VGA is
 * defined using this definition will cause problems. See BCN 1486 for details.
 */
        #define EGA_PLANE_SZ    0x10000

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */
        #ifdef BIT_ORDER1
typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned hardware_reset             : 1,    /* NO           */
        word_or_byte_mode          : 1,    /* YES          */
        address_wrap               : 1,    /* NO           */
        output_control             : 1,    /* YES - screen goes black              */
        count_by_two               : 1,    /* NO           */
        horizontal_retrace_select  : 1,    /* NO           */
        select_row_scan_counter    : 1,    /* NO           */
        compatibility_mode_support : 1;    /* YES - CGA graphics banks             */
    } as_bfld;
} MODE_CONTROL;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 3,
        line_compare_bit_8                 : 1,    /* YES  */
        start_vertical_blank_bit_8         : 1,    /* NO   */
        vertical_retrace_start_bit_8       : 1,    /* NO   */
        vertical_display_enab_end_bit_8    : 1,    /* YES  */
        vertical_total_bit_8               : 1;    /* NO   */
    } as_bfld;
} CRTC_OVERFLOW;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 3,
        maximum_scan_line                  : 5;    /* YES                                  */
    } as_bfld;
} MAX_SCAN_LINE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 3,
        cursor_start                       : 5;    /* YES                                  */
    } as_bfld;
} CURSOR_START;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 1,
        cursor_skew_control                : 2,    /* NO                                   */
        cursor_end                         : 5;    /* YES                                  */
    } as_bfld;
} CURSOR_END;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                   : 6,
        synchronous_reset          : 1,            /* Ditto (could implement as enable_ram)*/
        asynchronous_reset         : 1;            /* NO - damages video and font RAM      */
    } as_bfld;
} SEQ_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                   : 4,
        dot_clock                  : 1,            /* YES - distinguishes 40 or 80 chars   */
        shift_load                 : 1,            /* NO                                   */
        bandwidth                  : 1,            /* NO                                   */
        eight_or_nine_dot_clocks   : 1;            /* NO - only for mono display           */
    } as_bfld;
} CLOCKING_MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                   : 4,
        all_planes                 : 4;            /* YES                                  */
    } as_bfld;
} MAP_MASK;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                   : 4,
        character_map_select_b     : 2,            /* YES                                  */
        character_map_select_a     : 2;            /* YES                                  */
    } as_bfld;
    struct
    {
        unsigned not_used                   : 4,
        map_selects                : 4;            /* YES                                  */
    } character;
} CHAR_MAP_SELECT;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned
        not_used                   : 5,            /* If above 2 not both 1, bank 0 set 2  */
        not_odd_or_even            : 1,            /* YES (check consistency)              */
        extended_memory            : 1,            /* NO - assume full 256K on board       */
        alpha_mode                 : 1;            /* YES (check consistency)              */
    } as_bfld;
} MEMORY_MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 4,
        set_or_reset                       : 4;    /* YES - write mode 0 only              */
    } as_bfld;
} SET_OR_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 4,
        enable_set_or_reset                : 4;    /* YES - write mode 0 only              */
    } as_bfld;
} ENABLE_SET_OR_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 4,
        color_compare                      : 4;    /* YES - read mode 1 only               */
    } as_bfld;
} COLOR_COMPARE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 3,
        function_select                    : 2,    /* YES - write mode 0 only              */
        rotate_count                       : 3;    /* YES - write mode 0 only              */
    } as_bfld;
} DATA_ROTATE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 5,
        map_select                             : 3;    /* YES                                  */
    } as_bfld;
} READ_MAP_SELECT;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 2,
        shift_register_mode                : 1,    /* YES - CGA colour graphics            */
        odd_or_even                        : 1,    /* YES (check for consistency)          */
        read_mode                          : 1,    /* YES                                  */
        test_condition                     : 1,    /* NO                                   */
        write_mode                         : 2;    /* YES                                  */
    } as_bfld;
} MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 4,
        memory_map                         : 2,    /* YES - location of EGA in M           */
        odd_or_even                        : 1,    /* YES (check consistency)              */
        graphics_mode                      : 1;    /* YES                                  */
    } as_bfld;
} MISC_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 4,
        color_dont_care                    : 4;    /* YES - read mode 1 only               */
    } as_bfld;
} COLOR_DONT_CARE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned
        not_used                           : 4,
        background_intensity_or_blink      : 1,    /* NO - never blink                     */
        enable_line_graphics_char_codes    : 1,    /* NO mono display only                 */
        display_type                       : 1,    /* NO - always colour display           */
        graphics_mode                      : 1;    /* YES - with Sequencer Mode reg        */
    } as_bfld;
} AC_MODE_CONTROL;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned vertical_retrace_polarity      : 1,            /* YES - switch between 200/350 lines   */
        horizontal_retrace_polarity    : 1,            /* NO - probably destroys display!      */
        page_bit_odd_even              : 1,            /* NO - selects 32k page in odd/even?   */
        disable_internal_video_drivers : 1,            /* NO - like switching PC off           */
        clock_select                   : 2,            /* YES - only for switch address        */
        enable_ram                     : 1,            /* YES - writes to display mem ignored  */
        io_address_select              : 1;            /* NO - only used for mono screens      */
    } as_bfld;
} MISC_OUTPUT_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                       : 4,
        reserved                       : 2,            /* YES - ignore                         */
        feature_control                : 2;            /* NO - device not supported            */
    } as_bfld;
} FEAT_CONT_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned crt_interrupt                  : 1,            /* YES - sequence if not timing         */
        reserved                       : 2,            /* YES - all bits 1                     */
        switch_sense                   : 1,            /* YES - switch selected by clock sel.  */
        not_used                       : 4;            /* YES - all bits 1                     */
    } as_bfld;
} INPUT_STAT_REG0;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                           : 2,
        video_status_mux                   : 2,    /* NO                                   */
        color_plane_enable                 : 4;    /* YES  NB. affects attrs in text mode  */
    } as_bfld;
} COLOR_PLANE_ENABLE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                       : 1,            /* YES - set to 1                       */
        diagnostic_0                   : 1,            /* NO - set to 0                        */
        diagnostic_1                   : 1,            /* NO - set to 0                        */
        vertical_retrace               : 1,            /* YES - sequence only                  */
        light_pen_switch               : 1,            /* YES - set to 0                       */
        light_pen_strobe               : 1,            /* YES - set to 1                       */
        display_enable                 : 1;            /* YES - sequence only                  */
    } as_bfld;
} INPUT_STAT_REG1;
        #endif
        #ifdef BIT_ORDER2
typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned compatibility_mode_support         : 1,    /* YES - CGA graphics banks             */
        select_row_scan_counter            : 1,    /* NO                                   */
        horizontal_retrace_select          : 1,    /* NO                                   */
        count_by_two                       : 1,    /* NO                                   */
        output_control                     : 1,    /* YES - screen goes black              */
        address_wrap                       : 1,    /* NO                                   */
        word_or_byte_mode                  : 1,    /* YES                                  */
        hardware_reset                     : 1;    /* NO                                   */
    } as_bfld;
} MODE_CONTROL;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned vertical_total_bit_8               : 1,    /* NO                                   */
        vertical_display_enab_end_bit_8    : 1,    /* YES                                  */
        vertical_retrace_start_bit_8       : 1,    /* NO                                   */
        start_vertical_blank_bit_8         : 1,    /* NO                                   */
        line_compare_bit_8                 : 1,    /* YES                                  */
        not_used                           : 3;
    } as_bfld;
} CRTC_OVERFLOW;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned maximum_scan_line                  : 5,    /* YES                                  */
        not_used                           : 3;
    } as_bfld;
} MAX_SCAN_LINE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned cursor_start                       : 5,    /* YES                                  */
        not_used                           : 3;
    } as_bfld;
} CURSOR_START;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned cursor_end                         : 5,    /* YES                                  */
        cursor_skew_control                : 2,    /* NO                                   */
        not_used                           : 1;
    } as_bfld;
} CURSOR_END;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned asynchronous_reset         : 1,            /* NO - damages video and font RAM      */
        synchronous_reset          : 1,            /* Ditto (could implement as enable_ram)*/
        not_used                   : 6;
    } as_bfld;
} SEQ_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned eight_or_nine_dot_clocks   : 1,            /* NO - only for mono display           */
        bandwidth                  : 1,            /* NO                                   */
        shift_load                 : 1,            /* NO                                   */
        dot_clock                  : 1,            /* YES - distinguishes 40 or 80 chars   */
        not_used                   : 4;
    } as_bfld;
} CLOCKING_MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned all_planes                 : 4,            /* YES                                  */
        not_used                   : 4;
    } as_bfld;
} MAP_MASK;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned character_map_select_a     : 2,            /* YES                                  */
        character_map_select_b     : 2,            /* YES                                  */
        not_used                   : 4;
    } as_bfld;
    struct
    {
        unsigned map_selects                : 4,            /* YES                                  */
        not_used                   : 4;
    } character;
} CHAR_MAP_SELECT;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned alpha_mode                 : 1,            /* YES (check consistency)              */
        extended_memory            : 1,            /* NO - assume full 256K on board       */
        not_odd_or_even            : 1,            /* YES (check consistency)              */
        not_used                   : 5;            /* If above 2 not both 1, bank 0 set 2  */
    } as_bfld;
} MEMORY_MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned set_or_reset                       : 4,    /* YES - write mode 0 only              */
        not_used                           : 4;
    } as_bfld;
} SET_OR_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned enable_set_or_reset                : 4,    /* YES - write mode 0 only              */
        not_used                           : 4;
    } as_bfld;
} ENABLE_SET_OR_RESET;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned color_compare                      : 4,    /* YES - read mode 1 only               */
        not_used                           : 4;
    } as_bfld;
} COLOR_COMPARE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned rotate_count                       : 3,    /* YES - write mode 0 only              */
        function_select                    : 2,    /* YES - write mode 0 only              */
        not_used                           : 3;
    } as_bfld;
} DATA_ROTATE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned map_select                         : 3,    /* YES - read mode 0 only               */
        not_used                               : 5;
    } as_bfld;
} READ_MAP_SELECT;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned write_mode                         : 2,    /* YES                                  */
        test_condition                     : 1,    /* NO                                   */
        read_mode                          : 1,    /* YES                                  */
        odd_or_even                        : 1,    /* YES (check for consistency)          */
        shift_register_mode                : 1,    /* YES - CGA colour graphics            */
        not_used                           : 2;
    } as_bfld;
} MODE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned graphics_mode                      : 1,    /* YES                                  */
        odd_or_even                        : 1,    /* YES (check consistency)              */
        memory_map                         : 2,    /* YES - location of EGA in M           */
        not_used                           : 4;
    } as_bfld;
} MISC_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned color_dont_care                    : 4,    /* YES - read mode 1 only               */
        not_used                           : 4;
    } as_bfld;
} COLOR_DONT_CARE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned graphics_mode                      : 1,    /* YES - with Sequencer Mode reg        */
        display_type                       : 1,    /* NO - always colour display           */
        enable_line_graphics_char_codes    : 1,    /* NO mono display only                 */
        background_intensity_or_blink      : 1,    /* NO - never blink                     */
        not_used                           : 4;
    } as_bfld;
} AC_MODE_CONTROL;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned io_address_select              : 1,            /* NO - only used for mono screens      */
        enable_ram                     : 1,            /* YES - writes to display mem ignored  */
        clock_select                   : 2,            /* YES - only for switch address        */
        disable_internal_video_drivers : 1,            /* NO - like switching PC off           */
        page_bit_odd_even              : 1,            /* NO - selects 32k page in odd/even?   */
        horizontal_retrace_polarity    : 1,            /* NO - probably destroys display!      */
        vertical_retrace_polarity      : 1;            /* YES - switch between 200/350 lines   */
    } as_bfld;
} MISC_OUTPUT_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned feature_control                : 2,            /* NO - device not supported            */
        reserved                       : 2,            /* YES - ignore                         */
        not_used                       : 4;
    } as_bfld;
} FEAT_CONT_REG;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned not_used                       : 4,            /* YES - all bits 1                     */
        switch_sense                   : 1,            /* YES - switch selected by clock sel.  */
        reserved                       : 2,            /* YES - all bits 1                     */
        crt_interrupt                  : 1;            /* YES - sequence if not timing         */
    } as_bfld;
} INPUT_STAT_REG0;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned color_plane_enable                 : 4,    /* YES  NB. affects attrs in text mode  */
        video_status_mux                   : 2,    /* NO                                   */
        not_used                           : 2;
    } as_bfld;
} COLOR_PLANE_ENABLE;

typedef union
{
    struct
    {
        unsigned abyte : 8;
    } as;
    struct
    {
        unsigned display_enable                 : 1,            /* YES - sequence only                  */
        light_pen_strobe               : 1,            /* YES - set to 1                       */
        light_pen_switch               : 1,            /* YES - set to 0                       */
        vertical_retrace               : 1,            /* YES - sequence only                  */
        diagnostic_1                   : 1,            /* NO - set to 0                        */
        diagnostic_0                   : 1,            /* NO - set to 0                        */
        not_used                       : 1;            /* YES - set to 1                       */
    } as_bfld;
} INPUT_STAT_REG1;
        #endif



/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

/*

/* EGA REGISTERS */
/* Comments after bitfields indicate whether change of value affects emulated screen display or memory interface */

/* Registers not contained in an LSI device */

static  MISC_OUTPUT_REG miscellaneous_output_register;

static  FEAT_CONT_REG   feature_control_register;

static  INPUT_STAT_REG0 input_status_register_zero;

static  INPUT_STAT_REG1 input_status_register_one;

/* The Sequencer Registers */
        #ifdef BIT_ORDER1
static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                   : 5,
            index                      : 3;
        } as_bfld;
    } address;

    SEQ_RESET           reset;
    CLOCKING_MODE       clocking_mode;
    MAP_MASK            map_mask;
    CHAR_MAP_SELECT     character_map_select;
    MEMORY_MODE         memory_mode;
} sequencer;


/* The CRT Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 3,
            index                              : 5;
        } as_bfld;
    } address;

    byte horizontal_total;                                      /* NO - screen trash if wrong value     */
    byte horizontal_display_end;                                /* YES - defines line length!!          */
    byte start_horizontal_blanking;                             /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 1,
            display_enable_skew_control        : 2,    /* NO                                   */
            end_blanking                       : 5;    /* NO                                   */
        } as_bfld;
    } end_horizontal_blanking;

    byte start_horizontal_retrace;                              /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 1,
            horizontal_retrace_delay           : 2,    /* NO                                   */
            end_horizontal_retrace             : 5;    /* NO                                   */
        } as_bfld;
    } end_horizontal_retrace;

    byte vertical_total;                                        /* NO                                   */
    CRTC_OVERFLOW       crtc_overflow;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 3,
            preset_row_scan                    : 5;    /* NO                                   */
        } as_bfld;
    } preset_row_scan;

    MAX_SCAN_LINE       maximum_scan_line;
    CURSOR_START        cursor_start;
    CURSOR_END          cursor_end;
    byte start_address_high;                                    /* YES                                  */
    byte start_address_low;                                     /* YES                                  */
    byte cursor_location_high;                                  /* YES                                  */
    byte cursor_location_low;                                   /* YES                                  */
    byte vertical_retrace_start;                                /* NO                                   */
    byte light_pen_high;                                        /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned
            not_used                           : 2,
            enable_vertical_interrupt          : 1,    /* YES - ditto                          */
            clear_vertical_interrupt           : 1,    /* YES - needs investigation            */
            vertical_retrace_end               : 4;    /* NO                                   */
        } as_bfld;
    } vertical_retrace_end;

    byte light_pen_low;                                         /* NO                                   */
    byte vertical_display_enable_end;                           /* YES - defines screen height          */
    byte offset;                                                /* YES (maybe!) ???????                 */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 3,
            underline_location                 : 5;    /* NO (mono display only)               */
        } as_bfld;
    } underline_location;

    byte start_vertical_blanking;                               /* NO                                   */
    byte end_vertical_blanking;                                 /* NO                                   */
    MODE_CONTROL        mode_control;
    byte line_compare;                                          /* YES                                  */

} crt_controller;


/* The Graphics Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 4,
            index                              : 4;
        } as_bfld;
    } address;

    SET_OR_RESET        set_or_reset;
    ENABLE_SET_OR_RESET enable_set_or_reset;
    COLOR_COMPARE       color_compare;
    DATA_ROTATE         data_rotate;
    READ_MAP_SELECT     read_map_select;
    MODE                mode;
    MISC_REG            miscellaneous;
    COLOR_DONT_CARE     color_dont_care;
    byte bit_mask_register;                                     /* YES - write modes 0 & 2              */
    byte graphics_1_position;                                   /* NO                                   */
    byte graphics_2_position;                                   /* NO                                   */
} graphics_controller;


/* The Attribute Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 3,
            index                              : 5;
        } as_bfld;
    } address;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned
            not_used                           : 2,    /* YES                                  */
            secondary_red                      : 1,    /* YES                                  */
            secondary_green                    : 1,    /* YES                                  */
            secondary_blue                     : 1,    /* YES                                  */
            red                                : 1,    /* YES                                  */
            green                              : 1,    /* YES                                  */
            blue                               : 1;    /* YES                                  */
        } as_bfld;
    } palette[EGA_PALETTE_SIZE];

    AC_MODE_CONTROL     mode_control;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 2,
            secondary_red_border               : 1,    /* YES                                  */
            secondary_green_border             : 1,    /* YES                                  */
            secondary_blue_border              : 1,    /* YES                                  */
            red_border                         : 1,    /* YES                                  */
            green_border                       : 1,    /* YES                                  */
            blue_border                        : 1;    /* YES - real thing isn't good at this  */
        } as_bfld;
    } overscan_color;

    COLOR_PLANE_ENABLE  color_plane_enable;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned not_used                           : 4,
            horizontal_pel_panning             : 4;    /* NO                                   */
        } as_bfld;
    } horizontal_pel_panning;
} attribute_controller;
        #endif

        #ifdef BIT_ORDER2
static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned index                              : 3,
            not_used                           : 5;
        } as_bfld;
    } address;

    SEQ_RESET           reset;
    CLOCKING_MODE       clocking_mode;
    MAP_MASK            map_mask;
    CHAR_MAP_SELECT     character_map_select;
    MEMORY_MODE         memory_mode;
} sequencer;


/* The CRT Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned index                              : 5,
            not_used                           : 3;
        } as_bfld;
    } address;

    byte horizontal_total;                                      /* NO - screen trash if wrong value     */
    byte horizontal_display_end;                                /* YES - defines line length!!          */
    byte start_horizontal_blanking;                             /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned end_blanking                       : 5,    /* NO                                   */
            display_enable_skew_control        : 2,    /* NO                                   */
            not_used                           : 1;
        } as_bfld;
    } end_horizontal_blanking;

    byte start_horizontal_retrace;                              /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned end_horizontal_retrace             : 5,    /* NO                                   */
            horizontal_retrace_delay           : 2,    /* NO                                   */
            not_used                           : 1;
        } as_bfld;
    } end_horizontal_retrace;

    byte vertical_total;                                        /* NO                                   */
    CRTC_OVERFLOW       crtc_overflow;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned preset_row_scan                    : 5,    /* NO                                   */
            not_used                           : 3;
        } as_bfld;
    } preset_row_scan;

    MAX_SCAN_LINE       maximum_scan_line;
    CURSOR_START        cursor_start;
    CURSOR_END          cursor_end;
    byte start_address_high;                                    /* YES                                  */
    byte start_address_low;                                     /* YES                                  */
    byte cursor_location_high;                                  /* YES                                  */
    byte cursor_location_low;                                   /* YES                                  */
    byte vertical_retrace_start;                                /* NO                                   */
    byte light_pen_high;                                        /* NO                                   */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned vertical_retrace_end               : 4,    /* NO                                   */
            clear_vertical_interrupt           : 1,    /* YES - needs investigation            */
            enable_vertical_interrupt          : 1,    /* YES - ditto                          */
            not_used                           : 2;
        } as_bfld;
    } vertical_retrace_end;

    byte light_pen_low;                                         /* NO                                   */
    byte vertical_display_enable_end;                           /* YES - defines screen height          */
    byte offset;                                                /* YES (maybe!) ???????                 */

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned underline_location                 : 5,    /* NO (mono display only)               */
            not_used                           : 3;
        } as_bfld;
    } underline_location;

    byte start_vertical_blanking;                               /* NO                                   */
    byte end_vertical_blanking;                                 /* NO                                   */
    MODE_CONTROL        mode_control;
    byte line_compare;                                          /* YES                                  */

} crt_controller;


/* The Graphics Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned index                              : 4,
            not_used                           : 4;
        } as_bfld;
    } address;

    SET_OR_RESET        set_or_reset;
    ENABLE_SET_OR_RESET enable_set_or_reset;
    COLOR_COMPARE       color_compare;
    DATA_ROTATE         data_rotate;
    READ_MAP_SELECT     read_map_select;
    MODE                mode;
    MISC_REG            miscellaneous;
    COLOR_DONT_CARE     color_dont_care;
    byte bit_mask_register;                                     /* YES - write modes 0 & 2              */
    byte graphics_1_position;                                   /* NO                                   */
    byte graphics_2_position;                                   /* NO                                   */
} graphics_controller;


/* The Attribute Controller Registers */

static struct
{
    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned index                              : 5,
            not_used                           : 3;
        } as_bfld;
    } address;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned blue                               : 1,    /* YES                                  */
            green                              : 1,    /* YES                                  */
            red                                : 1,    /* YES                                  */
            secondary_blue                     : 1,    /* YES                                  */
            secondary_green                    : 1,    /* YES                                  */
            secondary_red                      : 1,    /* YES                                  */
            not_used                           : 2;    /* YES                                  */
        } as_bfld;
    } palette[EGA_PALETTE_SIZE];

    AC_MODE_CONTROL     mode_control;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned blue_border                        : 1,    /* YES - real thing isn't good at this  */
            green_border                       : 1,    /* YES                                  */
            red_border                         : 1,    /* YES                                  */
            secondary_blue_border              : 1,    /* YES                                  */
            secondary_green_border             : 1,    /* YES                                  */
            secondary_red_border               : 1,    /* YES                                  */
            not_used                           : 2;
        } as_bfld;
    } overscan_color;

    COLOR_PLANE_ENABLE  color_plane_enable;

    union
    {
        struct
        {
            unsigned abyte : 8;
        } as;
        struct
        {
            unsigned horizontal_pel_panning             : 4,    /* NO                                   */
            not_used                           : 4;
        } as_bfld;
    } horizontal_pel_panning;
} attribute_controller;
        #endif

static  boolean ac_index_state = NO;
extern half_word bg_col_mask; /* Used to work out the background colour */

IMPORT VOID _ega_gc_outb_index IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask_ff IPT2(io_addr,port,half_word,value);

/* Declarations for new multi-routine graphics controller */
void    ega_gc_set_reset IPT2(io_addr, port, half_word, value);
void    ega_gc_enable_set IPT2(io_addr, port, half_word, value);
void    ega_gc_compare IPT2(io_addr, port, half_word, value);
void    ega_gc_rotate IPT2(io_addr, port, half_word, value);
void    ega_gc_read_map IPT2(io_addr, port, half_word, value);
void    ega_gc_mode IPT2(io_addr, port, half_word, value);
void    ega_gc_misc IPT2(io_addr, port, half_word, value);
void    ega_gc_dont_care IPT2(io_addr, port, half_word, value);
LOCAL void      ega_gc_mask IPT2(io_addr, port, half_word, value);
void    ega_gc_mask_ff IPT2(io_addr, port, half_word, value);
LOCAL void      ega_index_invalid IPT2(io_addr, port, half_word, value);

void (*ega_gc_regs[]) IPT2(io_addr, port, half_word, value) = {
    ega_gc_set_reset,
    ega_gc_enable_set,
    ega_gc_compare,
    ega_gc_rotate,
    ega_gc_read_map,
    ega_gc_mode,
    ega_gc_misc,
    ega_gc_dont_care,
    ega_gc_mask,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
};

        #ifndef A2CPU
void (*ega_gc_regs_cpu[]) IPT2(io_addr,port,half_word,value) = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};
        #endif  /* A2CPU */

/* Declarations for new seqencer code */
void    ega_seq_reset IPT2(io_addr, port, half_word, value);
void    ega_seq_clock IPT2(io_addr, port, half_word, value);
void    ega_seq_map_mask IPT2(io_addr, port, half_word, value);
void    ega_seq_char_map IPT2(io_addr, port, half_word, value);
void    ega_seq_mem_mode IPT2(io_addr, port, half_word, value);

void (*ega_seq_regs[]) IPT2(io_addr, port, half_word, value) =
{
    ega_seq_reset,
    ega_seq_clock,
    ega_seq_map_mask,
    ega_seq_char_map,
    ega_seq_mem_mode,
    ega_index_invalid,
    ega_index_invalid,
    ega_index_invalid,
};


/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */

/*
==========================================================================
FUNCTION        :       set_index_state()
PURPOSE         :       Set the attribute controller to use the next value
                        written to its port as the index value.
EXTERNAL OBJECTS:
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

void    set_index_state IFN0()
{
    /*
     * Seems strange, but in_index_state changes the state & returns the result
     * so we set state to NO, so that next call of in_index_state will return YES
     */
    ac_index_state = NO;
}

/*
==========================================================================
FUNCTION        :       in_index_state()
PURPOSE         :       To determine if the value written to the attribute
                        controller is destined for the index register, or
                        another register specified by the current index
                        value.
EXTERNAL OBJECTS:
RETURN VALUE    :       Boolean
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

boolean in_index_state IFN0()
{
    ac_index_state = ! ac_index_state;
    return (ac_index_state);
}

/*
==========================================================================
FUNCTION        :       do_new_cursor()
PURPOSE         :       deals with the shape of the cursor according to
                        char_height, cursor_start and cursor_end. See Tech
                        Memo 88.6.1 for details.
EXTERNAL OBJECTS:       EGA_GRAPH.cursor_start,EGA_GRAPH.cursor_height,EGA_cursor_start1,
                        EGA_GRAPH.cursor_height1,host_cursor_has_changed().
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

LOCAL void      do_new_cursor IFN0()
{

    note_entrance0("do_new_cursor()");

        #ifdef VGG
    if (video_adapter == VGA)
    {
        note_entrance0("VGA cursor");
        set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
        set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
        set_cursor_start1(0);   /* cursor never splits */
        set_cursor_height1(0);
        set_cursor_visible(TRUE);
        host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                 crt_controller.cursor_end.as_bfld.cursor_end);
    }
    else
    {
        #endif
        if (crt_controller.cursor_start.as_bfld.cursor_start >= (unsigned)get_char_height())
        {
            note_entrance0("No cursor");
            set_cursor_visible(FALSE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start | 0x20,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        else if (crt_controller.cursor_end.as_bfld.cursor_end == 0)
        {
            note_entrance0("cursor from start to bum");
            set_cursor_start1(0);
            set_cursor_height1(0);
            set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
            set_cursor_height(get_char_height() - get_cursor_start());
            set_cursor_visible(TRUE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        else if (crt_controller.cursor_end.as_bfld.cursor_end < crt_controller.cursor_start.as_bfld.cursor_start)
        {
            note_entrance0("2 cursors");
            set_cursor_start1(0);
            set_cursor_height1(crt_controller.cursor_end.as_bfld.cursor_end);
            set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
            set_cursor_height(get_char_height() - get_cursor_start());
            set_cursor_visible(TRUE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        else if (crt_controller.cursor_end.as_bfld.cursor_end == crt_controller.cursor_start.as_bfld.cursor_start)
        {
            note_entrance0("One line cursor");
            set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
            set_cursor_height(1);
            set_cursor_start1(0);
            set_cursor_height1(0);
            set_cursor_visible(TRUE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        else if (crt_controller.cursor_end.as_bfld.cursor_end - 1 >= (unsigned)get_char_height())
        {
            note_entrance0("block cursor");
            set_cursor_start(0);
            set_cursor_height(get_char_height());
            set_cursor_start1(0);
            set_cursor_height1(0);
            set_cursor_visible(TRUE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        else
        {
            assert2(((crt_controller.cursor_end.as_bfld.cursor_end - 1) >= crt_controller.cursor_start.as_bfld.cursor_start),
                    "cursor values do not match default set Start %d, End %d",
                    crt_controller.cursor_end.as_bfld.cursor_end,
                    crt_controller.cursor_start.as_bfld.cursor_start);
            note_entrance0("normal cursor");
            set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
            set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
            set_cursor_start1(0);
            set_cursor_height1(0);
            set_cursor_visible(TRUE);
            host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
                                     crt_controller.cursor_end.as_bfld.cursor_end);
        }
        #ifdef VGG
    }
        #endif

    if (( get_cur_y() < 0 ) ||
        ((( get_cur_y() + 1 ) * get_char_height()) > get_screen_height() ))
    {
        set_cursor_visible( FALSE );
    }

    base_cursor_shape_changed();
}

/*
==========================================================================
FUNCTION        :       do_chain_majority_decision()
PURPOSE         :       deals with any contention regarding whether the
                        ega registers indicate that the addressing of the
                        planes is in chained mode or not. If the result
                        of the election is a new addressing mode, then
                        the video routines, read mode and paint modules
                        are informed of the change.
EXTERNAL OBJECTS:       uses local ega register data to count votes.
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/


LOCAL void      do_chain_majority_decision IFN0()
{
    static  int     current_votes=0;
    int             new_votes;

    new_votes = sequencer.memory_mode.as_bfld.not_odd_or_even ? 0 : 1 ;     /* 0 - chained */
    new_votes += graphics_controller.mode.as_bfld.odd_or_even ;     /* 1 - chained */
    new_votes += graphics_controller.miscellaneous.as_bfld.odd_or_even ;    /* 1 - chained */

    if (new_votes == 1 && current_votes > 1)
    {
        /*
         * Transition from chained to unchained
         */

        EGA_CPU.chain  = UNCHAINED;
        setVideochain(EGA_CPU.chain);
        ega_read_routines_update();
        ega_write_routines_update(CHAINED);
        set_memory_chained(NO);
        flag_mode_change_required();
    }
    else
        if (new_votes > 1 && current_votes == 1)
    {
        /*
         * Transition from unchained to chained
         */

        EGA_CPU.chain = CHAIN2;
        setVideochain(EGA_CPU.chain);
        ega_read_routines_update();
        ega_write_routines_update(CHAINED);
        set_memory_chained(YES);
        flag_mode_change_required();
    }

    current_votes = new_votes;
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]                              */

/*
 * This structure should contain all the global definitions used by EGA
 */

struct  EGA_GLOBALS     EGA_GRAPH;
struct  EGA_CPU_GLOBALS EGA_CPU;

byte    *EGA_planes;

int ega_int_enable;

GLOBAL UTINY *ega_gc_outb_index_addr;


/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */

GLOBAL void
set_banking IFN2(UTINY, rd_bank, UTINY, wrt_bank)
{
    ULONG roffs, woffs;
        #ifdef PIG
    IMPORT ULONG pig_vid_bank;
        #endif

        #ifdef V7VGA
    if (get_seq_chain4_mode() && get_chain4_mode())
    {
        roffs = (ULONG)rd_bank << 16;
        woffs = (ULONG)wrt_bank << 16;
    }
    else
    {
        roffs = (ULONG)rd_bank << 18;
        woffs = (ULONG)wrt_bank << 18;
    }
        #else
    UNUSED(rd_bank);
    UNUSED(wrt_bank);
    roffs = 0;
    woffs = 0;
        #endif

        #ifdef PIG
    pig_vid_bank = woffs;
        #endif
    setVideorplane(EGA_planes + roffs);
    setVideowplane(EGA_planes + woffs);

        #ifdef  VGG
    if (get_256_colour_mode())
        setVideov7_bank_vid_copy_off(woffs >> 2);
    else
        #endif  /* VGG */
        setVideov7_bank_vid_copy_off(woffs >> 4);

        #ifdef GORE
    gd.max_vis_addr = get_screen_length() - 1 + woffs;
        #endif /* GORE */
}

GLOBAL void
update_banking IFN0()
{
    UTINY rd_bank, wrt_bank;

        #ifdef V7VGA
    v7_get_banks( &rd_bank, &wrt_bank );
        #else
    rd_bank = wrt_bank = 0;
        #endif

    set_banking( rd_bank, wrt_bank );
}

VOID
init_vga_globals IFN0()
{
    setVideov7_bank_vid_copy_off(0);
    setVideosr_lookup(sr_lookup);
    setVideovideo_copy(&video_copy[0]);
    setVideoscratch(sas_scratch_address(0x10000));
    setVideoscreen_ptr(EGA_planes);
    setVideorotate(0);
        #if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
            #ifndef CPU_40_STYLE    /* EVID */
    setVideomark_byte(_simple_mark_sml);
    setVideomark_word(_simple_mark_sml);
    setVideomark_string(_simple_mark_lge);
            #else
    SetMarkPointers(0);
            #endif  /* CPU_40_STYLE - EVID */
        #endif

    update_banking();
}

void    ega_init IFN0()
{
    note_entrance0("ega_init");
    /*
     * Define sequencer's ports
     */

    io_define_outb(EGA_SEQ_ADAP_INDEX,ega_seq_outb_index);
    io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
    io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_WRITE);
    io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_WRITE);

    /*
     * Define CRTC's ports
     */

    io_define_outb(EGA_CRTC_ADAPTOR,ega_crtc_outb);
    io_define_inb(EGA_CRTC_ADAPTOR,ega_crtc_inb);
    io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_WRITE);
    io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

    /*
     * Define Graphics Controller's ports
     */

    ega_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

    /*io_define_outb(EGA_GC_ADAP_INDEX,ega_gc_outb_index);*/
    io_define_out_routines(EGA_GC_ADAP_INDEX, ega_gc_outb_index, ega_gc_outw, NULL, NULL);

        #ifndef CPU_40_STYLE    /* TEMPORARY */
    Cpu_define_outb(EGA_GC_ADAP_INDEX,_ega_gc_outb_index);
        #endif

    io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
    Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);
        #ifndef A2CPU
    ega_gc_regs_cpu[8] = NULL;
        #endif

    io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_WRITE);
    io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_WRITE);

    /*
     * Define Attribute controller's ports
     */

    io_define_outb(EGA_AC_ADAPTOR,ega_ac_outb);
    io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_WRITE);
    io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_WRITE);

    /*
     * Define Miscellaneous register's port
     */

    io_define_outb(EGA_MISC_ADAPTOR,ega_misc_outb);
    io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);

    /*
     * Define Feature controller's port
     */

    io_define_outb(EGA_FEAT_ADAPTOR,ega_feat_outb);
    io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);

    /*
     * Define Input Status Register 0 port
     */

    io_define_inb(EGA_IPSTAT0_ADAPTOR,ega_ipstat0_inb);
    io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

    /*
     * Define Input Status Register 1 port
     */

    io_define_inb(EGA_IPSTAT1_ADAPTOR,ega_ipstat1_inb);
    io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

    /*
     * Initialise internals of EGA
     * +++++++++++++++++++++++++++
     */

    /* hardware reset sets Misc reg to 0, so.. */
    /* Perhaps this should be in 'ega_reset()'? */

    miscellaneous_output_register.as.abyte = 0;

    set_pc_pix_height(1); /* set by bit 7 of the misc reg */
    set_host_pix_height(1);

    /* Initialize address map */

    graphics_controller.miscellaneous.as.abyte = 0;
    graphics_controller.read_map_select.as_bfld.map_select = 0;

    /* Looking for bright white */

    graphics_controller.color_compare.as_bfld.color_compare = 0xf;

    /* All planes significant */

    graphics_controller.color_dont_care.as_bfld.color_dont_care = 0xf;

    /* Initialise crtc screen height fields and set screen height to be consistent */

    crt_controller.vertical_display_enable_end = 0;
    crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 = 0;

    set_screen_height(0);

    init_vga_globals();

    EGA_CPU.fun_or_protection = 1;  /* assume complicated until we know it's easy */

    setVideobit_prot_mask(0xffffffff);

    ega_write_init();
    ega_read_init();
    ega_mode_init();        /* sets a flag in ega_mode.c to allow optimisation of mode changes without falling over */

    /*
     * Some parts of input status register always return 1, so set fields accordingly
     */
    input_status_register_zero.as.abyte = 0x7f ;

    /*
     * set up some variables to get us going
     * (They may have to be changed in the fullness of time)
     */

    gvi_pc_low_regen  = CGA_REGEN_START;
    gvi_pc_high_regen = CGA_REGEN_END;

    choose_display_mode = choose_ega_display_mode;

    set_pix_width(1);
    set_pix_char_width(8);
    set_display_disabled(FALSE);

    set_char_height(8);
    set_screen_limit(0x8000);
    set_screen_start(0);
    set_word_addressing(YES);
    set_actual_offset_per_line(80);
    set_offset_per_line(160);       /* chained */
    set_horiz_total(80);    /* calc screen params from this and prev 3 */
    set_screen_split(511);  /* make sure there is no split screen to start with ! */

    set_prim_font_index(0);
    set_sec_font_index(0);

    set_regen_ptr(0,EGA_planes);

    /* prevent copyright message mysteriously disappearing */
    timer_video_enabled = TRUE;

}

void    ega_term IFN0()
{

    int     index;

    note_entrance0("ega_term");

    /*
     * Disconnect sequencer's ports
     */

    io_disconnect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX);
    io_disconnect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA);

    /*
     * Disconnect CRTC's ports
     */

    io_disconnect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR);
    io_disconnect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR);

    /*
     * Disconnect Graphics Controller's ports
     */

    io_disconnect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX);
    io_disconnect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA);

    /*
     * Disconnect Attribute controller's ports
     */

    io_disconnect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR);
    io_disconnect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR);

    /*
     * Disconnect Miscellaneous register's port
     */

    io_disconnect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR);

    /*
     * Disconnect Feature controller's port
     */

    io_disconnect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR);

    /*
     * Disconnect Input Status Register 0 port
     */

    io_disconnect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR);

    /*
     * Disconnect Input Status Register 1 port
     */

    io_disconnect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR);

    /*
     * Free internals of EGA
     */

    /* free the font files */
    for (index = 0; index < 4; index++)
        host_free_font(index);

    /* Disable CPU read processing */
    ega_read_term();
    ega_write_term();
}

LOCAL void      ega_seq_outb_index IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_outb_index(%x,%x)", port, value);
    assert1(value<5,"Bad seq index %d",value);
    NON_PROD(sequencer.address.as.abyte = value);
    io_redefine_outb(EGA_SEQ_ADAP_DATA,ega_seq_regs[value & 7]);
}

void    ega_seq_reset IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_reset(%x,%x)", port, value);
    /* change reset register */
    note_entrance0("reset register");
    sequencer.reset.as.abyte = value ;
    if (sequencer.reset.as_bfld.asynchronous_reset==0)
        set_bit_display_disabled(ASYNC_RESET);
    else
        clear_bit_display_disabled(ASYNC_RESET);
    if (sequencer.reset.as_bfld.synchronous_reset==0)
        set_bit_display_disabled(SYNC_RESET);
    else
        clear_bit_display_disabled(SYNC_RESET);
}

void    ega_seq_clock IFN2(io_addr, port, half_word, value)
{
    register unsigned dot_clock;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_clock(%x,%x)", port, value);
    /* clock mode register */
    dot_clock = sequencer.clocking_mode.as_bfld.dot_clock;
    sequencer.clocking_mode.as.abyte = value;
    if (sequencer.clocking_mode.as_bfld.dot_clock != dot_clock)
    {
        /*
        ** Switch to/from double width pixels
        */
        if (sequencer.clocking_mode.as_bfld.dot_clock==1)
        {
            set_pix_width(2);
            set_double_pix_wid(YES);
            set_pix_char_width(16);
        }
        else
        {
            set_pix_width(1);
            set_double_pix_wid(NO);
            set_pix_char_width(8);
        }
        flag_mode_change_required();
    }
}

void    ega_seq_map_mask IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_map_mask(%x,%x)", port, value);

    /* map mask register */

    /*
     * Different display plane(s) have been enabled. Update the video
     * routines to deal with this
     */

    setVideoplane_enable(value & 0xf);
    setVideoplane_enable_mask(sr_lookup[value & 0xf]);
    write_state.pe = ((value & 0xf) == 0xf) ? 1 : 0;
    setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);

    ega_write_routines_update(PLANES_ENABLED);
}

void    ega_seq_char_map IFN2(io_addr, port, half_word, value)
{
    register unsigned map_selects;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_char_map(%x,%x)", port, value);
    /* char map select reg */
    map_selects = sequencer.character_map_select.character.map_selects;
    sequencer.character_map_select.as.abyte = value;
    if (sequencer.character_map_select.character.map_selects != map_selects)
    {
        /*
        ** character mapping attributes have changed.
        **
        ** If fonts selected are different bit 3 of attribute byte in alpha mode
        ** selects which of the two fonts to use (giving 512 chars).
        */

        EGA_GRAPH.attrib_font_select = (sequencer.character_map_select.as_bfld.character_map_select_a !=
                                        sequencer.character_map_select.as_bfld.character_map_select_b );
        set_prim_font_index(sequencer.character_map_select.as_bfld.character_map_select_a);
        set_sec_font_index(sequencer.character_map_select.as_bfld.character_map_select_b);

        host_select_fonts(get_prim_font_index(), get_sec_font_index());
        flag_mode_change_required();
    }
}

void    ega_seq_mem_mode IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_seq_mem_mode(%x,%x)", port, value);

    /* mem mode register */

    sequencer.memory_mode.as.abyte = value ;

    /*
    ** Decide alpha/graphics mode by voting
     */
    vote_ega_mode();

    /*
     * See if this causes a by-election for plane addressing
     */

    do_chain_majority_decision();

    assert1(sequencer.memory_mode.as_bfld.extended_memory == 1,"Someone is trying to set extended memory to 0 (reg=%x)",value);
}

LOCAL void      ega_crtc_outb IFN2(io_addr, port, half_word, value)
{
    SHORT offset;
    struct
    {        /* avoid alignment problems with casts */
        unsigned value : 8;
    } new;
    static int old_underline_start;


    note_entrance2("ega_crtc_outb(%x,%x)", port, value);
    new.value = value;
    switch (port)
    {
    case 0x3d4:
        note_entrance1("New crtc index %d",value);
        crt_controller.address.as.abyte = value;
        break;
    case 0x3d5:
        note_entrance1( "Index %d", crt_controller.address.as_bfld.index );
        switch (crt_controller.address.as_bfld.index)
        {
        case 0:
            note_entrance0("horiz total");
            NON_PROD(crt_controller.horizontal_total = value);
            break;
        case 1:
            note_entrance0("horiz display end");
            crt_controller.horizontal_display_end = value+1;
            set_horiz_total(crt_controller.horizontal_display_end);
            break;
        case 2:
            note_entrance0("start horiz blank");
            NON_PROD(crt_controller.start_horizontal_blanking = value);
            break;
        case 3:
            note_entrance0("end horiz blank");
            NON_PROD(crt_controller.end_horizontal_blanking.as.abyte = value);
            break;
        case 4:
            note_entrance0("start horiz retrace");
            NON_PROD(crt_controller.start_horizontal_retrace = value);
            break;
        case 5:
            note_entrance0("end horiz retrace");
            NON_PROD(crt_controller.end_horizontal_retrace.as.abyte = value);
            break;
        case 6:
            note_entrance0("vert tot");
            NON_PROD(crt_controller.vertical_total = value);
            break;
        case 7:
            note_entrance0("overflow");
            if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 !=
                ((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8)
            {
                /*
                 * Screen height changed
                 */

        #ifdef VGG
                /*
                 * if VGG is set then the screen height
                 * definition is extended from 9 bits to
                 * 10. Thus the 9th bit is now a 'med'
                 * bit and not a 'hi' bit.
                 */
                set_screen_height_med_recal(
                                           ((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );
        #else
                set_screen_height_hi_recal(
                                          ((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );
        #endif
                flag_mode_change_required();
            }
            if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 !=
                ((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8)
            {
                /*
                 * split screen height changed
                 */

                EGA_GRAPH.screen_split.as_bfld.top_bit =
                ((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;

                if (!get_split_screen_used())
                    flag_mode_change_required();

                screen_refresh_required();
            }
            crt_controller.crtc_overflow.as.abyte = value;
            break;
        case 8:
            note_entrance0("preset row scan");
            NON_PROD(crt_controller.preset_row_scan.as.abyte = value);
            break;
        case 9:
            note_entrance0("max scan line");
            if (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line !=
                ((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)
            {
                set_char_height_recal(
                                     (((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)+1);
                do_new_cursor();
            }
            crt_controller.maximum_scan_line.as.abyte = value;
            break;
        case 10:
            note_entrance0("cursor start");
            if (crt_controller.cursor_start.as_bfld.cursor_start !=
                ((CURSOR_START*)&new)->as_bfld.cursor_start)
            {
                crt_controller.cursor_start.as.abyte = value;
                do_new_cursor();
            }
            break;
        case 11:
            note_entrance0("cursor end");
            if (crt_controller.cursor_end.as_bfld.cursor_end !=
                ((CURSOR_END*)&new)->as_bfld.cursor_end)
            {
                crt_controller.cursor_end.as.abyte = value;
                assert0(crt_controller.cursor_end.as_bfld.cursor_skew_control == 0,
                        "Someone is trying to use cursor skew");
                do_new_cursor();
            }
            break;
        case 12:
            note_entrance0("start address high");
            if (crt_controller.start_address_high != value)
            {
                set_screen_start((value << 8) + crt_controller.start_address_low);
                host_screen_address_changed(crt_controller.start_address_high,
                                            crt_controller.start_address_low);
                /* check if it wraps now */
                if (get_memory_chained())
                {
                    if ((get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_SZ)
                        choose_ega_display_mode();
                }
                else
                {
                    if (get_screen_start() + get_screen_length() > EGA_PLANE_SZ)
                        choose_ega_display_mode();
                }
                screen_refresh_required();
            }
            crt_controller.start_address_high = value;
            break;
        case 13:
            note_entrance0("start address low");
            if (crt_controller.start_address_low != value)
            {
                set_screen_start((crt_controller.start_address_high << 8) + value);
                host_screen_address_changed(crt_controller.start_address_high,
                                            crt_controller.start_address_low);
                /* check if it wraps now */
                if (get_memory_chained())
                {
                    if ((get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_SZ)
                        choose_ega_display_mode();
                }
                else
                {
                    if (get_screen_start() + get_screen_length() > EGA_PLANE_SZ)
                        choose_ega_display_mode();
                }
                screen_refresh_required();
            }
            crt_controller.start_address_low = value;
            break;
        case 14:
            note_entrance0("cursor loc high");
            if (crt_controller.cursor_location_high != value)
            {
                crt_controller.cursor_location_high = value;

                offset = (value<<8) | crt_controller.cursor_location_low;
                offset -= (short)get_screen_start();

                set_cur_x(offset % crt_controller.horizontal_display_end);
                set_cur_y(offset / crt_controller.horizontal_display_end);

                do_new_cursor();

                if (!get_mode_change_required() && is_it_text())
                    cursor_changed( get_cur_x(), get_cur_y());
            }
            break;
        case 15:
            note_entrance0("cursor loc lo");
            if (crt_controller.cursor_location_low != value)
            {
                crt_controller.cursor_location_low = value;

                offset = value | (crt_controller.cursor_location_high<<8);
                offset -= (short)get_screen_start();

                set_cur_x(offset % crt_controller.horizontal_display_end);
                set_cur_y(offset / crt_controller.horizontal_display_end);

                do_new_cursor();

                if (!get_mode_change_required() && is_it_text())
                    cursor_changed( get_cur_x(), get_cur_y());
            }
            break;
        case 16:
            note_entrance0("vert retrace start");
            NON_PROD(crt_controller.vertical_retrace_start = value);
            break;
        case 17:
            note_entrance0("vert retrace end");
            crt_controller.vertical_retrace_end.as.abyte = value;
            if ((value & 32) == 32)
                ega_int_enable = 0;
            else
                ega_int_enable = 1;
            if ((value & 16) != 16)
            {
                ica_clear_int(AT_EGA_VTRACE_ADAPTER,AT_EGA_VTRACE_INT);
                /*
                 * clear status latch
                 */
                input_status_register_zero.as_bfld.crt_interrupt = 0;        /* = !VS */
            }
            /* ??? */
            break;
        case 18:
            note_entrance0("vert disp enable end");
            if (crt_controller.vertical_display_enable_end != value)
            {
                crt_controller.vertical_display_enable_end = value;
                set_screen_height_lo_recal(value);
            }
            break;
        case 19:
            note_entrance0("offset");
            if (crt_controller.offset != value)
            {
                crt_controller.offset = value;
                set_actual_offset_per_line(value<<1);   /* actual offset into plane in bytes */
                flag_mode_change_required();
            }
            break;
        case 20:
            note_entrance0("underline loc");
            crt_controller.underline_location.as.abyte = value;
            if (value != old_underline_start)
            {
                old_underline_start = value;
                set_underline_start(
                                   crt_controller.underline_location.as_bfld.underline_location);
                screen_refresh_required();
            }
            break;
        case 21:
            note_entrance0("start vert blank");
            NON_PROD(crt_controller.start_vertical_blanking = value);
            break;
        case 22:
            note_entrance0("end vert blank");
            NON_PROD(crt_controller.end_vertical_blanking = value);
            break;
        case 23:
            note_entrance0("mode control");
            if (crt_controller.mode_control.as_bfld.compatibility_mode_support !=
                ((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support)
            {
                if ((((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support) == 0)
                    set_cga_mem_bank(YES);
                else    set_cga_mem_bank(NO);
                flag_mode_change_required();
            }
            if (crt_controller.mode_control.as_bfld.word_or_byte_mode !=
                ((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode)
            {
                set_word_addressing_recal(
                                         (((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode) == 0 );
            }
            crt_controller.mode_control.as.abyte = value;
            assert0(crt_controller.mode_control.as_bfld.select_row_scan_counter == 1,"Row scan 0");
            assert0(crt_controller.mode_control.as_bfld.horizontal_retrace_select == 0,
                    "retrace select 1");
            assert0(crt_controller.mode_control.as_bfld.output_control == 0,"output control set");
            assert0(crt_controller.mode_control.as_bfld.hardware_reset == 1,"hardware reset cleared");
            break;
        case 24:
            note_entrance0("line compare reg");
            if (crt_controller.line_compare != value)
            {
                crt_controller.line_compare = value;
                EGA_GRAPH.screen_split.as_bfld.low_byte = value;

                if (!get_split_screen_used())
                    flag_mode_change_required();

                screen_refresh_required();

            }
            break;
        default:
            assert1(NO,"Bad crtc index %d",crt_controller.address.as_bfld.index);
            break;
        }
        break;
    default:
        assert1(NO,"Bad port passed %x", port );
        break;
    }
}

LOCAL void      ega_crtc_inb IFN2(io_addr, port, half_word *, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance3("ega_crtc_inb(%x,%x) index %d", port, value, crt_controller.address.as_bfld.index);
    switch (crt_controller.address.as_bfld.index)
    {
    case    10:
        *value = (half_word)crt_controller.cursor_start.as.abyte ;
        note_entrance1("cursor start %d",*value);
        break;
    case    11:
        *value = (half_word)crt_controller.cursor_end.as.abyte ;
        note_entrance1("cursor end %d",*value);
        break;
    case    12:
        *value = crt_controller.start_address_high ;
        note_entrance1("start address high %x",*value);
        break;
    case    13:
        *value = crt_controller.start_address_low ;
        note_entrance1("start address low %x",*value);
        break;
    case    14:
        *value = crt_controller.cursor_location_high ;
        note_entrance1("cursor location high %x",*value);
        break;
    case    15:
        *value = crt_controller.cursor_location_low ;
        note_entrance1("cursor location low %x",*value);
        break;
    case    16:
        *value = 0;     /* light pen high */
        note_entrance1("light pen high %x",*value);
        break;
    case    17:
        *value = 0;     /* light pen low */
        note_entrance1("light pen low %x",*value);
        break;
    default:
        assert1(crt_controller.address.as_bfld.index>24,"inb from bad crtc index %d",crt_controller.address.as_bfld.index);
        *value = IO_EMPTY_PORT_BYTE_VALUE;
        break;
    }
}


void    ega_gc_outb_index IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_outb_index(%x,%x)", port, value);
    NON_PROD(graphics_controller.address.as.abyte = value);
    assert1(value<9,"Bad gc index %d",value);

    io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value & 15]);
    Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value & 15]);
}


/**/


/*( ega_gc_outw
**      Most PC programs do an "OUT DX, AX" which sets up the GC index
**      register with the AL and the GC data register with AH.
**      Avoid going through generic_outw() by doing it all here!
)*/
GLOBAL VOID ega_gc_outw IFN2(io_addr, port, word, outval)
{
    reg     temp;
    INT             value;

    temp.X = outval;
    value = temp.byte.low;

    NON_PROD(graphics_controller.address.as.abyte = value);

    assert1(value<9,"Bad gc index %#x", value);

    value &= 15;

    io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);
    Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);

    (*(ega_gc_regs[value]))((IU16)(port+1), temp.byte.high);
}


/**/


void    ega_gc_set_reset IFN2(io_addr, port, half_word, value)
{
    register unsigned set_reset;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_set_reset(%x,%x)", port, value);

    set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
    graphics_controller.set_or_reset.as.abyte = value;

    if (graphics_controller.set_or_reset.as_bfld.set_or_reset != set_reset)
    {
        EGA_CPU.set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
        ega_write_routines_update(SET_RESET);
    }
}

void    ega_gc_enable_set IFN2(io_addr, port, half_word, value)
{
    register unsigned en_set_reset;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_enable_set(%x,%x)", port, value);

    en_set_reset = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
    graphics_controller.enable_set_or_reset.as.abyte = value;

    if (graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset != en_set_reset)
    {
        EGA_CPU.sr_enable = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
        write_state.sr = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset==0?0:1;
        setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
        ega_write_routines_update(ENABLE_SET_RESET);
    }
}

void    ega_gc_compare IFN2(io_addr, port, half_word, value)
{
    register unsigned colour_compare;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_compare(%x,%x)", port, value);
    colour_compare = graphics_controller.color_compare.as_bfld.color_compare;
    graphics_controller.color_compare.as.abyte = value;
    if (graphics_controller.color_compare.as_bfld.color_compare != colour_compare)
    {
        read_state.colour_compare = (unsigned char)graphics_controller.color_compare.as_bfld.color_compare;
        if (read_state.mode == 1) ega_read_routines_update();
    }
}

void    ega_gc_rotate IFN2(io_addr, port, half_word, value)
{
    struct
    {
        unsigned value : 8;
    } new;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_rotate(%x,%x)", port, value);
    note_entrance0("data rotate");
    new.value = value;
    if (graphics_controller.data_rotate.as_bfld.rotate_count != ((DATA_ROTATE*)&new)->as_bfld.rotate_count)
    {
        setVideorotate(((DATA_ROTATE*)&new)->as_bfld.rotate_count);
        ega_write_routines_update(ROTATION);
    }

    if (graphics_controller.data_rotate.as_bfld.function_select != ((DATA_ROTATE*)&new)->as_bfld.function_select)
    {
        write_state.func = ((DATA_ROTATE*)&new)->as_bfld.function_select;
        setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
        ega_write_routines_update(FUNCTION);
    }
    EGA_CPU.fun_or_protection = (value != 0) || write_state.bp;
    graphics_controller.data_rotate.as.abyte = value;
}

void    ega_gc_read_map IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_read_map(%x,%x)", port, value);

    setVideoread_mapped_plane(value & 3);

    update_shift_count();
}

void    ega_gc_mode IFN2(io_addr, port, half_word, value)
{
    MODE new_mode;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_set_reset(%x,%x)", port, value);
    new_mode.as.abyte = value;
    if (graphics_controller.mode.as_bfld.write_mode != new_mode.as_bfld.write_mode)
    {
        /*
         * write mode change
         */

        EGA_CPU.write_mode = (unsigned char)new_mode.as_bfld.write_mode;
        setVideowrmode(EGA_CPU.write_mode);
        ega_write_routines_update(WRITE_MODE);
    }

    if (graphics_controller.mode.as_bfld.read_mode != new_mode.as_bfld.read_mode)
    {
        /*
         * read mode change
         */
        read_state.mode = new_mode.as_bfld.read_mode;
        ega_read_routines_update();
    }

    if (graphics_controller.mode.as_bfld.shift_register_mode != new_mode.as_bfld.shift_register_mode)
    {
        /*
         * going to/from one cga graphics mode to another
         */
        set_graph_shift_reg(new_mode.as_bfld.shift_register_mode);
        flag_mode_change_required();
    }

    graphics_controller.mode.as.abyte = new_mode.as.abyte;

    /*
     * Check for any change to chained mode rule by having an election
     * (Note: EGA registers must be updated before calling election)
     */

    do_chain_majority_decision();

    assert0(graphics_controller.mode.as_bfld.test_condition == 0,"Test conditon set");
}

void    ega_gc_misc IFN2(io_addr, port, half_word, value)
{
    register unsigned memory_map;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_misc(%x,%x)", port, value);
    memory_map = graphics_controller.miscellaneous.as_bfld.memory_map;
    graphics_controller.miscellaneous.as.abyte = value;
    if (graphics_controller.miscellaneous.as_bfld.memory_map != memory_map)
    {
        /*
         * Where EGA appears in PC memory space changed.
        */
        if (miscellaneous_output_register.as_bfld.enable_ram)
            sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

        switch (graphics_controller.miscellaneous.as_bfld.memory_map)
        {
        case 0:
            gvi_pc_low_regen = 0xA0000;
            gvi_pc_high_regen = 0xBFFFF;
            break;
        case 1:
            gvi_pc_low_regen = 0xA0000;
            gvi_pc_high_regen = 0xAFFFF;
            break;
        case 2:
            gvi_pc_low_regen = 0xB0000;
            gvi_pc_high_regen = 0xB7FFF;
            break;
        case 3:
            gvi_pc_low_regen = 0xB8000;
            gvi_pc_high_regen = 0xBFFFF;
            break;
        }

        if (miscellaneous_output_register.as_bfld.enable_ram)
            sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

        /*
         * Tell cpu associated modules that regen area has moved
         */

        ega_read_routines_update();
        ega_write_routines_update(RAM_MOVED);
    }

    /*
    ** Vote on alpha/graphics mode.
     */
    vote_ega_mode();

    /*
     * Check for any change to chained mode rule by having an election
     * (Note: EGA registers must be updated before calling election)
     */

    do_chain_majority_decision();
}

void    ega_gc_dont_care IFN2(io_addr, port, half_word, value)
{
    register unsigned colour_dont_care;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_dont_care(%x,%x)", port, value);
    colour_dont_care = graphics_controller.color_dont_care.as_bfld.color_dont_care;
    graphics_controller.color_dont_care.as.abyte = value;
    if (graphics_controller.color_dont_care.as_bfld.color_dont_care != colour_dont_care)
    {
        read_state.colour_dont_care = (unsigned char)graphics_controller.color_dont_care.as_bfld.color_dont_care;
        if (read_state.mode == 1) ega_read_routines_update();
    }
}

/*
 * The EGA mask register is written to more times than all other ports added together!
 * To help make this register fast, we have two different routines to handle it:
 * ega_gc_mask for when the register's current value is not 0xFF, ie. masking is active
 * ega_gc_mask_ff for when the mask register = 0xFF, so masking is disabled.
 */

/*(
** ega_mask_register_changed
**      This gets called whenever the mask register gets changed, and
**      updates the internals appropriately. Since the mask registers
**      are hit more than any other registers, this should do the job!
**
**      Rather than calling the monster ega_write_routines_update() (in "ega_write.c"),
**      we do as little as we possibly can here!
**      In particular, all we do is set the video write pointer handlers
**      to the appropriate one and update the internal EGA_CPU state...
**
**      We DON'T do anything about altering the marking funcs, etc.
**
**      See also "vga_mask_register_changed" in "vga_ports.c"
**
**      NB: GLOBAL for JOKER.
**
)*/
        #include        "cpu_vid.h"

IMPORT void Glue_set_vid_wrt_ptrs (WRT_POINTERS * handler );

GLOBAL VOID ega_mask_register_changed IFN1(BOOL, gotBitProtection)
{
    ULONG                           state;
    SAVED IU8                       masks[] = {0x1f, 0x01, 0x0f, 0x0f};
    IMPORT WRT_POINTERS     *mode_chain_handler_table[];
        #ifdef V7VGA
    IMPORT  UTINY           Last_v7_fg_bg, fg_bg_control;
        #endif

    write_state.bp = gotBitProtection;
    setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
    EGA_CPU.fun_or_protection = (gotBitProtection || (graphics_controller.data_rotate.as.abyte != 0));

    /* Check that we're not trying to handle any pathological cases here...
    ** This means we chicken out for Chain2 and V7VGA dithering.
    */

    if ((EGA_CPU.chain == CHAIN2)
        #ifdef V7VGA
        || ( Last_v7_fg_bg != fg_bg_control)
        #endif /* V7VGA */
       )
    {
        ega_write_routines_update(BIT_PROT);

        return;
    }

    /* the "mode_0" union variant has the largest "lookup" field (5 bits.) */

    state = EGA_CPU.ega_state.mode_0.lookup & masks[EGA_CPU.write_mode];

        #ifdef A3CPU
            #ifdef C_VID
    Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
            #else
    Cpu_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
            #endif /* C_VID */
        #else
            #if !(defined(NTVDM) && defined(MONITOR))
    Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
            #endif /* !(NTVDM && MONITOR) */
        #endif /* A3CPU */

    EGA_CPU.saved_state = state;
}


/**/


/* ega_gc_mask is the one that is usually called */

LOCAL void      ega_gc_mask IFN2(io_addr, port, half_word, value)
{
    register unsigned int mask;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_mask(%x,%x)", port, value);

    /*
     * Update video routine according to new bit protection
     */

    mask = value | (((USHORT)value) << 8);
    mask |= (mask << 16);   /* replicate the mask into 4 bytes */
    setVideobit_prot_mask(mask);
    setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
    setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);
    if (value == 0xff)
    {
        #ifndef USE_OLD_MASK_CODE
        ega_mask_register_changed(/*bit protection :=*/0);
        #else
        write_state.bp = 0;
        setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
        EGA_CPU.fun_or_protection = (graphics_controller.data_rotate.as.abyte != 0);
        ega_write_routines_update(BIT_PROT);
        #endif  /* USE_OLD_MASK_CODE */

        /* Alter the function table used by ega_gc_index */
        ega_gc_regs[8] = ega_gc_mask_ff;

        #ifndef CPU_40_STYLE    /* TEMPORARY */
            #ifndef A2CPU
        /* Alter the function table used by assembler ega_gc_index */
        ega_gc_regs_cpu[8] = _ega_gc_outb_mask_ff;
            #endif
        #endif

        io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_mask_ff);

        #ifndef CPU_40_STYLE    /* TEMPORARY */
        Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask_ff);
        #endif
    }
}

/* This version isn't called so often */
void    ega_gc_mask_ff IFN2(io_addr, port, half_word, value)
{
    register unsigned int mask;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_gc_mask(%x,%x)", port, value);

    /*
     * Update video routine according to new bit protection
     */

    if (value != 0xff)
    {
        mask = value | (((USHORT)value) << 8);
        mask |= (mask << 16);   /* replicate the mask into 4 bytes */
        setVideobit_prot_mask(mask);
        setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
        setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);
        #ifndef USE_OLD_MASK_CODE
        ega_mask_register_changed(/*bit protection :=*/1);
        #else
        write_state.bp = 1;
        setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
        EGA_CPU.fun_or_protection = TRUE;
        ega_write_routines_update(BIT_PROT);
        #endif  /* USE_OLD_MASK_CODE*/

        /* Alter the function table used by ega_gc_index */
        ega_gc_regs[8] = ega_gc_mask;

        #ifndef CPU_40_STYLE    /* TEMPORARY */
            #ifndef A2CPU
        /* Alter the function table used by assembler ega_gc_index */
        ega_gc_regs_cpu[8] = _ega_gc_outb_mask;
            #endif
        #endif

        io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_mask);

        #ifndef CPU_40_STYLE    /* TEMPORARY */
        Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask);
        #endif
    }
}

LOCAL void      ega_index_invalid IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
    UNUSED(value);
        #endif
    note_entrance2("ega_index_invalid(%x,%x)", port, value);
    assert1(NO,"Invalid index %d",graphics_controller.address.as_bfld.index);
}

LOCAL void      ega_ac_outb IFN2(io_addr, port, half_word, value)
{
    struct
    {
        unsigned value : 8;
    } new;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_ac_outb(%x,%x)", port, value);
    assert1( port == EGA_AC_INDEX_DATA || port == EGA_AC_SECRET, "Bad port %x", port);
    new.value = value;
    if (in_index_state())
    {
        note_entrance1("Setting index to %d", value);
        attribute_controller.address.as.abyte = value;
    }
    else
    {
        switch (attribute_controller.address.as_bfld.index)
        {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
/*
 *              A real EGA monitor behaves in a strange way:
 *              When it is in 200 scan line mode (vertical_retrace_polarity = 0)
 *              it emulates a CGA monitor - not just in screen resolution, but also
 *              in the way it inteprets the colour signals:
 *              Instead of having 6 colour signals: RGBrgb,
 *              it has 4, RGBI. The Intensity signal is on the same input pin as the secondary green signal.
 */
            note_entrance1("Change palette %d",attribute_controller.address.as_bfld.index);
            attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte = value;
            if (miscellaneous_output_register.as_bfld.vertical_retrace_polarity)
            {
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].red =
                get_palette_color(red,secondary_red);
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].green =
                get_palette_color(green,secondary_green);
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].blue =
                get_palette_color(blue,secondary_blue);
            }
            else
            {
                /* Interpret secondary_green as intensity */
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].red =
                get_palette_color(red,secondary_green);
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].green =
                get_palette_color(green,secondary_green);
                EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].blue =
                get_palette_color(blue,secondary_green);
            }
            host_set_palette(EGA_GRAPH.palette,EGA_PALETTE_SIZE);
            break;
        case 16:
            note_entrance0("mode control reg");
            if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink !=
                ((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink)
            {
                set_intensity( ((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink );
            }

            attribute_controller.mode_control.as.abyte = value;

            if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink)
                /* blinking - not supported */
                bg_col_mask = 0x70;
            else
                /* using blink bit to provide 16 background colours */
                bg_col_mask = 0xf0;

            /*
             ** Vote on alpha/graphics mode
             */
            vote_ega_mode();
            assert0(attribute_controller.mode_control.as_bfld.display_type == 0, "Mono display selected");
            assert0(attribute_controller.mode_control.as_bfld.enable_line_graphics_char_codes == 0,
                    "line graphics enabled");
            break;
        case 17:
            note_entrance0("set border");
            attribute_controller.overscan_color.as.abyte = value;
            EGA_GRAPH.border[RED] = get_border_color(red_border,secondary_red_border);
            EGA_GRAPH.border[GREEN] = get_border_color(green_border,secondary_green_border);
            EGA_GRAPH.border[BLUE] = get_border_color(blue_border,secondary_blue_border);
            host_set_border_colour(value);
            break;
        case 18:
            note_entrance1("color plane enable %x",value);
            if (attribute_controller.color_plane_enable.as_bfld.color_plane_enable !=
                ((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable)
            {
                set_plane_mask(((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable);
                host_change_plane_mask(get_plane_mask());       /* Update Host palette */
            }
            attribute_controller.color_plane_enable.as.abyte = value;
            break;
        case 19:
            note_entrance0("horiz pel panning");
            NON_PROD(attribute_controller.horizontal_pel_panning.as.abyte = value);
            break;
        default:
            assert1(NO,"Bad ac index %d", attribute_controller.address.as_bfld.index);
            break;
        }
    }
}

LOCAL void      ega_misc_outb IFN2(io_addr, port, half_word, value)
{
    MISC_OUTPUT_REG new;

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance2("ega_misc_outb(%x,%x)", port, value);
    assert1(port==EGA_MISC_REG,"Bad port %x",port);
    new.as.abyte = value;
    if (miscellaneous_output_register.as_bfld.enable_ram != new.as_bfld.enable_ram)
    {
        /*
         * writes to plane memory en/disabled
         */

        note_entrance0("Ram enabled");
        if (new.as_bfld.enable_ram)
            sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
        else
            sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

        EGA_CPU.ram_enabled = new.as_bfld.enable_ram;
        ega_read_routines_update();
        ega_write_routines_update(RAM_ENABLED);
    }

    if (miscellaneous_output_register.as_bfld.vertical_retrace_polarity !=
        new.as_bfld.vertical_retrace_polarity)
    {
        /*
         * Going to/from CGA monitor compatibility mode
         * if this bit is set, it means that the pixels are 'stretched' vertically.
         */

        set_pc_pix_height( new.as_bfld.vertical_retrace_polarity ? 1 : 2);
        flag_mode_change_required();
    }

    miscellaneous_output_register.as.abyte = new.as.abyte;

    set_bit_display_disabled(miscellaneous_output_register.as_bfld.disable_internal_video_drivers ? VIDEO_DRIVERS_DISABLED : 0);

    /*
     * register value used by ipsr0 to find out the index into the switches
     * so that correct switch setting can be returned.
     */
}

LOCAL void      ega_feat_outb IFN2(io_addr, port, half_word, value)
{
        #ifdef PROD
    UNUSED(port);
    UNUSED(value);
        #endif
    note_entrance2("ega_feat_outb(%x,%x)", port, value);
    NON_PROD(feature_control_register.as.abyte = value);
}

LOCAL void      ega_ipstat0_inb IFN2(io_addr, port, half_word *, value)
{
        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance1("ega_ipstat0_inb(%x)", port);
    input_status_register_zero.as_bfld.switch_sense =

    /* The following function call used to pass the argument
    ** miscellaneous_output_register.as_bfld.clock_select
    ** but the function expects no argument so it was removed.
    */
    get_ega_switch_setting();
    *value = (half_word)input_status_register_zero.as.abyte;
    note_entrance1("returning %x",*value);
}

LOCAL void      ega_ipstat1_inb IFN2(io_addr, port, half_word *, value)
{

    /*
     * The whole of this routine has been nicked from the cga without modification
     * The s_lengths array should probably be altered for the ega timings, and somewhere
     * an interrupt should be fired off.
     */

    static int ega_state = 0;       /* current ega status state */
    static int state_count = 1;     /* position in that state */
    static int sub_state = 0;       /* sub state for ega state 2 */

    static unsigned long gmfudge = 17; /* Random number seed for pseudo-random
                                          bitstream generator to give the state                                           lengths below that 'genuine' feel to
                                          progs that require it! */
    register unsigned long h;

    /*
     * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
     */

    static int s_lengths[] = { 8, 18, 8, 6};

    /*
     * Status register, simulated adapter has
     *
     *  bit                     setting
     *  ---                     -------
     *  Display enable             1/0 Toggling each inb
     *  Light Pen                  0
     *  Light Pen                  0
     *  Vertical Sync              1/0 Toggling each inb
     *  4-7 Unused                 0,0,0,0
     *
     * The upper nibble of the byte is always set.
     * Some programs synchronise with the display by waiting for the
     * next vertical retrace.
     *
     * We attempt to follow the following waveform
     *
     *    --                                                     ----------
     * VS  |_____________________________________________________|        |____
     *
     *
     *    -------------  -   -                           ------------------
     * DE             |__||__||__ ... about 180         _|
     *
     *State|--- 0 ----|-------------- 1 -----------------|-- 3 --|-- 4 --|
     *
     * We do this with a 4 state machine. Each state has a count associated
     * with it to represent the relative time spent in each state. When this
     * count is exhausted the machine moves into the next state. One Inb
     * equals 1 count. The states are as follows:
     *     0: VS low, DE high.
     *     1: VS low, DE toggles. This works via an internal state.
     *     3: VS low, DE high.
     *     4: VS high,DE high.
     *
     */

        #ifdef PROD
    UNUSED(port);
        #endif
    note_entrance1("ega_ipstat1_inb(%x)", port);
    note_entrance2("ega_ipstat1_inb(%x,%x)", port, value);

    set_index_state();  /* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */

    state_count --;     /* attempt relative 'timings' */
    switch (ega_state)
    {

    case 0:
        if (state_count == 0)
        { /* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
            state_count = s_lengths[1] + (gmfudge & 3);
            ega_state = 1;
        }
        input_status_register_zero.as_bfld.crt_interrupt = 1;   /* = !VS */
        *value = 0xf1;
        break;

    case 1:
        if (state_count == 0)
        { /* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
            state_count = s_lengths[2] + (gmfudge & 3);
            ega_state = 2;
            sub_state = 2;
        }
        switch (sub_state)
        {    /* cycle through 0,0,1 sequence */
        case 0:         /* to represent DE toggling */
            *value = 0xf0;
            sub_state = 1;
            break;
        case 1:
            *value = 0xf0;
            sub_state = 2;
            break;
        case 2:
            *value = 0xf1;
            sub_state = 0;
            break;
        }
        input_status_register_zero.as_bfld.crt_interrupt = 1;   /* = !VS */
        break;

    case 2:
        if (state_count == 0)
        { /* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
            state_count = s_lengths[3] + (gmfudge & 3);
            ega_state = 3;
        }
        *value = 0xf1;
        input_status_register_zero.as_bfld.crt_interrupt = 1;   /* = !VS */
        break;

    case 3:
        if (state_count == 0)
        { /* wrap back to first state */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
            state_count = s_lengths[0] + (gmfudge & 3);
            ega_state = 0;
        }
        input_status_register_zero.as_bfld.crt_interrupt = 0;   /* = !VS */
        *value = 0xf9;
        break;
    }
    note_entrance1("returning %x",*value);
}

LOCAL   void    vote_ega_mode IFN0()
{
    static  int     old_votes = 3;
    int     votes;

    votes = sequencer.memory_mode.as_bfld.alpha_mode ? 0 : 1;
    votes += graphics_controller.miscellaneous.as_bfld.graphics_mode;
    votes += attribute_controller.mode_control.as_bfld.graphics_mode;
    assert1( votes == 3 || votes == 0, "Headline: Mode government returned with small majority %d", votes);
    if ((old_votes < 2) && (votes >= 2))
    {
        /* change to graphics mode */
        set_text_mode(NO);
        flag_mode_change_required();
    }
    else if ((old_votes >= 2) && (votes < 2))
    {
        /* change to text mode */
        set_text_mode(YES);
        flag_mode_change_required();
    }
    old_votes = votes;
}

        #ifdef HUNTER

/* Get line compare value */

int ega_get_line_compare IFN0()

{
    int         return_value;

    return_value = crt_controller.line_compare;
    if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 != 0)
        return_value += 0x100;
    return (return_value);
}                   /* ega_get_line_compare */

/* Get maximum scan lines value */

int ega_get_max_scan_lines IFN0()

{
    return (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line);
}                   /* ega_get_max_scan_lines */

/* Set line compare value */

void ega_set_line_compare IFN1(int, lcomp_val)
{
    CRTC_OVERFLOW       new_overflow;

    new_overflow.as.abyte = crt_controller.crtc_overflow.as.abyte;
    if (lcomp_val >= 0x100)
        new_overflow.as_bfld.line_compare_bit_8 = 1;
    else
        new_overflow.as_bfld.line_compare_bit_8 = 0;

    outb(EGA_CRTC_INDEX, 7);
    outb(EGA_CRTC_DATA, new_overflow.as.abyte);
    outb(EGA_CRTC_INDEX, 24);
    outb(EGA_CRTC_DATA, lcomp_val & 0xff);
}

        #endif /* HUNTER */
    #endif /* EGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_mode.c ===
#include "insignia.h"
#include "host_def.h"
/*                      INSIGNIA (SUB)MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DESIGNER                : S.Frost

REVISION HISTORY        :
First version           : 12 Aug 1988, J.Roper

SOURCE FILE NAME        : ega_mode.c

PURPOSE                 : To decide which mode the EGA is in according to variables set in ega_ports.c and
                           to choose the appropriate update and paint routines accordingly.

SccsID[]="@(#)ega_mode.c        1.26 06/01/95 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

        INCLUDE FILE : ega_mode.gi

[1.1    INTERMODULE EXPORTS]

        PROCEDURES() :  choose_ega_display_mode

        DATA         :  uses EGA_GRAPH.display_state which is set in ega_ports.c, to
                        determine what memory organisation the display side is in, and
                        hence what sort of update and paint routines to use.

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

        STRUCTURES/TYPEDEFS/ENUMS:

uses    enum DISPLAY_STATE which is declared in ega_graph.pi.

uses    EGA_GRAPH structure for global variables set by the ports and
        used by the display.

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

        PROCEDURES() : vote_ega_mode()
                        host_set_paint_routine(DISPLAY_MODE)

        DATA         : EGA_GRAPH struct.

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]

=========================================================================
PROCEDURE         :     choose_ega_display_mode

PURPOSE           :     To decide which memory organisation is being used by the
                        ega, and to pick the best update and paint routines accordingly.
                        The paint routines are host specific, and so the memory organisation
                        is indicated by an enum (called DISPLAY_MODE), describing each sort
                        of memory organisation.

PARAMETERS        :     none

GLOBALS           :     uses EGA_GRAPH struct, specially display_state to decide which mode is being used.

=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                                               */


#ifndef REAL_VGA
    #ifdef  EGG

/* [3.1.1 #INCLUDES]                                                    */

        #include        "xt.h"
        #include        "error.h"
        #include        "config.h"
        #include        "gvi.h"
        #include        "egacpu.h"
        #include        "debug.h"
        #include        "gmi.h"
        #include        "gfx_upd.h"
        #include        "egagraph.h"
        #include        "vgaports.h"
        #include        "egaports.h"
        #include        "host_gfx.h"

        #ifdef GORE
            #include        "gore.h"
        #endif /* GORE */

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]                                            */

        #include        "egamode.h"

boolean (*choose_display_mode)();

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

/* [5.1.1 #DEFINES]                                                     */
        #ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
            #include "SOFTPC_EGA.seg"
        #endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */

/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */

/*
=========================================================================
PROCEDURE         :     set_up_screen_ptr()

PURPOSE           :     Decide which plane the information must come from for displaying

PARAMETERS        :     none

GLOBALS           :     uses EGA_GRAPH struct, plane_mask to decide which planes are enabled

=========================================================================
*/

LOCAL VOID
set_up_screen_ptr()
{
    if (get_memory_chained())
    {
        if (plane01_enabled())
            set_screen_ptr(EGA_plane01);
        else
            if (plane23_enabled())
                set_screen_ptr(EGA_plane23);
            else
                assert0(NO,"No planes enabled for chain mode");
    }
    else
        set_screen_ptr(EGA_planes);
}

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

GLOBAL  DISPLAY_MODE    choose_mode[] = {

    /* unchained, no cga mem bank, no shift reg */

    EGA_HI,                 /* 350 height, no pixel doubling */
    EGA_HI_WR,              /* 350 height, no pixel doubling */
    EGA_HI_SP,              /* 350 height, no pixel doubling */
    EGA_HI_SP_WR,           /* 350 height, no pixel doubling */

    EGA_MED,                /* 200 height, no pixel doubling */
    EGA_MED_WR,             /* 200 height, no pixel doubling */
    EGA_MED_SP,             /* 200 height, no pixel doubling */
    EGA_MED_SP_WR,          /* 200 height, no pixel doubling */

    EGA_HI_FUN,             /* 350 height, pixel doubling */
    EGA_HI_FUN,             /* 350 height, pixel doubling */
    EGA_HI_FUN,             /* 350 height, pixel doubling */
    EGA_HI_FUN,             /* 350 height, pixel doubling */

    EGA_LO,                 /* 200 height, pixel doubling */
    EGA_LO_WR,              /* 200 height, pixel doubling */
    EGA_LO_SP,              /* 200 height, pixel doubling */
    EGA_LO_SP_WR,           /* 200 height, pixel doubling */

    /* unchained, no cga_mem_bank, shift reg */

    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,

    EGA_MED_FUN,
    EGA_MED_FUN,
    EGA_MED_FUN,
    EGA_MED_FUN,

    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,

    EGA_LO_FUN,
    EGA_LO_FUN,
    EGA_LO_FUN,
    EGA_LO_FUN,

    /* unchained, cga_mem_bank, no shift reg */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI,                 /* 200 height, no pixel doubling, the real bios mode */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, wrap */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, split screen */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, split screen, wrap */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    /* unchained, cga_mem_bank, shift reg */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    /* chained, no cga_mem_bank, no shift reg */

    EGA_TEXT_80,                    /* 350 scan lines */
    EGA_TEXT_80_WR,                 /* 350 scan lines */
    EGA_TEXT_80_SP,                 /* 350 scan lines */
    EGA_TEXT_80_SP_WR,              /* 350 scan lines */

    CGA_TEXT_80,                    /* 200 scan lines */
    CGA_TEXT_80_WR,                 /* 200 scan lines */
    CGA_TEXT_80_SP,                 /* 200 scan lines */
    CGA_TEXT_80_SP_WR,              /* 200 scan lines */

    EGA_TEXT_40,                    /* 350 scan lines */
    EGA_TEXT_40_WR,                 /* 350 scan lines */
    EGA_TEXT_40_SP,                 /* 350 scan lines */
    EGA_TEXT_40_SP_WR,              /* 350 scan lines */

    CGA_TEXT_40,                    /* 200 scan lines */
    CGA_TEXT_40_WR,                 /* 200 scan lines */
    CGA_TEXT_40_SP,                 /* 200 scan lines */
    CGA_TEXT_40_SP_WR,              /* 200 scan lines */

    /* chained, no cga_mem_bank, shift reg */

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    /* chained, cga mem bank, no shift reg */

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    /* chained, cga mem banks shift reg */

    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, wrap */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, split */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, wrap split */

    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */

    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */

    CGA_MED,                        /* proper bios mode */
    CGA_MED_FUN,                    /* proper bios mode, wrap */
    CGA_MED_FUN,                    /* proper bios mode, split */
    CGA_MED_FUN,                    /* proper bios mode, split, wrap */


    /* text mode(!), unchained, no cga mem bank, no shift reg
    ** we think the textness overrides the unchainedness
    */

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    /* unchained, no cga_mem_bank, shift reg */

    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,

    EGA_MED_FUN,
    EGA_MED_FUN,
    EGA_MED_FUN,
    EGA_MED_FUN,

    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,
    EGA_HI_FUN,

    EGA_LO_FUN,
    EGA_LO_FUN,
    EGA_LO_FUN,
    EGA_LO_FUN,

    /* unchained, cga_mem_bank, no shift reg */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI,                 /* 200 height, no pixel doubling, the real bios mode */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, wrap */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, split screen */
    CGA_HI_FUN,             /* 200 height, no pixel doubling, the real bios mode, split screen, wrap */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    /* unchained, cga_mem_bank, shift reg */

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,
    CGA_HI_FUN,

    /* chained, no cga_mem_bank, no shift reg */

    EGA_TEXT_80,                    /* 350 scan lines */
    EGA_TEXT_80_WR,                 /* 350 scan lines */
    EGA_TEXT_80_SP,                 /* 350 scan lines */
    EGA_TEXT_80_SP_WR,              /* 350 scan lines */

    CGA_TEXT_80,                    /* 200 scan lines */
    CGA_TEXT_80_WR,                 /* 200 scan lines */
    CGA_TEXT_80_SP,                 /* 200 scan lines */
    CGA_TEXT_80_SP_WR,              /* 200 scan lines */

    EGA_TEXT_40,                    /* 350 scan lines */
    EGA_TEXT_40_WR,                 /* 350 scan lines */
    EGA_TEXT_40_SP,                 /* 350 scan lines */
    EGA_TEXT_40_SP_WR,              /* 350 scan lines */

    CGA_TEXT_40,                    /* 200 scan lines */
    CGA_TEXT_40_WR,                 /* 200 scan lines */
    CGA_TEXT_40_SP,                 /* 200 scan lines */
    CGA_TEXT_40_SP_WR,              /* 200 scan lines */

    /* chained, no cga_mem_bank, shift reg */

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,
    TEXT_80_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,
    TEXT_40_FUN,

    /* chained, cga mem bank, no shift reg */

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,
    CGA_MED_FUN,

    /* chained, cga mem banks shift reg */

    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, wrap */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, split */
    CGA_MED_FUN,                    /* not 200 scan lines and not double pix width, wrap split */

    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */
    CGA_MED_FUN,                    /* not double pix width */

    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */
    CGA_MED_FUN,                    /* not 200 scan lines */

    CGA_MED,                        /* proper bios mode */
    CGA_MED_FUN,                    /* proper bios mode, wrap */
    CGA_MED_FUN,                    /* proper bios mode, split */
    CGA_MED_FUN,                    /* proper bios mode, split, wrap */

};

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */

LOCAL void ega_dummy_calc IFN0()
{
}

static  void    set_update_routine(mode)
DISPLAY_MODE    mode;
{
        #ifndef NTVDM
    static int last_height = 200;

    if (last_height != get_screen_height())
    {
        last_height = get_screen_height();
    }
    note_entrance1("set_update_routine called for mode %s", get_mode_string(mode) );
    switch (mode)
    {
    case EGA_TEXT_40_SP_WR:
    case EGA_TEXT_80_SP_WR:
    case CGA_TEXT_40_SP_WR:
    case CGA_TEXT_80_SP_WR:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        set_gfx_update_routines( ega_wrap_split_text_update, SIMPLE_MARKING, NO_SCROLL );
        host_update_fonts();
        break;
    case EGA_TEXT_40_SP:
    case EGA_TEXT_80_SP:
    case CGA_TEXT_40_SP:
    case CGA_TEXT_80_SP:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        set_gfx_update_routines( ega_split_text_update, SIMPLE_MARKING, NO_SCROLL );
        host_update_fonts();
        break;
    case EGA_TEXT_40_WR:
    case EGA_TEXT_80_WR:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        assert1( get_screen_height() == 350, "screen height %d for text mode", get_screen_height() );
        set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
        host_update_fonts();
        break;
    case EGA_TEXT_40:
    case EGA_TEXT_80:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        assert1( get_screen_height() == 350, "screen height %d for text mode", get_screen_height() );
        set_gfx_update_routines( ega_text_update, SIMPLE_MARKING, TEXT_SCROLL );
        host_update_fonts();
        break;
    case CGA_TEXT_40_WR:
    case CGA_TEXT_80_WR:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
        set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
        host_update_fonts();
        break;
    case CGA_TEXT_40:
    case CGA_TEXT_80:
        assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
        assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
        set_gfx_update_routines( text_update, SIMPLE_MARKING, CGA_TEXT_SCROLL );
        host_update_fonts();
        break;
    case CGA_MED:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
        set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
        break;
    case CGA_HI:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
        set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
        break;
    case EGA_HI_WR:
    case EGA_MED_WR:
    case EGA_LO_WR:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
        set_gfx_update_routines( ega_wrap_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
        break;
    case EGA_HI:
    case EGA_MED:
    case EGA_LO:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
            #ifdef GORE
        set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
            #else
        set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
            #endif /* GORE */
        break;
    case EGA_HI_SP_WR:
    case EGA_MED_SP_WR:
    case EGA_LO_SP_WR:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
        set_gfx_update_routines( ega_wrap_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
        break;
    case EGA_HI_SP:
    case EGA_MED_SP:
    case EGA_LO_SP:
        assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
        set_gfx_update_routines( ega_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
        break;
    case TEXT_40_FUN:
    case TEXT_80_FUN:
        assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
        do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
        set_gfx_update_routines( text_update, SIMPLE_MARKING, NO_SCROLL );
        host_update_fonts();
        break;
    case CGA_HI_FUN:
        assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
        do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
        set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
        break;
    case CGA_MED_FUN:
        assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
        do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
        set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
        break;
    case EGA_HI_FUN:
    case EGA_MED_FUN:
    case EGA_LO_FUN:
        assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
        do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
            #ifdef GORE
        set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, NO_SCROLL );
            #else
        set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
            #endif /* GORE */
        break;
    case DUMMY_FUN:
        assert0(NO,"Using the dummy mode!!");
        set_gfx_update_routines( ega_dummy_calc, SIMPLE_MARKING, NO_SCROLL );
        break;
    default:
        assert1(NO,"Bad display mode %d", (int) mode );
        break;
    }
        #endif /* NTVDM */
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]                              */

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */



void    ega_mode_init()
{
    /*
    ** This bit moved here from ega_video_init(), since it's all about
    ** the emulation of the video hardware, not the video BIOS.
    **      WJG 22/8/90
    ** Set the host graphics paint function to match the base update
    ** function and the PC graphics mode.
    ** Normally the host gfx func is not set until the next timer tick
    ** as the mode change can involve quite a lot of Intel instructions.
    ** However when booting SoftPC the EGA is going into a known mode.
    ** This was added to fix a convoluted Fatal bug.
    ** 1) Enter a gfx mode in EGA.
    ** 2) Reset SoftPC.
    ** 3) Bring up the disk panel as soon as you can.
    ** 4) SoftPC crashes.
    ** Cause: Because SoftPC was in gfx mode the paint function remains
    ** a gfx mode paint function even though SoftPC thinks it is now in
    ** text mode. When the panel is displayed a full screen update is
    ** forced which then gets too confused and dies.
    */
    set_update_routine(DUMMY_FUN);
}


boolean choose_ega_display_mode()
{
    DISPLAY_MODE    mode;
    int     old_offset;

    note_entrance0("choose ega display mode");

    /*
     * offset_per_line depends upon whether chained addressing is being used. This is
     * because we interleave the planes, rather than anything the EGA does.
     */

    old_offset = get_offset_per_line();
    if (get_memory_chained())
    {
        set_offset_per_line_recal(get_actual_offset_per_line() << 1);
    }
    else
    {
        set_offset_per_line_recal(get_actual_offset_per_line());
    }

    /*
     * If the offset has actually changed, repaint the whole screen
     */

    if (old_offset != get_offset_per_line())
        screen_refresh_required();

    /*
     * It is possible that the display hardware will wrap the plane addressing. This occurs
     * when the screen_start plus the screen_length are longer than the plane length.
     * When in chained mode there is two planes length before wrapping occurs.
     */

    if (get_memory_chained())
    {
        set_screen_can_wrap( (get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_DISP_SIZE );
    }
    else
    {
        set_screen_can_wrap( get_screen_start() + get_screen_length() > EGA_PLANE_DISP_SIZE );
    }

    /*
     * split screen comes into operation when screen_split is less than screen height
     * split screen used is used as part of munge_index.
     */

    set_split_screen_used( get_screen_split() < get_screen_height() );

    /*
     * For the purposes of choosing a mode set up boolean values for chars per line (to help
     * select the correct text mode), and screen height (to select EGA resolution).
     */

    set_200_scan_lines( (get_screen_height()/get_pc_pix_height()) == 200 );

    /*
     * Set up the appropriate update routine according to the memory organisation selected
     * and return an indication of whether more than 1 plane can be used by the display.
     *
     * Note that in chained mode plane01 is considered to be one plane. Similarly for plane23
     *
     * We have to be careful that a nasty program, such as EGA-PICS, hasn't set up a ridiculously big
     * screen size for the CGA modes (presumably caused by us being unlucky when the timer tick goes off).
     */
    if (is_it_cga() && get_screen_length() > 0x4000)
        mode = DUMMY_FUN;
    else
        mode = choose_mode[get_munged_index()];

    /*
     * Now set up screen pointers appropriately.
     */

    set_up_screen_ptr();

    set_update_routine(mode);

    /*
     * set up the paint routine to correspond with the memory organisation and the update routine
     * (this bit is host specific)
     */

    host_set_paint_routine(mode,get_screen_height());

    /*
     * The screen needs refreshing, because the update and paint routines have changed.
     * Indicate to the update routines that the next time they are called, they must update
     * the whole screen
     */

    screen_refresh_required();
    return (TRUE);
}

    #endif /* EGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_trcr.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SccsID @(#)ega_tracer.c	1.7 8/25/93 Copyright Insignia Solutions
 *    Set of routines to output all accesses to the EGA, in a form that
 *    can be read in & executed by the stand-alone EGA.
 *
 */


#ifdef EGA_DUMP

#include <stdio.h>
#include TypesH

#include "xt.h"
#include "sas.h"
#include "gmi.h"
#include "egatrace.h"
#include "egaports.h"
#include "gfx_upd.h"
#include CpuH

IMPORT VOID host_applClose IPT0();

static FILE *dump_file;
mem_handlers dump_writes;

static void putl(addr,dest_file)
byte *addr;
FILE *dest_file;
{
	sys_addr addr_m = addr-M;

	putc(addr_m & 0xff,dest_file);
	addr_m >>= 8;
	putc(addr_m & 0xff,dest_file);
	addr_m >>= 8;
	putc(addr_m & 0xff,dest_file);
}

dump_inb(port)
int port;
{
	putc(INB,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
}

dump_inw(port)
int port;
{
	putc(INW,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
}

dump_outb(port,value)
int port,value;
{
	putc(OUTB,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
	putc(value,dump_file);
}

dump_outw(port,value)
int port,value;
{
	putc(OUTW,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
	putc(value & 0xff,dump_file);
	putc((value >> 8),dump_file);
}

boolean	dump_b_write(addr)
host_addr addr;
{
	putc(WRITE_BYTE,dump_file);
	putl(addr,dump_file);
	putc(*addr,dump_file);

	(*dump_writes.b_write)(addr);
}

boolean	dump_w_write(addr)
host_addr addr;
{
	putc(WRITE_WORD,dump_file);
	putl(addr,dump_file);
	putc(*addr,dump_file);
	putc(*(addr+1),dump_file);

	(*dump_writes.w_write)(addr);
}

boolean	dump_b_fill(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	putc(FILL_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putc(*l_addr,dump_file);

	(*dump_writes.b_fill)(l_addr,h_addr);
}

boolean	dump_w_fill(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	putc(FILL_WORD,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putc(*l_addr,dump_file);
	putc(*(l_addr+1),dump_file);

	(*dump_writes.w_fill)(l_addr,h_addr);
}

boolean	dump_b_move(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	host_addr i;

	putc(MOVE_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putl(haddr_of_src_string,dump_file);
	for(i=l_addr;i<=h_addr;i++)
	{
		putc(*i,dump_file);
	}

	(*dump_writes.b_move)(l_addr,h_addr);
}

boolean	dump_w_move(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	host_addr i;

	putc(MOVE_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putl(haddr_of_src_string,dump_file);
	for(i=l_addr;i<=h_addr;i++)
	{
		putc(*i,dump_file);
	}

	(*dump_writes.w_move)(l_addr,h_addr);
}

dump_tick()
{
	putc(TICK,dump_file);
}

dump_scroll(mode,direction,video_addr,video_off,video_cols,lr,tc,rd,cd,lines,attr)
byte mode,direction;
sys_addr video_addr;
word video_off,video_cols;
byte lr,tc,rd,cd,lines,attr;
{
	putc(SCROLL,dump_file);
	putc(mode,dump_file);
	putc(direction,dump_file);
	putl(video_addr,dump_file);
	putc(video_off,dump_file);
	putc(video_off >> 8,dump_file);
	putc(video_cols,dump_file);
	putc(lr,dump_file);
	putc(tc,dump_file);
	putc(rd,dump_file);
	putc(cd,dump_file);
	putc(lines,dump_file);
	putc(attr,dump_file);
}


static	void	recalc_dump(),byte_read_dump(),word_read_dump(),string_read_dump();

struct READ_POINTERS
  {
	void (*recalc_read) ();
	void (*byte_read) ();
	void (*word_read) ();
	void (*string_read) ();
  } dump_read_pointers = { recalc_dump, byte_read_dump, word_read_dump,
				string_read_dump };

extern	struct	READ_POINTERS	read_pointers;

/*
 * cpu read handlers
 * rely on C being called if read_pointer.xxxx_read
 * does not point at byte_read_mode0
 */

static	void	recalc_dump()
{
	printf("recalc dump called!!!\n");
}

static	void	byte_read_dump(addr)
byte	*addr;
{
	putc(READ_BYTE,dump_file);
	putl(addr,dump_file);
	(*dump_read_pointers.byte_read)(addr);
}

static	void	word_read_dump(addr)
byte	*addr;
{
	putc(READ_WORD,dump_file);
	putl(addr,dump_file);
	(*dump_read_pointers.word_read)(addr);
}

static	void	string_read_dump(laddr,haddr)
byte	*laddr,*haddr;
{
	putc(READ_STRING,dump_file);
	putl(laddr,dump_file);
	putl(haddr,dump_file);
	putc(getDF(),dump_file);
	(*dump_read_pointers.string_read)(laddr,haddr);
}

dump_read_pointers_init()
{
	read_pointers = dump_read_pointers;
}

dump_change_read_pointers(ptr)
struct	READ_POINTERS	*ptr;
{
	dump_read_pointers = *ptr;
}

static mem_handlers catch_writes = 
	{dump_b_write,dump_w_write,dump_b_fill,dump_w_fill,dump_b_move,dump_w_move};

void	dump_add_checkpoint()
{
	putc(CHECKPT,dump_file);
}

dump_init(file_name,type)
char *file_name;
char type;
{
	dump_file = fopen(file_name,"w");
	if(dump_file == NULL)
	{
		host_applClose();
		printf("ARRGGH can't open %s\n",file_name);
		exit(1);
	}
	putc(type,dump_file);

	dump_writes = vid_handlers;
	gmi_define_mem(VIDEO,&catch_writes);
}

dump_end()
{
	fclose(dump_file);
}

#endif

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_writ.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS	: include all relevant references

DESIGNER		: J.Roper

REVISION HISTORY	:
First version		: 7/22/88 W.Gulland

SUBMODULE NAME		: ega_write		

SOURCE FILE NAME	: ega_write.c

PURPOSE			: control the way writes to EGA memory is emulated.
			  This module looks at the state of the EGA when it is changed
			  via writes to the EGA registers, and works out what to do about it.
		
		
SccsID = @(#)ega_write.c	1.40 12/15/95 Copyright Insignia Solutions Ltd.

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#include <stdio.h>
#include TypesH
#include FCntlH

#ifdef EGG
#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"cpu_vid.h"
#include	"video.h"


/* [3.1.2 DECLARATIONS]                                                 */
#if defined(EGA_DUMP) || defined(EGA_STAT)
extern WRT_POINTERS dump_writes;
#endif

extern WRT_POINTERS mode0_gen_handlers, mode0_copy_handlers;
extern WRT_POINTERS mode1_handlers, mode2_handlers;

/* [3.2 INTERMODULE EXPORTS]						*/

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

#ifndef REAL_VGA

#ifdef V7VGA
IMPORT UTINY fg_bg_control;
GLOBAL UTINY Last_v7_fg_bg;			/* used by {ev}ga_mask_register_changed() */
#endif

#ifndef CPU_40_STYLE	/* EVID without introducing EVID define */

WRT_POINTERS *mode_chain_handler_table[] =
{
	&mode_table.nch.mode_0[0],
	&mode_table.nch.mode_1[0],
	&mode_table.nch.mode_2[0],
#ifdef VGG
	&mode_table.nch.mode_3[0],
#endif

	&mode_table.nch.mode_0[0],		/* This should be chain 2 eventually */
	&mode_table.nch.mode_1[0],		/* This should be chain 2 eventually */
	&mode_table.nch.mode_2[0],		/* This should be chain 2 eventually */
#ifdef VGG
	&mode_table.nch.mode_3[0],		/* This should be chain 2 eventually */
#endif

#ifdef VGG
	&mode_table.ch4.mode_0[0],
	&mode_table.ch4.mode_1[0],
	&mode_table.ch4.mode_2[0],
	&mode_table.ch4.mode_3[0],
#endif /* VGG */
};
	
#ifndef EGATEST
IMPORT VOID glue_b_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID glue_w_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID glue_b_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID glue_w_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID glue_b_move IPT4(UTINY *, laddr, UTINY *, haddr, UTINY *, src, UTINY, src_type);
IMPORT VOID glue_w_move IPT3(UTINY *, laddr, UTINY *, haddr, UTINY *, src);

#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
IMPORT VOID _glue_b_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID _glue_w_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID _glue_b_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID _glue_w_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID _glue_b_fwd_move IPT0();
IMPORT VOID _glue_b_bwd_move IPT0();
IMPORT VOID _glue_w_fwd_move IPT0();
IMPORT VOID _glue_w_bwd_move IPT0();

GLOBAL WRT_POINTERS Glue_writes =
{
	_glue_b_write,
	_glue_w_write

#ifndef	NO_STRING_OPERATIONS
	,
	_glue_b_fill,
	_glue_w_fill,
	_glue_b_fwd_move,
	_glue_b_bwd_move,
	_glue_w_fwd_move,
	_glue_w_bwd_move

#endif	/* NO_STRING_OPERATIONS */

};

GLOBAL WRT_POINTERS C_vid_writes;
#endif /* C_VID */
#else

#ifdef A_VID
IMPORT VOID _glue_b_write();
IMPORT VOID _glue_w_write();
IMPORT VOID _glue_b_fill();
IMPORT VOID _glue_w_fill();
IMPORT VOID _glue_b_move();
IMPORT VOID _glue_w_move();

GLOBAL MEM_HANDLERS Glue_writes =
{
	_glue_b_write,
	_glue_w_write,
	_glue_b_fill,
	_glue_w_fill,
	_glue_b_move,
	_glue_w_move,
};

GLOBAL WRT_POINTERS A_vid_writes;

#else

GLOBAL MEM_HANDLERS Glue_writes =
{
	glue_b_write,
	glue_w_write,
	glue_b_fill,
	glue_w_fill,
	glue_b_move,
	glue_w_move,
};

GLOBAL WRT_POINTERS C_vid_writes;
#endif /* C_VID */
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */

IMPORT VOID _simple_b_write();
IMPORT VOID _simple_w_write();
IMPORT VOID _simple_b_fill();
IMPORT VOID _simple_w_fill();
IMPORT VOID _simple_bf_move();
IMPORT VOID _simple_wf_move();
IMPORT VOID _simple_bb_move();
IMPORT VOID _simple_wb_move();

WRT_POINTERS simple_writes =
{
	_simple_b_write,
	_simple_w_write
#ifndef	NO_STRING_OPERATIONS
	,
	_simple_b_fill,
	_simple_w_fill,
	_simple_bf_move,
	_simple_bb_move,
	_simple_wf_move,
	_simple_wb_move

#endif	/* NO_STRING_OPERATIONS */
};

IMPORT VOID _dt0_bw_nch();
IMPORT VOID _dt0_ww_nch();
IMPORT VOID _dt0_bf_nch();
IMPORT VOID _dt0_wf_nch();
IMPORT VOID _vid_md0_bfm_0_8();
IMPORT VOID _vid_md0_bbm_0_8();
IMPORT VOID _vid_md0_wfm_0_8();
IMPORT VOID _vid_md0_wbm_0_8();

IMPORT VOID _dt2_bw_nch();
IMPORT VOID _dt2_ww_nch();
IMPORT VOID _dt2_bf_nch();
IMPORT VOID _dt2_wf_nch();
IMPORT VOID _vid_md2_bfm_0_8();
IMPORT VOID _vid_md2_bbm_0_8();
IMPORT VOID _vid_md2_wfm_0_8();
IMPORT VOID _vid_md2_wbm_0_8();

IMPORT VOID _dt3_bw_nch();
IMPORT VOID _dt3_ww_nch();
IMPORT VOID _dt3_bf_nch();
IMPORT VOID _dt3_wf_nch();
IMPORT VOID _vid_md3_bfm_0_8();
IMPORT VOID _vid_md3_bbm_0_8();
IMPORT VOID _vid_md3_wfm_0_8();
IMPORT VOID _vid_md3_wbm_0_8();

WRT_POINTERS dth_md0_writes =
{
	_dt0_bw_nch,
	_dt0_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt0_bf_nch,
	_dt0_wf_nch,
	_vid_md0_bfm_0_8,
	_vid_md0_bbm_0_8,
	_vid_md0_wfm_0_8,
	_vid_md0_wbm_0_8

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS dth_md2_writes =
{
	_dt2_bw_nch,
	_dt2_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt2_bf_nch,
	_dt2_wf_nch,
	_vid_md2_bfm_0_8,
	_vid_md2_bbm_0_8,
	_vid_md2_wfm_0_8,
	_vid_md2_wbm_0_8
#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS dth_md3_writes =
{
	_dt3_bw_nch,
	_dt3_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt3_bf_nch,
	_dt3_wf_nch,
	_vid_md3_bfm_0_8,
	_vid_md3_bbm_0_8,
	_vid_md3_wfm_0_8,
	_vid_md3_wbm_0_8

#endif	/* NO_STRING_OPERATIONS */

};

#else	/* CPU_40_STYLE - EVID */
WRT_POINTERS *mode_chain_handler_table[] = { 0 };
#ifdef C_VID

/* C_Evid glue */
extern void  write_byte_ev_glue IPT2(IU32, eaOff, IU8, eaVal);
extern void  write_word_ev_glue IPT2(IU32, eaOff, IU16, eaVal);
extern void  fill_byte_ev_glue IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void  fill_word_ev_glue IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void  move_byte_fwd_ev_glue IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void  move_word_fwd_ev_glue IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
MEM_HANDLERS Glue_writes =
{
	write_byte_ev_glue,
	write_word_ev_glue,
	fill_byte_ev_glue,
	fill_word_ev_glue,
	move_byte_fwd_ev_glue,
	move_word_fwd_ev_glue,
};
#else	/* C_VID */
/* no glue required */
MEM_HANDLERS Glue_writes = { 0, 0, 0, 0, 0, 0 };
#endif	/* CVID */
WRT_POINTERS dth_md0_writes;
WRT_POINTERS dth_md2_writes;
WRT_POINTERS simple_writes;
WRT_POINTERS dth_md3_writes;
#endif	/* CPU_40_STYLE - EVID */

IMPORT VOID ega_copy_b_write(ULONG, ULONG);
IMPORT VOID ega_mode0_chn_b_write(ULONG, ULONG);
IMPORT VOID ega_mode1_chn_b_write(ULONG, ULONG);
IMPORT VOID ega_mode2_chn_b_write(ULONG, ULONG);

IMPORT VOID ega_copy_w_write(ULONG, ULONG);
IMPORT VOID ega_mode0_chn_w_write(ULONG, ULONG);
IMPORT VOID ega_mode1_chn_w_write(ULONG, ULONG);
IMPORT VOID ega_mode2_chn_w_write(ULONG, ULONG);

/* Handy array to extract all 4 plane values in one go. */

ULONG sr_lookup[16] =
{
#ifdef LITTLEND
	0x00000000,0x000000ff,0x0000ff00,0x0000ffff,
	0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,
	0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,
	0xffff0000,0xffff00ff,0xffffff00,0xffffffff
#endif
#ifdef BIGEND
	0x00000000,0xff000000,0x00ff0000,0xffff0000,
	0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,
	0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,
	0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff
#endif
};

GLOBAL VOID
stub IFN0()
{
	/*
	 * For VGA write modes we don't do because they represent
	 * unlikely combinations of registers.
	 */
}

GLOBAL ULONG calc_data_xor;
GLOBAL ULONG calc_latch_xor;

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if !(defined(NTVDM) && defined(MONITOR))
GLOBAL VOID
Glue_set_vid_wrt_ptrs IFN1(WRT_POINTERS *, handler )
{

#ifndef CPU_40_STYLE	/* EVID */
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID

	C_vid_writes.b_write = handler->b_write;
	C_vid_writes.w_write = handler->w_write;
	C_vid_writes.b_fill = handler->b_fill;
	C_vid_writes.w_fill = handler->w_fill;
	C_vid_writes.b_fwd_move = handler->b_fwd_move;
	C_vid_writes.b_bwd_move = handler->b_bwd_move;
	C_vid_writes.w_fwd_move = handler->w_fwd_move;
	C_vid_writes.w_bwd_move = handler->w_bwd_move;

#else
	UNUSED(handler);
#endif /* C_VID */
#else
#ifdef C_VID

	C_vid_writes.b_write = handler->b_write;
	C_vid_writes.w_write = handler->w_write;

#ifndef	NO_STRING_OPERATIONS

	C_vid_writes.b_fill = handler->b_fill;
	C_vid_writes.w_fill = handler->w_fill;
	C_vid_writes.b_fwd_move = handler->b_fwd_move;
	C_vid_writes.b_bwd_move = handler->b_bwd_move;
	C_vid_writes.w_fwd_move = handler->w_fwd_move;
	C_vid_writes.w_bwd_move = handler->w_bwd_move;

#endif	/* NO_STRING_OPERATIONS */

#else

	A_vid_writes = *handler;

#if	0
	A_vid_writes.b_write = handler->b_write;
	A_vid_writes.w_write = handler->w_write;

#ifndef	NO_STRING_OPERATIONS

	A_vid_writes.b_fill = handler->b_fill;
	A_vid_writes.w_fill = handler->w_fill;
	A_vid_writes.b_fwd_move = handler->b_fwd_move;
	A_vid_writes.b_bwd_move = handler->b_bwd_move;
	A_vid_writes.w_fwd_move = handler->w_fwd_move;
	A_vid_writes.w_bwd_move = handler->w_bwd_move;

#endif	/* NO_STRING_OPERATIONS */
#endif	/* 0 */

#endif /* C_VID */
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif 	/* CPU_40_STYLE - EVID */
}
#endif /* !(NTVDM && MONITOR) */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

/*  Initialize the write module */

VOID
ega_write_init IFN0()
{
#ifndef NEC_98
	WRT_POINTERS *handler;

	note_entrance0("ega_write_init");

	EGA_CPU.saved_state = 0;
	EGA_CPU.write_mode = 0;
	EGA_CPU.chain = UNCHAINED;
	setVideochain(EGA_CPU.chain);
	setVideowrmode(EGA_CPU.write_mode);
	setVideowrstate(0);

	handler = &mode_chain_handler_table[0][0];

#ifdef CPU_40_STYLE
	/* ensure correct write mode in place for initial font writes */
	SetWritePointers();
#endif

#ifdef	JOKER

	Glue_set_vid_wrt_ptrs(handler);

#else	/* not JOKER */

#if defined(EGA_DUMP) || defined(EGA_STAT)
	dump_writes = handler;
#else
#ifdef EGATEST
	gmi_define_mem(VIDEO,(*handler));
#else
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_wrt_ptrs( &Glue_writes );	
	Glue_set_vid_wrt_ptrs( handler );
#else
	Cpu_set_vid_wrt_ptrs( handler );	
#endif /* C_VID */
#else
	gmi_define_mem(VIDEO,&Glue_writes);
	Glue_set_vid_wrt_ptrs( handler );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */
#endif /* EGA_DUMP || EGA_STAT */
#endif /* JOKER */

	ega_write_routines_update(WRITE_MODE);
	ega_write_routines_update(RAM_MOVED);
	ega_write_routines_update(RAM_ENABLED);
	ega_write_routines_update(SET_RESET);
	ega_write_routines_update(ENABLE_SET_RESET);
	ega_write_routines_update(FUNCTION);
#endif  //NEC_98
}

VOID
ega_write_term IFN0()
{
#ifndef NEC_98
	/*
	 * ensure that if you are an EGA and then change to a VGA (or vice
	 * versa) the write mode will be changed by the new adaptor. Otherwise
	 * this gives a 'drunken' font
	 */

	EGA_CPU.write_mode = 0;
	EGA_CPU.ega_state.mode_0.lookup =
				(EGA_CPU.ega_state.mode_0.lookup == 0) ? 1 : 0;
	setVideowrmode(EGA_CPU.write_mode);

	ega_write_routines_update(WRITE_MODE);
#endif  //NEC_98
}


/* analyze the write state, and update the routines if necesary */

VOID
ega_write_routines_update IFN1(CHANGE_TYPE, reason )
{
#ifndef NEC_98
	ULONG state;
	ULONG mode_and_chain;
	WRT_POINTERS *handler;
#ifndef PROD
	LOCAL WRT_POINTERS *last_handler;
#endif

	note_entrance1("ega_write_routines_update(%d)",reason);

	switch( reason )
	{
		case FUNCTION:
			switch (write_state.func)
			{
				case 0:	/* Assign */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(~(getVideobit_prot_mask()));
					setVideolatch_xor_mask(getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0xffffffff;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;

				case 1:	/* AND */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(~(getVideobit_prot_mask()));
					setVideolatch_xor_mask(0);
					EGA_CPU.calc_data_xor = 0xffffffff;
					EGA_CPU.calc_latch_xor = 0x00000000;
					break;

				case 2:	/* OR */
					setVideodata_and_mask(0);
					setVideodata_xor_mask(0xffffffff);
					setVideolatch_xor_mask(
						getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0x00000000;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;

				case 3:	/* XOR */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(0xffffffff);
					setVideolatch_xor_mask(
						getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0x00000000;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;
			}

			setVideocalc_data_xor(EGA_CPU.calc_data_xor);
			setVideocalc_latch_xor(EGA_CPU.calc_latch_xor);
			break;

		case WRITE_MODE:
			/* write mode 3 has set/reset enabled for all planes
			 * so recalulate the mask ignoring the sr_enable register
			 * otherwise set the mask in case mode 3 last time.
			 */
			if( EGA_CPU.write_mode == 3) {
				setVideosr_nmask(0);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_nmask(~sr_lookup[EGA_CPU.sr_enable]);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case SET_RESET:
			EGA_CPU.sr_value= sr_lookup[EGA_CPU.set_reset];
			if( EGA_CPU.write_mode == 3) {
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case ENABLE_SET_RESET:
			if( EGA_CPU.write_mode == 3) {
				setVideosr_nmask(0);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_nmask(~sr_lookup[EGA_CPU.sr_enable]);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case PLANES_ENABLED:
			if (EGA_CPU.chain == CHAIN2)
			{
				if( getVideoplane_enable() & 0xc )
				{
					setVideorplane(EGA_plane23);
					setVideowplane(EGA_plane23);
				}
				else
				{
					setVideorplane(EGA_plane01);
					setVideowplane(EGA_plane01);
				}
			}
			break;

		case CHAINED:
			switch( EGA_CPU.chain )
			{
				case UNCHAINED:
				case CHAIN4:
					update_banking();
					break;

				case CHAIN2:
					if( getVideoplane_enable() & 0xc )
					{
						setVideorplane(EGA_plane23);
						setVideowplane(EGA_plane23);
					}
					else
					{
						setVideorplane(EGA_plane01);
						setVideowplane(EGA_plane01);
					}
					break;
			}

			break;

		case RAM_MOVED:
		case RAM_ENABLED:
		case BIT_PROT:
			/* No action required */
			break;
				
/*
 * Rotates are only partially supported in Avid and Cvid.
 * Mode 0 unchained byte writes are supported.  Word writes are also
 * supported in this case, as they use the byte write routines.
 *
 * Manage Your Money is the only application currently known to use rotates,
 * as of 22 Jan 1993.
 */
		case ROTATION:
			if (getVideorotate() > 0)
			{
#ifdef CPU_40_STYLE
				/* Write pointer change required but probably
				 * no state change otherwise.
				 */
				SetWritePointers();
#endif
				always_trace3("Possible unsupported data rotate mode %d chain %d rotate by %d",
				               EGA_CPU.write_mode,
					       EGA_CPU.chain, getVideorotate());
			}
			break;
				
		default:
			assert0( NO, "Bad reason in ega_write_routines_update" );
			break;
	}

	/*
	 * Now select the right set of write routines according to the current state.
	 */

	switch( EGA_CPU.write_mode )
	{
		case 0:
			state = EGA_CPU.ega_state.mode_0.lookup;
			break;

		case 1:
			state = EGA_CPU.ega_state.mode_1.lookup;
			break;

		case 2:
			state = EGA_CPU.ega_state.mode_2.lookup;
			break;

#ifdef VGG
		case 3:
			state = EGA_CPU.ega_state.mode_3.lookup;
			break;
#endif /* VGG */

		default:
			assert1( NO, "Bad write mode %d\n", EGA_CPU.write_mode );
			break;
	}

#ifdef VGG
	mode_and_chain = (EGA_CPU.chain << 2) + EGA_CPU.write_mode;
#else
	mode_and_chain = (EGA_CPU.chain * 3) + EGA_CPU.write_mode;
#endif /* VGG */

	if(( EGA_CPU.saved_mode_chain != mode_and_chain )
		|| ( EGA_CPU.saved_state != state )
#ifdef V7VGA
		|| ( Last_v7_fg_bg != fg_bg_control)
#endif /* V7VGA */
		)
	{
		setVideowrmode(EGA_CPU.write_mode);	/* reset for 'copy case' below */

		if( EGA_CPU.chain == CHAIN2 )
			switch (EGA_CPU.write_mode)
			{
				case 0:
					if( state == 0 )	/* basic text */
					{
						handler = &mode0_copy_handlers;
#ifdef CPU_40_STYLE
						setVideowrmode(4);	/* indicate 'copy case' */
#endif	/* CPU_40_STYLE */
						bios_ch2_byte_wrt_fn = ega_copy_b_write;
						bios_ch2_word_wrt_fn = ega_copy_w_write;
					}
					else
					{
						handler = &mode0_gen_handlers;
						bios_ch2_byte_wrt_fn = ega_mode0_chn_b_write;
						bios_ch2_word_wrt_fn = ega_mode0_chn_w_write;
					}
					break;

				case 1:
					handler = &mode1_handlers;
					bios_ch2_byte_wrt_fn = ega_mode1_chn_b_write;
					bios_ch2_word_wrt_fn = ega_mode1_chn_w_write;
					break;

				case 2:
				case 3:	/* We don't support mode 3, chain 2 - JS */
					handler = &mode2_handlers;
					bios_ch2_byte_wrt_fn = ega_mode2_chn_b_write;
					bios_ch2_word_wrt_fn = ega_mode2_chn_w_write;
					break;
			}
		else
		{
#ifdef	V7VGA
			/*
			 *	Is it the V7VGA foreground dithering extension ?
			 */

			if( fg_bg_control & 0x8 )
			{
				setVideodither(1);	/* enable Evid dither fns */
				switch( EGA_CPU.write_mode )
				{
					case 0:
						handler = &dth_md0_writes;
						break;
					
					case 1:

						/*
						 *	No fg dither variant for write mode 1
						 */

						handler = &mode_chain_handler_table[mode_and_chain][state];
						break;
					
					case 2:
						handler = &dth_md2_writes;
						break;
					
					case 3:
						handler = &dth_md3_writes;
						break;
				}
			}
			else
#endif	/* V7VGA */
				setVideodither(0);	/* disable Evid dither fns */

				handler = &mode_chain_handler_table[mode_and_chain][state];
		}

#ifdef CPU_40_STYLE
		SetWritePointers();
#else  /* CPU_40_STYLE */

#if defined(EGA_DUMP) || defined(EGA_STAT)
		dump_writes = handler;
#else
		/* Tell the glue code about the new write routines */

#ifdef EGATEST
		gmi_redefine_mem(VIDEO,(*handler));
#else
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
		Glue_set_vid_wrt_ptrs( handler );
#else
		Cpu_set_vid_wrt_ptrs( handler );	
#endif /* C_VID */
#else
		Glue_set_vid_wrt_ptrs( handler );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */
#endif

#endif	/* CPU_40_STYLE */

#ifndef PROD
		last_handler = handler;
#endif

		set_mark_funcs();

		EGA_CPU.saved_state = state;
		EGA_CPU.saved_mode_chain = mode_and_chain;
#ifdef V7VGA
		Last_v7_fg_bg = fg_bg_control;
#endif
	}
#endif  //NEC_98
}
#endif /* REAL VGA */
#endif /* EGG */

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ga_glue.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Revision 3.0
 *
 * Title		:	ga_glue.c
 *
 * Description	: 	Glue to fit an a2cpu to 3.0 GA graphics
 *			Also used for later C CPUs which use the 2.0
 *			video interface.
 *
 * Author	: John Shanly
 *
 * Notes	:
 *
 */

/*
 *	static char SccsID[] = "@(#)ga_glue.c	1.14 12/17/93 Copyright Insignia Solutions Ltd.";
 */

#ifdef C_VID

#include "xt.h"
#include CpuH
#include "sas.h"
#include "gvi.h"
#include "gmi.h"
#include "egacpu.h"
#include "cpu_vid.h"
#include "ga_defs.h"

#include <stdio.h>
#include "trace.h"
#include "debug.h"

#define INTEL_SRC	0
#define HOST_SRC	1

IMPORT READ_POINTERS C_vid_reads;
IMPORT WRT_POINTERS C_vid_writes;

GLOBAL VOID
glue_b_write( addr, val )

UTINY *addr;
ULONG val;

{
	sub_note_trace2( GLUE_VERBOSE,
			"glue_b_write: addr=%x, pe = %x", addr, VGLOBS->plane_enable );

#ifdef CCPU
	EasVal = val;
	Ead = (ULONG) addr - gvi_pc_low_regen;
#else
	UNUSED(val);
	
	EasVal = *addr;
	Ead = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_writes.b_write)( EasVal, Ead );
}

GLOBAL VOID
glue_w_write( addr, val )

UTINY *addr;
ULONG val;

{
	sub_note_trace2( GLUE_VERBOSE,
			"glue_w_write: addr=%x, pe = %x", addr, VGLOBS->plane_enable );

#ifdef CCPU
	EasVal = val;
	Ead = (ULONG) addr - gvi_pc_low_regen;
#else
	UNUSED(val);
	
	EasVal = *addr | ( *(addr+1) << 8 );
	Ead = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_writes.w_write)( EasVal, Ead );
}


#ifndef	NO_STRING_OPERATIONS

GLOBAL VOID
glue_b_fill( laddr, haddr, val )

UTINY *laddr, *haddr;
ULONG val;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_b_fill: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = val;
#else
	UNUSED(val);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = *laddr;
#endif /* CCPU */

	(*C_vid_writes.b_fill)( EasVal, Ead, Count );
}

GLOBAL VOID
glue_w_fill( laddr, haddr, val )

UTINY *laddr, *haddr;
ULONG val;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_w_fill: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = val;
#else
	UNUSED(val);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = *laddr | ( *(laddr+1) << 8 );
#endif /* CCPU */

	(*C_vid_writes.w_fill)( EasVal, Ead, Count );
}

GLOBAL VOID
glue_b_move( laddr, haddr, src, src_type )

UTINY *laddr, *haddr, *src, src_type;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_b_move: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = (ULONG) src;
#else
	UNUSED(src);
	UNUSED(src_type);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = (ULONG) haddr_of_src_string - Count + 1;
#endif /* CCPU */

#ifdef CCPU
	if(( src_type == HOST_SRC )
			|| ( EasVal < (ULONG) gvi_pc_low_regen ) || ((ULONG) gvi_pc_high_regen < EasVal ))
#else
	if(( EasVal < (ULONG) get_byte_addr(gvi_pc_low_regen) ) || ((ULONG) get_byte_addr(gvi_pc_high_regen) < EasVal ))
#endif /* CCPU */
	{
		/* Ram source */

		V1 = 0;
#ifdef CCPU
		/*
		 * This looks like a deliberate hack to pass an intel address
		 * in a host pointer.  Hence I've added a cast to the
		 * get_byte_addr call to remove an ANSI warning.  (Mike).
		 */

		if( src_type == INTEL_SRC )
			EasVal = (ULONG) get_byte_addr((PHY_ADDR)src);	/* Staging post eliminated */
#else
		EasVal = (ULONG) laddr;						/* Staging post hack */
#endif /* CCPU */
	}
	else
	{
		/* VGA source */

		V1 = 1;
#ifdef CCPU
		EasVal -= (ULONG) gvi_pc_low_regen;
#else
		EasVal -= (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	}

	if( getDF() )
	{
		Ead += Count - 1;
		EasVal += Count - 1;
		(*C_vid_writes.b_bwd_move)( Ead, EasVal, Count, V1 );
	}
	else
		(*C_vid_writes.b_fwd_move)( Ead, EasVal, Count, V1 );
}

GLOBAL VOID
glue_w_move( laddr, haddr, src )

UTINY *laddr, *haddr, *src;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_w_move: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = ( haddr - laddr + 1 ) >> 1;

#ifdef CCPU
	Ead = (ULONG) laddr;
	EasVal = (ULONG) src;
#else
	UNUSED(src);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = (ULONG) haddr_of_src_string - ( Count << 1 ) + 1;
#endif /* CCPU */


#ifdef CCPU
	if(( EasVal < (ULONG) gvi_pc_low_regen ) || ((ULONG) gvi_pc_high_regen < EasVal ))
#else
	if(( EasVal < (ULONG) get_byte_addr(gvi_pc_low_regen) ) || ((ULONG) get_byte_addr(gvi_pc_high_regen) < EasVal ))
#endif /* CCPU */
	{
		/* Ram source */

		V1 = 0;
#ifdef CCPU
		EasVal = (ULONG ) get_byte_addr((PHY_ADDR)laddr);	/* Staging post hack */
#else
		EasVal = (ULONG) laddr;					/* Staging post hack */
#endif /* CCPU */
	}
	else
	{
		/* VGA source */

		V1 = 1;
#ifdef CCPU
		EasVal -= (ULONG) gvi_pc_low_regen;
#else
		EasVal -= (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	}

	if( getDF() )
	{
		Ead += ( Count << 1 ) - 2;
		EasVal += ( Count << 1 ) - 2; 
		(*C_vid_writes.w_bwd_move)( Ead, EasVal, Count, V1 );
	}
	else
		(*C_vid_writes.w_fwd_move)( Ead, EasVal, Count, V1 );
}


#endif	/* NO_STRING_OPERATIONS */


/**/


GLOBAL ULONG
glue_b_read( addr )

UTINY *addr;

{
	sub_note_trace2( GLUE_VERBOSE,
		"glue_b_read: addr=%x, shift = %d", addr, VGLOBS->read_shift_count );

#ifdef CCPU
	EasVal = (ULONG) addr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_reads.b_read)( EasVal );

#ifdef CCPU
	return( EasVal );
#else
	*addr = EasVal;
	return( 0 );
#endif /* CCPU */
}

GLOBAL ULONG
glue_w_read( addr )

UTINY *addr;

{
	sub_note_trace2( GLUE_VERBOSE,
		"glue_w_read: addr=%x, shift = %d", addr, VGLOBS->read_shift_count );

#ifdef CCPU
	EasVal = (ULONG) addr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_reads.w_read)( EasVal );

#ifdef CCPU
	return( EasVal );
#else
	*(addr+1) = EasVal >> 8;
	*addr = EasVal;
	return( 0 );
#endif /* CCPU */
}


GLOBAL VOID
glue_str_read( laddr, haddr )

UTINY *laddr, *haddr;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_str_read: laddr=%x, haddr=%x, shift = %d",
						laddr, haddr, VGLOBS->read_shift_count );

	Count = haddr - laddr + 1;
#ifdef CCPU
	EasVal = (ULONG) laddr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	Ead = (ULONG ) laddr;

	(*C_vid_reads.str_read)( (UTINY *)Ead, EasVal, Count );
}

#endif /* C_VID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_read.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		:

REVISION HISTORY	:
First version		: August 1988, J. Maiden
Second version		: February 1991, John Shanly, SoftPC 3.0

SUBMODULE NAME		: ega		

SOURCE FILE NAME	: ega_read.c

PURPOSE			: emulation of EGA read operations

SccsID = @(#)ega_read.c	1.32 09/07/94 Copyright Insignia Solutions Ltd.
		

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_read.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :
			void ega_read_init()
			void ega_read_term()
			void ega_read_routines_update()
	DATA 	     :	
-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
	 (not o/s objects or standard libs)

	PROCEDURES() :

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	 	 : 	ega_read_init

PURPOSE		  : 	initialize EGA read aspects.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	initialize ega read data and code to sensible state.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================
PROCEDURE	 	 : 	ega_read_term

PURPOSE		  : 	terminate EGA read aspects.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	set things up so that read processing is effectively turned off.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

PROCEDURE	 	 : 	ega_read_routines_update

PURPOSE		  : 	Update read state to match registers.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	Examines RAM enabled/disabled bit, read mode, chained/unchained
				and either mapped plane or colour compare and colour don't
				care states.  Sets global variables that allow byte_read,
				word_read and string_read to yield the data that would be
				read from M.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.

=========================================================================

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG

#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include	"sas.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"ios.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"egaread.h"
#include	"ga_mark.h"
#include	"ga_defs.h"
#include	"cpu_vid.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

/*
5.0 MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

#if defined(EGA_DUMP) || defined(EGA_STAT)
#define	change_read_pointers(ptr)	dump_change_read_pointers(&ptr)
#else
#ifdef EGATEST
#define	change_read_pointers(ptr)	read_pointers = ptr
#else
#define	change_read_pointers(ptr)	read_glue_ptrs = ptr
#endif /* EGATEST */
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/


/* [5.1.3 PROCEDURE() DECLARATIONS]					*/


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

	[5.2.1 INTERNAL DATA DEFINITIONS 					*/

extern IU32 glue_b_read();
extern IU32 glue_w_read();
extern void glue_str_read();

#ifndef REAL_VGA
READ_POINTERS read_glue_ptrs;

/* If we have no string operations, the host allocates storage for "read_pointers" */

#ifndef	NO_STRING_OPERATIONS
GLOBAL READ_POINTERS read_pointers;
#endif	/* NO_STRING_OPERATIONS */


#ifndef CPU_40_STYLE	/* i.e. EVID without introducing an EVID define */
#ifndef EGATEST
#ifndef A3CPU
#ifndef JOKER
READ_POINTERS Glue_reads =
{
	glue_b_read,
	glue_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	glue_str_read
#endif	/* NO_STRING_OPERATIONS */
};
#endif /* JOKER */
#endif /* A3CPU */
#endif /* EGATEST */

READ_POINTERS	simple_reads =
{
	_simple_b_read,
	_simple_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	_simple_str_read
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_RAM_off =
{
	_rd_ram_dsbld_byte,
	_rd_ram