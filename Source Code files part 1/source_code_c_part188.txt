Error for a failure code.

--*/

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    CHAR RegKey[MAX_REGISTRY_KEYA];
    PCSTR Start;
    PCSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheA (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYA (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (NewKeyName, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyA (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyA (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = _mbschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringA (Start);
        }

        //If a subkey name exceeds 256 WCHARS or 512 ANSI chars, then it's invalid (ie. RegCreateKey will fail).
        //So we should restrict the max number of chars to copy to 512, in this case.
        //I.e. End - Start <= 512

        if ((End - Start) > 512)
        {
            MYASSERT(FALSE);

            if ((End - Start ) > 768)
            {
                End = Start + 768;
            }
            //this is enough room to copy the string into RegKey, so that RegCreateKey will fail, but
            //not enough to overun the buffer
        }

        StringCopyABA (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) { //lint !e613
            rc = OurRegOpenKeyExA (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExA (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) { //lint !e613
            Start = _mbsinc (Start);
        }

    } while (*Start);   //lint !e613

    if (Parent) {
        RegAddKeyToCacheA (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheA (NewKeyName, lastWack);
    }

    return Parent;
}


HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_REGISTRY_KEYW];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCWSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheW (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYW (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (NewKeyName, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyW (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        //If a subkey name exceeds 256 WCHARS or 512 ANSI chars, then it's invalid (ie. RegCreateKey will fail).
        //So we should restrict the max number of chars to copy to 256, in this case.
        //I.e. End - Start <= 256 wchars

        if ((End - Start) > 256)
        {
            MYASSERT(FALSE);

            if ((End - Start ) > 384)
            {
                End = Start + 384;
            }
            //this is enough room to copy the string into RegKey, so that RegCreateKey will fail, but
            //not enough to overun the buffer
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = OurRegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    if (Parent) {
        RegAddKeyToCacheW (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheW (NewKeyName, lastWack);
    }

    return Parent;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyExA (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerA (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_OpenSam);

    return result;
}


HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen           OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerW (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_OpenSam);

    return result;
}


LONG
CloseRegKeyWorker (
    IN      HKEY Key
    )
{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "RegCloseKey threw an exception!"));
    }

    MYASSERT (rc == ERROR_SUCCESS);

    return rc;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (RegDecrementRefCount (Key)) {
        //
        // Key is in the cache; don't call CloseRegKeyWorker. This will
        // be done by the cache code.
        //

        return ERROR_SUCCESS;
    }

    return CloseRegKeyWorker (Key);
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    UINT    TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKR",                     L"HKR",                     3, HKEY_ROOT,
    "HKEY_ROOT",               L"HKEY_ROOT",               9, HKEY_ROOT,
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringA (
    IN      PCSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    MBCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (StringIMatchTcharCountA (
                RootString,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength
                )) {

            c = _mbsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != '\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = _wcsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    if (RootKey == g_Root) {
        return 1;
    }

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    HKEY Ret;

    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    Ret = g_RegRoots[i - 1].RootKey;
    if (Ret == HKEY_ROOT) {
        Ret = g_Root;
    }

    return Ret;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyA (
    PCSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringA (RegPath, LengthPtr));
}

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCSTR
ConvertKeyToRootStringA (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetA (GetOffsetOfRootKey (RegRoot));
}

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}



/*++

Routine Description:

  CreateEncodedRegistryStringEx is used to create a registry string in the format commonly
  expected by w95upg reg routines. This format is:

    EncodedKey\[EncodedValue]

  Encoding is used to safely represent "special" characters
    (such as MBS chars and certain punctuation marks.)

  The [EncodedValue] part will exist only if Value is non null.

Arguments:

    Key - Contains an unencoded registry key.
    Value - Optionally contains an unencoded registry value.
    Tree - Specifies that the registry key refers to the entire key

Return Value:

    Returns a pointer to the encoded registry string, or NULL if there was an error.

--*/

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    )
{
    PSTR    rEncodedString = NULL;
    DWORD   requiredSize;
    PSTR    end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = (strlen(Key)*6 + (Value ? strlen(Value)*6 : 0) + 10) * sizeof(CHAR);
    rEncodedString  = AllocPathStringA(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsA(rEncodedString, requiredSize / sizeof(CHAR), Key);

    //
    // Finally, if a value exists, append it in encoded form. If a value does not exist,
    // then add an '*' to the line.
    //
    if (Value) {

        StringCopyA (AppendWackA (rEncodedString), "[");
        end = GetEndOfStringA (rEncodedString);
        EncodeRuleCharsA(end, requiredSize / sizeof(CHAR) - (end - rEncodedString) - 1, Value);
        StringCatA(end, "]");

    } else if (Tree) {
        StringCopyA (AppendWackA (rEncodedString), "*");
    }

    return rEncodedString;
}


PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    )
{
    PWSTR   rEncodedString = NULL;
    DWORD   requiredSize;
    PWSTR   end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = (wcslen(Key)*6 + (Value ? wcslen(Value)*6 : 0) + 10) * sizeof(WCHAR);
    rEncodedString  = AllocPathStringW(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsW(rEncodedString, requiredSize / sizeof(WCHAR), Key);

    //
    // Finally, if a value exists, append it in encoded form.
    // If a value doesn't exist, add na '*' to the line.
    //
    if (Value) {

        StringCopyW (AppendWackW (rEncodedString), L"[");
        end = GetEndOfStringW (rEncodedString);
        EncodeRuleCharsW(end, requiredSize / sizeof(WCHAR) - (end - rEncodedString) - 1, Value);
        StringCatW(end, L"]");
    } else if (Tree) {
        StringCopyW (AppendWackW (rEncodedString), L"*");
    }

    return rEncodedString;
}


/*++

Routine Description:

    FreeEncodedRegistryString frees the memory allocated by a call to CreateEncodedRegistryString.

Arguments:

    None.


Return Value:

    None.

--*/
VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    )
{
    FreePathStringA(RegString);
}


VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    )
{
    FreePathStringW(RegString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"
#include "migutilp.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif

#define DBG_POOLMEM "Poolmem"

// Tree Memory Allocation structure.


#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    UINT_PTR              Index;            // Tracks into RawMemory.
    SIZE_T                Size;             // the size in bytes of RawMemory.
    PPOOLMEMORYBLOCK      NextBlock;        // A pointer to the next block in the pool chain.
    PPOOLMEMORYBLOCK      PrevBlock;        // A pointer to the prev block in the pool chain.
    DWORD                 UseCount;         // The number of allocations currently referring
                                            // to this block.
    PBYTE                 RawMemory;        // The actual bytes of allocable memory in this block.
};


typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD               DogTag;             // A signature to ensure validity.
    PALLOCATION         Next;               // The next allocation in the list.
    PALLOCATION         Prev;               // The previous allocation in the list.
#endif

    PPOOLMEMORYBLOCK    ParentBlock;        // A reference to the block from which this allocation
                                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;              // The active memory block in this pool.
    SIZE_T           MinimumBlockSize;      // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR             Name[MAX_POOL_NAME];
    SIZE_T           TotalAllocationRequestBytes;
    SIZE_T           MaxAllocationSize;
    SIZE_T           CurrentlyAllocatedMemory;
    SIZE_T           MaximumAllocatedMemory;
    DWORD            NumAllocationRequests;
    DWORD            NumFreeRequests;
    DWORD            NumBlockFrees;
    DWORD            NumBlockClears;
    DWORD            NumBlockAllocations;

    PALLOCATION      AllocationList;        // A linked list of all of the allocations active in the
                                            // pool.

    FREESTATE        FreeCalled;            // A state variable indicating that PoolMemReleaseMemory()
                                            // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;


#ifdef DEBUG

DWORD g_PoolMemDisplayed;
DWORD g_PoolMemNotDisplayed;



#endif

BOOL
pPoolMemAddMemory (
    IN  POOLHANDLE Handle,
    IN  SIZE_T Size
    )
/*++

Routine Description:

    pPoolMemAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PoolMemInitPool and PoolMemGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    SIZE_T              sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > poolHeader -> MinimumBlockSize) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = poolHeader -> MinimumBlockSize;
    }
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
        newBlock -> UseCount    = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader -> CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader -> MaximumAllocatedMemory    =
            max(poolHeader -> MaximumAllocatedMemory,poolHeader -> CurrentlyAllocatedMemory);

        poolHeader -> NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


POOLHANDLE
PoolMemInitPool (
    VOID
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid POOLHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> MinimumBlockSize = POOLMEMORYBLOCKSIZE;
        header -> PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header -> TotalAllocationRequestBytes   = 0;
        header -> MaxAllocationSize             = 0;
        header -> CurrentlyAllocatedMemory      = 0;
        header -> MaximumAllocatedMemory        = 0;
        header -> NumAllocationRequests         = 0;
        header -> NumFreeRequests               = 0;
        header -> NumBlockFrees                 = 0;
        header -> NumBlockClears                = 0;
        header -> NumBlockAllocations           = 0;
        header -> Name[0]                       = 0;


#endif
        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);
            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PoolMemNotDisplayed =  12;
        g_PoolMemDisplayed =     24;

        if (ableToAddMemory) {
            header -> AllocationList = NULL;
            header -> FreeCalled = FREE_NOT_CALLED;
        }
#endif

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

    return (POOLHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION      p,cur;

    if (PoolHeader -> FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader -> AllocationList;

    while (p) {

        cur = p;
        p = p -> Next;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader -> AllocationList = NULL;
#endif
}


VOID
PoolMemEmptyPool (
    IN      POOLHANDLE Handle
    )

/*++

Routine Description:

    PoolMemEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        poolHeader -> PoolHead -> UseCount = 0;
        poolHeader -> PoolHead -> Index = 0;

#ifdef DEBUG
        poolHeader -> NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

}



VOID
PoolMemSetMinimumGrowthSize (
    IN POOLHANDLE Handle,
    IN SIZE_T     Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid POOLHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader -> MinimumBlockSize = max(Size,0);
}


VOID
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
/*++

Routine Description:

    PoolMemDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid POOLHANDLE.

Return Value:

    None.

--*/
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree;
    PPOOLHEADER      poolHeader;


    MYASSERT(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader -> TotalAllocationRequestBytes)) / poolHeader -> NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSGA ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader -> Name[0] ? poolHeader -> Name : "[Unnamed Pool]",
            FloatWorkaround,
            poolHeader -> MaxAllocationSize,
            poolHeader -> CurrentlyAllocatedMemory,
            poolHeader -> MaximumAllocatedMemory,
            poolHeader -> NumAllocationRequests,
            poolHeader -> NumBlockAllocations,
            poolHeader -> NumFreeRequests,
            poolHeader -> NumBlockFrees,
            poolHeader -> NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSGA ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }


    //
    // Free all allocations that have not yet been freed.
    //

    pDeregisterPoolAllocations(poolHeader);

#endif


    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;
        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    MemFree(g_hHeap,0,poolHeader);

}

PVOID
PoolMemRealGetMemory (
    IN POOLHANDLE Handle,
    IN SIZE_T Size,
    IN SIZE_T AlignSize /*,*/
    ALLOCATION_TRACKING_DEF
    )

/*++

Routine Description:

    PoolMemRealGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    (File) - The File from whence the call orignated. This is used for memory tracking and checking
             in the debug version.
    (Line) - The Line from whence the call orignated.

    Handle - A valid POOLHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    PALLOCATION         allocation;
    SIZE_T              sizeNeeded;
    UINT_PTR            padLength;

    MYASSERT(poolHeader != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader -> PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader->MaxAllocationSize = max (poolHeader->MaxAllocationSize, Size);
        poolHeader->NumAllocationRequests++;
        poolHeader->TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader -> PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (UINT_PTR) currentBlock + sizeof(POOLMEMORYBLOCK) +
                                       currentBlock->Index + sizeof(ALLOCATION);

                currentBlock->Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            (PBYTE) allocation = &(currentBlock -> RawMemory[currentBlock -> Index]);
            allocation -> ParentBlock = currentBlock;


#ifdef DEBUG

            //
            // Track this memory.
            //
            allocation -> DogTag = VALIDDOGTAG;
            allocation -> Next = poolHeader -> AllocationList;
            allocation -> Prev = NULL;

            if (poolHeader -> AllocationList) {
                poolHeader -> AllocationList -> Prev = allocation;
            }

            poolHeader -> AllocationList = allocation;

            if (poolHeader -> FreeCalled != WHO_CARES) {

                DebugRegisterAllocation(POOLMEM_POINTER, allocation, File, Line);

            }


#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock -> Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

    return rMemory;
}

VOID
PoolMemReleaseMemory (
    IN POOLHANDLE Handle,
    IN LPVOID     Memory
    )
/*++

Routine Description:

    PoolMemReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION         allocation;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader -> NumFreeRequests++;

#endif




#ifdef DEBUG

        if (poolHeader -> FreeCalled == FREE_NOT_CALLED) {
            poolHeader -> FreeCalled = FREE_CALLED;
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation -> DogTag != VALIDDOGTAG) {
            if (allocation -> DogTag == FREEDOGTAG) {
                DEBUGMSGA ((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSGA ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);
            }

            __leave;

        } else {
            allocation -> DogTag = FREEDOGTAG;
        }

        if (allocation -> Next) {
            allocation -> Next -> Prev = allocation -> Prev;
        }

        if (poolHeader -> AllocationList == allocation) {
            poolHeader -> AllocationList = allocation -> Next;
        } else {

            allocation -> Prev -> Next = allocation -> Next;
        }


        if (poolHeader -> FreeCalled != WHO_CARES) {
            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation -> ParentBlock == NULL) {
            DEBUGMSGA ((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation -> ParentBlock -> UseCount--;




        if (allocation -> ParentBlock -> UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation -> ParentBlock != poolHeader -> PoolHead) {
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader -> NumBlockFrees++;
                poolHeader -> CurrentlyAllocatedMemory -=
                    allocation -> ParentBlock -> Size + sizeof(POOLMEMORYBLOCK);


#endif

                if (allocation -> ParentBlock -> NextBlock) {
                    allocation -> ParentBlock -> NextBlock -> PrevBlock =
                        allocation -> ParentBlock -> PrevBlock;
                }
                allocation -> ParentBlock -> PrevBlock -> NextBlock =
                    allocation -> ParentBlock -> NextBlock;
                MemFree(g_hHeap,0,allocation -> ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation -> ParentBlock -> Index = 0;
                allocation -> ParentBlock = NULL;

#ifdef DEBUG
                poolHeader -> NumBlockClears++;
#endif

            }
        }
        else {
            allocation -> ParentBlock = NULL;

        }

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

}


#ifdef DEBUG

POOLHANDLE
PoolMemInitNamedPool (
    IN      PCSTR Name
    )
{
    POOLHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = PoolMemInitPool();
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        _mbssafecpy (poolHeader->Name, Name, sizeof(poolHeader->Name));
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PoolMemDuplicateMultiSzA (
    IN POOLHANDLE    Handle,
    IN PCSTR         MultiSzToCopy
    )
{
    PSTR tmpString = (PSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (tmpString [0] != 0) {
        tmpString = GetEndOfStringA (tmpString) + 1;
    }
    size = tmpString - MultiSzToCopy + 1;
    tmpString = PoolMemGetAlignedMemory(Handle, size);

    if (tmpString) {
        memcpy (tmpString, MultiSzToCopy, size);
    }

    return tmpString;
}

PWSTR
PoolMemDuplicateMultiSzW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        MultiSzToCopy
    )
{
    PWSTR tmpString = (PWSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (tmpString [0] != 0) {
        tmpString = GetEndOfStringW (tmpString) + 1;
    }
    size = (tmpString - MultiSzToCopy + 1) * sizeof(WCHAR);
    tmpString = PoolMemGetAlignedMemory(Handle, size);

    if (tmpString) {
        memcpy (tmpString, MultiSzToCopy, size);
    }

    return tmpString;
}



#ifdef DEBUG

VOID
PoolMemDisableTracking (
    IN POOLHANDLE Handle
    )

/*++

Routine Description:

    PoolMemDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    poolHeader -> FreeCalled = WHO_CARES;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:


--*/


#include "pch.h"
#include "migutilp.h"

#include "regp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = GROWLIST_INIT;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;

    //Note that we are copying to memory immediately after the KEYTRACK structure
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    AddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\regp.h ===
HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    );

HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
CloseRegKeyWorker (
    IN      HKEY Key
    );

#ifdef DEBUG

VOID
RegTrackTerminate (
    VOID
    );

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#define TRACK_KEYA(handle,keystr) AddKeyReferenceA(handle,keystr,__FILE__,__LINE__)
#define TRACK_KEYW(handle,keystr) AddKeyReferenceW(handle,keystr,__FILE__,__LINE__)

#else

#define TRACK_KEYA(handle,keystr)
#define TRACK_KEYW(handle,keystr)

#endif


//
// Cache apis
//

VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    );

HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    );

HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

BOOL
RegDecrementRefCount (
    IN      HKEY Key
    );

VOID
RegIncrementRefCount (
    IN      HKEY Key
    );

extern REGSAM g_OpenSam;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\regenum.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    regenum.c

Abstract:

    Implements utilties to enumerate the registry.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    <alias> <date> <comment>

--*/

#include "pch.h"
#include "migutilp.h"

#include "regp.h"

#define DBG_REG     "Reg"

//
// Private prototypes
//

BOOL
pPopRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr
    );

BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    );

/*++

Routine Description:

  EnumFirstRegKeyA and EnumFirstRegKeyW begin an enumeration of registry
  subkeys.  They initialize the registy enumeration structure and
  call the registry APIs to enumerate subkeys of the specified key handle.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.  It points to a REGKEY_ENUM structure
              in memory.

  Key       - Specifies the handle of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegKeyA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKeyA (EnumPtr);
}


BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKeyW (EnumPtr);
}


/*++

Routine Description:

  EnumFirstRegKeyStrA and EnumFirstRegKeyStrW start an enumeration of
  subkeys within the given key.  In these functions, the key is specified
  via a string instead of an HKEY value.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.  It points to a REGKEY_ENUM structure
              in memory.

  RegKey    - Specifies the full path of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
RealEnumFirstRegKeyStrA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStrA (RegKey /* , */ DEBUG_TRACKING_ARGS);

    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKeyA (EnumPtr, Key);
    if (!b) {
        CloseRegKey (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


BOOL
RealEnumFirstRegKeyStrW (
    IN      PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStrW (RegKey /* , */ DEBUG_TRACKING_ARGS);
    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKeyW (EnumPtr, Key);
    if (!b) {
        CloseRegKey (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


/*++

Routine Description:

  AbortRegKeyEnumA and AbortRegKeyEnumW release all resources associated
  with a registry subkey enumeration.  Call this function to stop the
  enumeration before it completes by itself.

Arguments:

  EnumPtr   - Specifies the enumeration to stop.  Receives the updated
              state of enumeration.

Return Value:


  none

--*/

VOID
AbortRegKeyEnumA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


/*++

Routine Description:

  EnumNextRegKeyA and EnumNextRegKeyW continue an enumeration started by
  one of the subkey enumeration routines above.  If all items have been
  enumerated, this function cleans up all resources and returns FALSE.

Arguments:

  EnumPtr   - Specifies the enumeration to continue.  Receives the updated
              state of enumeration.  The structure can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegKeyA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    LONG rc;

    rc = RegEnumKeyA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYA
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    LONG rc;

    rc = RegEnumKeyW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYW
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
pPushRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr,
    IN      PCSTR KeyName
    )
{
    PREGKEYINFOA RetVal;
    PSTR p;

    RetVal = (PREGKEYINFOA) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOA)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOA));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    //We must have enough space for the backslash & nul byte.
    if (EnumPtr->FullKeyNameBytes && (MAX_REGISTRY_KEYA > EnumPtr->FullKeyNameBytes + 1)) {
        StringCopyA (p, "\\");
        EnumPtr->FullKeyNameBytes += ByteCountA (p);
        p = _mbsinc (p);
    }

    //We must make sure that the EnumPtr->FullKeyName buffer is large enough to hold the
    //full key name, since we have not allowed enough space for a "maliciously" created key name.
    //In theory, a key name can be arbitrarily long, but its subkey names are limited to 512 bytes storage space.

    MYASSERT(MAX_REGISTRY_KEYA > EnumPtr->FullKeyNameBytes + ByteCountA (KeyName));

    _mbssafecpy (p, KeyName, MAX_REGISTRY_KEYA - EnumPtr->FullKeyNameBytes);
    EnumPtr->FullKeyNameBytes = ByteCountA (EnumPtr->FullKeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _mbssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYA);
    RetVal->KeyHandle = OpenRegKeyStrA (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfoA (EnumPtr);
        return FALSE;
    }

    return TRUE;
}


BOOL
pPushRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR KeyName
    )
{
    PREGKEYINFOW RetVal;
    PWSTR p;

    RetVal = (PREGKEYINFOW) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOW)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOW));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    //We must have enough space for the backslash & nul byte.
    if (EnumPtr->FullKeyNameBytes
        && (MAX_REGISTRY_KEYW > (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)) + 1))
    {
        StringCopyW (p, L"\\");
        EnumPtr->FullKeyNameBytes += ByteCountW (p);
        p++;
    }

    //We must make sure that the EnumPtr->FullKeyName buffer is large enough to hold the
    //full key name, since we have not allowed enough space for a "maliciously" created key name.
    //In theory, a key name can be arbitrarily long, but its subkey names are limited to 512 bytes storage space.

    MYASSERT(MAX_REGISTRY_KEYW > (EnumPtr->FullKeyNameBytes + ByteCountW (KeyName)) / sizeof (WCHAR));

    _wcssafecpy (p, KeyName, MAX_REGISTRY_KEYW - (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)));
    EnumPtr->FullKeyNameBytes = ByteCountW (EnumPtr->FullKeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _wcssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYW);
    RetVal->KeyHandle = OpenRegKeyStrW (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfoW (EnumPtr);
        return FALSE;
    }

    return TRUE;
}



BOOL
pPopRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr
    )
{
    PREGKEYINFOA FreeMe;
    PSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey (FreeMe->KeyHandle);
    }

    AbortRegKeyEnumA (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    )
{
    PREGKEYINFOW FreeMe;
    PWSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey (FreeMe->KeyHandle);
    }

    AbortRegKeyEnumW (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
RealEnumFirstRegKeyInTreeA (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMA));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTreeA");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfoA (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REG, "EnumFirstRegKeyInTreeA failed to push base key"));
        AbortRegKeyTreeEnumA (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountA (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMW));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTreeW");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfoW (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REG, "EnumFirstRegKeyInTreeW failed to push base key"));
        AbortRegKeyTreeEnumW (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountW (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumNextRegKeyInTreeA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    for (;;) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKeyA (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKeyA (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfoA (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnumA (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfoA (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGA ((
                    DBG_REG,
                    "RealEnumNextRegKeyInTreeA failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (CHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    for (;;) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKeyW (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKeyW (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfoW (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnumW (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfoW (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGW ((
                    DBG_REG,
                    "RealEnumNextRegKeyInTreeW failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (WCHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


VOID
AbortRegKeyTreeEnumA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfoA (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}


VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfoW (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}



/*++

Routine Description:

  EnumFirstRegValueA and EnumerateFirstRegvalueW enumerate the first registry
  value name in the specified subkey.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  hKey      - Specifies handle of registry subkey to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegValueA (
    IN      PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValueA (EnumPtr);
}


BOOL
EnumFirstRegValueW (
    IN      PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValueW (EnumPtr);
}


/*++

Routine Description:

  EnumNextRegValueA and EnumNextRegValueW continue the enumeration started
  by EnumFirstRegValueA/W.  The enumeration structure is updated to
  reflect the next value name in the subkey being enumerated.

Arguments:

  EnumPtr   - Specifies the registry subkey and enumeration position.
              Receives the updated state of enumeration.  The structure
              can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegValueA (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEA;

    rc = RegEnumValueA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEW;

    rc = RegEnumValueW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


/*++

Routine Description:

  DecodeRegistryString turns an encoded string back into a key, value name
  and tree flag.

  The caller must pass in buffers at least as big as MAX_REGISTRY_KEY and
  MAX_REGISTRY_VALUE_NAME.

Arguments:

  RegString - Specifies the encoded registry string that contains a key name,
              and an optional value name or tree flag.
  KeyBuf    - Optionally receives the key name (points to a buffer of size MAX_REGISTRY_KEY)
  ValueBuf  - Optionally receives the value name (points to a buffer of
              size MAX_REGISTRY_VALUE_NAME)
  TreeFlag  - Optionally receives the tree flag, TRUE if the encoded string indicates a
              registry key tree, FALSE otherwise.

Return Value:

  TRUE if the encoded string contained a value, FALSE if it contained just a
  key or key tree.

--*/

BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    )
{
    CHAR TempKeyBuf[MAX_REGISTRY_KEY];
    PSTR End;
    CHAR TempValueNameBuf[MAX_REGISTRY_VALUE_NAME];
    BOOL TempTreeFlag = FALSE;
    MBCHAR ch;
    PSTR p;
    BOOL b = FALSE;

    //
    // Walk through encoded string, pulling out key name
    //

    TempKeyBuf[0] = 0;
    TempValueNameBuf[0] = 0;

    End = TempKeyBuf + ARRAYSIZE(TempKeyBuf) - 2;
    p = TempKeyBuf;

    while (*RegString && *RegString != '*' && *RegString != '[') {
        ch = GetNextRuleCharA (&RegString, NULL);

        *((PWORD) p) = (WORD)ch;
        p = _mbsinc (p);

        if (p >= End) {
            RegString = GetEndOfStringA (RegString);
            break;
        }
    }

    *p = 0;
    p = (PSTR) SkipSpaceRA (TempKeyBuf, p);
    *(_mbsinc (p)) = 0;

    if (*RegString == '*' && _mbsnextc (p) == '\\') {
        //
        // If a tree, stop here
        //

        TempTreeFlag = TRUE;
        *p = 0;

    } else if (*RegString == '[') {
        //
        // If a value name, parse it
        //

        RegString++;

        End = TempValueNameBuf + ARRAYSIZE(TempValueNameBuf) - 2;
        p = TempValueNameBuf;

        while (*RegString && *RegString != ']') {

            ch = GetNextRuleCharA (&RegString, NULL);

            *((PWORD) p) = (WORD)ch;
            p = _mbsinc (p);

            if (p >= End) {
                RegString = GetEndOfStringA (RegString);
                break;
            }
        }

        *p = 0;
        p = (PSTR) SkipSpaceRA (TempValueNameBuf, p);
        if (p) // Guard against empty or all-whitespace value name.
            *(p + 1) = 0;

        RemoveWackAtEndA (TempKeyBuf);

        b = TRUE;
    }

    if (KeyBuf) {
        StringCopyA (KeyBuf, TempKeyBuf);
    }

    if (ValueBuf) {
        StringCopyA (ValueBuf, TempValueNameBuf);
    }

    if (TreeFlag) {
        *TreeFlag = TempTreeFlag;
    }

    return b;
}


BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    )
{
    WCHAR TempKeyBuf[MAX_REGISTRY_KEY];
    PWSTR End;
    WCHAR TempValueNameBuf[MAX_REGISTRY_VALUE_NAME];
    BOOL TempTreeFlag = FALSE;
    WCHAR ch;
    PWSTR p;
    BOOL b = FALSE;

    //
    // Walk through encoded string, pulling out key name
    //

    TempKeyBuf[0] = 0;
    TempValueNameBuf[0] = 0;

    End = TempKeyBuf + ARRAYSIZE(TempKeyBuf) - 2;
    p = TempKeyBuf;

    while (*RegString && *RegString != L'*' && *RegString != L'[') {
        ch = GetNextRuleCharW (&RegString, NULL);

        *((PWORD) p) = ch;
        p++;

        if (p >= End) {
            RegString = GetEndOfStringW (RegString);
            break;
        }
    }

    *p = 0;
    p = (PWSTR) SkipSpaceRW (TempKeyBuf, p);
    if (!p) {
        return FALSE;
    }
    *(p + 1) = 0;

    if (*RegString == L'*' && *p == L'\\') {
        //
        // If a tree, stop here
        //

        TempTreeFlag = TRUE;
        *p = 0;

    } else if (*RegString == L'[') {
        //
        // If a value name, parse it
        //

        RegString++;

        End = TempValueNameBuf + ARRAYSIZE(TempValueNameBuf) - 2;
        p = TempValueNameBuf;

        while (*RegString && *RegString != L']') {

            ch = GetNextRuleCharW (&RegString, NULL);

            *((PWORD) p) = ch;
            p++;

            if (p >= End) {
                RegString = GetEndOfStringW (RegString);
                break;
            }
        }

        *p = 0;
        p = (PWSTR) SkipSpaceRW (TempValueNameBuf, p);
        if (p) { // Guard against empty or all-whitespace value name.
            *(p + 1) = 0;
        }

        RemoveWackAtEndW (TempKeyBuf);

        b = TRUE;
    }

    if (KeyBuf) {
        StringCopyW (KeyBuf, TempKeyBuf);
    }

    if (ValueBuf) {
        StringCopyW (ValueBuf, TempValueNameBuf);
    }

    if (TreeFlag) {
        *TreeFlag = TempTreeFlag;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\pcha\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\safemode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    safemode.c

Abstract:

    A number of utilities for safe/recovery mode

Author:

    Calin Negreanu (calinn)   6-Aug-1999

Revisions:

--*/


#include "pch.h"
#include "migutilp.h"


BOOL g_SafeModeInitialized = FALSE;
BOOL g_SafeModeActive = FALSE;
PCSTR g_SafeModeFileA = NULL;
PCWSTR g_SafeModeFileW = NULL;
HANDLE g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
HASHTABLE g_SafeModeCrashTable = NULL;
BOOL g_ExceptionOccured = FALSE;

typedef struct {
    ULONG Signature;
    ULONG NumCrashes;
} SAFEMODE_HEADER, *PSAFEMODE_HEADER;

typedef struct {
    ULONG CrashId;
    ULONG CrashStrSize;
} CRASHDATA_HEADER, *PCRASHDATA_HEADER;

typedef struct _SAFEMODE_NODE {
    DWORD FilePtr;
    struct _SAFEMODE_NODE *Next;
} SAFEMODE_NODE, *PSAFEMODE_NODE;

PSAFEMODE_NODE g_SafeModeLastNode = NULL;
PSAFEMODE_NODE g_SafeModeCurrentNode = NULL;

POOLHANDLE g_SafeModePool = NULL;

#define SAFE_MODE_SIGNATURE     0x45464153


/*++

Routine Description:

  pGenerateCrashString generates a crash string given an identifier and a string
  The generated string will look like <Id>-<String>

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  A pointer to a crash string allocated from g_SafeModePool
  The caller must free the memory by calling PoolMemReleaseMemory

--*/

PCSTR
pGenerateCrashStringA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    CHAR idStr [sizeof (ULONG) * 2 + 1];
    _ultoa (Id, idStr, 16);
    return JoinTextExA (g_SafeModePool, idStr, String, "-", 0, NULL);
}

PCWSTR
pGenerateCrashStringW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    WCHAR idStr [sizeof (ULONG) * 2 + 1];
    _ultow (Id, idStr, 16);
    return JoinTextExW (g_SafeModePool, idStr, String, L"-", 0, NULL);
}



/*++

Routine Description:

  pSafeModeOpenAndResetFile opens the safe mode file looking for
  crash strings stored here. It will also reset the part that is
  dealing with nested calls by extracting the inner most crash string
  stored there.

Arguments:

  None

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
pSafeModeOpenAndResetFileA (
    VOID
    )
{
    SAFEMODE_HEADER header;
    CRASHDATA_HEADER crashData;
    DWORD lastFilePtr;
    DWORD noBytes;
    PSTR crashString = NULL;
    PSTR lastCrashString = NULL;
    ULONG lastCrashId;
    PCSTR completeCrashString;

    //
    // Open the existing safe mode file or create a
    // new one.
    //
    g_SafeModeFileHandle = CreateFileA (
                                g_SafeModeFileA,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                                );
    if (g_SafeModeFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Let's try to read our header. If signature does
        // match we will try to read extra data.
        //

        if (ReadFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                ) &&
            (noBytes == sizeof (SAFEMODE_HEADER)) &&
            (header.Signature == SAFE_MODE_SIGNATURE)
            ) {

            //
            // we know now we had an valid safe mode file. Enter safe mode.
            //

            g_SafeModeActive = TRUE;

            LOGA ((LOG_ERROR, "Setup detected a crash on the previous upgrade attempt. Setup is running in safe mode."));
            LOGA ((LOG_WARNING, "Setup has run in safe mode %d time(s).", header.NumCrashes));

            //
            // we need to initialize safe mode crash table
            //
            g_SafeModeCrashTable = HtAllocA ();

            //
            // Now, let's read all crash data, a ULONG and a string at a time
            //

            lastFilePtr = SetFilePointer (
                                g_SafeModeFileHandle,
                                0,
                                NULL,
                                FILE_CURRENT
                                );

            while (TRUE) {

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        &crashData,
                        sizeof (CRASHDATA_HEADER),
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != sizeof (CRASHDATA_HEADER))
                    ) {
                    break;
                }

                if ((crashData.CrashId == 0) &&
                    (crashData.CrashStrSize == 0)
                    ) {

                    //
                    // we crashed inside a nested guard. We need to
                    // extract the inner guard we crashed in.
                    //

                    lastCrashId = 0;
                    lastCrashString = NULL;

                    while (TRUE) {
                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                &crashData,
                                sizeof (CRASHDATA_HEADER),
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != sizeof (CRASHDATA_HEADER))
                            ) {
                            crashData.CrashId = 0;
                            break;
                        }

                        //
                        // Restrict the length of CrashStrSize to 32K
                        //

                        if (crashData.CrashStrSize >= 32768 * sizeof (CHAR)) {
                            crashData.CrashId = 0;
                            break;
                        }

                        crashString = AllocPathStringA (crashData.CrashStrSize);

                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                crashString,
                                crashData.CrashStrSize,
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != crashData.CrashStrSize)
                            ) {
                            crashData.CrashId = 0;
                            FreePathStringA (crashString);
                            break;
                        }

                        if (lastCrashString) {
                            FreePathStringA (lastCrashString);
                        }

                        lastCrashId = crashData.CrashId;
                        lastCrashString = crashString;

                    }

                    if (lastCrashId && lastCrashString) {

                        //
                        // we found the inner guard we crashed in. Let's put this into
                        // the right place.
                        //

                        SetFilePointer (
                            g_SafeModeFileHandle,
                            lastFilePtr,
                            NULL,
                            FILE_BEGIN
                            );

                        crashData.CrashId = lastCrashId;
                        crashData.CrashStrSize = SizeOfStringA (lastCrashString);

                        WriteFile (
                            g_SafeModeFileHandle,
                            &crashData,
                            sizeof (CRASHDATA_HEADER),
                            &noBytes,
                            NULL
                            );

                        WriteFile (
                            g_SafeModeFileHandle,
                            lastCrashString,
                            crashData.CrashStrSize,
                            &noBytes,
                            NULL
                            );

                        //
                        // store this information in Safe Mode crash table
                        //
                        completeCrashString = pGenerateCrashStringA (crashData.CrashId, crashString);
                        HtAddStringA (g_SafeModeCrashTable, completeCrashString);
                        PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                        LOGA ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                        lastFilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

                        FreePathStringA (lastCrashString);
                    }
                    break;
                }

                //
                // Limit the size of the crash string
                //

                if (crashData.CrashStrSize >= 32768 * sizeof (CHAR)) {
                    LOG ((LOG_ERROR, "The crash detection journal contains garbage."));
                    break;
                }

                crashString = AllocPathStringA (crashData.CrashStrSize);

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        crashString,
                        crashData.CrashStrSize,
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != crashData.CrashStrSize)
                    ) {
                    break;
                }

                //
                // store this information in Safe Mode crash table
                //
                completeCrashString = pGenerateCrashStringA (crashData.CrashId, crashString);
                HtAddStringA (g_SafeModeCrashTable, completeCrashString);
                PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                LOGA ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                lastFilePtr = SetFilePointer (
                                    g_SafeModeFileHandle,
                                    0,
                                    NULL,
                                    FILE_CURRENT
                                    );
            }

            //
            // Write how many times we ran in safe mode
            //

            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes += 1;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            SetFilePointer (
                g_SafeModeFileHandle,
                lastFilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );

        } else {

            //
            // Reset the file
            //
            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes = 0;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );
        }

        //
        // Flush the file
        //

        FlushFileBuffers (g_SafeModeFileHandle);

        //
        // initialize the nested list
        //

        g_SafeModeLastNode = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));
        g_SafeModeCurrentNode = g_SafeModeLastNode->Next = g_SafeModeLastNode;
        g_SafeModeLastNode->FilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

        return TRUE;

    }
    return FALSE;
}

BOOL
pSafeModeOpenAndResetFileW (
    VOID
    )
{
    SAFEMODE_HEADER header;
    CRASHDATA_HEADER crashData;
    DWORD lastFilePtr;
    DWORD noBytes;
    PWSTR crashString = NULL;
    PWSTR lastCrashString = NULL;
    ULONG lastCrashId;
    PCWSTR completeCrashString;

    //
    // Open the existing safe mode file or create a
    // new one.
    //
    g_SafeModeFileHandle = CreateFileW (
                                g_SafeModeFileW,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                                );
    if (g_SafeModeFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Let's try to read our header. If signature does
        // match we will try to read extra data.
        //

        if (ReadFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                ) &&
            (noBytes == sizeof (SAFEMODE_HEADER)) &&
            (header.Signature == SAFE_MODE_SIGNATURE)
            ) {

            //
            // we know now we had an valid safe mode file. Enter safe mode.
            //

            g_SafeModeActive = TRUE;

            LOGW ((LOG_ERROR, "Setup detected a crash on the previous upgrade attempt. Setup is running in safe mode."));
            LOGW ((LOG_WARNING, "Setup has run in safe mode %d time(s).", header.NumCrashes));

            //
            // we need to initialize safe mode crash table
            //
            g_SafeModeCrashTable = HtAllocW ();

            //
            // Now, let's read all crash data, a ULONG and a string at a time
            //

            lastFilePtr = SetFilePointer (
                                g_SafeModeFileHandle,
                                0,
                                NULL,
                                FILE_CURRENT
                                );

            while (TRUE) {

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        &crashData,
                        sizeof (CRASHDATA_HEADER),
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != sizeof (CRASHDATA_HEADER))
                    ) {
                    break;
                }

                if ((crashData.CrashId == 0) &&
                    (crashData.CrashStrSize == 0)
                    ) {

                    //
                    // we crashed inside a nested guard. We need to
                    // extract the inner guard we crashed in.
                    //

                    lastCrashId = 0;
                    lastCrashString = NULL;

                    while (TRUE) {
                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                &crashData,
                                sizeof (CRASHDATA_HEADER),
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != sizeof (CRASHDATA_HEADER))
                            ) {
                            crashData.CrashId = 0;
                            break;
                        }

                        //
                        // Restrict the length of CrashStrSize to 32K
                        //

                        if (crashData.CrashStrSize >= 32768 * sizeof (WCHAR)) {
                            crashData.CrashId = 0;
                            break;
                        }

                        crashString = AllocPathStringW (crashData.CrashStrSize);

                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                crashString,
                                crashData.CrashStrSize,
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != crashData.CrashStrSize)
                            ) {
                            crashData.CrashId = 0;
                            FreePathStringW (crashString);
                            break;
                        }

                        if (lastCrashString) {
                            FreePathStringW (lastCrashString);
                        }

                        lastCrashId = crashData.CrashId;
                        lastCrashString = crashString;

                    }

                    if (lastCrashId && lastCrashString) {

                        //
                        // we found the inner guard we crashed in. Let's put this into
                        // the right place.
                        //

                        SetFilePointer (
                            g_SafeModeFileHandle,
                            lastFilePtr,
                            NULL,
                            FILE_BEGIN
                            );

                        crashData.CrashId = lastCrashId;
                        crashData.CrashStrSize = SizeOfStringW (lastCrashString);

                        WriteFile (
                            g_SafeModeFileHandle,
                            &crashData,
                            sizeof (CRASHDATA_HEADER),
                            &noBytes,
                            NULL
                            );

                        WriteFile (
                            g_SafeModeFileHandle,
                            lastCrashString,
                            crashData.CrashStrSize,
                            &noBytes,
                            NULL
                            );

                        //
                        // store this information in Safe Mode crash table
                        //
                        completeCrashString = pGenerateCrashStringW (crashData.CrashId, crashString);
                        HtAddStringW (g_SafeModeCrashTable, completeCrashString);
                        PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                        LOGW ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                        lastFilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

                        FreePathStringW (lastCrashString);
                    }
                    break;
                }

                //
                // Limit the size of the crash string
                //

                if (crashData.CrashStrSize >= 32768 * sizeof (WCHAR)) {
                    LOG ((LOG_ERROR, "The crash detection journal contains garbage."));
                    break;
                }

                crashString = AllocPathStringW (crashData.CrashStrSize);

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        crashString,
                        crashData.CrashStrSize,
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != crashData.CrashStrSize)
                    ) {
                    break;
                }

                //
                // store this information in Safe Mode crash table
                //
                completeCrashString = pGenerateCrashStringW (crashData.CrashId, crashString);
                HtAddStringW (g_SafeModeCrashTable, completeCrashString);
                PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                LOGW ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                lastFilePtr = SetFilePointer (
                                    g_SafeModeFileHandle,
                                    0,
                                    NULL,
                                    FILE_CURRENT
                                    );
            }

            //
            // Write how many times we ran in safe mode
            //

            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes += 1;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            SetFilePointer (
                g_SafeModeFileHandle,
                lastFilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );

        } else {

            //
            // Reset the file
            //
            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes = 0;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );
        }

        //
        // Flush the file
        //

        FlushFileBuffers (g_SafeModeFileHandle);

        //
        // initialize the nested list
        //

        g_SafeModeLastNode = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));
        g_SafeModeCurrentNode = g_SafeModeLastNode->Next = g_SafeModeLastNode;
        g_SafeModeLastNode->FilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

        return TRUE;

    }
    return FALSE;
}



/*++

Routine Description:

  SafeModeInitialize is called to initialize safe mode. The result of this
  function will be to either have safe mode active (if forced or if a crash
  was detected) or not. If safe mode is not active all other call are almost
  noop.

Arguments:

  Forced    - if this is TRUE, safe mode will be forced to be active

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeInitializeA (
    BOOL Forced
    )
{
    CHAR winDir[MAX_MBCHAR_PATH];

    g_ExceptionOccured = FALSE;

    if (GetWindowsDirectoryA (winDir, MAX_MBCHAR_PATH)) {

        g_SafeModePool = PoolMemInitNamedPool ("SafeMode Pool");

        //
        // BUGBUG -- technically this is wrong, it generates > MAX_PATH
        // potentially. However, this is an impractical case, and the
        // code is safe.
        //
        // BUGBUG -- This is inefficient. It breaks the paths pool by
        // allocating a global. Paths pool is optimized for short-term use
        // only.
        //

        g_SafeModeFileA = JoinPathsA (winDir, S_SAFE_MODE_FILEA);

        //
        // we are going to open the existing safe mode file
        // or to create a new one
        //
        if (pSafeModeOpenAndResetFileA ()) {

            if (Forced) {
                g_SafeModeActive = TRUE;

                if (g_SafeModeCrashTable == NULL) {
                    //
                    // we need to initialize safe mode crash table
                    //
                    g_SafeModeCrashTable = HtAllocA ();
                }
            }
            g_SafeModeInitialized = TRUE;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SafeModeInitializeW (
    BOOL Forced
    )
{
    WCHAR winDir[MAX_WCHAR_PATH];

    g_ExceptionOccured = FALSE;

    if (GetWindowsDirectoryW (winDir, MAX_WCHAR_PATH)) {

        g_SafeModePool = PoolMemInitNamedPool ("SafeMode Pool");

        //
        // BUGBUG -- technically this is wrong, it generates > MAX_PATH
        // potentially. However, this is an impractical case, and the
        // code is safe.
        //
        // BUGBUG -- This is inefficient. It breaks the paths pool by
        // allocating a global. Paths pool is optimized for short-term use
        // only.
        //

        g_SafeModeFileW = JoinPathsW (winDir, S_SAFE_MODE_FILEW);

        //
        // we are going to open the existing safe mode file
        // or to create a new one
        //
        if (pSafeModeOpenAndResetFileW ()) {

            if (Forced) {
                g_SafeModeActive = TRUE;

                if (g_SafeModeCrashTable == NULL) {
                    //
                    // we need to initialize safe mode crash table
                    //
                    g_SafeModeCrashTable = HtAllocA ();
                }
            }
            g_SafeModeInitialized = TRUE;
            return TRUE;
        }
    }
    return FALSE;
}



/*++

Routine Description:

  SafeModeShutDown is called to clean all data used by safe mode. It will remove
  safe mode file, release all used memory, reset all globals. Subsequent calls
  to safe mode functions after this will be noops.

Arguments:

  NONE

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeShutDownA (
    VOID
    )
{

    if (g_SafeModeInitialized) {

        //
        // Close and delete safe mode file.
        // Reset all globals.
        //
#ifdef DEBUG
        if (g_SafeModeLastNode != g_SafeModeCurrentNode) {
            DEBUGMSGA ((DBG_ERROR, "SafeMode: Unregistered action detected"));
        }
#endif


        if (!g_ExceptionOccured) {
            CloseHandle (g_SafeModeFileHandle);
            g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
            DeleteFileA (g_SafeModeFileA);
        }
        ELSE_DEBUGMSGA ((DBG_WARNING, "SafeModeShutDown called after exception. Files will not be cleaned up."));

        FreePathStringA (g_SafeModeFileA);
        g_SafeModeFileA = NULL;
        HtFree (g_SafeModeCrashTable);
        g_SafeModeCrashTable = NULL;
        g_SafeModeActive = FALSE;
        g_SafeModeInitialized = FALSE;
    }
    if (g_SafeModePool != NULL) {
        PoolMemDestroyPool (g_SafeModePool);
        g_SafeModePool = NULL;
    }
    return TRUE;
}

BOOL
SafeModeShutDownW (
    VOID
    )
{



    if (g_SafeModeInitialized) {

        //
        // Close and delete safe mode file.
        // Reset all globals.
        //
#ifdef DEBUG
        if (g_SafeModeLastNode != g_SafeModeCurrentNode) {
            DEBUGMSGW ((DBG_ERROR, "SafeMode: Unregistered action detected"));
        }
#endif

        if (!g_ExceptionOccured) {

            CloseHandle (g_SafeModeFileHandle);
            g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
            DeleteFileW (g_SafeModeFileW);
        }
        ELSE_DEBUGMSGW ((DBG_WARNING, "SafeModeShutDown called after exception. Files will not be cleaned up."));


        FreePathStringW (g_SafeModeFileW);
        g_SafeModeFileW = NULL;
        HtFree (g_SafeModeCrashTable);
        g_SafeModeCrashTable = NULL;
        g_SafeModeActive = FALSE;
        g_SafeModeInitialized = FALSE;
    }
    if (g_SafeModePool != NULL) {
        PoolMemDestroyPool (g_SafeModePool);
        g_SafeModePool = NULL;
    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeRegisterAction is called when we want to guard a specific part of
  the code. The caller should pass an guard ID and a guard string (used to
  uniquely identify the portion of code beeing guarded.

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeRegisterActionA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    DWORD noBytes;
    CRASHDATA_HEADER crashData;
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        SetFilePointer (
            g_SafeModeFileHandle,
            g_SafeModeCurrentNode->FilePtr,
            NULL,
            FILE_BEGIN
            );

        SetEndOfFile (g_SafeModeFileHandle);

        crashData.CrashId = Id;
        crashData.CrashStrSize = SizeOfStringA (String);

        WriteFile (
            g_SafeModeFileHandle,
            &crashData,
            sizeof (CRASHDATA_HEADER),
            &noBytes,
            NULL
            );

        WriteFile (
            g_SafeModeFileHandle,
            String,
            crashData.CrashStrSize,
            &noBytes,
            NULL
            );

        FlushFileBuffers (g_SafeModeFileHandle);

        node = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));

        node->Next = g_SafeModeCurrentNode;

        node->FilePtr = SetFilePointer (
                            g_SafeModeFileHandle,
                            0,
                            NULL,
                            FILE_CURRENT
                            );

        g_SafeModeCurrentNode = node;

    }
    return TRUE;
}

BOOL
SafeModeRegisterActionW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    DWORD noBytes;
    CRASHDATA_HEADER crashData;
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        SetFilePointer (
            g_SafeModeFileHandle,
            g_SafeModeCurrentNode->FilePtr,
            NULL,
            FILE_BEGIN
            );

        SetEndOfFile (g_SafeModeFileHandle);

        crashData.CrashId = Id;
        crashData.CrashStrSize = SizeOfStringW (String);

        WriteFile (
            g_SafeModeFileHandle,
            &crashData,
            sizeof (CRASHDATA_HEADER),
            &noBytes,
            NULL
            );

        WriteFile (
            g_SafeModeFileHandle,
            String,
            crashData.CrashStrSize,
            &noBytes,
            NULL
            );

        FlushFileBuffers (g_SafeModeFileHandle);

        node = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));

        node->Next = g_SafeModeCurrentNode;

        node->FilePtr = SetFilePointer (
                            g_SafeModeFileHandle,
                            0,
                            NULL,
                            FILE_CURRENT
                            );

        g_SafeModeCurrentNode = node;

    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeUnregisterAction is called when we want end the guard set for
  a specific part of the code. Since we allow nested guards, calling this
  function at the end of the guarded code is neccessary. The function will
  unregister the last registered guard.

Arguments:

  NONE

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeUnregisterActionA (
    VOID
    )
{
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        if (g_SafeModeCurrentNode != g_SafeModeLastNode) {

            node = g_SafeModeCurrentNode;

            g_SafeModeCurrentNode = g_SafeModeCurrentNode->Next;

            PoolMemReleaseMemory (g_SafeModePool, node);

            SetFilePointer (
                g_SafeModeFileHandle,
                g_SafeModeCurrentNode->FilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);
        }
#ifdef DEBUG
        else {
            DEBUGMSGA ((DBG_ERROR, "SafeMode: Too many actions unregistered."));
        }
#endif
    }
    return TRUE;
}

BOOL
SafeModeUnregisterActionW (
    VOID
    )
{
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        if (g_SafeModeCurrentNode != g_SafeModeLastNode) {

            node = g_SafeModeCurrentNode;

            g_SafeModeCurrentNode = g_SafeModeCurrentNode->Next;

            PoolMemReleaseMemory (g_SafeModePool, node);

            SetFilePointer (
                g_SafeModeFileHandle,
                g_SafeModeCurrentNode->FilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);
        }
#ifdef DEBUG
        else {
            DEBUGMSGW ((DBG_ERROR, "SafeMode: Too many actions unregistered."));
        }
#endif
    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeActionCrashed will return TRUE if one of the previous crashes
  was detected in the code guarded by these arguments.

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  TRUE if one of the previous crashes occured in the code guarded by the
  arguments, FALSE otherwise

--*/

BOOL
SafeModeActionCrashedA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    PCSTR crashString;
    BOOL result = FALSE;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        crashString = pGenerateCrashStringA (Id, String);
        result = crashString && (HtFindStringA (g_SafeModeCrashTable, crashString));
        PoolMemReleaseMemory (g_SafeModePool, (PVOID)crashString);
#ifdef DEBUG
        {
            UINT infId;

            infId = GetPrivateProfileIntA ("SafeMode", String, SAFEMODEID_FIRST, g_DebugInfPathA);
            result = result || (infId == Id);
        }
#endif
    }
    return result;
}

BOOL
SafeModeActionCrashedW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    PCWSTR crashString;
    BOOL result = FALSE;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        crashString = pGenerateCrashStringW (Id, String);
        result = crashString && (HtFindStringW (g_SafeModeCrashTable, crashString));
        PoolMemReleaseMemory (g_SafeModePool, (PVOID)crashString);
#ifdef DEBUG
        {
            UINT infId;

            infId = GetPrivateProfileIntW (L"SafeMode", String, SAFEMODEID_FIRST, g_DebugInfPathW);
            result = result || (infId == Id);
        }
#endif
    }
    return result;
}



/*++

Routine Description:

  SafeModeExceptionOccured is called by exception handlers to let Safemode
  know that something unexpected happened.

Arguments:

  None.

Return Value:



--*/


VOID
SafeModeExceptionOccured (
    VOID
    )
{
    g_ExceptionOccured = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\shappmgrp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for shappmgrp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shappmgrp_h__
#define __shappmgrp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IADCCtl_FWD_DEFINED__
#define __IADCCtl_FWD_DEFINED__
typedef interface IADCCtl IADCCtl;
#endif    /* __IADCCtl_FWD_DEFINED__ */


#ifndef __ADCCtl_FWD_DEFINED__
#define __ADCCtl_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADCCtl ADCCtl;
#else
typedef struct ADCCtl ADCCtl;
#endif /* __cplusplus */

#endif    /* __ADCCtl_FWD_DEFINED__ */


#ifndef __IInstalledApp_FWD_DEFINED__
#define __IInstalledApp_FWD_DEFINED__
typedef interface IInstalledApp IInstalledApp;
#endif    /* __IInstalledApp_FWD_DEFINED__ */


#ifndef __IEnumInstalledApps_FWD_DEFINED__
#define __IEnumInstalledApps_FWD_DEFINED__
typedef interface IEnumInstalledApps IEnumInstalledApps;
#endif    /* __IEnumInstalledApps_FWD_DEFINED__ */


#ifndef __EnumInstalledApps_FWD_DEFINED__
#define __EnumInstalledApps_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInstalledApps EnumInstalledApps;
#else
typedef struct EnumInstalledApps EnumInstalledApps;
#endif /* __cplusplus */

#endif    /* __EnumInstalledApps_FWD_DEFINED__ */


#ifndef __IShellAppManager_FWD_DEFINED__
#define __IShellAppManager_FWD_DEFINED__
typedef interface IShellAppManager IShellAppManager;
#endif    /* __IShellAppManager_FWD_DEFINED__ */


#ifndef __ShellAppManager_FWD_DEFINED__
#define __ShellAppManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellAppManager ShellAppManager;
#else
typedef struct ShellAppManager ShellAppManager;
#endif /* __cplusplus */

#endif    /* __ShellAppManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "shappmgr.h"

#ifdef __cplusplus
extern "C"{
#endif

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * );

/* interface __MIDL_itf_shappmgrp_0000 */
/* [local] */

#ifndef _SHAPPMGRP_H_
#define _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_s_ifspec;


#ifndef __SHAPPMGRPLib_LIBRARY_DEFINED__
#define __SHAPPMGRPLib_LIBRARY_DEFINED__

/* library SHAPPMGRPLib */
/* [version][lcid][helpstring][uuid] */


EXTERN_C const IID LIBID_SHAPPMGRPLib;

#ifndef __IADCCtl_INTERFACE_DEFINED__
#define __IADCCtl_INTERFACE_DEFINED__

/* interface IADCCtl */
/* [dual][object][oleautomation][unique][helpstring][uuid] */


EXTERN_C const IID IID_IADCCtl;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3964D99F-AC96-11D1-9851-00C04FD91972")
    IADCCtl : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dirty(
            /* [in] */ VARIANT_BOOL bDirty) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dirty(
            /* [retval][out] */ VARIANT_BOOL *pbDirty) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Category(
            /* [in] */ BSTR bstrCategory) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Category(
            /* [retval][out] */ BSTR *pbstrCategory) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Sort(
            /* [in] */ BSTR bstrSortExpr) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Sort(
            /* [retval][out] */ BSTR *pbstrSortExpr) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Forcex86(
            /* [in] */ VARIANT_BOOL bForce) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Forcex86(
            /* [retval][out] */ VARIANT_BOOL *pbForce) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowPostSetup(
            /* [retval][out] */ VARIANT_BOOL *pbShow) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDomain(
            /* [in] */ VARIANT_BOOL bOnDomain) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OnDomain(
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCategory(
            /* [retval][out] */ BSTR *pbstrCategory) = 0;

        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE msDataSourceObject(
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk) = 0;

        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE addDataSourceListener(
            /* [in] */ IUnknown *pEvent) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset(
            BSTR bstrQualifier) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsRestricted(
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted) = 0;

        virtual HRESULT STDMETHODCALLTYPE Exec(
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord) = 0;

    };

#else   /* C style interface */

    typedef struct IADCCtlVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IADCCtl * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IADCCtl * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IADCCtl * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IADCCtl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IADCCtl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dirty )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bDirty);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbDirty);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )(
            IADCCtl * This,
            /* [in] */ BSTR bstrCategory);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sort )(
            IADCCtl * This,
            /* [in] */ BSTR bstrSortExpr);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sort )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrSortExpr);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Forcex86 )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bForce);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forcex86 )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbForce);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPostSetup )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbShow);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDomain )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bOnDomain);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OnDomain )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultCategory )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);

        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *msDataSourceObject )(
            IADCCtl * This,
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk);

        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *addDataSourceListener )(
            IADCCtl * This,
            /* [in] */ IUnknown *pEvent);

        HRESULT ( STDMETHODCALLTYPE *Reset )(
            IADCCtl * This,
            BSTR bstrQualifier);

        HRESULT ( STDMETHODCALLTYPE *IsRestricted )(
            IADCCtl * This,
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted);

        HRESULT ( STDMETHODCALLTYPE *Exec )(
            IADCCtl * This,
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord);

        END_INTERFACE
    } IADCCtlVtbl;

    interface IADCCtl
    {
        CONST_VTBL struct IADCCtlVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IADCCtl_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADCCtl_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IADCCtl_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IADCCtl_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADCCtl_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADCCtl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADCCtl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADCCtl_put_Dirty(This,bDirty)  \
    (This)->lpVtbl -> put_Dirty(This,bDirty)

#define IADCCtl_get_Dirty(This,pbDirty)   \
    (This)->lpVtbl -> get_Dirty(This,pbDirty)

#define IADCCtl_put_Category(This,bstrCategory)   \
    (This)->lpVtbl -> put_Category(This,bstrCategory)

#define IADCCtl_get_Category(This,pbstrCategory)    \
    (This)->lpVtbl -> get_Category(This,pbstrCategory)

#define IADCCtl_put_Sort(This,bstrSortExpr)   \
    (This)->lpVtbl -> put_Sort(This,bstrSortExpr)

#define IADCCtl_get_Sort(This,pbstrSortExpr)    \
    (This)->lpVtbl -> get_Sort(This,pbstrSortExpr)

#define IADCCtl_put_Forcex86(This,bForce) \
    (This)->lpVtbl -> put_Forcex86(This,bForce)

#define IADCCtl_get_Forcex86(This,pbForce)  \
    (This)->lpVtbl -> get_Forcex86(This,pbForce)

#define IADCCtl_get_ShowPostSetup(This,pbShow)  \
    (This)->lpVtbl -> get_ShowPostSetup(This,pbShow)

#define IADCCtl_put_OnDomain(This,bOnDomain)    \
    (This)->lpVtbl -> put_OnDomain(This,bOnDomain)

#define IADCCtl_get_OnDomain(This,pbOnDomain) \
    (This)->lpVtbl -> get_OnDomain(This,pbOnDomain)

#define IADCCtl_get_DefaultCategory(This,pbstrCategory)   \
    (This)->lpVtbl -> get_DefaultCategory(This,pbstrCategory)

#define IADCCtl_msDataSourceObject(This,qualifier,ppUnk)    \
    (This)->lpVtbl -> msDataSourceObject(This,qualifier,ppUnk)

#define IADCCtl_addDataSourceListener(This,pEvent)  \
    (This)->lpVtbl -> addDataSourceListener(This,pEvent)

#define IADCCtl_Reset(This,bstrQualifier) \
    (This)->lpVtbl -> Reset(This,bstrQualifier)

#define IADCCtl_IsRestricted(This,bstrPolicy,pbRestricted)  \
    (This)->lpVtbl -> IsRestricted(This,bstrPolicy,pbRestricted)

#define IADCCtl_Exec(This,bstrQualifier,bstrCmd,nRecord)    \
    (This)->lpVtbl -> Exec(This,bstrQualifier,bstrCmd,nRecord)

#endif /* COBJMACROS */


#endif    /* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Dirty_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bDirty);


void __RPC_STUB IADCCtl_put_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Dirty_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbDirty);


void __RPC_STUB IADCCtl_get_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Category_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrCategory);


void __RPC_STUB IADCCtl_put_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Category_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Sort_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrSortExpr);


void __RPC_STUB IADCCtl_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Sort_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrSortExpr);


void __RPC_STUB IADCCtl_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Forcex86_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bForce);


void __RPC_STUB IADCCtl_put_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Forcex86_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbForce);


void __RPC_STUB IADCCtl_get_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_ShowPostSetup_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbShow);


void __RPC_STUB IADCCtl_get_ShowPostSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_OnDomain_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bOnDomain);


void __RPC_STUB IADCCtl_put_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_OnDomain_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbOnDomain);


void __RPC_STUB IADCCtl_get_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_DefaultCategory_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_DefaultCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_msDataSourceObject_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR qualifier,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IADCCtl_msDataSourceObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_addDataSourceListener_Proxy(
    IADCCtl * This,
    /* [in] */ IUnknown *pEvent);


void __RPC_STUB IADCCtl_addDataSourceListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Reset_Proxy(
    IADCCtl * This,
    BSTR bstrQualifier);


void __RPC_STUB IADCCtl_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_IsRestricted_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrPolicy,
    /* [retval][out] */ VARIANT_BOOL *pbRestricted);


void __RPC_STUB IADCCtl_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Exec_Proxy(
    IADCCtl * This,
    BSTR bstrQualifier,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ LONG nRecord);


void __RPC_STUB IADCCtl_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IADCCtl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ADCCtl;

#ifdef __cplusplus

class DECLSPEC_UUID("3964D9A0-AC96-11D1-9851-00C04FD91972")
ADCCtl;
#endif

#ifndef __IInstalledApp_INTERFACE_DEFINED__
#define __IInstalledApp_INTERFACE_DEFINED__

/* interface IInstalledApp */
/* [object][helpstring][uuid] */


EXTERN_C const IID IID_IInstalledApp;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1BC752DF-9046-11D1-B8B3-006008059382")
    IInstalledApp : public IShellApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Uninstall(
            HWND hwnd) = 0;

        virtual HRESULT STDMETHODCALLTYPE Modify(
            HWND hwndParent) = 0;

        virtual HRESULT STDMETHODCALLTYPE Repair(
            /* [in] */ BOOL bReinstall) = 0;

        virtual HRESULT STDMETHODCALLTYPE Upgrade( void) = 0;

    };

#else   /* C style interface */

    typedef struct IInstalledAppVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IInstalledApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IInstalledApp * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IInstalledApp * This);

        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )(
            IInstalledApp * This,
            /* [out][in] */ PAPPINFODATA pai);

        HRESULT ( STDMETHODCALLTYPE *GetPossibleActions )(
            IInstalledApp * This,
            /* [out] */ DWORD *pdwActions);

        HRESULT ( STDMETHODCALLTYPE *GetSlowAppInfo )(
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);

        HRESULT ( STDMETHODCALLTYPE *GetCachedSlowAppInfo )(
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);

        HRESULT ( STDMETHODCALLTYPE *IsInstalled )(
            IInstalledApp * This);

        HRESULT ( STDMETHODCALLTYPE *Uninstall )(
            IInstalledApp * This,
            HWND hwnd);

        HRESULT ( STDMETHODCALLTYPE *Modify )(
            IInstalledApp * This,
            HWND hwndParent);

        HRESULT ( STDMETHODCALLTYPE *Repair )(
            IInstalledApp * This,
            /* [in] */ BOOL bReinstall);

        HRESULT ( STDMETHODCALLTYPE *Upgrade )(
            IInstalledApp * This);

        END_INTERFACE
    } IInstalledAppVtbl;

    interface IInstalledApp
    {
        CONST_VTBL struct IInstalledAppVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IInstalledApp_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstalledApp_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInstalledApp_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IInstalledApp_GetAppInfo(This,pai)  \
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IInstalledApp_GetPossibleActions(This,pdwActions) \
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IInstalledApp_GetSlowAppInfo(This,psaid)    \
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IInstalledApp_GetCachedSlowAppInfo(This,psaid)  \
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IInstalledApp_IsInstalled(This)   \
    (This)->lpVtbl -> IsInstalled(This)


#define IInstalledApp_Uninstall(This,hwnd)  \
    (This)->lpVtbl -> Uninstall(This,hwnd)

#define IInstalledApp_Modify(This,hwndParent) \
    (This)->lpVtbl -> Modify(This,hwndParent)

#define IInstalledApp_Repair(This,bReinstall) \
    (This)->lpVtbl -> Repair(This,bReinstall)

#define IInstalledApp_Upgrade(This)   \
    (This)->lpVtbl -> Upgrade(This)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IInstalledApp_Uninstall_Proxy(
    IInstalledApp * This,
    HWND hwnd);


void __RPC_STUB IInstalledApp_Uninstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Modify_Proxy(
    IInstalledApp * This,
    HWND hwndParent);


void __RPC_STUB IInstalledApp_Modify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Repair_Proxy(
    IInstalledApp * This,
    /* [in] */ BOOL bReinstall);


void __RPC_STUB IInstalledApp_Repair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Upgrade_Proxy(
    IInstalledApp * This);


void __RPC_STUB IInstalledApp_Upgrade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IInstalledApp_INTERFACE_DEFINED__ */


#ifndef __IEnumInstalledApps_INTERFACE_DEFINED__
#define __IEnumInstalledApps_INTERFACE_DEFINED__

/* interface IEnumInstalledApps */
/* [object][helpstring][uuid] */


EXTERN_C const IID IID_IEnumInstalledApps;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1BC752E1-9046-11D1-B8B3-006008059382")
    IEnumInstalledApps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [out] */ IInstalledApp **pia) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumInstalledAppsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEnumInstalledApps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEnumInstalledApps * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEnumInstalledApps * This);

        HRESULT ( STDMETHODCALLTYPE *Next )(
            IEnumInstalledApps * This,
            /* [out] */ IInstalledApp **pia);

        HRESULT ( STDMETHODCALLTYPE *Reset )(
            IEnumInstalledApps * This);

        END_INTERFACE
    } IEnumInstalledAppsVtbl;

    interface IEnumInstalledApps
    {
        CONST_VTBL struct IEnumInstalledAppsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumInstalledApps_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInstalledApps_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumInstalledApps_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumInstalledApps_Next(This,pia) \
    (This)->lpVtbl -> Next(This,pia)

#define IEnumInstalledApps_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Next_Proxy(
    IEnumInstalledApps * This,
    /* [out] */ IInstalledApp **pia);


void __RPC_STUB IEnumInstalledApps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Reset_Proxy(
    IEnumInstalledApps * This);


void __RPC_STUB IEnumInstalledApps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IEnumInstalledApps_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_EnumInstalledApps;

#ifdef __cplusplus

class DECLSPEC_UUID("0B124F8F-91F0-11D1-B8B5-006008059382")
EnumInstalledApps;
#endif

#ifndef __IShellAppManager_INTERFACE_DEFINED__
#define __IShellAppManager_INTERFACE_DEFINED__

/* interface IShellAppManager */
/* [object][helpstring][uuid] */

typedef struct _ShellAppCategory
    {
    LPWSTR pszCategory;
    UINT idCategory;
    }   SHELLAPPCATEGORY;

typedef struct _ShellAppCategory *PSHELLAPPCATEGORY;

typedef struct _ShellAppCategoryList
    {
    UINT cCategories;
    SHELLAPPCATEGORY *pCategory;
    }   SHELLAPPCATEGORYLIST;

typedef struct _ShellAppCategoryList *PSHELLAPPCATEGORYLIST;


EXTERN_C const IID IID_IShellAppManager;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("352EC2B8-8B9A-11D1-B8AE-006008059382")
    IShellAppManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberofInstalledApps(
            DWORD *pdwResult) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumInstalledApps(
            IEnumInstalledApps **peia) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPublishedAppCategories(
            PSHELLAPPCATEGORYLIST pCategoryList) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumPublishedApps(
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa) = 0;

        virtual HRESULT STDMETHODCALLTYPE InstallFromFloppyOrCDROM(
            HWND hwndParent) = 0;

    };

#else   /* C style interface */

    typedef struct IShellAppManagerVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IShellAppManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IShellAppManager * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IShellAppManager * This);

        HRESULT ( STDMETHODCALLTYPE *GetNumberofInstalledApps )(
            IShellAppManager * This,
            DWORD *pdwResult);

        HRESULT ( STDMETHODCALLTYPE *EnumInstalledApps )(
            IShellAppManager * This,
            IEnumInstalledApps **peia);

        HRESULT ( STDMETHODCALLTYPE *GetPublishedAppCategories )(
            IShellAppManager * This,
            PSHELLAPPCATEGORYLIST pCategoryList);

        HRESULT ( STDMETHODCALLTYPE *EnumPublishedApps )(
            IShellAppManager * This,
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa);

        HRESULT ( STDMETHODCALLTYPE *InstallFromFloppyOrCDROM )(
            IShellAppManager * This,
            HWND hwndParent);

        END_INTERFACE
    } IShellAppManagerVtbl;

    interface IShellAppManager
    {
        CONST_VTBL struct IShellAppManagerVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IShellAppManager_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellAppManager_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IShellAppManager_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IShellAppManager_GetNumberofInstalledApps(This,pdwResult) \
    (This)->lpVtbl -> GetNumberofInstalledApps(This,pdwResult)

#define IShellAppManager_EnumInstalledApps(This,peia) \
    (This)->lpVtbl -> EnumInstalledApps(This,peia)

#define IShellAppManager_GetPublishedAppCategories(This,pCategoryList)  \
    (This)->lpVtbl -> GetPublishedAppCategories(This,pCategoryList)

#define IShellAppManager_EnumPublishedApps(This,pszCategory,ppepa)  \
    (This)->lpVtbl -> EnumPublishedApps(This,pszCategory,ppepa)

#define IShellAppManager_InstallFromFloppyOrCDROM(This,hwndParent)  \
    (This)->lpVtbl -> InstallFromFloppyOrCDROM(This,hwndParent)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IShellAppManager_GetNumberofInstalledApps_Proxy(
    IShellAppManager * This,
    DWORD *pdwResult);


void __RPC_STUB IShellAppManager_GetNumberofInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumInstalledApps_Proxy(
    IShellAppManager * This,
    IEnumInstalledApps **peia);


void __RPC_STUB IShellAppManager_EnumInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_GetPublishedAppCategories_Proxy(
    IShellAppManager * This,
    PSHELLAPPCATEGORYLIST pCategoryList);


void __RPC_STUB IShellAppManager_GetPublishedAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumPublishedApps_Proxy(
    IShellAppManager * This,
    LPCWSTR pszCategory,
    IEnumPublishedApps **ppepa);


void __RPC_STUB IShellAppManager_EnumPublishedApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_InstallFromFloppyOrCDROM_Proxy(
    IShellAppManager * This,
    HWND hwndParent);


void __RPC_STUB IShellAppManager_InstallFromFloppyOrCDROM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IShellAppManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellAppManager;

#ifdef __cplusplus

class DECLSPEC_UUID("352EC2B7-8B9A-11D1-B8AE-006008059382")
ShellAppManager;
#endif
#endif /* __SHAPPMGRPLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shappmgrp_0257 */
/* [local] */

#endif // _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\pchw\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"
#include "migutilp.h"

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK 32

extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PGROWBUFFER g_LastAllocTable;        // in main.c

extern POOLHANDLE g_TextPool;

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


PCWSTR g_FailedGetResourceString = L"";




/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      POOLHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PoolMemGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    text [0] = 0;

    return text;
}

PWSTR
RealAllocTextExW (
    IN      POOLHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PoolMemGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    text [0] = 0;

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR Buf;
    PSTR d;
    PCSTR s;


    Buf = AllocTextExA (Pool, LcharCountA (Text) + ExtraChars + 1);
    if (Buf) {
        s = Text;
        d = Buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}

PWSTR
RealDuplicateTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR Buf;
    PWSTR d;
    PCWSTR s;

    Buf = AllocTextExW (Pool, wcslen (Text) + ExtraChars + 1);
    if (Buf) {
        s = Text;
        d = Buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR Buf;
    PSTR End;
    PSTR d;
    PCSTR s;

    Buf = DuplicateTextExA (
              Pool,
              String1,
              LcharCountA (String2) + ExtraChars + (CenterString ? LcharCountA (CenterString) : 0),
              &End
              );

    if (Buf) {

        d = End;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                *d++ = *s++;
            }
        }

        s = String2;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


PWSTR
RealJoinTextExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR Buf;
    PWSTR End;
    PCWSTR s;
    PWSTR d;

    Buf = DuplicateTextExW (
              Pool,
              String1,
              wcslen (String2) + ExtraChars + (CenterString ? wcslen(CenterString) : 0),
              &End
              );

    if (Buf) {
        d = End;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                *d++ = *s++;
            }
        }

        s = String2;

        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR InString,
    IN PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    INT     maxSize             = 0;
    INT     curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    //
    // We assume that InString is valid.
    //
    MYASSERT(InString);


    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize > maxSize - 3) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpanEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    memcpy(newString,rString,curSize * sizeof(WCHAR));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW((UINT) (UINT_PTR) (nextPercent - source));

                        _wcssafecpyab(envName,source+1,nextPercent,(nextPercent - source)*sizeof(WCHAR));


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Odd entries of this list are env var names. Even entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PWSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableW(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            } else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextW(size);


                                if ((size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }

                                freeValue = TRUE;
                            }
                        }


                        if (foundValue) {
                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;
                       }
                       else {
                            DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;
                       }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextW(envName);
                        envName = NULL;
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //
            rString[curSize++] = *source++;


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) {
                        rString[curSize] = 0;
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;
                }
            }

        }
    }
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}

PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR InString,
    IN PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    INT    maxSize             = 0;
    INT    curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    //
    // We assume that InString is valid.
    //
    MYASSERT(InString);

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize > maxSize - 3) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (rString) {
                    memcpy(newString,rString,curSize * sizeof(CHAR));
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA((UINT) (UINT_PTR) (nextPercent - source));
                        _mbssafecpyab(envName,source+1,nextPercent,nextPercent - source);


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatch(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableA(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            }
                            else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextA(size);
                                freeValue = TRUE;

                                if ((size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }
                            }
                        }




                        if (foundValue) {

                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;



                        }
                        else {
                            DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;

                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextA(envName);
                        envName = NULL;


                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(source)) {
                rString[curSize++] = *source++;
            }
            rString[curSize++] = *source++;


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) {
                        rString[curSize] = 0;
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;
                }
            }
        }
    }
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}

/*++

Routine Description:

  StringCbAppendWackA calls AppendWackA only if the buffer is large enough
  to contain an additional backslash.

Arguments:

  str       - Specifies a buffer that holds the path
  buflen    - Specifies the length of the entire bufer in bytes, not characters

Return Value:

  none

--*/
PSTR
StringCbAppendWackA (
    IN      PSTR str,
    IN      UINT buflen
)
{
    //allow space for one null byte and one backslash
    if (ByteCountA(str) + 2 <= buflen)
        return AppendWackA(str);
    else
        return NULL;
}

/*++

Routine Description:

  StringCbAppendWackW calls AppendWackW only if the buffer is large enough
  to contain an additional backslash.

Arguments:

  str       - Specifies a buffer that holds the path
  buflen    - Specifies the length of the entire bufer in bytes, not characters

Return Value:

  none

--*/
PWSTR
StringCbAppendWackW (
    IN      PWSTR str,
    IN      UINT buflen
)
{
    //allow space for one null byte and one backslash
    if (ByteCountW(str) + 4 <= buflen)
        return AppendWackW(str);
    else
        return NULL;
}


/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str)
        return str;

    Last = str;

    while (*str) {
        Last = str;
        str = our_mbsinc (str);
    }

    if (*Last != '\\') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}

PWSTR
AppendWackW (
    IN PWSTR str
    )
{
    PCWSTR Last;

    if (!str)
        return str;

    if (*str) {
        str = GetEndOfStringW (str);
        Last = str - 1;
    } else {
        Last = str;
    }

    if (*Last != '\\') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}

PSTR
AppendDosWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str || !(*str))
        return str;

    do {
        Last = str;
        str = our_mbsinc (str);
    } while (*str);

    if (*Last != '\\' && *Last != ':') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}


PWSTR
AppendDosWackW (
    IN PWSTR str
    )
{
    PWSTR Last;

    if (!str || !(*str))
        return str;

    str = GetEndOfStringW (str);
    Last = str - 1;

    if (*Last != L'\\' && *Last != L':') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}


PSTR
AppendUncWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str || !(*str))
        return str;

    do {
        Last = str;
        str = our_mbsinc (str);
    } while (*str);

    if (*Last != '\\') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}


PWSTR
AppendUncWackW (
    IN PWSTR str
    )
{
    PWSTR Last;

    if (!str || !(*str))
        return str;

    str = GetEndOfStringW (str);
    Last = str - 1;

    if (*Last != L'\\') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}

PSTR
AppendPathWackA (
    IN PSTR str
    )
{
    if (!str) {
        return str;
    }

    if (str[0] == '\\' && str[1] == '\\') {
        return AppendUncWackA (str);
    }

    return AppendDosWackA (str);
}


PWSTR
AppendPathWackW (
    IN PWSTR str
    )
{
    if (!str) {
        return str;
    }

    if (str[0] == L'\\' && str[1] == L'\\') {
        return AppendUncWackW (str);
    }

    return AppendDosWackW (str);
}


/*++

Routine Description:

  RealJoinPathsEx joins 2 paths, introducing a backslash between them
  if needed. If the first path is empty, it makes sure the resulting path
  does NOT start with a backslash. If the second path is empty, it makes
  sure the resulting path ends in a backslash.

Arguments:

  Pool - Pool handle used to allocate memory from
  PathA - First path
  PathB - Second path

Return Value:

  Pointer to the new (combined) path

--*/

PSTR
RealJoinPathsExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR PathA,
    IN      PCSTR PathB
    )
{
    PSTR end;
    PSTR endMinusOne;
    DWORD Size;
    PSTR Dest;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    Size = ByteCountA (PathA) + 1 + SizeOfStringA (PathB);
    Dest = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    MYASSERT (Dest);

    *Dest = 0;
    end = _mbsappend (Dest, PathA);
    endMinusOne = our_mbsdec (Dest, end);
    if (endMinusOne && our_mbsnextc (endMinusOne) != '\\') {
        *end = '\\';
        end++;
    }
    //
    // BUGBUG: this may actually cut a whack from PathB if PathA is empty
    //
    if (our_mbsnextc (PathB) == '\\') {
        PathB = our_mbsinc (PathB);
    }
    StringCopyA (end, PathB);

    return Dest;
}

PWSTR
RealJoinPathsExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR PathA,
    IN      PCWSTR PathB
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    DWORD Size;
    PWSTR Dest;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    Size = ByteCountW (PathA) + sizeof (WCHAR) + SizeOfStringW (PathB);
    Dest = (PWSTR) PoolMemGetAlignedMemory (Pool, Size);
    MYASSERT (Dest);

    *Dest = 0;
    end = _wcsappend (Dest, PathA);
    endMinusOne = _wcsdec2 (Dest, end);
    if (endMinusOne && *endMinusOne != L'\\') {
        *end = L'\\';
        end++;
    }
    //
    // BUGBUG: this may actually cut a whack from PathB if PathA is empty
    //
    if (*PathB == L'\\') {
        PathB++;
    }
    StringCopyW (end, PathB);

    return Dest;
}


/*++

Routine Description:

  RealAllocPathString allocates a buffer of specified size from the
  Paths pool. If no size is specified, MAX_TCHAR_PATH is assumed

Arguments:

  Chars - Specifies how large the buffer is (in TCHARs)

Return Value:

  Pointer to the newly allocated path

--*/

PSTR
RealAllocPathStringA (
    DWORD Chars
    )
{
    PSTR Str;

    if (Chars == 0) {
        Chars = MAX_MBCHAR_PATH;
    }

    Str = (PSTR) PoolMemGetAlignedMemory (g_PathsPool, Chars);

    Str [0] = 0;

    return Str;
}

PWSTR
RealAllocPathStringW (
    DWORD Chars
    )
{
    PWSTR Str;

    if (Chars == 0) {
        Chars = MAX_WCHAR_PATH;
    }

    Str = (PWSTR) PoolMemGetAlignedMemory (g_PathsPool, Chars * sizeof (WCHAR));

    Str [0] = 0;

    return Str;
}

/*++

Routine Description:

  RealSplitPath splits a path into components. Any element except the source string
  is optional. The caller should free the allocated buffers when done with them
  via FreePathString

Arguments:

  Path - Specifies the source path

  DrivePtr - Receives the drive letter

  PathPtr - Receives the sub-path relative to the drive letter

  FileNamePtr - Receives the filename part

  ExtPtr - Receives the file extension part

Return Value:

  none

--*/

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR FileName[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];

    _splitpath (Path, Drive, Dir, FileName, Ext);

    if (DrivePtr) {
        *DrivePtr = PoolMemDuplicateStringA (g_PathsPool, Drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PoolMemDuplicateStringA (g_PathsPool, Dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PoolMemDuplicateStringA (g_PathsPool, FileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PoolMemDuplicateStringA (g_PathsPool, Ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR Drive[_MAX_DRIVE];
    WCHAR Dir[_MAX_DIR];
    WCHAR FileName[_MAX_FNAME];
    WCHAR Ext[_MAX_EXT];

    _wsplitpath (Path, Drive, Dir, FileName, Ext);

    if (DrivePtr) {
        *DrivePtr = PoolMemDuplicateStringW (g_PathsPool, Drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PoolMemDuplicateStringW (g_PathsPool, Dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PoolMemDuplicateStringW (g_PathsPool, FileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PoolMemDuplicateStringW (g_PathsPool, Ext);
        MYASSERT (*ExtPtr);
    }
}

/*++

Routine Description:

  RealDuplicatePathString duplicates a source path, optionally
  reserving extra memory

Arguments:

  Path - The path to duplicate

  ExtraBytes - Extra bytes (not TCHARs) to allocate

Return Value:

  Pointer to the newly allocated buffer; caller must free with FreePathString

--*/

PSTR
RealDuplicatePathStringA (
    PCSTR Path,
    DWORD ExtraBytes
    )
{
    PSTR str;

    str = PoolMemGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}

PWSTR
RealDuplicatePathStringW (
    PCWSTR Path,
    DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PoolMemGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


PSTR
pCopyAndCleanupPathsA (
    IN      PCSTR Source,
    OUT     PSTR Dest
    )

/*++

Routine Description:

  pCopyAndCleanupPathsA sanitizes the Source path (i.e. removes leading spaces
  and any quotes inside the string). Dest and Source may be identical pointers.
  If they are not, Dest is assumed big enough to hold the sanitized copy
  of Source (final Dest length never exceeds that of Source).

Arguments:

  Source - Specifies the source path

  Dest - Receives the sanitized path

Return Value:

  A pointer to the end (the null char) of the destination buffer.

--*/

{
    //
    // eliminate leading blanks
    //
    while (*Source && _ismbcspace (*Source)) {
        Source = our_mbsinc (Source);
    }

    while (*Source) {
        //
        // skip quotes
        //
        if (*Source == '\"') {
            Source++;
        } else {
            if (IsLeadByte (Source)) {
                *Dest++ = *Source++;
            }
            *Dest++ = *Source++;
        }
    }

    *Dest = 0;

    return Dest;
}

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,       OPTIONAL
    IN      PCSTR WinDir,               OPTIONAL
    IN      PCSTR SysDir,               OPTIONAL
    IN      BOOL IncludeEnvPath         OPTIONAL
    )

/*++

Routine Description:

  EnumFirstPathExA starts the path enumeration from a buffer built according to
  the input params.
  IT DOES NOT ENUMERATE PATHS LONGER THAN MAX_TCHAR_PATH CHARS!

Arguments:

  PathEnum - Receives the first enumerated path

  AdditionalPath - Specifies a caller-supplied path to start enumeration with

  WinDir - Specifies an additional path to enumerate

  SysDir - Specifies an additional path to enumerate

  IncludeEnvPath - Indicates if the enumerator should include the paths
                   specified by the PATH environment variable

Return Value:

  TRUE if at least one path is enumerated

--*/

{
    DWORD bufferSize = 0;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    if (IncludeEnvPath) {
        bufferSize = pathSize = GetEnvironmentVariableA ("PATH", NULL, 0);
    }
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = MemAlloc (g_hHeap, 0, bufferSize + 1);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    currPathEnd = PathEnum->BufferPtr;
    if (AdditionalPath != NULL) {
        currPathEnd = _mbsappend (currPathEnd, AdditionalPath);
    }
    if (SysDir != NULL) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        currPathEnd = _mbsappend (currPathEnd, SysDir);
    }
    if (WinDir != NULL) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        currPathEnd = _mbsappend (currPathEnd, WinDir);
    }
    if (IncludeEnvPath) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        GetEnvironmentVariableA ("PATH", currPathEnd, pathSize);
    }

    //
    // clean up quotes
    //
    pCopyAndCleanupPathsA (currPathEnd, currPathEnd);

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )

/*++

Routine Description:

  EnumNextPathA enumerates the next path.
  IT DOES NOT ENUMERATE PATHS LONGER THAN MAX_TCHAR_PATH CHARS!

Arguments:

  PathEnum - Specifies/Receives the next enumerated path

Return Value:

  TRUE if a new path is enumerated

--*/

{
    do {
        if (PathEnum->PtrNextPath == NULL) {
            EnumPathAbort (PathEnum);
            return FALSE;
        }
        PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

        PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
        if (PathEnum->PtrNextPath != NULL) {
            if (PathEnum->PtrNextPath - PathEnum->PtrCurrPath >= MAX_MBCHAR_PATH) {
                *PathEnum->PtrNextPath = 0;
                LOG ((
                    LOG_WARNING,
                    "Skipping enumeration of path (too long): %s",
                    PathEnum->PtrCurrPath
                    ));
                *PathEnum->PtrNextPath = ';';
                //
                // cut this path
                //
                *PathEnum->PtrCurrPath = 0;
                //
                // and continue with the next one
                //
                continue;
            }
            *PathEnum->PtrNextPath++ = 0;
            if (*(PathEnum->PtrNextPath) == 0) {
                PathEnum->PtrNextPath = NULL;
            }
        } else {
            if (ByteCountA (PathEnum->PtrCurrPath) >= MAX_MBCHAR_PATH) {
                LOG ((
                    LOG_WARNING,
                    "Skipping enumeration of path (too long): %s",
                    PathEnum->PtrCurrPath
                    ));
                //
                // cut this path
                //
                *PathEnum->PtrCurrPath = 0;
            }
        }

    } while (*(PathEnum->PtrCurrPath) == 0);

    return TRUE;
}

BOOL
EnumPathAbortA (
    IN OUT  PPATH_ENUMA PathEnum
    )

/*++

Routine Description:

  EnumPathAbortA aborts enumeration of PathEnum, freeing any resources.

Arguments:

  PathEnum - Specifies/Receives the enumeration object to be freed

Return Value:

  TRUE

--*/

{
    if (PathEnum->BufferPtr != NULL) {
        MemFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    //
    // BUGBUG - eliminate this; nobody cares
    //
    return TRUE;
}



/*++

Routine Description:

  FreePathStringEx frees the specified buffer.

Arguments:

  Pool - Specifies the pool to be used; the Paths pool if not specified

  Path - A pointer to the buffer to be freed

Return Value:

  none

--*/

VOID
FreePathStringExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PoolMemReleaseMemory (Pool, (PSTR) Path);
    }
}

VOID
FreePathStringExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PoolMemReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;

VOID
PushNewError (
    IN      DWORD dwError
    )
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

VOID
PushError (
    VOID
    )
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (
    VOID
    )
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

INT
GetHexDigit (
    IN      INT c
    )
{
    if (c >= (INT)'0' && c <= (INT)'9')
        return (c - (INT)'0');

    if (c >= (INT)'a' && c <= (INT)'f')
        return (c - 'a' + 10);

    if (c >= (INT)'A' && c <= (INT)'F')
        return (c - (INT)'A' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, up to the first invalid char

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, up to the first invalid char

--*/

DWORD
_mbsnum (
    IN      PCSTR szNum
    )
{
    UINT d = 0;
    INT i;

    if (szNum[0] == '0' && tolower (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + i;
            szNum++;
        }
    } else {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD
_wcsnum (
    IN      PCWSTR szNum
    )
{
    UINT d = 0;
    INT i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + i;
            szNum++;
        }
    } else {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  _tcsappend is a strcpy that returns the pointer to the end
  of a string instead of the beginning.

Arguments:

  szDest - A pointer to a caller-allocated buffer that may point
           anywhere within the string to append to
  szSrc  - A pointer to a string that is appended to szDest

Return Value:

  A pointer to the NULL terminator within the szDest string.

--*/

PSTR
_mbsappend (
    OUT     PSTR mbstrDest,
    IN      PCSTR mbstrSrc
    )
{
    // Advance mbstrDest to end of string
    mbstrDest = GetEndOfStringA (mbstrDest);

    // Copy string
    while (*mbstrSrc) {
        *mbstrDest++ = *mbstrSrc++;
    }

    *mbstrDest = 0;

    return mbstrDest;
}


PWSTR
_wcsappend (
    OUT     PWSTR wstrDest,
    IN      PCWSTR wstrSrc
    )
{
    // Advance wstrDest to end of string
    wstrDest = GetEndOfStringW (wstrDest);

    // Copy string
    while (*wstrSrc) {
        *wstrDest++ = *wstrSrc++;
    }

    *wstrDest = 0;

    return wstrDest;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (
    IN      PCSTR mbstrStr,
    IN      PCSTR mbstrSubStr
    )
{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = our_mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               _mbctolower ((MBCHAR) our_mbsnextc (mbstrSubStrPos)) == _mbctolower ((MBCHAR) our_mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = our_mbsinc (mbstrStrPos);
            mbstrSubStrPos = our_mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (
    IN      PCWSTR wstrStr,
    IN      PCWSTR wstrSubStr
    )
{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  StringCompareAB compares a string against a string between two string pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  End - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and End
  Zero: String matches the string between Start and End identically
  Greater than zero: String is numerically greater than the string between Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (our_mbsnextc (String) != our_mbsnextc (Start)) {
            break;
        }

        String = our_mbsinc (String);
        Start = our_mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return our_mbsnextc (Start) - our_mbsnextc (String);
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


/*++

Routine Description:

  StringICompareAB compares case-insensitive a string against a string between two string pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  End - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and End
  Zero: String matches case-insensitive the string between Start and End
  Greater than zero: String is numerically greater than the string between Start and End

--*/

INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbctolower (our_mbsnextc (String)) != _mbctolower (our_mbsnextc (Start))) {
            break;
        }

        String = our_mbsinc (String);
        Start = our_mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return _mbctolower (our_mbsnextc (Start)) - _mbctolower (our_mbsnextc (String));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



VOID
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.
  WARNING: the function may grow the string with one byte!

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR)c;
    } else {
        if (!IsLeadByte (Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *PtrToRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  PtrToRule - A pointer to a pointer; a caller-allocated buffer that
              holds the rule string.
  FromHex - A pointer to a caller-allocated BOOL that receives TRUE
            when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *FromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (our_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        //
        // don't allow more than 2 bytes for a char
        //
        for (i = 0 ; **PtrToRule; i++) {

            ch = our_mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            if (i >= 4) {
                break;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = our_mbsinc (StartPtr);
    return our_mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            if (i >= 4) {
                break;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (mbstrEncRule), possibly
  encoded with hex-specified character values (~xx~).  The output
  string contains unencoded characters.
  The output buffer is guaranteed to be NULL-terminated

Arguments:

  mbstrRule    - A caller-allocated buffer, big enough to hold an
                 unencoded rule.  szRule can be equal to szEncRule.
  mbstrRuleBufferChars - Size in TCHARs of mbstrRule, including
                         the NULL terminator
  mbstrEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to mbstrRule or NULL if mbstrRuleBufferSize is 0.

--*/

PSTR
DecodeRuleCharsA (
    IN      PSTR mbstrRule,
    IN      DWORD mbstrRuleBufferChars,
    IN      PCSTR mbstrEncRule
    )
{
    MBCHAR c;
    PSTR mbstrOrgRule;

    if (!mbstrRuleBufferChars) {
        MYASSERT (FALSE);
        return NULL;
    }

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (--mbstrRuleBufferChars) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        if (!c) {
            break;
        }
        if ((c > 0xFF) && (mbstrRuleBufferChars < 2)) {
            //
            // dest buffer doesn't accomodate the whole DBCS char
            //
            break;
        }
        if (c > 0xFF) {
            *mbstrRule = (CHAR)(c >> 8);
            mbstrRule++;
        }
        *mbstrRule = (CHAR)c;
        mbstrRule++;
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (
    IN      PWSTR wstrRule,
    IN      DWORD wstrRuleBufferChars,
    IN      PCWSTR wstrEncRule
    )
{
    WCHAR c;
    PWSTR wstrOrgRule;

    if (!wstrRuleBufferChars) {
        MYASSERT (FALSE);
        return NULL;
    }

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (--wstrRuleBufferChars) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        if (!c) {
            break;
        }
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  DecodeRuleCharsAB takes a portion of a rule string (mbstrEncRule), possibly
  encoded with hex-specified character values (~xx~).  The output
  string contains unencoded characters.
  The output buffer is guaranteed to be NULL-terminated

Arguments:

  mbstrRule    - A caller-allocated buffer, big enough to hold an
                 unencoded rule.  szRule can be equal to szEncRule.
  mbstrRuleBufferChars - Size in TCHARs of mbstrRule, including
                         the NULL terminator
  mbstrEncRule - The string holding a possibly encoded string.
  End - Specifies the end of the portion to decode

Return Value:

  Equal to mbstrRule or NULL if mbstrRuleBufferSize is 0.

--*/

PSTR
DecodeRuleCharsABA (
    IN      PSTR mbstrRule,
    IN      DWORD mbstrRuleBufferChars,
    IN      PCSTR mbstrEncRule,
    IN      PCSTR End
    )
{
    MBCHAR c;
    PSTR mbstrOrgRule;

    if (!mbstrRuleBufferChars) {
        MYASSERT (FALSE);
        return NULL;
    }

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    *mbstrRule = 0;
    while (--mbstrRuleBufferChars && mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        if (!c) {
            break;
        }
        if ((c > 0xFF) && (mbstrRuleBufferChars < 2)) {
            //
            // dest buffer doesn't accomodate the whole DBCS char
            //
            break;
        }
        if (c > 0xFF) {
            *mbstrRule = (CHAR)(c >> 8);
            mbstrRule++;
        }
        *mbstrRule = (CHAR)c;
        mbstrRule++;
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (
    IN      PWSTR wstrRule,
    IN      DWORD wstrRuleBufferChars,
    IN      PCWSTR wstrEncRule,
    IN      PCWSTR End
    )

{
    WCHAR c;
    PWSTR wstrOrgRule;

    if (!wstrRuleBufferChars) {
        MYASSERT (FALSE);
        return NULL;
    }

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (--wstrRuleBufferChars && wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        if (!c) {
            break;
        }
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  mbstrEncRule -  A caller-allocated buffer, big enough to hold an
                  encoded rule.  szEncRule CAN NOT be equal to szRule.
                  One way to calculate a max buffer size for szEncRule
                  is to use the following code:

                      allocsize = _tcslen (szRule) * 6 * sizeof(TCHAR);

                  In the worst case, each character in szRule will take
                  six single-byte characters in szEncRule.  In the normal
                  case, szEncRule will only be a few bytes bigger than
                  szRule.

  mbstrRuleBufferChars - Size in TCHARs of mbstrEncRule, including
                         the NULL terminator

  mbstrRule - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsA (
    IN      PSTR mbstrEncRule,
    IN      DWORD mbstrEncRuleChars,
    IN      PCSTR mbstrRule
    )
{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;
    INT len;

    if (!mbstrEncRuleChars) {
        MYASSERT (FALSE);
        return NULL;
    }

    mbstrOrgRule = mbstrEncRule;

    while (--mbstrEncRuleChars && *mbstrRule)  {
        c = our_mbsnextc (mbstrRule);
        MYASSERT (c < 0x10000);

        if ((c > 127) || _mbschr (mbstrExclusions, c)) {

            // Escape unprintable or excluded character
            len = _snprintf (mbstrEncRule, mbstrEncRuleChars, "~%X~", c);
            if (len < 0) {
                //
                // not enough output buffer, fix this
                //
                MYASSERT (FALSE);
                break;
            }
            MYASSERT (mbstrEncRuleChars > (DWORD)len);
            mbstrEncRuleChars -= len;
            mbstrEncRule += len;
            MYASSERT (*mbstrEncRule == 0);
            mbstrRule = our_mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
                --mbstrEncRuleChars;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsW (
    IN      PWSTR wstrEncRule,
    IN      DWORD wstrEncRuleChars,
    IN      PCWSTR wstrRule
    )
{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;
    INT len;

    if (!wstrEncRule) {
        MYASSERT (FALSE);
        return NULL;
    }


    wstrOrgRule = wstrEncRule;

    while (--wstrEncRuleChars && (c = *wstrRule))   {
        if ((c > 127) || wcschr (wstrExclusions, c)) {
            len = _snwprintf (wstrEncRule, wstrEncRuleChars, L"~%X~", c);
            if (len < 0) {
                //
                // not enough output buffer, fix this
                //
                MYASSERT (FALSE);
                break;
            }
            MYASSERT (wstrEncRuleChars > (DWORD)len);
            wstrEncRuleChars -= len;
            wstrEncRule += len;
            MYASSERT (*wstrEncRule == 0);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


INT
_mbsisprint (
    IN      PCSTR mbstrStr
    )
{
    while (*mbstrStr && _ismbcprint ((MBCHAR) our_mbsnextc (mbstrStr))) {
        mbstrStr = our_mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


INT
_wcsisprint (
    IN      PCWSTR wstrStr
    )
{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime _ismbcspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (
    IN      PCSTR mbstrStr
    )
{
    while (_ismbcspace ((MBCHAR) our_mbsnextc (mbstrStr))) {
        mbstrStr = our_mbsinc (mbstrStr);
    }

    return mbstrStr;
}


PCWSTR
SkipSpaceW (
    IN      PCWSTR wstrStr
    )
{
    while (iswspace (*wstrStr)) {
        wstrStr++;
    }

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime _ismbcspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {
        Str = our_mbsdec (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) our_mbsnextc(Str))) {
            return Str;
        }

    } while (Str = our_mbsdec(StrBase, Str));

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses _istspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) our_mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = our_mbsinc (Str);
    }

    if (LastNonSpace) {
        if('\0' != *our_mbsinc (LastNonSpace)){
            *our_mbsinc (LastNonSpace) = '\0';
        }
    } else {
        *OrgStr = '\0';
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        if('\0' != *(LastNonSpace + 1)){
            *(LastNonSpace + 1) = '\0';
        }
    } else {
        *OrgStr = '\0';
    }
}



/*++

Routine Description:

  _tcsnzcpy copies bytecount bytes from the source string to the
  destination string, and terminates the string if it needs to
  be truncated.  This function is a _tcsncpy, plus a terminating
  nul.

  _tcsnzcpy always requires a destination buffer that can hold
  bytecount + sizeof (TCHAR) bytes.

  Use the _tcssafecpy macros to specify the maximum number of bytes
  to copy, including the nul.

Arguments:

  dest      - The destination buffer that is at least bytecount + sizeof(TCHAR)
  src       - The source string
  bytecount - The number of bytes to copy.  If src is greater than bytecount,
              the destination string is truncated.

Return Value:

  A pointer to dest.

--*/

PSTR
_mbsnzcpy (
    PSTR dest,
    PCSTR src,
    INT bytecount
    )
{
    PSTR realdest;

    realdest = dest;
    while (*src && bytecount >= sizeof (CHAR)) {
        if (IsLeadByte (src)) {
            if (bytecount == 1) {
                // double char can't fit
                break;
            }
            *dest++ = *src++;
            bytecount--;
        }
        *dest++ = *src++;
        bytecount--;
    }
    *dest = 0;

    return realdest;
}

PWSTR
_wcsnzcpy (
    PWSTR dest,
    PCWSTR src,
    INT bytecount
    )
{
    PWSTR realdest;

    realdest = dest;
    while (*src && bytecount >= sizeof (WCHAR)) {
        *dest++ = *src++;
        bytecount -= sizeof(WCHAR);
    }
    *dest = 0;

    return realdest;
}



/*++

Routine Description:

  _tcsnzcpyab copies bytecount bytes between two pointers to the
  destination string, and terminates the string if it needs to
  be truncated.  This function is a _tcscpyab, plus a terminating
  nul, plus bytecount safety guard.

  _tcsnzcpy always requires a destination buffer that can hold
  bytecount + sizeof (TCHAR) bytes.

  Use the _tcssafecpyab macros to specify the maximum number of bytes
  to copy, including the nul.

Arguments:

  Dest      - The destination buffer that is at least bytecount + sizeof(TCHAR)
  Start     - The start of the source string
  End       - Points to the character one position past the
              last character to copy in the string pointed to
              by start.
  bytecount - The number of bytes to copy.  If src is greater than bytecount,
              the destination string is truncated.

Return Value:

  A pointer to Dest.  Start and End must be pointers within
  the same string, and End must be greater than Start.  If
  it isn't, the function will make the string empty.

--*/

PSTR
_mbsnzcpyab (
    PSTR Dest,
    PCSTR Start,
    PCSTR End,
    INT count
    )
{
    PSTR realdest;

    realdest = Dest;
    while ((Start < End) && count >= sizeof (CHAR)) {
        if (IsLeadByte (Start)) {
            if (count == 1) {
                // double char can't fit
                break;
            }
            *Dest++ = *Start++;
            count--;
        }
        *Dest++ = *Start++;
        count--;
    }
    *Dest = 0;

    return realdest;
}

PWSTR
_wcsnzcpyab (
    PWSTR Dest,
    PCWSTR Start,
    PCWSTR End,
    INT count
    )
{
    PWSTR realdest;

    realdest = Dest;
    while ((Start < End) && count >= sizeof (WCHAR)) {
        *Dest++ = *Start++;
        count -= sizeof(WCHAR);
    }
    *Dest = 0;

    return realdest;
}


/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) our_mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) our_mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (our_mbsnextc (our_mbsinc (strPattern)) == '*') {
                strPattern = our_mbsinc (strPattern);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!our_mbsnextc (our_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (our_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = our_mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = our_mbsinc (strStr);
        strPattern = our_mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in asterisk(s)
    //

    while (our_mbsnextc (strPattern) == '*') {
        strPattern = our_mbsinc (strPattern);
    }
    if (our_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    if (wstrPattern[0] == L'*' && wstrPattern[1] == 0) {
        return TRUE;
    }

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            //
            // BUGBUG - the ANSI version of this function doesn't have this
            // optimization
            //
            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = _mbctolower ((MBCHAR) our_mbsnextc (Start));
        chPat = _mbctolower ((MBCHAR) our_mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (our_mbsnextc (our_mbsinc (Pattern)) == '*') {
                Start = our_mbsinc (Pattern);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!our_mbsnextc (our_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (our_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = our_mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = our_mbsinc (Start);
        Pattern = our_mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (our_mbsnextc (Pattern) == '*') {
        Pattern = our_mbsinc (Pattern);
    }

    if (our_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            //
            // BUGBUG - the ANSI version of this function doesn't have this
            // optimization
            //
            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}


BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}


/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  Buf       - Specifies the grow buffer to add the character to, receives the
              character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (PtrToChar)) {
        MYASSERT (PtrToChar[1]);
        Len = 2;
    } else {
        Len = 1;
    }

    p = GrowBuffer (Buf, Len);
    CopyMemory (p, PtrToChar, Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GrowBuffer (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}


/*++

Routine Description:

  CreateParsedPattern parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    )
{
    POOLHANDLE Pool;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = GROWBUF_INIT;
    GROWBUFFER SegmentArray = GROWBUF_INIT;
    GROWBUFFER PatternArray = GROWBUF_INIT;
    GROWBUFFER SetBuf = GROWBUF_INIT;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PoolMemInitNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNA) PoolMemGetAlignedMemory (Pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (our_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (_ismbcspace (our_mbsnextc (Pattern))) {
                Pattern = our_mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (our_mbsnextc (Pattern) == '<') {
                Pattern = our_mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GrowBuffer (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PoolMemGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = our_mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = our_mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = our_mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = our_mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = our_mbsinc (Pattern);

                if (our_mbsnextc (Pattern) == '[') {
                    Pattern = our_mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = our_mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PoolMemDuplicateStringA (
                                                Pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _mbslwr ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GrowBuffer (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && our_mbsnextc (LookAhead) == ':') {
                Pattern = our_mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = our_mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PoolMemDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = our_mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = our_mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PoolMemDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = our_mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = our_mbsinc (SetBegin);

                if (our_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = our_mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (our_mbsnextc (SetBegin) == '^') {
                SetBegin = our_mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = our_mbsinc (SetBegin);

            if (our_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = our_mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (our_mbsnextc (SetBegin) == '^') {
                    SetBegin = our_mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = our_mbsinc (SetBegin);
            ch = our_mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = our_mbsinc (SetBegin);
                    ch = our_mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = our_mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (our_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = our_mbsinc (SetBegin);

            while (*SetBegin) {
                if (our_mbsnextc (SetBegin) == '^') {

                    SetBegin = our_mbsinc (SetBegin);

                } else if (our_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin)) {
                    MYASSERT(SetBegin[1]);
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = our_mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = our_mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = our_mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) {
                ch = our_mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = our_mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = our_mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);

            if (ch == ',') {
                SetBegin = our_mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    FreeGrowBuffer (&ExactMatchBuf);
    FreeGrowBuffer (&SetBuf);
    FreeGrowBuffer (&SegmentArray);

    if (State == PATTERN_ERROR || PatternArray.End == 0) {
        FreeGrowBuffer (&PatternArray);
        PoolMemDestroyPool (Pool);
        return NULL;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PoolMemGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = Pool;

    FreeGrowBuffer (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    )
{
    POOLHANDLE Pool;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = GROWBUF_INIT;
    GROWBUFFER SegmentArray = GROWBUF_INIT;
    GROWBUFFER PatternArray = GROWBUF_INIT;
    GROWBUFFER SetBuf = GROWBUF_INIT;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PoolMemInitNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNW) PoolMemGetAlignedMemory (Pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GrowBuffer (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PoolMemGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PoolMemDuplicateStringW (
                                                Pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _wcslwr ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GrowBuffer (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PoolMemDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );
                    _wcslwr ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PoolMemDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );
                    _wcslwr ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++;

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++;

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    FreeGrowBuffer (&ExactMatchBuf);
    FreeGrowBuffer (&SetBuf);
    FreeGrowBuffer (&SegmentArray);

    if (State == PATTERN_ERROR || PatternArray.End == 0) {
        FreeGrowBuffer (&PatternArray);
        PoolMemDestroyPool (Pool);
        return NULL;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PoolMemGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = Pool;

    FreeGrowBuffer (&PatternArray);

    return Struct;
}


/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (_ismbcspace (ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = _mbctolower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = our_mbsnextc (IncludeSet);
            IncludeSet = our_mbsinc (IncludeSet);
            HighChar = our_mbsnextc (IncludeSet);
            IncludeSet = our_mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    //
    // BUGBUG - the routine can be slightly optimized
    // if this test is moved before the previous one
    //
    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = our_mbsnextc (ExcludeSet);
            ExcludeSet = our_mbsinc (ExcludeSet);
            HighChar = our_mbsnextc (ExcludeSet);
            ExcludeSet = our_mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    //
    // BUGBUG - the routine can be slightly optimized
    // if this test is moved before the previous one
    //
    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT) (UINT_PTR) ((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 1;

            while (q < TempEnd) {

                ch1 = our_mbsnextc (StringToTest);
                ch2 = our_mbsnextc (q);

                ch1 = _mbctolower (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!_ismbcspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = our_mbsinc (q);
                StringToTest = our_mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            our_mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = our_mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = our_mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                our_mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = our_mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                our_mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = our_mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = our_mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = our_mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT) (UINT_PTR) ((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 1;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        PoolMemDestroyPool (ParsedPattern->Pool);
    }
}

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        PoolMemDestroyPool (ParsedPattern->Pool);
    }
}


VOID
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (sz2))
        sz1[1] = sz2[1];

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = our_mbsdec (str, end);
    if (end && our_mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}

BOOL
_wcsctrim (
    PWSTR str,
    WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    LPCTSTR *Ptr, *End, *Start;

    if (!String || String == (PCSTR) g_FailedGetResourceString) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSGA ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }
    if (AllocTable->End % sizeof (PCSTR)) {
        DEBUGMSGA ((DBG_ERROR, "FreeStringResourceA: Invalid allocation table %x", AllocTable));
        return;
    }

    Start = (PCSTR *) AllocTable->Buf;
    End = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    Ptr = End;
    while (Ptr >= Start) {
        if (*Ptr == String) {
            break;
        }
        Ptr--;
    }

    //
    // String not found case
    //

    if (Ptr < Start) {
        DEBUGMSGA ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (Ptr < End) {
        *Ptr = *End;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *Ptr;

    Ptr = (PCSTR *) GrowBuffer (GrowBuf, sizeof (PCSTR));
    if (Ptr) {
        *Ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *Ptr, *Start, *End;

    if (AllocTable->End) {
        Start = (PCSTR *) AllocTable->Buf;
        End = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (Ptr = Start ; Ptr < End ; Ptr++) {
            LocalFree ((HLOCAL) (*Ptr));
        }
    }

    FreeGrowBuffer (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
CreateAllocTable (
    VOID
    )
{
    PGROWBUFFER AllocTable;
    GROWBUFFER TempForInit = GROWBUF_INIT;

    AllocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (AllocTable, &TempForInit, sizeof (GROWBUFFER));

    return AllocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/

BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}

VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf = NULL;

    SetLastError (ERROR_SUCCESS);
    if ((UINT_PTR) Template > 0xffff) {
        // From string
        FormatMessageA (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_STRING,
            (PVOID) Template,
            0,
            0,
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    } else {
        // From resource
        FormatMessageA (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (PVOID) g_hInst,
            (UINT) (UINT_PTR) Template,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    }

    if (!MsgBuf && GetLastError() == ERROR_SUCCESS) {

        //
        // FormatMessage returns "fail" on a resource that is an empty
        // string, but fortunately it does not alter the last error
        //

        MsgBuf = (PSTR) LocalAlloc (LPTR, sizeof (CHAR));
        if (MsgBuf) {
            *MsgBuf = 0;
        }

    }

    if (MsgBuf) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    if ((UINT_PTR) Template > 0xffff) {
        DEBUGMSGA ((
            DBG_WARNING,
            "Can't get string resource ID %s -- returning an empty string",
            Template
            ));
    } else {
        DEBUGMSG ((
            DBG_WARNING,
            "Can't get string resource ID %u -- returning an empty string",
            (UINT) (UINT_PTR) Template
            ));
    }

    return (PCSTR) g_FailedGetResourceString;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf = NULL;

    SetLastError (ERROR_SUCCESS);
    if ((UINT_PTR) Template > 0xffff) {
        // From string
        FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_STRING,
            (PVOID) Template,
            0,
            0,
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    } else {
        // From resource
        FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (PVOID) g_hInst,
            (UINT) (UINT_PTR) Template,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    }

    if (!MsgBuf && GetLastError() == ERROR_SUCCESS) {

        //
        // FormatMessage returns "fail" on a resource that is an empty
        // string, but fortunately it does not alter the last error
        //

        MsgBuf = (PWSTR) LocalAlloc (LPTR, sizeof (WCHAR));
        if (MsgBuf) {
            *MsgBuf = 0;
        }

    }

    if (MsgBuf) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    if ((UINT_PTR) Template > 0xffff) {
        DEBUGMSGW ((
            DBG_ERROR,
            "Can't get string resource ID %s -- returning an empty string",
            Template
            ));
    } else {
        DEBUGMSG ((
            DBG_ERROR,
            "Can't get string resource ID %u -- returning an empty string",
            (UINT) (UINT_PTR) Template
            ));
    }

    return g_FailedGetResourceString;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    HWND hwnd,
    PCSTR ArgArray[]
    )
{
    CHAR Buffer[512];
    PCSTR ParsedMsg;

    GetWindowTextA (hwnd, Buffer, 512);
    ParsedMsg = ParseMessageA (Buffer, ArgArray);
    if (ParsedMsg) {
        SetWindowTextA (hwnd, ParsedMsg);
        FreeStringResourceA (ParsedMsg);
    }
}


VOID
ParseMessageInWndW (
    HWND hwnd,
    PCWSTR ArgArray[]
    )
{
    WCHAR Buffer[512];
    PCWSTR ParsedMsg;

    GetWindowTextW (hwnd, Buffer, 512);
    ParsedMsg = ParseMessageW (Buffer, ArgArray);
    if (ParsedMsg) {
        SetWindowTextW (hwnd, ParsedMsg);
        FreeStringResourceW (ParsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  hwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND hwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR Message;
    PCSTR Title;
    int rc;

    Message = ParseMessageA ((PSTR) (UINT_PTR) ID, ArgArray);
    if (!Message)
        return -1;

    Title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (hwndOwner, Message, Title, Flags);

    FreeStringResourceA (Message);
    if (Title) {
        FreeStringResourceA (Title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND hwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR Message;
    PCWSTR Title;
    int rc;

    Message = ParseMessageW ((PWSTR) (UINT_PTR) ID, ArgArray);
    if (!Message)
        return -1;

    Title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (hwndOwner, Message, Title, Flags);

    FreeStringResourceW (Message);
    if (Title) {
        FreeStringResourceW (Title);
    }

    return rc;
}



/*++

Routine Description:

  StringReplace replaces a portion of a string with another string

Arguments:

  Buffer - Buffer containing string to be substituted
  MaxSize - Size of Buffer, in TCHARs
  ReplaceStartPos - Position within Buffer to start replacement
  ReplaceEndPos - Position within Buffer where chars cannot be overwritten
  NewString - New string

Return Value:

  TRUE if the substitution was succssful

--*/

BOOL
StringReplaceA (
    IN PSTR     Buffer,
    IN DWORD    MaxSize,
    IN PSTR     ReplaceStartPos,
    IN PSTR     ReplaceEndPos,
    IN PCSTR    NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (UINT) (UINT_PTR) (ReplaceEndPos - ReplaceStartPos);
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer too small to perform string replacement."));
        rf = FALSE;
    }
    else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 movePosition >= ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        }
        else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        _mbsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN PWSTR     Buffer,
    IN DWORD     MaxSize,
    IN PWSTR     ReplaceStartPos,
    IN PWSTR     ReplaceEndPos,
    IN PCWSTR   NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (UINT) (UINT_PTR) (ReplaceEndPos - ReplaceStartPos);
    newSubStringLength  = wcslen(NewString);
    currentStringLength = wcslen(Buffer) + 1;
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    }
    else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 movePosition >= ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        }
        else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

#if 0 // REMOVED
/*++

Routine Description:

  AddInfSectionToStringTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

  Note - if this code is re-enabled, cleanup all pSetupStringTableXXXX functions
  callers will *ALWAYS* link to SPUTILSA.LIB and never SPUTILSU.LIB
  so all pSetupStringTableXXXX functions are ANSI

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToStringTableA (
    IN OUT  PVOID Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      INT Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    DWORD ReqSize;
    DWORD CurrentSize = 0;
    PSTR NewBuffer, Buffer = NULL;
    PVOID Data;
    UINT DataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //
    // Above comment is now incorrect, string table functions linked
    // with this module are always ANSI
    //

#error FIX pSetupStringTableXXXX usage
    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &ReqSize)) {
                continue;
            }

            if (ReqSize > CurrentSize) {
                ReqSize = ((ReqSize / 1024) + 1) * 1024;
                if (Buffer) {
                    NewBuffer = (PSTR) MemReAlloc (g_hHeap, 0, Buffer, ReqSize);
                } else {
                    NewBuffer = (PSTR) MemAlloc (g_hHeap, 0, ReqSize);
                }

                if (!NewBuffer) {
                    goto cleanup;
                }

                Buffer = NewBuffer;
                CurrentSize = ReqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, Buffer, CurrentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToStringTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            Data = NULL;
            DataSize = 0;

            if (Callback) {
                rc = Callback (Buffer, &Data, &DataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            rc = pSetupStringTableAddStringEx (
                        Table,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,
                        Data,
                        DataSize
                        );

            if (rc == -1) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (Buffer) {
        PushError();
        MemFree (g_hHeap, 0, Buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToStringTableW (
    IN OUT  PVOID Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      INT Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    DWORD ReqSize;
    DWORD CurrentSize = 0;
    PWSTR NewBuffer, Buffer = NULL;
    PVOID Data;
    UINT DataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //
    // Above comment is now incorrect, string table functions linked
    // with this module are always ANSI
    //

#error FIX pSetupStringTableXXXX usage
    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &ReqSize)) {
                continue;
            }

            if (ReqSize > CurrentSize) {
                ReqSize = ((ReqSize / 1024) + 1) * 1024;
                if (Buffer) {
                    NewBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, Buffer, ReqSize);
                } else {
                    NewBuffer = (PWSTR) MemAlloc (g_hHeap, 0, ReqSize);
                }

                if (!NewBuffer) {
                    goto cleanup;
                }

                Buffer = NewBuffer;
                CurrentSize = ReqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, Buffer, CurrentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToStringTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            Data = NULL;
            DataSize = 0;

            if (Callback) {
                rc = Callback (Buffer, &Data, &DataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            rc = pSetupStringTableAddStringEx (
                        Table,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,
                        Data,
                        DataSize
                        );

            if (rc == -1) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (Buffer) {
        PushError();
        MemFree (g_hHeap, 0, Buffer);
        PopError();
    }
    return b;
}
#endif // REMOVED

/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = our_mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = our_mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = our_mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT Count;

    Count = 0;
    while (*String) {
        if (our_mbsnextc (String) == Char) {
            Count++;
        }

        String = our_mbsinc (String);
    }

    return Count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT Count;

    Count = 0;
    while (*String) {
        if (*String == Char) {
            Count++;
        }

        String++;
    }

    return Count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT Count;

    Char = _mbctolower (Char);

    Count = 0;
    while (*String) {
        if ((MBCHAR) _mbctolower (our_mbsnextc (String)) == Char) {
            Count++;
        }

        String = our_mbsinc (String);
    }

    return Count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT Count;

    Char = towlower (Char);

    Count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            Count++;
        }

        String++;
    }

    return Count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT Count;
    UINT SearchBytes;

    Count = 0;
    p = SourceString;
    SearchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {
        Count++;
        p += SearchBytes;
    }

    return Count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT Count;
    UINT SearchChars;

    Count = 0;
    p = SourceString;
    SearchChars = wcslen (SearchString);

    while (p = _wcsistr (p, SearchString)) {
        Count++;
        p += SearchChars;
    }

    return Count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR NewString;
    PBYTE p, q;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT UntouchedBytes;

    //
    // Count occurances within the string
    //

    Count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!Count) {
        return NULL;
    }

    SearchBytes = ByteCountA (SearchString);
    ReplaceBytes = ByteCountA (ReplaceString);
    MYASSERT (SearchBytes);

    Size = SizeOfStringA (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PSTR) PoolMemGetAlignedMemory (g_PathsPool, Size);
    if (!NewString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {

        UntouchedBytes = (UINT) (UINT_PTR) (q - p);

        if (UntouchedBytes) {
            CopyMemory (Dest, p, UntouchedBytes);
            Dest += UntouchedBytes;
        }

        if (ReplaceBytes) {
            CopyMemory (Dest, (PBYTE) ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
        }

        p = q + SearchBytes;
    }

    StringCopyA ((PSTR) Dest, (PSTR) p);

    return NewString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR NewString;
    PBYTE p, q;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT UntouchedBytes;

    //
    // Count occurances within the string
    //

    Count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!Count) {
        return NULL;
    }

    SearchBytes = ByteCountW (SearchString);
    ReplaceBytes = ByteCountW (ReplaceString);
    MYASSERT (SearchBytes);

    Size = SizeOfStringW (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PWSTR) PoolMemGetAlignedMemory (g_PathsPool, Size);
    if (!NewString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {

        UntouchedBytes = (UINT) (UINT_PTR) (q - p);

        if (UntouchedBytes) {
            CopyMemory (Dest, p, UntouchedBytes);
            Dest += UntouchedBytes;
        }

        if (ReplaceBytes) {
            CopyMemory (Dest, (PBYTE) ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
        }

        p = q + SearchBytes;
    }

    StringCopyW ((PWSTR) Dest, (PWSTR) p);

    return NewString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     INT *NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR Start, End;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    INT Pass;
    INT ArgStrSize;
    INT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // Count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        Start = CmdLine;

        // Skip leading space
        while (_ismbcspace (*Start)) {
            Start++;
        }

        while (*Start) {
            // Look for quote mode
            if (*Start == '\"') {
                QuoteMode = TRUE;
                Start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            End = Start;
            while (*End) {
                ch = our_mbsnextc (End);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (_ismbcspace (ch)) {
                        break;
                    }
                }

                End = our_mbsinc (End);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (UINT) (UINT_PTR) (End - Start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;
                StringCopyABA (ArgStrEnd, Start, End);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);
                ArgStrEnd++;
            }

            // Set Start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                End = our_mbsinc (End);
            }

            Start = End;
            while (_ismbcspace (*Start)) {
                Start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            sizeof (PSTR) * Args + ArgStrSize
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      CHARTYPE SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = our_mbsdec (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (our_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    for (;;) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
        if (ptr == StartStr) {
            return NULL;
        }
    }
}

#define WACK_REPLACE_CHAR 0x02

VOID
ToggleWacksA (
    IN PSTR Line,
    IN BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = our_mbsinc (p);
        }

    } while (p);
}

VOID
ToggleWacksW (
    IN PWSTR Line,
    IN BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PWSTR
our_lstrcpynW (
    OUT     PWSTR Dest,
    IN      PCWSTR Src,
    IN      INT NumChars
    )
{
    PCWSTR srcEnd;

    __try {

        if (NumChars > 0) {
            //
            // assuming we wrote this because lstrcpyn has problems... we
            // cannot use wcsncpy, because it fills the entire Dest buffer
            // with nuls when WcharCount(Src) < NumChars - 1. That just
            // wastes time.
            //

            srcEnd = Src + NumChars - 1;
            while (*Src && Src < srcEnd) {
                *Dest++ = *Src++;
            }

            *Dest = 0;
        }
    }
    __except (1) {
    }

    return Dest;
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = our_mbsdec (FirstChar, LastChar);
    while (NumWacks && (LastChar>=FirstChar)) {
        if (our_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = our_mbsdec (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar>=FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (our_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = our_mbsinc (PathSeg);
    }
    return numDots;
}

UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MEMDB_MAX];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = our_mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (our_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = our_mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                _mbssafecpyab (pathSeg, FileSpec, wackPtr, MEMDB_MAX);

                FileSpec = our_mbsinc (wackPtr);
            } else {
                _mbssafecpyab (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MEMDB_MAX);
            }
        } else {
            _mbssafecpyab (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MEMDB_MAX);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == 0) {
                    FreePathStringW (newPath);
                    return NULL;
                }
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    if (!wackPtr) {
                        FreePathStringW (newPath);
                        return NULL;
                    }
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                _wcssafecpyab(pathSeg, FileSpec, wackPtr, MEMDB_MAX * sizeof (WCHAR));
                FileSpec = wackPtr + 1;
            } else {
                _wcssafecpyab(pathSeg, FileSpec, GetEndOfStringW (FileSpec), MEMDB_MAX * sizeof (WCHAR));
            }
        } else {
            _wcssafecpyab(pathSeg, FileSpec, GetEndOfStringW (FileSpec), MEMDB_MAX * sizeof (WCHAR));
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}

VOID
_mbssetchar (
    PSTR Dest,
    UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)((UINT_PTR)(&Char) + 1));
    }
    else {
        *Dest = (CHAR)Char;
    }
}

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && ((UINT) (UINT_PTR) ((PBYTE) s - (PBYTE) result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, our_mbsnextc(p));
            q = our_mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, our_mbsnextc(p));
        } else {
            ch = our_mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = our_mbsinc (p);
                if (p1) {
                    ch1 = our_mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = our_mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = our_mbsinc (p);
        s = our_mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}

unsigned char * __cdecl our_mbsinc(
    const unsigned char *current
    )
/***
*our_mbsinc - Move MBCS string pointer ahead one charcter.
*
*Purpose:
*       Move the supplied string pointer ahead by one
*       character.  MBCS characters are handled correctly.
*
*Entry:
*       const unsigned char *current = current char pointer (legal MBCS boundary)
*
*Exit:
*       Returns pointer after moving it.
*
*Exceptions:
*
*******************************************************************************/

{
    if (IsLeadByte (current++)) {
        current++;
    }
    return (unsigned char *)current;
}

/***
*our_mbsdec - Move MBCS string pointer backward one charcter.
*
*Purpose:
*       Move the supplied string pointer backwards by one
*       character.  MBCS characters are handled correctly.
*
*Entry:
*       const unsigned char *string = pointer to beginning of string
*       const unsigned char *current = current char pointer (legal MBCS boundary)
*
*Exit:
*       Returns pointer after moving it.
*       Returns NULL if string >= current.
*
*Exceptions:
*
*******************************************************************************/

unsigned char * __cdecl our_mbsdec(
    const unsigned char *string,
    const unsigned char *current
    )
{
    const unsigned char *temp;

    if (string >= current)
        return(NULL);

    temp = current - 1;

    if ( _ISNOTMBCP ) {
        return (unsigned char *)temp;
    }

/*
 *  If (current-1) returns true from _ISLEADBTYE, it is a trail byte, because
 *  it is not a legal single byte MBCS character.  Therefore, is so, return
 *  (current-2) because it is the trailbyte's lead.
 */
    if ( IsLeadByte(temp) ) {
        //
        // never underrun the buffer
        //
        if (temp <= string) {
            return NULL;
        }
        if ( _ISNOTMBCP )
            return (unsigned char *)--current;

        return (unsigned char *)(temp - 1);
    }

/*
 *  It is unknown whether (current - 1) is a single byte character or a
 *  trail.  Now decrement temp until
 *      a)  The beginning of the string is reached, or
 *      b)  A non-lead byte (either single or trail) is found.
 *  The difference between (current-1) and temp is the number of non-single
 *  byte characters preceding (current-1).  There are two cases for this:
 *      a)  (current - temp) is odd, and
 *      b)  (current - temp) is even.
 *  If odd, then there are an odd number of "lead bytes" preceding the
 *  single/trail byte (current - 1), indicating that it is a trail byte.
 *  If even, then there are an even number of "lead bytes" preceding the
 *  single/trail byte (current - 1), indicating a single byte character.
 */
    while ( (string <= --temp) && (IsLeadByte(temp)) )
            ;

    //
    // never underrun the buffer
    //
    temp = current - 1 - ((current - temp) & 0x01);
    return temp < string ? NULL : (unsigned char *)temp;
}

//
// BUGBUG - I don't see any problems with this one, so I commented it out
//
#if 0
/***
* _mbsncat - concatenate max cnt characters onto dst
*
*Purpose:
*       Concatenates src onto dst, with a maximum of cnt characters copied.
*       Handles 2-byte MBCS characters correctly.
*
*Entry:
*       unsigned char *dst - string to concatenate onto
*       unsigned char *src - string to concatenate from
*       int cnt - number of characters to copy
*
*Exit:
*       returns dst, with src (at least part) concatenated on
*
*Exceptions:
*
*******************************************************************************/

unsigned char * __cdecl our_mbsncat(
    unsigned char *dst,
    const unsigned char *src,
    size_t cnt
    )
{
    unsigned char *start;

    if (!cnt)
        return(dst);

    if ( _ISNOTMBCP )
        return strncat(dst, src, cnt);

    start = dst;
    while (*dst++)
            ;
    --dst;          // dst now points to end of dst string

    /* even if last char in string is a lead byte, do NOT back up pointer;
       we don't want any data loss */
/*
    if ( _ismbslead(start, dst) )
        --dst;
*/

    /* copy over the characters */

    while (cnt--) {
        if (IsLeadByte (*src)) {
            *dst++ = *src++;
            if ((*dst++ = *src++) == '\0') {
                dst[-2] = '\0';
                break;
            }
        }

        else if ((*dst++ = *src++) == '\0')
            break;

    }

    /* enter final nul, if necessary */
#ifdef  _MT
    if ( __mbsbtype_mt(ptmbci, start, (int) ((dst - start) - 1)) ==
         _MBC_LEAD )
#else
    if ( _mbsbtype(start, (int) ((dst - start) - 1)) == _MBC_LEAD )
#endif
        dst[-1] = '\0';
    else
        *dst = '\0';

    return(start);
}

#endif

/***
*_mbsnextc:  Returns the next character in a string.
*
*Purpose:
*       To return the value of the next character in an MBCS string.
*       Does not advance pointer to the next character.
*
*Entry:
*       unsigned char *s = string
*
*Exit:
*       unsigned int next = next character.
*
*Exceptions:
*
*******************************************************************************/

unsigned int __cdecl our_mbsnextc (
    const unsigned char *s
    )
{
    unsigned int  next = 0;

    if ( IsLeadByte(s) )
        next = ((unsigned int) *s++) << 8;

    next += (unsigned int) *s;

    return(next);
}


/***
* _mbclen - Find length of MBCS character
*
*Purpose:
*       Find the length of the MBCS character (in bytes).
*
*Entry:
*       unsigned char *c = MBCS character
*
*Exit:
*       Returns the number of bytes in the MBCS character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl our_mbclen (
    const unsigned char *c
    )
{
    return (IsLeadByte(c)) ? 2 : 1;
}

/***
* _mbsstr - Search for one MBCS string inside another (case sensitive)
*
*Purpose:
*       Find the first occurrence of str2 in str1.
*
*Entry:
*       unsigned char *str1 = beginning of string
*       unsigned char *str2 = string to search for
*
*Exit:
*       Returns a pointer to the first occurrence of str2 in
*       str1, or NULL if str2 does not occur in str1
*
*Exceptions:
*
*******************************************************************************/

unsigned char * __cdecl our_mbsstr (
    const unsigned char *str1,
    const unsigned char *str2
    )
{
    unsigned char *cp, *s1, *s2, *endp;
    if ( _ISNOTMBCP )
        return strstr(str1, str2);

    if ( *str2 == '\0')
        return (unsigned char *)str1;

    cp = (unsigned char *) str1;
    endp = (unsigned char *) (str1 + (strlen(str1) - strlen(str2)));

    while (*cp && (cp <= endp))
    {
        s1 = cp;
        s2 = (char *) str2;

        /*
         * MBCS: ok to ++ since doing equality comparison.
         * [This depends on MBCS strings being "legal".]
         */
        while ( *s1 && *s2 && (*s1 == *s2) )
            s1++, s2++;

        if (!(*s2))
            return(cp);     /* success! */

        /*
         * bump pointer to next char
         */
        if ( IsLeadByte(cp++) )
            cp++;
    }

    return(NULL);

}

INT
StringICompareByteCountA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    )
{
    PCSTR end;
    UINT ch1;
    UINT ch2;
    PCSTR maxString1;
    PCSTR maxString2;
    BOOL cut = FALSE;

    if (!ByteCount) {
        return 0;
    }

    maxString1 = (PCSTR) ((PBYTE) String1 + ByteCount);
    maxString2 = (PCSTR) ((PBYTE) String2 + ByteCount);

    do {
        //
        // Compute ch1. We use this code instead of _mbsnextc, so we can
        // support mismatched code pages.
        //

        if (_ISMBCP) {
            end = String1 + 1;

            if (end == maxString1) {
                //
                // only 1 char left in string 1
                //

                if (IsDBCSLeadByte (*String1)) {
                    cut = TRUE;
                }
            } else {
                //
                // 2 or more chars left in string 1
                //

                if (IsDBCSLeadByte (String1[0]) && String1[1]) {
                    end++;
                }
            }

            if (!cut) {
                ch1 = _mbctolower (_mbsnextc (String1));
            } else {
                cut = FALSE;
                ch1 = *String1;
            }

            String1 = end;
        } else {
            ch1 = tolower (*String1++);
        }


        //
        // Compute ch2.
        //

        if (_ISMBCP) {
            end = String2 + 1;

            if (end == maxString2) {
                //
                // only 1 char left in string 2
                //

                if (IsDBCSLeadByte (*String2)) {
                    cut = TRUE;
                }
            } else {
                //
                // 2 or more chars left in string 2
                //

                if (IsDBCSLeadByte (String2[0]) && String2[1]) {
                    end++;
                }
            }

            if (!cut) {
                ch2 = _mbctolower (_mbsnextc (String2));
            } else {
                cut = FALSE;
                ch2 = *String2;
            }

            String2 = end;
        } else {
            ch2 = tolower (*String2++);
        }

        //
        // Compare
        //

        if (ch1 != ch2) {
            return (INT) ch1 - (INT) ch2;
        }

        //
        // If this is the end of the string, then we're done
        //

        if (!ch1) {
            return 0;
        }

    } while (String1 < maxString1 && String2 < maxString2);

    //
    // One or both strings terminated
    //

    if (String1 < maxString1) {
        return -1;
    }

    if (String2 < maxString2) {
        return 1;
    }

    return 0;
}


INT
StringCompareByteCountA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    )
{
    PCSTR end;
    UINT ch1;
    UINT ch2;
    PCSTR maxString1;
    PCSTR maxString2;
    BOOL cut = FALSE;

    if (!ByteCount) {
        return 0;
    }

    maxString1 = (PCSTR) ((PBYTE) String1 + ByteCount);
    maxString2 = (PCSTR) ((PBYTE) String2 + ByteCount);

    do {
        //
        // Compute ch1. We use this code instead of _mbsnextc, so we can
        // support mismatched code pages.
        //

        if (_ISMBCP) {
            end = String1 + 1;

            if (end == maxString1) {
                //
                // only 1 char left in string 1
                //

                if (IsDBCSLeadByte (*String1)) {
                    cut = TRUE;
                }
            } else {
                //
                // 2 or more chars left in string 1
                //

                if (IsDBCSLeadByte (String1[0]) && String1[1]) {
                    end++;
                }
            }

            if (!cut) {
                ch1 = _mbsnextc (String1);
            } else {
                cut = FALSE;
                ch1 = *String1;
            }

            String1 = end;
        } else {
            ch1 = *String1++;
        }


        //
        // Compute ch2.
        //

        if (_ISMBCP) {
            end = String2 + 1;

            if (end == maxString2) {
                //
                // only 1 char left in string 2
                //

                if (IsDBCSLeadByte (*String2)) {
                    cut = TRUE;
                }
            } else {
                //
                // 2 or more chars left in string 2
                //

                if (IsDBCSLeadByte (String2[0]) && String2[1]) {
                    end++;
                }
            }

            if (!cut) {
                ch2 = _mbsnextc (String2);
            } else {
                cut = FALSE;
                ch2 = *String2;
            }

            String2 = end;
        } else {
            ch2 = *String2++;
        }

        //
        // Compare
        //

        if (ch1 != ch2) {
            return (INT) ch1 - (INT) ch2;
        }

        //
        // If this is the end of the string, then we're done
        //

        if (!ch1) {
            return 0;
        }

    } while (String1 < maxString1 && String2 < maxString2);

    //
    // One or both strings terminated
    //

    if (String1 < maxString1) {
        return -1;
    }

    if (String2 < maxString2) {
        return 1;
    }

    return 0;
}

BOOL
StringMemMatchA (
    IN      PCSTR Buffer1,
    IN      PCSTR Buffer2,
    IN      SIZE_T ByteCount
    )
{
    SIZE_T u;
    PCSTR end;

    end = (PCSTR) ((PBYTE) Buffer1 + ByteCount);

    while (Buffer1 < end) {

        if (*Buffer1 != *Buffer2++) {
            return FALSE;
        }

        if (*Buffer1++ == 0) {
            return TRUE;
        }
    }

    return TRUE;
}


BOOL
StringMemMatchW (
    IN      PCWSTR Buffer1,
    IN      PCWSTR Buffer2,
    IN      SIZE_T ByteCount
    )
{
    SIZE_T u;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) Buffer1 + ByteCount);

    while (Buffer1 < end) {

        if (*Buffer1 != *Buffer2++) {
            return FALSE;
        }

        if (*Buffer1++ == 0) {
            return TRUE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\strmap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm)   05-Jun-2000     Added multi table capability

    Jim Schmidt (jimschm)   08-May-2000     Improved replacement routines and
                                            added consistent filtering and
                                            extra data option

    Jim Schmidt (jimschm)   18-Aug-1998     Redesigned to fix two bugs, made
                                            A & W versions

--*/

//
// Includes
//

#include "pch.h"
#include "migutilp.h"


//
// Strings
//

// None

//
// Constants
//

#define CHARNODE_SINGLE_BYTE            0x0000
#define CHARNODE_DOUBLE_BYTE            0x0001
#define CHARNODE_REQUIRE_WACK_OR_NUL    0x0002

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilters,
    IN      BOOL UsesExtraData
    )

/*++

Routine Description:

  CreateStringMapping allocates a string mapping data structure and
  initializes it. Callers can enable filter callbacks, extra data support, or
  both. The mapping structure contains either CHARNODE elements, or
  CHARNODEEX elements, depending on the UsesFilters or UsesExtraData flag.

Arguments:

  UsesFilters   - Specifies TRUE to enable filter callbacks. If enabled,
                  those who add string pairs must specify the filter callback
                  (each search/replace pair has its own callback)
  UsesExtraData - Specifies TRUE to associate extra data with the string
                  mapping pair.

Return Value:

  A handle to the string mapping structure, or NULL if a structure could not
  be created.

--*/

{
    POOLHANDLE Pool;
    PMAPSTRUCT Map;

    Pool = PoolMemInitNamedPool ("String Mapping");
    MYASSERT (Pool);

    Map = (PMAPSTRUCT) PoolMemGetAlignedMemory (Pool, sizeof (MAPSTRUCT));
    MYASSERT (Map);

    ZeroMemory (Map, sizeof (MAPSTRUCT));
    Map->Pool = Pool;

    Map->UsesExNode = UsesFilters|UsesExtraData;
    Map->UsesFilter = UsesFilters;
    Map->UsesExtraData = UsesExtraData;

    return Map;
}

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    )
{
    if (Map) {
        PoolMemEmptyPool (Map->Pool);
        PoolMemDestroyPool (Map->Pool);
        // Map is no longer valid
    }
}

PCHARNODE
pFindCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char
    )
{
    PCHARNODE Node;

    if (!PrevNode) {
        Node = Map->FirstLevelRoot;
    } else {
        Node = PrevNode->NextLevel;
    }

    while (Node) {
        if (Node->Char == Char) {
            return Node;
        }
        Node = Node->NextPeer;
    }

    return NULL;
}

PCHARNODE
pAddCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char,
    IN      WORD Flags
    )
{
    PCHARNODE Node;
    PCHARNODEEX exNode;

    if (Map->UsesExNode) {
        exNode = PoolMemGetAlignedMemory (Map->Pool, sizeof (CHARNODEEX));
        Node = (PCHARNODE) exNode;
        MYASSERT (Node);
        ZeroMemory (exNode, sizeof (CHARNODEEX));
    } else {
        Node = PoolMemGetAlignedMemory (Map->Pool, sizeof (CHARNODE));
        MYASSERT (Node);
        ZeroMemory (Node, sizeof (CHARNODE));
    }

    Node->Char = Char;
    Node->Flags = Flags;

    if (PrevNode) {
        Node->NextPeer = PrevNode->NextLevel;
        PrevNode->NextLevel = Node;
    } else {
        Node->NextPeer = Map->FirstLevelRoot;
        Map->FirstLevelRoot = Node;
    }

    return Node;
}


VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PSTR OldCopy;
    PSTR NewCopy;
    PCSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PoolMemDuplicateStringA (Map->Pool, Old);
    NewCopy = PoolMemDuplicateStringA (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerA (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    for (Prev = NULL, p = OldCopy ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);
        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;
    }

    for ( ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);

        nodeFlags |= (WORD) (IsLeadByte (p) ? CHARNODE_DOUBLE_BYTE : CHARNODE_SINGLE_BYTE);
        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
    }

    if (Prev) {
        StringCopyA (OldCopy, Old);
        Prev->OriginalStr = (PVOID) OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountA (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PWSTR OldCopy;
    PWSTR NewCopy;
    PCWSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PoolMemDuplicateStringW (Map->Pool, Old);
    NewCopy = PoolMemDuplicateStringW (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerW (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    Prev = NULL;
    p = OldCopy;
    while (w = *p) {        // intentional assignment optimization

        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;

        p++;
    }

    while (w = *p) {        // intentional assignment optimization

        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
        p++;
    }

    if (Prev) {
        StringCopyW (OldCopy, Old);
        Prev->OriginalStr = OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountW (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


PCSTR
pFindReplacementStringInOneMapA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    WORD Char;
    PCSTR OrgSource;
    PCSTR newString;
    INT newStringSizeInBytes;
    PCHARNODEEX exNode;
    BOOL replacementFound;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Char = (WORD) _mbsnextc (Source);

        Node = pFindCharNode (Map, Node, Char);

        if (Node) {
            //
            // Advance string pointer
            //

            if (Node->Flags & CHARNODE_DOUBLE_BYTE) {
                Source += 2;
            } else {
                Source++;
            }

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && _mbsnextc (Source) != '\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Ansi.BeginningOfMatch = OrgSource;
                        Data->Ansi.OldSubString = (PCSTR) Node->OriginalStr;
                        Data->Ansi.NewSubString = newString;
                        Data->Ansi.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Ansi.NewSubString;
                            newStringSizeInBytes = Data->Ansi.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (UINT) (UINT_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {
        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCSTR
pFindReplacementStringA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapA (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


PCWSTR
pFindReplacementStringInOneMapW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    PCWSTR OrgSource;
    PCWSTR newString;
    INT newStringSizeInBytes;
    BOOL replacementFound;
    PCHARNODEEX exNode;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Node = pFindCharNode (Map, Node, *Source);

        if (Node) {
            //
            // Advance string pointer
            //

            Source++;

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && *Source != L'\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCWSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Unicode.BeginningOfMatch = OrgSource;
                        Data->Unicode.OldSubString = (PCWSTR) Node->OriginalStr;
                        Data->Unicode.NewSubString = newString;
                        Data->Unicode.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Unicode.NewSubString;
                            newStringSizeInBytes = Data->Unicode.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (UINT) (UINT_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {

        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCWSTR
pFindReplacementStringW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCWSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapW (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )

/*++

Routine Description:

  MappingSearchAndReplaceEx performs a search/replace operation based on the
  specified string mapping. The replace can be in-place or to another buffer.

Arguments:

  MapArray          - Specifies an array of string mapping tables that holds
                      zero or more search/replace pairs
  MapArrayCount     - Specifies the number of mapping tables in MapArray
  SrcBuffer         - Specifies the source string that might contain one or
                      more search strings
  Buffer            - Specifies the outbound buffer. This arg can be the same
                      as SrcBuffer.
  InboundBytes      - Specifies the number of bytes in SrcBuffer to process,
                      or 0 to process a nul-terminated string in SrcBuffer.
                      If InboundBytes is specified, it must point to the nul
                      terminator of SrcBuffer.
  OutbountBytesPtr  - Receives the number of bytes that Buffer contains,
                      excluding the nul terminator.
  MaxSizeInBytes    - Specifies the size of Buffer, in bytes.
  Flags             - Specifies flags that control the search/replace:
                            STRMAP_COMPLETE_MATCH_ONLY
                            STRMAP_FIRST_CHAR_MUST_MATCH
                            STRMAP_RETURN_AFTER_FIRST_REPLACE
                            STRMAP_REQUIRE_WACK_OR_NUL
  ExtraDataValue    - Receives the extra data associated with the first search/
                      replace pair.
  EndOfString       - Receives a pointer to the end of the replace string, or
                      the nul pointer when the entire string is processed. The
                      pointer is within the string contained in Buffer.

--*/

{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCSTR lowerCaseSrc;
    PCSTR orgSrc;
    PCSTR lowerSrcPos;
    PCSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PSTR destPos;
    PCSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCSTR replaceString;
    BOOL result = FALSE;
    INT i;
    PCSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountA (SrcBuffer);
    } else {
        i = 0;
        while (i < InboundBytes) {
            if (IsLeadByte (&SrcBuffer[i])) {
                MYASSERT (SrcBuffer[i + 1]);
                i += 2;
            } else {
                i++;
            }
        }

        if (i > InboundBytes) {
            InboundBytes--;
        }
    }

    inboundSize = InboundBytes + sizeof (CHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextA (sizeOfTempBuf);
    if (!lowerCaseSrc) {
        return FALSE;
    }

    CopyMemory ((PSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffA ((PSTR) lowerCaseSrc, InboundBytes / sizeof (CHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (CHAR);

    filterData.UnicodeData = FALSE;
    filterData.Ansi.OriginalString = orgSrc;
    filterData.Ansi.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringA (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (UINT) (UINT_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {

                //
                // Respect logical dbcs characters
                //

                replaceStringBytes = 0;
                i = 0;

                while (i < destBytesLeft) {
                    MYASSERT (replaceString[i]);

                    if (IsLeadByte (&replaceString[i])) {
                        MYASSERT (replaceString[i + 1]);
                        i += 2;
                    } else {
                        i++;
                    }
                }

                if (i > destBytesLeft) {
                    destBytesLeft--;
                }

                replaceStringBytes = destBytesLeft;

            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (IsLeadByte (orgSrcPos)) {

                //
                // Copy double-byte character
                //

                if (destBytesLeft < sizeof (CHAR) * 2) {
                    break;
                }

                MYASSERT (sizeof (CHAR) * 2 == sizeof (WORD));

                *((PWORD) destPos)++ = *((PWORD) orgSrcPos)++;
                destBytesLeft -= sizeof (WORD);
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + sizeof (WORD));

            } else {

                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }
        }
    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountA (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringA (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringA (endPtr);
        }

        *OutboundBytesPtr = (UINT) (UINT_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextA (lowerCaseSrc);

    return result;
}


BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCWSTR lowerCaseSrc;
    PCWSTR orgSrc;
    PCWSTR lowerSrcPos;
    PCWSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PWSTR destPos;
    PCWSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCWSTR replaceString;
    BOOL result = FALSE;
    PCWSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountW (SrcBuffer);
    } else {
        InboundBytes = (InboundBytes / sizeof (WCHAR)) * sizeof (WCHAR);
    }


    inboundSize = InboundBytes + sizeof (WCHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextW (sizeOfTempBuf);
    if (!lowerCaseSrc) {
        return FALSE;
    }

    CopyMemory ((PWSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PWSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffW ((PWSTR) lowerCaseSrc, InboundBytes / sizeof (WCHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCWSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCWSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCWSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (WCHAR);

    filterData.UnicodeData = TRUE;
    filterData.Unicode.OriginalString = orgSrc;
    filterData.Unicode.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringW (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (UINT) (UINT_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {
                replaceStringBytes = destBytesLeft;
            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PWSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCWSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCWSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (destBytesLeft < sizeof (WCHAR)) {
                break;
            }

            *destPos++ = *orgSrcPos++;
            destBytesLeft -= sizeof (WCHAR);
            lowerSrcPos++;
        }

    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountW (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PWSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringW (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringW (endPtr);
        }

        *OutboundBytesPtr = (UINT) (UINT_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextW (lowerCaseSrc);

    return result;
}


BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExA (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExW (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include "migutilp.h"

#include <locale.h>
#include <mbctype.h>

extern POOLHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadSystemLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
    g_IsMbcp = (_setmbcp(CodePage) == 0);
}


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD)GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Lchars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

  WARNING: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Lchars - Specifies the number of characters, excluding the nul, to
           convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Lchars) {
        Lchars = LcharCountW (StrIn);
    }

    Size = (Lchars + 1) * sizeof (WCHAR);

    DbcsStr = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Lchars,                // wc input count
             DbcsStr,
             Size,
             NULL,
             NULL
             );

    // Report error returns from WideCharToMultiByte
    if (!rc && Lchars) {
        PushError();
        PoolMemReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    *LcharCountToPointerA (DbcsStr, Lchars) = 0;

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Lchars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

  WARNING: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Lchars - Specifies the number of multibyte characters, excluding the nul,
           to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Lchars) {
        Lchars = LcharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = (UINT) (UINT_PTR) (LcharCountToPointerA(StrIn, Lchars) - StrIn);

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Lchars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PoolMemGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             StrInBytesToConvert,
             UnicodeStr,
             UnicodeStrBufLenBytes
             );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Lchars) {
        PushError();
        PoolMemReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PoolMemReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Lchars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Lchars - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Lchars) {
        Lchars = LcharCountW (StrIn);
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Lchars,                // wc input count
             StrOut,
             Lchars * 2,
             NULL,
             NULL
             );

    DEBUGMSG_IF ((
        !rc && Lchars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Lchars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Lchars - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Lchars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = (UINT) (UINT_PTR) (LcharCountToPointerA (StrIn, Lchars) - StrIn);
    }

    rc = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             StrInBytesToConvert,
             StrOut,
             StrInBytesToConvert * 2
             );

    DEBUGMSG_IF ((
        !rc && Lchars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Bytes / sizeof (WCHAR),
             StrOut,
             Bytes,
             NULL,
             NULL
             );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             Bytes,
             StrOut,
             Bytes * 2
             );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\pcha\pch.h ===
#pragma warning(push)

#include "chartype.h"

#define COBJMACROS

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <shlobj.h>
#include <objidl.h>
#include <mmsystem.h>

#include <setupbat.h>
#include <sputils.h>

//
// Common includes
//

#include "coreutil.h"

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\version.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.c

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    <alias>  <date>  <comments>

--*/

#include "pch.h"
#include "migutilp.h"


#define DBG_ACTION "Action"

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Prototypes
//

PCSTR
pEnumVersionValueCommonA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCWSTR
pEnumVersionValueCommonW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );


//
// Implementation
//

BOOL
CreateVersionStructA (
    OUT     PVERSION_STRUCTA VersionStruct,
    IN      PCSTR FileSpec
    )

/*++

Routine Description:

  CreateVersionStruct is called to load a version structure from a file
  and to obtain the fixed version stamp info that is language-independent.

  The caller must call DestroyVersionStruct after the VersionStruct is no
  longer needed.

Arguments:

  VersionStruct - Receives the version stamp info to be used by other
                  functions in this module

  FileSpec - Specifies the file to obtain version info from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

{
    //
    // Init the struct
    //

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTA));
    VersionStruct->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VersionStruct->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VersionStruct->Handle
                                );
    if (!VersionStruct->Size) {
        DEBUGMSG ((DBG_WARNING, "File %s does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VersionStruct->VersionBuffer = GrowBuffer (&VersionStruct->GrowBuf, VersionStruct->Size * 2);

    if (!VersionStruct->VersionBuffer) {
        return FALSE;
    }

    VersionStruct->StringBuffer = VersionStruct->GrowBuf.Buf + VersionStruct->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VersionStruct->Handle,
             VersionStruct->Size,
             VersionStruct->VersionBuffer
             )) {
        DestroyVersionStructA (VersionStruct);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VersionStruct->VersionBuffer,
        "\\",
        &VersionStruct->FixedInfo,
        &VersionStruct->FixedInfoSize
        );

    return TRUE;
}

ULONGLONG
VerGetFileVer (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwFileVersionMS;
    }
    return result;
}

ULONGLONG
VerGetProductVer (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwProductVersionMS;
    }
    return result;
}

DWORD
VerGetFileDateLo (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateLS;
    }
    return 0;
}

DWORD
VerGetFileDateHi (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateMS;
    }
    return 0;
}

DWORD
VerGetFileVerOs (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileOS;
    }
    return 0;
}

DWORD
VerGetFileVerType (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileType;
    }
    return 0;
}

VOID
DestroyVersionStructA (
    IN      PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  DestroyVersionStruct cleans up all memory allocated by the routines
  in this module.

Arguments:

  VersionStruct - Specifies the structure to clean up

Return Value:

  none

--*/

{
    //
    // Clean up all allocations made by any routine using
    // the VersionStruct
    //

    if (VersionStruct->GrowBuf.Buf) {
        FreeGrowBuffer (&VersionStruct->GrowBuf);
    }

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTA));
}


PCSTR
EnumFirstVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumFirstVersionTranslation returins the translation string needed
  to access the string table of a version stamp.

Arguments:

  VersionStruct - Specifies the structure that has been initialized
                  by InitializeVersionStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

{
    UINT ArraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VersionStruct->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VersionStruct->Translations,
            &ArraySize
            )) {
        //
        // No translations are available
        //

        ArraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VersionStruct->CurrentDefaultTranslation = 0;
    VersionStruct->MaxTranslations = ArraySize / sizeof (TRANSLATION);
    VersionStruct->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VersionStruct->MaxTranslations == 0,
        DBG_WARNING,
        "File %s has no translations",
        VersionStruct->FileSpec
        ));

    return EnumNextVersionTranslationA (VersionStruct);
}


BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )

/*++

Routine Description:

  pIsDefaultTranslationA returns TRUE if the specified translation
  string is enumerated by default.  This routine stops multiple
  enumeration of the same translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


PCSTR
EnumNextVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionTranslation continues the enumeration of translation
  strings, needed to access the string table in a version stamp.

Arguments:

  VersionStruct - Specifies the same structure passed to
                  EnumFirstVersionTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

{
    PTRANSLATION Translation;

    if (g_DefaultTranslationsA[VersionStruct->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCbCopyA (
            VersionStruct->TranslationStr,
            sizeof(VersionStruct->TranslationStr),
            g_DefaultTranslationsA[VersionStruct->CurrentDefaultTranslation]
            );

        VersionStruct->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VersionStruct->CurrentTranslation == VersionStruct->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            Translation = &VersionStruct->Translations[VersionStruct->CurrentTranslation];

            StringCbPrintfA(
                VersionStruct->TranslationStr,
                sizeof(VersionStruct->TranslationStr),
                "%04x%04x",
                Translation->CodePage,
                Translation->Language
                );

            VersionStruct->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VersionStruct->TranslationStr));
    }

    return VersionStruct->TranslationStr;
}


PCSTR
EnumFirstVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct,
    IN      PCSTR VersionField
    )

/*++

Routine Description:

  EnumFirstVersionValue returns the first value stored in a version
  stamp for a specific field.  If the field does not exist, the
  function returns NULL.

  An enumeration of EnumFirstVersionValue/EnumNextVersionValue
  is used to list all localized strings for a field.

Arguments:

  VersionStruct - Specifies the structure that was initialized by
                  InitializeVersionStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

{
    PCSTR rc;

    if (!EnumFirstVersionTranslationA (VersionStruct)) {
        return NULL;
    }

    VersionStruct->VersionField = VersionField;

    rc = pEnumVersionValueCommonA (VersionStruct);

    if (!rc) {
        rc = EnumNextVersionValueA (VersionStruct);
    }

    return rc;
}


PCSTR
EnumNextVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionValue returns the next value stored in a version
  stamp for a specific field.

Arguments:

  VersionStruct - Specifies the same structure passed to EnumFirstVersionField

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

{
    PCSTR rc = NULL;

    do {
        if (!EnumNextVersionTranslationA (VersionStruct)) {
            break;
        }

        rc = pEnumVersionValueCommonA (VersionStruct);

    } while (!rc);

    return rc;
}


PCSTR
pEnumVersionValueCommonA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  pEnumVersionValueCommon is a routine that obtains the value
  of a version field.  It is used for both EnumFirstVersionValue
  and EnumNextVersionValue.

Arguments:

  VersionStruct - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

{
    PSTR Text;
    UINT StringLen;
    PBYTE String;
    PCSTR Result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    Text = AllocTextA (
               16 +
               SizeOfStringA (VersionStruct->TranslationStr) +
               SizeOfStringA (VersionStruct->VersionField)
               );

    if (!Text) {
        return NULL;
    }

    wsprintfA (
        Text,
        "\\StringFileInfo\\%s\\%s",
        VersionStruct->TranslationStr,
        VersionStruct->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VersionStruct->VersionBuffer,
                Text,
                &String,
                &StringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        _mbsnzcpy (VersionStruct->StringBuffer, (PCSTR) String, StringLen);

        Result = VersionStruct->StringBuffer;

    }
    __finally {
        FreeTextA (Text);
    }

    return Result;
}


BOOL
CreateVersionStructW (
    OUT     PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  CreateVersionStruct is called to load a version structure from a file
  and to obtain the fixed version stamp info that is language-independent.

  The caller must call DestroyVersionStruct after the VersionStruct is no
  longer needed.

Arguments:

  VersionStruct - Receives the version stamp info to be used by other
                  functions in this module

  FileSpec - Specifies the file to obtain version info from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

{
    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTW));
    VersionStruct->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VersionStruct->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VersionStruct->Handle
                                );
    if (!VersionStruct->Size) {
        DEBUGMSG ((DBG_WARNING, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VersionStruct->VersionBuffer = GrowBuffer (&VersionStruct->GrowBuf, VersionStruct->Size * 2);

    if (!VersionStruct->VersionBuffer) {
        return FALSE;
    }

    VersionStruct->StringBuffer = VersionStruct->GrowBuf.Buf + VersionStruct->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VersionStruct->Handle,
             VersionStruct->Size,
             VersionStruct->VersionBuffer
             )) {
        DestroyVersionStructW (VersionStruct);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VersionStruct->VersionBuffer,
        L"\\",
        &VersionStruct->FixedInfo,
        &VersionStruct->FixedInfoSize
        );

    return TRUE;
}


VOID
DestroyVersionStructW (
    IN      PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  DestroyVersionStruct cleans up all memory allocated by the routines
  in this module.

Arguments:

  VersionStruct - Specifies the structure to clean up

Return Value:

  none

--*/

{
    if (VersionStruct->GrowBuf.Buf) {
        FreeGrowBuffer (&VersionStruct->GrowBuf);
    }

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTW));
}


PCWSTR
EnumFirstVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumFirstVersionTranslation returins the translation string needed
  to access the string table of a version stamp.

Arguments:

  VersionStruct - Specifies the structure that has been initialized
                  by InitializeVersionStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

{
    UINT ArraySize;

    if (!VerQueryValueW (
            VersionStruct->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VersionStruct->Translations,
            &ArraySize
            )) {
        //
        // No translations are available
        //

        ArraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VersionStruct->CurrentDefaultTranslation = 0;
    VersionStruct->MaxTranslations = ArraySize / sizeof (TRANSLATION);
    VersionStruct->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VersionStruct->MaxTranslations == 0,
        DBG_WARNING,
        "File %S has no translations",
        VersionStruct->FileSpec
        ));

    return EnumNextVersionTranslationW (VersionStruct);
}


BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


PCWSTR
EnumNextVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionTranslation continues the enumeration of translation
  strings, needed to access the string table in a version stamp.

Arguments:

  VersionStruct - Specifies the same structure passed to
                  EnumFirstVersionTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

{
    PTRANSLATION Translation;

    if (g_DefaultTranslationsW[VersionStruct->CurrentDefaultTranslation]) {

        StringCbCopyW (
            VersionStruct->TranslationStr,
            sizeof(VersionStruct->TranslationStr),
            g_DefaultTranslationsW[VersionStruct->CurrentDefaultTranslation]
            );

        VersionStruct->CurrentDefaultTranslation++;

    } else {

        do {
            if (VersionStruct->CurrentTranslation == VersionStruct->MaxTranslations) {
                return NULL;
            }

            Translation = &VersionStruct->Translations[VersionStruct->CurrentTranslation];

            StringCbPrintfW(
                VersionStruct->TranslationStr,
                sizeof(VersionStruct->TranslationStr),
                L"%04x%04x",
                Translation->CodePage,
                Translation->Language
                );

            VersionStruct->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VersionStruct->TranslationStr));
    }

    return VersionStruct->TranslationStr;
}


PCWSTR
EnumFirstVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR VersionField
    )

/*++

Routine Description:

  EnumFirstVersionValue returns the first value stored in a version
  stamp for a specific field.  If the field does not exist, the
  function returns NULL.

  An enumeration of EnumFirstVersionValue/EnumNextVersionValue
  is used to list all localized strings for a field.

Arguments:

  VersionStruct - Specifies the structure that was initialized by
                  InitializeVersionStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

{
    PCWSTR rc;

    if (!EnumFirstVersionTranslationW (VersionStruct)) {
        return NULL;
    }

    VersionStruct->VersionField = VersionField;

    rc = pEnumVersionValueCommonW (VersionStruct);

    if (!rc) {
        rc = EnumNextVersionValueW (VersionStruct);
    }

    return rc;
}


PCWSTR
EnumNextVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionValue returns the next value stored in a version
  stamp for a specific field.

Arguments:

  VersionStruct - Specifies the same structure passed to EnumFirstVersionField

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

{
    PCWSTR rc = NULL;

    do {
        if (!EnumNextVersionTranslationW (VersionStruct)) {
            break;
        }

        rc = pEnumVersionValueCommonW (VersionStruct);

    } while (!rc);

    return rc;
}


PCWSTR
pEnumVersionValueCommonW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  pEnumVersionValueCommon is a routine that obtains the value
  of a version field.  It is used for both EnumFirstVersionValue
  and EnumNextVersionValue.

Arguments:

  VersionStruct - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

{
    PWSTR Text;
    UINT StringLen;
    PBYTE String;
    PCWSTR Result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    Text = AllocTextW (
               18 +
               LcharCountW (VersionStruct->TranslationStr) +
               LcharCountW (VersionStruct->VersionField)
               );

    if (!Text) {
        return NULL;
    }

    wsprintfW (
        Text,
        L"\\StringFileInfo\\%s\\%s",
        VersionStruct->TranslationStr,
        VersionStruct->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VersionStruct->VersionBuffer,
                Text,
                &String,
                &StringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        CopyMemory (VersionStruct->StringBuffer, String, StringLen * sizeof (WCHAR));
        VersionStruct->StringBuffer [StringLen * sizeof (WCHAR)] = 0;
        Result = (PWSTR) VersionStruct->StringBuffer;

    }
    __finally {
        FreeTextW (Text);
    }

    return Result;
}


PSTR
UnicodeToCcs (
    PCWSTR Source
    )

/*++

Routine Description:

  UnicodeToCcs will walk the unicode string and convert it to ANSII by encoding all DBCS characters
  to hex values.

Arguments:

  Source - the Unicode string

Return Value:

  An encoded ANSII string.

--*/

{
    CHAR result [MEMDB_MAX];
    UINT srcIndex = 0;
    UINT destIndex = 0;

    while (Source [srcIndex] && (destIndex < MEMDB_MAX)) {
        if ((Source [srcIndex] >=32) &&
            (Source [srcIndex] <=126)
            ) {
            result [destIndex] = (BYTE) Source [srcIndex];
            destIndex ++;
        }
        else {
            if ((destIndex == 0) ||
                (result [destIndex-1] != '*')
                ) {
                result [destIndex] = '*';
                destIndex ++;
            }
        }
        srcIndex ++;
    }

    result [destIndex] = 0;
    return DuplicatePathString (result, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\pchw\pch.h ===
#pragma warning(push)

#include "chartype.h"

#define COBJMACROS

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <shlobj.h>
#include <objidl.h>
#include <mmsystem.h>

#include <setupbat.h>
#include <sputils.h>

//
// Common includes
//

#include "coreutil.h"

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\dllentry.c ===
//
//  DLLENTRY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef USEHEAP
#define RGHEAP_SIZE                 9256*1024
HANDLE g_RgHeap = NULL;
#endif

BOOL
WINAPI
VMMRegDllEntry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
#ifdef USEHEAP
            if ((g_RgHeap = HeapCreate(0, RGHEAP_SIZE, RGHEAP_SIZE)) == NULL)
                return FALSE;
#endif

            if (VMMRegLibAttach(0) != ERROR_SUCCESS)
                return FALSE;

            break;

        case DLL_PROCESS_DETACH:
            VMMRegLibDetach();

#ifdef USEHEAP
            if (g_RgHeap != NULL)
                HeapDestroy(g_RgHeap);
#endif

            break;

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\makefile.inc ===
obj\$(TARGET_DIRECTORY)\vmmreg32.res: vmmreg32.rc vmmreg32.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\progbar\progbar.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    progbar.c

Abstract:

    Centralizes access to the progress bar and associated messages accross components
    (hwcomp,migapp,etc.) and sides (w9x, nt)

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm     19-Jun-1998     Improved to allow revision of estimates, necessary
                                for NT-side progress bar.

--*/

#include "pch.h"
#include "migshared.h"

//
// Types
//

typedef struct {
    BOOL    Started;
    BOOL    Completed;
    UINT    InitialGuess;
    UINT    TotalTicks;
    UINT    TicksSoFar;
    UINT    LastTickDisplayed;
} SLICE, *PSLICE;

typedef struct {
    HWND Window;
    HANDLE CancelEvent;
    PCSTR Message;
    DWORD MessageId;
    DWORD Delay;
    BOOL  InUse;
} DELAYTHREADPARAMS, *PDELAYTHREADPARAMS;


#if 0

typedef struct {
    HANDLE CancelEvent;
    DWORD TickCount;
    BOOL  InUse;
} TICKTHREADPARAMS, *PTICKTHREADPARAMS;

#endif


//
// Globals
//

BOOL g_ProgBarInitialized = FALSE;

HWND g_ProgressBar;
HWND g_Component;
HWND g_SubComponent;

PBRANGE g_OrgRange;

HANDLE g_ComponentCancelEvent;
HANDLE g_SubComponentCancelEvent;

BOOL *g_CancelFlagPtr;
GROWBUFFER g_SliceArray;
UINT g_SliceCount;
UINT g_MaxTickCount;
UINT g_PaddingTicks;
UINT g_CurrentTickCount;
UINT g_CurrentPos;
UINT g_ReduceFactor;
BOOL g_Reverse = FALSE;
OUR_CRITICAL_SECTION g_ProgBarCriticalSection;
UINT g_CurrentSliceId = (UINT)-1;

//
// Tuning constants
//

#define TICKSCALE       100


//
// Implementaiton
//

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    LONG rc;
    CHAR Data[256];
    DWORD Size;
    HKEY Key;

    g_ProgressBar = ProgressBar;
    g_CancelFlagPtr = CancelFlagPtr;

    g_ProgBarInitialized = TRUE;

    SendMessage (ProgressBar, PBM_SETPOS, 0, 0);
    g_CurrentPos = 0;
    SendMessage (ProgressBar, PBM_GETRANGE, 0, (LPARAM) &g_OrgRange);

    //
    // Create cancel events for delayed messages.
    //
    g_ComponentCancelEvent      = CreateEvent (NULL, FALSE, FALSE, NULL);
    g_SubComponentCancelEvent   = CreateEvent (NULL, FALSE, FALSE, NULL);

    if (!g_ComponentCancelEvent || !g_SubComponentCancelEvent) {
        DEBUGMSG ((DBG_ERROR, "ProgressBar: Could not create cancel events."));
    }

    InitializeOurCriticalSection (&g_ProgBarCriticalSection);

    g_Component = Component;
    g_SubComponent = SubComponent;

    DEBUGMSG_IF ((
        Component && !IsWindow (Component),
        DBG_WHOOPS,
        "Progress bar component is not a valid window"
        ));

    DEBUGMSG_IF ((
        SubComponent && !IsWindow (SubComponent),
        DBG_WHOOPS,
        "Progress bar sub component is not a valid window"
        ));

    MYASSERT (!g_SliceCount);
    MYASSERT (!g_SliceArray.Buf);
    MYASSERT (!g_MaxTickCount);
    MYASSERT (!g_PaddingTicks);
    MYASSERT (!g_CurrentTickCount);
    MYASSERT (g_CurrentSliceId == (UINT)-1);

    g_ReduceFactor = 1;

    Key = OpenRegKeyStrA ("HKLM\\inapoi");
    if (Key) {
        Size = 256;
        rc = RegQueryValueExA (Key, "", NULL, NULL, (PBYTE) Data, &Size);
        CloseRegKey (Key);

        #pragma prefast(suppress:400, "not concerned about different code page")
        if (rc == ERROR_SUCCESS && !lstrcmpiA (Data, "backwards")) {
            g_Reverse = TRUE;
        }
    }
}


VOID
TerminateProgressBar (
    VOID
    )
{
    if (g_ComponentCancelEvent) {
        CloseHandle (g_ComponentCancelEvent);
        g_ComponentCancelEvent = NULL;
    }

    if (g_SubComponentCancelEvent) {
        CloseHandle (g_SubComponentCancelEvent);
        g_SubComponentCancelEvent = NULL;
    }

    DeleteOurCriticalSection (&g_ProgBarCriticalSection);

    FreeGrowBuffer (&g_SliceArray);
    g_SliceCount = 0;
    g_MaxTickCount = 0;
    g_PaddingTicks = 0;
    g_CurrentTickCount = 0;
    g_CurrentSliceId = -1;
    g_Component = NULL;
    g_SubComponent = NULL;

    g_ReduceFactor = 1;

    SendMessage (g_ProgressBar, PBM_SETRANGE32, g_OrgRange.iLow, g_OrgRange.iHigh);

    g_ProgBarInitialized = FALSE;
}


UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    )
{
    PSLICE Slice;
    UINT SliceId;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return 0;
    }

    SliceId = g_SliceCount;

    Slice = (PSLICE) GrowBuffer (&g_SliceArray, sizeof (SLICE));
    g_SliceCount++;

    Slice->Started = FALSE;
    Slice->Completed = FALSE;
    Slice->TotalTicks = InitialEstimate * TICKSCALE;
    Slice->InitialGuess = Slice->TotalTicks;
    Slice->TicksSoFar = 0;
    Slice->LastTickDisplayed = 0;

    return SliceId;
}


VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Invalid slice ID %u", SliceId));
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (!g_CurrentTickCount) {
        Slice->TotalTicks = RevisedEstimate;
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Can't revise completed slice"));
        return;
    }

    if (Slice->InitialGuess == 0) {
        return;
    }

    RevisedEstimate *= TICKSCALE;

    MYASSERT (Slice->TicksSoFar * RevisedEstimate > Slice->TicksSoFar);
    MYASSERT (Slice->LastTickDisplayed * RevisedEstimate > Slice->LastTickDisplayed);

    Slice->TicksSoFar = (UINT) ((LONGLONG) Slice->TicksSoFar * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->LastTickDisplayed = (UINT) ((LONGLONG) Slice->LastTickDisplayed * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->TotalTicks = RevisedEstimate;
}


VOID
BeginSliceProcessing (
    IN      UINT SliceId
    )
{
    PSLICE Slice;
    UINT u;
    UINT TotalTicks;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (!g_ProgressBar) {
        DEBUGMSG ((DBG_WHOOPS, "No progress bar handle"));
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Invalid slice ID %u", SliceId));
        return;
    }

    if (!g_CurrentTickCount) {
        //
        // Initialize the progress bar
        //

        MYASSERT (g_CurrentSliceId == (UINT)-1);

        TotalTicks = 0;
        Slice = (PSLICE) g_SliceArray.Buf;

        for (u = 0 ; u < g_SliceCount ; u++) {
            TotalTicks += Slice->InitialGuess;
            Slice++;
        }

        TotalTicks /= TICKSCALE;
        g_PaddingTicks = TotalTicks * 5 / 100;
        g_MaxTickCount = TotalTicks + 2 * g_PaddingTicks;

        g_ReduceFactor = 1;
        while (g_MaxTickCount > 0xffff) {
            g_ReduceFactor *= 10;
            g_MaxTickCount /= 10;
        }

        SendMessage (g_ProgressBar, PBM_SETRANGE, 0, MAKELPARAM (0, g_MaxTickCount));
        SendMessage (g_ProgressBar, PBM_SETSTEP, 1, 0);

        if (g_Reverse) {
            SendMessage (
                g_ProgressBar,
                PBM_SETPOS,
                g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor),
                0
                );
        } else {
            SendMessage (g_ProgressBar, PBM_SETPOS, g_PaddingTicks / g_ReduceFactor, 0);
        }

        g_CurrentTickCount = g_PaddingTicks;
        g_CurrentPos = g_PaddingTicks;

    } else if (SliceId <= g_CurrentSliceId) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Slice ID %u processed already", SliceId));
        return;
    }


    g_CurrentSliceId = SliceId;
    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    Slice->Started = TRUE;
}


VOID
pIncrementBarIfNecessary (
    IN OUT  PSLICE Slice
    )
{
    UINT Increment;
    UINT Pos;

    if (Slice->TicksSoFar >= Slice->TotalTicks) {
        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;
    }

    if (Slice->TicksSoFar - Slice->LastTickDisplayed >= TICKSCALE) {
        Increment = (Slice->TicksSoFar - Slice->LastTickDisplayed) / TICKSCALE;
        Slice->LastTickDisplayed += Increment * TICKSCALE;

        if (g_Reverse) {

            Pos = ((g_CurrentPos + Slice->TicksSoFar) / TICKSCALE);

            Pos += g_PaddingTicks;
            Pos /= g_ReduceFactor;

            if (Pos > g_MaxTickCount) {
                Pos = g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor);
            }

            SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount - Pos, 0);
        } else {
            SendMessage (g_ProgressBar, PBM_DELTAPOS, Increment / g_ReduceFactor, 0);
        }
    }
}


VOID
pTickProgressBar (
    IN      UINT Ticks
    )
{
    PSLICE Slice;
    LONGLONG x;

    if (!Ticks || g_CurrentSliceId == (UINT)-1 || g_CurrentSliceId >= g_SliceCount) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_VERBOSE, "Progress slice ID %u already completed", g_CurrentSliceId));
        return;
    }

    MYASSERT (Ticks * TICKSCALE > Ticks);
    x = ((LONGLONG) Ticks * TICKSCALE * (LONGLONG) Slice->TotalTicks) / (LONGLONG) Slice->InitialGuess;
    MYASSERT (x + (LONGLONG) Slice->TicksSoFar < 0x100000000);

    Slice->TicksSoFar += (UINT) x;

    pIncrementBarIfNecessary (Slice);

}


BOOL
TickProgressBarDelta (
        IN      UINT TickCount
    )
{
    BOOL    rSuccess = TRUE;

    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    if (g_CancelFlagPtr && *g_CancelFlagPtr) {
        SetLastError (ERROR_CANCELLED);
        rSuccess = FALSE;
    } else {
        pTickProgressBar (TickCount);
    }

    return rSuccess;
}


BOOL
TickProgressBar (
    VOID
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return TickProgressBarDelta (1);
}


VOID
EndSliceProcessing (
    VOID
    )
{
    PSLICE Slice;

    if (!g_ProgBarInitialized) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        Slice->Completed = TRUE;
        return;
    }

    if (!Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Progress bar slice %u was not completed.", g_CurrentSliceId));

        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;

        pIncrementBarIfNecessary (Slice);
    }

    g_CurrentPos += Slice->TotalTicks;

    if (g_CurrentSliceId == g_SliceCount - 1) {
        //
        // End of progress bar
        //

        SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount, 0);
    }
}


BOOL
pCheckProgressBarState (
    IN HANDLE CancelEvent
    )
{

    SetEvent(CancelEvent);

    return (!g_CancelFlagPtr || !*g_CancelFlagPtr);
}


BOOL
ProgressBar_SetWindowStringA(
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,        OPTIONAL
    IN      DWORD MessageId       OPTIONAL
    )
{
    BOOL rSuccess = TRUE;
    PCSTR string = NULL;

    EnterOurCriticalSection (&g_ProgBarCriticalSection);

    if (g_ProgBarInitialized) {

        if (pCheckProgressBarState(CancelEvent)) {

            if (Message) {

                //
                // We have a normal message string.
                //

                if (!SetWindowTextA(Window, Message)) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
            else if (MessageId) {

                //
                // We have a message ID. Convert it and set it.
                //
                string = GetStringResourceA(MessageId);

                if (string) {

                    if (!SetWindowTextA(Window, string)) {
                        rSuccess = FALSE;
                        DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                    }

                    FreeStringResourceA(string);
                }
                ELSE_DEBUGMSG((DBG_ERROR,"ProgressBar: Error with GetStringResource"));

            }
            else {

                //
                // Just clear the text.
                //

                if (!SetWindowTextA(Window, "")) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
        }
        else {
            //
            // We are in a canceled state.
            //
            rSuccess = FALSE;
            SetLastError (ERROR_CANCELLED);
        }
    }

    LeaveOurCriticalSection (&g_ProgBarCriticalSection);

    return rSuccess;

}


DWORD
pSetDelayedMessageA (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PDELAYTHREADPARAMS  tParams = (PDELAYTHREADPARAMS) Param;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //
    switch (WaitForSingleObject(tParams -> CancelEvent, tParams -> Delay)) {

    case WAIT_TIMEOUT:
        //
        // We timed out without cancel being signaled. Set the delayed message.
        //
        ProgressBar_SetWindowStringA (
            tParams -> Window,
            tParams -> CancelEvent,
            tParams -> Message,
            tParams -> MessageId
            );

        break;

    case WAIT_OBJECT_0:
    default:
        //
        //  We were canceled (or something strange happened :> Do nothing!
        //
        break;
    }

    //
    // can set a new thread now
    //
    tParams->InUse = FALSE;

    return rc;
}


VOID
ProgressBar_CancelDelayedMessage (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return;
    }

    SetEvent(CancelEvent);

}


BOOL
ProgressBar_SetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    )
{
    BOOL                rSuccess = FALSE;
    DWORD               threadId;
    static DELAYTHREADPARAMS   tParams;

    if (!g_ProgBarInitialized || tParams.InUse) {
        return TRUE;
    }

    if (!pCheckProgressBarState(Window)) {


        //
        // Fill in the parameters for this call to create thread.
        //
        tParams.Window       = Window;
        tParams.CancelEvent  = CancelEvent;
        tParams.Message      = Message;
        tParams.MessageId    = MessageId;
        tParams.Delay        = Delay;

        //
        // Spawn off a thread that will set the message.
        //
        rSuccess = NULL != CreateThread (
                            NULL,   // No inheritance.
                            0,      // Normal stack size.
                            pSetDelayedMessageA,
                            &tParams,
                            0,      // Run immediately.
                            &threadId
                            );

        if (rSuccess) {
            tParams.InUse = TRUE;
        }
        ELSE_DEBUGMSG((DBG_ERROR,"Error spawning thread in ProgressBar_SetDelayedMessageA."));
    }

    return rSuccess;
}

#if 0

DWORD
pTickProgressBarThread (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PTICKTHREADPARAMS   Params = (PTICKTHREADPARAMS)Param;
    BOOL                Continue = TRUE;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //

    do {
        switch (WaitForSingleObject(Params->CancelEvent, Params->TickCount)) {

        case WAIT_TIMEOUT:
            //
            // We timed out without cancel being signaled. Tick the progress bar.
            //
            if (!TickProgressBarDelta (Params->TickCount)) {
                //
                // cancelled
                //
                Continue = FALSE;
            }
            break;

        case WAIT_OBJECT_0:
        default:
            //
            //  We were canceled (or something strange happened :> Do nothing!
            //
            Continue = FALSE;
            break;
        }
    } while (Continue);

    //
    // can set a new thread now
    //
    Params->InUse = FALSE;

    return rc;
}


BOOL
ProgressBar_CreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    )
{
    BOOL                    rSuccess = FALSE;
    DWORD                   threadId;
    static TICKTHREADPARAMS g_Params;

    if (g_ProgBarInitialized && !g_Params.InUse) {

        if (pCheckProgressBarState(NULL)) {

            //
            // Fill in the parameters for this call to create thread.
            //
            g_Params.CancelEvent = CancelEvent;
            g_Params.TickCount = TickCount;

            //
            // Spawn off a thread that will set the message.
            //
            if (CreateThread (
                    NULL,   // No inheritance.
                    0,      // Normal stack size.
                    pTickProgressBarThread,
                    &g_Params,
                    0,      // Run immediately.
                    &threadId
                    )) {
                rSuccess = TRUE;
                g_Params.InUse = TRUE;
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Error spawning thread in ProgressBar_CreateTickThread."));
        }
    }

    return rSuccess;
}


BOOL
ProgressBar_CancelTickThread (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return SetEvent(CancelEvent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\pch.h ===
//
//  PCH.H
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//

#ifndef _REGPRIV_
#define _REGPRIV_

//  Conditional enable registry "features" based on the target model.
//
//  WANT_STATIC_KEYS:  Allocates key handles from a memory pool allocated
//  during library initialization.  Especially useful for real-mode to reduce
//  the memory fragmentation caused by allocating several small fixed objects.
//
//  WANT_FULL_MEMORY_CLEANUP:  When detaching, free every memory block.  Not
//  necessary for the ring zero version where "detach" means system shutdown.
//
//  WANT_HIVE_SUPPORT:  RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey
//  APIs plus support code.
//
//  WANT_DYNKEY_SUPPORT:  RegCreateDynKey plus HKEY_DYN_DATA support.
//
//  WANT_NOTIFY_CHANGE_SUPPORT:  RegNotifyChangeKeyValue plus support code.
#ifndef IS_32
#define WANT_STATIC_KEYS
#endif
#ifndef VXD
#define WANT_FULL_MEMORY_CLEANUP
#endif
#ifndef REALMODE
#define WANT_HIVE_SUPPORT
#endif
#ifdef VXD
#define WANT_REGREPLACEKEY
#define WANT_DYNKEY_SUPPORT
#define WANT_NOTIFY_CHANGE_SUPPORT
#endif

//  Map any other header's definitions of these to unused types.
#define HKEY __UNUSED_HKEY
#define LPHKEY __UNUSED_LPHKEY

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define NORESOURCE                  //  prevent RT_* definitions from vmmsys.h
#include <windows.h>
#include <string.h>
#ifdef VXD
#error "Cannot compile with VXD defined"
// #include <vmmsys.h>
// #include <thrdsys.h>
#endif

#ifndef UNALIGNED
#define UNALIGNED                   //  defined in standard headers for RISC
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY               1
#endif

#ifdef VXD
//  By default, all registry code and data is pageable.
#pragma VMM_PAGEABLE_CODE_SEG
#pragma VMM_PAGEABLE_DATA_SEG
#endif

#define UNREFERENCED_PARAMETER(P)   (P)

#define INTERNAL                    PASCAL NEAR
#define INTERNALV                   CDECL NEAR

//  Undefine any constants that we're about to define ourselves.
#undef HKEY
#undef LPHKEY
#undef HKEY_CLASSES_ROOT
#undef HKEY_CURRENT_USER
#undef HKEY_LOCAL_MACHINE
#undef HKEY_USERS
#undef HKEY_PERFORMANCE_DATA
#undef HKEY_CURRENT_CONFIG
#undef HKEY_DYN_DATA

typedef struct _KEY FAR*            HKEY;               //  Forward reference

#include "regdebug.h"
#include "regffmt.h"
#include "regfinfo.h"

//  Many file structures in the registry are declared as DWORDs, the HIWORD is
//  always zero.  Use SmallDword to access such DWORDs for optimal access in
//  16-bit or 32-bit code.
#if defined(IS_32)
#define SmallDword(dw)              ((UINT) (dw))
#else
#define SmallDword(dw)              ((UINT) LOWORD((dw)))
#endif

#if defined(WIN16)
#define IsNullPtr(ptr)              (SELECTOROF((ptr)) == NULL)
#else
#define IsNullPtr(ptr)              ((ptr) == NULL)
#endif

//  In either mode, the resulting code uses an instrinsic version of the memcmp
//  function.
#if defined(IS_32)
#define CompareMemory               memcmp
#else
#define CompareMemory               _fmemcmp
#endif

#if defined(WIN16) || defined(WIN32)
#define StrCpy(lpd, lps)            (lstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (lstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (lstrlen((lpstr)))
#define ToUpper(ch)                 ((int) (DWORD) AnsiUpper((LPSTR)((BYTE)(ch))))
#define RgCreateFile(lpfn)          ((HFILE) _lcreat((lpfn), 0))
#define RgOpenFile(lpfn, mode)      ((HFILE) _lopen((lpfn), (mode)))
#define RgCloseFile(h)              ((VOID) _lclose(h))
#if defined(WIN32)
#define RgDeleteFile(lpv)           (DeleteFile((lpv)))
#define RgRenameFile(lpv1, lpv2)    (MoveFile((lpv1), (lpv2)))
#define RgGetFileAttributes(lpv)    (GetFileAttributes((lpv)))
#define RgSetFileAttributes(lpv, a) (SetFileAttributes((lpv), (a)))
#define RgCommitFile(h)             (FlushFileBuffers((HANDLE)h))
#ifdef USEHEAP
extern HANDLE g_RgHeap;             //  Low memory heap for testing
#define AllocBytes(cb)              ((LPVOID) HeapAlloc(g_RgHeap, 0, (cb)))
#define FreeBytes(lpv)              ((VOID) HeapFree(g_RgHeap, 0, (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) HeapReAlloc(g_RgHeap, 0, (lpv), (cb)))
#define MemorySize(lpv)             ((UINT) HeapSize(g_RgHeap, 0, (lpv)))
#else
#define AllocBytes(cb)              ((LPVOID) LocalAlloc(LMEM_FIXED, (cb)))
#define FreeBytes(lpv)              ((VOID) LocalFree((HLOCAL) (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) LocalReAlloc((HLOCAL) (lpv), (cb), LMEM_MOVEABLE))
#define MemorySize(lpv)             ((UINT) LocalSize((lpv)))
#endif // USEHEAP
#else
#define AllocBytes(cb)              ((LPVOID) MAKELP(GlobalAlloc(GMEM_FIXED, (cb)), 0))
#define FreeBytes(lpv)              ((VOID) GlobalFree((HGLOBAL) SELECTOROF((lpv))))
#define ReAllocBytes(lpv, cb)       ((LPVOID) MAKELP(GlobalReAlloc((HGLOBAL) SELECTOROF((lpv)), (cb), GMEM_MOVEABLE), 0))
#define MemorySize(lpv)             ((UINT) GlobalSize((HGLOBAL) SELECTOROF((lpv))))
//  WIN16's ZeroMemory/MoveMemory:  SETUPX is the only target WIN16 environment
//  and they already use _fmemset and _fmemmove, so just use their versions.
#define ZeroMemory(lpv, cb)         (_fmemset((lpv), 0, (cb)))
#define MoveMemory(lpd, lps, cb)    (_fmemmove((lpd), (lps), (cb)))
#endif // WIN16 || WIN32
#elif defined(REALMODE)
#define IsBadStringPtr(lpv, cb)     (FALSE)
#define IsBadHugeWritePtr(lpv, cb)  (FALSE)
#define IsBadHugeReadPtr(lpv, cb)   (FALSE)
#define StrCpy(lpd, lps)            (_fstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (_fstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (_fstrlen((lpstr)))
#define ToUpper(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))
LPVOID INTERNAL AllocBytes(UINT);
VOID   INTERNAL FreeBytes(LPVOID);
LPVOID INTERNAL ReAllocBytes(LPVOID, UINT);
UINT   INTERNAL MemorySize(LPVOID);
VOID   INTERNAL ZeroMemory(LPVOID, UINT);
VOID   INTERNAL MoveMemory(LPVOID, const VOID FAR*, UINT);
#elif defined(VXD)
#undef IsBadStringPtr               //  Conflicts with windows.h
#undef ZeroMemory                   //  Conflicts with windows.h
#undef MoveMemory                   //  Conflicts with windows.h
BOOL    INTERNAL RgIsBadStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadOptionalStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeOptionalWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeReadPtr(const VOID FAR*, UINT);
#define IsBadStringPtr(lpv, cb)     (RgIsBadStringPtr((lpv), (cb)))
#define IsBadOptionalStringPtr(lpv, cb)     (RgIsBadOptionalStringPtr((lpv), (cb)))
#define IsBadHugeWritePtr(lpv, cb)  (RgIsBadHugeWritePtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb)  (RgIsBadHugeOptionalWritePtr((lpv), (cb)))
#define IsBadHugeReadPtr(lpv, cb)   (RgIsBadHugeReadPtr((lpv), (cb)))
#define StrCpy(lpd, lps)            (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(-1)))
#define StrCpyN(lpd, lps, cb)       (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(cb)))
#define StrLen(lpstr)               (_lstrlen((PCHAR)(lpstr)))
extern  UCHAR UpperCaseTable[256];
#define ToUpper(ch)                 ((int)(UpperCaseTable[(UCHAR)(ch)]))
VOID	INTERNAL RgSetAndReleaseEvent(HANDLE hEvent);
#define RgGetCurrentThreadId()      ((DWORD)pthcbCur)
#define AllocBytes(cb)              ((LPVOID) _HeapAllocate((cb), HEAPSWAP))
#define FreeBytes(lpv)              ((VOID) _HeapFree((lpv), 0))
#define ReAllocBytes(lpv, cb)       ((LPVOID) _HeapReAllocate((lpv), (cb), HEAPSWAP))
#define MemorySize(lpv)             ((UINT) _HeapGetSize((lpv), 0))
#define AllocPages(cp)              ((LPVOID) _PageAllocate((cp), PG_SYS, 0, 0, 0, 0, NULL, 0))
#define FreePages(lpv)              ((VOID) _PageFree((ULONG) (lpv), 0))
#define ReAllocPages(lpv, cp)       ((LPVOID) _PageReAllocate((ULONG) (lpv), (cp), 0))
VOID   INTERNAL RgZeroMemory(LPVOID, UINT);
VOID   INTERNAL RgMoveMemory(LPVOID, const VOID FAR*, UINT);
#define ZeroMemory                  RgZeroMemory
#define MoveMemory                  RgMoveMemory
#else
#error Must define REALMODE, VXD, WIN16, or WIN32.
#endif

//  The IsBadHugeOptional*Ptr macros are used to validate pointers that may be
//  NULL.  By wrapping this "predicate", we can generate smaller code in some
//  environments, specifically VMM...
#if !defined(VXD)
#define IsBadOptionalStringPtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadStringPtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadHugeWritePtr((lpv), (cb)))
#endif

//  The IsEnumIndexTooBig macro is used to check if a DWORD sized index can fit
//  into a UINT sized variable.  Only useful for validation of RegEnumKey or
//  RegEnumValue to make small code in both 16 and 32 bit environments.
#if defined(IS_32)
#define IsEnumIndexTooBig(index)    (FALSE)
#else
#define IsEnumIndexTooBig(index)    (HIWORD(index) > 0)
#endif

#if defined(VXD)
BOOL INTERNAL RgLockRegistry(VOID);
VOID INTERNAL RgUnlockRegistry(VOID);
VOID INTERNAL RgDelayFlush(VOID);
VOID INTERNAL RgYield(VOID);
#else
#define RgLockRegistry()            (TRUE)
#define RgUnlockRegistry()          (TRUE)
#define RgDelayFlush()              (TRUE)
#define RgYield()                   (TRUE)
#endif

//  Eliminate the need for #ifdef DBCS by using macros and letting the compiler
//  optimize out the DBCS code on SBCS systems.
#ifdef DBCS
#if !defined(WIN16) && !defined(WIN32)
BOOL INTERNAL RgIsDBCSLeadByte(BYTE TestChar);
#define IsDBCSLeadByte(ch)              RgIsDBCSLeadByte(ch)
#endif
#else
#define IsDBCSLeadByte(ch)              ((ch), FALSE)
#endif // DBCS

#ifdef WANT_DYNKEY_SUPPORT
//  Internally used for maintaining dynamic key information; only keeps the
//  fields that we actually need from the REG_PROVIDER structure given to
//  VMMRegCreateDynKey.
typedef struct _INTERNAL_PROVIDER {
    PQUERYHANDLER ipi_R0_1val;
    PQUERYHANDLER ipi_R0_allvals;
    LPVOID ipi_key_context;
}   INTERNAL_PROVIDER, FAR* PINTERNAL_PROVIDER;
#endif

typedef struct _KEY {
    WORD Signature;                             //  KEY_SIGNATURE
    WORD Flags; 				//  KEYF_* bits
    UINT ReferenceCount;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    DWORD ChildKeynodeIndex;
    WORD BlockIndex;
    WORD BigKeyLockedBlockIndex;        // If a bigkey function locked a datablock, this is its index
    BYTE KeyRecordIndex;
    BYTE PredefinedKeyIndex;
    struct _KEY FAR* lpNext;
    struct _KEY FAR* lpPrev;
    UINT LastEnumKeyIndex;
    DWORD LastEnumKeyKeynodeIndex;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
#endif
}   KEY;

#define KEY_SIGNATURE               0x4B48      //  "HK"

#define KEYF_PREDEFINED             0x01        //  Represents one of HKEY_*
#define KEYF_DELETED                0x02        //
#define KEYF_INVALID                0x04        //
#define KEYF_STATIC                 0x08        //  Allocated from static pool
#define KEYF_ENUMKEYCACHED          0x10        //  LastEnumKey* values valid
#define KEYF_HIVESALLOWED           0x20        //
#define KEYF_PROVIDERHASVALUELENGTH 0x40        //  PROVIDER_KEEPS_VALUE_LENGTH
#define KEYF_NEVERDELETE            0x80        //  Reference count overflow
#define KEYF_BIGKEYROOT             0x100       //  This key handle is for a big key
#define KEYF_ENUMEXTENTCACHED       0x200       //  LastEnumKey* is for a big key extent

#define INDEX_CLASSES_ROOT          0
#define INDEX_CURRENT_USER          1
#define INDEX_LOCAL_MACHINE         2
#define INDEX_USERS                 3
#define INDEX_PERFORMANCE_DATA      4
#define INDEX_CURRENT_CONFIG        5
#define INDEX_DYN_DATA              6

//  Returns TRUE if the KEY references the root of a hive, such as
//  HKEY_LOCAL_MACHINE, HKEY_USERS, or any hive loaded by RegLoadKey.
#define IsKeyRootOfHive(hkey)       \
    ((hkey)-> KeynodeIndex == (hkey)-> lpFileInfo-> KeynodeHeader.RootIndex)

//  Returns TRUE if the KEY is a subkey of HKEY_DYN_DATA.
#ifdef WANT_DYNKEY_SUPPORT
#define IsDynDataKey(hkey)          \
    ((hkey)-> PredefinedKeyIndex == INDEX_DYN_DATA)
#else
#define IsDynDataKey(hkey)          (FALSE)
#endif

#include <regapix.h>
#include "regkylst.h"
#include "regdblk.h"
#include "regknode.h"
#include "regnckey.h"
#include "regfsio.h"
#include "regmem.h"


#define ERROR_BIGKEY_NEEDED             1025L   // Internal error, the data won't fit in a normal key

#ifdef VXD
extern BYTE g_RgPostCriticalInit;
extern BYTE g_RgFileAccessDisabled;
#define IsPostCriticalInit()        (g_RgPostCriticalInit)
#define IsFileAccessDisabled()      (g_RgFileAccessDisabled)
#else
#define IsPostCriticalInit()        (TRUE)
#define IsFileAccessDisabled()      (FALSE)
#endif

//  g_RgWorkBuffer: one buffer is always available of size SIZEOF_WORK_BUFFER.
//  These macros wrap access to this buffer for to verify only one routine is
//  attempting to use it at any time.
extern LPVOID g_RgWorkBuffer;
#ifdef DEBUG
extern BOOL g_RgWorkBufferBusy;
#define RgLockWorkBuffer()          \
    (ASSERT(!g_RgWorkBufferBusy), g_RgWorkBufferBusy = TRUE, (LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)     \
    (VOID) (ASSERT((lpv) == g_RgWorkBuffer), g_RgWorkBufferBusy = FALSE)
#else
#define RgLockWorkBuffer()          ((LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)
#endif
#define SIZEOF_WORK_BUFFER          (sizeof(W95KEYNODE_BLOCK))

#define IsKeyRecordFree(lpkr) \
    (((lpkr)-> DatablockAddress) == REG_NULL)

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    );

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    );

#define LK_OPEN                     0x0000      //  Open key only
#define LK_CREATE                   0x0001      //  Create or open key
#define LK_CREATEDYNDATA            0x0002      //  HKEY_DYN_DATA may create
#define LK_BIGKEYEXT                0x0004      //  Search only for big key extents

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    );

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    );

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName,
    UINT Flags
    );

int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByNameStd(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndexStd(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord,
    UINT FAR* lpValueCount
    );

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );


VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    );

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    );

int
INTERNAL
RgSetValueStd(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData,
    BOOL fBigKeyExtent
    );

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    );

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    );

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    );

WORD
INTERNAL 
RgAtoW(
    LPCSTR lpDec
      );

VOID
INTERNAL
RgWtoA(
    WORD Dec,
    LPSTR lpDec
      );

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    );

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    );

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    );

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    );

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    );

#endif // _REGPRIV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdebug.h ===
//
//  DEBUG.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _DEBUG_
#define _DEBUG_

#ifdef DEBUG

//  Disable the "in-line assembler precludes global optimizations" warning
//  because of debug breaks.
#pragma warning(disable:4704)

#if !defined(WIN32) || defined(_X86_)
#define TRAP()                      _asm {int 3}
#else
#define TRAP()                      DebugBreak()
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    );

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    );

#define TRACE(x)    RgDebugPrintf ##x

#ifdef REGDEBUG
#define NOISE(x)    RgDebugPrintf ##x
#else
#define NOISE(x)
#endif

#define ASSERT(x)   ((x) ? (VOID) 0 : RgDebugAssert(__FILE__, __LINE__))

#define DECLARE_DEBUG_COUNT(var)    int var = 0;
#define INCREMENT_DEBUG_COUNT(var)  ((var)++)
#define DECREMENT_DEBUG_COUNT(var)  ASSERT(((var)--))

#if !defined(WIN32) || defined(_X86_)
#define DEBUG_OUT(x)                { TRACE(x); _asm {int 1}; }
#else
#define DEBUG_OUT(x)                { TRACE(x); TRAP(); }
#endif

#else
#define TRAP()
#define TRACE(x)
#define NOISE(x)
#define ASSERT(x)
#define DECLARE_DEBUG_COUNT(var)
#define INCREMENT_DEBUG_COUNT(var)
#define DECREMENT_DEBUG_COUNT(var)
#define DEBUG_OUT(x)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdebug.c ===
//
//  REGDEBUG.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//  VXD_NODEBUGGER:  Uses debug services available when a debugger is not
//  installed, but at the cost of an intermediate debug buffer.
//#define VXD_NODEBUGGER

#ifdef DEBUG

#include <stdarg.h>

#ifdef STDIO_DEBUG
#include <stdio.h>
#else
static char g_RgDebugBuffer[256];
#endif

#ifdef VXD_NODEBUGGER
extern	ULONG	(SERVICE*_Vsprintf)(PCHAR,PCHAR,va_list);
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    )
{

    va_list arglist;

    va_start(arglist, lpFormatString);

#ifdef STDIO_DEBUG
    vprintf(lpFormatString, arglist);
#else
#ifdef VXD
#ifdef VXD_NODEBUGGER
    _Vsprintf(g_RgDebugBuffer, (PCHAR) lpFormatString, arglist);
    _Debug_Out_Service(g_RgDebugBuffer);
#else
    _Debug_Printf_Service((PCHAR) lpFormatString, arglist);
#endif
#else
    wvsprintf(g_RgDebugBuffer, lpFormatString, arglist);
    OutputDebugString(g_RgDebugBuffer);
#endif
#endif

}

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    )
{

    RgDebugPrintf("assert failed %s@%d\n", lpFile, LineNumber);

    TRAP();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdblk.c ===
//
//  REGDBLK.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgDatablockLockCount);

//  Don't let a FREE_RECORD shrink less than this value.
#define MINIMUM_FREE_RECORD_LENGTH  (sizeof(KEY_RECORD) + sizeof(VALUE_RECORD))

//
//  RgAllocDatablockInfoBuffers
//
//  Allocates the buffers associated with a DATABLOCK_INFO structure.  The
//  size of the datablock buffer is determined by the BlockSize member.
//

int
INTERNAL
RgAllocDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    lpDatablockInfo-> lpDatablockHeader = (LPDATABLOCK_HEADER)
        RgAllocMemory(lpDatablockInfo-> BlockSize);

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {

        lpDatablockInfo-> lpKeyRecordTable = (LPKEY_RECORD_TABLE_ENTRY)
            RgSmAllocMemory(sizeof(KEY_RECORD_TABLE_ENTRY) *
            KEY_RECORDS_PER_DATABLOCK);

        if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable))
            return ERROR_SUCCESS;

        RgFreeDatablockInfoBuffers(lpDatablockInfo);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgFreeDatablockInfoBuffers
//
//  Frees the buffers associated with a DATABLOCK_INFO structure.
//

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {
        RgFreeMemory(lpDatablockInfo-> lpDatablockHeader);
        lpDatablockInfo-> lpDatablockHeader = NULL;
    }

    if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable)) {
        RgSmFreeMemory(lpDatablockInfo-> lpKeyRecordTable);
        lpDatablockInfo-> lpKeyRecordTable = NULL;
    }

}

//
//  RgBuildKeyRecordTable
//
//  Builds a KEY_RECORD index table for the given datablock.
//
//  A datablock consists of a header followed by a series of variable-sized
//  KEY_RECORDs, each with a unique id.  To make lookups fast, an index table is
//  used to map from the unique id to that KEY_RECORD's location.
//
//  As we walk over each KEY_RECORD, we do checks to validate the structure of
//  the datablock, so the error code should be checked for corruption.
//

int
INTERNAL
RgBuildKeyRecordTable(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT Offset;
    UINT BytesRemaining;
    LPKEY_RECORD lpKeyRecord;
    DWORD DatablockAddress;

    ZeroMemory(lpDatablockInfo-> lpKeyRecordTable,
        sizeof(KEY_RECORD_TABLE_ENTRY) * KEY_RECORDS_PER_DATABLOCK);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    Offset = sizeof(DATABLOCK_HEADER);
    BytesRemaining = lpDatablockInfo-> BlockSize - sizeof(DATABLOCK_HEADER);

    while (BytesRemaining) {

        lpKeyRecord = (LPKEY_RECORD) ((LPBYTE) lpDatablockHeader + Offset);
        DatablockAddress = lpKeyRecord-> DatablockAddress;

        if ((lpKeyRecord-> AllocatedSize == 0) || (lpKeyRecord-> AllocatedSize >
            BytesRemaining) || ((DatablockAddress != REG_NULL) &&
            (LOWORD(DatablockAddress) >= KEY_RECORDS_PER_DATABLOCK))) {

            TRACE(("RgBuildKeyRecordTable: invalid key record detected\n"));

            TRACE(("lpdh=%x\n", lpDatablockHeader));
            TRACE(("lpkr=%x\n", lpKeyRecord));
            TRACE(("as=%x\n", lpKeyRecord-> AllocatedSize));
            TRACE(("br=%x\n", BytesRemaining));
            TRACE(("dba=%x\n", DatablockAddress));
            TRAP();

            //  Old code tries to reclaim some of the data.
            return ERROR_BADDB;

        }

        if (DatablockAddress != REG_NULL) {
	    lpDatablockInfo-> lpKeyRecordTable[LOWORD(DatablockAddress)] =
                (KEY_RECORD_TABLE_ENTRY) Offset;
        }

        Offset += SmallDword(lpKeyRecord-> AllocatedSize);
        BytesRemaining -= SmallDword(lpKeyRecord-> AllocatedSize);

    }

    return ERROR_SUCCESS;

}

//
//  RgLockDatablock
//
//  Locks the specified datablock in memory, indicating that it is about to be
//  used.  If the datablock is not currently in memory, then it is brought in.
//  Unlocked datablocks are freed as necessary to make room for this new
//  datablock.
//
//  IMPORTANT:  Locking a datablock only means that it's guaranteed to be kept
//  in memory.  It does not mean that pointers contained in a DATABLOCK_INFO
//  structure will remain the same: routines that could change the
//  DATABLOCK_INFO pointers are labeled "IMPORTANT" as well.
//
//  lpFileInfo, registry file containing the datablock.
//  BlockIndex, index of the datablock.
//

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;
    HFILE hFile = HFILE_ERROR;

    if (BlockIndex >= lpFileInfo-> FileHeader.BlockCount) {
        TRACE(("RgLockDatablock: invalid datablock number\n"));
        return ERROR_BADDB;
    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    //
    //  Is the datablock currently in memory?
    //

    if (!(lpDatablockInfo-> Flags & DIF_PRESENT)) {

        NOISE(("RgLockDatablock: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", BlockIndex));

        ASSERT(lpDatablockInfo-> FileOffset != -1);

        if ((ErrorCode = RgAllocDatablockInfoBuffers(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        NOISE(("    lpDatablockHeader=%lx\n", lpDatablockInfo-> lpDatablockHeader));
        NOISE(("    lpKeyRecordTable=%lx\n", lpDatablockInfo-> lpKeyRecordTable));

        if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) == HFILE_ERROR)
            goto CleanupAfterFileError;

        if (!RgSeekFile(hFile, lpDatablockInfo-> FileOffset))
            goto CleanupAfterFileError;

        if (!RgReadFile(hFile, lpDatablockInfo-> lpDatablockHeader,
            (UINT) lpDatablockInfo-> BlockSize))
            goto CleanupAfterFileError;

        if (!RgIsValidDatablockHeader(lpDatablockInfo-> lpDatablockHeader)) {
            ErrorCode = ERROR_BADDB;
            goto CleanupAfterError;
        }

        if ((ErrorCode = RgBuildKeyRecordTable(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        RgCloseFile(hFile);

    }

    lpDatablockInfo-> Flags |= (DIF_ACCESSED | DIF_PRESENT);
    lpDatablockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);
    return ERROR_SUCCESS;

CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

CleanupAfterError:
    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    RgFreeDatablockInfoBuffers(lpDatablockInfo);

    DEBUG_OUT(("RgLockDatablock() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgUnlockDatablock
//
//  Unlocks the datablock, indicating that the datablock is no longer in active
//  use.  After a datablock has been unlocked, the datablock may be freed after
//  flushing to disk if dirty.
//

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    ASSERT(lpDatablockInfo-> LockCount > 0);
    lpDatablockInfo-> LockCount--;

    if (fMarkDirty) {
        lpDatablockInfo-> Flags |= DIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

}

//
//  RgLockKeyRecord
//
//  Wraps RgLockDatablock, returning the address of the specified KEY_RECORD
//  structure.
//

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;

    if ((ErrorCode = RgLockDatablock(lpFileInfo, BlockIndex)) ==
        ERROR_SUCCESS) {

        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (IsNullKeyRecordTableEntry(lpDatablockInfo->
            lpKeyRecordTable[KeyRecordIndex])) {
            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);
            TRACE(("RgLockKeyRecord: invalid datablock address %x:%x\n",
                BlockIndex, KeyRecordIndex));
            ErrorCode = ERROR_BADDB;
        }

        else {
            *lplpKeyRecord = RgIndexKeyRecordPtr(lpDatablockInfo,
                KeyRecordIndex);
        }

    }

    return ErrorCode;

}

//
//  RgCompactDatablock
//
//  Compacts the datablock by pushing all KEY_RECORDS together and leaving a
//  single FREEKEY_RECORD at the end.
//
//  The datablock must be marked dirty by the caller, if desired.
//
//  Returns TRUE if any action was taken.
//

BOOL
INTERNAL
RgCompactDatablock(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    LPBYTE lpSource;
    LPBYTE lpDestination;
    UINT Offset;
    UINT BlockSize;
    UINT BytesToPushDown;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    //  Only need to compact if there's a free record in this datablock.
    if (lpDatablockHeader-> FirstFreeOffset == REG_NULL)
        return FALSE;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        SmallDword(lpDatablockHeader-> FirstFreeOffset));

    //  Only need to compact if the all the free bytes aren't already at the end
    //  of the datablock (datablocks can't be greater than 64K-1, so no overflow
    //  is possible).
    if ((SmallDword(lpDatablockHeader-> FirstFreeOffset) +
        SmallDword(lpFreeKeyRecord-> AllocatedSize) >= lpDatablockInfo->
        BlockSize) && (lpFreeKeyRecord-> NextFreeOffset == REG_NULL))
        return FALSE;

    NOISE(("RgCompactDatablock: block %d\n", lpDatablockHeader-> BlockIndex));

    lpSource = NULL;
    lpDestination = NULL;
    Offset = sizeof(DATABLOCK_HEADER);
    BlockSize = lpDatablockInfo-> BlockSize;

    while (Offset < BlockSize) {

        //  Advance to the next free record or the end of the block.
        for (;;) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                Offset);

            if (Offset >= BlockSize || IsKeyRecordFree(lpFreeKeyRecord)) {

                //
                //  If lpSource is valid, then we can push down the bytes from
                //  lpSource through lpFreeKeyRecord to lpDestination.
                //

                if (!IsNullPtr(lpSource)) {
                    BytesToPushDown = (LPBYTE) lpFreeKeyRecord -
                        (LPBYTE) lpSource;
                    MoveMemory(lpDestination, lpSource, BytesToPushDown);
                    lpDestination += BytesToPushDown;
                }

                if (IsNullPtr(lpDestination))
                    lpDestination = (LPBYTE) lpFreeKeyRecord;

                break;

            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

        //  Advance to the next key record.
        while (Offset < BlockSize) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                Offset);

            if (!IsKeyRecordFree(lpFreeKeyRecord)) {
                lpSource = (LPBYTE) lpFreeKeyRecord;
                break;
            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

    }

    //  lpDestination now points at the end of the datablock where the giant
    //  free record is to be placed.  Initialize this record and patch up the
    //  datablock header.
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpDestination -
        (LPBYTE) lpDatablockHeader;
    ((LPFREEKEY_RECORD) lpDestination)-> AllocatedSize = lpDatablockInfo->
        FreeBytes;
    ((LPFREEKEY_RECORD) lpDestination)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpDestination)-> NextFreeOffset = REG_NULL;

    //  The key record table is now invalid, so we must refresh its contents.
    RgBuildKeyRecordTable(lpDatablockInfo);

    return TRUE;

}

//
//  RgCreateDatablock
//
//  Creates a new datablock at the end of the file of the specified length (plus
//  padding to align the block).
//
//  The datablock is locked, so RgUnlockDatablock must be called on the last
//  datablock in the file.
//

int
INTERNAL
RgCreateDatablock(
    LPFILE_INFO lpFileInfo,
    UINT Length
    )
{

    UINT BlockCount;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (BlockCount >= DATABLOCKS_PER_FILE)
        return ERROR_OUTOFMEMORY;

    if (BlockCount >= lpFileInfo-> DatablockInfoAllocCount) {

        //  lpDatablockInfo is too small to hold the info for a new datablock,
        //  so we must grow it a bit.
        if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
            RgSmReAllocMemory(lpFileInfo-> lpDatablockInfo, (BlockCount +
            DATABLOCK_INFO_SLACK_ALLOC) * sizeof(DATABLOCK_INFO)))))
            return ERROR_OUTOFMEMORY;

        lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
        lpFileInfo-> DatablockInfoAllocCount += DATABLOCK_INFO_SLACK_ALLOC;

    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockCount);

    Length = RgAlignBlockSize(Length + sizeof(DATABLOCK_HEADER));
    lpDatablockInfo-> BlockSize = Length;

    if (RgAllocDatablockInfoBuffers(lpDatablockInfo) != ERROR_SUCCESS)
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> FreeBytes = Length - sizeof(DATABLOCK_HEADER);
    lpDatablockInfo-> FirstFreeIndex = 0;
    lpDatablockInfo-> FileOffset = -1;          //  Set during file flush
    lpDatablockInfo-> Flags = DIF_PRESENT | DIF_ACCESSED | DIF_DIRTY;
    lpDatablockInfo-> LockCount = 1;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    lpDatablockHeader-> Signature = DH_SIGNATURE;
    lpDatablockHeader-> BlockSize = Length;
    lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
    lpDatablockHeader-> Flags = DHF_HASBLOCKNUMBERS;
    lpDatablockHeader-> BlockIndex = (WORD) BlockCount;
    lpDatablockHeader-> FirstFreeOffset = sizeof(DATABLOCK_HEADER);
    lpDatablockHeader-> MaxAllocatedIndex = 0;
    //  lpDatablockHeader-> FirstFreeIndex is copied back on the flush.
    //  lpDatablockHeader-> Reserved is worthless because it was randomly set
    //      to a pointer in the old code.

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        sizeof(DATABLOCK_HEADER));
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpFreeKeyRecord-> DatablockAddress = REG_NULL;
    lpFreeKeyRecord-> NextFreeOffset = REG_NULL;

    lpFileInfo-> FileHeader.BlockCount++;
    lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;
    //  Extending a datablock does not necessarily mean "rewrite the
    //  whole file again", but it works for now...
    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

    //  We must initialize the key record table, so we might as well let
    //  RgBuildKeyRecordTable check the validity of what we just created...
    return RgBuildKeyRecordTable(lpDatablockInfo);

}

//
//  RgExtendDatablock
//
//  Extends the given datablock to the specified size.  If successful, then the
//  resulting datablock will be compacted with a single FREEKEY_RECORD at the
//  end of the datablock which will include the added space.
//

int
INTERNAL
RgExtendDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    DWORD NewBlockSize;
    LPDATABLOCK_HEADER lpNewDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    //  Check if enough free bytes already exist: if so, no need to extend.
    if (lpDatablockInfo-> FreeBytes >= Length) {
        DEBUG_OUT(("RgExtendDatablock: unexpectedly called\n"));
        return ERROR_SUCCESS;
    }

    NewBlockSize = RgAlignBlockSize(lpDatablockInfo-> BlockSize + Length -
        lpDatablockInfo-> FreeBytes);

    if (NewBlockSize > MAXIMUM_DATABLOCK_SIZE) {
        TRACE(("RgExtendDatablock: datablock too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    NOISE(("RgExtendDatablock: block %d\n", BlockIndex));
    NOISE(("block size=%x, new block size=%x\n", lpDatablockInfo-> BlockSize,
        NewBlockSize));

    if (IsNullPtr((lpNewDatablockHeader = (LPDATABLOCK_HEADER)
        RgReAllocMemory(lpDatablockInfo-> lpDatablockHeader, (UINT)
        NewBlockSize))))
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> lpDatablockHeader = lpNewDatablockHeader;

    RgCompactDatablock(lpDatablockInfo);

    if (lpNewDatablockHeader-> FirstFreeOffset == REG_NULL) {
        lpNewDatablockHeader-> FirstFreeOffset = lpDatablockInfo-> BlockSize;
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
            SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
        lpFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpFreeKeyRecord-> NextFreeOffset = REG_NULL;
    }

    else {
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
            SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
    }

    lpDatablockInfo-> FreeBytes += (UINT) NewBlockSize - lpDatablockInfo->
        BlockSize;
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpDatablockInfo-> BlockSize = (UINT) NewBlockSize;

    lpDatablockInfo-> Flags |= (DIF_DIRTY | DIF_EXTENDED);
    //  Extending a datablock does not necessarily mean "rewrite the
    //  whole file again", but it works for now...
    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordFromDatablock
//
//  Creates an uninitialized KEY_RECORD of the desired size from the provided
//  datablock.  On exit, only AllocatedSize is valid.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    LPFREEKEY_RECORD lpNewFreeKeyRecord;
    UINT ExtraBytes;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    if (Length > lpDatablockInfo-> FreeBytes)
        return ERROR_OUTOFMEMORY;

    RgCompactDatablock(lpDatablockInfo);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        SmallDword(lpDatablockHeader-> FirstFreeOffset));

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (Length > AllocatedSize) {
        TRACE(("RgAllocKeyRecordFromDatablock() detected corruption?\n"));
        return ERROR_OUTOFMEMORY;
    }

    ExtraBytes = AllocatedSize - Length;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        lpNewFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
            Length);

        lpDatablockHeader-> FirstFreeOffset += Length;

        lpFreeKeyRecord-> AllocatedSize = Length;

	//  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
	//  overlap so we have to be careful when changing these fields!
	lpNewFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpNewFreeKeyRecord-> DatablockAddress = REG_NULL;
	lpNewFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        Length = AllocatedSize;

        lpDatablockHeader-> FirstFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

    }

    //  Adjust the number of free bytes in this datablock.  At this point,
    //  Length is equal to the size of the newly formed record.
    lpDatablockInfo-> FreeBytes -= Length;

    *lplpKeyRecord = (LPKEY_RECORD) lpFreeKeyRecord;
    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordIndex
//
//  Allocates a key record index from the provided datablock.  If no indexs
//  are available in the datablock, then KEY_RECORDS_PER_DATABLOCK is returned.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

UINT
INTERNAL
RgAllocKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT KeyRecordIndex;
    UINT NextFreeIndex;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTableEntry;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    KeyRecordIndex = lpDatablockInfo-> FirstFreeIndex;
    NextFreeIndex = KeyRecordIndex + 1;

    ASSERT(KeyRecordIndex < KEY_RECORDS_PER_DATABLOCK);
    ASSERT(IsNullKeyRecordTableEntry(lpDatablockInfo->
        lpKeyRecordTable[KeyRecordIndex]));

    if (KeyRecordIndex > lpDatablockHeader-> MaxAllocatedIndex)
        lpDatablockHeader-> MaxAllocatedIndex = (WORD) KeyRecordIndex;

    else {

        //  Find the next free hole in the key record table or leave ourselves
        //  at the end of the table.
        for (lpKeyRecordTableEntry =
            &lpDatablockInfo-> lpKeyRecordTable[NextFreeIndex]; NextFreeIndex <=
            lpDatablockHeader-> MaxAllocatedIndex; NextFreeIndex++,
            lpKeyRecordTableEntry++) {
            if (IsNullKeyRecordTableEntry(*lpKeyRecordTableEntry))
                break;
        }

    }

    lpDatablockInfo-> FirstFreeIndex = NextFreeIndex;

    return KeyRecordIndex;

}

//
//  RgAllocKeyRecord
//
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    BOOL fExtendDatablock;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT KeyRecordIndex;

    if (lpFileInfo-> FileHeader.BlockCount == 0)
        goto MakeNewDatablock;

    //
    //  Find a datablock that can satisfy the allocation request.  Two passes
    //  may be made over this routine-- during the second pass, datablocks may
    //  be extended.
    //

    fExtendDatablock = FALSE;

DoSecondPass:
    BlockIndex = lpFileInfo-> FileHeader.BlockCount;
    //  We overindex by one, but this gets decremented at the start of the loop.
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    while (BlockIndex--) {

        lpDatablockInfo--;

        //  Are there any more ids available in this datablock?
        if (lpDatablockInfo-> FirstFreeIndex >= KEY_RECORDS_PER_DATABLOCK)
            continue;

        if (fExtendDatablock) {
            //  Can we grow this datablock without exceeding the maximum size?
            if ((DWORD) (lpDatablockInfo-> BlockSize - lpDatablockInfo->
                FreeBytes) + Length > MAXIMUM_DATABLOCK_SIZE)
                continue;
        }
        else {
            //  Is there enough free space in this datablock for this record?
            if (Length > lpDatablockInfo-> FreeBytes)
                continue;
        }

        if (RgLockDatablock(lpFileInfo, BlockIndex) == ERROR_SUCCESS) {

            if (!fExtendDatablock || RgExtendDatablock(lpFileInfo, BlockIndex,
                Length) == ERROR_SUCCESS) {

                if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex,
                    Length, lplpKeyRecord) == ERROR_SUCCESS)
                    goto AllocatedKeyRecord;

            }

            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

        }

    }

    //  If we haven't already tried to extend some datablock, make another
    //  pass over the blocks to do so.
    if (!fExtendDatablock) {
        fExtendDatablock = TRUE;
        goto DoSecondPass;
    }

    //
    //  No datablock has enough space to satisfy the request, so attempt to
    //  create a new one at the end of the file.
    //

MakeNewDatablock:
    if (RgCreateDatablock(lpFileInfo, Length) == ERROR_SUCCESS) {

        BlockIndex = lpFileInfo-> FileHeader.BlockCount - 1;
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex, Length,
            lplpKeyRecord) == ERROR_SUCCESS) {

AllocatedKeyRecord:
            KeyRecordIndex = RgAllocKeyRecordIndex(lpDatablockInfo);
            (*lplpKeyRecord)-> DatablockAddress = MAKELONG(KeyRecordIndex,
                BlockIndex);
            lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
                (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
                (LPBYTE) lpDatablockInfo-> lpDatablockHeader);
            return ERROR_SUCCESS;

        }

        RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgExtendKeyRecord
//
//  Attempts to extend the given KEY_RECORD by combining it with an adjacent
//  FREE_RECORD.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  Returns ERROR_SUCCESS if the KEY_RECORD could be extended, else
//  ERROR_OUTOFMEMORY.
//

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    UINT FreeSizeAllocation;
    UINT ExtraBytes;
    LPFREEKEY_RECORD lpTempFreeKeyRecord;
    DWORD NewFreeOffset;                    //  May be REG_NULL
    UINT FreeOffset;
    DWORD Offset;                           //  May be REG_NULL

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    AllocatedSize = SmallDword(lpKeyRecord-> AllocatedSize);

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpKeyRecord +
        AllocatedSize);
    FreeOffset = (LPBYTE) lpFreeKeyRecord - (LPBYTE) lpDatablockHeader;

    //  Check if this key record is at the very end of the datablock and that
    //  lpFreeKeyRecord is really a free key record.
    if (FreeOffset >= lpDatablockInfo-> BlockSize ||
        !IsKeyRecordFree(lpFreeKeyRecord))
        return ERROR_OUTOFMEMORY;

    ASSERT(Length >= AllocatedSize);
    FreeSizeAllocation = Length - AllocatedSize;

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (FreeSizeAllocation > AllocatedSize)
        return ERROR_OUTOFMEMORY;

    ExtraBytes = AllocatedSize - FreeSizeAllocation;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        NewFreeOffset = FreeOffset + FreeSizeAllocation;
        lpTempFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
            FreeSizeAllocation);

	//  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
	//  overlap so we have to be careful when changing these fields!
        lpTempFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpTempFreeKeyRecord-> DatablockAddress = REG_NULL;
	lpTempFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        NewFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

        //  The key record's allocated length will also include all of the extra
        //  bytes.
        FreeSizeAllocation += ExtraBytes;

    }

    lpKeyRecord-> AllocatedSize += FreeSizeAllocation;
    lpDatablockInfo-> FreeBytes -= FreeSizeAllocation;

    //
    //  Unlink the free record that we just extended into and possibly link in
    //  the new FREEKEY_RECORD if a split occurred.
    //

    Offset = lpDatablockHeader-> FirstFreeOffset;

    if (Offset == FreeOffset) {
        lpDatablockHeader-> FirstFreeOffset = NewFreeOffset;
    }

    else {

        while (Offset != REG_NULL) {

            lpTempFreeKeyRecord =
                (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                SmallDword(Offset));

            Offset = lpTempFreeKeyRecord-> NextFreeOffset;

            if (Offset == FreeOffset) {
                lpTempFreeKeyRecord-> NextFreeOffset = NewFreeOffset;
                break;
            }

        }

    }

    return ERROR_SUCCESS;

}

//
//  RgFreeKeyRecord
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    ((LPFREEKEY_RECORD) lpKeyRecord)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpKeyRecord)-> NextFreeOffset = lpDatablockHeader->
        FirstFreeOffset;
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpKeyRecord - (LPBYTE)
        lpDatablockHeader;
    lpDatablockInfo-> FreeBytes += SmallDword(((LPFREEKEY_RECORD) lpKeyRecord)->
        AllocatedSize);

}

//
//  RgFreeKeyRecordIndex
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  We don't bother updated MaxAllocatedIndex because it's only really useful
//  if we're always freeing from the maximum index to zero.  This is very
//  rarely the case, so no point in keeping that test around or touching the
//  datablock header page just to do it.
//

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    )
{

    ASSERT(lpDatablockInfo-> lpDatablockHeader-> MaxAllocatedIndex >=
	KeyRecordIndex);

    if (lpDatablockInfo-> FirstFreeIndex > KeyRecordIndex)
        lpDatablockInfo-> FirstFreeIndex = KeyRecordIndex;

    lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
        NULL_KEY_RECORD_TABLE_ENTRY;

}

//
//  RgWriteDatablocks
//
//  Writes all dirty datablocks to the file specified by the file handle.
//

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        if (lpDatablockInfo-> Flags & DIF_PRESENT) {

            //  The block is currently in memory.  If we're either extending
            //  the file or the block is dirty, then write out our in-memory
            //  copy to disk.
            if (hSourceFile != HFILE_ERROR || lpDatablockInfo-> Flags &
                DIF_DIRTY) {

                NOISE(("writing datablock #%d of ", BlockIndex));
                NOISE((lpFileInfo-> FileName));
                NOISE(("\n"));

                lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

                //  Copy back the fields that we've been maintaining in the
                //  DATABLOCK_INFO structure.
                lpDatablockHeader-> BlockSize = lpDatablockInfo-> BlockSize;
                lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
                lpDatablockHeader-> FirstFreeIndex = (WORD) lpDatablockInfo->
                    FirstFreeIndex;

                //  The checksum is not currently calculated, so we must clear
                //  the flag so we don't confuse Win95.
                lpDatablockHeader-> Flags &= ~DHF_HASCHECKSUM;

                if (!RgSeekFile(hDestinationFile, FileOffset))
                    return ERROR_REGISTRY_IO_FAILED;

                if (!RgWriteFile(hDestinationFile, lpDatablockHeader,
                    lpDatablockInfo-> BlockSize))
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        else {

            //  The block is not currently in memory.  If we're extending the
            //  file, then we must write out this datablock.  The overhead is
            //  too great to lock the datablock down, so just copy it from the
            //  original file to the extended file.
            if (hSourceFile != HFILE_ERROR) {

                if (RgCopyFileBytes(hSourceFile, lpDatablockInfo-> FileOffset,
                    hDestinationFile, FileOffset, lpDatablockInfo->
                    BlockSize) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteDatablocksComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        lpDatablockInfo-> Flags &= ~DIF_DIRTY;
        lpDatablockInfo-> FileOffset = FileOffset;

        FileOffset += lpDatablockInfo-> BlockSize;

    }

}

//
//  RgSweepDatablocks
//
//  Makes a pass through all the present datablocks of the given FILE_INFO
//  structure and discards datablocks that have not been accessed since the last
//  sweep.
//

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPDATABLOCK_INFO lpDatablockInfo;

    for (BlocksLeft = lpFileInfo-> FileHeader.BlockCount, lpDatablockInfo =
        lpFileInfo-> lpDatablockInfo; BlocksLeft > 0; BlocksLeft--,
        lpDatablockInfo++) {

        if (((lpDatablockInfo-> Flags & (DIF_PRESENT | DIF_ACCESSED |
            DIF_DIRTY)) == DIF_PRESENT) && (lpDatablockInfo-> LockCount == 0)) {

            NOISE(("discarding datablock #%d of ",
                lpFileInfo-> FileHeader.BlockCount - BlocksLeft));
            NOISE((lpFileInfo-> FileName));
            NOISE(("\n"));

            RgFreeDatablockInfoBuffers(lpDatablockInfo);

            lpDatablockInfo-> Flags = 0;

        }

        //  Reset the accessed bit for the next sweep.
        lpDatablockInfo-> Flags &= ~DIF_ACCESSED;

    }

}

//
//  RgIsValidDatablockHeader
//
//  Returns TRUE if lpDatablockHeader is a valid DATABLOCK_HEADER structure.
//

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    )
{

    if (lpDatablockHeader-> Signature != DH_SIGNATURE ||
        HIWORD(lpDatablockHeader-> BlockSize) != 0)
        return FALSE;

    return TRUE;

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitDatablockInfo
//
//  Initializes fields in the provided FILE_INFO related to the datablocks.
//

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    )
{

    UINT BlockCount;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;
    DATABLOCK_HEADER DatablockHeader;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
        RgSmAllocMemory((BlockCount + DATABLOCK_INFO_SLACK_ALLOC) *
        sizeof(DATABLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpDatablockInfo, BlockCount * sizeof(DATABLOCK_INFO));
    lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
    lpFileInfo-> DatablockInfoAllocCount = BlockCount +
        DATABLOCK_INFO_SLACK_ALLOC;

    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex++,
        lpDatablockInfo++) {

        if (!RgSeekFile(hFile, FileOffset))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgReadFile(hFile, &DatablockHeader, sizeof(DATABLOCK_HEADER)))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgIsValidDatablockHeader(&DatablockHeader))
            return ERROR_BADDB;

        //  Following fields already zeroed by above ZeroMemory.
        //  lpDatablockInfo-> lpDatablockHeader = NULL;
        //  lpDatablockInfo-> lpKeyRecordTable = NULL;
        //  lpDatablockInfo-> Flags = 0;
        //  lpDatablockInfo-> LockCount = 0;

        lpDatablockInfo-> FileOffset = FileOffset;

        //  Cache these fields from the datablock header.  These fields should
        //  not be considered valid when the datablock is physically in memory.
        lpDatablockInfo-> BlockSize = SmallDword(DatablockHeader.BlockSize);
        lpDatablockInfo-> FreeBytes = SmallDword(DatablockHeader.FreeBytes);
        lpDatablockInfo-> FirstFreeIndex = DatablockHeader.FirstFreeIndex;

        NOISE(("DB#%d fileoff=%lx, size=%x free=%x 1stindex=%d\n", BlockIndex,
            FileOffset, lpDatablockInfo-> BlockSize, lpDatablockInfo->
            FreeBytes, lpDatablockInfo-> FirstFreeIndex));

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdblk.h ===
//
//  REGDBLK.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGDBLK_
#define _REGDBLK_

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    );

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    );

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    );

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    );

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    );

#endif // _REGDBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdval.c ===
//
//  REGDVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegDeleteValue and supporting functions.
//

#include "pch.h"

//
//  RgDeleteValueRecord
//
//  Deletes the specified VALUE_RECORD from the provided KEY_RECORD.
//

VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    )
{

    UINT ValueRecordLength;
    LPBYTE lpSource;
    UINT BytesToPushDown;

    ASSERT(lpKeyRecord-> ValueCount > 0);

    ValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord-> NameLength +
        lpValueRecord-> DataLength - 1;

    ASSERT(lpKeyRecord-> RecordSize >= ValueRecordLength);

    //
    //  If this isn't the last value of this KEY_RECORD, then push down any
    //  VALUE_RECORDs after the VALUE_RECORD to delete.
    //

    if (--lpKeyRecord-> ValueCount) {

        lpSource = (LPBYTE) lpValueRecord + ValueRecordLength;

        BytesToPushDown = (UINT) ((LPBYTE) lpKeyRecord + lpKeyRecord->
            RecordSize - lpSource);

        MoveMemory((LPBYTE) lpValueRecord, lpSource, BytesToPushDown);

    }

    lpKeyRecord-> RecordSize -= ValueRecordLength;

}

//
//  VMMRegDeleteValue
//
//  See Win32 documentation of RegDeleteValue.
//

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    LPCSTR lpValueName
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            if (IsDynDataKey(hKey) || (hKey-> lpFileInfo-> Flags & FI_READONLY))
                ErrorCode = ERROR_ACCESS_DENIED;
            else {
                RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdkey.c ===
//
//  REGDKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteKey and supporting functions.
//

#include "pch.h"

//
//  RgFreeDatablockStructures
//
//  Helper routine for RgDeleteKey.  Deletes the specified datablock structures.
//  The datablock is not assumed to be locked.  We don't care about the success
//  of this routine-- in the worst case, some stuff will be orphaned in the
//  file.
//

VOID
INTERNAL
RgFreeDatablockStructures(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT KeyRecordIndex
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(lpFileInfo, BlockIndex, (BYTE) KeyRecordIndex,
        &lpKeyRecord) == ERROR_SUCCESS) {
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
        RgFreeKeyRecord(lpDatablockInfo, lpKeyRecord);
        RgFreeKeyRecordIndex(lpDatablockInfo, KeyRecordIndex);
        RgUnlockDatablock(lpFileInfo, BlockIndex, TRUE);
    }

}

//
//  RgDeleteKey
//
//  Worker routine for VMMRegDeleteKey.  The given key handle references a key
//  that has already been validated as "deleteable".
//

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    LPKEYNODE lpKeynode;
    DWORD NextKeynodeIndex;
    LPKEYNODE lpNextKeynode;
    DWORD ReplacementKeynodeIndex;
    HKEY hTempKey;

    lpFileInfo = hKey-> lpFileInfo;

    //
    //  Stage one: unlink the keynode of the specified key from the keynode
    //  tree and free all associate file structures with the key.
    //

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    KeynodeIndex = lpKeynode-> ParentIndex;
    ReplacementKeynodeIndex = lpKeynode-> NextIndex;
    RgUnlockKeynode(lpFileInfo, hKey-> KeynodeIndex, FALSE);

    //  Signal any waiting notifies on the parent that this key is about to be
    //  deleted.
    //
    //  Note that we may fail below, but NT does _exactly_ the same thing in
    //  this case: doesn't care.  If we get an error and don't actually delete
    //  this key, then we'll have sent a spurious notify.
    //
    //  Note also that we don't send any notification that the key itself has
    //  been deleted.  REG_NOTIFY_CHANGE_NAME is supposed to be for subkey
    //  changes only, not changes to the key itself.  But because of the
    //  incompatible way we must deal with subkeys of the key we're about to
    //  delete, we may well end up notifying the key if it has subkeys.
    RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex, REG_NOTIFY_CHANGE_NAME);

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    //  The per-key cache that we use for RegEnumKey may be invalid, so it must
    //  be zapped.
    if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex)))
        hTempKey-> Flags &= ~KEYF_ENUMKEYCACHED;

    NextKeynodeIndex = lpKeynode-> ChildIndex;

    if (NextKeynodeIndex == hKey-> KeynodeIndex) {

        //  Update the cached child keynode index in the open handle on the
        //  parent.
        if (!IsNullPtr(hTempKey))
            hTempKey-> ChildKeynodeIndex = ReplacementKeynodeIndex;

        //  This is the parent of the keynode that we need to delete.  Replace
        //  it's "child" link.
        lpKeynode-> ChildIndex = ReplacementKeynodeIndex;

    }

    else {

        //  Loop through the siblings of the keynode we're trying to delete.
        do {

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            KeynodeIndex = NextKeynodeIndex;

            if (IsNullKeynodeIndex(KeynodeIndex)) {
                DEBUG_OUT(("RgDeleteKey: couldn't find the keynode to delete\n"));
                return ERROR_BADDB;
            }

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            NextKeynodeIndex = lpKeynode-> NextIndex;

        }   while (NextKeynodeIndex != hKey-> KeynodeIndex);

        //  This is the previous sibling of the keynode that we need to delete.
        //  Replace it's "next" link.
        lpKeynode-> NextIndex = ReplacementKeynodeIndex;

    }

    //  Unlock the updated "parent" or "next" of this keynode.
    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    //  Free the structures associated with the datablock.
    RgFreeDatablockStructures(lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex);

    //  Free the structures associated with the keynode tables.
    RgFreeKeynode(lpFileInfo, hKey-> KeynodeIndex);

    //  The key is definitely toast now.
    hKey-> Flags |= KEYF_DELETED;

    //
    //  Stage two: the specified key is unlinked, but any of its subkeys now
    //  have to be freed.  Errors are ignored at this point: we won't try to
    //  undo the stuff we did in stage one.  The worst thing that can happen is
    //  that some file structures are orphaned.
    //

    NextKeynodeIndex = hKey-> ChildKeynodeIndex;

    if (IsNullKeynodeIndex(NextKeynodeIndex) || RgLockInUseKeynode(lpFileInfo,
        NextKeynodeIndex, &lpNextKeynode) != ERROR_SUCCESS)
        return ERROR_SUCCESS;

    while (!IsNullKeynodeIndex(NextKeynodeIndex)) {

        KeynodeIndex = NextKeynodeIndex;
        lpKeynode = lpNextKeynode;

        //  Check if the keynode has any children.  If it does and we can lock
        //  it down, then move to it.
        NextKeynodeIndex = lpKeynode-> ChildIndex;

        if (!IsNullKeynodeIndex(NextKeynodeIndex) &&
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) ==
            ERROR_SUCCESS) {

            ASSERT(KeynodeIndex == lpNextKeynode-> ParentIndex);

            RgYield();

            //  "Burn" the link to our child, so that on the way back out of
            //  the tree, we don't end up recursing.  Plus, if we hit any errors
            //  deep in the tree deletion, the child of the current keynode
            //  could have already been toasted, so we have to zap our link to
            //  it.
            lpKeynode-> ChildIndex = REG_NULL;
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

            //  We've now caused a change in the subkeys of the current key.
            //  Note that we don't bother signaling notifies that are doing a
            //  subtree watch because any such notifies should have already been
            //  signaled by the above call or they've already been signaled
            //  during our recursion.  In the off chance that we have a lot of
            //  notifications registered, this will avoid a lot of unnecessary
            //  checking.
            RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_NO_WATCH_SUBTREE);

            continue;

        }

        //  The keynode doesn't have any children.  Check for sibling keynodes.
        NextKeynodeIndex = lpKeynode-> NextIndex;

        if (IsNullKeynodeIndex(NextKeynodeIndex) ||
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) !=
            ERROR_SUCCESS) {

            //  The keynode doesn't have any siblings or we were unable to get
            //  at them.  Move back to the parent.
            NextKeynodeIndex = lpKeynode-> ParentIndex;

            //  If we wrapped back up to the top of the deleted branch or if we
            //  just can't access the parent keynode, then set next to REG_NULL
            //  and bail out on the next iteration.
            if ((NextKeynodeIndex == hKey-> KeynodeIndex) ||
                RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex,
                &lpNextKeynode) != ERROR_SUCCESS)
                NextKeynodeIndex = REG_NULL;

        }

        //  If an open key refers to this file and keynode index, mark it as
        //  deleted.
        if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo,
            KeynodeIndex)))
            hTempKey-> Flags |= KEYF_DELETED;

        //  Free the structures associated with the datablock.
        RgFreeDatablockStructures(lpFileInfo, lpKeynode-> BlockIndex,
            (BYTE) lpKeynode-> KeyRecordIndex);

        //  Free the structures associated with the keynode tables.
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);
        RgFreeKeynode(lpFileInfo, KeynodeIndex);

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegDeleteKey
//
//  See Win32 documentation for a description of the behavior.
//
//  Although the Win32 documentation states that lpSubKey must be NULL, NT
//  actually allows this to pass through.  Win95 rejected the call, but the only
//  reason we didn't change it then was because we realized too late in the
//  product that it was different.
//

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if (IsNullPtr(lpSubKey))
	{
		if (IsNullPtr(hKey))
			return ERROR_BADKEY;
		else
			return ERROR_INVALID_PARAMETER;
	}

    if ((ErrorCode = VMMRegOpenKey(hKey, lpSubKey, &hSubKey)) != ERROR_SUCCESS)
        return ErrorCode;

        //  Don't allow HKEY_LOCAL_MACHINE or HKEY_USERS to be deleted.
    if (hSubKey == &g_RgLocalMachineKey || hSubKey == &g_RgUsersKey)
	{
		if (*lpSubKey == '\0')
		{
			ErrorCode = ERROR_ACCESS_DENIED;
			goto SkipDelete;
		}
		else if (lpSubKey[0] == '\\' && lpSubKey[1] == '\0')
		{
			ErrorCode = ERROR_CANTOPEN16_FILENOTFOUND32;
			goto SkipDelete;
		}
	}

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {
        if (IsKeyRootOfHive(hSubKey) || (hSubKey-> lpFileInfo-> Flags &
            FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else
            ErrorCode = RgDeleteKey(hSubKey);

        RgUnlockRegistry();

    }

SkipDelete:

    VMMRegCloseKey(hSubKey);

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regdykey.c ===
//
//  REGDYKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateDynKey and supporting functions.
//

#include "pch.h"

#ifdef WANT_DYNKEY_SUPPORT

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegCreateDynKey
//
//  See VMM DDK of _RegCreateDynKey.
//

LONG
REGAPI
VMMRegCreateDynKey(
    LPCSTR lpKeyName,
    LPVOID KeyContext,
    PPROVIDER pProvider,
    PPVALUE pValueList,
    DWORD ValueCount,
    LPHKEY lphKey
    )
{

    LONG ErrorCode;
    HKEY hKey;
    PINTERNAL_PROVIDER pProviderCopy;
    PPVALUE pCurrentValue;

    if (IsBadHugeReadPtr(pProvider, sizeof(REG_PROVIDER)) ||
        (IsNullPtr(pProvider-> pi_R0_1val) &&
        IsNullPtr(pProvider-> pi_R0_allvals)) ||
        IsBadHugeReadPtr(pValueList, sizeof(PVALUE) * ValueCount))
        return ERROR_INVALID_PARAMETER;

    //  The key could currently exist.  Win95 didn't handle this case,
    //  so would we have problems changing this behavior now?
    if ((ErrorCode = RgCreateOrOpenKey(HKEY_DYN_DATA, lpKeyName, &hKey,
        LK_CREATE | LK_CREATEDYNDATA)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        pProviderCopy = RgSmAllocMemory(sizeof(INTERNAL_PROVIDER));

        if (IsNullPtr(pProviderCopy))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            //  ErrorCode = ERROR_SUCCESS;  //  Must be true if we're here...

            hKey-> pProvider = pProviderCopy;

            //  If no "get single" callback was provided, we can just use the
            //  "get atomic" callback.
            if (IsNullPtr(pProvider-> pi_R0_1val))
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_allvals;
            else
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_1val;

            pProviderCopy-> ipi_R0_allvals = pProvider-> pi_R0_allvals;
            pProviderCopy-> ipi_key_context = KeyContext;

            //  No point in keeping a whole DWORD for one bit when we can fit
            //  it inside the main key structure.
            if (pProvider-> pi_flags & PROVIDER_KEEPS_VALUE_LENGTH)
                hKey-> Flags |= KEYF_PROVIDERHASVALUELENGTH;

            //  Loop over all the values and store each name in the registry
            //  with a partial PVALUE record as the value's data.
            for (pCurrentValue = pValueList; ValueCount > 0; ValueCount--,
                pCurrentValue++) {

                if (IsBadStringPtr(pCurrentValue-> pv_valuename, (UINT) -1)) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    break;
                }

                //  Skip storing the pv_valuename field.
                if ((ErrorCode = RgSetValue(hKey, pCurrentValue-> pv_valuename,
                    REG_BINARY, (LPBYTE) &(pCurrentValue-> pv_valuelen),
                    sizeof(PVALUE) - FIELD_OFFSET(PVALUE, pv_valuelen))) !=
                    ERROR_SUCCESS) {
                    TRAP();
                    break;
                }

            }

        }

        RgUnlockRegistry();

    }

    //  Win95 difference: on an error, don't modify lphKey and close the key
    //  created above.
    if (ErrorCode == ERROR_SUCCESS)
        *lphKey = hKey;
    else
        VMMRegCloseKey(hKey);

    return ErrorCode;

}

#endif // WANT_DYNKEY_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regekey.c ===
//
//  REGEKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumKey and supporting functions.
//

#include "pch.h"

//
//  RgLookupKeyByIndex
//
//  lpKeyName, points to a buffer that receives the name of the subkey,
//      including the null terminator.  May be NULL.
//  lpcbKeyName, on entry, specifies the size in characters of the buffer
//      pointed to be lpKeyName, and on return, specifies the size of the
//      indexed subkey.  May not be NULL.
//

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName,
    UINT Flags
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    UINT KeysToSkip;
    DWORD KeynodeIndex;
    DWORD TempOffset;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
#ifdef REALMODE
    BOOL secondTry;
#endif

    lpFileInfo = hKey-> lpFileInfo;
    KeysToSkip = Index;

    //
    //  Check if we've cached the keynode index of the last key index
    //  (confusing?) from a previous call to this function.  If so, then we can
    //  skip ahead a bit and avoid touching a bunch of keynode pages.
    //

    if ((hKey-> Flags & KEYF_ENUMKEYCACHED) &&
        (!(hKey-> Flags & KEYF_ENUMEXTENTCACHED) == !(Flags & LK_BIGKEYEXT)) &&
        (Index >= hKey-> LastEnumKeyIndex)) {
        KeysToSkip -= hKey-> LastEnumKeyIndex;
        KeynodeIndex = hKey-> LastEnumKeyKeynodeIndex;
    }
    else
        KeynodeIndex = hKey-> ChildKeynodeIndex;

    //
    //  Loop over the child keys of this key until we find our index or run out
    //  of children.
    //

    while (!IsNullKeynodeIndex(KeynodeIndex)) {

#ifdef REALMODE
        secondTry = FALSE;
tryAgain:
#endif // REALMODE

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        ASSERT(hKey-> KeynodeIndex == lpKeynode-> ParentIndex);

        if (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT) &&
            KeysToSkip == 0) {

            if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode-> BlockIndex,
                (BYTE) lpKeynode-> KeyRecordIndex, &lpKeyRecord)) ==
                ERROR_SUCCESS) {

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpKeyRecord-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                            NameLength);
                        lpKeyName[lpKeyRecord-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpKeyRecord-> NameLength;

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

            }
#ifdef REALMODE
            else if (!secondTry)
            {
                // What happens in real mode, is that we get wedged with the
                // Keynode block allocated and locked in the middle of the free
                // space, and there is not a free block large enough for the data block.
                // We have already free'd up everything that isn't locked.
                // So, by unlocking and freeing the Keynode block and then restarting
                // the operation, the Keynode block gets allocated at the bottom of the
                // heap, leaving room for the data block.
                secondTry = TRUE;
                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgEnumFileInfos(RgSweepFileInfo);
                RgEnumFileInfos(RgSweepFileInfo);
                goto tryAgain;
            }
#endif // REALMODE

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);

            //  Cache our current position because the caller is likely to turn
            //  around and ask for the next index.
            hKey-> LastEnumKeyIndex = Index;
            hKey-> LastEnumKeyKeynodeIndex = KeynodeIndex;
            hKey-> Flags |= KEYF_ENUMKEYCACHED;
            if (Flags & LK_BIGKEYEXT)
                hKey-> Flags |= KEYF_ENUMEXTENTCACHED;
            else
                hKey-> Flags &= ~KEYF_ENUMEXTENTCACHED;

            return ErrorCode;

        }

        TempOffset = lpKeynode-> NextIndex;
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
        KeynodeIndex = TempOffset;

        if (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT))
        {
            KeysToSkip--;
        }
    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Loop over the hives of this key until we find our index or run out of
    //  hives.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (KeysToSkip == 0) {

                ErrorCode = ERROR_SUCCESS;

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpHiveInfo-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpHiveInfo-> Name, lpHiveInfo->
                            NameLength);
                        lpKeyName[lpHiveInfo-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpHiveInfo-> NameLength;

                //  We don't worry about the enum key cache if we find a
                //  hit in this code.  This is a rare case and already the cache
                //  that we do have is much better then Win95.

                return ErrorCode;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
            KeysToSkip--;

        }

    }
#endif

    return ERROR_NO_MORE_ITEMS;

}

//
//  VMMRegEnumKey
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    LPSTR lpKeyName,
    DWORD cbKeyName
    )
{

    int ErrorCode;

    if (IsBadHugeWritePtr(lpKeyName, cbKeyName))
        return ERROR_INVALID_PARAMETER;

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKeyByIndex(hKey, (UINT) Index, lpKeyName,
            &cbKeyName, 0);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regeval.c ===
//
//  REGEVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumValue and supporting functions.
//

#include "pch.h"


//
//  RgLookupValueByIndex
//  (BIGKEY aware)
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BigKeyLockedBlockIndex
//  It is the callers responsibility to unlock the datablock.  
//
int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT IndexKey;
    LPSTR KeyName;
    DWORD cbKeyName;
    UINT ValueCount;

    ErrorCode = RgLookupValueByIndexStd(hKey, Index, lplpValueRecord, &ValueCount);
    hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
    
    if (ErrorCode == ERROR_NO_MORE_ITEMS && (hKey->Flags & KEYF_BIGKEYROOT)) {

        if (IsNullPtr(KeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;
        
        IndexKey = 0;
        
        while (ErrorCode == ERROR_NO_MORE_ITEMS && Index >= ValueCount)
        {
            Index -= ValueCount;

            cbKeyName = MAXIMUM_SUB_KEY_LENGTH;
            if (RgLookupKeyByIndex(hKey, IndexKey++, KeyName, &cbKeyName, LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_NO_MORE_ITEMS;
                goto lFreeKeyName;
            }

            if (RgLookupKey(hKey, KeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_NO_MORE_ITEMS;
                goto lFreeKeyName;
            }

            hKey-> BigKeyLockedBlockIndex = hKeyExtent-> BlockIndex;
            ErrorCode = RgLookupValueByIndexStd(hKeyExtent, Index, 
                            lplpValueRecord, &ValueCount);

            RgDestroyKeyHandle(hKeyExtent);
        }

lFreeKeyName:
        RgSmFreeMemory(KeyName);
    }

    return ErrorCode;
}


//
//  RgLookupValueByIndexStd
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//
//  This locks the datablock associated with the VALUE_RECORD.
//  This is always hKey->BlockIndex
//  It is the callers responsibility to unlock the datablock.  
//

int
INTERNAL
RgLookupValueByIndexStd(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord,
    UINT FAR* lpValueCount
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    *lpValueCount = 0;
    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_NO_MORE_ITEMS;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
        hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        *lpValueCount = lpKeyRecord-> ValueCount;

        if (Index >= lpKeyRecord-> ValueCount) {
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
            ErrorCode = ERROR_NO_MORE_ITEMS;
        }

        else {

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

            //  Should probably do more sanity checking on lpValueRecord
            while (Index--) {
                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                    Name + lpValueRecord-> NameLength + lpValueRecord->
                    DataLength);
            }

            *lplpValueRecord = lpValueRecord;
            ErrorCode = ERROR_SUCCESS;

        }

    }

    return ErrorCode;

}

//
//  VMMRegEnumValue
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadHugeWritePtr(lpcbValueName, sizeof(DWORD)) ||
        IsBadHugeWritePtr(lpValueName, *lpcbValueName) ||
        (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD))))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
	//  Win95 compatibility: don't validate lpData is of size *lpcbData.
	//  Instead of validating the entire buffer, we'll validate just the
	//  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByIndex(hKey, (UINT) Index, 
            &lpValueRecord)) == ERROR_SUCCESS) {
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, lpValueName,
                lpcbValueName, lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regfinfo.c ===
//
//  REGFINFO.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

LPFILE_INFO g_RgFileInfoList = NULL;

const char g_RgDotBackslashPath[] = ".\\";

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgCreateFileInfoNew
//
//  If CFIN_VOLATILE is specified, then we skip trying to create the backing
//  store for the FILE_INFO.  lpFileName should point at a null byte so we can
//  initialize the FILE_INFO properly.
//
//  CFIN_PRIMARY and CFIN_SECONDARY are used to determine the FHT_* constant
//  to put in the file header.
//

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
        RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  For volatile FILE_INFOs, we obviously don't need to create the backing
    //  store.
    if (!(Flags & CFIN_VOLATILE)) {

        //  Attempt to the create the given filename.
        if ((hFile = RgCreateFile(lpFileName)) == HFILE_ERROR) {
            ErrorCode = ERROR_REGISTRY_IO_FAILED;
            goto ErrorDestroyFileInfo;
        }

        RgCloseFile(hFile);

    }

    lpFileInfo-> Flags = FI_DIRTY | FI_KEYNODEDIRTY;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    if (Flags & CFIN_VOLATILE)
        lpFileInfo-> Flags |= FI_VOLATILE;

    //  Initialize the file header.
    lpFileInfo-> FileHeader.Signature = FH_SIGNATURE;
    //  If we're using compact keynodes, up the version number to make sure
    //  Win95 doesn't try to load this hive.
    if (Flags & CFIN_VERSION20) {
        lpFileInfo-> FileHeader.Version = FH_VERSION20;
        lpFileInfo-> Flags |= FI_VERSION20;
    }
    else {
        lpFileInfo-> FileHeader.Version = FH_VERSION10;
    }
    //  lpFileInfo-> FileHeader.Size = 0;
    //  lpFileInfo-> FileHeader.Checksum = 0;
    //  lpFileInfo-> FileHeader.BlockCount = 0;
    lpFileInfo-> FileHeader.Flags = FHF_DIRTY;
    lpFileInfo-> FileHeader.Type = ((Flags & CFIN_SECONDARY) ? FHT_SECONDARY :
        FHT_PRIMARY);

    //  Initialize the keynode header.
    lpFileInfo-> KeynodeHeader.Signature = KH_SIGNATURE;
    //  lpFileInfo-> KeynodeHeader.FileKnSize = 0;
    lpFileInfo-> KeynodeHeader.RootIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.Flags = KHF_DIRTY | KHF_NEWHASH;
    //  lpFileInfo-> KeynodeHeader.Checksum = 0;

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  For uncompacted keynode tables, the keynode table now includes at least
    //  the header itself.
    if (!(lpFileInfo-> Flags & FI_VERSION20))
        lpFileInfo-> CurTotalKnSize = sizeof(KEYNODE_HEADER);

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, HFILE_ERROR)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Allocate the keynode for the root of the file.
    if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex, &lpKeynode)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    lpFileInfo-> KeynodeHeader.RootIndex = KeynodeIndex;

    lpKeynode-> ParentIndex = REG_NULL;
    lpKeynode-> NextIndex = REG_NULL;
    lpKeynode-> ChildIndex = REG_NULL;
    lpKeynode-> Hash = 0;
    //  Note that we don't allocate a key record for this root keynode.  Win95
    //  didn't do this either, so we already must handle this case in code that
    //  needs a key record.  Our code is smaller if we just don't allocate this
    //  key record which is rarely ever used anyway...
    lpKeynode-> BlockIndex = NULL_BLOCK_INDEX;

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    if ((ErrorCode = RgFlushFileInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

ErrorDeleteFile:
    if (!(Flags & CFIN_VOLATILE))
        RgDeleteFile(lpFileName);

ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

ErrorReturn:
    TRACE(("RgCreateFileInfoNew: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgCreateFileInfoExisting
//

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    DWORD FileAttributes;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
        RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  lpFileInfo-> Flags = 0;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    //  Attempt to the open the given filename.
    if ((hFile = RgOpenFile(lpFileName, OF_READ)) == HFILE_ERROR)
        goto ErrorDestroyFileInfo;

    //  Read and validate the file header.
    if (!RgReadFile(hFile, &lpFileInfo-> FileHeader, sizeof(FILE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> FileHeader.Signature != FH_SIGNATURE ||
        (lpFileInfo-> FileHeader.Version != FH_VERSION10 &&
        lpFileInfo-> FileHeader.Version != FH_VERSION20)) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    lpFileInfo-> FileHeader.Flags &= ~(FHF_DIRTY | FHF_HASCHECKSUM);

    if (lpFileInfo-> FileHeader.Version == FH_VERSION20)
        lpFileInfo-> Flags |= FI_VERSION20;

    //  Read and validate the keynode header.
    if (!RgReadFile(hFile, &lpFileInfo-> KeynodeHeader,
        sizeof(KEYNODE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> KeynodeHeader.Signature != KH_SIGNATURE) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, hFile)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    RgCloseFile(hFile);

    //  Check if the file can be written to.  We did this in Win95 by getting
    //  the current file attributes and then slamming them back on the file.  If
    //  this failed, then we treated the file as read-only (such as hive from
    //  a read-only network share).  This seems to work, so why change?
    if ((FileAttributes = RgGetFileAttributes(lpFileName)) != (DWORD) -1) {
        if (!RgSetFileAttributes(lpFileName, (UINT) FileAttributes))
            lpFileInfo-> Flags |= FI_READONLY;
    }

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

ErrorCloseFile:
    RgCloseFile(hFile);

ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

ErrorReturn:
    TRACE(("RgCreateFileInfoExisting: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgDestroyFileInfo
//
//  Unlinks the FILE_INFO from the global list, if appropriate, and frees all
//  memory associated with the structure including the structure itself.
//
//  If the FILE_INFO is dirty, then all changes will be lost.  Call
//  RgFlushFileInfo first if the file should be flushed.
//

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    LPFILE_INFO lpPrevFileInfo;
    LPFILE_INFO lpCurrFileInfo;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
    LPHIVE_INFO lpTempHiveInfo;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    LPNOTIFY_CHANGE lpNotifyChange;
    LPNOTIFY_CHANGE lpTempNotifyChange;
#endif
    UINT Counter;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(!IsNullPtr(lpFileInfo));

    RgInvalidateKeyHandles(lpFileInfo, (UINT) -1);

    //
    //  Unlink this FILE_INFO from the the file info list.  Note that the
    //  structure may not have actually been linked in if we're called as a
    //  result of an error in one of the create file info functions.
    //

    lpPrevFileInfo = NULL;
    lpCurrFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpCurrFileInfo)) {

        if (lpCurrFileInfo == lpFileInfo) {
            if (IsNullPtr(lpPrevFileInfo))
                g_RgFileInfoList = lpCurrFileInfo-> lpNextFileInfo;
            else
                lpPrevFileInfo-> lpNextFileInfo = lpCurrFileInfo->
                    lpNextFileInfo;
            break;
        }

        lpPrevFileInfo = lpCurrFileInfo;
        lpCurrFileInfo = lpCurrFileInfo-> lpNextFileInfo;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Delete all of the hives connected to this FILE_INFO.
    //

    lpHiveInfo = lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpHiveInfo)) {
        RgDestroyFileInfo(lpHiveInfo-> lpFileInfo);
        lpTempHiveInfo = lpHiveInfo;
        lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
        RgSmFreeMemory(lpTempHiveInfo);
    }
#endif

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    //
    //  Signal and free all of the change notifications.  On NT, a hive cannot
    //  be unloaded if there are any open handles referencing it.  Change
    //  notifications are cleaned up when a key handle is closed.  So this
    //  cleanup is unique to our registry code.
    //

    lpNotifyChange = lpFileInfo-> lpNotifyChangeList;

    while (!IsNullPtr(lpNotifyChange)) {
        RgSetAndReleaseEvent(lpNotifyChange-> hEvent);
        lpTempNotifyChange = lpNotifyChange;
        lpNotifyChange = lpNotifyChange-> lpNextNotifyChange;
        RgSmFreeMemory(lpTempNotifyChange);
    }
#endif

    //
    //  Free all memory associated with the keynode table.
    //

    if (!IsNullPtr(lpFileInfo-> lpKeynodeBlockInfo)) {

        for (Counter = 0, lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;
            Counter < lpFileInfo-> KeynodeBlockCount; Counter++,
            lpKeynodeBlockInfo++) {
            if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock))
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
        }

        RgSmFreeMemory(lpFileInfo-> lpKeynodeBlockInfo);

    }

    //
    //  Free all memory associated with the datablocks.
    //

    if (!IsNullPtr(lpFileInfo-> lpDatablockInfo)) {

        for (Counter = 0, lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
            Counter < lpFileInfo-> FileHeader.BlockCount; Counter++,
            lpDatablockInfo++)
            RgFreeDatablockInfoBuffers(lpDatablockInfo);

        RgSmFreeMemory(lpFileInfo-> lpDatablockInfo);

    }

    //
    //  Free the FILE_INFO itself.
    //

    RgSmFreeMemory(lpFileInfo);

    return ERROR_SUCCESS;

}

#ifdef VXD
#pragma VxD_PAGEABLE_CODE_SEG
#endif

//
//  RgFlushFileInfo
//

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    )
{                                      

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    char TempFileName[MAX_PATH];
    UINT Index;

    ASSERT(!IsNullPtr(lpFileInfo));

    if (!IsPostCriticalInit() || IsFileAccessDisabled())
        return ERROR_SUCCESS;               //  Win95 compatibility.

    if (!(lpFileInfo-> Flags & FI_DIRTY))
        return ERROR_SUCCESS;

    //  If we're currently flushing this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, there's nothing to flush to.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_FLUSHING;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    hSourceFile = HFILE_ERROR;
    hDestinationFile = HFILE_ERROR;

    if (!RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_NONE))
        goto CleanupAfterError;

    //  Datablocks really shouldn't need to set this flag-- instead
    //  do some smart checking to see if we really need to rewrite the whole
    //  bloody thing.
    if (lpFileInfo-> Flags & FI_EXTENDED) {

        if ((Index = StrLen(lpFileInfo-> FileName)) >= MAX_PATH)
            goto CleanupAfterError;

        StrCpy(TempFileName, lpFileInfo-> FileName);

        //  Back up to the last backslash (or the start of the string) and
        //  null-terminate.
        do {
            Index--;
        }   while (Index > 0 && TempFileName[Index] != '\\');

        //  If we found a backslash, then null terminate the string after the
        //  backslash.  Otherwise, we don't have a full qualified pathname, so
        //  make the temporary file in the current directory and pray that's
        //  where the registry file is.
        if (Index != 0)
            TempFileName[Index + 1] = '\0';
        else
            StrCpy(TempFileName, g_RgDotBackslashPath);

        if ((hDestinationFile = RgCreateTempFile(TempFileName)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        if ((hSourceFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        TRACE(("rewriting to TempFileName = \""));
        TRACE((TempFileName));
        TRACE(("\"\n"));

    }

    else {
        if ((hDestinationFile = RgOpenFile(lpFileInfo-> FileName, OF_WRITE)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        // Mark the file is in the process of being updated
        lpFileInfo-> FileHeader.Flags |= FHF_FILEDIRTY | FHF_DIRTY;
    }

    //  Write out the file header.
    if (hSourceFile != HFILE_ERROR || lpFileInfo-> FileHeader.Flags &
        FHF_DIRTY) {

        lpFileInfo-> FileHeader.Flags |= FHF_SUPPORTSDIRTY;

        //  Note that RgWriteDatablocks and RgWriteDatablocksComplete uses this
        //  value, too.
        if (lpFileInfo-> Flags & FI_VERSION20)
            lpFileInfo-> FileHeader.Size = sizeof(VERSION20_HEADER_PAGE) +
                lpFileInfo-> CurTotalKnSize;
        else
            lpFileInfo-> FileHeader.Size = sizeof(FILE_HEADER) +
                lpFileInfo-> CurTotalKnSize;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
            sizeof(FILE_HEADER)))
            goto CleanupAfterError;

            // Commit the change to disk, if we are modifying in place
        if (lpFileInfo-> FileHeader.Flags & FHF_FILEDIRTY)
        {
            if (!RgCommitFile(hDestinationFile))
                goto CleanupAfterError;
        }

    }

    //  Write out the keynode header and table.
    if ((ErrorCode = RgWriteKeynodes(lpFileInfo, hSourceFile,
        hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteKeynodes returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    //  Write out the datablocks.
    if ((ErrorCode = RgWriteDatablocks(lpFileInfo, hSourceFile,
        hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteDatablocks returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    // Ensure that the file is actually written
    if (!RgCommitFile(hDestinationFile))
        goto CleanupAfterError;

    // Mark the file update as complete
    if (lpFileInfo-> FileHeader.Flags & FHF_FILEDIRTY)
    {
        lpFileInfo-> FileHeader.Flags &= ~FHF_FILEDIRTY;

        if (!RgSeekFile(hDestinationFile, 0))
            goto CleanupAfterError;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
            sizeof(FILE_HEADER)))
            goto CleanupAfterError;
    }

    RgCloseFile(hDestinationFile);

    //  If we're extending the file, we now go back and delete the current file
    //  and replace it with our temporary file.
    if (hSourceFile != HFILE_ERROR) {

        RgCloseFile(hSourceFile);

        ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

        if (!RgDeleteFile(lpFileInfo-> FileName))
            goto CleanupAfterFilesClosed;

        if (!RgRenameFile(TempFileName, lpFileInfo-> FileName)) {
            //  If we ever hit this, we're in trouble.  Need to handle it
            //  somehow, though.
            DEBUG_OUT(("RgFlushFileInfo failed to replace backing file\n"));
            goto CleanupAfterFilesClosed;
        }

    }

    //  Go back and tell everyone that the write is complete-- the file has
    //  been successfully written to disk.
    RgWriteDatablocksComplete(lpFileInfo);
    RgWriteKeynodesComplete(lpFileInfo);
    lpFileInfo-> FileHeader.Flags &= ~FHF_DIRTY;
    lpFileInfo-> Flags &= ~(FI_DIRTY | FI_EXTENDED);

    ErrorCode = ERROR_SUCCESS;

CleanupAfterFilesClosed:
    RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN);

    lpFileInfo-> Flags &= ~FI_FLUSHING;

    if (ErrorCode != ERROR_SUCCESS)
        DEBUG_OUT(("RgFlushFileInfo() returning error %d\n", ErrorCode));

    return ErrorCode;

CleanupAfterError:
    if (hSourceFile != HFILE_ERROR)
        RgCloseFile(hSourceFile);

    if (hDestinationFile != HFILE_ERROR) {

        //  If both hSourceFile and hDestinationFile were valid, then we must
        //  have created a temporary file.  Delete it now that we've failed.
        if (hSourceFile != HFILE_ERROR)
            RgDeleteFile(TempFileName);

        RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN);

    }

    goto CleanupAfterFilesClosed;

}

//
//  RgSweepFileInfo
//

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    ASSERT(!IsNullPtr(lpFileInfo));

    //  If we're currently sweeping this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, we can't sweep anything out.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_SWEEPING;

    RgSweepKeynodes(lpFileInfo);
    RgSweepDatablocks(lpFileInfo);

    lpFileInfo-> Flags &= ~FI_SWEEPING;

    return ERROR_SUCCESS;

}

//
//  RgEnumFileInfos
//
//  Enumerates over all FILE_INFO structures, passing each to the provided
//  callback.  Currently, all errors from callbacks are ignored.
//

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    )
{

    LPFILE_INFO lpFileInfo;
    LPFILE_INFO lpTempFileInfo;

    lpFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpFileInfo)) {
        lpTempFileInfo = lpFileInfo;
        lpFileInfo = lpFileInfo-> lpNextFileInfo;
        (*lpEnumFileInfoProc)(lpTempFileInfo);
    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitRootKeyFromFileInfo
//
//  Using the FILE_INFO contained in the key, initialize the rest of the members
//  of the key.  If any errors occur, then the FILE_INFO is destroyed.
//

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    hKey-> KeynodeIndex = hKey-> lpFileInfo-> KeynodeHeader.RootIndex;

    if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) == ERROR_SUCCESS) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED | KEYF_ENUMKEYCACHED);
        hKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
        hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
        hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);

    }

    else
        RgDestroyFileInfo(hKey-> lpFileInfo);

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToFile
//

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    LPCSTR lpFileName,
    UINT Flags
    )
{

    int ErrorCode;
#ifdef WIN32
    char FullPathName[MAX_PATH];
#endif
    UINT CreateNewFlags;

    if (hKey != HKEY_LOCAL_MACHINE && hKey != HKEY_USERS
#ifndef VXD
        && hKey != HKEY_CURRENT_USER
#endif
        )
        return ERROR_INVALID_PARAMETER;

    if (IsBadOptionalStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    RgValidateAndConvertKeyHandle(&hKey);

    if (!(hKey-> Flags & KEYF_INVALID))
        RgDestroyFileInfo(hKey-> lpFileInfo);

    //  Specifying NULL "unmaps" the key and leaves it invalidated.
    if (IsNullPtr(lpFileName))
        return ERROR_SUCCESS;

#ifdef WIN32
    //  For users of the Win32 DLL, resolve the path name so they don't have to.
    if ((GetFullPathName(lpFileName, sizeof(FullPathName), FullPathName,
        NULL)) != 0)
        lpFileName = FullPathName;
#endif

    if (Flags & MPKF_CREATENEW) {
        CreateNewFlags = CFIN_PRIMARY | ((Flags & MPKF_VERSION20) ?
            CFIN_VERSION20 : 0);
        ErrorCode = RgCreateFileInfoNew(&hKey-> lpFileInfo, lpFileName,
            CreateNewFlags);
    }

    else {
        ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo, lpFileName);
    }

    if (ErrorCode == ERROR_SUCCESS)
        ErrorCode = RgInitRootKeyFromFileInfo(hKey);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regffmt.h ===
//
//  REGFFMT.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Defines the physical format of a Windows VMM registry file.
//

#ifndef _REGFFMT_
#define _REGFFMT_

#ifdef WIN32
#include <pshpack1.h>
#else
#pragma pack(1)
#endif

#define REG_NULL                    0xFFFFFFFF

typedef struct _FILE_HEADER {
    DWORD Signature;                            //  FH_SIGNATURE
    DWORD Version;                              //  FH_VERSION_*
    DWORD Size;                                 //  of file header, all keynodes
    DWORD Checksum;                             //  of file header
    WORD BlockCount;
    DWORD Flags;                                //  FHF_* bits
    WORD Type;                                  //  FHT_* constant
    BYTE Reserved[8];
}   FILE_HEADER, UNALIGNED FAR* LPFILE_HEADER;

#define FH_SIGNATURE                0x47455243  //  "CREG"
#define FH_VERSION10                0x00010000  //  Win95 compatible
#define FH_VERSION20                0x00020000  //  Supports compact keynodes (never used)

#define FHF_DIRTY                   0x00000001  //  Must rewrite to disk
#define FHF_RESERVED1               0x00000002  //  Dead bit from VERY old files
#define FHF_HASCHECKSUM             0x00000004  //  Checksum member is valid
#define FHF_FILEDIRTY               0x00000008  //  File is in the process of being updated (checked by win.com)
#define FHF_CORRUPT                 0x00000010  //  File is corrupt (detected by scanregw.exe)
#define FHF_SUPPORTSDIRTY           0x00000020  //  The registry supports FHF_CORRUPT and FHF_FILEDIRTY
#define FHF_BOOTFAILED              0x00000040  //  Failed to boot and verify the integrity of the registry

#define FHT_PRIMARY                 0x0001      //  System hives
#define FHT_SECONDARY               0x0080      //  User/application hives

typedef struct _KEYNODE_HEADER {
    DWORD Signature;                            //  KH_SIGNATURE
    DWORD FileKnSize;				//  of entire keynode table inc header
    DWORD RootIndex;				// Index into keynode array of the root key node
    DWORD FirstFreeIndex;			// Index into keynode array of the root of the key node free list
    DWORD Flags;                                //  KHF_* bits
    DWORD Checksum;                             //  of entire keynode table
    BYTE Reserved[8];
}   KEYNODE_HEADER, UNALIGNED FAR* LPKEYNODE_HEADER;

#define KH_SIGNATURE                0x4E4B4752  //  "RGKN"

#define KHF_DIRTY                   0x00000001  //  Win95: Must rewrite to disk
#define KHF_EXTENDED                0x00000002  //  Win95: Table has grown
#define KHF_HASCHECKSUM             0x00000004  //  Win95: Checksum is valid
#define KHF_NEWHASH                 0x00000008  //  Always expect

typedef struct _VERSION20_HEADER_PAGE {
    union {
        struct {
            FILE_HEADER FileHeader;
            KEYNODE_HEADER KeynodeHeader;
        };
        struct {
            BYTE Page[4096];
        };
    };
}   VERSION20_HEADER_PAGE, UNALIGNED FAR* LPVERSION20_HEADER_PAGE;

typedef struct _W95KEYNODE {
    DWORD W95State;				//  KNS_* constant
    union {
        //  State == KNS_USED or KNS_BIGUSED
        struct {
	    DWORD W95Hash;
	    DWORD W95Reserved1;
	    DWORD W95ParentOffset;              // offset from start of keynode header
	    DWORD W95ChildOffset;               // offset from start of keynode header
	    DWORD W95NextOffset;                // offset from start of keynode header
	    DWORD W95DatablockAddress;          // HIWORD: block #, LOWORD: Index in block
        };
        //  State == KNS_FREE or KNS_ALLFREE
        struct {
	    DWORD W95FreeRecordSize;
	    DWORD W95NextFreeOffset;
	    DWORD W95Reserved2[4];
        };
    };
}   W95KEYNODE, UNALIGNED FAR* LPW95KEYNODE;

#define KNS_USED                    0x00000000UL  //  Normal Keynode
#define KNS_BIGUSED                 0x00000001UL  //  Big key node root
#define KNS_BIGUSEDEXT              0x00000002UL  //  Big key node extension
#define KNS_FREE                    0x80000000UL
#define KNS_ALLFREE                 0xFFFFFFFFUL

typedef struct _KEYNODE {
    DWORD NextIndex:24,
          Flags:8;
    union {
        //  Flags & KNF_INUSE
	struct {
	    DWORD ChildIndex:24,
		  BinNumber:8;
	    DWORD ParentIndex:24,
                  KeyRecordIndex:8;
            WORD  BlockIndex;
	    WORD  Hash;
        };
        //  !(Flags & KNF_INUSE)
	struct {
            DWORD Reserved;
            DWORD FreeRecordSize;
        };
    };
}   KEYNODE, FAR* LPKEYNODE;

#define KNF_INUSE           0x01        // Block is in use
#define KNF_BIGKEYROOT      0x02        // Keynode represents a big key root
#define KNF_BIGKEYEXT       0x04        // Keynode represents a big key extension

#define IsNullKeynodeIndex(kni)     ((kni) >= 0x00FFFFFF)

typedef struct _DATABLOCK_HEADER {
    DWORD Signature;                            //  DH_SIGNATURE
    DWORD BlockSize;                            //  size of block including header
    DWORD FreeBytes;                            //  total of free bytes in block
    WORD Flags;                                 //  DHF_* bits
    WORD BlockIndex;
    DWORD FirstFreeOffset;                      //  offset of first free record from start of data block header
    WORD MaxAllocatedIndex;                     //  maximum index already allocated in the block
    WORD FirstFreeIndex;                        //  first available index in the block
    DWORD Reserved;
    DWORD Checksum;                             //  of entire datablock
}   DATABLOCK_HEADER, UNALIGNED FAR* LPDATABLOCK_HEADER;

#define DH_SIGNATURE                0x42444752  //  "RGDB"

#define DHF_DIRTY                   0x0001      //  Must rewrite to disk
#define DHF_EXTENDED                0x0002      //  Datablock size has grown
#define DHF_HASCHECKSUM             0x0004      //  Checksum member is valid
#define DHF_HASBLOCKNUMBERS         0x0008      //  Keys contain block numbers

#define DATABLOCKS_PER_FILE         0xFFFE      //  0xFFFF is 'null' block index

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_DATABLOCK_SIZE      ((DWORD)(60L*1024L))

//  Win95 registry files may not always have a key record for the root key of
//  a file.
#define NULL_BLOCK_INDEX            0xFFFF
#define IsNullBlockIndex(bi)        ((bi) == NULL_BLOCK_INDEX)

typedef struct _KEY_RECORD {
    DWORD AllocatedSize;            // bytes allocated for the record
    union {
        DWORD DatablockAddress;     // corresponds to W95KEYNODE.W95DatablockAddress
        struct {
            WORD KeyRecordIndex;    // index into the data block for this key
            WORD BlockIndex;        // data block index that this key resides in
        };
    };
    DWORD RecordSize;               // bytes used in the record
    WORD NameLength;
    WORD ValueCount;                // Count of value name records
    WORD ClassLength;
    WORD Reserved;
    char Name[ANYSIZE_ARRAY];
}   KEY_RECORD, UNALIGNED FAR* LPKEY_RECORD;

typedef struct _FREEKEY_RECORD {
    DWORD AllocatedSize;
    DWORD DatablockAddress;                     //  REG_NULL for free records
    DWORD NextFreeOffset;
}   FREEKEY_RECORD, UNALIGNED FAR* LPFREEKEY_RECORD;

typedef struct _VALUE_RECORD {
    DWORD DataType;
    DWORD Reserved;
    WORD NameLength;
    WORD DataLength;
    char Name[ANYSIZE_ARRAY];
}   VALUE_RECORD, UNALIGNED FAR* LPVALUE_RECORD;

#define KEY_RECORDS_PER_DATABLOCK   255

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_KEY_RECORD_SIZE     \
    ((DWORD)(MAXIMUM_DATABLOCK_SIZE-sizeof(DATABLOCK_HEADER)))

#ifdef WIN32
#include <poppack.h>
#else
#pragma pack()
#endif

#endif // _REGFFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regfsio.h ===
//
//  REGFSIO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Prototypes for file system I/O.  Many of these prototypes may not be used
//  if a direct mapping is available in the target environment.
//

#ifndef _REGFSIO_
#define _REGFSIO_

//  Consistent with both 16-bit and 32-bit windows.h.
#ifndef HFILE_ERROR
typedef int HFILE;
#define HFILE_ERROR     ((HFILE)-1)
#endif

//  Special value used for the VMM version when we haven't fully initialized yet
//  but are reading SYSTEM.DAT from the XMS cache.
#define HFILE_MEMORY    ((HFILE)-2)

#ifndef RgCreateFile
HFILE
INTERNAL
RgCreateFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgOpenFile
HFILE
INTERNAL
RgOpenFile(
    LPCSTR lpFileName,
    int Mode
    );
#endif

#ifndef RgCreateTempFile
HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    );
#endif

#ifndef RgReadFile
BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgWriteFile
BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgSeekFile
BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    );
#endif

#ifndef RgCommitFile
BOOL
INTERNAL
RgCommitFile(
    HFILE hFile
    );
#endif


#ifndef RgCloseFile
VOID
INTERNAL
RgCloseFile(
    HFILE hFile
    );
#endif

#ifndef RgDeleteFile
BOOL
INTERNAL
RgDeleteFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgRenameFile
BOOL
INTERNAL
RgRenameFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
#endif

#define FILE_ATTRIBUTE_NONE             0

#ifndef RgGetFileAttributes
DWORD
INTERNAL
RgGetFileAttributes(
    LPCSTR lpFileName
    );
#endif

#ifndef RgSetFileAttributes
BOOL
INTERNAL
RgSetFileAttributes(
    LPCSTR lpFileName,
    UINT FileAttributes
    );
#endif

#ifndef RgGetFileSize
DWORD
INTERNAL
RgGetFileSize(
    HFILE hFile
    );
#endif

#endif // _REGFSIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regfinfo.h ===
//
//  REGFINFO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGFINFO_
#define _REGFINFO_

#define PAGESHIFT                   12
#define PAGESIZE                    (1 << PAGESHIFT)
#define PAGEMASK                    (PAGESIZE - 1)

#define KEYNODE_BLOCK_SHIFT	    10
#define KEYNODES_PER_BLOCK	    (1 << KEYNODE_BLOCK_SHIFT)
#define KEYNODE_BLOCK_MASK	    (KEYNODES_PER_BLOCK-1)
#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

#define KN_INDEX_IN_BLOCK(i)        ((i) & KEYNODE_BLOCK_MASK)
#define KN_BLOCK_NUMBER(i)          ((UINT) ((i) >> KEYNODE_BLOCK_SHIFT))

typedef struct _KEYNODE_BLOCK {
    KEYNODE	aKN[KEYNODES_PER_BLOCK];
} KEYNODE_BLOCK, FAR* LPKEYNODE_BLOCK;

#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

typedef struct _W95KEYNODE_BLOCK {
    W95KEYNODE	aW95KN[KEYNODES_PER_BLOCK];
} W95KEYNODE_BLOCK, FAR* LPW95KEYNODE_BLOCK;

typedef struct _KEYNODE_BLOCK_INFO {
    LPKEYNODE_BLOCK lpKeynodeBlock;
    BYTE Flags;                                 // KBDF_* bits
    BYTE LockCount;
}   KEYNODE_BLOCK_INFO, FAR* LPKEYNODE_BLOCK_INFO;

#define KBIF_ACCESSED               0x01        //  Recently accessed
#define KBIF_DIRTY                  0x02        //  Must rewrite to disk

//  Number of extra KEYNODE_BLOCK_INFO structures to alloc on top of the block
//  count already in the file.  Reduces heap fragmentation in real-mode.
#define KEYNODE_BLOCK_INFO_SLACK_ALLOC 4

#ifdef WIN32
typedef UINT KEY_RECORD_TABLE_ENTRY;
#else
typedef WORD KEY_RECORD_TABLE_ENTRY;
#endif
typedef KEY_RECORD_TABLE_ENTRY FAR* LPKEY_RECORD_TABLE_ENTRY;

#define NULL_KEY_RECORD_TABLE_ENTRY     ((KEY_RECORD_TABLE_ENTRY) 0)
#define IsNullKeyRecordTableEntry(kri)  ((kri) == NULL_KEY_RECORD_TABLE_ENTRY)

typedef struct _DATABLOCK_INFO {
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTable;
    UINT BlockSize;                             //  cached from datablock header
    UINT FreeBytes;                             //  cached from datablock header
    UINT FirstFreeIndex;                        //  cached from datablock header
    LONG FileOffset;
    BYTE Flags;                                 //  DIF_* bits
    BYTE LockCount;
}   DATABLOCK_INFO, FAR* LPDATABLOCK_INFO;

#define DIF_PRESENT                 0x01        //  In memory
#define DIF_ACCESSED                0x02        //  Recently accessed
#define DIF_DIRTY                   0x04        //  Must rewrite to disk
#define DIF_EXTENDED                0x08        //  Has grown in size

//  Number of extra DATABLOCK_INFO structures to alloc on top of the block count
//  already in the file.  Reduces heap fragmentation in real-mode.
#define DATABLOCK_INFO_SLACK_ALLOC  4

//  When we create or extend a datablock, try to keep it on page boundaries.
#define DATABLOCK_GRANULARITY       4096
#define RgAlignBlockSize(size) \
    (((size) + (DATABLOCK_GRANULARITY - 1)) & ~(DATABLOCK_GRANULARITY - 1))

typedef struct _FILE_INFO {
    struct _FILE_INFO FAR* lpNextFileInfo;
#ifdef WANT_HIVE_SUPPORT
    struct _HIVE_INFO FAR* lpHiveInfoList;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
#ifdef WANT_HIVE_SUPPORT
    struct _FILE_INFO FAR* lpParentFileInfo;
#endif
    struct _NOTIFY_CHANGE FAR* lpNotifyChangeList;
#endif
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockCount;
    UINT KeynodeBlockInfoAllocCount;
    DWORD CurTotalKnSize;           // Normally = to FileKnSize unless grown
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT DatablockInfoAllocCount;
    FILE_HEADER FileHeader;
    KEYNODE_HEADER KeynodeHeader;
    WORD Flags;                                 //  FI_* bits
    char FileName[ANYSIZE_ARRAY];
}   FILE_INFO, FAR* LPFILE_INFO;

#define FI_DIRTY                    0x0001      //  Must rewrite to disk
#define FI_KEYNODEDIRTY             0x0002      //
#define FI_EXTENDED                 0x0004      //
#define FI_VERSION20                0x0008      //
#define FI_FLUSHING                 0x0010      //  Currently flushing file
#define FI_SWEEPING                 0x0020      //  Currently sweeping file
#define FI_VOLATILE                 0x0040      //  File has no backing store
#define FI_READONLY                 0x0080      //  File cannot be modified
#define FI_REPLACEMENTEXISTS        0x0100      //  RegReplaceKey called on file

typedef struct _HIVE_INFO {
    struct _HIVE_INFO FAR* lpNextHiveInfo;
    LPFILE_INFO lpFileInfo;
    UINT NameLength;
    BYTE Hash;
    char Name[ANYSIZE_ARRAY];
}   HIVE_INFO, FAR* LPHIVE_INFO;

#define CFIN_PRIMARY                0x0000      //  FHT_PRIMARY header type
#define CFIN_SECONDARY              0x0001      //  FHT_SECONDARY header type
#define CFIN_VOLATILE               0x0002      //  File has no backing store
#define CFIN_VERSION20              0x0004      //  Use compact keynode form

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    );

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    );

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    );

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    );

typedef int (INTERNAL* LPENUMFILEINFOPROC)(LPFILE_INFO);

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    );

#define RgIndexKeynodeBlockInfoPtr(lpfi, index) \
    ((LPKEYNODE_BLOCK_INFO) (&(lpfi)-> lpKeynodeBlockInfo[index]))

#define RgIndexDatablockInfoPtr(lpfi, index) \
    ((LPDATABLOCK_INFO) (&(lpfi)-> lpDatablockInfo[index]))

#define RgIndexKeyRecordPtr(lpdi, index) \
    ((LPKEY_RECORD) ((LPBYTE)(lpdi)-> lpDatablockHeader + (lpdi)-> lpKeyRecordTable[(index)]))

BOOL
INTERNAL
RgIsValidFileHeader(
    LPFILE_HEADER lpFileHeader
    );

BOOL
INTERNAL
RgIsValidKeynodeHeader(
    LPKEYNODE_HEADER lpKeynodeHeader
    );

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    );

extern LPFILE_INFO g_RgFileInfoList;

#endif // _REGFINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\reghive.c ===
//
//  REGHIVE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey and
//  supporting functions.
//

#include "pch.h"

#ifdef WANT_HIVE_SUPPORT

//  Maximum number of times we'll allow RgCopyBranch to be reentered.
#define MAXIMUM_COPY_RECURSION          32

LPSTR g_RgNameBufferPtr;                //  Temporary buffer for RgCopyBranch
LPBYTE g_RgDataBufferPtr;               //  Temporary buffer for RgCopyBranch
UINT g_RgRecursionCount;                //  Tracks depth of RgCopyBranch

#if MAXIMUM_VALUE_NAME_LENGTH > MAXIMUM_SUB_KEY_LENGTH
#error Code assumes a value name can fit in a subkey buffer.
#endif

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgValidateHiveSubKey
//
//  Note that unlike most parameter validation routines, this routine must be
//  called with the registry lock taken because we call RgGetNextSubSubKey.
//
//  Pass back the length of the subkey to deal with the trailing backslash
//  problem.
//
//  Returns TRUE if lpSubKey is a valid subkey string for hive functions.
//

BOOL
INTERNAL
RgValidateHiveSubKey(
    LPCSTR lpSubKey,
    UINT FAR* lpHiveKeyLength
    )
{

    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;

    //  Verify that we have a valid subkey that has one and only one sub-subkey.
    //  in Win95 it was possible to load a hive with a keyname
    //  containing a backslash!
    return !IsNullPtr(lpSubKey) && !RgIsBadSubKey(lpSubKey) &&
        (RgGetNextSubSubKey(lpSubKey, &lpSubSubKey, lpHiveKeyLength) > 0) &&
        (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength) == 0);

}

//
//  VMMRegLoadKey
//
//  See Win32 documentation of RegLoadKey.
//

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    UINT SubKeyLength;
    LPHIVE_INFO lpHiveInfo;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength)) {
        ErrorCode = ERROR_BADKEY;
        goto ReturnErrorCode;
    }

    //  Check if a subkey with the specified name already exists.
    if (RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN) == ERROR_SUCCESS) {
        RgDestroyKeyHandle(hSubKey);
        ErrorCode = ERROR_BADKEY;       //  Win95 compatibility
        goto ReturnErrorCode;
    }

    if (IsNullPtr((lpHiveInfo = (LPHIVE_INFO)
        RgSmAllocMemory(sizeof(HIVE_INFO) + SubKeyLength)))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ReturnErrorCode;
    }

    //  Fill in the HIVE_INFO.
    StrCpy(lpHiveInfo-> Name, lpSubKey);
    lpHiveInfo-> NameLength = SubKeyLength;
    lpHiveInfo-> Hash = (BYTE) RgHashString(lpSubKey, SubKeyLength);

    //  Attempt to create a FILE_INFO for the specified file.  If successful,
    //  link this HIVE_INFO into the parent FILE_INFO's hive list.
    if ((ErrorCode = RgCreateFileInfoExisting(&lpHiveInfo-> lpFileInfo,
        lpFileName)) == ERROR_SUCCESS) {

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        lpHiveInfo-> lpFileInfo-> lpParentFileInfo = hKey-> lpFileInfo;
#endif
        lpHiveInfo-> lpNextHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;
        hKey-> lpFileInfo-> lpHiveInfoList = lpHiveInfo;

        //  Signal any notifications waiting on this top-level key.
        RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);

    }

    else
        RgFreeMemory(lpHiveInfo);

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  VMMRegUnLoadKey
//
//  See Win32 documentation of RegUnLoadKey.
//

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    int ErrorCode;
    UINT SubKeyLength;
    LPFILE_INFO lpFileInfo;
    LPHIVE_INFO lpPrevHiveInfo;
    LPHIVE_INFO lpCurrHiveInfo;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    ErrorCode = ERROR_BADKEY;               //  Assume this error code

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength))
        goto ReturnErrorCode;

    lpPrevHiveInfo = NULL;
    lpCurrHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpCurrHiveInfo)) {

        if (SubKeyLength == lpCurrHiveInfo-> NameLength && RgStrCmpNI(lpSubKey,
            lpCurrHiveInfo-> Name, SubKeyLength) == 0) {

            //  Unlink this HIVE_INFO structure.
            if (IsNullPtr(lpPrevHiveInfo))
                hKey-> lpFileInfo-> lpHiveInfoList = lpCurrHiveInfo->
                    lpNextHiveInfo;
            else
                lpPrevHiveInfo-> lpNextHiveInfo = lpCurrHiveInfo->
                    lpNextHiveInfo;

            //  Flush and destroy it's associated FILE_INFO structure.  When we
            //  destroy the FILE_INFO, all open keys in this hive will be
            //  invalidated.
            lpFileInfo = lpCurrHiveInfo-> lpFileInfo;
            RgFlushFileInfo(lpFileInfo);
            RgDestroyFileInfo(lpFileInfo);

            //  Free the HIVE_INFO itself.
            RgSmFreeMemory(lpCurrHiveInfo);

            //  Signal any notifications waiting on this top-level key.
            RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME);

            ErrorCode = ERROR_SUCCESS;
            break;

        }

        lpPrevHiveInfo = lpCurrHiveInfo;
        lpCurrHiveInfo = lpCurrHiveInfo-> lpNextHiveInfo;

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  RgCopyBranchHelper
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  For Win95 compatibility, we don't stop the copy process if we encounter an
//  error.  (But unlike Win95, we do actually check more error codes)
//
//  SHOULD ONLY BE CALLED BY RgCopyBranch.
//

VOID
INTERNAL
RgCopyBranchHelper(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    UINT Index;
    DWORD cbNameBuffer;
    LPVALUE_RECORD lpValueRecord;

    //
    //  Copy all of the values from the source key to the destination key.
    //

    Index = 0;

    while (RgLookupValueByIndex(hSourceKey, Index++, &lpValueRecord) ==
        ERROR_SUCCESS) {

        DWORD cbDataBuffer;
        DWORD Type;

        cbNameBuffer = MAXIMUM_VALUE_NAME_LENGTH;
        cbDataBuffer = MAXIMUM_DATA_LENGTH + 1;         //  Terminating null

        if (RgCopyFromValueRecord(hSourceKey, lpValueRecord, g_RgNameBufferPtr,
            &cbNameBuffer, &Type, g_RgDataBufferPtr, &cbDataBuffer) ==
            ERROR_SUCCESS) {
            //  Subtract the terminating null that RgCopyFromValueRecord added
            //  to cbDataBuffer.  We don't save that in the file.
            if (Type == REG_SZ) {
                ASSERT(cbDataBuffer > 0);               //  Must have the null!
                cbDataBuffer--;
            }
            RgSetValue(hDestinationKey, g_RgNameBufferPtr, Type,
                g_RgDataBufferPtr, cbDataBuffer);
        }

        RgUnlockDatablock(hSourceKey-> lpFileInfo, hSourceKey-> BigKeyLockedBlockIndex,
            FALSE);

    }

    //  We can't recurse forever, so enforce a maximum depth like Win95.
    if (g_RgRecursionCount > MAXIMUM_COPY_RECURSION)
        return;

    g_RgRecursionCount++;

    //
    //  Copy all of the subkeys from the source key to the destination key.
    //

    Index = 0;

    while (TRUE) {

        HKEY hSubSourceKey;
        HKEY hSubDestinationKey;

        cbNameBuffer = MAXIMUM_SUB_KEY_LENGTH;

        if (RgLookupKeyByIndex(hSourceKey, Index++, g_RgNameBufferPtr,
            &cbNameBuffer,0 ) != ERROR_SUCCESS)
            break;

        if (RgLookupKey(hSourceKey, g_RgNameBufferPtr, &hSubSourceKey,
            LK_OPEN) == ERROR_SUCCESS) {

            if (RgLookupKey(hDestinationKey, g_RgNameBufferPtr,
                &hSubDestinationKey, LK_CREATE) == ERROR_SUCCESS) {
                RgYield();
                RgCopyBranchHelper(hSubSourceKey, hSubDestinationKey);
                RgDestroyKeyHandle(hSubDestinationKey);
            }

            else
                TRAP();

            RgDestroyKeyHandle(hSubSourceKey);

        }

        else
            TRAP();

    }

    g_RgRecursionCount--;

}

//
//  RgCopyBranch
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  This function sets and cleans up for RgCopyBranchHelper who does all
//  the real copying.
//
//  The backing store of the destination file is flushed if successful.
//

int
INTERNAL
RgCopyBranch(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    int ErrorCode;

    if (IsNullPtr(g_RgNameBufferPtr = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        if (IsNullPtr(g_RgDataBufferPtr = RgSmAllocMemory(MAXIMUM_DATA_LENGTH +
            1)))                                        //  + terminating null
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            g_RgRecursionCount = 0;
            RgCopyBranchHelper(hSourceKey, hDestinationKey);

            //  Everything should be copied over, so flush the file now since
            //  all callers will be immediately destroying this FILE_INFO
            //  anyways.
            ErrorCode = RgFlushFileInfo(hDestinationKey-> lpFileInfo);

        }

        RgSmFreeMemory(g_RgNameBufferPtr);

    }

    RgSmFreeMemory(g_RgDataBufferPtr);

    return ErrorCode;

}

//
//  RgSaveKey
//
//  Worker routine for VMMRegSaveKey and VMMRegReplaceKey.  Saves all the keys
//  and values starting at hKey, which must point at a valid KEY structure, to
//  the location specified by lpFileName.  The file must not currently exist.
//

int
INTERNAL
RgSaveKey(
    HKEY hKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hHiveKey;

    if (IsNullPtr(hHiveKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so the below destroy will work.
        RgIncrementKeyReferenceCount(hHiveKey);

        if ((ErrorCode = RgCreateFileInfoNew(&hHiveKey-> lpFileInfo, lpFileName,
            CFIN_SECONDARY)) == ERROR_SUCCESS) {

            if (((ErrorCode = RgInitRootKeyFromFileInfo(hHiveKey)) != ERROR_SUCCESS) ||
                ((ErrorCode = RgCopyBranch(hKey, hHiveKey)) != ERROR_SUCCESS)) {
                RgSetFileAttributes(hHiveKey-> lpFileInfo-> FileName,
                    FILE_ATTRIBUTE_NONE);
                RgDeleteFile(hHiveKey-> lpFileInfo-> FileName);
            }

            //  If successful, then RgCopyBranch has already flushed the file.
            RgDestroyFileInfo(hHiveKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hHiveKey);

    }

    return ErrorCode;

}

//
//  VMMRegSaveKey
//
//  See Win32 documentation of RegSaveKey.
//

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    LPCSTR lpFileName,
    LPVOID lpSecurityAttributes
    )
{

    int ErrorCode;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgSaveKey(hKey, lpFileName);

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpSecurityAttributes);

}

#ifdef WANT_REGREPLACEKEY

//
//  RgGetKeyName
//

LPSTR
INTERNAL
RgGetKeyName(
    HKEY hKey
    )
{

    LPSTR lpKeyName;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex, &lpKeyRecord) != ERROR_SUCCESS)
        lpKeyName = NULL;

    else {

        //  A registry is corrupt if we ever hit this.  We'll continue to
        //  allocate a buffer and let downstream code fail when we try to use
        //  the string.
        ASSERT(lpKeyRecord-> NameLength < MAXIMUM_SUB_KEY_LENGTH);

        if (!IsNullPtr(lpKeyName = (LPSTR) RgSmAllocMemory(lpKeyRecord->
            NameLength + 1))) {                         //  + terminating null
            MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                NameLength);
            lpKeyName[lpKeyRecord-> NameLength] = '\0';
        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

    }

    return lpKeyName;

}

//
//  RgCreateRootKeyForFile
//
//  Creates a KEY and a FILE_INFO to access the specified file.
//

int
INTERNAL
RgCreateRootKeyForFile(
    LPHKEY lphKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hKey;

    if (IsNullPtr(hKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so RgDestroyKeyHandle will work.
        RgIncrementKeyReferenceCount(hKey);

        if ((ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo,
            lpFileName)) == ERROR_SUCCESS) {

            if ((ErrorCode = RgInitRootKeyFromFileInfo(hKey)) ==
                ERROR_SUCCESS) {
                *lphKey = hKey;
                return ERROR_SUCCESS;
            }

            RgDestroyFileInfo(hKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hKey);

    }

    return ErrorCode;

}

//
//  RgDestroyRootKeyForFile
//
//  Destroys the resources allocated by RgCreateRootKeyForFile.
//

VOID
INTERNAL
RgDestroyRootKeyForFile(
    HKEY hKey
    )
{

    RgDestroyFileInfo(hKey-> lpFileInfo);
    RgDestroyKeyHandle(hKey);

}

//
//  RgDeleteHiveFile
//
//  Deletes the specified hive file after clearing its file attributes.
//

BOOL
INTERNAL
RgDeleteHiveFile(
    LPCSTR lpFileName
    )
{

    RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE);
    //  RgSetFileAttributes may fail, but try to delete the file anyway.
    return RgDeleteFile(lpFileName);

}

//
//  VMMRegReplaceKey
//
//  See Win32 documentation of RegReplaceKey.
//

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFileName,
    LPCSTR lpOldFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;
    HKEY hParentKey;
    char ReplaceFileName[MAX_PATH];
    BOOL fCreatedReplaceFile;
    HKEY hReplaceKey;
    HKEY hNewKey;
    HKEY hReplaceSubKey;
    LPSTR lpReplaceSubKey;

    if (IsBadOptionalStringPtr(lpSubKey, (UINT) -1) ||
        IsBadStringPtr(lpNewFileName, (UINT) -1) ||
        IsBadStringPtr(lpOldFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ErrorReturn;

    if ((ErrorCode = RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) !=
        ERROR_SUCCESS)
        goto ErrorReturn;

    //
    //  The provided key handle must an immediate child from the same backing
    //  store (not a hive) as either HKEY_LOCAL_MACHINE or HKEY_USERS.
    //

    if (RgLockInUseKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex,
        &lpKeynode) != ERROR_SUCCESS) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorDestroySubKey;
    }

    KeynodeIndex = lpKeynode-> ParentIndex;
    RgUnlockKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex, FALSE);

    //  Find an open key on the parent check if it's HKEY_LOCAL_MACHINE or
    //  HKEY_USERS.  If not, bail out.  KeynodeIndex may be REG_NULL, but
    //  RgFindOpenKeyHandle handles that case.
    if (IsNullPtr(hParentKey = RgFindOpenKeyHandle(hSubKey-> lpFileInfo,
        KeynodeIndex)) || ((hParentKey != &g_RgLocalMachineKey) &&
        (hParentKey != &g_RgUsersKey))) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto ErrorDestroySubKey;
    }

    //
    //  All parameters have been validated, so begin the real work of the API.
    //

    //  Because we'll be doing a file copy below, all changes must be flushed
    //  now.
    if ((ErrorCode = RgFlushFileInfo(hSubKey-> lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    //  Make a backup of the current contents of the subkey.
    if ((ErrorCode = RgSaveKey(hSubKey, lpOldFileName)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    RgGenerateAltFileName(hSubKey-> lpFileInfo-> FileName, ReplaceFileName, 'R');

    //  Check if the magic replacement file already exists and if not, create
    //  it.
    if (RgGetFileAttributes(ReplaceFileName) == (DWORD) -1) {
        if ((ErrorCode = RgCopyFile(hSubKey-> lpFileInfo-> FileName,
            ReplaceFileName)) != ERROR_SUCCESS)
            goto ErrorDeleteOldFile;
        fCreatedReplaceFile = TRUE;
    }

    else
        fCreatedReplaceFile = FALSE;

    if ((ErrorCode = RgCreateRootKeyForFile(&hNewKey, lpNewFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteReplaceFile;

    if ((ErrorCode = RgCreateRootKeyForFile(&hReplaceKey, ReplaceFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDestroyNewRootKey;

    //  The original key that we were given may reference the subkey, so
    //  lpSubKey would be a NULL or empty string.  But we need the name that
    //  this subkey refers to, so we have to go back to the file to pull out
    //  the name.
    if (hKey != hSubKey)
        lpReplaceSubKey = (LPSTR) lpSubKey;

    else {
        //  We allocate this from the heap to reduce the requirements of an
        //  already strained stack.  If this fails, we're likely out of memory.
        //  Even if that's not why we failed, this is such an infrequent path
        //  that it's a good enough error code.
        if (IsNullPtr(lpReplaceSubKey = RgGetKeyName(hSubKey))) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ErrorDestroyReplaceRootKey;
        }
    }

    //  Check if the specified subkey already exists and if it does, delete it.
    if (RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey, LK_OPEN) ==
        ERROR_SUCCESS) {
        RgDeleteKey(hReplaceSubKey);
        RgDestroyKeyHandle(hReplaceSubKey);
    }

    //  Create the specified subkey in the replacement registry and copy the
    //  new hive to that key.
    if ((ErrorCode = RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey,
        LK_CREATE)) == ERROR_SUCCESS) {

        //  If successful, tag the FILE_INFO so that on system exit, we'll go
        //  and rename the replacement file to actual filename.
        if ((ErrorCode = RgCopyBranch(hNewKey, hReplaceSubKey)) ==
            ERROR_SUCCESS)
            hKey-> lpFileInfo-> Flags |= FI_REPLACEMENTEXISTS;

        RgDestroyKeyHandle(hReplaceSubKey);

    }

    if (lpSubKey != lpReplaceSubKey)
        RgSmFreeMemory(lpReplaceSubKey);

ErrorDestroyReplaceRootKey:
    RgDestroyRootKeyForFile(hReplaceKey);

ErrorDestroyNewRootKey:
    RgDestroyRootKeyForFile(hNewKey);

ErrorDeleteReplaceFile:
    if (ErrorCode != ERROR_SUCCESS && fCreatedReplaceFile)
        RgDeleteHiveFile(ReplaceFileName);

ErrorDeleteOldFile:
    if (ErrorCode != ERROR_SUCCESS)
        RgDeleteHiveFile(lpOldFileName);

ErrorDestroySubKey:
    RgDestroyKeyHandle(hSubKey);

ErrorReturn:
    RgUnlockRegistry();

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

//
//  RgReplaceFileOnSysExit
//
//  Essentially the same algorithm as rlReplaceFile from the Win95 registry
//  code with modifications for how file I/O is handled in this library.
//

int
INTERNAL
RgReplaceFileOnSysExit(
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    char ReplaceFileName[MAX_PATH];
    char SaveFileName[MAX_PATH];

    ErrorCode = ERROR_SUCCESS;

    if (RgGenerateAltFileName(lpFileName, ReplaceFileName, 'R') &&
        RgGetFileAttributes(ReplaceFileName) == (FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN)) {

        //  If we were able to generate the replace file name, then we must be
        //  able to generate the save file name, so ignore the result.
        RgGenerateAltFileName(lpFileName, SaveFileName, 'S');
        RgDeleteHiveFile(SaveFileName);

        //  Preserve the current hive in case something fails below.
        if (!RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE) ||
            !RgRenameFile(lpFileName, SaveFileName))
            ErrorCode = ERROR_REGISTRY_IO_FAILED;

        else {
            //  Now try to move the replacement in.
            if (!RgSetFileAttributes(ReplaceFileName, FILE_ATTRIBUTE_NONE) ||
                !RgRenameFile(ReplaceFileName, lpFileName)) {
                ErrorCode = ERROR_REGISTRY_IO_FAILED;
                RgRenameFile(SaveFileName, lpFileName);
            }
            else
                RgDeleteFile(SaveFileName);
        }

        RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN);

    }

    return ErrorCode;

}

//
//  RgReplaceFileInfo
//
//  Called during registry detach to do any necessary file replacements as a
//  result of calling RegReplaceKey.
//

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    if (lpFileInfo-> Flags & FI_REPLACEMENTEXISTS)
        RgReplaceFileOnSysExit(lpFileInfo-> FileName);

    return ERROR_SUCCESS;

}

#endif // WANT_REGREPLACEKEY

#endif // WANT_HIVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regfkey.c ===
//
//  REGFKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegFlushKey and supporting functions.
//

#include "pch.h"

//  Magic HKEY used by Setup to disable disk I/O for the duration of this
//  Windows session (you must restart to re-enable disk I/O).  This is done
//  just before the new SYSTEM.DAT and USER.DAT are copied to their final
//  destination.
#define HKEY_DISABLE_REG            (HKEY) 0x484A574D

//  Magic HKEY used by CONFIGMG to force a flush of the registry before we've
//  received our normal post-critical init call.
#define HKEY_CRITICAL_FLUSH         (HKEY) 0x5350574D

// Magic HKEY used by ScanregW to clear the failed boot bit FHF_BOOTFAILED in the file header
// of HKEY_LOCAL_MACHINE. Indicating that we successfully booted and verified the integrity
// of the registry files, and that scanreg.exe does not need to be ran by win.com on next boot.
#define HKEY_BOOT_SUCCESS           (HKEY) 0x5342574D

//
//  VMMRegFlushKey
//

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    )
{

    int ErrorCode;
    BOOL fBootSuccess = FALSE;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

#ifdef VXD
    //  Set the g_RgFileAccessDisabled flag so that all create or open file
    //  calls will be failed.  The backing stores for our files are about to
    //  be changed, so there's no file for us to go to.
    if (hKey == HKEY_DISABLE_REG) {
        g_RgFileAccessDisabled = TRUE;
        ErrorCode = ERROR_SUCCESS;
        goto ReturnErrorCode;
    }

    //  Set the g_RgPostCriticalInit flag so that all I/O calls will go to disk
    //  instead of the XMS cache.  The XMS cache will be freed when/if the
    //  normal post critical init routine is called, but we should only be
    //  getting this call when we're about to die, so it doesn't really matter.
    if (hKey == HKEY_CRITICAL_FLUSH) {
        g_RgPostCriticalInit = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }

    // Clears the failed boot bit FHF_BOOTFAILED in the file header of HKEY_LOCAL_MACHINE.
    // Indicating that we successfully booted and verified the integrity of the registry files.
    if (hKey == HKEY_BOOT_SUCCESS)
    {
        fBootSuccess = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }
#endif

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
    {
#ifdef VXD
        if (fBootSuccess)
        {
            hKey-> lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;
            hKey-> lpFileInfo-> FileHeader.Flags &= ~FHF_BOOTFAILED;
        }
#endif
        ErrorCode = RgFlushFileInfo(hKey-> lpFileInfo);
    }

#ifdef VXD
ReturnErrorCode:
#endif
    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\reginit.c ===
//
//  REGINIT.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef DEBUG
extern int g_RgDatablockLockCount;
extern int g_RgKeynodeLockCount;
extern int g_RgMemoryBlockCount;
#endif

#ifdef WANT_DYNKEY_SUPPORT
#ifdef VXD
#pragma VMM_IDATA_SEG
#endif
const char g_RgNull[] = "";
#ifdef VXD
#pragma VMM_PAGEABLE_DATA_SEG
#endif
#endif

#ifdef VXD
//  Set when our post critical init routine is called indicating that it's safe
//  to make disk I/O calls.  May also be set early when RegFlushKey gets the
//  magic HKEY_CRITICAL_FLUSH.
BYTE g_RgPostCriticalInit = FALSE;
//  Set when RegFlushKey gets the magic HKEY_DISABLE_REG.  No disk I/O will be
//  allowed after this flag is set.
BYTE g_RgFileAccessDisabled = FALSE;
#endif

LPVOID g_RgWorkBuffer = NULL;
#ifdef DEBUG
BOOL g_RgWorkBufferBusy = FALSE;
#endif

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegLibAttach
//
//  Prepares the registry library for use by allocating any global resources.
//  If ERROR_SUCCESS is returned, then VMMRegLibDetach should be called to 
//  release these resources.
//

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    )
{

    if (IsNullPtr((g_RgWorkBuffer = RgAllocMemory(SIZEOF_WORK_BUFFER))))
        goto MemoryError;

#ifdef WANT_STATIC_KEYS
    if (!RgAllocKeyHandleStructures())
        goto MemoryError;
#endif
    RgInitPredefinedKeys();

#ifdef WANT_DYNKEY_SUPPORT
    //  Initialize HKEY_DYN_DATA.  If anything fails here, we won't stop the
    //  initialize of the entire registry.
    if (RgCreateFileInfoNew(&g_RgDynDataKey.lpFileInfo, g_RgNull,
        CFIN_VERSION20 | CFIN_VOLATILE) == ERROR_SUCCESS)
        RgInitRootKeyFromFileInfo(&g_RgDynDataKey);

    ASSERT(!(g_RgDynDataKey.Flags & KEYF_INVALID));
#endif

    return ERROR_SUCCESS;

MemoryError:
    //  Release anything that we may have allocated up to this point.
    VMMRegLibDetach();

    TRACE(("VMMRegLibAttach returning ERROR_OUTOFMEMORY\n"));
    return ERROR_OUTOFMEMORY;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgDetachPredefKey
//
//  Destroys the memory associated with a predefined key and marks the key
//  invalid.
//

VOID
INTERNAL
RgDetachPredefKey(
    HKEY hKey
    )
{

    if (!(hKey-> Flags & KEYF_INVALID)) {
        RgDestroyFileInfo(hKey-> lpFileInfo);
        hKey-> Flags |= KEYF_INVALID;
    }

}
#endif

//
//  VMMRegLibDetach
//
//  Releases resources allocated by VMMRegLibAttach.  This function may be
//  called after VMMRegLibDetach returns an error, so this function and all
//  functions it calls must be aware that their corresponding 'alloc' function
//  was not called.
//

VOID
REGAPI
VMMRegLibDetach(
    VOID
    )
{

    RgEnumFileInfos(RgFlushFileInfo);

#ifdef VXD
    //  Reduce the chance that we'll go and try to touch the file again!
    //g_RgFileAccessDisabled = TRUE;
    // Unfortunately, we cannot disable writing to the file in this case
    // because Win95 allowed it, and there is at least one VXD that attempts to write
    // to the registry when called with the Sys_VM_Terminate message.
    // However, it seemed like a good idea since the file system is shutting down.
#endif

#ifdef WANT_REGREPLACEKEY
    //  Win95 difference: file replacement used to take place on system startup,
    //  not system exit.  It's much easier to deal with file replacement now
    //  since we know somebody called RegReplaceKey and we only have to do the
    //  work in one component, instead of multiple copies in io.sys, VMM loader,
    //  and VMM.
    RgEnumFileInfos(RgReplaceFileInfo);
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
    //
    //  Delete the FILE_INFO of each of these top-level keys will cause all
    //  of their hives to be deleted.
    //

    RgDetachPredefKey(&g_RgLocalMachineKey);
    RgDetachPredefKey(&g_RgUsersKey);

#ifdef WANT_DYNKEY_SUPPORT
    RgDetachPredefKey(&g_RgDynDataKey);
#endif

    RgFreeKeyHandleStructures();

    if (!IsNullPtr(g_RgWorkBuffer))
        RgFreeMemory(g_RgWorkBuffer);
#endif

    ASSERT(g_RgDatablockLockCount == 0);
    ASSERT(g_RgKeynodeLockCount == 0);
#ifdef WANT_FULL_MEMORY_CLEANUP
    ASSERT(g_RgMemoryBlockCount == 0);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regknode.c ===
//
//  REGKNODE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgKeynodeLockCount);

#define HAS_COMPACT_KEYNODES(lpfi)      ((lpfi)-> Flags & FI_VERSION20)

#define SIZEOF_KEYNODE_BLOCK(lpfi)      \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE_BLOCK) : sizeof(W95KEYNODE_BLOCK))

#define SIZEOF_FILE_KEYNODE(lpfi)       \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE) : sizeof(W95KEYNODE))

#define ROUND_UP(i, basesize) (((((i) + (basesize) - 1) / (basesize))) * (basesize))

#define BLOCK_DESC_GROW_SIZE 0x400

#define W95KEYNODES_PER_PAGE            (PAGESIZE / sizeof(W95KEYNODE))

typedef BOOL (INTERNAL *LPPROCESSKEYNODEPROC)(LPKEYNODE, LPW95KEYNODE);

//
//  RgOffsetToIndex
//

DWORD
INTERNAL
RgOffsetToIndex(
    DWORD W95KeynodeOffset
    )
{

    return (W95KeynodeOffset == REG_NULL) ? W95KeynodeOffset :
	(W95KeynodeOffset / sizeof(W95KEYNODE));

}

//
//  RgIndexToOffset
//

DWORD
INTERNAL
RgIndexToOffset(
    DWORD KeynodeIndex
    )
{

    if (IsNullKeynodeIndex(KeynodeIndex))
        return REG_NULL;

    else {
        if (KeynodeIndex >= 2 * W95KEYNODES_PER_PAGE) {
            DWORD dwUnroundedOff = (KeynodeIndex * sizeof(W95KEYNODE))
				  + sizeof(W95KEYNODE)-1;
	    DWORD dwRoundPage = ((dwUnroundedOff & PAGEMASK) / sizeof(W95KEYNODE))
				  * sizeof(W95KEYNODE);
	    return((dwUnroundedOff & ~PAGEMASK) + dwRoundPage);
	} else {
            return(((KeynodeIndex-1)*sizeof(W95KEYNODE))+sizeof(KEYNODE_HEADER));
	}
    }

}

//
//  RgPackKeynode
//
//  Packs the data from the provided W95KEYNODE to the KEYNODE structure.
//

BOOL
INTERNAL
RgPackKeynode(
    LPKEYNODE lpKeynode,
    LPW95KEYNODE lpW95Keynode
    )
{
    lpKeynode->Flags = 0;

    //  Don't use a switch statement here.  Apparently the compiler will treat
    //  lpW95Keynode->W95State as an integer, so the 16-bit compiler ends up truncating
    //  the value.

    if (lpW95Keynode->W95State == KNS_USED ||
        lpW95Keynode->W95State == KNS_BIGUSED ||
        lpW95Keynode->W95State == KNS_BIGUSEDEXT) {
        lpKeynode->Flags = KNF_INUSE;
        lpKeynode->ParentIndex = RgOffsetToIndex(lpW95Keynode->W95ParentOffset);
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextOffset);
        lpKeynode->ChildIndex = RgOffsetToIndex(lpW95Keynode->W95ChildOffset);
        lpKeynode->KeyRecordIndex = LOWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->BlockIndex = HIWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->Hash = (WORD)lpW95Keynode->W95Hash;

        if (lpW95Keynode->W95State == KNS_BIGUSED)
            lpKeynode->Flags |= KNF_BIGKEYROOT;
        else if (lpW95Keynode->W95State == KNS_BIGUSEDEXT)
            lpKeynode->Flags |= KNF_BIGKEYEXT;

    }

    else if (lpW95Keynode->W95State == KNS_FREE || lpW95Keynode->W95State ==
	KNS_ALLFREE) {
	lpKeynode->FreeRecordSize = lpW95Keynode->W95FreeRecordSize;
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextFreeOffset);
	//  Review this later.  Previous versions of this code checked
	//  if the next index was REG_NULL and bailed out of the processing
	//  loop.  It's possible to have a registry with a free keynode sitting
	//  in the middle of some keynode block and that keynode is the last
	//  in the chain.  We don't want to bail out in those cases.
	//
	//  For now, just bail out if the free record size is greater than a
	//  couple keynodes indicating that this is probably the last free
	//  record and the last record of the keynode.
	if (lpKeynode-> FreeRecordSize > (sizeof(W95KEYNODE)*2))
	    return TRUE;
    }

    else {
        DEBUG_OUT(("RgPackKeynode: Unrecognized state (%lx)\n", lpW95Keynode->
            W95State));
    }

    return FALSE;
}

//
//  RgUnpackKeynode
//
//  Unpacks the data from the provided KEYNODE to the W95KEYNODE structure.
//

BOOL
INTERNAL
RgUnpackKeynode(
    LPKEYNODE lpKeynode,
    LPW95KEYNODE lpW95Keynode
    )
{

    if (lpKeynode->Flags & KNF_INUSE) {

        if (lpKeynode->Flags & KNF_BIGKEYROOT)
            lpW95Keynode->W95State = KNS_BIGUSED;
        else if (lpKeynode->Flags & KNF_BIGKEYEXT)
            lpW95Keynode->W95State = KNS_BIGUSEDEXT;
        else
            lpW95Keynode->W95State = KNS_USED;
        lpW95Keynode->W95ParentOffset = RgIndexToOffset(lpKeynode->ParentIndex);
        lpW95Keynode->W95NextOffset = RgIndexToOffset(lpKeynode->NextIndex);
        lpW95Keynode->W95ChildOffset = RgIndexToOffset(lpKeynode->ChildIndex);
        lpW95Keynode->W95Hash = lpKeynode->Hash;

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  The datablock address must be REG_NULL for Win95 to work.
        lpW95Keynode->W95DatablockAddress = IsNullBlockIndex(lpKeynode->
            BlockIndex) ? REG_NULL : MAKELONG(lpKeynode-> KeyRecordIndex,
            lpKeynode-> BlockIndex);

    }

    else {

        lpW95Keynode->W95State = KNS_FREE;
        lpW95Keynode->W95FreeRecordSize = lpKeynode->FreeRecordSize;
        lpW95Keynode->W95NextFreeOffset = RgIndexToOffset(lpKeynode->NextIndex);

    }

    return FALSE;

}

//
//  RgProcessKeynodeBlock
//
//  The provided callback function is called for each pair of KEYNODE and
//  W95KEYNODE structures from the given keynode blocks.
//

VOID
INTERNAL
RgProcessKeynodeBlock(
    DWORD dwStartOffset,
    DWORD dwBlockSize,
    LPKEYNODE_BLOCK lpKeynodeBlock,
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock,
    LPPROCESSKEYNODEPROC lpfnProcessKeynode
    )
{

    DWORD dwCurOffset;
    LPKEYNODE lpKeynode;
    LPW95KEYNODE lpW95Keynode;
    UINT SkipSize;

    dwCurOffset = dwStartOffset;
    lpW95Keynode = &lpW95KeynodeBlock->aW95KN[0];
    SkipSize = (dwStartOffset == 0) ? sizeof(KEYNODE_HEADER) : 0;

    for (;;) {

        lpW95Keynode = (LPW95KEYNODE)(((LPBYTE)lpW95Keynode)+SkipSize);
        dwCurOffset += SkipSize;

	if (dwCurOffset >= dwStartOffset+dwBlockSize) {
	    goto Done;
	}
        lpKeynode = &lpKeynodeBlock->aKN[KN_INDEX_IN_BLOCK(RgOffsetToIndex(dwCurOffset))];
	while ((dwCurOffset < dwStartOffset+dwBlockSize) &&
	       ((dwCurOffset >> PAGESHIFT) == 0) ||
	       ((dwCurOffset >> PAGESHIFT) ==
		((dwCurOffset + sizeof(W95KEYNODE)) >> PAGESHIFT))) {
            if (lpfnProcessKeynode(lpKeynode, lpW95Keynode)) {
		goto Done;
	    }
	    dwCurOffset += sizeof(W95KEYNODE);
            lpW95Keynode++;
            lpKeynode++;
	}
	//
	//  Compute the number of bytes to skip to get to the next page
	//
        SkipSize = PAGESIZE - (UINT) (dwCurOffset & PAGEMASK);
    }
    Done: {};

}

//
//  RgLockKeynode
//

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockSize;
    HFILE hFile;
    LPKEYNODE_BLOCK lpKeynodeBlock;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;
    DWORD BlockOffset;
    UINT ReadBlockSize;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);

    if (KeynodeBlockIndex > lpFileInfo-> KeynodeBlockCount) {
        DEBUG_OUT(("RgLockKeynode: invalid keynode offset\n"));
        return ERROR_BADDB;
    }

    //
    //  Is the keynode block currently in memory?
    //

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KeynodeBlockIndex);
    lpKeynodeBlock = lpKeynodeBlockInfo-> lpKeynodeBlock;

    if (IsNullPtr(lpKeynodeBlock)) {

        NOISE(("RgLockKeynode: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", KeynodeBlockIndex));

        if (IsNullPtr((lpKeynodeBlock = (LPKEYNODE_BLOCK)
            RgAllocMemory(sizeof(KEYNODE_BLOCK)))))
            return ERROR_OUTOFMEMORY;

        KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
        BlockOffset = (DWORD) KeynodeBlockIndex * KeynodeBlockSize;

        if (BlockOffset < lpFileInfo-> KeynodeHeader.FileKnSize) {

            ASSERT(!(lpFileInfo-> Flags & FI_VOLATILE));

            ReadBlockSize = (UINT) min(KeynodeBlockSize, (lpFileInfo->
                KeynodeHeader.FileKnSize - BlockOffset));

            if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
                HFILE_ERROR)
                goto CleanupAfterFileError;

            if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

                if (!RgSeekFile(hFile, sizeof(VERSION20_HEADER_PAGE) +
                    BlockOffset))
                    goto CleanupAfterFileError;

                if (!RgReadFile(hFile, lpKeynodeBlock, ReadBlockSize))
                    goto CleanupAfterFileError;

            }

            else {

                if (!RgSeekFile(hFile, sizeof(FILE_HEADER) + BlockOffset))
                    goto CleanupAfterFileError;

                lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();

                if (!RgReadFile(hFile, lpW95KeynodeBlock, ReadBlockSize)) {
                    RgUnlockWorkBuffer(lpW95KeynodeBlock);
                    goto CleanupAfterFileError;
                }

                RgProcessKeynodeBlock(BlockOffset, ReadBlockSize,
                    lpKeynodeBlock, lpW95KeynodeBlock, RgPackKeynode);

                RgUnlockWorkBuffer(lpW95KeynodeBlock);

            }

            RgCloseFile(hFile);

        }

        lpKeynodeBlockInfo-> lpKeynodeBlock = lpKeynodeBlock;
        lpKeynodeBlockInfo-> Flags = 0;
        lpKeynodeBlockInfo-> LockCount = 0;

    }

    *lplpKeynode = &lpKeynodeBlock-> aKN[KN_INDEX_IN_BLOCK(KeynodeIndex)];
    lpKeynodeBlockInfo-> Flags |= KBIF_ACCESSED;
    lpKeynodeBlockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);
    return ERROR_SUCCESS;

CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    RgFreeMemory(lpKeynodeBlock);

    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    DEBUG_OUT(("RgLockKeynode() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgLockInUseKeynode
//
//  Wrapper for RgLockKeynode that guarantees that the returned keynode is
//  marked as being in-use.  If not, ERROR_BADDB is returned.
//

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, lplpKeynode)) ==
        ERROR_SUCCESS) {
        if (!((*lplpKeynode)-> Flags & KNF_INUSE)) {
            DEBUG_OUT(("RgLockInUseKeynode: keynode unexpectedly not marked used\n"));
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            ErrorCode = ERROR_BADDB;
        }
    }

    return ErrorCode;

}

//
//  RgUnlockKeynode
//

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    )
{

    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);
    ASSERT(KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount);

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KeynodeBlockIndex);

    ASSERT(lpKeynodeBlockInfo-> LockCount > 0);
    lpKeynodeBlockInfo-> LockCount--;

    if (fMarkDirty) {
        lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);

}

//
//  RgAllocKeynode
//

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;
    DWORD FreeKeynodeOffset;
    DWORD FreeKeynodeIndex;
    UINT FreeRecordSize;
    UINT ExtraPadding;
    UINT KeynodeBlockIndex;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPKEYNODE lpKeynode;
    DWORD NextFreeKeynodeIndex;
    LPKEYNODE lpNextFreeKeynode;
    UINT KeynodeSize;

    FreeKeynodeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  If no more free keynodes exist, then we try to extend the keynode table
    //  to provide more entries.
    if (IsNullKeynodeIndex(FreeKeynodeIndex)) {

        if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
            FreeKeynodeIndex = ROUND_UP(lpFileInfo-> CurTotalKnSize, PAGESIZE) /
                sizeof(KEYNODE);
            FreeRecordSize = PAGESIZE;
	    ExtraPadding = 0;
        }

        else {

            //  Handle the special case of a new file being created: for
            //  uncompacted keynode tables, the first offset is immediately
            //  after the keynode header and the size of the free record must
            //  account for  the size of this header.
            if (lpFileInfo-> CurTotalKnSize == sizeof(KEYNODE_HEADER)) {
                FreeKeynodeOffset = sizeof(KEYNODE_HEADER);
		    //  Win95 compatiblity:  Same initial table size, plus
		    //  causes us to stress the below special grow case.
		    FreeRecordSize = PAGESIZE - sizeof(KEYNODE_HEADER) * 2;
		    ExtraPadding = 0;
            }

            else {

		    FreeKeynodeOffset = ROUND_UP(lpFileInfo-> CurTotalKnSize,
                        PAGESIZE);
                    FreeRecordSize = PAGESIZE;
                    ExtraPadding = (UINT) (FreeKeynodeOffset - lpFileInfo->
                        CurTotalKnSize);

		    //  Handle the case of a keynode table with a non-integral
		    //  number of pages.  We'll place the new free keynode at the
		    //  top of the existing keynode table with a size including
		    //  the remaining bytes on the page plus a new page (effectively
		    //  the same as Win95).
		    if (ExtraPadding > sizeof(W95KEYNODE) || FreeKeynodeOffset ==
		        PAGESIZE) {
		        //	Although this code will work for any non-integral
		        //	number of pages, it should ONLY occur for <4K tables.
		        ASSERT(FreeKeynodeOffset == PAGESIZE);
		        FreeRecordSize += ExtraPadding;
		        FreeKeynodeOffset = lpFileInfo-> CurTotalKnSize;
		        ExtraPadding = 0;
                }

            }

            FreeKeynodeIndex = RgOffsetToIndex(FreeKeynodeOffset);

        }

        KeynodeBlockIndex = KN_BLOCK_NUMBER(FreeKeynodeIndex);

        //  Put in some sort of "max" count/KEYNODE_BLOCKS_PER_FILE
        //  check.

        //  Check if lpKeynodeBlockInfo is too small to hold the info for a new
        //  keynode block.  If so, then we must grow it a bit.
        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockInfoAllocCount) {

            AllocCount = KeynodeBlockIndex + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

            if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                RgSmReAllocMemory(lpFileInfo-> lpKeynodeBlockInfo, AllocCount *
                sizeof(KEYNODE_BLOCK_INFO)))))
                return ERROR_OUTOFMEMORY;

            ZeroMemory(lpKeynodeBlockInfo + lpFileInfo->
                KeynodeBlockInfoAllocCount, (AllocCount - lpFileInfo->
                KeynodeBlockInfoAllocCount) * sizeof(KEYNODE_BLOCK_INFO));

            lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
            lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

        }

        if (KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount)
        {
    	    lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
            lpFileInfo-> Flags |= FI_EXTENDED;
            lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;
        }

        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockCount)
        {
            lpFileInfo-> KeynodeBlockCount = KeynodeBlockIndex + 1;

    	    lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
            lpFileInfo-> Flags |= FI_EXTENDED;
            lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;
        }
        
        lpKeynode-> NextIndex = REG_NULL;
        lpKeynode-> Flags = 0;
        lpKeynode-> FreeRecordSize = FreeRecordSize;

    }

    else {
        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;
    }

    NextFreeKeynodeIndex = lpKeynode-> NextIndex;
    KeynodeSize = SIZEOF_FILE_KEYNODE(lpFileInfo);

    //  If the free keynode record can be broken up into smaller chunks, then
    //  create another free record immediately after the one we're about to
    //  snag.
    if ((lpKeynode-> FreeRecordSize >= KeynodeSize * 2) &&
        (RgLockKeynode(lpFileInfo, FreeKeynodeIndex + 1, &lpNextFreeKeynode) ==
        ERROR_SUCCESS)) {

	//  Copy the next link from the current free keynode (likely REG_NULL).
        lpNextFreeKeynode-> NextIndex = NextFreeKeynodeIndex;
        lpNextFreeKeynode-> Flags = 0;
        lpNextFreeKeynode-> FreeRecordSize = lpKeynode-> FreeRecordSize -
            KeynodeSize;

        NextFreeKeynodeIndex = FreeKeynodeIndex + 1;
        RgUnlockKeynode(lpFileInfo, NextFreeKeynodeIndex, TRUE);

    }

    lpFileInfo-> KeynodeHeader.FirstFreeIndex = NextFreeKeynodeIndex;

    lpKeynode-> Flags |= KNF_INUSE;

    //  Mark the keynode block that holds this keynode dirty.
    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KN_BLOCK_NUMBER(FreeKeynodeIndex));
    lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
    lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
    RgDelayFlush();

    //  WARNING:  The following two statements used to be above the block that
    //  dirtied the keynode.  The 16-bit compiler messed up and
    //  lpKeynodeBlockInfo ended up with a bogus offset thus corrupting random
    //  memory.  Be sure to trace through this function if you change it!
    *lpKeynodeIndex = FreeKeynodeIndex;
    *lplpKeynode = lpKeynode;

    return ERROR_SUCCESS;

}

//
//  RgFreeKeynode
//
//  Marks the specified keynode index free and adds it to the hive's free
//  keynode list.
//

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, &lpKeynode)) ==
        ERROR_SUCCESS) {

        lpKeynode-> Flags &= ~(KNF_INUSE | KNF_BIGKEYROOT | KNF_BIGKEYEXT);
        lpKeynode-> NextIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;
        lpKeynode-> FreeRecordSize = SIZEOF_FILE_KEYNODE(lpFileInfo);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = KeynodeIndex;

        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    }

    return ErrorCode;

}

//
//  RgGetKnBlockIOInfo
//

VOID
INTERNAL
RgGetKnBlockIOInfo(
    LPFILE_INFO lpFileInfo,
    DWORD       BaseKeynodeIndex,
    UINT FAR*   lpFileBlockSize,
    LONG FAR*   lpFileOffset
    )
{

    UINT FileBlockSize;
    DWORD FileOffset;
    DWORD BaseKeynodeOffset;

    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

        FileBlockSize = sizeof(KEYNODE_BLOCK);

        BaseKeynodeOffset = BaseKeynodeIndex * sizeof(KEYNODE);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                BaseKeynodeOffset);

        FileOffset = sizeof(VERSION20_HEADER_PAGE) + BaseKeynodeIndex *
            sizeof(KEYNODE);

    }

    else {

        FileBlockSize = sizeof(W95KEYNODE_BLOCK);

        //  The first keynode block of an uncompacted keynode table should
        //  start writing AFTER the keynode header.
        if (BaseKeynodeIndex == 0) {
            BaseKeynodeIndex = RgOffsetToIndex(sizeof(KEYNODE_HEADER));
            FileBlockSize -= sizeof(KEYNODE_HEADER);
	}

        BaseKeynodeOffset = RgIndexToOffset(BaseKeynodeIndex);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                BaseKeynodeOffset);

        FileOffset = sizeof(FILE_HEADER) + BaseKeynodeOffset;

    }

    *lpFileBlockSize = FileBlockSize;
    *lpFileOffset = FileOffset;

}



int
_inline
RgCopyKeynodeBlock(
    LPFILE_INFO lpFileInfo,
    DWORD BaseIndex,
    HFILE hSrcFile,
    HFILE hDestFile
    )
{
    UINT FileBlockSize;
    LONG FileOffset;
    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);
    return RgCopyFileBytes(hSrcFile,
			  FileOffset,
			  hDestFile,
			  FileOffset,
			  FileBlockSize);
}

//
//  RgWriteKeynodeBlock
//

int
INTERNAL
RgWriteKeynodeBlock(
    LPFILE_INFO lpFileInfo,
    DWORD BaseIndex,
    HFILE hDestFile,
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo
    )
{
    int ErrorCode;
    UINT FileBlockSize;
    LONG FileOffset;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;

    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;       // Assume I/O fails
    if (!RgSeekFile(hDestFile, FileOffset)) {
        goto Exit;
    }
    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
        if (RgWriteFile(hDestFile, lpKeynodeBlockInfo->lpKeynodeBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
    } else {
        LPBYTE lpWriteBlock;
        lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();
        RgProcessKeynodeBlock(
			    BaseIndex * sizeof(W95KEYNODE),
			    FileBlockSize,
                            lpKeynodeBlockInfo->lpKeynodeBlock,
                            lpW95KeynodeBlock,
                            RgUnpackKeynode);
        lpWriteBlock = (LPBYTE)lpW95KeynodeBlock;
        if (BaseIndex == 0) {
            lpWriteBlock += sizeof(KEYNODE_HEADER);
        }
        if (RgWriteFile(hDestFile, lpWriteBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
        RgUnlockWorkBuffer(lpW95KeynodeBlock);
    }
Exit:   ;
    return(ErrorCode);
}

//
//  RgWriteKeynodes
//

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    )
{

    DWORD SavedRootIndex;
    DWORD SavedFreeIndex;
    DWORD SavedFileKnSize;
    BOOL fResult;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    if ((hSrcFile == HFILE_ERROR) && !(lpFileInfo->Flags & FI_KEYNODEDIRTY))
        return ERROR_SUCCESS;

    NOISE(("writing keynodes of "));
    NOISE((lpFileInfo-> FileName));
    NOISE(("\n"));

    //
    //	Write out the keynode header.  If the keynodes are not compact then
    //	convert to offsets before writing.
    //

    if (!RgSeekFile(hDestFile, sizeof(FILE_HEADER)))
        return ERROR_REGISTRY_IO_FAILED;

    SavedFileKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;
    SavedRootIndex = lpFileInfo-> KeynodeHeader.RootIndex;
    SavedFreeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  Write the real size of the keynode table to disk.
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    //  Convert keynode indexes back to offsets temporarily for uncompacted
    //  keynode tables.
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgIndexToOffset(lpFileInfo->
            KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgIndexToOffset(lpFileInfo->
            KeynodeHeader.FirstFreeIndex);
    }

    fResult = RgWriteFile(hDestFile, &lpFileInfo-> KeynodeHeader,
        sizeof(KEYNODE_HEADER));

    lpFileInfo-> KeynodeHeader.FileKnSize = SavedFileKnSize;
    lpFileInfo-> KeynodeHeader.RootIndex = SavedRootIndex;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = SavedFreeIndex;

    if (!fResult)
        return ERROR_REGISTRY_IO_FAILED;

    //
    //	Now loop through each block.
    //

    lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;

    for (KeynodeBlockIndex = 0; KeynodeBlockIndex < lpFileInfo->
        KeynodeBlockCount; KeynodeBlockIndex++, lpKeynodeBlockInfo++) {

        DWORD BaseKeynodeIndex = KeynodeBlockIndex * KEYNODES_PER_BLOCK;

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {
            if (hSrcFile != HFILE_ERROR || lpKeynodeBlockInfo-> Flags &
                KBIF_DIRTY) {
                if (RgWriteKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hDestFile,
                    lpKeynodeBlockInfo) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

        else {
            if (hSrcFile != HFILE_ERROR) {
                if (RgCopyKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hSrcFile,
                    hDestFile) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteKeynodesComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    lpFileInfo-> Flags &= ~FI_KEYNODEDIRTY;
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
        lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++)
        lpKeynodeBlockInfo-> Flags &= ~KBIF_DIRTY;

}

//
//  RgSweepKeynodes
//
//  Makes a pass through all the present keynode blocks of the given FILE_INFO
//  structure and discards keynode blocks that have not been accessed since the
//  last sweep.
//

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
        lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++) {

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {

            if (((lpKeynodeBlockInfo-> Flags & (KBIF_ACCESSED | KBIF_DIRTY)) ==
                0) && (lpKeynodeBlockInfo-> LockCount == 0)) {
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
                lpKeynodeBlockInfo-> lpKeynodeBlock = NULL;
            }

            lpKeynodeBlockInfo-> Flags &= ~KBIF_ACCESSED;

	}

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitKeynodeInfo
//
//  Initializes fields in the provided FILE_INFO related to the keynode table.
//

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    )
{

    UINT KeynodeBlockSize;
    UINT BlockCount;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
    BlockCount = (UINT) ((DWORD) (lpFileInfo-> KeynodeHeader.FileKnSize +
        KeynodeBlockSize - 1) / (DWORD) KeynodeBlockSize);
    AllocCount = BlockCount + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

    if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
        RgSmAllocMemory(AllocCount * sizeof(KEYNODE_BLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpKeynodeBlockInfo, AllocCount * sizeof(KEYNODE_BLOCK_INFO));
    lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
    lpFileInfo-> KeynodeBlockCount = BlockCount;
    lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

    lpFileInfo-> KeynodeHeader.Flags &= ~(KHF_DIRTY | KHF_EXTENDED |
        KHF_HASCHECKSUM);

    //  Convert file offsets to index values for uncompressed files
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgOffsetToIndex(lpFileInfo->
            KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgOffsetToIndex(lpFileInfo->
            KeynodeHeader.FirstFreeIndex);
    }

    lpFileInfo-> CurTotalKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regkey.c ===
//
//  REGKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegCreateKey, RegOpenKey, RegCloseKey, and supporting
//  functions.
//

#include "pch.h"

//
//  RgIsBadSubKey
//
//  Returns TRUE if lpSubKey is a invalid subkey string.  An invalid subkey
//  string may be an invalid pointer or contain double-backslashes or elements
//  greater than MAXIMUM_SUB_KEY_LENGTH.
//

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    )
{

    LPCSTR lpString;
    UINT SubSubKeyLength;
    BYTE Char;

    if (IsNullPtr(lpSubKey))
        return FALSE;

    if (!IsBadStringPtr(lpSubKey, (UINT) -1)) {

        lpString = lpSubKey;
        SubSubKeyLength = 0;

        while (TRUE) {

            Char = *((LPBYTE) lpString);

            if (Char == '\0')
                return FALSE;

            else if (Char == '\\') {
                //  Catch double-backslashes and leading backslashes.  One
                //  leading backslash is acceptable...
                if (SubSubKeyLength == 0 && lpString != lpSubKey)
                    break;
                SubSubKeyLength = 0;
            }

            else {

                if (IsDBCSLeadByte(Char)) {
                    SubSubKeyLength++;
                    //  Catch an unpaired DBCS pair...
                    if (*lpString++ == '\0')
                        break;
                }

                //  Win95 compatibility: don't accept strings with control
                //  characters.
                else if (Char < ' ')
                    break;

                if (++SubSubKeyLength >= MAXIMUM_SUB_KEY_LENGTH)
                    break;

            }

            lpString++;

        }

    }

    return TRUE;

}

//
//  RgGetNextSubSubKey
//
//  Extracts the next subkey component tokenized by backslashes.  Works like
//  strtok where on the first call, lpSubKey points to the start of the subkey.
//  On subsequent calls, lpSubKey is NULL and the last offset is used to find
//  the next component.
//
//  Returns the length of the SubSubKey string.
//

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    )
{

    static LPCSTR lpLastSubSubKey = NULL;
    LPCSTR lpString;
    UINT SubSubKeyLength;

    if (!IsNullPtr(lpSubKey))
        lpLastSubSubKey = lpSubKey;

    lpString = lpLastSubSubKey;

    if (*lpString == '\0') {
        *lplpSubSubKey = NULL;
        *lpSubSubKeyLength = 0;
        return 0;
    }

    if (*lpString == '\\')
        lpString++;
    
    *lplpSubSubKey = lpString;

    while (*lpString != '\0') {

        if (*lpString == '\\')
            break;

        //  The subkey has already been validated, so we know there's a matching
        //  trail byte.
        if (IsDBCSLeadByte(*lpString))
            lpString++;                 //  Trail byte skipped immediately below

        lpString++;

    }

    lpLastSubSubKey = lpString;

    SubSubKeyLength = lpString - *lplpSubSubKey;
    *lpSubSubKeyLength = SubSubKeyLength;

    return SubSubKeyLength;

}

//
//  RgLookupKey
//

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    )
{

    int ErrorCode;
    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;
    BOOL fCreatedKeynode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
    BOOL fPrevIsNextIndex;
    DWORD SubSubKeyHash;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
    BOOL fFound;
    DWORD PrevKeynodeIndex;
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    DWORD NotifyKeynodeIndex;
#endif
    LPKEYNODE lpNewKeynode;
    HKEY hSubKey;
#ifdef REALMODE
    BOOL secondTry;
#endif

    fCreatedKeynode = FALSE;

    //
    //  Check if the caller is trying to open a key with a NULL or zero-length
    //  sub key string.  If so, simply return hKey.
    //  This also ignores "\"
    //

    if (IsNullPtr(lpSubKey) || RgGetNextSubSubKey(lpSubKey, &lpSubSubKey,
        &SubSubKeyLength) == 0) {
        hSubKey = hKey;
        goto HaveSubKeyHandle;
    }

    //
    // The next two lines fix the problem with Publisher 97. It tries to open
    // HKEY_LOCAL_MACHINE, \KEY_NAME. This was being allowed to succeed by
    // this API. That is because, RlGetNextSubSubKey blasts off the starting
    // '\' and then this api is equivalent to HKEY_LOCAL_MACHINE, KEY_NAME.
    // This is a no-no since Publisher 97 proceeds to blast off the whole
    // registry if we let this call succeed.
    //
    
    if (!(Flags & LK_CREATE)) {
        SubSubKeyLength += (DWORD)lpSubSubKey - (DWORD)lpSubKey;
        lpSubSubKey = lpSubKey;
    }
    
    lpFileInfo = hKey-> lpFileInfo;
    KeynodeIndex = hKey-> ChildKeynodeIndex;
    PrevKeynodeIndex = hKey-> KeynodeIndex;

#ifdef WANT_HIVE_SUPPORT
    //
    //  If this key can have hives attached to it, check there for the first
    //  part of the subkey.  If we have a match, then switch into that
    //  FILE_INFO.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (SubSubKeyLength == lpHiveInfo-> NameLength &&  
                RgStrCmpNI(lpSubSubKey, lpHiveInfo-> Name,
                SubSubKeyLength) == 0) {

                lpFileInfo = lpHiveInfo-> lpFileInfo;
                KeynodeIndex = lpFileInfo-> KeynodeHeader.RootIndex;

                if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    return ErrorCode;

                if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
                    goto LookupComplete;

                PrevKeynodeIndex = KeynodeIndex;
                KeynodeIndex = lpKeynode-> ChildIndex;
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

                break;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;

        }

    }
#endif

    //
    //  Walk as deep as we can into the registry tree using existing key
    //  records.  For each subkey component, move to the child of the current
    //  tree position and walk each sibling looking for a match.  Repeat until
    //  we're out of subkey components or we hit the end of a branch.
    //

    fPrevIsNextIndex = FALSE;

    for (;;) {

        SubSubKeyHash = RgHashString(lpSubSubKey, SubSubKeyLength);

        while (!IsNullKeynodeIndex(KeynodeIndex)) {
#ifdef REALMODE
            secondTry = FALSE;
tryAgain:
#endif // REALMODE
            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            if (lpKeynode-> Hash == SubSubKeyHash) {

                if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode->
                    BlockIndex, (BYTE) lpKeynode-> KeyRecordIndex,
                    &lpKeyRecord)) != ERROR_SUCCESS) {
                    RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
#ifdef REALMODE
                    if (!secondTry)
                    {
                        // What happens in real mode, is that we get wedged with the
                        // Keynode block allocated and locked in the middle of the free
                        // space, and there is not a free block large enough for the data block.
                        // So, by unlocking and freeing the Keynode block and then restarting
                        // the operation, the Keynode block gets allocated at the bottom of the
                        // heap, leaving room for the data block.
                        secondTry = TRUE;
                        RgEnumFileInfos(RgSweepFileInfo);
                        RgEnumFileInfos(RgSweepFileInfo);
                        goto tryAgain;
                    }
#endif // REALMODE
                    return ErrorCode;
                }


                fFound = (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT) &&
                    SubSubKeyLength == lpKeyRecord-> NameLength &&
                    RgStrCmpNI(lpSubSubKey, lpKeyRecord-> Name,
                    SubSubKeyLength) == 0);

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

                if (fFound)
                    break;

            }

            //  Unlock the current keynode and advance to its sibling.  Set
            //  fPrevIsNextIndex so that if we have to create, we know that
            //  we'll be inserting the new keynode as a sibling.
            fPrevIsNextIndex = TRUE;
            PrevKeynodeIndex = KeynodeIndex;
            KeynodeIndex = lpKeynode-> NextIndex;
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

        }

        //  Break out if we looped over all the siblings of the previous keynode
        //  or if the previous keynode didn't have any children.  If we're in
        //  create mode, then fPrevIsNextIndex and PrevKeynodeIndex will
        //  represent where we need to start inserting.
        if (IsNullKeynodeIndex(KeynodeIndex))
            break;

        //  Break out there are no more subkey components to lookup.
        //  KeynodeIndex represents the index of the matching key.  It's
        //  corresponding keynode is locked.
        if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
            break;

        //  Unlock the current keynode and advance to its child.  Clear
        //  fPrevIsNextIndex so that if we have to create, we know that we'll
        //  be inserting the new keynode as a child.
        fPrevIsNextIndex = FALSE;
        PrevKeynodeIndex = KeynodeIndex;
        KeynodeIndex = lpKeynode-> ChildIndex;
        RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

    }

    if (IsNullKeynodeIndex(KeynodeIndex)) {

        if (!(Flags & LK_CREATE))
            return ERROR_CANTOPEN16_FILENOTFOUND32;

        if ((IsDynDataKey(hKey) && !(Flags & LK_CREATEDYNDATA)) || (lpFileInfo->
            Flags & FI_READONLY))
            return ERROR_ACCESS_DENIED;

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, PrevKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS) {
            TRACE(("RgLookupKey: failed to lock keynode we just had?\n"));
            return ErrorCode;
        }

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        //  Which keynode index we'll notify of the subkeys we're creating
        //  depends on the state of fPrevIsNextIndex.
        NotifyKeynodeIndex = fPrevIsNextIndex ? lpKeynode-> ParentIndex :
            PrevKeynodeIndex;
#endif

        //  See if there's an open handle on the parent so that we can patch up
        //  its child keynode index member.  We only need this on the first
        //  pass.
        hSubKey = RgFindOpenKeyHandle(lpFileInfo, PrevKeynodeIndex);

        do {

            if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex,
                &lpNewKeynode)) != ERROR_SUCCESS)
                goto CreateAllocFailed1;

            if ((ErrorCode = RgAllocKeyRecord(lpFileInfo, sizeof(KEY_RECORD) +
                SubSubKeyLength - 1, &lpKeyRecord)) != ERROR_SUCCESS) {

                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgFreeKeynode(lpFileInfo, KeynodeIndex);

CreateAllocFailed1:
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, fCreatedKeynode);

                DEBUG_OUT(("RgLookupKey: allocation failed\n"));
                goto SignalAndReturnErrorCode;

            }

            //  Fixup the previous keynode's next offset.
            if (fPrevIsNextIndex) {

                fPrevIsNextIndex = FALSE;
                hSubKey = NULL;
                lpNewKeynode-> ParentIndex = lpKeynode-> ParentIndex;
                lpKeynode-> NextIndex = KeynodeIndex;

            }

            //  Fixup the previous keynode's child offset.
            else {

                lpNewKeynode-> ParentIndex = PrevKeynodeIndex;
                lpKeynode-> ChildIndex = KeynodeIndex;

                //  If hSubKey is not NULL, then we may have to patch up the
                //  child offset cache to point to the newly created keynode.
                if (!IsNullPtr(hSubKey)) {
                    if (IsNullKeynodeIndex(hSubKey-> ChildKeynodeIndex))
                        hSubKey-> ChildKeynodeIndex = KeynodeIndex;
                    hSubKey = NULL;
                }

            }

            //  Fill in the keynode.
            lpNewKeynode-> NextIndex = REG_NULL;
            lpNewKeynode-> ChildIndex = REG_NULL;
            lpNewKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpNewKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;
            lpNewKeynode-> Hash = (WORD) RgHashString(lpSubSubKey,
                SubSubKeyLength);

            //  Fill in the key record.
            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD) + SubSubKeyLength - 1;
            lpKeyRecord-> NameLength = (WORD) SubSubKeyLength;
            MoveMemory(lpKeyRecord-> Name, lpSubSubKey, SubSubKeyLength);
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            //  Unlock the keynode that points to the new keynode and advance
            //  to the next keynode.
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, TRUE);
            PrevKeynodeIndex = KeynodeIndex;
            lpKeynode = lpNewKeynode;

            RgUnlockDatablock(lpFileInfo, lpKeyRecord-> BlockIndex, TRUE);

            fCreatedKeynode = TRUE;

            //  Following should already be zeroed for subsequent iterations.
            ASSERT(!fPrevIsNextIndex);
            ASSERT(IsNullPtr(hSubKey));

        }   while (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength));

    }

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Now we've got the keynode for the request subkey.  Check if it has been
    //  previously opened.  If not, then allocate a new key handle for it and
    //  initialize it.
    //

#ifdef WANT_HIVE_SUPPORT
LookupComplete:
#endif
    if (IsNullPtr(hSubKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex))) {

        if (IsNullPtr(hSubKey = RgCreateKeyHandle()))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            hSubKey-> lpFileInfo = lpFileInfo;
            hSubKey-> KeynodeIndex = KeynodeIndex;
            hSubKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
            hSubKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hSubKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;
            hSubKey-> PredefinedKeyIndex = hKey-> PredefinedKeyIndex;

            if (lpKeynode-> Flags & KNF_BIGKEYROOT)
                hSubKey-> Flags |= KEYF_BIGKEYROOT;
        }

    }

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, fCreatedKeynode);

    //
    //  Now we've got a key handle that references the requested subkey.
    //  Increment the reference count on the handle and return it to the caller.
    //  Note that this differs from NT semantic where they return a unique
    //  handle for every open.
    //

    if (!IsNullPtr(hSubKey)) {
HaveSubKeyHandle:
        RgIncrementKeyReferenceCount(hSubKey);
        *lphSubKey = hSubKey;
        ErrorCode = ERROR_SUCCESS;
    }

SignalAndReturnErrorCode:
    //  If we managed to create any keynodes, regardless of what ErrorCode is
    //  set to now, then we must signal any waiting events.
    if (fCreatedKeynode) {
        RgSignalWaitingNotifies(lpFileInfo, NotifyKeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);
    }

    return ErrorCode;

}

//
//  RgCreateOrOpenKey
//
//  Common routine for VMMRegCreateKey and VMMRegOpenKey.  Valids parameters,
//  locks the registry, and calls the real worker routine.
//

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    )
{

    int ErrorCode;

    if (RgIsBadSubKey(lpSubKey))
        return ERROR_BADKEY;

    if (IsBadHugeWritePtr(lphKey, sizeof(HKEY)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKey(hKey, lpSubKey, lphKey, Flags);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegCreateKey
//
//  See Win32 documentation of RegCreateKey.
//

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_CREATE);

}

//
//  VMMRegOpenKey
//
//  See Win32 documentation of RegOpenKey.
//

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_OPEN);

}

//
//  VMMRegCloseKey
//
//  See Win32 documentation of RegCloseKey.
//

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    ErrorCode = RgValidateAndConvertKeyHandle(&hKey);

    if (ErrorCode == ERROR_SUCCESS || ErrorCode == ERROR_KEY_DELETED) {
        RgDestroyKeyHandle(hKey);
        ErrorCode = ERROR_SUCCESS;
    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regknode.h ===
//
//  REGKNODE.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKNODE_
#define _REGKNODE_

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    );

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

#endif // _REGKNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regkylst.h ===
//
//  REGKYLST.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKYLST_
#define _REGKYLST_

VOID
INTERNAL
RgInitPredefinedKeys(
    VOID
    );

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    );

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    );

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    );

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    );

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    );

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    );

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    );

extern KEY g_RgLocalMachineKey;
extern KEY g_RgUsersKey;
#ifdef WANT_DYNKEY_SUPPORT
extern KEY g_RgDynDataKey;
#endif

#endif // _REGKYLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regmem.h ===
//
//  REGMEM.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGMEM_
#define _REGMEM_

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    );

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpMemory,
    UINT cbBytes
    );

#ifdef DEBUG
VOID
INTERNAL
RgFreeMemory(
    LPVOID
    );
#else
#ifdef VXD
#define RgFreeMemory(lpv)           (FreePages(lpv))
#else
#define RgFreeMemory(lpv)           (FreeBytes(lpv))
#endif
#endif

//  Use the RgSm*Memory macros to allocate small chunks of memory off the heap.
//  For the VMM mode registry, the Rg*Memory functions will allocate pages,
//  while the RgSm*Memory functions will allocate from the heap.  For all other
//  modes, the two sets are equivalent.
#if defined(VXD)
#define RgSmAllocMemory             AllocBytes
#define RgSmFreeMemory              FreeBytes
#define RgSmReAllocMemory           ReAllocBytes
#else
#define RgSmAllocMemory             RgAllocMemory
#define RgSmFreeMemory              RgFreeMemory
#define RgSmReAllocMemory           RgReAllocMemory
#endif

#endif // _REGMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regnckey.h ===
//
//  REGNCKEY.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGNCKEY_
#define _REGNCKEY_

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
typedef struct _NOTIFY_CHANGE {
    struct _NOTIFY_CHANGE FAR* lpNextNotifyChange;
    DWORD ThreadId;
    HANDLE hEvent;
    DWORD KeynodeIndex;
    DWORD NotifyFilter;
}   NOTIFY_CHANGE, FAR* LPNOTIFY_CHANGE;

//  Map the bWatchSubtree flag to this bit tucked into the NotifyFilter field.
#define REG_NOTIFY_WATCH_SUBTREE        0x40
//  Only signal events that are watching the specified keynode index, not
//  parents of the keynode index.
#define REG_NOTIFY_NO_WATCH_SUBTREE     0x80

VOID
INTERNAL
RgSignalWaitingNotifies(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    UINT NotifyEvent
    );
#else
#define RgSignalWaitingNotifies(lpfi, ki, nevt)
#endif

#endif // _REGNCKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regkylst.c ===
//
//  REGKYLST.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Declares the predefined key structures and manages dynamic HKEY structures.
//

#include "pch.h"
#include <limits.h>

//  We would rather just have one definition a
#ifdef WANT_DYNKEY_SUPPORT
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL,                                       \
        NULL                                            \
    }
#else
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL                                        \
    }
#endif

KEY g_RgLocalMachineKey =
    INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
KEY g_RgUsersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);
#ifdef WANT_DYNKEY_SUPPORT
KEY g_RgDynDataKey = INITED_PREDEFINED_KEY(INDEX_DYN_DATA, 0);
#endif

HKEY g_RgPredefinedKeys[] = {
    NULL,                                       //  HKEY_CLASSES_ROOT
    NULL,                                       //  HKEY_CURRENT_USER
    &g_RgLocalMachineKey,                       //  HKEY_LOCAL_MACHINE
    &g_RgUsersKey,                              //  HKEY_USERS
    NULL,                                       //  HKEY_PERFORMANCE_DATA
    NULL,                                       //  HKEY_CURRENT_CONFIG
#ifdef WANT_DYNKEY_SUPPORT
    &g_RgDynDataKey,                            //  HKEY_DYN_DATA
#endif
};

#define NUMBER_PREDEF_KEYS      (sizeof(g_RgPredefinedKeys) / sizeof(HKEY))

#ifdef WANT_STATIC_KEYS
#define NUMBER_STATIC_KEYS              32
HKEY g_RgStaticKeyArray = NULL;
#endif

//  List of all dynamically allocated keys.
HKEY g_RgDynamicKeyList = NULL;

const char g_RgClassesRootSubKey[] = "SOFTWARE\\CLASSES";
const char g_RgCurrentUserSubKey[] = ".DEFAULT";


//
// RgInitPredefinedKeys
// 

VOID
INTERNAL
RgInitPredefinedKeys(
    VOID
    )
{
    KEY localMachineKey = INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
    KEY usersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);

    g_RgLocalMachineKey = localMachineKey;
    g_RgUsersKey = usersKey;
}


#ifdef WANT_STATIC_KEYS
//
//  RgAllocKeyHandleStructures
//

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    )
{

    UINT Index;
    HKEY hKey;

    ASSERT(IsNullPtr(g_RgStaticKeyArray));
    ASSERT(IsNullPtr(g_RgDynamicKeyList));

    //
    //  Allocate and initialize the static key table.
    //

    g_RgStaticKeyArray = RgSmAllocMemory(NUMBER_STATIC_KEYS * sizeof(KEY));

    if (IsNullPtr(g_RgStaticKeyArray))
        return FALSE;

    for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
        Index--, hKey++) {
        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = KEYF_STATIC | KEYF_INVALID;
        hKey-> ReferenceCount = 0;
    }

    return TRUE;

}
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgFreeKeyHandleStructures
//
//  Releases resources allocated by RgAllocKeyHandleStructures.
//

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    )
{

    HKEY hTempKey;
    HKEY hKey;

    //
    //  Delete all of the dynamically allocated keys.
    //

    hKey = g_RgDynamicKeyList;

    if (!IsNullPtr(hKey)) {
        do {
            hTempKey = hKey;
            hKey = hKey-> lpNext;
#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hTempKey-> pProvider))
                RgSmFreeMemory(hTempKey-> pProvider);
#endif
            RgSmFreeMemory(hTempKey);
        }   while (hKey != g_RgDynamicKeyList);
    }

    g_RgDynamicKeyList = NULL;

#ifdef WANT_STATIC_KEYS
    //
    //  Delete the static key table.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {
        RgSmFreeMemory(g_RgStaticKeyArray);
        g_RgStaticKeyArray = NULL;
    }
#endif

}
#endif

//
//  RgCreateKeyHandle
//
//  Allocates one KEY structure, initializes some of its members, and links it
//  to the list of open key handles.
//

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    )
{

#ifdef WANT_STATIC_KEYS
    UINT Index;
#endif
    HKEY hKey;

#ifdef WANT_STATIC_KEYS
    //
    //  Check if any keys are available in the static pool.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> Flags & KEYF_INVALID) {
                ASSERT(hKey-> ReferenceCount == 0);
                hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED |
                    KEYF_ENUMKEYCACHED);
                return hKey;
            }
        }

    }
#endif

    //
    //  Must allocate a dynamic key.  Initialize it and add it to our list.
    //

    hKey = (HKEY) RgSmAllocMemory(sizeof(KEY));

    if (!IsNullPtr(hKey)) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = 0;
        hKey-> ReferenceCount = 0;
#ifdef WANT_DYNKEY_SUPPORT
        hKey-> pProvider = NULL;
#endif

        if (IsNullPtr(g_RgDynamicKeyList)) {
            hKey-> lpPrev = hKey;
            hKey-> lpNext = hKey;
        }

        else if (hKey != g_RgDynamicKeyList) {
            hKey-> lpNext = g_RgDynamicKeyList;
            hKey-> lpPrev = g_RgDynamicKeyList-> lpPrev;
            hKey-> lpPrev-> lpNext = hKey;
            g_RgDynamicKeyList-> lpPrev = hKey;
        }

        g_RgDynamicKeyList = hKey;

    }

    return hKey;

}

//
//  RgDeleteKeyHandle
//
//  Decrements the reference count on the given key handle.  If the count
//  reaches zero and the key was dynamically allocated, then the key is unlinked
//  from the key list and the key is freed.
//

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    )
{

    ASSERT(!IsNullPtr(hKey));

    //	Don't allow the reference count to underflow for predefined keys or
    //	keys marked "never delete".
    if (hKey-> ReferenceCount > 0)
        hKey-> ReferenceCount--;

    if (hKey-> ReferenceCount == 0) {

        if (!(hKey-> Flags & (KEYF_PREDEFINED | KEYF_NEVERDELETE))) {

#ifdef WANT_STATIC_KEYS
            if (hKey-> Flags & KEYF_STATIC) {
                hKey-> Flags |= KEYF_INVALID;
                return;
            }
#endif

            if (hKey == hKey-> lpNext)
                g_RgDynamicKeyList = NULL;

            else {

                hKey-> lpPrev-> lpNext = hKey-> lpNext;
                hKey-> lpNext-> lpPrev = hKey-> lpPrev;

                if (hKey == g_RgDynamicKeyList)
                    g_RgDynamicKeyList = hKey-> lpNext;

            }

#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hKey-> pProvider))
                RgSmFreeMemory(hKey-> pProvider);
#endif

            hKey-> Signature = 0;
            RgSmFreeMemory(hKey);

        }

    }

}

//
//  RgValidateAndConvertKeyHandle
//
//  Verifies the the given key handle is valid.  If the handle is one of the
//  special predefined constants, then it is converted to the handle of the
//  real KEY structure.
//

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    )
{

    HKEY hKey;
    UINT Index;
    HKEY hRootKey;
    LPCSTR lpSubKey;

    hKey = *lphKey;

    //
    //  Check if this is one of the predefined key handles.
    //

    if ((DWORD) HKEY_CLASSES_ROOT <= (DWORD) hKey &&
        (DWORD) hKey < (DWORD) HKEY_CLASSES_ROOT + NUMBER_PREDEF_KEYS) {

        Index = (UINT) ((DWORD) hKey - (DWORD) HKEY_CLASSES_ROOT);
        hKey = g_RgPredefinedKeys[Index];

        //  If the predefined handle is not valid, we'll try to (re)open it for
        //  use.  This isn't pretty, but in the typical case, this code path is
        //  only executed once per handle.
        if (IsNullPtr(hKey) || (hKey-> Flags & KEYF_DELETED)) {

            if (Index == INDEX_CLASSES_ROOT) {
                hRootKey = &g_RgLocalMachineKey;
                lpSubKey = g_RgClassesRootSubKey;
            }

            else if (Index == INDEX_CURRENT_USER) {
                hRootKey = &g_RgUsersKey;
                lpSubKey = g_RgCurrentUserSubKey;
            }
#ifndef VXD
			else if (Index == INDEX_USERS) {
				goto ReturnKeyAndSuccess;
			}
#endif
            else
                return ERROR_BADKEY;

            //  Extremely rare case: somebody has deleted one of the predefined
            //  key paths.  We'll clear the predefined bit on this key and throw
            //  it away.
            if (!IsNullPtr(hKey)) {
                g_RgPredefinedKeys[Index] = NULL;
                hKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hKey);
            }

            //  If the base root key for this predefined key is valid, attempt
            //  to open the key.  Mark the key as predefined so that bad apps
            //  can't close a key more times then it has opened it.
            if (!(hRootKey-> Flags & KEYF_INVALID) && RgLookupKey(hRootKey,
                lpSubKey, &hKey, LK_CREATE) == ERROR_SUCCESS) {
                g_RgPredefinedKeys[Index] = hKey;
                hKey-> Flags |= KEYF_PREDEFINED;
                hKey-> PredefinedKeyIndex = (BYTE) Index;
                goto ReturnKeyAndSuccess;
            }

            return ERROR_BADKEY;

        }

ReturnKeyAndSuccess:
        *lphKey = hKey;
        return (hKey-> Flags & KEYF_INVALID) ? ERROR_BADKEY : ERROR_SUCCESS;

    }

    else {

        if (IsBadHugeReadPtr(hKey, sizeof(KEY)) || hKey-> Signature !=
            KEY_SIGNATURE || (hKey-> Flags & KEYF_INVALID))
            return ERROR_BADKEY;

        return (hKey-> Flags & KEYF_DELETED) ? ERROR_KEY_DELETED :
            ERROR_SUCCESS;

    }

}

//
//  RgIncrementKeyReferenceCount
//
//  Safely increments the reference count of the specified KEY.  If the count
//  overflows, then the key is marked as "never delete" since the usage count
//  is now unknown.
//

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    )
{

    if (hKey-> ReferenceCount != UINT_MAX)
        hKey-> ReferenceCount++;
    else {
        if (!(hKey-> Flags & KEYF_NEVERDELETE)) {
            TRACE(("RgIncrementKeyReferenceCount: handle %lx has overflowed\n",
                hKey));
        }
        hKey-> Flags |= KEYF_NEVERDELETE;
    }

}

//
//  RgFindOpenKeyHandle
//
//  Searches the list of currently opened keys for a key that refers to the same
//  FILE_INFO structure and keynode offset.  If found, the HKEY is returned, or
//  if not, NULL.
//

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Check if this is one of the predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey) && hKey-> lpFileInfo == lpFileInfo && hKey->
            KeynodeIndex == KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED |
            KEYF_INVALID)))
            return hKey;

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Check if this is one of the static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo && hKey-> KeynodeIndex ==
                KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED | KEYF_INVALID)))
                return hKey;
        }

    }
#endif

    //
    //  Check if this is one of the dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> KeynodeIndex == KeynodeIndex && hKey-> lpFileInfo ==
                lpFileInfo && !(hKey-> Flags & KEYF_DELETED))
                return hKey;

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

    return NULL;

}

//
//  RgInvalidateKeyHandles
//
//  Generic routine to invalidate key handles based on a set of criteria.
//  If any key handle meets any of the given criteria, then it's marked invalid.
//

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    //
    //  Invalidate predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey)) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Invalidate static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }
#endif

    //
    //  Invalidate dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToKey
//

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hTargetKey,
    HKEY hPredefKey
    )
{

    int ErrorCode;
    UINT PredefinedKeyIndex;
    HKEY hOldKey;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hTargetKey)) ==
        ERROR_SUCCESS) {

        if ((hPredefKey == HKEY_CURRENT_USER && hTargetKey->
            PredefinedKeyIndex == INDEX_USERS) || (hPredefKey ==
            HKEY_CURRENT_CONFIG && hTargetKey-> PredefinedKeyIndex ==
            INDEX_LOCAL_MACHINE)) {

            PredefinedKeyIndex = (UINT) ((DWORD) hPredefKey - (DWORD)
                HKEY_CLASSES_ROOT);

            hOldKey = g_RgPredefinedKeys[PredefinedKeyIndex];

            if (!IsNullPtr(hOldKey)) {

                //  Invalidate open handles based off the existing predefined
                //  key handle.  Win95 behavior.
                RgInvalidateKeyHandles((LPFILE_INFO) -1L, (BYTE)
                    PredefinedKeyIndex);

                hOldKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hOldKey);

            }

            hTargetKey-> Flags |= KEYF_PREDEFINED;
            RgIncrementKeyReferenceCount(hTargetKey);
            g_RgPredefinedKeys[PredefinedKeyIndex] = hTargetKey;

        }

        else {
            DEBUG_OUT(("VMMRegMapPredefKeyToKey: invalid hTargetKey\n"));
            ErrorCode = ERROR_BADKEY;
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regmisc.c ===
//
//  REGMISC.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//

#include "pch.h"
#include "mbstring.h"

//  We MUST calculate the hash consistently between the 16-bit and 32-bit
//  versions of the registry.
#define ToUpperHash(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))

#if 0
//
//  RgChecksum
//

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    LPDWORD lpdwBuffer;
    DWORD Checksum;

    lpdwBuffer = (LPDWORD) lpBuffer;
    ByteCount >>= 2;
    Checksum = 0;

    while (ByteCount) {
        Checksum += *lpdwBuffer++;
        ByteCount--;
    }

    return Checksum;

}
#endif



//
//  RgHashString
//
//  Simple hash computation of a counted string.  All characters less than 0x80
//  0x80 and all DBCS characters are added up.
//
//  We MUST calculate the hash consistently between the 16-bit and
//  32-bit versions of the registry.  We will ignore all extended
//  characters because we cannot uppercase the character in 16-bit
//  mode.
//

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    )
{

    DWORD Hash;
    UINT Byte;

    Hash = 0;

    while (Length) {

        Byte = *((LPBYTE) lpString)++;

        if (IsDBCSLeadByte((BYTE) Byte)) {

            Hash += Byte;
            Length--;
            Hash += *lpString++; // Note that this is a signed char!

        }
        else if (Byte < 0x80)
            Hash += ToUpperHash(Byte);

        Length--;

    }

    return Hash;

}


//
//  RgAtoW
//  Convert an ascii string to a WORD
//

WORD
INTERNAL
RgAtoW(
    LPCSTR lpDec
      )
{
    WORD Dec;

    Dec = 0;

    while (*lpDec >= '0' && *lpDec <= '9') {
        Dec *= 10;
        Dec += *lpDec - '0';
        lpDec++;
    }

    return Dec;
}


//
// RgWtoA
// Convert a WORD to an ascii string
//

VOID
INTERNAL
RgWtoA(
    WORD Dec,
    LPSTR lpDec
      )
{
    WORD Divisor;
    WORD Digit;
    BOOL fSignificant = FALSE;

    Divisor = 10000;

    if (Dec) {
        while (Divisor) {
            Digit = Dec / Divisor;
            Dec -= Digit * Divisor;

            if (Digit)
                fSignificant = TRUE;

            if (fSignificant)
                *lpDec++ = '0' + Digit;

            Divisor /= 10;
        }
    }
    else {
        *lpDec++ = '0';
    }
    *lpDec = '\0';
}


//
//  RgStrCmpNI
//

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    )
{

    int Difference;

    while (Length) {

        if (IsDBCSLeadByte(*lpString1)) {

            Difference = _mbctoupper (_mbsnextc (lpString1))  - _mbctoupper (_mbsnextc (lpString2));

            if (Difference != 0)
                return Difference;

            lpString1+=2;
            lpString2+=2;

            if (Length < 2) {
                break;
            }
            Length -=2;
        }

        else {

            if ((Difference = (int) ToUpper(*lpString1) -
            (int) ToUpper(*lpString2)) != 0)
                return Difference;

            lpString1++;
            lpString2++;
            Length--;

        }

    }

    return 0;
}

//
//  RgCopyFileBytes
//
//  Copies the specified number of bytes from the source to the destination
//  starting at the specified offsets in each file.
//

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    )
{

    int ErrorCode;
    LPVOID lpWorkBuffer;
    UINT cbBytesThisPass;

    ASSERT(hSourceFile != HFILE_ERROR);
    ASSERT(hDestinationFile != HFILE_ERROR);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    lpWorkBuffer = RgLockWorkBuffer();

    if (!RgSeekFile(hSourceFile, SourceOffset))
        goto ErrorUnlockWorkBuffer;

    if (!RgSeekFile(hDestinationFile, DestinationOffset))
        goto ErrorUnlockWorkBuffer;

    while (cbSize) {

        cbBytesThisPass = (UINT) ((DWORD) min(cbSize, SIZEOF_WORK_BUFFER));

        if (!RgReadFile(hSourceFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        if (!RgWriteFile(hDestinationFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        cbSize -= cbBytesThisPass;

    }

    ErrorCode = ERROR_SUCCESS;

ErrorUnlockWorkBuffer:
    RgUnlockWorkBuffer(lpWorkBuffer);
    return ErrorCode;

}

#ifdef WANT_HIVE_SUPPORT
//
//  RgGenerateAltFileName
//

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    )
{

    LPSTR lpString;

    StrCpy(lpAltFileName, lpFileName);
    lpString = lpAltFileName + StrLen(lpAltFileName) - 3;

    *lpString++ = '~';
    *lpString++ = '~';
    *lpString = ExtensionChar;

    return TRUE;

}
#endif

#ifdef VXD

#pragma VxD_RARE_CODE_SEG

//
//  RgCopyFile
//

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    DWORD FileSize;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    if ((hSourceFile = RgOpenFile(lpSourceFile, OF_READ)) != HFILE_ERROR) {

        if ((FileSize = RgGetFileSize(hSourceFile)) != (DWORD) -1) {

            if ((hDestinationFile = RgCreateFile(lpDestinationFile)) !=
                HFILE_ERROR) {

                ErrorCode = RgCopyFileBytes(hSourceFile, 0, hDestinationFile, 0,
                    FileSize);

                RgCloseFile(hDestinationFile);

                if (ErrorCode != ERROR_SUCCESS)
                    RgDeleteFile(lpDestinationFile);

            }

        }

        RgCloseFile(hSourceFile);

    }

    return ErrorCode;

}

#endif // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regmem.c ===
//
//  REGMEM.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Upper-level memory management functions that discards unlocked memory blocks
//  as required to fulfill allocation requests.
//
//  For the ring zero version of this code, only large requests will call these
//  functions.  For most registry files, these requests will already be an
//  integral number of pages, so it's best just to do page allocations.  Small
//  allocations, such as key handles,  will use the heap services and not go
//  through this code.
//
//  For all other models of this code, all memory requests will go through this
//  code and memory is allocated from the heap.
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgMemoryBlockCount);

//  For the ring zero version, only large allocations that should be page
//  aligned will pass through these functions.
#ifdef VXD

//  Converts number of bytes to number of whole pages.
#define ConvertToMemoryUnits(cb)        \
    ((((cb) + (PAGESIZE - 1)) & ~(PAGESIZE - 1)) >> PAGESHIFT)

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgAllocMemoryUnits(
    UINT nPages
    )
{

    return AllocPages(nPages);

}

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgReAllocMemoryUnits(
    LPVOID lpMemory,
    UINT nPages
    )
{

    return ReAllocPages(lpMemory, nPages);

}

#define RgFreeMemoryUnits           FreePages

//  For non-ring zero version of the registry code, all allocations will funnel
//  through these functions.  All allocations are off the heap.
#else
#define ConvertToMemoryUnits(cb)    (cb)
#define RgAllocMemoryUnits          AllocBytes
#define RgReAllocMemoryUnits        ReAllocBytes
#define RgFreeMemoryUnits           FreeBytes
#endif

//
//  RgAllocMemory
//

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    DEBUG_OUT(("RgAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;                    //  Must be NULL if we're here

}

//
//  RgReAllocMemory
//

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpOldMemory,
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(!IsNullPtr(lpOldMemory));
    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    DEBUG_OUT(("RgReAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;

}

#ifdef DEBUG
//
//  RgFreeMemory
//

VOID
INTERNAL
RgFreeMemory(
    LPVOID lpMemory
    )
{

    ASSERT(!IsNullPtr(lpMemory));

    DECREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);

#ifdef ZEROONFREE
    ZeroMemory(lpMemory, MemorySize(lpMemory));
#endif

    RgFreeMemoryUnits(lpMemory);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regqkey.c ===
//
//  REGQKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryInfoKey.
//

#include "pch.h"

//
//  VMMRegQueryInfoKey
//
//  See Win32 documentation of RegQueryInfoKey.  When VXD is defined, this
//  function does not take all of the parameters that we end up ignoring anyway
//  (class, security, timestamp parameters).
//

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData
    )
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData,
    LPVOID lpcbSecurityDescriptor,
    LPVOID lpftLastWriteTime
    )
#endif
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;
    UINT cItems;
    DWORD cbValueData;
    DWORD cbMaxValueData;
    DWORD cbStringLen;
    DWORD cbMaxStringLen;

    if (IsBadHugeOptionalWritePtr(lpcSubKeys, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxSubKeyLen, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcValues, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueName, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    //
    //  Compute cValues, cbMaxValueName, and cbMaxValueData.
    //

    if (!IsNullPtr(lpcValues) || !IsNullPtr(lpcbMaxValueName) ||
        !IsNullPtr(lpcbMaxValueData)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbMaxValueData = 0;

        while ((ErrorCode = RgLookupValueByIndex(hKey, cItems,
            &lpValueRecord)) == ERROR_SUCCESS) {

            cItems++;

            if (lpValueRecord-> NameLength > cbMaxStringLen)
                cbMaxStringLen = lpValueRecord-> NameLength;

            //  RgCopyFromValueRecord will handle static and dynamic keys...
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                NULL, NULL, &cbValueData);

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

            if (ErrorCode != ERROR_SUCCESS)
                goto ReturnErrorCode;

            if (cbValueData > cbMaxValueData)
                cbMaxValueData = cbValueData;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcValues))
                *lpcValues = cItems;

            if (!IsNullPtr(lpcbMaxValueName))
                *lpcbMaxValueName = cbMaxStringLen;

            if (!IsNullPtr(lpcbMaxValueData))
                *lpcbMaxValueData = cbMaxValueData;

            ErrorCode = ERROR_SUCCESS;

        }

    }

    //
    //  Compute cSubKeys and cbMaxSubKeyLen.  Somewhat painful because we must
    //  touch each child keynode and datablock.
    //

    if (!IsNullPtr(lpcSubKeys) || !IsNullPtr(lpcbMaxSubKeyLen)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbStringLen = 0;

        while (TRUE) {
            ErrorCode = RgLookupKeyByIndex(hKey, cItems, NULL,
                &cbStringLen, 0);

            if ((ErrorCode != ERROR_SUCCESS) && (ErrorCode != ERROR_MORE_DATA))
                break;
            cItems++;

            // Win95 compatibility: the old code included the null terminator, even
            // though the documentation for RegQueryInfoKey states that it doesn't.
            if (cbStringLen && (cbStringLen + 1 > cbMaxStringLen))
                cbMaxStringLen = cbStringLen + 1;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcSubKeys))
                *lpcSubKeys = cItems;

            if (!IsNullPtr(lpcbMaxSubKeyLen))
                *lpcbMaxSubKeyLen = cbMaxStringLen;

            ErrorCode = ERROR_SUCCESS;

        }

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

#ifndef VXD
    UNREFERENCED_PARAMETER(lpClass);
    UNREFERENCED_PARAMETER(lpcbClass);
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(lpcbMaxClassLen);
    UNREFERENCED_PARAMETER(lpcbSecurityDescriptor);
    UNREFERENCED_PARAMETER(lpftLastWriteTime);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regqval.c ===
//
//  REGQVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryValue, RegQueryValueEx and supporting functions.
//

#include "pch.h"


//
//  RgLookupValueByName
//  (BIGKEY aware)
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BigKeyLockedBlockIndex
//  It is the callers responsibility to unlock the datablock.  
//
int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT Index;
    LPSTR ExtentKeyName;
    DWORD cbExtentKeyName;

    hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
    ErrorCode = RgLookupValueByNameStd(hKey, lpValueName, lplpKeyRecord, lplpValueRecord);

    // If this is a big key and we couldn't find it in the first key extent, then
    // try the remaining extents.
    if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32 && (hKey->Flags & KEYF_BIGKEYROOT)) {

        if (IsNullPtr(ExtentKeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;
        
        Index = 0;
        
        do {
            cbExtentKeyName = MAXIMUM_SUB_KEY_LENGTH;
            if (RgLookupKeyByIndex(hKey, Index++, ExtentKeyName, &cbExtentKeyName, LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
                goto lFreeKeyName;
            }

            if (RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
                goto lFreeKeyName;
            }

            hKey-> BigKeyLockedBlockIndex = hKeyExtent-> BlockIndex;
            ErrorCode = RgLookupValueByNameStd(hKeyExtent, lpValueName,
                               lplpKeyRecord, lplpValueRecord);

            RgDestroyKeyHandle(hKeyExtent);

        } while (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32);

lFreeKeyName:
        RgSmFreeMemory(ExtentKeyName);
    }

    return ErrorCode;
}


//
//  RgLookupValueByNameStd
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BlockIndex.
//  It is the callers responsibility to unlock the datablock.  
//

int
INTERNAL
RgLookupValueByNameStd(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    UINT ValueNameLength;
    LPVALUE_RECORD lpValueRecord;
    UINT ValuesRemaining;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_CANTREAD16_FILENOTFOUND32;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
        hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT)
            StrLen(lpValueName));

        lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
            lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

        ValuesRemaining = lpKeyRecord-> ValueCount;

        //  Should probably do more sanity checking on lpValueRecord
        while (ValuesRemaining) {

            if (lpValueRecord-> NameLength == ValueNameLength &&
                (ValueNameLength == 0 || RgStrCmpNI(lpValueName, lpValueRecord->
                Name, ValueNameLength) == 0)) {
                *lplpKeyRecord = lpKeyRecord;
                *lplpValueRecord = lpValueRecord;
                return ERROR_SUCCESS;
            }

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                Name + lpValueRecord-> NameLength + lpValueRecord->
                DataLength);

            ValuesRemaining--;

        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;

    }

    return ErrorCode;

}

//
//  RgCopyFromValueRecord
//
//  Shared routine for RegQueryValue and RegEnumValue.  Copies the information
//  from the VALUE_RECORD to the user-provided buffers.  All parameters should
//  have already been validated.
//
//  Because all parameters have been validated, if lpData is valid, then
//  lpcbData MUST be valid.
//

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    UINT BytesToTransfer;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
    struct val_context ValueContext;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    if (IsDynDataKey(hKey)) {

        pProvider = hKey-> pProvider;

        if (IsNullPtr(pProvider))
            return ERROR_CANTOPEN;

        //  The value data contains only part of a PROVIDER structure.
        pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
            lpValueRecord-> NameLength, PVALUE, pv_valuelen);

        if (!IsNullPtr(lpType))
            *lpType = pProviderValue-> pv_type;

        if (!(hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)) {

            BytesToTransfer = pProviderValue-> pv_valuelen;

            if (IsNullPtr(lpData))
                goto ValueDataNotNeeded;

            if (BytesToTransfer > *lpcbData) {
                *lpcbData = BytesToTransfer;
                return ERROR_MORE_DATA;
            }

        //  Win95 compatibility: now that we know the required number of
        //  bytes, validate the data buffer.
        if (IsBadHugeWritePtr(lpData, BytesToTransfer))
        return ERROR_INVALID_PARAMETER;

        }

        ValueContext.value_context = pProviderValue-> pv_value_context;

        if (!IsNullPtr(lpcbData)) {

            //  Zero *lpcbData, if we aren't actually copying any data back to
            //  the user's buffer.  This keeps some providers from stomping on
            //  lpData.
            if (IsNullPtr(lpData))
                *lpcbData = 0;

            if ((ErrorCode = (int) pProvider-> ipi_R0_1val(pProvider->
                ipi_key_context, &ValueContext, 1, lpData, lpcbData, 0)) !=
                ERROR_SUCCESS) {

                //  Win95 compatibility: the old code ignored any errors if
                //  lpData is NULL.  The below ASSERT will verify that we aren't
                //  dropping errors.
                if (!IsNullPtr(lpData))
                    return ErrorCode;

                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

        }

        goto CopyValueName;

    }
#endif

    if (!IsNullPtr(lpType))
        *lpType = lpValueRecord-> DataType;

    BytesToTransfer = lpValueRecord-> DataLength;

    //  The terminating null is not stored in the value record.
    if (lpValueRecord-> DataType == REG_SZ)
        BytesToTransfer++;

    //
    //  Win32 compatibilty: lpData must be filled in before lpValueName.  Word
    //  NT and Excel NT broke when we validated lpValueName and failed the call
    //  before filling in lpData which was valid.  Don't rearrange this code!
    //

    if (!IsNullPtr(lpData)) {

        ErrorCode = ERROR_SUCCESS;

        if (BytesToTransfer > *lpcbData) {
            *lpcbData = BytesToTransfer;
            return ERROR_MORE_DATA;
        }

    //  Win95 compatibility: now that we know the required number of bytes,
    //  validate the data buffer.
        else if (IsBadHugeWritePtr(lpData, BytesToTransfer))
        return ERROR_INVALID_PARAMETER;

        else {

            MoveMemory(lpData, &lpValueRecord-> Name + lpValueRecord->
                NameLength, lpValueRecord-> DataLength);

            if (lpValueRecord-> DataType == REG_SZ)
                lpData[lpValueRecord-> DataLength] = '\0';

        }

    }

#ifdef WANT_DYNKEY_SUPPORT
ValueDataNotNeeded:
#endif
    if (!IsNullPtr(lpcbData))
        *lpcbData = BytesToTransfer;

#ifdef WANT_DYNKEY_SUPPORT
CopyValueName:
#endif
    if (!IsNullPtr(lpValueName)) {

        ErrorCode = ERROR_SUCCESS;

        if (*lpcbValueName <= lpValueRecord-> NameLength) {

            //  Although we will not touch the lpData buffer if it's too small
            //  to hold the value data, we will partially fill lpValueName if
            //  it's too small.
            ErrorCode = ERROR_MORE_DATA;

            if (*lpcbValueName == 0)
                return ErrorCode;

            BytesToTransfer = (UINT) *lpcbValueName - 1;

        }

        else
            BytesToTransfer = lpValueRecord-> NameLength;

        MoveMemory(lpValueName, &lpValueRecord-> Name, BytesToTransfer);
        lpValueName[BytesToTransfer] = '\0';

        //  Does not include terminating null.
        *lpcbValueName = BytesToTransfer;

        return ErrorCode;

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegQueryValueEx
//
//  See Win32 documentation of RegQueryValueEx.
//

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;


    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!IsNullPtr(lpType))
        *lpType = 0;        // assume unknown data type

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
    //  Win95 compatibility: don't validate lpData is of size *lpcbData.
    //  Instead of validating the entire buffer, we'll validate just the
    //  required buffer length in RgCopyFromValueRecord.
    if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        }

        else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

            //
            //  Windows 95 compatibility problem.  If the "value
            //  record" didn't exist in Windows 3.1, then it acted like it was
            //  really a null byte REG_SZ string.  This should have only been
            //  done in RegQueryValue, but we're stuck with it now...
            //

            if (IsNullPtr(lpValueName) || *lpValueName == '\0') {

                if (!IsNullPtr(lpType))
                    *lpType = REG_SZ;

                if (!IsNullPtr(lpData) && *lpcbData > 0)
                    *lpData = 0;

                if (!IsNullPtr(lpcbData))
                    *lpcbData = sizeof(char);

                ErrorCode = ERROR_SUCCESS;

            }

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}

//
//  VMMRegQueryValue
//
//  See Win32 documentation of RegQueryValue.
//

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegQueryValueEx(hSubKey, NULL, NULL, NULL, lpData,
            lpcbData);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\utilw32c.c ===
//
//  UTILW32C.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Win32 environments.
//

#include "pch.h"

//
//  RgCreateTempFile
//
//  Returns the path through lpFileName and a file handle of a temporary file
//  located in the same directory as lpFileName.  lpFileName must specify the
//

HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    )
{

    HFILE hFile;

    if (GetTempFileName(lpFileName, "reg", 0, lpFileName) > 0) {
        if ((hFile = RgOpenFile(lpFileName, OF_WRITE)) != HFILE_ERROR)
            return hFile;
        DeleteFile(lpFileName);
    }

    DEBUG_OUT(("RgCreateTempFile failed\n"));
    return HFILE_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\snapshot\pch.h ===
#include "migshared.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\utilwinc.c ===
//
//  UTILWINC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Windows environments.
//

#include "pch.h"

BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesRead;

    BytesRead = _lread(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesRead;

}

BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesWritten;

    BytesWritten = _lwrite(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesWritten;

}

#ifndef FILE_BEGIN
#define FILE_BEGIN SEEK_SET
#endif

BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    )
{

    LONG NewFileOffset;

    NewFileOffset = _llseek(hFile, FileOffset, FILE_BEGIN);

    return FileOffset == NewFileOffset;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regqmval.c ===
//
//  REGQMVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegQueryMultipleValues and supporting functions.
//

#include "pch.h"

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

#ifdef IS_32

//
//  VMMRegQueryMultipleValues
//
//  See Win32 documentation of RegQueryMultipleValues.  However, the Win95
//  implementation breaks many of the rules that are described in the
//  documentation:
//      *  num_vals is a count of VALENT structures, not a size in bytes.
//      *  data is not DWORD aligned in lpValueBuffer.
//      *  if lpValueBuffer is too small, lpValueBuffer is not filled to the
//         size specified by lpdwTotalSize.
//
//  All of this plus dynamic keys makes this an extremely ugly routine, but
//  every attempt was made to be compatible with the Win95 semantics.
//

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    PVALENT val_list,
    DWORD num_vals,
    LPSTR lpValueBuffer,
    LPDWORD lpdwTotalSize
    )
{

    int ErrorCode;
    PVALENT pCurrentValent;
    DWORD Counter;
    DWORD BufferSize;
    DWORD RequiredSize;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPSTR lpCurrentBuffer;
#ifdef WANT_DYNKEY_SUPPORT
    PVALCONTEXT pValueContext;
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
#endif

    if (IsBadHugeReadPtr(val_list, sizeof(VALENT) * num_vals))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpdwTotalSize, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpValueBuffer, *lpdwTotalSize))
        return ERROR_INVALID_PARAMETER;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {
        if (IsBadStringPtr(pCurrentValent-> ve_valuename, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

#ifdef WANT_DYNKEY_SUPPORT
    //  Check if this a dynamic key that has a "get all" atomic callback.  If
    //  the dynamic key just has "get one" callback, then we'll fall into the
    //  non-dynamic case.
    if (IsDynDataKey(hKey) && !IsNullPtr(hKey-> pProvider-> ipi_R0_allvals)) {

        pProvider = hKey-> pProvider;

        pValueContext = RgSmAllocMemory(sizeof(struct val_context) * num_vals);

        if (IsNullPtr(pValueContext)) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ReturnErrorCode;
        }

        //
        //  Compute the required buffer size to hold all the value data and
        //  check it against the provided buffer size.
        //

        RequiredSize = 0;

        for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
            Counter++, pCurrentValent++) {

            if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
                ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
                goto ReturnErrorCode;

            //  The value data contains only part of a PROVIDER structure.
            pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                lpValueRecord-> NameLength, PVALUE, pv_valuelen);

            pValueContext[Counter].value_context = pProviderValue->
                pv_value_context;
            pCurrentValent-> ve_type = pProviderValue-> pv_type;

            if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH) {

                //  Must zero it so that some providers don't try to stomp on
                //  lpData.
                pCurrentValent-> ve_valuelen = 0;

                ErrorCode = pProvider-> ipi_R0_1val(pProvider-> ipi_key_context,
                    &pValueContext[Counter], 1, NULL, &(pCurrentValent->
                    ve_valuelen), 0);

                //  Providers should really be returning either of these errors
                //  to us.
                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

            else {
                pCurrentValent-> ve_valuelen = pProviderValue-> pv_valuelen;
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

            pCurrentValent-> ve_valueptr = (DWORD) NULL;
            RequiredSize += pCurrentValent-> ve_valuelen;

        }

        BufferSize = *lpdwTotalSize;
        *lpdwTotalSize = RequiredSize;

        if (BufferSize < RequiredSize)
            ErrorCode = ERROR_MORE_DATA;

        else if (pProvider-> ipi_R0_allvals(pProvider-> ipi_key_context,
            pValueContext, num_vals, lpValueBuffer, lpdwTotalSize, 0) !=
            ERROR_SUCCESS)
            ErrorCode = ERROR_CANTREAD;

        else {

            ErrorCode = ERROR_SUCCESS;

            //  Copy the pointers to the value data back to the user's buffer.
            //  Don't ask me why, but the Win95 code copies the value length
            //  back again if the provider is maintaining it.
            for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
                Counter++, pCurrentValent++) {
                pCurrentValent-> ve_valueptr = (DWORD)
                    pValueContext[Counter].val_buff_ptr;
                if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)
                    pCurrentValent-> ve_valuelen = pValueContext[Counter].valuelen;
            }

        }

        RgSmFreeMemory(pValueContext);

        goto ReturnErrorCode;

    }
#endif

    //
    //  First pass over the value names checks for the existence of the value
    //  and its size.  We check the total size against the provided buffer size
    //  and bail out if necessary.
    //

    RequiredSize = 0;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorCode;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
            &(pCurrentValent-> ve_type), NULL, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS)
            goto ReturnErrorCode;

        pCurrentValent-> ve_valueptr = (DWORD) NULL;
        RequiredSize += pCurrentValent-> ve_valuelen;

    }

    BufferSize = *lpdwTotalSize;
    *lpdwTotalSize = RequiredSize;

    if (BufferSize < RequiredSize) {
        ErrorCode = ERROR_MORE_DATA;
        goto ReturnErrorCode;
    }

    //
    //  Second pass copies the value data back to the user's buffer now that we
    //  know the buffer is large enough to contain the data.
    //

    lpCurrentBuffer = lpValueBuffer;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorReading;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL, NULL,
            lpCurrentBuffer, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS) {
ReturnErrorReading:
            TRAP();                     //  Registry is internally inconsistent?
            ErrorCode = ERROR_CANTREAD;
            goto ReturnErrorCode;
        }

        pCurrentValent-> ve_valueptr = (DWORD) lpCurrentBuffer;
        lpCurrentBuffer += pCurrentValent-> ve_valuelen;

    }

    ErrorCode = ERROR_SUCCESS;

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\regw32d\regsval.c ===
//
//  REGSVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegSetValue, RegSetValueEx and supporting functions.
//

#include "pch.h"

//
//  RgReAllocKeyRecord
//

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpOldKeyRecord;
    UINT BlockIndex;
    UINT KeyRecordIndex;
    LPDATABLOCK_INFO lpOldDatablockInfo;
    LPKEYNODE lpKeynode;

    if (Length > MAXIMUM_KEY_RECORD_SIZE) {
        return ERROR_BIGKEY_NEEDED;         // A big key is required
    }

    lpOldKeyRecord = *lplpKeyRecord;

    BlockIndex = HIWORD(lpOldKeyRecord-> DatablockAddress);
    KeyRecordIndex = LOWORD(lpOldKeyRecord-> DatablockAddress);

    //
    //  Check if we can simply extend this key record by taking space from an
    //  adjacent free record.
    //

    if (RgExtendKeyRecord(hKey-> lpFileInfo, BlockIndex, (UINT) Length,
        lpOldKeyRecord) == ERROR_SUCCESS)
        return ERROR_SUCCESS;

    //
    //  Check if there's enough space in the datablock lpCurrKeyRecord is in to
    //  contain a key record of the specified size.  If so, then we don't have
    //  to dirty the keynode.
    //

    if (RgAllocKeyRecordFromDatablock(hKey-> lpFileInfo, BlockIndex,
        (UINT) Length, lplpKeyRecord) == ERROR_SUCCESS) {

        //  After an alloc, we must refetch these pointers because they may be
        //  invalid.
        lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
            BlockIndex);
        lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
            KeyRecordIndex);

        //  Transfer all the data to the new record, except for the allocated
        //  size which is already correctly set.
        MoveMemory(&(*lplpKeyRecord)-> DatablockAddress, &lpOldKeyRecord->
            DatablockAddress, SmallDword(lpOldKeyRecord-> RecordSize) -
            sizeof(DWORD));

        RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);

        //  Update the key record table to point to the new key record.
        lpOldDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
            (LPBYTE) lpOldDatablockInfo-> lpDatablockHeader);

        return ERROR_SUCCESS;

    }

    //
    //  Check if we can allocate a key record from another datablock.  If so,
    //  then copy the key to the other datablock and update the keynode.
    //

    if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode) == ERROR_SUCCESS) {

        if ((ErrorCode = RgAllocKeyRecord(hKey-> lpFileInfo, (UINT) Length,
            lplpKeyRecord)) == ERROR_SUCCESS) {

            //  After an alloc, we must refetch these pointers because they may
            //  be invalid.
            lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
                BlockIndex);
            lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
                KeyRecordIndex);

            //  Transfer all the data to the new record, except for the
            //  allocated size which is already correctly set.
            MoveMemory(&(*lplpKeyRecord)-> RecordSize, &lpOldKeyRecord->
                RecordSize, SmallDword(lpOldKeyRecord-> RecordSize) -
                (sizeof(DWORD) * 2));

            RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);
            RgFreeKeyRecordIndex(lpOldDatablockInfo, KeyRecordIndex);

            //  Unlock the old datablock.
            RgUnlockDatablock(hKey-> lpFileInfo, BlockIndex, TRUE);

            //  Update the open key and keynode to point to the key record in
            //  the new datablock.
            hKey-> BlockIndex = (*lplpKeyRecord)-> BlockIndex;
            hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
            lpKeynode-> BlockIndex = hKey-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) (*lplpKeyRecord)-> KeyRecordIndex;
            lpKeynode-> KeyRecordIndex = hKey-> KeyRecordIndex;

        }

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

        return ErrorCode;

    }

    return ERROR_OUTOFMEMORY;

}


//
//  RgSetValue
//  (BIGKEY aware)
//

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT Index;
    LPSTR ExtentKeyName;
    DWORD cbExtentKeyName;
    WORD NameID = 1;
    WORD MaxNameID = 0;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPKEYNODE lpKeynode;
    BOOL fTryRoot = FALSE;


    ErrorCode = RgSetValueStd(hKey, lpValueName, Type, lpData, cbData, FALSE);

    if (ErrorCode == ERROR_BIGKEY_NEEDED)
    {
        //
        // Couldn't fit the value in the key, make it a big key
        // (if it isn't one already)
        //


        // First delete its old value if it exists
        ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord);

        if (ErrorCode == ERROR_SUCCESS)
        {
            // If a value record already existed, and it was not in the root of the big key
            // then we should try inserting the new value record into the root, after deleting
            // it from its old location.
            if (hKey-> BigKeyLockedBlockIndex != hKey-> BlockIndex)
                fTryRoot = TRUE;

            RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);
        }
        else if (ErrorCode != ERROR_CANTREAD16_FILENOTFOUND32) {
            return ERROR_OUTOFMEMORY;
        }

        if (IsNullPtr(ExtentKeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;

        // Second, search for room in each of the big key's extents
        // (we should never mark the root with an LK_BIGKEYEXT, otherwise it won't be found
        // by RgLookupKey and RgLookupKeyByIndex)
        if ((hKey-> Flags & KEYF_BIGKEYROOT)) {
            if (fTryRoot) {
                // This happens if the value record previously existed in a big key extension,
                // but the new value record doesn't fit in the same extension, so we want to try
                // the root of the big key.
                if ((ErrorCode = RgSetValueStd(hKey, lpValueName, Type, lpData, cbData, TRUE)) ==
                    ERROR_SUCCESS) {
                    goto lFreeKeyName;
                }
            }

            Index = 0;
        
            do {
                cbExtentKeyName = MAXIMUM_SUB_KEY_LENGTH;
                if (RgLookupKeyByIndex(hKey, Index++, ExtentKeyName, &cbExtentKeyName, LK_BIGKEYEXT) !=
                    ERROR_SUCCESS) {
                    goto lGrowKey;
                }

                NameID = RgAtoW(ExtentKeyName);

                if (NameID > MaxNameID)
                    MaxNameID = NameID;

                if (RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                    goto lGrowKey;
                }

                ErrorCode = RgSetValueStd(hKeyExtent, lpValueName, Type, lpData, cbData, TRUE);

                RgDestroyKeyHandle(hKeyExtent);

            } while (ErrorCode == ERROR_BIGKEY_NEEDED);

            goto lFreeKeyName;
        }

        // Third, make it a big key, or if it is a big key, then grow it
lGrowKey:
        // Create a unique name for the big key extent
        if (MaxNameID)
            NameID = MaxNameID + 1;

        RgWtoA(NameID, ExtentKeyName);

        if ((ErrorCode = RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_CREATE)) ==
            ERROR_SUCCESS) {

            // Mark the parent as the big key root, if it isn't already
            if (!(hKey-> Flags & KEYF_BIGKEYROOT))
            {
                if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    goto lFreeKeyName;

                lpKeynode-> Flags |= KNF_BIGKEYROOT;
                hKey-> Flags |= KEYF_BIGKEYROOT;

                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);
            }

            // Mark the new key as a big key extent
            if ((ErrorCode = RgLockInUseKeynode(hKeyExtent-> lpFileInfo, hKeyExtent-> KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                goto lFreeKeyName;

            lpKeynode-> Flags |= KNF_BIGKEYEXT;
            
            RgUnlockKeynode(hKeyExtent-> lpFileInfo, hKeyExtent-> KeynodeIndex, TRUE);

            // Now add the value record to the new key
            ErrorCode = RgSetValueStd(hKeyExtent, lpValueName, Type, lpData, cbData, TRUE);

            ASSERT(ErrorCode != ERROR_BIGKEY_NEEDED);
            RgDestroyKeyHandle(hKeyExtent);
        }

lFreeKeyName:
        RgSmFreeMemory(ExtentKeyName);

        if (ErrorCode == ERROR_BIGKEY_NEEDED)
            ErrorCode = ERROR_OUTOFMEMORY;
    }

    return ErrorCode;
}


//
//  RgSetValueStd
//

int
INTERNAL
RgSetValueStd(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData,
    BOOL fBigKeyExtent
    )
{

    int ErrorCode;
    UINT ValueNameLength;
    UINT NewValueRecordLength;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    UINT CurrentValueRecordLength;
    LPBYTE lpDestination;
    UINT BytesToExtend;
    UINT TempCount;
    LPKEYNODE lpKeynode;

    ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT) StrLen(lpValueName));

    if (ValueNameLength > MAXIMUM_VALUE_NAME_LENGTH - 1)
        return ERROR_INVALID_PARAMETER;

    NewValueRecordLength = sizeof(VALUE_RECORD) + ValueNameLength + cbData - 1;

    if (!fBigKeyExtent) {
        ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord);
    }
    else {
        // If we didn't find it searching from the root of a bigkey, then we won't
        // find it beginning from an extent.
        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
    }

    //
    //  A value with this name already exists, so update the existing
    //  VALUE_RECORD with the new information.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        CurrentValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord->
            NameLength + lpValueRecord-> DataLength - 1;

        // Is the value record staying the same?
        if (NewValueRecordLength == CurrentValueRecordLength) {
            if (lpValueRecord-> DataLength == cbData && lpValueRecord->
                DataType == Type && CompareMemory((LPBYTE) lpValueRecord->
                Name + ValueNameLength, lpData, cbData) == 0) {
                RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);
                return ERROR_SUCCESS;
            }
        }

        // Is the value record shrinking?
        if (NewValueRecordLength < CurrentValueRecordLength) {
            lpKeyRecord-> RecordSize -= (CurrentValueRecordLength -
                NewValueRecordLength);
        }

        // Is the value record growing?
        else if (NewValueRecordLength > CurrentValueRecordLength) {

            BytesToExtend = NewValueRecordLength - CurrentValueRecordLength;

            // Does the value record fit in the allocated key size?
            if (BytesToExtend > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                TempCount = (LPBYTE) lpValueRecord - (LPBYTE) lpKeyRecord;

                // Grow the key record
                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + BytesToExtend, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex,
                        FALSE);
                    return ErrorCode;
                }

                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                    TempCount);

            }

            lpKeyRecord-> RecordSize += BytesToExtend;

        }

        lpDestination = (LPBYTE) lpValueRecord + NewValueRecordLength;
        TempCount = (UINT) ((LPBYTE) lpKeyRecord + SmallDword(lpKeyRecord->
            RecordSize) - lpDestination);

        if (TempCount > 0) {
            MoveMemory(lpDestination, (LPBYTE) lpValueRecord +
                CurrentValueRecordLength, TempCount);
        }

    }

    //
    //  No value exists with this name.  Place a new VALUE_RECORD at the end of
    //  the KEY_RECORD.
    //

    else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  We don't check if this is really the root key, but it doesn't
        //  matter much.
        if (IsNullBlockIndex(hKey-> BlockIndex)) {

            if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                &lpKeynode) != ERROR_SUCCESS)
                goto LockKeynodeFailed;

            if (RgAllocKeyRecord(hKey-> lpFileInfo, sizeof(KEY_RECORD) +
                NewValueRecordLength, &lpKeyRecord) != ERROR_SUCCESS) {
                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);
LockKeynodeFailed:
                TRAP();
                return ERROR_CANTOPEN;          //  Win95 compatibility
            }

            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD);
            lpKeyRecord-> NameLength = 1;       //  Win95 compatibility
            lpKeyRecord-> Name[0] = '\0';       //  Win95 compatibility
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            lpKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;

            hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

            RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

            ErrorCode = ERROR_SUCCESS;
            goto AddValueRecord;

        }

        if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
            hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

            if (NewValueRecordLength > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + NewValueRecordLength, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

            }

AddValueRecord:
            hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                SmallDword(lpKeyRecord-> RecordSize));
            lpKeyRecord-> RecordSize += NewValueRecordLength;
            lpKeyRecord-> ValueCount++;

        }

    }

    //
    //  If we're successful at this point, then lpValueRecord is valid and we
    //  should copy the data into this record.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        lpValueRecord-> DataType = Type;

        lpValueRecord-> NameLength = (WORD) ValueNameLength;
        MoveMemory(lpValueRecord-> Name, lpValueName, ValueNameLength);

        lpValueRecord-> DataLength = (WORD) cbData;
        MoveMemory((LPBYTE) lpValueRecord-> Name + ValueNameLength, lpData,
            cbData);

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);

    }

    return ErrorCode;

}

//
//  VMMRegSetValueEx
//
//  See Win32 documentation of RegSetValueEx.
//

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    int ErrorCode;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    //
    //  bad Windows 95 compatibility problem.  If the type is REG_SZ,
    //  then override cbData with the length of the string pointed to by lpData.
    //  This should have only been done in RegSetValue, but we're stuck with it
    //  now...
    //

    if (Type == REG_SZ) {
        if (IsBadStringPtr(lpData, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
        cbData = StrLen(lpData);

        // Must leave room for the null terminator
        if (cbData >= MAXIMUM_DATA_LENGTH)
                return ERROR_INVALID_PARAMETER;
    }
    else {
        if (cbData > 0 && IsBadHugeReadPtr(lpData, cbData))
            return ERROR_INVALID_PARAMETER;
    }

    if (cbData > MAXIMUM_DATA_LENGTH)
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {
        if (IsDynDataKey(hKey) || (hKey-> lpFileInfo-> Flags & FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else {
            if ((ErrorCode = RgSetValue(hKey, lpValueName, Type, lpData,
                (UINT) cbData)) == ERROR_SUCCESS) {
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }
        }
    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(Reserved);

}

//
//  VMMRegSetValue
//
//  See Win32 documentation of RegSetValue.
//

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_CREATE)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegSetValueEx(hSubKey, NULL, 0, REG_SZ, lpData, 0);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(cbData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\win95reg\pch.h ===
#define COMMON_INCLUDES
#include "migshared.h"
#include "regapix.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\win95reg\win95regp.h ===
#include "migshared.h"
#include "regapix.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\snapshot\snapshot.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    snapshot.c

Abstract:

    Implements a memdb-based snapshot of all files, directories, registry keys and
    registry values.

Author:

    Jim Schmidt (jimschm) 13-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "migshared.h"

#define S_SNAPSHOT_A        "Snapshot"

BOOL
pGetFullKeyA (
    IN OUT  PSTR Object
    )
{
    MEMDB_ENUMA e;
    CHAR Pattern[MEMDB_MAX];
    PSTR p;

    wsprintfA (Pattern, "%s*", Object);
    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY)) {
        p = _mbsrchr (Object, TEXT('\\'));
        if (p) {
            p = _mbsinc (p);
        } else {
            p = Object;
        }

        StringCopyA (p, e.szName);
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
pSnapDirsA (
    IN      PCSTR Drive,
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    TREE_ENUMA FileEnum;
    CHAR Node[MEMDB_MAX];
    DWORD Value;

    //
    // Enumerate the file system
    //

    if (EnumFirstFileInTreeA (&FileEnum, Drive, NULL, TRUE)) {
        do {
            wsprintfA (
                Node,
                "%s\\%s\\%u\\%u%u",
                S_SNAPSHOT_A,
                FileEnum.FullPath,
                FileEnum.FindData->nFileSizeLow,
                FileEnum.FindData->ftLastWriteTime.dwHighDateTime,
                FileEnum.FindData->ftLastWriteTime.dwLowDateTime
                );

            if (!DiffMode) {
                MemDbSetValueA (Node, SNAP_RESULT_DELETED);
            } else {
                Value = SNAP_RESULT_UNCHANGED;
                if (!MemDbGetValueA (Node, NULL)) {
                    if (DiffHandle) {
                        WriteFileStringA (DiffHandle, FileEnum.FullPath);
                        WriteFileStringA (DiffHandle, "\r\n");
                    }

                    wsprintfA (Node, "%s\\%s,", S_SNAPSHOT_A, FileEnum.FullPath);

                    Value = SNAP_RESULT_CHANGED;
                    if (!pGetFullKeyA (Node)) {
                        wsprintfA (
                            Node,
                            "%s\\%s\\%u\\%u%u",
                            S_SNAPSHOT_A,
                            FileEnum.FullPath,
                            FileEnum.FindData->nFileSizeLow,
                            FileEnum.FindData->ftLastWriteTime.dwHighDateTime,
                            FileEnum.FindData->ftLastWriteTime.dwLowDateTime
                            );
                        Value = SNAP_RESULT_ADDED;
                    }
                }
                MemDbSetValueA (Node, Value);
            }
        } while (EnumNextFileInTreeA (&FileEnum));
    }
}

VOID
pSnapAllDrivesA (
    IN      BOOL DiffMode,
    IN      HANDLE  DiffHandle      OPTIONAL
    )
{
    CHAR Drives[256];
    MULTISZ_ENUMA e;

    if (GetLogicalDriveStringsA (256, Drives)) {
        if (EnumFirstMultiSzA (&e, Drives)) {
            do {
                if (DRIVE_FIXED == GetDriveTypeA (e.CurrentString)) {
                    pSnapDirsA (e.CurrentString, DiffMode, DiffHandle);
                    break;
                }
            } while (EnumNextMultiSzA (&e));
        }
    }
}

VOID
pSnapRegistryHiveA (
    IN      PCSTR Hive,
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    REGTREE_ENUMA RegEnum;
    REGVALUE_ENUMA RegValue;
    CHAR Node[MEMDB_MAX];
    PBYTE Data;
    DWORD Checksum;
    PBYTE p;
    UINT Count;
    DWORD Value;

    if (EnumFirstRegKeyInTreeA (&RegEnum, Hive)) {
        do {
            wsprintfA (
                Node,
                "%s\\%s",
                S_SNAPSHOT_A,
                RegEnum.FullKeyName
                );

            if (!DiffMode) {
                MemDbSetValueA (Node, SNAP_RESULT_DELETED);
            } else {
                if (!MemDbGetValueA (Node, NULL)) {
                    if (DiffHandle) {
                        WriteFileStringA (DiffHandle, RegEnum.FullKeyName);
                        WriteFileStringA (DiffHandle, "\r\n");
                    }
                } else {
                    MemDbSetValueA (Node, SNAP_RESULT_UNCHANGED);
                }
            }

            if (EnumFirstRegValueA (&RegValue, RegEnum.CurrentKey->KeyHandle)) {
                do {
                    Data = GetRegValueData (RegValue.KeyHandle, RegValue.ValueName);
                    if (!Data) {
                        continue;
                    }

                    Checksum = RegValue.Type;
                    p = Data;

                    for (Count = 0 ; Count < RegValue.DataSize ; Count++) {
                        Checksum = (Checksum << 1) | (Checksum >> 31) | *p;
                        p++;
                    }

                    MemFree (g_hHeap, 0, Data);

                    wsprintfA (
                        Node,
                        "%s\\%s\\[%s],%u",
                        S_SNAPSHOT_A,
                        RegEnum.FullKeyName,
                        RegValue.ValueName,
                        Checksum
                        );

                    if (!DiffMode) {
                        MemDbSetValueA (Node, SNAP_RESULT_DELETED);
                    } else {
                        Value = SNAP_RESULT_UNCHANGED;
                        if (!MemDbGetValueA (Node, NULL)) {
                            WriteFileStringA (DiffHandle, RegEnum.FullKeyName);
                            WriteFileStringA (DiffHandle, " [");
                            WriteFileStringA (DiffHandle, RegValue.ValueName);
                            WriteFileStringA (DiffHandle, "]\r\n");

                            wsprintfA (
                                Node,
                                "%s\\%s\\[%s],",
                                S_SNAPSHOT_A,
                                RegEnum.FullKeyName,
                                RegValue.ValueName
                                );

                            Value = SNAP_RESULT_CHANGED;
                            if (!pGetFullKeyA (Node)) {
                                wsprintfA (
                                    Node,
                                    "%s\\%s\\[%s],%u",
                                    S_SNAPSHOT_A,
                                    RegEnum.FullKeyName,
                                    RegValue.ValueName,
                                    Checksum
                                    );
                                Value = SNAP_RESULT_ADDED;
                            }
                        }

                        MemDbSetValueA (Node, Value);
                    }

                } while (EnumNextRegValueA (&RegValue));
            }

        } while (EnumNextRegKeyInTreeA (&RegEnum));
    }
}

VOID
pSnapRegistryA (
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    pSnapRegistryHiveA (TEXT("HKLM"), DiffMode, DiffHandle);
    pSnapRegistryHiveA (TEXT("HKU"), DiffMode, DiffHandle);
}

VOID
TakeSnapShotEx (
    IN      DWORD SnapFlags
    )
{
    MemDbCreateTemporaryKeyA (S_SNAPSHOT_A);

    if (SnapFlags & SNAP_FILES) {
        pSnapAllDrivesA (FALSE, NULL);
    }
    if (SnapFlags & SNAP_REGISTRY) {
        pSnapRegistryA (FALSE, NULL);
    }
}

BOOL
GenerateDiffOutputExA (
    IN      PCSTR FileName,
    IN      PCSTR Comment,      OPTIONAL
    IN      BOOL Append,
    IN      DWORD SnapFlags
    )
{
    HANDLE File = NULL;
    MEMDB_ENUMA e;

    if (FileName) {
        File = CreateFileA (
                   FileName,
                   GENERIC_WRITE,
                   0,
                   NULL,
                   Append ? OPEN_ALWAYS : CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );

        if (File == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s for output", FileName));
            return FALSE;
        }

        if (Append) {
            SetFilePointer (File, 0, NULL, FILE_END);
        }

        if (Comment) {
            WriteFileStringA (File, Comment);
            WriteFileStringA (File, "\r\n");
        }

        WriteFileStringA (File, "Changes:\r\n");
    }

    if (SnapFlags & SNAP_FILES) {
        pSnapAllDrivesA (TRUE, File);
    }

    if (SnapFlags & SNAP_REGISTRY) {
        pSnapRegistryA (TRUE, File);
    }

    if (File) {
        WriteFileStringA (File, "\r\nDeleted Settings:\r\n");

        if (MemDbGetValueExA (&e, S_SNAPSHOT_A, NULL, NULL)) {
            do {
                if (e.dwValue == SNAP_RESULT_DELETED) {
                    WriteFileStringA (File, e.szName);
                    WriteFileStringA (File, "\r\n");
                }
            } while (MemDbEnumNextValue (&e));
        }

        WriteFileStringA (File, "\r\nEnd.\r\n\r\n");

        CloseHandle (File);
    }

    return TRUE;
}


BOOL
EnumFirstSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e,
    IN      PCSTR FilePattern,   OPTIONAL
    IN      DWORD SnapStatus
    )
{
    CHAR node[MEMDB_MAX];

    e->FilePattern = FilePattern;
    e->SnapStatus = SnapStatus;
    e->FirstCall = TRUE;
    MemDbBuildKeyA (node, S_SNAPSHOT_A, "*", NULL, NULL);

    if (!MemDbEnumFirstValue (&(e->mEnum), node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        return FALSE;
    }
    return EnumNextSnapFileA (e);
}

BOOL
EnumNextSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e
    )
{
    PSTR lastWack;

    while (e->FirstCall?(e->FirstCall = FALSE, TRUE):MemDbEnumNextValue (&(e->mEnum))) {
        StringCopyA (e->FileName, e->mEnum.szName);
        lastWack = _mbsrchr (e->FileName, '\\');
        if (lastWack) {
            *lastWack = 0;
            lastWack = _mbsrchr (e->FileName, '\\');
            if (lastWack) {
                *lastWack = 0;
            }
        }
        if (e->FilePattern && (!IsPatternMatch (e->FilePattern, e->FileName))) {
            continue;
        }
        if ((e->SnapStatus & e->mEnum.dwValue) == 0) {
            continue;
        }
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\moricons\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for the
    DOS PIF Setup icons resource DLL.

Author:

    Sunil Pai (sunilp) Feb 5, 1992

Revision History:

--*/

#include <windows.h>

HANDLE ThisDLLHandle;

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\win95reg\reg95.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    regutils.c

Abstract:

    Implements wrappers similar to migutil's reg.c, but for Win95 registry.

Author:

    Jim Schmidt (jimschm)  30-Jan-1998

Revisions:

--*/

#include "pch.h"
#include "win95regp.h"

#ifdef DEBUG
#undef Win95RegCloseKey
#endif

#define DBG_REGUTILS     "RegUtils"

//
// Private prototypes
//

BOOL
pPopRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr
    );

BOOL
pPopRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr
    );

//
// Implementation
//


/*++

Routine Description:

  EnumFirstRegKey95A and EnumFirstRegKey95W begin an enumeration of registry
  subkeys.  They initialize the registy enumeration structure and
  call the registry APIs to enumerate subkeys of the specified key handle.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  Key       - Specifies the handle of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegKey95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKey95A (EnumPtr);
}


BOOL
EnumFirstRegKey95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKey95W (EnumPtr);
}


/*++

Routine Description:

  OpenRegKeyStr95A and OpenRegKeyStr95W parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStr95A (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKey95A (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = RealOpenRegKey95A (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);
    return Key;
}


HKEY
RealOpenRegKeyStr95W (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStr95A (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}


/*++

Routine Description:

  EnumFirstRegKeyStr95A and EnumFirstRegKeyStr95W start an enumeration of
  subkeys within the given key.  In these functions, the key is specified
  via a string instead of an HKEY value.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  RegKey    - Specifies the full path of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
RealEnumFirstRegKeyStr95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStr95A (RegKey /* , */ DEBUG_TRACKING_ARGS);

    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKey95A (EnumPtr, Key);
    if (!b) {
        CloseRegKey95 (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


BOOL
RealEnumFirstRegKeyStr95W (
    IN      PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStr95W (RegKey /* , */ DEBUG_TRACKING_ARGS);
    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKey95W (EnumPtr, Key);
    if (!b) {
        CloseRegKey95 (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


/*++

Routine Description:

  AbortRegKeyEnum95A and AbortRegKeyEnum95W release all resources associated
  with a registry subkey enumeration.  Call this function to stop the
  enumeration before it completes by itself.

Arguments:

  EnumPtr   - Specifies the enumeration to stop.  Receives the updated
              state of enumeration.

Return Value:


  none

--*/

VOID
AbortRegKeyEnum95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey95 (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


VOID
AbortRegKeyEnum95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey95 (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


/*++

Routine Description:

  EnumNextRegKey95A and EnumNextRegKey95W continue an enumeration started by
  one of the subkey enumeration routines above.  If all items have been
  enumerated, this function cleans up all resources and returns FALSE.

Arguments:

  EnumPtr   - Specifies the enumeration to continue.  Receives the updated
              state of enumeration.  The structure can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegKey95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    LONG rc;

    rc = Win95RegEnumKeyA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYA
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey95 (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegKey95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    LONG rc;

    rc = Win95RegEnumKeyW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYW
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey95 (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
pPushRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr,
    IN      PCSTR KeyName
    )
{
    PREGKEYINFOA RetVal;
    PSTR p;

    RetVal = (PREGKEYINFOA) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOA)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOA));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyA (p, "\\");
        EnumPtr->FullKeyNameBytes += ByteCountA (p);
        p = _mbsinc (p);
    }

    _mbssafecpy (p, KeyName, MAX_REGISTRY_KEYA - EnumPtr->FullKeyNameBytes);
    EnumPtr->FullKeyNameBytes += ByteCountA (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _mbssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYA);
    RetVal->KeyHandle = OpenRegKeyStr95A (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfo95A (EnumPtr);
        return FALSE;
    }

    return TRUE;
}


BOOL
pPushRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR KeyName
    )
{
    PREGKEYINFOW RetVal;
    PWSTR p;

    RetVal = (PREGKEYINFOW) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOW)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOW));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyW (p, L"\\");
        EnumPtr->FullKeyNameBytes += ByteCountW (p);
        p++;
    }

    _wcssafecpy (p, KeyName, MAX_REGISTRY_KEYW - (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)));
    EnumPtr->FullKeyNameBytes += ByteCountW (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _wcssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYW);
    RetVal->KeyHandle = OpenRegKeyStr95W (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfo95W (EnumPtr);
        return FALSE;
    }

    return TRUE;
}



BOOL
pPopRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr
    )
{
    PREGKEYINFOA FreeMe;
    PSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey95 (FreeMe->KeyHandle);
    }

    AbortRegKeyEnum95A (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
pPopRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr
    )
{
    PREGKEYINFOW FreeMe;
    PWSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey95 (FreeMe->KeyHandle);
    }

    AbortRegKeyEnum95W (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
RealEnumFirstRegKeyInTree95A (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMA));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTree95A");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfo95A (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REGUTILS, "EnumFirstRegKeyInTree95A failed to push base key"));
        AbortRegKeyTreeEnum95A (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountA (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree95 knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumFirstRegKeyInTree95W (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMW));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTree95W");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfo95W (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REGUTILS, "EnumFirstRegKeyInTree95W failed to push base key"));
        AbortRegKeyTreeEnum95W (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountW (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree95 knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumNextRegKeyInTree95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    while (TRUE) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKey95A (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKey95A (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfo95A (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnum95A (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfo95A (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGA ((
                    DBG_REGUTILS,
                    "EnumFirstRegKeyInTree95A failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (CHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


BOOL
RealEnumNextRegKeyInTree95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    while (TRUE) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKey95W (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKey95W (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfo95W (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnum95W (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfo95W (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGW ((
                    DBG_REGUTILS,
                    "EnumFirstRegKeyInTree95A failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (WCHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


VOID
AbortRegKeyTreeEnum95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfo95A (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}


VOID
AbortRegKeyTreeEnum95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfo95W (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}



/*++

Routine Description:

  EnumFirstRegValue95A and EnumerateFirstRegvalueW enumerate the first registry
  value name in the specified subkey.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  hKey      - Specifies handle of registry subkey to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegValue95A (
    IN      PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValue95A (EnumPtr);
}


BOOL
EnumFirstRegValue95W (
    IN      PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValue95W (EnumPtr);
}


/*++

Routine Description:

  EnumNextRegValue95A and EnumNextRegValue95W continue the enumeration started
  by EnumFirstRegValue95A/W.  The enumeration structure is updated to
  reflect the next value name in the subkey being enumerated.

Arguments:

  EnumPtr   - Specifies the registry subkey and enumeration position.
              Receives the updated state of enumeration.  The structure
              can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegValue95A (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEA;

    rc = Win95RegEnumValueA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegValue95W (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEW;

    rc = Win95RegEnumValueW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}



PVOID
pMemAllocWrapper95 (
    IN      DWORD Size
    )

/*++

Routine Description:

  pMemAllocWrapper95 implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
pMemFreeWrapper95 (
    IN      PVOID Mem
    )

/*++

Routine Description:

  pMemFreeWrapper95 implements a default deallocation routine.
  See pMemAllocWrapper95 above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        pMemAllocWrapper95 function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueDataEx95A and GetRegValueDataEx95W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  Free  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof (CHAR));
    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


PBYTE
GetRegValueDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }


    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfTypeEx95A and GetRegValueDataOfTypeEx95W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  Alloc - Specifies the allocation routine, called to allocate the return data.

  Free - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfTypeEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = Win95RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS || Type != MustBeType) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof (CHAR));
    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


PBYTE
GetRegValueDataOfTypeEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = Win95RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS || Type != MustBeType) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


/*++

Routine Description:

  GetRegKeyDataEx95A and GetRegKeyDataEx95W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  Alloc  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  Free   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyDataEx95A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKey95A (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueDataEx95A (SubKeyHandle, "", Alloc, Free);

    CloseRegKey95 (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyDataEx95W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKey95W (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueDataEx95W (SubKeyHandle, L"", Alloc, Free);

    CloseRegKey95 (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegDataEx95A and GetRegDataEx95W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  Alloc - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  Free  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegDataEx95A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStr95A (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueDataEx95A (Key, ValueName, Alloc, Free);

    CloseRegKey95 (Key);

    return Data;
}


PBYTE
GetRegDataEx95W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStr95W (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueDataEx95W (Key, ValueName, Alloc, Free);

    CloseRegKey95 (Key);

    return Data;
}


/*++

Routine Description:

  OpenRegKey95A and OpenRegKey95W open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealOpenRegKey95A (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyEx95A (
             ParentKey,
             KeyToOpen,
             0,
             KEY_ALL_ACCESS,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKey95W (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyEx95W (
             ParentKey,
             KeyToOpen,
             0,
             KEY_ALL_ACCESS,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


LONG
RealCloseRegKey95 (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey95 closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey95 macro resolves directly
  to this function in the free build, and to OurCloseRegKey95 in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    return Win95RegCloseKey (Key);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\win95reg\reg95trk.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  w95track.c

Abstract:

  Routines to track calls to Win95Reg APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  30-Jan-1998

Revisions:


--*/


#include "pch.h"
#include "win95regp.h"

#ifdef DEBUG


#undef Win95RegOpenKeyExA
#undef Win95RegCreateKeyExA
#undef Win95RegOpenKeyExW
#undef Win95RegCreateKeyExW

#define DBG_W95TRACK "W95Track"

#define NO_MATCH        0xffffffff

DWORD g_DontCare95;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList95 = GROWLIST_INIT;

DWORD
pFindKeyReference95 (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList95);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList95, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
pAddKeyReference95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList95, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
pAddKeyReference95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    pAddKeyReference95A (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference95 (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference95 (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList95, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys95 (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList95);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList95, d);
        DEBUGMSG ((DBG_W95TRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate95 (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList95);
}

VOID
DebugRegOpenRootKey95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReference95A (Key, SubKey, File, Line);
}


VOID
DebugRegOpenRootKey95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReference95W (Key, SubKey, File, Line);
}


LONG
DebugRegOpenKeyEx95A (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = Win95RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        pAddKeyReference95A (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
DebugRegOpenKeyEx95W (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = Win95RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        pAddKeyReference95W (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
DebugCloseRegKey95 (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey95 (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference95 (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey95, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\win95reg\win95reg.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    win95reg.c

Abstract:

    Implements Win95-registry access functions callable from Win95 or WinNT.

Author:

    MCondra, 16 Oct 1996

Revision History:

    jimschm     11-Feb-1999     Rewrite of portions because of DBCS bugs
                                and static array problems
    calinn      29-Jan-1998     Added Win95RegOpenKeyStr function

--*/



#include "pch.h"
#include "win95regp.h"

#define DBG_WIN95REG    "Win95Reg"



#ifdef UNICODE
#error "UNICODE builds not supported"
#endif

//
// Undefine tracking macros
//

#ifdef DEBUG

#undef Win95RegOpenKeyExA
#undef Win95RegOpenKeyExW
#undef Win95RegCloseKey

#endif

//
// Define globals for Win95 registry wrappers
//

#define DEFMAC(fn,name)     P##fn Win95##name;

REGWRAPPERS

#undef DEFMAC


#ifdef RegOpenKeyA

#undef RegOpenKeyA
#undef RegOpenKeyW
#undef RegOpenKeyExA
#undef RegOpenKeyExW

#endif


//
// Declare VMM W versions
//

REG_ENUM_KEY_W pVmmRegEnumKeyW;
REG_ENUM_KEY_EX_A pVmmRegEnumKeyExA;
REG_ENUM_KEY_EX_W pVmmRegEnumKeyExW;
REG_ENUM_VALUE_W pVmmRegEnumValueW;
REG_LOAD_KEY_W pVmmRegLoadKeyW;
REG_UNLOAD_KEY_W pVmmRegUnLoadKeyW;
REG_OPEN_KEY_W pVmmRegOpenKeyW;
REG_CLOSE_KEY pVmmRegCloseKey;
REG_OPEN_KEY_EX_A pVmmRegOpenKeyExA;
REG_OPEN_KEY_EX_W pVmmRegOpenKeyExW;
REG_QUERY_INFO_KEY_W pVmmRegQueryInfoKeyW;
REG_QUERY_VALUE_W pVmmRegQueryValueW;
REG_QUERY_VALUE_EX_W pVmmRegQueryValueExW;

VOID
pCleanupTempUser (
    VOID
    );

BOOL
pIsCurrentUser (
    IN      PCSTR UserNameAnsi
    );

LONG
pWin95RegSetCurrentUserCommonW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,               OPTIONAL
    OUT     PWSTR UserDatOut,                   OPTIONAL
    IN      PCWSTR UserDat                      OPTIONAL
    );

LONG
pWin95RegSetCurrentUserCommonA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,                OPTIONAL
    OUT     PSTR UserDatOut,                    OPTIONAL
    IN      PCSTR UserDat                       OPTIONAL
    );

LONG
pReplaceWinDirInPath (
    IN      PSTR ProfilePathMunged,
    IN      PCSTR ProfilePath,
    IN      PCSTR NewWinDir
    );

DWORD
pSetDefaultUserHelper (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller            OPTIONAL
    );


BOOL g_IsNt;
CHAR g_SystemHiveDir[MAX_MBCHAR_PATH];
CHAR g_SystemUserHive[MAX_MBCHAR_PATH];
BOOL g_UnloadLastUser = FALSE;
PCSTR g_UserKey;
BOOL g_UseClassesRootHive = FALSE;
HKEY g_ClassesRootKey = NULL;



//
// Wrappers of tracking API
//

LONG
pOurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr
    )
{
    return TrackedRegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
}

LONG
pOurRegOpenKeyA (
    HKEY Key,
    PCSTR SubKey,
    PHKEY Result
    )
{
    return TrackedRegOpenKeyA (Key, SubKey, Result);
}


LONG
WINAPI
pOurCloseRegKey (
    HKEY Key
    )
{
    return CloseRegKey (Key);
}


//
// Platform-dependent functions
//

VOID
InitWin95RegFnPointers (
    VOID
    )
{
    OSVERSIONINFO vi;

    vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&vi);

    g_IsNt = (vi.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (g_IsNt) {

        //
        //  Attach to VMM registry library
        //

        VMMRegLibAttach(0);

        //
        // Initialize global function pointers for NT
        //

        Win95RegFlushKey = VMMRegFlushKey;

        Win95RegEnumKeyA = VMMRegEnumKey;
        Win95RegEnumKeyW = pVmmRegEnumKeyW;

        Win95RegEnumKeyExA = pVmmRegEnumKeyExA;
        Win95RegEnumKeyExW = pVmmRegEnumKeyExW;

        Win95RegEnumValueA = VMMRegEnumValue;
        Win95RegEnumValueW = pVmmRegEnumValueW;

        Win95RegLoadKeyA = VMMRegLoadKey;
        Win95RegLoadKeyW = pVmmRegLoadKeyW;

        Win95RegUnLoadKeyA = VMMRegUnLoadKey;
        Win95RegUnLoadKeyW = pVmmRegUnLoadKeyW;

        Win95RegOpenKeyA = VMMRegOpenKey;
        Win95RegOpenKeyW = pVmmRegOpenKeyW;

        Win95RegOpenKeyExA = pVmmRegOpenKeyExA;
        Win95RegOpenKeyExW = pVmmRegOpenKeyExW;

        Win95RegCloseKey = pVmmRegCloseKey;

        Win95RegQueryInfoKeyA = VMMRegQueryInfoKey;
        Win95RegQueryInfoKeyW = pVmmRegQueryInfoKeyW;

        Win95RegQueryValueA = (PREG_QUERY_VALUE_A)VMMRegQueryValue;
        Win95RegQueryValueW = pVmmRegQueryValueW;

        Win95RegQueryValueExA = VMMRegQueryValueEx;
        Win95RegQueryValueExW = pVmmRegQueryValueExW;

    } else {
        //
        // Initialize global function pointers for NT
        //

        Win95RegFlushKey = RegFlushKey;

        Win95RegEnumKeyA = RegEnumKeyA;
        Win95RegEnumKeyW = RegEnumKeyW;

        Win95RegEnumKeyExA = RegEnumKeyExA;
        Win95RegEnumKeyExW = RegEnumKeyExW;

        Win95RegEnumValueA = RegEnumValueA;
        Win95RegEnumValueW = RegEnumValueW;

        Win95RegLoadKeyA = RegLoadKeyA;
        Win95RegLoadKeyW = RegLoadKeyW;

        Win95RegUnLoadKeyA = RegUnLoadKeyA;
        Win95RegUnLoadKeyW = RegUnLoadKeyW;

        Win95RegOpenKeyA = pOurRegOpenKeyA;
        Win95RegOpenKeyW = RegOpenKeyW;

        Win95RegOpenKeyExA = pOurRegOpenKeyExA;
        Win95RegOpenKeyExW = RegOpenKeyExW;

        Win95RegCloseKey = pOurCloseRegKey;

        Win95RegQueryInfoKeyA = RegQueryInfoKeyA;
        Win95RegQueryInfoKeyW = RegQueryInfoKeyW;

        Win95RegQueryValueA = RegQueryValueA;
        Win95RegQueryValueW = RegQueryValueW;

        Win95RegQueryValueExA = RegQueryValueExA;
        Win95RegQueryValueExW = RegQueryValueExW;

        //
        // Clear away HKLM\Migration
        //

        RegUnLoadKey(
            HKEY_LOCAL_MACHINE,
            S_MIGRATION
            );

        pSetupRegistryDelnode (
            HKEY_LOCAL_MACHINE,
            S_MIGRATION
            );
    }
}


VOID
Win95RegTerminate (
    VOID
    )
{
#ifdef DEBUG
    DumpOpenKeys95();
    RegTrackTerminate95();
#endif

    if (!g_IsNt) {
        pCleanupTempUser();
    } else {
        VMMRegLibDetach();
    }
}



BOOL
WINAPI
Win95Reg_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        InitWin95RegFnPointers();
    } else if (dwReason == DLL_PROCESS_DETACH) {
        Win95RegTerminate();
        pSetupUninitializeUtils();
    }

    return TRUE;
}


LONG
pVmmRegEnumKeyW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR KeyName,
    IN      DWORD KeyNameSize
    )
{
    PSTR AnsiBuf;
    LONG rc;
    UINT Chars;

    AnsiBuf = AllocTextA (KeyNameSize);
    MYASSERT (AnsiBuf);

    rc = VMMRegEnumKey (Key, Index, AnsiBuf, KeyNameSize);

    if (rc == ERROR_SUCCESS) {

        Chars = LcharCountA (AnsiBuf);

        //
        // Special case: if Chars is zero, then we have 1/2 of a DBCS char.
        //

        if (!Chars && *AnsiBuf) {
            if (KeyNameSize < 4) {
                rc = ERROR_MORE_DATA;
            }

            KeyName[0] = *AnsiBuf;
            KeyName[1] = 0;

        } else {

            //
            // Normal case
            //

            if (Chars >= KeyNameSize / sizeof (WCHAR)) {
                rc = ERROR_MORE_DATA;
            } else {
                KnownSizeDbcsToUnicodeN (KeyName, AnsiBuf, Chars);
            }

        }
    }

    FreeTextA (AnsiBuf);

    return rc;
}


LONG
pVmmRegEnumValueW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR ValueName,
    IN OUT  PDWORD ValueNameChars,
            PDWORD Reserved,
    OUT     PDWORD Type,                OPTIONAL
    OUT     PBYTE Data,                 OPTIONAL
    IN OUT  PDWORD DataSize             OPTIONAL
    )
{
    PSTR AnsiValueName;
    LONG rc;
    PSTR AnsiData;
    UINT DataChars;
    UINT ValueChars;
    DWORD OurType;
    DWORD OrgValueNameChars;
    DWORD OrgDataSize;
    DWORD OurValueNameChars;
    DWORD OurValueNameCharsBackup;
    DWORD AnsiDataSize;
    BOOL HalfDbcs = FALSE;

    __try {
        MYASSERT (ValueNameChars);
        MYASSERT (ValueName);

        OrgValueNameChars = *ValueNameChars;
        OrgDataSize = DataSize ? *DataSize : 0;

        OurValueNameChars = min (*ValueNameChars, MAX_REGISTRY_VALUE_NAMEA);
        OurValueNameCharsBackup = OurValueNameChars;

        AnsiValueName = AllocTextA (OurValueNameChars);
        MYASSERT (AnsiValueName);

        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper calculation of DataSize.
            //

            rc = VMMRegEnumValue (
                    Key,
                    Index,
                    AnsiValueName,
                    &OurValueNameChars,
                    NULL,
                    &OurType,
                    NULL,
                    DataSize
                    );

            OurValueNameChars = OurValueNameCharsBackup;

            if (rc == ERROR_SUCCESS) {

                if (OurType == REG_SZ || OurType == REG_EXPAND_SZ || OurType == REG_MULTI_SZ) {
                    *DataSize += 2;
                    AnsiData = AllocTextA (*DataSize);
                }
            } else {
                //
                // Value name must be too small
                //

                __leave;
            }
        }

        rc = VMMRegEnumValue (
                Key,
                Index,
                AnsiValueName,
                &OurValueNameChars,
                NULL,
                &OurType,
                AnsiData,
                DataSize
                );

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Return the type
        //

        if (Type) {
            *Type = OurType;
        }

        //
        // Return the sizes
        //

        if (rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA) {

            //
            // The inbound value name size is in characters, including the nul.
            // The outbound value name size is also in characteres, excluding
            // the nul.
            //

            ValueChars = LcharCountA (AnsiValueName);

            //
            // Special case: if ValueChars is zero, and AnsiValueName is
            // not empty, then we have half of a DBCS character.
            //

            if (!ValueChars && *AnsiValueName) {
                ValueChars = 1;
                HalfDbcs = TRUE;
            }

            *ValueNameChars = ValueChars;
        }

        if (DataSize) {

            if (rc == ERROR_SUCCESS) {

                //
                // The inbound data size is in bytes, including any nuls that apply.
                // The outbound data size is the same.
                //

                if (AnsiData) {

                    MYASSERT (Data ||
                              OurType == REG_SZ ||
                              OurType == REG_EXPAND_SZ ||
                              OurType == REG_MULTI_SZ
                              );

                    //
                    // If the type is a string, then DataSize needs adjustment.
                    //

                    if (OurType == REG_SZ || OurType == REG_EXPAND_SZ || OurType == REG_MULTI_SZ) {
                        DataChars = LcharCountInByteRangeA (AnsiData, AnsiDataSize);
                        *DataSize = DataChars * sizeof (WCHAR);
                    }
                }

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }

            } else if (rc == ERROR_MORE_DATA) {

                //
                // Get the correct DataSize value
                //

                pVmmRegEnumValueW (
                    Key,
                    Index,
                    ValueName,
                    ValueNameChars,
                    NULL,
                    NULL,
                    NULL,
                    DataSize
                    );

                __leave;
            }
        }

        //
        // Convert the outbound strings
        //

        if (rc == ERROR_SUCCESS) {

            //
            // Convert value name
            //

            if (ValueChars >= OrgValueNameChars) {
                rc = ERROR_MORE_DATA;
            } else {
                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (ValueName, AnsiValueName, ValueChars);
                } else {
                    ValueName[0] = *AnsiValueName;
                    ValueName[1] = 0;
                }
            }

            //
            // Convert data
            //

            if (Data) {

                MYASSERT (AnsiData);

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    DirectDbcsToUnicodeN (
                        (PWSTR) Data,
                        AnsiData,
                        AnsiDataSize
                        );

                } else {

                    CopyMemory (Data, AnsiData, AnsiDataSize);

                }
            }
        }
    }
    __finally {

        FreeTextA (AnsiValueName);
        FreeTextA (AnsiData);
    }

    return rc;
}


LONG
pVmmRegLoadKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    IN      PCWSTR FileName
    )
{
    PCSTR AnsiSubKey;
    PCSTR AnsiFileName;
    LONG rc;

    AnsiSubKey = ConvertWtoA (SubKey);
    AnsiFileName = ConvertWtoA (FileName);

    rc = VMMRegLoadKey (Key, AnsiSubKey, AnsiFileName);

    FreeConvertedStr (AnsiSubKey);
    FreeConvertedStr (AnsiFileName);

    return rc;
}


LONG
pVmmRegUnLoadKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey
    )
{
    PCSTR AnsiSubKey;
    LONG rc;

    AnsiSubKey = ConvertWtoA (SubKey);

    rc = VMMRegUnLoadKey (Key, AnsiSubKey);

    FreeConvertedStr (AnsiSubKey);

    return rc;
}


LONG
pVmmRegOpenKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    OUT     HKEY *KeyPtr
    )
{
    PCSTR AnsiSubKey;
    LONG rc;
    CHAR mappedSubKey[MAXIMUM_SUB_KEY_LENGTH];
    PCSTR MappedAnsiSubKey;

    MappedAnsiSubKey = AnsiSubKey = ConvertWtoA (SubKey);
    //
    // if g_UseClassesRootHive is set, then perform some translations
    //
    if (g_UseClassesRootHive) {
        if (Key == HKEY_LOCAL_MACHINE) {
            if (StringIMatchTcharCountA (
                    AnsiSubKey,
                    "SOFTWARE\\Classes",
                    sizeof ("SOFTWARE\\Classes") - 1
                    )) {

                StringCopyByteCountA (
                    mappedSubKey,
                    AnsiSubKey + sizeof ("SOFTWARE\\Classes") - 1,
                    MAXIMUM_SUB_KEY_LENGTH
                    );

                Key = g_ClassesRootKey;
                MappedAnsiSubKey = mappedSubKey;
                if (*MappedAnsiSubKey == '\\') {
                    MappedAnsiSubKey++;
                }
            }
        } else if (Key == HKEY_CLASSES_ROOT) {
            Key = g_ClassesRootKey;
        }
    }

    rc = VMMRegOpenKey (Key, MappedAnsiSubKey, KeyPtr);

    FreeConvertedStr (AnsiSubKey);

    return rc;
}


LONG
pVmmRegCloseKey (
    IN      HKEY Key
    )
{
    if (g_UseClassesRootHive) {
        if (Key == g_ClassesRootKey) {
            return ERROR_SUCCESS;
        }
    }

    return VMMRegCloseKey (Key);
}


LONG
pVmmRegEnumKeyExA (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PSTR KeyName,
    IN OUT  PDWORD KeyNameSize,
            PDWORD Reserved,
    OUT     PSTR Class,                     OPTIONAL
    IN OUT  PDWORD ClassSize,               OPTIONAL
    OUT     PFILETIME LastWriteTime         OPTIONAL
    )
{
    LONG rc;

    MYASSERT (KeyNameSize);
    MYASSERT (KeyName);

    rc = VMMRegEnumKey (
            Key,
            Index,
            KeyName,
            *KeyNameSize
            );

    if (rc == ERROR_SUCCESS) {
        //
        // Return length of key name, excluding delimiter
        //
        *KeyNameSize = ByteCount (KeyName);

        //
        // Return zero-length class
        //
        if (Class && *ClassSize) {
            *Class = 0;
        }

        if (ClassSize) {
            *ClassSize = 0;
        }

        //
        // Stuff last-write time with zero
        //
        if (LastWriteTime) {
            ZeroMemory (LastWriteTime, sizeof (FILETIME));
        }

    } else {
        *KeyNameSize = MAX_PATH + 1;

        if (ClassSize) {
            *ClassSize = 0;
        }
    }

    return rc;
}


LONG
pVmmRegEnumKeyExW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR KeyName,
    IN OUT  PDWORD KeyNameSize,
            PDWORD Reserved,
    OUT     PWSTR Class,                    OPTIONAL
    IN OUT  PDWORD ClassSize,               OPTIONAL
    OUT     PFILETIME LastWriteTime         OPTIONAL
    )
{
    LONG rc;
    PSTR AnsiKeyName;
    PSTR AnsiClass;
    UINT Chars;
    DWORD OrgKeyNameSize;
    DWORD OrgClassSize;
    BOOL HalfDbcs = FALSE;

    __try {
        MYASSERT (KeyName);
        MYASSERT (KeyNameSize);

        AnsiKeyName = AllocTextA (*KeyNameSize);

        if (Class) {
            MYASSERT (ClassSize);
            AnsiClass = AllocTextA (*ClassSize);
        } else {
            AnsiClass = NULL;
        }

        OrgKeyNameSize = *KeyNameSize;
        OrgClassSize = ClassSize ? *ClassSize : 0;

        rc = pVmmRegEnumKeyExA (
                Key,
                Index,
                AnsiKeyName,
                KeyNameSize,
                NULL,
                AnsiClass,
                ClassSize,
                LastWriteTime
                );

        if (rc == ERROR_SUCCESS) {

            Chars = LcharCountA (AnsiKeyName);

            //
            // Special case: If Chars is zero, but AnsiKeyName is not empty,
            // then we have 1/2 of a DBCS character.
            //

            if (!Chars && *AnsiKeyName) {
                Chars = 1;
                HalfDbcs = TRUE;
            }

            *KeyNameSize = Chars;

            if (Chars >= OrgKeyNameSize / sizeof (WCHAR)) {
                rc = ERROR_MORE_DATA;
                __leave;
            }

            if (!HalfDbcs) {
                KnownSizeDbcsToUnicodeN (KeyName, AnsiKeyName, Chars);
            } else {
                KeyName[0] = *AnsiKeyName;
                KeyName[1] = 0;
            }

            HalfDbcs = FALSE;

            if (Class) {

                Chars = LcharCountA (AnsiClass);

                //
                // Special case: If Chars is zero, but AnsiClass is not empty,
                // then we have 1/2 of a DBCS character.
                //

                if (!Chars && *AnsiClass) {
                    Chars = 1;
                    HalfDbcs = TRUE;
                }

                *ClassSize = Chars;

                if (Chars >= OrgClassSize / sizeof (WCHAR)) {
                    rc = ERROR_MORE_DATA;
                    __leave;
                }

                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (Class, AnsiClass, Chars);
                } else {
                    Class[0] = *AnsiClass;
                    Class[1] = 0;
                }
            }
        }
    }
    __finally {
        FreeTextA (AnsiKeyName);
        FreeTextA (AnsiClass);
    }

    return rc;
}


LONG
pVmmRegOpenKeyExA (
    IN      HKEY Key,
    IN      PCSTR SubKey,
    IN      DWORD Options,
    IN      REGSAM SamDesired,
    OUT     HKEY *KeyPtr
    )
{
    CHAR mappedSubKey[MAXIMUM_SUB_KEY_LENGTH];
    PCSTR MappedSubKey = SubKey;

    //
    // if g_UseClassesRootHive is set, then perform some translations
    //
    if (g_UseClassesRootHive) {
        if (Key == HKEY_LOCAL_MACHINE) {
            if (StringIMatchByteCountA (
                    SubKey,
                    "SOFTWARE\\Classes",
                    sizeof ("SOFTWARE\\Classes") - 1
                    )) {

                StringCopyByteCountA (
                    mappedSubKey,
                    SubKey + sizeof ("SOFTWARE\\Classes") - 1,
                    MAXIMUM_SUB_KEY_LENGTH
                    );

                Key = g_ClassesRootKey;
                MappedSubKey = mappedSubKey;
                if (*MappedSubKey == '\\') {
                    MappedSubKey++;
                }
            }
        } else if (Key == HKEY_CLASSES_ROOT) {
            Key = g_ClassesRootKey;
        }
    }

    return VMMRegOpenKey (Key, MappedSubKey, KeyPtr);
}


LONG
pVmmRegOpenKeyExW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    IN      DWORD Options,
    IN      REGSAM SamDesired,
    OUT     HKEY *KeyPtr
    )
{
    return pVmmRegOpenKeyW (Key, SubKey, KeyPtr);
}


LONG
pVmmRegQueryInfoKeyW (
    IN      HKEY Key,
    OUT     PWSTR Class,                    OPTIONAL
    OUT     PDWORD ClassSize,               OPTIONAL
    OUT     PDWORD Reserved,                OPTIONAL
    OUT     PDWORD SubKeys,                 OPTIONAL
    OUT     PDWORD MaxSubKeyLen,            OPTIONAL
    OUT     PDWORD MaxClassLen,             OPTIONAL
    OUT     PDWORD Values,                  OPTIONAL
    OUT     PDWORD MaxValueName,            OPTIONAL
    OUT     PDWORD MaxValueData,            OPTIONAL
    OUT     PVOID SecurityDescriptor,       OPTIONAL
    OUT     PVOID LastWriteTime             OPTIONAL
    )
{
    PSTR AnsiClass;
    LONG rc = ERROR_NOACCESS;
    UINT Chars;
    DWORD OrgClassSize;
    BOOL HalfDbcs = FALSE;

    __try {

        if (Class) {
            MYASSERT (ClassSize);
            AnsiClass = AllocTextA (*ClassSize);
            if (!AnsiClass) {
                __leave;
            }
        } else {
            AnsiClass = NULL;
        }

        OrgClassSize = ClassSize ? *ClassSize : 0;

        rc = VMMRegQueryInfoKey (
                Key,
                AnsiClass,
                ClassSize,
                Reserved,
                SubKeys,
                MaxSubKeyLen,
                MaxClassLen,
                Values,
                MaxValueName,
                MaxValueData,
                SecurityDescriptor,
                LastWriteTime
                );

        if (MaxValueData) {
            *MaxValueData *= 2;
        }

        if (rc == ERROR_SUCCESS) {
            if (Class) {

                Chars = LcharCountA (AnsiClass);

                //
                // Special case: If Chars is zero, but AnsiClass is not empty,
                // then we have 1/2 of a DBCS character.
                //

                if (!Chars && *AnsiClass) {
                    Chars = 1;
                    HalfDbcs = TRUE;
                }

                *ClassSize = Chars;

                if (Chars >= OrgClassSize / sizeof (WCHAR)) {
                    rc = ERROR_MORE_DATA;
                    __leave;
                }

                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (Class, AnsiClass, Chars);
                } else {
                    Class[0] = *AnsiClass;
                    Class[1] = 0;
                }
            }
        }
    }
    __finally {
        FreeTextA (AnsiClass);
    }

    return rc;
}


LONG
pVmmRegQueryValueW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    OUT     PWSTR Data,         OPTIONAL
    IN OUT  PLONG DataSize      OPTIONAL
    )
{
    PSTR AnsiData;
    PCSTR AnsiSubKey;
    LONG rc;
    UINT Chars;
    LONG OrgDataSize;
    DWORD AnsiDataSize;

    __try {
        AnsiSubKey = ConvertWtoA (SubKey);
        OrgDataSize = DataSize ? *DataSize : 0;
        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper computation of DataSize.
            //

            rc = VMMRegQueryValue (
                    Key,
                    AnsiSubKey,
                    NULL,
                    DataSize
                    );

            if (rc == ERROR_SUCCESS) {

                *DataSize += 2;
                AnsiData = AllocTextA (*DataSize);

            } else {
                //
                // An error usually means the sub key does not exist...
                //

                __leave;
            }
        }

        rc = VMMRegQueryValue (Key, AnsiSubKey, AnsiData, DataSize);

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Adjust the outbound size
        //

        if (DataSize) {
            if (rc == ERROR_SUCCESS) {

                Chars = LcharCountInByteRangeA (AnsiData, AnsiDataSize);

                MYASSERT (DataSize);
                *DataSize = (Chars + 1) * sizeof (WCHAR);

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }

            } else if (rc == ERROR_MORE_DATA) {

                pVmmRegQueryValueW (Key, SubKey, NULL, DataSize);
                __leave;

            }
        }

        //
        // Convert the return strings
        //

        if (rc == ERROR_SUCCESS) {

            MYASSERT (AnsiData);

            if (Data) {

                DirectDbcsToUnicodeN ((PWSTR) Data, AnsiData, AnsiDataSize);

            } else {

                // BUGBUG -- what was meant by this totally bogus fn call?
                //CopyMemory (Data, AnsiData, AnsiDataSize);

            }
        }
    }
    __finally {
        FreeTextA (AnsiData);
        FreeConvertedStr (AnsiSubKey);
    }

    return rc;
}


LONG
pVmmRegQueryValueExW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
            PDWORD Reserved,
    OUT     PDWORD Type,            OPTIONAL
    OUT     PBYTE Data,             OPTIONAL
    IN OUT  PDWORD DataSize         OPTIONAL
    )
{
    LONG rc;
    UINT Chars;
    PCSTR AnsiValueName;
    PSTR AnsiData;
    DWORD OurType;
    DWORD OrgDataSize;
    DWORD AnsiDataSize;

    __try {
        AnsiValueName = ConvertWtoA (ValueName);
        OrgDataSize = DataSize ? *DataSize : 0;
        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper computation of DataSize.
            //

            rc = VMMRegQueryValueEx (
                    Key,
                    AnsiValueName,
                    NULL,
                    &OurType,
                    NULL,
                    DataSize
                    );

            if (rc == ERROR_SUCCESS) {

                //
                // *DataSize is a byte count, but increase it to
                // accomodate multisz termination
                //

                *DataSize += 2;
                AnsiData = AllocTextA (*DataSize);

            } else {
                //
                // An error usually means the value does not exist...
                //

                __leave;
            }
        }

        rc = VMMRegQueryValueEx (
                Key,
                AnsiValueName,
                NULL,
                &OurType,
                AnsiData,
                DataSize
                );

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Return the type
        //

        if (Type) {
            *Type = OurType;
        }

        //
        // Return the sizes
        //

        if (DataSize) {
            if (rc == ERROR_SUCCESS) {

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    AnsiData[*DataSize] = 0;
                    AnsiData[*DataSize + 1] = 0;

                    Chars = LcharCountInByteRangeA (AnsiData, AnsiDataSize);
                    *DataSize = Chars * sizeof (WCHAR);
                }

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }
            } else if (rc == ERROR_MORE_DATA) {
                //
                // Get the correct data size
                //

                pVmmRegQueryValueExW (
                    Key,
                    ValueName,
                    NULL,
                    NULL,
                    NULL,
                    DataSize
                    );

                __leave;
            }
        }

        //
        // Convert the return strings
        //

        if (rc == ERROR_SUCCESS) {

            if (Data) {

                MYASSERT (AnsiData);

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    DirectDbcsToUnicodeN ((PWSTR) Data, AnsiData, AnsiDataSize);

                } else {

                    CopyMemory (Data, AnsiData, AnsiDataSize);

                }
            }
        }
    }
    __finally {
        FreeConvertedStr (AnsiValueName);
        FreeTextA (AnsiData);
    }

    return rc;
}



LONG
Win95RegInitA (
    IN      PCSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    )
{
    LONG rc = ERROR_SUCCESS;
    CHAR SystemDatPath[MAX_MBCHAR_PATH];
    CHAR ConfigKey[MAX_REGISTRY_KEY];
    CHAR ConfigVersion[256];
    HKEY Key;
    DWORD Size;

    //
    // Save the system hive dir
    //

    StringCopyA (g_SystemHiveDir, SystemHiveDir);
    AppendWackA (g_SystemHiveDir);

    //
    // Save the system user.dat
    //

    StringCopyA (g_SystemUserHive, g_SystemHiveDir);
    StringCatA (g_SystemUserHive, "user.dat");

    //
    // If NT, set up HKLM and HKU
    //

    if (g_IsNt) {

        __try {
            Key = NULL;

            StringCopyA (SystemDatPath, g_SystemHiveDir);
            StringCatA (SystemDatPath, "system.dat");

            rc = VMMRegMapPredefKeyToFile (HKEY_LOCAL_MACHINE, SystemDatPath, 0);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be loaded", SystemDatPath));
                __leave;
            }

            if (UseClassesRootHive) {

                StringCopyA (SystemDatPath, g_SystemHiveDir);
                StringCatA (SystemDatPath, "classes.dat");

                rc = VMMRegLoadKey (
                        HKEY_LOCAL_MACHINE,
                        "SOFTWARE$Classes",
                        SystemDatPath
                        );

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "%s could not be loaded", SystemDatPath));
                    __leave;
                }

                rc = VMMRegOpenKey (
                        HKEY_LOCAL_MACHINE,
                        "SOFTWARE$Classes",
                        &g_ClassesRootKey
                        );

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "%s could not be opened", "SOFTWARE$Classes"));
                    __leave;
                }

                g_UseClassesRootHive = TRUE;
            }

            rc = VMMRegMapPredefKeyToFile (HKEY_USERS, g_SystemUserHive, 0);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be loaded", g_SystemUserHive));
                __leave;
            }

            rc = Win95RegOpenKeyA (
                    HKEY_LOCAL_MACHINE,
                    "System\\CurrentControlSet\\control\\IDConfigDB",
                    &Key
                    );

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "IDConfigDB could not be opened"));
                __leave;
            }

            Size = sizeof (ConfigVersion);

            rc = Win95RegQueryValueExA (
                    Key,
                    "CurrentConfig",
                    NULL,
                    NULL,
                    (PBYTE) ConfigVersion,
                    &Size
                    );

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "CurrentConfig could not be queried"));
                __leave;
            }

            StringCopyA (ConfigKey, "Config\\");
            StringCatA (ConfigKey, ConfigVersion);

            Win95RegCloseKey (Key);
            rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, ConfigKey, &Key);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be opened", ConfigKey));

                rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, "Config", &Key);
                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "No Win9x hardware configuration keys available"));
                    Key = NULL;
                    __leave;
                }

                Size = 256;
                rc = Win95RegEnumKeyExA (
                        Key,
                        0,
                        ConfigVersion,
                        &Size,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                Win95RegCloseKey (Key);

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "Can't enumerate Win9x hardware configuration keys"));
                    Key = NULL;
                    __leave;
                }

                StringCopyA (ConfigKey, "Config\\");
                StringCatA (ConfigKey, ConfigVersion);
                rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, ConfigKey, &Key);

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "Can't open enumerated Win9x hardware configuration key"));
                    Key = NULL;
                    __leave;
                }
            }

            rc = VMMRegMapPredefKeyToKey (Key, HKEY_CURRENT_CONFIG);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "HKCC could not be mapped"));
                __leave;
            }

        }
        __finally {
            if (Key) {
                Win95RegCloseKey (Key);
            }
        }
    }

    if (rc != ERROR_SUCCESS) {
        LOGA ((LOG_ERROR, "Registry files from previous operating system are damaged or missing"));
    }

    return rc;
}


LONG
Win95RegInitW (
    IN      PCWSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    )
{
    LONG rc;
    PCSTR AnsiSystemHiveDir;

    AnsiSystemHiveDir = ConvertWtoA (SystemHiveDir);

    //
    // Call ANSI version of function
    //
    rc = Win95RegInitA (AnsiSystemHiveDir, UseClassesRootHive);

    FreeConvertedStr (AnsiSystemHiveDir);

    return rc;
}


#define GU_VALID 0x5538

LONG
Win95RegGetFirstUserA (
    PUSERPOSITION Pos,
    PSTR UserNameAnsi
    )
{
    DWORD rc = ERROR_SUCCESS;
    DWORD Size;
    DWORD Enabled;
    HKEY Key;

    MYASSERT (UserNameAnsi);
    MYASSERT (Pos);

    //
    // Initialize profile enumeration state (USERPOSITION)
    //
    ZeroMemory (Pos, sizeof (USERPOSITION));
    Pos->Valid = GU_VALID;

    //
    // See whether registry supports per-user profiles.
    //
    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, "Network\\Logon", &Key);

    if (rc == ERROR_SUCCESS) {

        Size = sizeof (DWORD);

        rc = Win95RegQueryValueExA (
                Key,
                "UserProfiles",
                NULL,
                NULL,
                (PBYTE) &Enabled,
                &Size
                );

        Pos->UseProfile = (rc == ERROR_SUCCESS && Enabled);

        //
        // Identify the last logged-on user.
        //

        Size = sizeof (Pos->LastLoggedOnUserName);
        rc = Win95RegQueryValueExA (
                Key,
                "UserName",
                NULL,
                NULL,
                Pos->LastLoggedOnUserName,
                &Size
                );

        if (rc == ERROR_SUCCESS) {
            #pragma prefast(suppress:56, "source and dest are the same, no buffer overrun possible")
            OemToCharA (Pos->LastLoggedOnUserName, Pos->LastLoggedOnUserName);

            if (!Pos->UseProfile || Win95RegIsValidUser (NULL, Pos->LastLoggedOnUserName)) {
                Pos->LastLoggedOnUserNameExists = TRUE;
            } else {
                Pos->LastLoggedOnUserName[0] = 0;
            }
        }

        Win95RegCloseKey (Key);
    }

    //
    // On a common-profile machine, we'll return the last logged-on user name.
    // If no last logged-on user exists, or if the path to this registry value
    // doesn't exist, we'll return "", meaning "no user". Both cases are considered
    // valid.
    //

    if (!Pos->UseProfile) {
        //
        // Success.
        //

        _mbssafecpy (UserNameAnsi, Pos->LastLoggedOnUserName, MAX_USER_NAMEA);
        //StringCopyA (UserNameAnsi, Pos->LastLoggedOnUserName);

        if (UserNameAnsi[0]) {
            Pos->NumPos = 1;
        }

        Pos->IsLastLoggedOnUserName = Pos->LastLoggedOnUserNameExists;
        return ERROR_SUCCESS;
    }

    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &Key);

    if (rc != ERROR_SUCCESS) {

        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE

        //
        // This error code change was added by MikeCo.  It likely doesn't
        // do anything useful.
        //

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        //
        // Find the first valid profile
        //

        Win95RegQueryInfoKeyA (Key, NULL, NULL, NULL, &Pos->NumPos, NULL, NULL,
                               NULL, NULL, NULL, NULL, NULL);

        if (Pos->NumPos > 0) {

            do {

                Size = MAX_USER_NAMEA;

                rc = Win95RegEnumKeyExA (
                        Key,
                        Pos->CurPos,
                        UserNameAnsi,
                        &Size,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                if (rc != ERROR_SUCCESS) {
                    Pos->NumPos = 0;
                    break;
                }

                if (Win95RegIsValidUser (Key, UserNameAnsi)) {

                    Pos->IsLastLoggedOnUserName = StringIMatch (
                                                    UserNameAnsi,
                                                    Pos->LastLoggedOnUserName
                                                    );
                    break;

                }

                Pos->CurPos++;

            } while (Pos->CurPos < Pos->NumPos);

            if (Pos->CurPos >= Pos->NumPos) {
                Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
            }
        }

        Win95RegCloseKey (Key);
    }

    DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "WIN95REG: Error getting first user"));

    return rc;
}


LONG
Win95RegGetNextUserA (
    PUSERPOSITION Pos,
    PSTR UserNameAnsi
    )
{
    DWORD Size;
    LONG rc = ERROR_SUCCESS;
    HKEY Key;

    MYASSERT (Pos && GU_VALID == Pos->Valid);
    MYASSERT (UserNameAnsi);

    Pos->IsLastLoggedOnUserName = FALSE;

    //
    // On a common-profile machine, this function always returns
    // "no more users", since the call to Win95RegGetFirstUserA/W
    // returned the only named user (the logged-on user, if it
    // exists).
    //
    if (!Pos->UseProfile) {
        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
        return rc;
    }

    //
    // Open key to profile list
    //
    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &Key);

    if (rc != ERROR_SUCCESS) {
        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
    } else {

        Pos->CurPos++;

        while (Pos->CurPos < Pos->NumPos) {

            //
            // Get first user's key name
            //
            Size = MAX_USER_NAMEA;

            rc = Win95RegEnumKeyExA(
                    Key,
                    Pos->CurPos,
                    UserNameAnsi,
                    &Size,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

            if (rc != ERROR_SUCCESS) {
                Pos->NumPos = 0;
                break;
            }

            if (Win95RegIsValidUser (Key, UserNameAnsi)) {

                Pos->IsLastLoggedOnUserName = StringIMatch (
                                                    UserNameAnsi,
                                                    Pos->LastLoggedOnUserName
                                                    );
                break;

            }

            Pos->CurPos++;
        }

        if (Pos->CurPos >= Pos->NumPos) {
            Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
        }

        Win95RegCloseKey (Key);
    }

    DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "WIN95REG: Error getting next user"));

    return rc;
}


LONG
Win95RegGetFirstUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    )
{
    LONG rc;
    CHAR AnsiUserName[MAX_USER_NAMEA];
    PSTR p;

    MYASSERT (Pos && UserName);

    rc = Win95RegGetFirstUserA (Pos, AnsiUserName);

    if (rc == ERROR_SUCCESS) {

        if (LcharCountA (AnsiUserName) > MAX_USER_NAMEW - 1) {
            p = LcharCountToPointerA (AnsiUserName, MAX_USER_NAMEW - 1);
            *p = 0;
        }

        KnownSizeAtoW (UserName, AnsiUserName);
    }

    return rc;
}


LONG
Win95RegGetNextUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    )
{
    LONG rc;
    CHAR AnsiUserName[MAX_USER_NAMEA];
    PSTR p;

    MYASSERT (Pos);
    MYASSERT (UserName);

    rc = Win95RegGetNextUserA (Pos, AnsiUserName);

    if (rc == ERROR_SUCCESS) {

        if (LcharCountA (AnsiUserName) > MAX_USER_NAMEW - 1) {
            p = LcharCountToPointerA (AnsiUserName, MAX_USER_NAMEW - 1);
            *p = 0;
        }

        KnownSizeAtoW (UserName, AnsiUserName);
    }

    return rc;
}


BOOL
pIsCurrentUser (
    IN      PCSTR UserNameAnsi
    )
{
    DWORD subKeys;
    LONG rc;
    HKEY win9xUpgKey;
    CHAR userName[MAX_USER_NAME];
    DWORD userNameSize;
    BOOL result = FALSE;
    HKEY profileKey;

    rc = Win95RegOpenKeyA (
            HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg",
            &win9xUpgKey
            );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    userNameSize = ARRAYSIZE(userName);

    rc = Win95RegQueryValueExA (
            win9xUpgKey,
            "CurrentUser",
            NULL,
            NULL,
            (PBYTE) userName,
            &userNameSize
            );

    if (rc == ERROR_SUCCESS) {
        result = StringIMatchA (UserNameAnsi, userName);
    }

    Win95RegCloseKey (win9xUpgKey);

    return result;
}


BOOL
Win95RegIsValidUser (
    HKEY ProfileListKey,            OPTIONAL
    PSTR UserNameAnsi
    )
{
    HKEY UserProfileKey;
    BOOL b = FALSE;
    BOOL CloseProfileListKey = FALSE;
    LONG rc;

    if (!ProfileListKey) {
        rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &ProfileListKey);
        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

        CloseProfileListKey = TRUE;
    }

    //
    // Open the user key
    //
    rc = Win95RegOpenKeyA (
            ProfileListKey,
            UserNameAnsi,
            &UserProfileKey
            );

    //
    // Does ProfileImagePath exist?
    // (The case where the user logged in but did not retain settings)
    //
    if (rc == ERROR_SUCCESS) {

        rc = Win95RegQueryValueExA (
                UserProfileKey,
                S_PROFILEIMAGEPATH,
                NULL,
                NULL,
                NULL,
                NULL
                );

        if (rc == ERROR_SUCCESS) {
            //
            // Add other tests here
            //

            b = TRUE;

        } else {
            //
            // Need to check if this is the current user. If it is, and we are
            // here, then the user doing the upgrade chose not to save his/her
            // settings.
            //

            b = pIsCurrentUser (UserNameAnsi);
        }

        Win95RegCloseKey (UserProfileKey);
    }

    if (CloseProfileListKey) {
        Win95RegCloseKey (ProfileListKey);
    }

    return b;
}


VOID
pCleanupTempUser (
    VOID
    )
{
    g_UserKey = NULL;

    if (!g_UnloadLastUser) {
        return;
    }

    //
    // Unload temp user hive
    //

    RegUnLoadKey(
        HKEY_LOCAL_MACHINE,
        S_MIGRATION
        );

    pSetupRegistryDelnode (
        HKEY_LOCAL_MACHINE,
        S_MIGRATION
        );

    g_UnloadLastUser = FALSE;
}


VOID
pGetCurrentUserDatPath (
    IN      PCSTR BaseDir,
    OUT     PSTR PathSpec
    )
{
    CHAR UserNameAnsi[MAX_USER_NAMEA];
    CHAR FullPath[MAX_MBCHAR_PATH];
    CHAR RegKey[MAX_REGISTRY_KEY];
    HKEY ProfileListKey;
    PCSTR Data;
    DWORD Size;

    Size = ARRAYSIZE(UserNameAnsi);

    if (!GetUserName (UserNameAnsi, &Size)) {
        *UserNameAnsi = 0;
    }

    *FullPath = 0;

    if (*UserNameAnsi) {
        //
        // Logged-in user case on a per-user profile machine.  Look in
        // Windows\CV\ProfileList\<user> for a ProfileImagePath value.
        //

        wsprintfA (RegKey, "%s\\%s", S_HKLM_PROFILELIST_KEY, UserNameAnsi);

        ProfileListKey = OpenRegKeyStrA (RegKey);
        if (!ProfileListKey) {
            //
            // No profile list!
            //

            DEBUGMSG ((DBG_WHOOPS, "pGetCurrentUserDatPath: No profile list found"));
        } else {
            //
            // Get the ProfileImagePath value
            //

            Data = GetRegValueDataOfTypeA (ProfileListKey, S_PROFILEIMAGEPATH, REG_SZ);

            if (Data) {
                _mbssafecpy (FullPath, Data, sizeof (FullPath));
                MemFree (g_hHeap, 0, Data);
            }
            ELSE_DEBUGMSG ((
                DBG_WARNING,
                "pGetCurrentUserDatPath: Profile for %s does not have a ProfileImagePath value",
                UserNameAnsi
                ));

            CloseRegKey (ProfileListKey);
        }

    } else {
        //
        // Default user case.  Prepare %windir%\user.dat.
        //

        StackStringCopyA (FullPath, BaseDir);
    }

    //
    // Append user.dat
    //

    if (*FullPath) {
        StringCopyA (AppendWackA (FullPath), "user.dat");
    }

    //
    // Convert to short name
    //

    if (!(*FullPath) || !OurGetShortPathName (FullPath, PathSpec, MAX_TCHAR_PATH)) {
        _mbssafecpy (PathSpec, FullPath, MAX_MBCHAR_PATH);
    }
}


PCSTR
pLoadUserDat (
    IN      PCSTR BaseDir,
    IN      PCSTR UserDatSpec
    )
{
    CHAR ShortPath[MAX_MBCHAR_PATH];
    CHAR CurrentUserDatPath[MAX_MBCHAR_PATH];
    DWORD rc;

    //
    // Unload last user if necessary
    //

    pCleanupTempUser();

    //
    // Determine if it is necessary to load UserDatSpec.  If not,
    // return HKEY_CURRENT_USER.  Otherwise, load the key into
    // HKLM\Migration, then open it.
    //

    //
    // Always use the short path name
    //

    if (!OurGetShortPathName (UserDatSpec, ShortPath, sizeof (ShortPath))) {
        DEBUGMSG ((
            DBG_WARNING,
            "pLoadUserDat: Could not get short name for %s",
            UserDatSpec
            ));

        return NULL;
    }

    //
    // Per-user profiles are enabled.  Determine if UserDatSpec
    // has already been mapped to HKCU.
    //

    pGetCurrentUserDatPath (BaseDir, CurrentUserDatPath);

    if (StringIMatch (ShortPath, CurrentUserDatPath)) {
        //
        // Yes -- return HKEY_CURRENT_USER
        //

        DEBUGMSG ((DBG_VERBOSE, "%s is the current user's hive.", CurrentUserDatPath));
        return "HKCU";
    }

    //
    // No -- load user.dat into HKLM\Migration
    //

    DEBUGMSG ((DBG_WIN95REG, "RegLoadKey: %s", ShortPath));

    rc = RegLoadKey (
            HKEY_LOCAL_MACHINE,
            S_MIGRATION,
            ShortPath
            );

    if (rc != ERROR_SUCCESS) {

        SetLastError (rc);

        DEBUGMSG ((
            DBG_WARNING,
            "pLoadUserDat: Could not load %s into HKLM\\Migration.  Original Path: %s",
            ShortPath,
            UserDatSpec
            ));

        return NULL;
    }

    g_UnloadLastUser = TRUE;

    return S_HKLM_MIGRATION;
}


LONG
Win95RegSetCurrentUserA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,        OPTIONAL
    OUT     PSTR UserDatOut             OPTIONAL
    )
{
    return pWin95RegSetCurrentUserCommonA (Pos, SystemHiveDir, UserDatOut, NULL);
}


LONG
Win95RegSetCurrentUserW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,       OPTIONAL
    OUT     PWSTR UserDatOut            OPTIONAL
    )
{
    return pWin95RegSetCurrentUserCommonW (Pos, SystemHiveDir, UserDatOut, NULL);
}


LONG
Win95RegSetCurrentUserNtA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR UserDat
    )
{
    return pWin95RegSetCurrentUserCommonA (Pos, NULL, NULL, UserDat);
}


LONG
Win95RegSetCurrentUserNtW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR UserDat
    )
{
    return pWin95RegSetCurrentUserCommonW (Pos, NULL, NULL, UserDat);
}


LONG
pWin95RegSetCurrentUserCommonW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,               OPTIONAL
    OUT     PWSTR UserDatOut,                   OPTIONAL
    IN      PCWSTR UserDat                      OPTIONAL
    )
{
    LONG rc;
    PCSTR AnsiSystemHiveDir;
    PCSTR AnsiUserDat;
    CHAR AnsiUserDatOut[MAX_MBCHAR_PATH];
    PSTR p;

    //
    // Convert args to ANSI
    //

    if (UserDat) {
        AnsiUserDat = ConvertWtoA (UserDat);
    } else {
        AnsiUserDat = NULL;
    }

    if (SystemHiveDir && UserDat) {
        AnsiSystemHiveDir = ConvertWtoA (UserDat);
    } else {
        AnsiSystemHiveDir = NULL;
    }

    //
    // Call ANSI function
    //
    rc = pWin95RegSetCurrentUserCommonA (Pos, AnsiSystemHiveDir, AnsiUserDatOut, AnsiUserDat);

    if (rc == ERROR_SUCCESS) {

        //
        // Convert OUT arg
        //

        if (UserDatOut) {
            if (LcharCountA (AnsiUserDatOut) > MAX_WCHAR_PATH - 1) {
                p = LcharCountToPointerA (AnsiUserDatOut, MAX_USER_NAMEW - 1);
                *p = 0;
            }

            KnownSizeAtoW (UserDatOut, AnsiUserDatOut);
        }
    }

    return rc;
}


DWORD
FindAndLoadHive (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller,           OPTIONAL
    IN      BOOL MapTheHive
    )
{
    CHAR RegistryUserDatPath[MAX_MBCHAR_PATH];
    CHAR ActualUserDatPath[MAX_MBCHAR_PATH];
    CHAR UserNameAnsi[MAX_USER_NAMEA];
    DWORD Size;
    HKEY ProfileListKey;
    HKEY UserKey = NULL;
    CHAR WinDir[MAX_MBCHAR_PATH];
    DWORD rc = ERROR_SUCCESS;

    //
    // 1. Determine the path to ActualUserDatPath
    //
    // 2. If user.dat is from registry and caller supplied alternate
    //    %windir%, replace the %windir% with SystemHiveDir
    //
    // 3. If caller wants final path, copy it to their buffer
    //
    // 4. On NT, map the hive as HKCU.  On 95, load the key and open
    //    a reg handle.
    //


    if (UserDatFromCaller) {
        //
        // Caller says where to find user.dat
        //

        StringCopyA (ActualUserDatPath, UserDatFromCaller);

    } else {
        //
        // System.dat says us where to find user.dat
        //

        rc = Win95RegOpenKeyA (
                HKEY_LOCAL_MACHINE,
                S_PROFILELIST_KEYA,
                &ProfileListKey
                );

        if (rc != ERROR_SUCCESS) {
            return rc;
        }

        //
        // Get name of user
        //

        Size = ARRAYSIZE(UserNameAnsi);
        rc = Win95RegEnumKeyExA (
                ProfileListKey,
                (DWORD) Pos->CurPos,
                UserNameAnsi,
                &Size,
                NULL,
                NULL,
                NULL,
                NULL
                );

        if (rc == ERROR_SUCCESS) {
            //
            // Open key to user
            //

            rc = Win95RegOpenKeyA (
                    ProfileListKey,
                    UserNameAnsi,
                    &UserKey
                    );
        }

        Win95RegCloseKey (ProfileListKey);

        if (rc != ERROR_SUCCESS) {
            return rc;
        }

        //
        // Get user's profile path from registry. Optionally relocate it, if user
        // supplied a replacement for WinDir.
        //

        Size = sizeof (RegistryUserDatPath);
        rc = Win95RegQueryValueExA (
                UserKey,
                S_PROFILEIMAGEPATH,
                NULL,
                NULL,
                RegistryUserDatPath,
                &Size
                );

        Win95RegCloseKey (UserKey);

        if (rc != ERROR_SUCCESS) {
            if (!pIsCurrentUser (UserNameAnsi)) {
                return rc;
            }

            return pSetDefaultUserHelper (
                        Pos,
                        SystemHiveDir,
                        UserDatFromCaller,
                        UserDatToCaller
                        );
        }

        //
        // Substitute %WinDir% in path that registry supplied?
        //

        if (SystemHiveDir && *SystemHiveDir) {
            //
            // Munge profile path
            //

            rc = pReplaceWinDirInPath (
                    ActualUserDatPath,
                    RegistryUserDatPath,
                    SystemHiveDir
                    );

            if (rc != ERROR_SUCCESS) {
                return rc;
            }

        } else {

            //
            // Don't munge. Leave as is (correct behavior on Win95 with local profiles)
            //

            StringCopyA (ActualUserDatPath, RegistryUserDatPath);
        }

        //
        // Add name of hive file, "\\user.dat"
        //

        StringCopyA (AppendWackA (ActualUserDatPath), "user.dat");

    }

    //
    // Send path to caller if necessary
    //

    if (UserDatToCaller) {
        _mbssafecpy (UserDatToCaller, ActualUserDatPath, MAX_MBCHAR_PATH);
    }

    if (MapTheHive) {
        if (g_IsNt) {

            //
            // WinNT: Associate filename with HKCU
            //

            rc = VMMRegMapPredefKeyToFile (
                    HKEY_CURRENT_USER,
                    ActualUserDatPath,
                    0
                    );

        } else {

            //
            // Win9x: Load HKLM\Migration
            //

            if (!SystemHiveDir) {
                if (!GetWindowsDirectory (WinDir, sizeof (WinDir))) {
                    rc = GetLastError ();
                }
            }

            if (rc == ERROR_SUCCESS) {
                g_UserKey = pLoadUserDat (
                               SystemHiveDir ? SystemHiveDir : WinDir,
                               ActualUserDatPath
                               );

                if (!g_UserKey) {
                    rc = GetLastError();
                }
            }
        }
    }

    return rc;
}


DWORD
pSetDefaultUserHelper (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller            OPTIONAL
    )
{
    CHAR ActualUserDatPath[MAX_MBCHAR_PATH];
    DWORD rc = ERROR_SUCCESS;
    HKEY DefaultKey;

    //
    // Determine path to default user's user.dat
    //

    if (UserDatFromCaller) {

        //
        // Caller-supplied user.dat path
        //

        StringCopyA (ActualUserDatPath, UserDatFromCaller);

    } else {

        //
        // Use the string received from Init
        //

        StringCopyA (ActualUserDatPath, g_SystemUserHive);
    }

    //
    // NT: Map the user via VMMREG
    // 9x: Load & open the user hive
    //

    if (g_IsNt) {

        //
        // NT: Map .Default into HKCU.
        //

        //
        // Reload HKEY_USERS
        //

        rc = VMMRegMapPredefKeyToFile (
                  HKEY_USERS,
                  ActualUserDatPath,
                  0
                  );

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG ((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Cannot reload HKU from %s",
                ActualUserDatPath
                ));

            return rc;
        }

        //
        // Get handle to default profile
        //

        rc = Win95RegOpenKeyA (
                 HKEY_USERS,
                 ".Default",
                 &DefaultKey
                 );

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG ((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Expected to find key HKU\\.Default in %s",
                ActualUserDatPath
                ));

            return rc;
        }

        //
        // Associate default profile with HKEY_CURRENT_USER
        //

        rc = VMMRegMapPredefKeyToKey (
                DefaultKey,
                HKEY_CURRENT_USER
                );

        Win95RegCloseKey (DefaultKey);

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Cannot map HKU\\.Default to HKCU from %s",
                ActualUserDatPath
                ));

            return rc;
        }

    } else {

        //
        // Win9x: Return HKU\.Default
        //

        g_UserKey = S_HKU_DEFAULT;
    }

    //
    // Send path to caller if necessary
    //

    if (UserDatToCaller) {
        _mbssafecpy (UserDatToCaller, ActualUserDatPath, MAX_MBCHAR_PATH);
    }

    return rc;
}


LONG
pWin95RegSetCurrentUserCommonA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,                OPTIONAL
    OUT     PSTR UserDatOut,                    OPTIONAL
    IN      PCSTR UserDat                       OPTIONAL
    )
{

    MYASSERT (!Pos || GU_VALID == Pos->Valid);

    //
    // Process per-user user.dat if
    //   (A) caller does not want default user
    //   (B) machine has per-user profiles
    //   (C) current user position is valid
    //

    if (Pos && Pos->UseProfile && Pos->CurPos < Pos->NumPos) {
        return (LONG) FindAndLoadHive (
                            Pos,
                            SystemHiveDir,
                            UserDat,
                            UserDatOut,
                            TRUE
                            );
    }

    //
    // For all other cases, use a default profile
    //

    return (LONG) pSetDefaultUserHelper (
                        Pos,
                        SystemHiveDir,
                        UserDat,
                        UserDatOut
                        );

}


LONG
pReplaceWinDirInPath (
    IN      PSTR ProfilePathMunged,
    IN      PCSTR ProfilePath,
    IN      PCSTR NewWinDir
    )
{
    PSTR EndOfWinDir;

    //
    // Test assumptions about profile dir. Expect x:\windir\...
    //
    if (!isalpha(ProfilePath[0]) ||
        ProfilePath[1] != ':' ||
        ProfilePath[2] != '\\'
        ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Find the second slash (the first is at ptr+2)
    //
    EndOfWinDir = _mbschr (&ProfilePath[3], '\\');
    if (!EndOfWinDir) {
        return ERROR_INVALID_DATA;
    }

    //
    // Make munged dir
    //
    StringCopyA (ProfilePathMunged, NewWinDir);
    StringCopyA (AppendPathWack (ProfilePathMunged), _mbsinc (EndOfWinDir));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\ntoc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntoc.cpp

Abstract:

    This file implements the NT OC Manager DLL.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include "ntoc.h"
#pragma hdrstop


//
// types
//

typedef void (*PWIZINIT)(void);
typedef void (*PWIZCOMMIT)(void);

//
// structures
//

typedef struct _WIZPAGE {
    DWORD           ButtonState;
    DWORD           PageId;
    DWORD           DlgId;
    DLGPROC         DlgProc;
    DWORD           Title;
    DWORD           SubTitle;
    DWORD           WizPageType;
    PWIZINIT        WizInit;
    PWIZCOMMIT      WizCommit;
    DWORDLONG       Modes;            
} WIZPAGE, *PWIZPAGE;


//
// globals
//

WIZPAGE SetupWizardPages[WizPageMaximum] =
{    
    {
        PSWIZB_NEXT,
        WizPageTapiLoc,
        IDD_TAPI_LOCATIONS,
        TapiLocDlgProc,
        IDS_TAPILOC_TITLE,
        IDS_TAPILOC_SUBTITLE,
        WizPagesEarly,
        TapiInit,
        TapiCommitChanges,
        -1
    },
/*
    {
        PSWIZB_NEXT,
        WizPageDisplay,
        IDD_DISPLAY,
        DisplayDlgProc,
        IDS_DISPLAY_TITLE,
        IDS_DISPLAY_SUBTITLE,
        WizPagesEarly,
        DisplayInit,
        DisplayCommitChanges,
        -1
    },
*/
    {
        PSWIZB_NEXT,
        WizPageDateTime,
        IDD_DATETIME,
        DateTimeDlgProc,
        IDS_DATETIME_TITLE,
        IDS_DATETIME_SUBTITLE,
        WizPagesEarly,
        DateTimeInit,
        DateTimeCommitChanges,
        -1
    },

    {
        PSWIZB_NEXT,
        WizPageWelcome,
        IDD_NTOC_WELCOME,
        WelcomeDlgProc,
        0,
        0,
        WizPagesWelcome,
        WelcomeInit,
        WelcomeCommit,
        SETUPOP_STANDALONE
    },
/*
    {
        PSWIZB_NEXT,
        WizPageReinstall,
        IDD_REINSTALL,
        ReinstallDlgProc,
        0,
        0,
        WizPagesEarly,
        ReinstallInit,
        ReinstallCommit,
        SETUPOP_STANDALONE
    },
*/
    {
        PSWIZB_FINISH,
        WizPageFinal,
        IDD_NTOC_FINISH,
        FinishDlgProc,
        0,
        0,
        WizPagesFinal,
        FinishInit,
        FinishCommit,
        SETUPOP_STANDALONE
    }

};


DWORD NtOcWizardPages[] =
{
    WizPageTapiLoc,
    // WizPageDisplay,
    WizPageDateTime,
    WizPageWelcome,
    //WizPageReinstall,
    WizPageFinal

};

//DWORD NtOcWrapPages[] =
//{
//}

#define MAX_NTOC_PAGES (sizeof(NtOcWizardPages)/sizeof(NtOcWizardPages[0]))
//#define MAX_NTOC_WRAP_PAGES (sizeof(NtOcWrapPages)/sizeof(NtOcWrapPages[0]))


HINSTANCE hInstance;
HPROPSHEETPAGE WizardPageHandles[WizPageMaximum];
PROPSHEETPAGE WizardPages[WizPageMaximum];
//HPROPSHEETPAGE WrapPageHandles[WizPageMaximum];
//PROPSHEETPAGE WizardPages[WizPageMaximum];
SETUP_INIT_COMPONENT SetupInitComponent;




extern "C"
DWORD
NtOcDllInit(
    HINSTANCE hInst,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        hInstance = hInst;
        DisableThreadLibraryCalls( hInstance );
        InitCommonControls();
    }

    return TRUE;
}


DWORD
NtOcSetupProc(
    IN LPCVOID ComponentId,
    IN LPCVOID SubcomponentId,
    IN UINT Function,
    IN UINT Param1,
    IN OUT PVOID Param2
    )
{
    DWORD i;
    DWORD cnt;
    DWORD WizPageCount = 0;
    WCHAR TitleBuffer[256];
    PSETUP_REQUEST_PAGES SetupRequestPages;


    switch( Function ) {
        case OC_PREINITIALIZE:
            return OCFLAG_UNICODE;

        case OC_INIT_COMPONENT:
            if (OCMANAGER_VERSION <= ((PSETUP_INIT_COMPONENT)Param2)->OCManagerVersion) {
                ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;
            } else {
                return ERROR_CALL_NOT_IMPLEMENTED;
            }
            CopyMemory( &SetupInitComponent, (LPVOID)Param2, sizeof(SETUP_INIT_COMPONENT) );
            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if (SetupWizardPages[NtOcWizardPages[i]].WizInit &&
                     (SetupWizardPages[NtOcWizardPages[i]].Modes & 
                     SetupInitComponent.SetupData.OperationFlags)) {
                    SetupWizardPages[NtOcWizardPages[i]].WizInit();
                }
            }
            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                        if (!RunningAsAdministrator()) {
                                FmtMessageBox(NULL,
                                          MB_ICONINFORMATION | MB_OK | MB_SETFOREGROUND,
                                          FALSE,
                                              ID_DSP_TXT_CHANGE_SETTINGS,
                                          ID_DSP_TXT_ADMIN_CHANGE);
                        return ERROR_CANCELLED;
                        }       
            }
            return 0;

        case OC_REQUEST_PAGES:

            SetupRequestPages = (PSETUP_REQUEST_PAGES) Param2;

            //
            // if this isn't gui-mode setup, then let's supply the welcome and finish pages
            //
            // Note that this code path "short circuits" inside this if statement
            //
            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {

                switch (Param1) {
                    case WizPagesWelcome:                    
                        i = WizPageWelcome;
                        cnt = 1;
                        break;
                    case WizPagesFinal:
                        cnt = 1;
                        i = WizPageFinal;
                        break;
//                  case WizPagesEarly:
//                      cnt = 1;
//                      i = WizPageReinstall;
//                      break;
                    default:
                        cnt = 0;
                        i = 0;
                        break;
                }

                if (cnt > SetupRequestPages->MaxPages) {
                    return cnt;
                }

                if (cnt == 0) {
                    goto getallpages;
                }
               

                WizardPages[WizPageCount].dwSize             = sizeof(PROPSHEETPAGE);
//                if (i == WizPageReinstall) {
//                    WizardPages[WizPageCount].dwFlags            = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
//                } else {
                    WizardPages[WizPageCount].dwFlags            = PSP_DEFAULT | PSP_HIDEHEADER;
//                }
                WizardPages[WizPageCount].hInstance          = hInstance;
                WizardPages[WizPageCount].pszTemplate        = MAKEINTRESOURCE(SetupWizardPages[NtOcWizardPages[i]].DlgId);
                WizardPages[WizPageCount].pszIcon            = NULL;
                WizardPages[WizPageCount].pszTitle           = NULL;
                WizardPages[WizPageCount].pfnDlgProc         = SetupWizardPages[NtOcWizardPages[i]].DlgProc;
                WizardPages[WizPageCount].lParam             = 0;
                WizardPages[WizPageCount].pfnCallback        = NULL;
                WizardPages[WizPageCount].pcRefParent        = NULL;

                WizardPages[WizPageCount].pszHeaderTitle     = NULL;
                WizardPages[WizPageCount].pszHeaderSubTitle  = NULL;

                if (SetupWizardPages[NtOcWizardPages[i]].Title) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].Title,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderTitle = _wcsdup( TitleBuffer );
                    }
                }

                if (SetupWizardPages[NtOcWizardPages[i]].SubTitle) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].SubTitle,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderSubTitle = _wcsdup( TitleBuffer );
                    }
                }

                WizardPageHandles[WizPageCount] = CreatePropertySheetPage( &WizardPages[WizPageCount] );
                if (WizardPageHandles[WizPageCount]) {
                    SetupRequestPages->Pages[WizPageCount] = WizardPageHandles[WizPageCount];
                    WizPageCount += 1;
                }

                return WizPageCount;


            }

getallpages:
            for (i=0,cnt=0; i<MAX_NTOC_PAGES; i++) {
                
                if ((SetupWizardPages[NtOcWizardPages[i]].WizPageType == Param1) &&
                    (SetupInitComponent.SetupData.OperationFlags & SetupWizardPages[NtOcWizardPages[i]].Modes)) {
                    cnt += 1;
                }

            }

            // if this is not gui mode setup, don't display pages

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                cnt = 0;
            }

            if (cnt == 0) {
                return cnt;
            }

            if (cnt > SetupRequestPages->MaxPages) {
                return cnt;
            }

            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if ((SetupWizardPages[NtOcWizardPages[i]].WizPageType != Param1) &&
                    (SetupInitComponent.SetupData.OperationFlags & SetupWizardPages[NtOcWizardPages[i]].Modes) == 0) {
                    continue;
                }

                WizardPages[WizPageCount].dwSize             = sizeof(PROPSHEETPAGE);
                WizardPages[WizPageCount].dwFlags            = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
                WizardPages[WizPageCount].hInstance          = hInstance;
                WizardPages[WizPageCount].pszTemplate        = MAKEINTRESOURCE(SetupWizardPages[NtOcWizardPages[i]].DlgId);
                WizardPages[WizPageCount].pszIcon            = NULL;
                WizardPages[WizPageCount].pszTitle           = NULL;
                WizardPages[WizPageCount].pfnDlgProc         = SetupWizardPages[NtOcWizardPages[i]].DlgProc;
                WizardPages[WizPageCount].lParam             = 0;
                WizardPages[WizPageCount].pfnCallback        = NULL;
                WizardPages[WizPageCount].pcRefParent        = NULL;
                WizardPages[WizPageCount].pszHeaderTitle     = NULL;
                WizardPages[WizPageCount].pszHeaderSubTitle  = NULL;

                if (SetupWizardPages[NtOcWizardPages[i]].Title) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].Title,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderTitle = _wcsdup( TitleBuffer );
                    }
                }

                if (SetupWizardPages[NtOcWizardPages[i]].SubTitle) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].SubTitle,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderSubTitle = _wcsdup( TitleBuffer );
                    }
                }

                WizardPageHandles[WizPageCount] = CreatePropertySheetPage( &WizardPages[WizPageCount] );
                if (WizardPageHandles[WizPageCount]) {
                    SetupRequestPages->Pages[WizPageCount] = WizardPageHandles[WizPageCount];
                    WizPageCount += 1;
                }
            }

            return WizPageCount;

        case OC_QUERY_SKIP_PAGE:
            
            // if this is gui mode setup and the system is NT Workstation, 
            // skip the select components page

            // remove workstation check to make this change effective on servers as well
            // if (SetupInitComponent.SetupData.ProductType == PRODUCT_WORKSTATION) {
                if (!(SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                    return TRUE;
                }
            // }

            return FALSE;

        case OC_COMPLETE_INSTALLATION:

            // if this is not gui mode setup, do nothing, else commit the pages

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                break;
            }

            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if (SetupWizardPages[NtOcWizardPages[i]].WizCommit) {
                    SetupWizardPages[NtOcWizardPages[i]].WizCommit();
                }
            }
            break;

        case OC_QUERY_STATE:

            // we are always installed
                        
            return SubcompOn;
                        
        default:
            break;
    }

    return 0;
}

/*---------------------------------------------------------------------------*\
  Function: RunningAsAdministrator()
|*---------------------------------------------------------------------------*|
  Description: Checks whether we are running as administrator on the machine
  or not
\*---------------------------------------------------------------------------*/
BOOL 
RunningAsAdministrator(
        VOID
        )
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    // First we must open a handle to the access token for this thread.
    
    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
#endif //_CHICAGO_
}



LRESULT
CommonWizardProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    DWORD   WizardId
    )

/*++

Routine Description:

    Common procedure for handling wizard pages:

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information
    WizardId - Indicate which wizard page this is for

Return Value:

    NULL - Message is processed and the dialog procedure should return FALSE
    Otherwise - Message is not completely processed and
        The return value is a pointer to the user mode memory structure

--*/

{

    switch (message) {

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

            case PSN_SETACTIVE:
                PropSheet_SetWizButtons( GetParent(hDlg), 
                                         SetupWizardPages[WizardId].ButtonState
                                       );
            break;

            default:
                ;
                
        }

        break;

    default:
        ;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\datetime.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    datetime.cpp

Abstract:

    This file implements the date & time page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 1-Dec-1997

--*/

#include "ntoc.h"
#pragma hdrstop

#define MYDEBUG 0

#define TIMER_ID                1
#define OPEN_TLEN               450    /* < half second */
#define TZNAME_SIZE             128
#define TZDISPLAYZ              128
#define REGKEY_TIMEZONES        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"
#define   REGVAL_TZ_DISPLAY     L"Display"
#define   REGVAL_TZ_STD         L"Std"
#define   REGVAL_TZ_DAYLIGHT    L"Dlt"
#define   REGVAL_TZ_TZI         L"TZI"
#define   REGVAL_TZ_INDEX       L"Index"
#define   REGVAL_TZ_INDEXMAP    L"IndexMapping"
#define REGKEY_TIMEZONE_INFO    L"System\\CurrentControlSet\\Control\\TimeZoneInformation"
#define   REGVAL_TZNOAUTOTIME   L"DisableAutoDaylightTimeSet"


typedef struct tagTZINFO
{
    LIST_ENTRY       ListEntry;
    WCHAR            szDisplayName[TZDISPLAYZ];
    WCHAR            szStandardName[TZNAME_SIZE];
    WCHAR            szDaylightName[TZNAME_SIZE];
    int              ReferenceIndex;
    LONG             Bias;
    LONG             StandardBias;
    LONG             DaylightBias;
    SYSTEMTIME       StandardDate;
    SYSTEMTIME       DaylightDate;

} TZINFO, *PTZINFO;

LIST_ENTRY ZoneList;
SYSTEMTIME SelectedTime;
SYSTEMTIME SelectedDate;
BOOL ChangeTime;
BOOL ChangeDate;
PTZINFO CurrZone;
BOOL AllowAutoDST;
INT gUnattenedTimeZone = -1;
BOOL DateTimeBadUnattend;


HWND  ghWnd;               // global copy of the handle to the wizard page. This
                           // is required by DateTimeCommitChanges during an
                           // unattended installation.


BOOL
ReadZoneData(
    PTZINFO zone,
    HKEY key,
    LPCWSTR keyname
    )
{
    WCHAR mapinfo[16];
    DWORD len;

    len = sizeof(zone->szDisplayName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_DISPLAY,
                         0,
                         NULL,
                         (LPBYTE)zone->szDisplayName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Under NT, the keyname is the "Standard" name.  Values stored
    //  under the keyname contain the other strings and binary info
    //  related to the time zone.  Every time zone must have a standard
    //  name, therefore, we save registry space by using the Standard
    //  name as the subkey name under the "Time Zones" key.
    //
    len = sizeof(zone->szStandardName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_STD,
                         0,
                         NULL,
                         (LPBYTE)zone->szStandardName,
                         &len ) != ERROR_SUCCESS)
    {
        //
        //  Use keyname if can't get StandardName value.
        //
        lstrcpyn( zone->szStandardName,
                  keyname,
                  sizeof(zone->szStandardName) );
    }

    len = sizeof(zone->szDaylightName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_DAYLIGHT,
                         0,
                         NULL,
                         (LPBYTE)zone->szDaylightName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->ReferenceIndex);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_INDEX,
                         0,
                         NULL,
                         (LPBYTE)&zone->ReferenceIndex,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->Bias) +
          sizeof(zone->StandardBias) +
          sizeof(zone->DaylightBias) +
          sizeof(zone->StandardDate) +
          sizeof(zone->DaylightDate);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_TZI,
                         0,
                         NULL,
                         (LPBYTE)&zone->Bias,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    return (TRUE);
}


#if MYDEBUG
void
PrintZones(
    void
    )
{
    PLIST_ENTRY NextZone;
    PTZINFO zone;
    NextZone = ZoneList.Flink;
    if (NextZone) {
        DebugPrint(( L"----------------- time zone list -------------------------------------\n" ));
        while (NextZone != &ZoneList) {
            zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
            NextZone = zone->ListEntry.Flink;
            DebugPrint(( L"%03d  %s", zone->ReferenceIndex, zone->szDisplayName ));
        }
    }
}
#endif


void
AddZoneToList(
    PTZINFO zone
    )
{
    PLIST_ENTRY NextZone;
    PTZINFO ThisZone;


    if (IsListEmpty( &ZoneList )) {
        InsertHeadList( &ZoneList, &zone->ListEntry );
        return;
    }

    NextZone = ZoneList.Flink;
    while (NextZone != &ZoneList)
    {
        ThisZone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
        NextZone = ThisZone->ListEntry.Flink;
        if (ThisZone->ReferenceIndex > zone->ReferenceIndex) {
            InsertTailList( &ThisZone->ListEntry, &zone->ListEntry );
            return;
        }
    }
    InsertTailList( &ZoneList, &zone->ListEntry );
}


int
BuildTimeZoneList(
    void
    )
{
    HKEY key = NULL;
    int count = -1;



    InitializeListHead( &ZoneList );

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONES, &key ) == ERROR_SUCCESS)
    {
        WCHAR name[TZNAME_SIZE];
        PTZINFO zone = NULL;
        int i;

        count = 0;

        for (i = 0; RegEnumKey( key, i, name, TZNAME_SIZE ) == ERROR_SUCCESS; i++)
        {
            HKEY subkey = NULL;

            if (!zone &&
                ((zone = (PTZINFO)LocalAlloc(LPTR, sizeof(TZINFO))) == NULL))
            {
                break;
            }

            if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
            {
                //
                //  Each sub key name under the Time Zones key is the
                //  "Standard" name for the Time Zone.
                //
                lstrcpyn(zone->szStandardName, name, TZNAME_SIZE);

                if (ReadZoneData(zone, subkey, name))
                {
                    AddZoneToList(zone);
                    zone = NULL;
                    count++;
                }

                RegCloseKey(subkey);
            }
        }

        RegCloseKey(key);
    }

    return count;
}


void
DateTimeInit(
    void
    )
{
    DWORD d;

    BuildTimeZoneList();

#if MYDEBUG
    PrintZones();
#endif

    if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) == 0) {
        return;
    }

    HINF InfHandle = SetupInitComponent.HelperRoutines.GetInfHandle(
        INFINDEX_UNATTENDED,
        SetupInitComponent.HelperRoutines.OcManagerContext
        );
    if (InfHandle == NULL) {
        DateTimeBadUnattend = TRUE;
        return;
    }

    INFCONTEXT InfLine;

    if (!SetupFindFirstLine(InfHandle, L"GuiUnattended", L"TimeZone", &InfLine )) {

        DateTimeBadUnattend = TRUE;

        return;
    }

    if (SetupGetIntField( &InfLine, 1, (PINT)&d )) {
        gUnattenedTimeZone = (INT) d;
    } else {
        DateTimeBadUnattend = TRUE;
    }
}


void
SetAllowLocalTimeChange(
    BOOL fAllow
    )
{
    HKEY key = NULL;

    if (fAllow)
    {
        //
        //  Remove the disallow flag from the registry if it exists.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
        {
            RegDeleteValue(key, REGVAL_TZNOAUTOTIME);
        }
    }
    else
    {
        //
        //  Add/set the nonzero disallow flag.
        //
        if (RegCreateKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
        {
            DWORD value = 1;

            RegSetValueEx( key,
                           REGVAL_TZNOAUTOTIME,
                           0,
                           REG_DWORD,
                           (LPBYTE)&value,
                           sizeof(value) );
        }
    }

    if (key)
    {
        RegCloseKey(key);
    }
}


BOOL
GetAllowLocalTimeChange(
    void
    )
{
    //
    //  Assume allowed until we see a disallow flag.
    //
    BOOL result = TRUE;
    HKEY key;

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
    {
        //
        //  Assume no disallow flag until we see one.
        //
        DWORD value = 0;
        DWORD len = sizeof(value);
        DWORD type;

        if ((RegQueryValueEx( key,
                              REGVAL_TZNOAUTOTIME,
                              NULL,
                              &type,
                              (LPBYTE)&value,
                              &len ) == ERROR_SUCCESS) &&
            ((type == REG_DWORD) || (type == REG_BINARY)) &&
            (len == sizeof(value)) && value)
        {
            //
            //  Okay, we have a nonzero value, it is either:
            //
            //  1) 0xFFFFFFFF
            //      this is set in an inf file for first boot to prevent
            //      the base from performing any cutovers during setup.
            //
            //  2) some other value
            //      this signifies that the user actualy disabled cutovers
            //     *return that local time changes are disabled
            //
            if (value != 0xFFFFFFFF)
            {
                result = FALSE;
            }
        }

        RegCloseKey(key);
    }

    return (result);
}


void
SetTheTimezone(
    BOOL bAutoMagicTimeChange,
    PTZINFO ptzi
    )
{
    TIME_ZONE_INFORMATION tzi;
    HCURSOR hCurOld;

    if (!ptzi)
    {
        return;
    }

    tzi.Bias = ptzi->Bias;

    tzi.StandardName[0] = 0;
    lstrcpyn(tzi.StandardName, ptzi->szStandardName, sizeof(tzi.StandardName)/sizeof(tzi.StandardName[0]));
    tzi.StandardName[sizeof(tzi.StandardName)/sizeof(tzi.StandardName[0])-1] = 0;

    tzi.DaylightName[0] = 0;

    if ((bAutoMagicTimeChange == 0) || (ptzi->StandardDate.wMonth == 0))
    {
        //
        //  Standard Only.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->StandardBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->StandardDate;
        lstrcpyn(tzi.DaylightName, ptzi->szStandardName, sizeof(tzi.DaylightName)/sizeof(tzi.DaylightName[0]));
    }
    else
    {
        //
        //  Automatically adjust for Daylight Saving Time.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->DaylightBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->DaylightDate;
        lstrcpyn(tzi.DaylightName, ptzi->szDaylightName, sizeof(tzi.DaylightName)/sizeof(tzi.DaylightName[0]));
    }
    tzi.DaylightName[sizeof(tzi.DaylightName)/sizeof(tzi.DaylightName[0])-1] = 0;

    SetAllowLocalTimeChange( bAutoMagicTimeChange );
    SetTimeZoneInformation( &tzi );
}

void
DateTimeApplyChanges(
    void
    )
{
    SYSTEMTIME SysTime;


    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
        return;
    }

    // Note that in the unattended case we will never have ChangeTime set
    // as the page never is used except for the timezone stuff. There is 
    // no support to set date/time via unattend.

    if (ChangeTime) {
        SysTime.wHour = SelectedTime.wHour;
        SysTime.wMinute = SelectedTime.wMinute;
        SysTime.wSecond = SelectedTime.wSecond;
        SysTime.wMilliseconds = SelectedTime.wMilliseconds;
    } else {
        GetLocalTime( &SysTime );
    }


    // If this is an unattended setup the PSN_WIZNEXT never arrived so it is
    // necessary to check the state of ICD_DAYTIME which was set by DateTimeOnInitDialog().

    if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1) {
       // This is unattended.

       AllowAutoDST = IsDlgButtonChecked( ghWnd, IDC_DAYLIGHT ) != 0;
    }
    else
    {
       // This is NOT UNATTENDED. SelectedDate was initialized when PSN_WIZNEXT
       // was processed.

       SysTime.wYear        = SelectedDate.wYear;
       SysTime.wMonth       = SelectedDate.wMonth;
       SysTime.wDayOfWeek   = SelectedDate.wDayOfWeek;
       SysTime.wDay         = SelectedDate.wDay;
    }

    // Function SetLocalTime uses Time Zone information so it is IMPERATIVE that
    // SetTheTimezone get called before SetLocalTime.

    SetTheTimezone( AllowAutoDST, CurrZone );

    SetLocalTime( &SysTime );

}


void
DateTimeCommitChanges(
    void
    )
{
    return;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetTimeZoneReferenceIndexFromRegistry
//
// Routine Description:
//    This funecion extracts the Time Zone reference index from information that
//    is stored in the registry.
//
// Arguments:
//    None
//
// Return Value:
//    The Time Zone reference index. If no valid reference index is deduced
//    this function will return zero.
//
// Note:
//    The logic performed by the following function was originally implemented in
//    DateTimeOnInitDialog.
//
//--
/////////////////////////////////////////////////////////////////////////////

int GetTimeZoneReferenceIndexFromRegistry( void )
{
   int   xReferenceIndex;

   HKEY hKey;

   // Attempt to open the Time Zones registry key.

   if ( RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONES, &hKey ) == ERROR_SUCCESS )
   {
      // The following call to RegQueryValueEx retrieves the size, in bytes, of
      // the IndexMapping registry value, in parameter "index".

      int   xIndexMapSize;

      if ( RegQueryValueEx( hKey, REGVAL_TZ_INDEXMAP, 0, NULL, NULL,
                            (LPDWORD) &xIndexMapSize ) == ERROR_SUCCESS )
      {
         // Allocate memory for the IndexMap registry value.

         LPWSTR wszIndexMap;

         wszIndexMap = (LPWSTR) LocalAlloc( LPTR, xIndexMapSize );

         // Was a buffer allocated successfully?

         if ( wszIndexMap != (LPWSTR) NULL )
         {
            // This call to RegQueryValueEx retrieves the IndexMap value into
            // the buffer, wszIndexMap.

            if ( RegQueryValueEx( hKey, REGVAL_TZ_INDEXMAP, 0, NULL,
                                  (LPBYTE) wszIndexMap,
                                  (LPDWORD) &xIndexMapSize ) == ERROR_SUCCESS )
            {
               // Get the language identifier.

               WCHAR wszLangStr[32];

               if ( GetLocaleInfo( LOCALE_USER_DEFAULT,
                                   LOCALE_ILANGUAGE, wszLangStr,
                                   sizeof( wszLangStr )/sizeof( WCHAR ) ) > 0 )
               {
                  LPWSTR lang = wszLangStr;

                  LPWSTR map = wszIndexMap;

                  while ( *lang == L'0' ) lang++;

                  while ( *map )
                  {
                     if ( _wcsicmp( lang, map ) == 0 )
                     {
                        while ( *map ) map++;

                        map++;

                        xReferenceIndex = _wtol( map );

                        break;
                     }

                     while ( *map ) map++;

                     map++;

                     while ( *map ) map++;

                     map++;
                  }      // end of while loop
               }      // language identifier obtained?
            }      // IndexMapping reg value queried?

            LocalFree( wszIndexMap );
         }   // memory allocated for ImageMap reg value retrieval?
         else
         {
            xReferenceIndex = 0;
         }   // memory allocated for ImageMap reg value retrieval?
      }   // Size of ImageMap obtained?
      else
      {
         xReferenceIndex = 0;
      }   // Size of ImageMap obtained?

      RegCloseKey( hKey );
   }   // TimeZones reg key opened?
   else
   {
      xReferenceIndex = 0;
   }   // TimeZones reg key opened?

   return ( xReferenceIndex );
}



BOOL
DateTimeOnInitDialog(
                    IN HWND hwnd,
                    IN HWND hwndFocus,
                    IN LPARAM lParam
                    )
{
   PLIST_ENTRY NextZone;
   PTZINFO zone;
   HWND combo;
   WCHAR LangStr[32];
   int DesiredZone = 0;
   int index;
   HKEY hKey;
   LPWSTR IndexMap;

   ghWnd = hwnd;           // initialize the global copy of the handle to the
                           // wizard page. ghWnd is used by DateTimeCommitChanges()
                           // during unattended setup.

   SetTimer( hwnd, TIMER_ID, OPEN_TLEN, 0 );

   if ( (SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1 )
   {
      //
      // We've got an unattended time zone value
      //

      // If everything were perfect DesiredZone will exactly match the ReferenceIndex
      // member of one of the TZINFO structures in ZoneList. Note that ZoneList was
      // built by BuildTimeZoneList.

      DesiredZone = gUnattenedTimeZone;
   }
   else
   {
      //
      // Base the default zone on the locale
      //

      // Extract the reference index for the desired time zone from the registry.

      DesiredZone = GetTimeZoneReferenceIndexFromRegistry();
   }  // Time zone specified in unattended setup answer file?
#if MYDEBUG
         DebugPrint(( L"DesiredZone = %03d", DesiredZone ));
#endif


   combo = GetDlgItem( hwnd, IDC_TIMEZONE );

   SetWindowRedraw( combo, FALSE );

   PTZINFO pTimeZoneInfo = (PTZINFO) NULL;

   // Note that ZoneList was built by BuildTimeZoneList.

   NextZone = ZoneList.Flink;

   if ( NextZone )
   {
      // Add time zones to the combo box.

      while ( NextZone != &ZoneList )
      {
         zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
         NextZone = zone->ListEntry.Flink;

         index = ComboBox_AddString( combo, zone->szDisplayName );

#if MYDEBUG
         DebugPrint(( L"%03d,%03d  %s", index, zone->ReferenceIndex, zone->szDisplayName ));
#endif

         if ( index < 0 )
         {
            break;
         }

         ComboBox_SetItemData( combo, index, (LPARAM)zone );

         if ( DesiredZone == zone->ReferenceIndex )
         {
            pTimeZoneInfo = zone;
#if MYDEBUG
            DebugPrint(( L"    Found DesiredZone" ));
#endif

         }
      }     // end of while loop
   }

   // Was a time zone that matched DesiredZone identified?

   if ( pTimeZoneInfo != (PTZINFO) NULL )
   {
      // Set the GLOBAL Time Zone Info structure pointer.

      CurrZone = pTimeZoneInfo;
   }
   else
   {
      // The fact that pTimeZoneInfo remained unchanged from its' initialized state
      // means that DesiredZone is not meaningfull.

      // Was DesiredZone obtained from the unattended setup answer file?

      if ( gUnattenedTimeZone != -1 )
      {
         // DesiredZone was obtained from the answer file. Since it is not meaningfull,
         // attempt to deduce it from registry information. Deducing DesiredZone from
         // information in the registry is the default action for ATTENDED setup.

         DesiredZone = GetTimeZoneReferenceIndexFromRegistry();
      }  // Was DesiredZone obtained from the answer file?

      // Is DesiredZone meaningfull now?

      if ( DesiredZone != 0 )
      {
         // Scan the list of Time Zones for one that matches DesiredZone.

         NextZone = ZoneList.Flink;

         if ( NextZone )
         {
            while ( NextZone != &ZoneList )
            {
               zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );

               NextZone = zone->ListEntry.Flink;

#if MYDEBUG
               DebugPrint(( L"%03d,%03d  %s", index, zone->ReferenceIndex, zone->szDisplayName ));
#endif

               if ( DesiredZone == zone->ReferenceIndex )
               {
                  pTimeZoneInfo = zone;
               }
            }   // end of while loop
         }  // Is NextZone legal?
      }  // Is DesiredZone meaningfull now?

      // Was a time zone that matched DesiredZone identified?

      Assert( pTimeZoneInfo != (PTZINFO) NULL );

      if ( pTimeZoneInfo != (PTZINFO) NULL )
      {
         // Set the GLOBAL Time Zone Info structure pointer.

         CurrZone = pTimeZoneInfo;
      }
      else
      {
         // Use the first Time Zone in the list as a default.

         CurrZone = CONTAINING_RECORD( ZoneList.Flink, TZINFO, ListEntry );
#if MYDEBUG
         DebugPrint(( L"Couldn't find default timzone" ));
#endif

      }  // Was a time zone that matched DesiredZone identified?

   }  // Was a time zone that matched DesiredZone identified?

   index = ComboBox_FindString( combo, 0, CurrZone->szDisplayName );
   if ( index == CB_ERR )
   {
      index = 0;
   }

   ComboBox_SetCurSel( combo, index );

   EnableWindow( GetDlgItem( hwnd, IDC_DAYLIGHT ), CurrZone->StandardDate.wMonth != 0 );
   CheckDlgButton( hwnd, IDC_DAYLIGHT, GetAllowLocalTimeChange() );

   SetWindowRedraw(combo, TRUE);

   return FALSE;
}


BOOL
DateTimeOnCommand(
    IN HWND hwnd,
    IN DWORD NotifyCode,
    IN DWORD ControlId,
    IN HWND hwndControl
    )
{
    if (NotifyCode == CBN_SELCHANGE && ControlId == IDC_TIMEZONE) {
        CurrZone = (PTZINFO) ComboBox_GetItemData( hwndControl, ComboBox_GetCurSel( hwndControl ) );
        EnableWindow( GetDlgItem( hwnd, IDC_DAYLIGHT ), CurrZone->StandardDate.wMonth != 0 );
        if (CurrZone->StandardDate.wMonth != 0) {
            CheckDlgButton( hwnd, IDC_DAYLIGHT, TRUE );
        } else {
            CheckDlgButton( hwnd, IDC_DAYLIGHT, FALSE );
        }
        return FALSE;
    }

    return TRUE;
}


BOOL
DateTimeOnNotify(
    IN HWND hwnd,
    IN WPARAM ControlId,
    IN LPNMHDR pnmh
    )
{
    switch( pnmh->code ) {
        case PSN_SETACTIVE:
            if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                return TRUE;
            }

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && DateTimeBadUnattend) {
                // No unattend value for time date in the unattend case.
                // make sure the wizard is shown.
                // note: When we get out here, only the next button is enabled.
                SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);
                return FALSE;
            }

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1) {
                //
                // we're in unattend mode
                //
                DateTimeApplyChanges();
                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                return TRUE;
            }

            // If we get here the user needs  has click next or back.
            // Make sure the wizard page is showing.
            // For Whistler GUI mode we try to hide wizard pages and show a background
            // billboard if there is only a progress bar.
            //
            SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);

            PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);

            break;

        case DTN_DATETIMECHANGE:
            if (ControlId == IDC_TIME_PICKER) {
                KillTimer( hwnd, TIMER_ID );
                ChangeTime = TRUE;
            } else if (ControlId == IDC_DATE_PICKER) {
                ChangeDate = TRUE;
            }
            break;

        case PSN_WIZNEXT:
            SendDlgItemMessage( hwnd, IDC_TIME_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&SelectedTime );
            SendDlgItemMessage( hwnd, IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&SelectedDate );
            AllowAutoDST = IsDlgButtonChecked( hwnd, IDC_DAYLIGHT ) != 0;
            DateTimeApplyChanges();
            break;
    }

    return FALSE;
}


BOOL
DateTimeOnTimer(
    IN HWND hwnd
    )
{
    SYSTEMTIME CurrTime;
    GetLocalTime( &CurrTime );
    SendDlgItemMessage( hwnd, IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&CurrTime );
    return FALSE;
}


INT_PTR CALLBACK
DateTimeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    CommonWizardProc( hwnd, message, wParam, lParam, WizPageDateTime );

    switch( message ) {
        case WM_INITDIALOG:
            return DateTimeOnInitDialog( hwnd, (HWND)wParam, lParam );

        case WM_COMMAND:
            return DateTimeOnCommand( hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

        case WM_TIMER:
            return DateTimeOnTimer( hwnd );

        case WM_NOTIFY:
            return DateTimeOnNotify( hwnd, wParam, (LPNMHDR) lParam );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\ntoc.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntoc.h

Abstract:

    This file contains the ntoc header stuff.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <wingdip.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <tapi.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"
#include "ntocmsg.h"


typedef enum {
    WizPageTapiLoc,
    //WizPageDisplay,
    WizPageDateTime,
    WizPageWelcome,
    //WizPageReinstall,
    WizPageFinal,
    WizPageMaximum    
} WizPage;


extern HINSTANCE hInstance;
extern SETUP_INIT_COMPONENT SetupInitComponent;


#if DBG

#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     dprintf _x_

#define DebugStop(_x_)      {\
                                dprintf _x_;\
                                dprintf(TEXT("Stopping at %s @ %d"),TEXT(__FILE__),__LINE__);\
                                __try {\
                                    DebugBreak();\
                                } __except (UnhandledExceptionFilter(GetExceptionInformation())) {\
                                }\
                            }

#else

#define Assert(exp)
#define DebugPrint(_x_)
#define DebugStop(_x_)

#endif

void
dprintf(
    LPTSTR Format,
    ...
    );

VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    );


//
// prototypes
//

LRESULT
CommonWizardProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD buttonFlags
    );


void
WelcomeInit(
    void
    );

void
WelcomeCommit(
    void
    );

INT_PTR CALLBACK
WelcomeDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );

void
ReinstallInit(
    void
    );

void
ReinstallCommit(
    void
    );

INT_PTR CALLBACK
ReinstallDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );



void
FinishInit(
    void
    );

void
FinishCommit(
    void
    );

INT_PTR CALLBACK
FinishDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );


void
TapiInit(
    void
    );

void
TapiCommitChanges(
    void
    );

INT_PTR CALLBACK
TapiLocDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );

void
DisplayInit(
    void
    );

void
DisplayCommitChanges(
    void
    );

INT_PTR CALLBACK
DisplayDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );

void
DateTimeInit(
    void
    );

void
DateTimeCommitChanges(
    void
    );

INT_PTR CALLBACK
DateTimeDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM wParam,
    LPARAM lParam
    );

HKEY
OpenRegistryKey(
    HKEY hKey,
    LPTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    );

LPTSTR
GetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    );

LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    );

DWORD
GetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName
    );

BOOL
SetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName,
    DWORD Value
    );

BOOL
SetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    );

BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    );

BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value,
    DWORD Length
    );

BOOL 
RunningAsAdministrator(
	VOID
	);

int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    BOOL fSound,
    DWORD dwTitleID,
    DWORD dwTextID,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\registry.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module provides a generic table driven access
    to the registry.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#define StringSize(_s) (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)


LPTSTR
StringDup(
    LPTSTR String
    )
{
    LPTSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPTSTR) LocalAlloc( LPTR, (_tcslen( String ) + 1) * sizeof(TCHAR) );
    if (!NewString) {
        return NULL;
    }

    _tcscpy( NewString, String );

    return NewString;
}


HKEY
OpenRegistryKey(
    HKEY hKey,
    LPTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    )
{
    LONG    Rslt;
    HKEY    hKeyNew;
    DWORD   Disposition;


    if (CreateNewKey) {
        Rslt = RegCreateKeyEx(
            hKey,
            KeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            NULL,
            &hKeyNew,
            &Disposition
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            return NULL;
        }

    } else {
        Rslt = RegOpenKeyEx(
            hKey,
            KeyName,
            0,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            &hKeyNew
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            return NULL;
        }
    }

    return hKeyNew;
}


LPTSTR
GetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    BOOL    Success = FALSE;
    DWORD   Size;
    LONG    Rslt;
    DWORD   Type;
    LPBYTE  Buffer = NULL;
    LPBYTE  ExpandBuffer = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == ERROR_FILE_NOT_FOUND) {
            Size = StringSize( DefaultValue );
        } else {
            goto exit;
        }
    }

    Buffer = (LPBYTE) LocalAlloc( LPTR, Size );
    if (!Buffer) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt != ERROR_FILE_NOT_FOUND) {
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        _tcscpy( (LPTSTR) Buffer, DefaultValue );

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            RegType,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            goto exit;
        }
    }
    if (RegType == REG_EXPAND_SZ) {
        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, NULL, 0 );
        if (!Rslt) {
            goto exit;
        }

        ExpandBuffer = (LPBYTE) LocalAlloc( LPTR, (Rslt + 1) * sizeof(WCHAR) );
        if (!ExpandBuffer) {
            goto exit;
        }

        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, (LPTSTR) ExpandBuffer, Rslt );
        if (Rslt == 0) {
            LocalFree( ExpandBuffer );
            goto exit;
        }
        LocalFree( Buffer );
        Buffer = ExpandBuffer;
    }

    Success = TRUE;

exit:
    if (!Success) {
        LocalFree( Buffer );
        return StringDup( DefaultValue );
    }

    return (LPTSTR) Buffer;
}


LPTSTR
GetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_SZ, ValueName, DefaultValue );
}


LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, DefaultValue );
}


DWORD
GetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName
    )
{
    DWORD   Size = sizeof(DWORD);
    LONG    Rslt;
    DWORD   Type;
    DWORD   Value = 0;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // create the value since it doesn't exist
        //
        Value = 0;

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Value,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            Value = 0;
        }
    }

    return Value;
}


DWORD
GetSubKeyCount(
    HKEY hKey
    )
{
    DWORD KeyCount = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, &KeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return KeyCount;
}


DWORD
GetMaxSubKeyLen(
    HKEY hKey
    )
{
    DWORD MaxSubKeyLen = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, &MaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return MaxSubKeyLen;
}


BOOL
SetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName,
    DWORD Value
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_DWORD,
        (LPBYTE) &Value,
        sizeof(DWORD)
        );
    if (Rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPTSTR ValueName,
    LPTSTR Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        RegType,
        (LPBYTE) Value,
        Length == -1 ? StringSize( Value ) : Length
        );
    if (Rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value,
    DWORD Length
    )
{
    return SetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, Value, Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\resource.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for the NTOC resource file.

Author:

    Wesley Witt (wesw) 7-Aug-1997

Environment:

    User Mode

--*/

#define WIZARD_WIDTH                         304
#define WIZARD_HEIGTH                        140

#define IDC_STATIC                           -1

#define IDD_TAPI_LOCATIONS                   501
#define IDD_DISPLAY                          502
#define IDD_DATETIME                         503
#define IDD_NTOC_WELCOME                     504
#define IDD_NTOC_FINISH                      505
#define IDD_REINSTALL                        506

#define IDC_COUNTRY_LIST                     201
#define IDC_AREA_CODE                        202
#define IDC_LONG_DISTANCE                    203
#define IDC_TONE                             204
#define IDC_PULSE                            205
#define IDC_SCREENSAMPLE                     206
#define IDC_DSP_CLRPALGRP                    207
#define IDC_DSP_COLORBOX                     208
#define IDC_DSP_COLORBAR                     209
#define IDC_DSP_DSKAREAGRP                   210
#define IDC_DSP_AREA_SB                      211
#define IDC_DSP_X_BY_Y                       212
#define IDC_DSP_FONTSIZEGRP                  213
#define IDC_DSP_FONTSIZE                     214
#define IDC_DSP_REFFREQGRP                   215
#define IDC_DSP_FREQ                         216
#define IDC_DSP_LIST_ALL                     217
#define IDC_DSP_TEST                         218
#define IDC_DSP_CHANGE                       219
#define IDC_MONITOR_BITMAP                   220
#define IDC_TEST                             221
#define IDC_DATE_PICKER                      222
#define IDC_TIME_PICKER                      223
#define IDC_TIMEZONE                         224
#define IDC_DAYLIGHT                         225
#define IDC_REFRESH_RATE                     226
#define IDT_TITLE                            227

#define IDS_TAPILOC_TITLE                    301
#define IDS_TAPILOC_SUBTITLE                 302
#define IDS_DISPLAY_TITLE                    303
#define IDS_DISPLAY_SUBTITLE                 304
#define IDS_RESOLUTION_FMT                   305
#define IDS_COLOR_RED                        306
#define IDS_COLOR_GREEN                      307
#define IDS_COLOR_BLUE                       308
#define IDS_COLOR_YELLOW                     309
#define IDS_COLOR_MAGENTA                    310
#define IDS_COLOR_CYAN                       311
#define IDS_COLOR_WHITE                      312
#define IDS_RED_SHADES                       313
#define IDS_GREEN_SHADES                     314
#define IDS_BLUE_SHADES                      315
#define IDS_GRAY_SHADES                      316
#define IDS_PATTERN_HORZ                     317
#define IDS_PATTERN_VERT                     318
#define IDS_UNAVAILABLE                      319
#define IDS_DATETIME_TITLE                   320
#define IDS_DATETIME_SUBTITLE                321
#define IDS_DEFAULT_LOCATION_NAME            322
#define IDS_LARGEFONT_NAME                   323
#define IDS_LARGEFONT_SIZE                   324


//#define IDB_MONITOR_BITMAP                   401
//#define IDB_COLORBAR_BITMAP                  402

#define IDI_DATE                             601
#define IDI_TIMEZONE                         602
#define IDI_MODEM                            603
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\tapi.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.cpp

Abstract:

    This file implements the tapi dialing location page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include "ntoc.h"
#pragma hdrstop


//
// constants
//

#define MY_SET_FOCUS                    (WM_USER+1000)

#define REGKEY_LOCATIONS                L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"
#define REGVAL_NUMENTRIES               L"NumEntries"

#define INTL_SECTION                    L"intl"
#define INTL_COUNTRY                    L"iCountry"

#define REGKEY_LOCATION                 L"Location1"

#define REGVAL_CURRENT_ID               L"CurrentID"
#define REGVAL_NEXT_ID                  L"NextID"
#define REGVAL_NUM_ENTRIES              L"NumEntries"
#define REGVAL_COUNTRY                  L"Country"
#define REGVAL_FLAGS                    L"Flags"
#define REGVAL_ID                       L"ID"
#define REGVAL_AREA_CODE                L"AreaCode"
#define REGVAL_DISABLE_CALL_WAITING     L"DisableCallWaiting"
#define REGVAL_LONG_DISTANCE_ACCESS     L"LongDistanceAccess"
#define REGVAL_NAME                     L"Name"
#define REGVAL_OUTSIDE_ACCESS           L"OutsideAccess"

#define REGKEY_PROVIDERS                L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers"
#define REGVAL_NUMPROVIDERS             L"NumProviders"
#define REGVAL_NEXTPROVIDERID           L"NextProviderID"
#define REGVAL_PROVIDERFILENAME         L"ProviderFileName"
#define REGVAL_PROVIDERID               L"ProviderID"

#define TAPILOC_SECTION                 L"TapiLocation"
#define TPILOC_COUNTRY_CODE             L"CountryCode"
#define TPILOC_DIALING                  L"Dialing"
#define TPILOC_TONE                     L"Tone"
#define TPILOC_AREA_CODE                L"AreaCode"
#define TPILOC_ACCESS                   L"LongDistanceAccess"

#define LOCATION_USETONEDIALING         0x00000001
#define LOCATION_USECALLINGCARD         0x00000002
#define LOCATION_HASCALLWAITING         0x00000004
#define LOCATION_ALWAYSINCLUDEAREACODE  0x00000008

#define MAX_TAPI_STRING                 32
#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

//
// structures
//

typedef struct _TAPI_LOCATION_INFO {
    BOOL            Valid;
    DWORD           Country;
    DWORD           Flags;
    WCHAR           AreaCode[MAX_TAPI_STRING+1];
    WCHAR           LongDistanceAccess[MAX_TAPI_STRING+1];
} TAPI_LOCATION_INFO, *PTAPI_LOCATION_INFO;

typedef struct _TAPI_SERVICE_PROVIDER
{
    DWORD           dwProviderID;
    WCHAR           szProviderName[PROVIDER_FILE_NAME_LEN];
}TAPI_SERVICE_PROVIDER, *PTAPI_SERVICE_PROVIDER;


//
// globals
//

TAPI_LOCATION_INFO TapiLoc;
LPLINECOUNTRYLIST LineCountry;
BOOL TapiBadUnattend;
WCHAR DefaultLocationName[MAX_PATH];


BOOL
IsDeviceModem(
    LPLINEDEVCAPS LineDevCaps
    )
{
    LPTSTR DeviceClassList;
    BOOL UnimodemDevice = FALSE;

    if (LineDevCaps->dwDeviceClassesSize && LineDevCaps->dwDeviceClassesOffset) {
        DeviceClassList = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwDeviceClassesOffset);
        while (*DeviceClassList) {
            if (wcscmp(DeviceClassList,TEXT("comm/datamodem")) == 0) {
                UnimodemDevice = TRUE;
                break;
            }
            DeviceClassList += (wcslen(DeviceClassList) + 1);
        }
    }

    if ((!(LineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
        (!(LineDevCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) {
            //
            // unacceptable modem device type
            //
            UnimodemDevice = FALSE;
    }

    return UnimodemDevice;
}


LPLINEDEVCAPS
MyLineGetDevCaps(
    HLINEAPP hLineApp,
    DWORD    TapiApiVersion,
    DWORD    DeviceId
    )
{
    DWORD LineDevCapsSize;
    LPLINEDEVCAPS LineDevCaps = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DWORD LocalTapiApiVersion;
    LINEEXTENSIONID  lineExtensionID;


    Rslt = lineNegotiateAPIVersion(
            hLineApp,
            DeviceId,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );


    //
    // allocate the initial linedevcaps structure
    //

    LineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    LineDevCaps = (LPLINEDEVCAPS) LocalAlloc( LPTR, LineDevCapsSize );
    if (!LineDevCaps) {
        return NULL;
    }

    LineDevCaps->dwTotalSize = LineDevCapsSize;

    Rslt = lineGetDevCaps(
        hLineApp,
        DeviceId,
        LocalTapiApiVersion,
        0,
        LineDevCaps
        );

    if (Rslt != 0) {
        //
        // lineGetDevCaps() can fail with error code 0x8000004b
        // if a device has been deleted and tapi has not been
        // cycled.  this is caused by the fact that tapi leaves
        // a phantom device in it's device list.  the error is
        // benign and the device can safely be ignored.
        //
        if (Rslt != LINEERR_INCOMPATIBLEAPIVERSION) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
        }
        goto exit;
    }

    if (LineDevCaps->dwNeededSize > LineDevCaps->dwTotalSize) {

        //
        // re-allocate the linedevcaps structure
        //

        LineDevCapsSize = LineDevCaps->dwNeededSize;

        LocalFree( LineDevCaps );

        LineDevCaps = (LPLINEDEVCAPS) LocalAlloc( LPTR, LineDevCapsSize );
        if (!LineDevCaps) {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetDevCaps(
            hLineApp,
            DeviceId,
            LocalTapiApiVersion,
            0,
            LineDevCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        LocalFree( LineDevCaps );
        LineDevCaps = NULL;
    }

    return LineDevCaps;
}



LPLINECOUNTRYLIST
MyLineGetCountry(
    void
    )
{
    #define DEFAULT_COUNTRY_SIZE 65536

    LPLINECOUNTRYLIST LineCountry = (LPLINECOUNTRYLIST) LocalAlloc( LPTR, DEFAULT_COUNTRY_SIZE );
    if (!LineCountry) {
      SetLastError(ERROR_NOT_ENOUGH_MEMORY);
      return NULL;
    }

    LineCountry->dwTotalSize = DEFAULT_COUNTRY_SIZE;
    if (lineGetCountry( 0, 0x00020001, LineCountry ) != 0) {
        return NULL;
    }

    if (LineCountry->dwNeededSize > LineCountry->dwTotalSize) {
        DWORD Size = LineCountry->dwNeededSize;
        LocalFree( LineCountry );
        LineCountry = (LPLINECOUNTRYLIST) LocalAlloc( LPTR, Size );
        if (!LineCountry) {
           SetLastError(ERROR_NOT_ENOUGH_MEMORY);
           return(NULL);
        }
        if (lineGetCountry( 0, 0x00020001, LineCountry ) != 0) {
            return NULL;
        }
    }

    return LineCountry;
}


static TAPI_SERVICE_PROVIDER DefaultProviders[] = {(DWORD)-1, L"unimdm.tsp",
                                                   (DWORD)-1, L"kmddsp.tsp",
                                                   (DWORD)-1, L"ndptsp.tsp",
                                                   (DWORD)-1, L"ipconf.tsp",
                                                   (DWORD)-1, L"h323.tsp",
                                                   (DWORD)-1, L"hidphone.tsp"};
#define NUM_DEFAULT_PROVIDERS           (sizeof(DefaultProviders)/sizeof(DefaultProviders[0]))

void
TapiInitializeProviders (void)
{
 DWORD dwNextProviderID = 1;
 DWORD dwExistingProviders = 0;
 DWORD dwMaxProviderID = 0;
 DWORD dwNextProviderNr = 0;
 HKEY  hKeyProviders = NULL;
 DWORD cbData, i, j;
 WCHAR szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 WCHAR szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 WCHAR szFileName[24];          // Enough to hold "ProviderFileNameXXXXX\0"
 WCHAR *pProviderFileNameNumber, *pProviderIDNumber;
 PTAPI_SERVICE_PROVIDER Providers = NULL, pProvider;

    // First, create / open the Providers key.
    if (ERROR_SUCCESS !=
        RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKeyProviders, &cbData))
    {
        return;
    }

    // Initialize value names and pointers
    lstrcpy (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpy (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlen (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlen (szProviderID);

    if (REG_CREATED_NEW_KEY == cbData)
    {
        // This means that there are no providers
        // in the registry yet. Go and add all the
        // default ones.
        goto _AddDefaultProviders;
    }

    // Now compute how big a provider array we have to allocate,
    // by looking at how many values there are in the providers key;
    // we divide this number by 2, because each provider will have a file
    // name and an ID.
    if (ERROR_SUCCESS !=
        RegQueryInfoKey (hKeyProviders,
                         NULL, NULL, NULL, NULL, NULL, NULL,
                         &dwExistingProviders,
                         NULL, NULL, NULL, NULL))
    {
        goto _CountProviders;
    }
    dwExistingProviders >>= 1;   // divide by 2
    if (0 == dwExistingProviders)
    {
        // This means that there are no providers
        // in the registry yet. Go and add all the
        // default ones.
        goto _AddDefaultProviders;
    }
    dwExistingProviders++;       // just in case

    // Allocate a provider array with enough entries.
    Providers = (PTAPI_SERVICE_PROVIDER)LocalAlloc (LPTR, dwExistingProviders*sizeof(TAPI_SERVICE_PROVIDER));
    if (NULL == Providers)
    {
        // we couldn't allocate memory, so skip
        // looking for providers and just go and
        // install the default ones.
        goto _AddDefaultProviders;
    }

    // Next, figure out the number of providers already
    // installed, and the next provider ID
    // Instead of reading NumProviders from the registry,
    // try to open each ProviderIDxxx and ProviderFileNameXXX.
    // Do this just in case the registry is not in a good state.
    // Also, store the provider (unless it's t1632tsp) in the
    // array.
_CountProviders:
    pProvider = Providers;
    dwExistingProviders = 0;
    for (i = 0; TRUE; i++)
    {
     BOOL bFound;
        wsprintf (pProviderFileNameNumber, L"%d", i);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);

        cbData = sizeof (szFileName);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderFileName, NULL, NULL, (PBYTE)szFileName, &cbData))
        {
            break;
        }
        cbData = sizeof (dwNextProviderID);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderID, NULL, NULL, (PBYTE)&dwNextProviderID, &cbData))
        {
            // We couldn't read this provider's ID. We must skip it.
            continue;
        }

        // Look for the current provider in the list
        // of default providers
        bFound = FALSE;
        for (j = 0; j < NUM_DEFAULT_PROVIDERS; j++)
        {
            if (0 == lstrcmpi (DefaultProviders[j].szProviderName, szFileName))
            {
                DefaultProviders[j].dwProviderID = dwNextProviderID;
                bFound = TRUE;
                break;
            }
        }

        if (!bFound)
        {
            // We have a provider that was installed by the user on the previous NT installation.
            pProvider->dwProviderID = dwNextProviderID;
            pProvider->szProviderName[0] = 0;
            lstrcpyn (pProvider->szProviderName, szFileName, sizeof(pProvider->szProviderName)/sizeof(pProvider->szProviderName[0]));
            pProvider->szProviderName[sizeof(pProvider->szProviderName)/sizeof(pProvider->szProviderName[0])-1] = 0;
            pProvider++;
            dwExistingProviders++;
        }

        if (dwNextProviderID > dwMaxProviderID)
        {
            dwMaxProviderID = dwNextProviderID;
        }
    }
    dwNextProviderID = dwMaxProviderID + 1;

    // We got a list of all providers that were installed before.
    // Clean up the Providers key.
    for (i = 0; TRUE; i++)
    {
        cbData = sizeof(szFileName)/sizeof(WCHAR);
        if (ERROR_SUCCESS !=
            RegEnumValue (hKeyProviders, i, szFileName, &cbData, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteValue (hKeyProviders, szFileName);
    }

_AddDefaultProviders:
    for (i = 0, pProvider = DefaultProviders;
         i < NUM_DEFAULT_PROVIDERS;
         i++, pProvider++)
    {
        // Found a provider that has to be added.
        // Compute it's value names.
        wsprintf (pProviderFileNameNumber, L"%d", dwNextProviderNr);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueEx (hKeyProviders, szProviderFileName, 0, REG_SZ, (PBYTE)pProvider->szProviderName,
                           (lstrlen(pProvider->szProviderName)+1)*sizeof(WCHAR)))
        {
         DWORD dwRet;
            if ((DWORD)-1 == pProvider->dwProviderID)
            {
                if (ERROR_SUCCESS == (dwRet =
                    RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                                   (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID))))
                {
                    dwNextProviderID++;
                }
            }
            else
            {
                dwRet = RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                                       (PBYTE)&pProvider->dwProviderID, sizeof(pProvider->dwProviderID));
            }
            if (ERROR_SUCCESS == dwRet)
            {
                dwNextProviderNr++;
            }
            else
            {
                RegDeleteValue (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Now, add all the providers again. We do this because the
    // IDs were REG_BINARY on win98 and have to be REG_DWORD on NT5.
    for (i = 0, pProvider = Providers;
         i < dwExistingProviders;
         i++, pProvider++)
    {
        // Found a provider that has to be added.
        // Compute it's value names.
        wsprintf (pProviderFileNameNumber, L"%d", dwNextProviderNr);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueEx (hKeyProviders, szProviderFileName, 0, REG_SZ,
                           (PBYTE)pProvider->szProviderName,
                           (lstrlen(pProvider->szProviderName)+1)*sizeof(WCHAR)))
        {
            if (ERROR_SUCCESS ==
                RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                               (PBYTE)&pProvider->dwProviderID,
                               sizeof(pProvider->dwProviderID)))
            {
                dwNextProviderNr++;
            }
            else
            {
                RegDeleteValue (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Finally, update NumProviders and NextProviderID.
    RegSetValueEx (hKeyProviders, REGVAL_NUMPROVIDERS, 0, REG_DWORD,
                   (PBYTE)&dwNextProviderNr, sizeof(dwNextProviderNr));
    RegSetValueEx (hKeyProviders, REGVAL_NEXTPROVIDERID, 0, REG_DWORD,
                   (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID));

    RegCloseKey (hKeyProviders);

    if (NULL != Providers)
    {
        LocalFree (Providers);
    }
}

void
CopyTsecFile (
    void
    )
{
    TCHAR               szWndDir[MAX_PATH];
    TCHAR               szSrc[MAX_PATH];
    TCHAR               szDest[MAX_PATH];
    TCHAR               szBuf[MAX_PATH];
    HANDLE              hFileIn = INVALID_HANDLE_VALUE;
    HANDLE              hFileOut = INVALID_HANDLE_VALUE;
    const TCHAR         szTsecSrc[] = TEXT("\\tsec.ini");
    const TCHAR         szTsecDest[] = TEXT("\\TAPI\\tsec.ini");
    DWORD               dwBytesRead, dwBytesWritten;
    BOOL                bError = FALSE;

    if (GetWindowsDirectory (szWndDir, sizeof(szWndDir)/sizeof(TCHAR)) == 0 ||
        lstrlen(szWndDir) + lstrlen(szTsecSrc) >= sizeof(szSrc)/sizeof(TCHAR) ||
        lstrlen(szWndDir) + lstrlen(szTsecDest) >= sizeof(szDest)/sizeof(TCHAR))
    {
        goto ExitHere;
    }

    lstrcpy (szSrc, szWndDir);
    lstrcat (szSrc, szTsecSrc);
    lstrcpy (szDest, szWndDir);
    lstrcat (szDest, szTsecDest);

    hFileIn = CreateFile (
        szSrc,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    hFileOut = CreateFile (
        szDest,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (hFileIn == INVALID_HANDLE_VALUE || hFileOut == INVALID_HANDLE_VALUE)
    {
        goto ExitHere;
    }

    do
    {
        if (!ReadFile (
            hFileIn,
            (LPVOID) szBuf,
            sizeof(szBuf),
            &dwBytesRead,
            NULL)
            )
        {
            bError = TRUE;
            dwBytesRead = 0;
        }
        if (dwBytesRead != 0)
        {
            if (!WriteFile (
                hFileOut,
                (LPVOID) szBuf,
                dwBytesRead,
                &dwBytesWritten,
                NULL
                ) ||
                dwBytesRead != dwBytesWritten)
            {
                bError = TRUE;
            }

        }
    } while (dwBytesRead != 0);

    //
    //  Be extra careful not to loose any data, delete
    //  old file only if we are sure no error happened
    //
    if (!bError)
    {
        CloseHandle (hFileIn);
        hFileIn = INVALID_HANDLE_VALUE;
        DeleteFile (szSrc);
    }

ExitHere:
    if (hFileIn != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileIn);
    }
    if (hFileOut != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileOut);
    }
}

void
TapiInit(
    void
    )
{
    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) {
        return;
    }

    CopyTsecFile();

    TapiInitializeProviders ();

    LineCountry = MyLineGetCountry();
    LoadString( hInstance, IDS_DEFAULT_LOCATION_NAME, DefaultLocationName, sizeof(DefaultLocationName)/sizeof(WCHAR) );
}


void
TapiCommitChanges(
    void
    )
{
    HKEY hKey, hKeyLoc;

    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) {
        return;
    }

    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
        return;
    }

    if (TapiLoc.Valid) {
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_LOCATIONS, TRUE, KEY_ALL_ACCESS );
        if (hKey) {
            SetRegistryDword( hKey, REGVAL_CURRENT_ID, 1 );
            SetRegistryDword( hKey, REGVAL_NEXT_ID, 2 );
//            SetRegistryDword( hKey, REGVAL_NUM_ENTRIES, 1 );

            hKeyLoc = OpenRegistryKey( hKey, REGKEY_LOCATION, TRUE, KEY_ALL_ACCESS );
            if (hKeyLoc) {

                SetRegistryDword( hKeyLoc, REGVAL_COUNTRY, TapiLoc.Country );
                SetRegistryDword( hKeyLoc, REGVAL_FLAGS, TapiLoc.Flags );
//                SetRegistryDword( hKeyLoc, REGVAL_ID, 1 );

                SetRegistryString( hKeyLoc, REGVAL_AREA_CODE, TapiLoc.AreaCode );
                SetRegistryString( hKeyLoc, REGVAL_DISABLE_CALL_WAITING, L"" );
                SetRegistryString( hKeyLoc, REGVAL_LONG_DISTANCE_ACCESS, TapiLoc.LongDistanceAccess );
                SetRegistryString( hKeyLoc, REGVAL_NAME, DefaultLocationName );
                SetRegistryString( hKeyLoc, REGVAL_OUTSIDE_ACCESS, TapiLoc.LongDistanceAccess );

                RegCloseKey( hKeyLoc );
            }
            RegCloseKey( hKey );
        }
    }
}

INT
IsCityCodeOptional(
    LPLINECOUNTRYENTRY pEntry
    )
{
#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

    if (pEntry  && pEntry->dwLongDistanceRuleSize && pEntry->dwLongDistanceRuleOffset )
    {
        LPWSTR  pLongDistanceRule;
        pLongDistanceRule = (LPTSTR)((PBYTE)LineCountry + pEntry->dwLongDistanceRuleOffset);

        if (wcschr(pLongDistanceRule, L'F') != NULL) return AREACODE_REQUIRED;
        if (wcschr(pLongDistanceRule, L'I') == NULL) return AREACODE_DONTNEED;
    }

    return AREACODE_OPTIONAL;
}



BOOL
TapiOnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lParam
    )
{
    SendDlgItemMessage( hwnd, IDC_AREA_CODE, EM_LIMITTEXT, MAX_TAPI_STRING, 0 );
    SendDlgItemMessage( hwnd, IDC_LONG_DISTANCE, EM_LIMITTEXT, MAX_TAPI_STRING, 0 );

    CheckRadioButton( hwnd, IDC_TONE, IDC_PULSE, IDC_TONE );

    if (LineCountry) {
        DWORD CurrCountryCode = GetProfileInt( INTL_SECTION, INTL_COUNTRY, 1 );
        LPLINECOUNTRYENTRY LineCountryEntry = (LPLINECOUNTRYENTRY) ((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);
        DWORD Selection = 0;
        DWORD Index;
        LPWSTR CountryName ;
        for (DWORD i=0; i<LineCountry->dwNumCountries; i++) {
            CountryName = (LPWSTR) ((LPBYTE)LineCountry + LineCountryEntry[i].dwCountryNameOffset);
            Index = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_ADDSTRING, 0, (LPARAM)CountryName );
            SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_SETITEMDATA, Index, i );
            if (LineCountryEntry[i].dwCountryID == CurrCountryCode) {
                Selection = i;
            }
        }
        CountryName = (LPWSTR) ((LPBYTE)LineCountry + LineCountryEntry[Selection].dwCountryNameOffset);
        Selection = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_FINDSTRING, 0, (LPARAM) CountryName );
        SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_SETCURSEL, Selection, 0 );

    }

    PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_AREA_CODE ) );

    return TRUE;
}


VOID
ValidateAndSetWizardButtons( HWND hwnd )
{

    BOOL AreaCodeOk;

    {
        DWORD CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETCURSEL, 0, 0 );
        LPLINECOUNTRYENTRY CntryFirstEntry = NULL;
        INT AreaCodeInfo = 0;
        WCHAR Buffer[MAX_TAPI_STRING+1];

        GetDlgItemText( hwnd, IDC_AREA_CODE, Buffer, MAX_TAPI_STRING );
        CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETITEMDATA, CurrCountry, 0 );
        CntryFirstEntry = (LPLINECOUNTRYENTRY)((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);
        AreaCodeInfo = IsCityCodeOptional( CntryFirstEntry + CurrCountry );

        AreaCodeOk = TRUE;

        //
        // If the area code is required, then there must be a value in the Buffer.
        //
        // Otherwise, it's OK.
        //
        if ( ( AreaCodeInfo == AREACODE_REQUIRED ) && ( *Buffer == UNICODE_NULL ) ){
           AreaCodeOk = FALSE;
        }
    }

    if ( TapiLoc.Valid )
        AreaCodeOk = TRUE;

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | ( AreaCodeOk ? PSWIZB_NEXT : 0 ) );

}


BOOL
TapiOnCommand(
    IN HWND hwnd,
    IN DWORD NotifyCode,
    IN DWORD ControlId,
    IN HWND hwndControl
    )
{
    // If the area code changed, or the country code changed
    if ((NotifyCode == EN_CHANGE && ControlId == IDC_AREA_CODE) ||
        (NotifyCode == CBN_SELCHANGE && ControlId == IDC_COUNTRY_LIST)) {
        ValidateAndSetWizardButtons(hwnd);
    }

    return TRUE;
}


BOOL
TapiOnNotify(
    IN HWND hwnd,
    IN WPARAM ControlId,
    IN LPNMHDR pnmh
    )
{
    switch (pnmh->code ) {
        case PSN_SETACTIVE:
            {
                HKEY hKey;
                DWORD NumEntries, Size;
                WCHAR buf[MAX_TAPI_STRING+1];
                BOOL OverrideMissingAreaCode = FALSE;

                if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
                    SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                    return TRUE;
                }

                if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_LOCATIONS, &hKey ) == ERROR_SUCCESS) {
                    Size = sizeof(DWORD);
                    if (RegQueryValueEx( hKey, REGVAL_NUMENTRIES, NULL, NULL, (LPBYTE)&NumEntries, &Size ) == ERROR_SUCCESS) {
                        if (NumEntries > 0 && !TapiLoc.Valid) {
                            SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                            return TRUE;
                        }
                    }
                    RegCloseKey( hKey );
                }

                // Look at the existing values on the page to see if everything
                // is OK to go to the next page
                ValidateAndSetWizardButtons(hwnd);

                TapiLoc.Valid = FALSE;

                HLINEAPP hLineApp;
                LINEINITIALIZEEXPARAMS LineInitializeExParams;
                DWORD TapiDevices = 0, ModemDevices = 0;
                DWORD LocalTapiApiVersion = 0x00020000;
                DWORD Rval;

                LineInitializeExParams.dwTotalSize      = sizeof(LINEINITIALIZEEXPARAMS);
                LineInitializeExParams.dwNeededSize     = 0;
                LineInitializeExParams.dwUsedSize       = 0;
                LineInitializeExParams.dwOptions        = LINEINITIALIZEEXOPTION_USEEVENT;
                LineInitializeExParams.Handles.hEvent   = NULL;
                LineInitializeExParams.dwCompletionKey  = 0;

                Rval = lineInitializeEx(
                    &hLineApp,
                    hInstance,
                    NULL,
                    TEXT("Setup"),
                    &TapiDevices,
                    &LocalTapiApiVersion,
                    &LineInitializeExParams
                    );

                if (Rval == 0) {
                    for (DWORD i=0; i< TapiDevices; i++ ) {
                        LPLINEDEVCAPS ldc = MyLineGetDevCaps( hLineApp, LocalTapiApiVersion, i );
                        if (ldc) {
                            if (IsDeviceModem(ldc)) {
                                ModemDevices++;
                            }

                            LocalFree( ldc );
                        }
                    }

                    lineShutdown( hLineApp );
                }

                // If lineInitilaizeEx failed or there are no modem devices installed
                // then suppress this wizard page.

                if ( Rval != 0 || ModemDevices == 0 )
                {
                   SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );         // don't activate this page
                   return TRUE;
                }
            }

            if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) {
                //
                // unattended mode
                //

                WCHAR Buf[MAX_TAPI_STRING+1];

                TapiLoc.Country = GetPrivateProfileInt(
                                      TAPILOC_SECTION,
                                      TPILOC_COUNTRY_CODE,
                                      1,
                                      SetupInitComponent.SetupData.UnattendFile
                                      );

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_DIALING,
                    TPILOC_TONE,
                    Buf,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                if (_wcsicmp( Buf, TPILOC_TONE ) == 0) {
                    TapiLoc.Flags = LOCATION_USETONEDIALING;
                } else {
                    TapiLoc.Flags = 0;
                }

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_AREA_CODE,
                    L"1",
                    TapiLoc.AreaCode,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_ACCESS,
                    L"",
                    TapiLoc.LongDistanceAccess,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                TapiLoc.Valid = TRUE;

                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                return TRUE;
            }

            // If we get here the user needs  has click next or back.
            // Make sure the wizard page is showing.
            // For Whistler GUI mode we try to hide wizard pages and show a background
            // billboard if there is only a progress bar.
            //
            SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);

            PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_AREA_CODE ) );
            break;

        case PSN_WIZNEXT:
            {
                DWORD CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETCURSEL, 0, 0 );
                CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETITEMDATA, CurrCountry, 0 );
                LPLINECOUNTRYENTRY LineCountryEntry = (LPLINECOUNTRYENTRY) ((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);

                TapiLoc.Country = LineCountryEntry[CurrCountry].dwCountryID;

                GetDlgItemText( hwnd, IDC_AREA_CODE, TapiLoc.AreaCode, MAX_TAPI_STRING );
                GetDlgItemText( hwnd, IDC_LONG_DISTANCE, TapiLoc.LongDistanceAccess, MAX_TAPI_STRING );

                if (IsDlgButtonChecked( hwnd, IDC_TONE )) {
                    TapiLoc.Flags = LOCATION_USETONEDIALING;
                } else {
                    TapiLoc.Flags = 0;
                }


                //
                // If an area code was not set but the areacode is required, then
                // fail to continue "going next."
                //
                if ((TapiLoc.AreaCode[0] == 0) &&
                    (IsCityCodeOptional(LineCountryEntry + CurrCountry) == AREACODE_REQUIRED)) {
                    SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                    return TRUE;
                }

                TapiLoc.Valid = TRUE;
            }

            break;
    }

    return FALSE;
}


INT_PTR CALLBACK
TapiLocDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageTapiLoc );

    switch( message ) {
        case WM_INITDIALOG:
            return TapiOnInitDialog( hwnd, (HWND)wParam, lParam );

        case WM_COMMAND:
            return TapiOnCommand( hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

        case WM_NOTIFY:
            return TapiOnNotify( hwnd, wParam, (LPNMHDR) lParam );

        case MY_SET_FOCUS:
            SetFocus( (HWND) lParam );
            SendMessage( (HWND) lParam, EM_SETSEL, 0, MAKELPARAM( 0, -1 ) );
            return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\welcome.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.cpp

Abstract:

    This file implements the welcome and finish pages.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (andrewr) 24-July-1998

--*/

#include "ntoc.h"
#pragma hdrstop

HFONT hBigFont = NULL;

HFONT
GetBigFont(
    void
    ) 
{

    LOGFONT         LargeFont;
    NONCLIENTMETRICS ncm = {0};
    WCHAR           FontName[100];
    WCHAR           FontSize[30];
    int             iFontSize;
    HDC             hdc;
    HFONT           hFont = NULL;
    
    //
    // get the large fonts for wizard97
    // 
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    CopyMemory((LPVOID* )&LargeFont,(LPVOID *) &ncm.lfMessageFont,sizeof(LargeFont) );

    
    LoadStringW(hInstance,IDS_LARGEFONT_NAME,FontName,sizeof(FontName)/sizeof(WCHAR) );
    LoadStringW(hInstance,IDS_LARGEFONT_SIZE,FontSize,sizeof(FontSize)/sizeof(WCHAR) );

    iFontSize = wcstoul( FontSize, NULL, 10 );

    // make sure we at least have some basic font
    if (*FontName == 0 || iFontSize == 0) {
        lstrcpy(FontName,TEXT("MS Shell Dlg") );
        iFontSize = 18;
    }

    LargeFont.lfFaceName[0] = 0;
    lstrcpyn(LargeFont.lfFaceName, FontName, sizeof(LargeFont.lfFaceName)/sizeof(LargeFont.lfFaceName[0]));
    LargeFont.lfFaceName[sizeof(LargeFont.lfFaceName)/sizeof(LargeFont.lfFaceName[0])-1] = 0;
    LargeFont.lfWeight   = FW_BOLD;

    if ((hdc = GetDC(NULL))) {
        LargeFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * iFontSize / 72);
        hFont = CreateFontIndirect(&LargeFont);
        ReleaseDC( NULL, hdc);
    }

    return hFont;

}


void    
WelcomeInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
WelcomeCommit(
    void
    ) 
{
    
    return;

}

#if 0
void    
ReinstallInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
ReinstallCommit(
    void
    ) 
{
    
    return;

}
#endif


void    
FinishInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
FinishCommit(
    void
    ) 
{
    
    return;

}



INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL FirstTime = TRUE;
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageWelcome );
    
    switch( message ) {
        case WM_INITDIALOG:
            
            if (hBigFont) {
                SetWindowFont(GetDlgItem(hwnd,IDT_TITLE), hBigFont, TRUE);        
            }
            break;

        case WM_NOTIFY:

            switch (((NMHDR *) lParam)->code) {
            
                case PSN_SETACTIVE:
#if 0
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
                        return TRUE;
                    }
#else
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
                        return TRUE;
                    }
                    
                    if (FirstTime) {
                        SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );                        
                        FirstTime = FALSE;
                        return TRUE;
                    }                                  
#endif

                break;
    
            }
            break;
    }

    return FALSE;
}

INT_PTR CALLBACK
FinishDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageFinal );

    switch( message ) {
        case WM_INITDIALOG:
            //PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_FINISH );

            //
            // don't allow cancel on the finish page...it's too late
            //
            ShowWindow(GetDlgItem(GetParent(hwnd),IDCANCEL),SW_HIDE);


            if (hBigFont) {
                SetWindowFont(GetDlgItem(hwnd,IDT_TITLE), hBigFont, TRUE);        
            }
            break;

        case WM_NOTIFY:

            switch (((NMHDR *) lParam)->code) {
            
                case PSN_SETACTIVE:
            
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_FINISH );
                        return TRUE;
                    }
        
                }

            break;

    }

    return FALSE;
}

#if 0
BOOL CALLBACK
ReinstallDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageReinstall );

    switch( message ) {
        case WM_INITDIALOG:
            //PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT );

            break;

        case WM_NOTIFY:
        
        switch (((NMHDR *) lParam)->code) {
        
            case PSN_SETACTIVE:
                //if (!NoChanges) {
                //    SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                //}
            break;
        
            case PSN_WIZNEXT:
                if (IsDlgButtonChecked(hwnd,IDYES)) {
                    
                    SetupInitComponent.HelperRoutines.SetSetupMode(
                        SetupInitComponent.HelperRoutines.OcManagerContext , 
                        SETUPMODE_REINSTALL | SetupInitComponent.HelperRoutines.GetSetupMode( SetupInitComponent.HelperRoutines.OcManagerContext )
                        );
                    
                }

                break;

            default:
               ;
        };

        default:
        ;

    };

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\dll.c ===
#include "precomp.h"
#pragma hdrstop


HMODULE MyModuleHandle;

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        InitCommonControls();
        MyModuleHandle = DllHandle;
        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\oc.h ===
//
// Need to include below 3 files for "IsNEC_98", even if DEBUGPERFTRACE does not defined.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>

#include <prsht.h>

#include <commctrl.h>

#ifdef PRERELEASE
#ifdef DBG
#include <objbase.h>
#endif
#endif

#include <setupapi.h>
#include <spapip.h>

#include <ocmanage.h>
#include <ocmgrlib.h>

#include <tchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <assert.h>

#include <winnls.h>

#ifdef UNICODE
    #include <sfcapip.h>
#endif

#include "msg.h"
#include "res.h"

#if DBG

#define MYASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else

#define MYASSERT( exp )

#endif // DBG

//
// Names of wizard page types.
//
extern LPCTSTR WizardPagesTypeNames[WizPagesTypeMax];

//
// Window handle of wizard dialog. Set when the OC Manager client
// calls OcRememberWizardDialogHandle.
//
extern HWND WizardDialogHandle;

//
// Name of sections and keys in infs.
//
extern LPCTSTR szComponents;
extern LPCTSTR szOptionalComponents;
extern LPCTSTR szExtraSetupFiles;
extern LPCTSTR szNeeds;
extern LPCTSTR szParent;
extern LPCTSTR szIconIndex;
extern LPCTSTR szTip;
extern LPCTSTR szOptionDesc;
extern LPCTSTR szInstalledFlag;

//
// Key in registry where private component data is kept.
// We form a unique name within this key for the OC Manager
// instantiation.
//
extern LPCTSTR szPrivateDataRoot;
extern LPCTSTR szMasterInfs;
extern LPCTSTR szSubcompList;

//
// Other string constants.
//
extern LPCTSTR szSetupDir;
extern LPCTSTR szOcManagerErrors;
//
// DLL module handle.
//
extern HMODULE MyModuleHandle;

//
// for debugging
//
extern DWORD gDebugLevel;

//
// Define structure describing an optional component.
//
typedef struct _OPTIONAL_COMPONENT {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    TCHAR IconDll[MAX_PATH];
    TCHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    TCHAR Description[MAXOCDESC];
    TCHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    TCHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    // points to the helper context for this component

    struct _HELPER_CONTEXT *HelperContext;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} OPTIONAL_COMPONENT, *POPTIONAL_COMPONENT;

//
// locale info
//
typedef struct _LOCALE {
    LCID    lcid;
    TCHAR   DecimalSeparator[4];
} LOCALE, *PLOCALE;

extern LOCALE locale;

//
// Indices for installation states.
//
#define INSTSTATE_NO         0
#define INSTSTATE_UNKNOWN    1
#define INSTSTATE_YES        2

//
// Flags for InternalFlags member of OPTIONAL_COMPONENT structure.
//
#define OCFLAG_PROCESSED        0x00000001
#define OCFLAG_ANYORIGINALLYON  0x00000002
#define OCFLAG_ANYORIGINALLYOFF 0x00000004
#define OCFLAG_HIDE             0x00000008
#define OCFLAG_STATECHANGE      0x00000010
#define OCFLAG_TOPLEVELITEM     0x00000020
#define OCFLAG_NEWITEM          0x00000040
#define OCFLAG_NOWIZARDPAGES    0x00000080
#define OCFLAG_APPROXSPACE      0x00000100
#define OCFLAG_NOQUERYSKIPPAGES 0x00000200
#define OCFLAG_NOEXTRAROUTINES  0x00000400



// indicates an exception when calling a component

#define ERROR_CALL_COMPONENT   -666

//
// values to sync copies with the OS
//
#define OC_ALLOWRENAME              TEXT("AllowProtectedRenames")


//
// Define structure describing a per-component inf.
//
typedef struct _OC_INF {
    //
    // Handle to open inf file.
    //
    HINF Handle;

} OC_INF, *POC_INF;


//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _OC_MANAGER {
        //
    // Callbacks into OC Manaer client.
    //
    OCM_CLIENT_CALLBACKS Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    TCHAR MasterOcInfPath[MAX_PATH];
    TCHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    TCHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    TCHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    TCHAR SetupPageTitle[MAX_PATH];

    // window title

    TCHAR WindowTitle[MAX_PATH];

    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;

    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    TCHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    PLONG AbortedComponentIds;
    UINT  AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATA SetupData;

} OC_MANAGER, *POC_MANAGER;

//
// Flags for InternalFlags member of OC_MANAGER structure
//
#define OCMFLAG_ANYORIGINALLYON     0x00000001
#define OCMFLAG_ANYORIGINALLYOFF    0x00000002
#define OCMFLAG_ANYDELAYEDMOVES     0x00000004
#define OCMFLAG_NEWINF              0x00000008
#define OCMFLAG_USERCANCELED        0x00000010
#define OCMFLAG_FILEABORT           0x00000020
#define OCMFLAG_NOPREOCPAGES        0x00000040
#define OCMFLAG_KILLSUBCOMPS        0x00000080
#define OCMFLAG_ANYINSTALLED        0x00000100
#define OCMFLAG_ANYUNINSTALLED      0x00000200
#define OCMFLAG_RUNQUIET            0x00000400
#define OCMFLAG_LANGUAGEAWARE       0x00000800

//
// Define structure we use to get back to a particular component
// when a component calls a helper routine asynchronously (for routines
// such as get and set private data).
//
// As each component is initialized it gets one of these structures.
//
typedef struct _HELPER_CONTEXT {
    POC_MANAGER OcManager;
    LONG ComponentStringId;
} HELPER_CONTEXT, *PHELPER_CONTEXT;


//
// Macros for callbacks. Assumes there is a local variable called OcManager
// that is of type POC_MANAGER.
//
#define OcFillInSetupDataA(p)   OcManager->Callbacks.FillInSetupDataA(p)
#ifdef UNICODE
#define OcFillInSetupDataW(p)   OcManager->Callbacks.FillInSetupDataW(p)
#endif
#define OcLogError              OcManager->Callbacks.LogError

//
// Global table of helper routines.
//

extern OCMANAGER_ROUTINESA HelperRoutinesA;
#ifdef UNICODE
extern OCMANAGER_ROUTINESW HelperRoutinesW;
#endif

extern EXTRA_ROUTINESA ExtraRoutinesA;
#ifdef UNICODE
extern EXTRA_ROUTINESW ExtraRoutinesW;
#endif

// ocm phase ids for reporting errors with

typedef enum {
    pidCallComponent = 0,
    pidLoadComponent,
    pidPreInit,
    pidInitComponent,
    pidRequestPages,
    pidCalcDiskSpace,
    pidQueueFileOps,
    pidQueryStepCount,
    pidCompleteInstallation,
    pidExtraRoutines
} pid;


//
// Misc routines.
//
VOID
pOcGetApproximateDiskSpace(
    IN POC_MANAGER OcManager
    );

LONG
pOcGetTopLevelComponent(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    );

VOID
pOcTickSetupGauge(
    IN OUT POC_MANAGER OcManager
    );

UINT
_LogError(
    IN POC_MANAGER  OcManager,
    IN OcErrorLevel ErrorLevel,
    IN UINT         MessageId,
    ...
    );

UINT
pOcCreateComponentSpecificMiniIcon(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN LPCTSTR     Subcomponent,
    IN UINT        Width,
    IN UINT        Height,
    IN LPCTSTR     DllName,         OPTIONAL
    IN LPCTSTR     ResourceId       OPTIONAL
    );

VOID
pOcUpdateParentSelectionStates(
    IN POC_MANAGER OcManager,
    IN HWND        ListBox,             OPTIONAL
    IN LONG        SubcomponentStringId
    );

VOID
pOcFormSuitePath(
    IN  LPCTSTR SuiteName,
    IN  LPCTSTR FileName,   OPTIONAL
    OUT LPTSTR  FullPath
    );

BOOL
OcHelperConfirmCancel(
    IN HWND ParentWindow
    );

BOOL
pOcDoesAnyoneWantToSkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     OcManagerPage WhichPage
    );

VOID
pOcExternalProgressIndicator(
    IN PHELPER_CONTEXT OcManagerContext,
    IN BOOL            ExternalIndicator
    );

BOOL
pConvertStringToLongLong(
    IN  PCTSTR   String,
    OUT PLONGLONG Value
    );

VOID
pOcFreeOcSetupPage(
    IN PVOID SetupPageData
    );

HRESULT
FTestForOutstandingCoInits(
    VOID
    );

//
// wrapper for calling components
//
DWORD
CallComponent(
    IN     POC_MANAGER OcManager,
    IN     POPTIONAL_COMPONENT Oc,
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Interfacing routines.
//
UINT
OcInterfacePreinitialize(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

UINT
OcInterfaceInitComponent(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

UINT
OcInterfaceExtraRoutines(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

SubComponentState
OcInterfaceQueryState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     UINT        WhichState
    );

BOOL
OcInterfaceSetLanguage(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     WORD        LanguageId
    );

HBITMAP
OcInterfaceQueryImage(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    );

HBITMAP
OcInterfaceQueryImageEx(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    );



VOID
OcInterfaceWizardCreated(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     HWND        DialogHandle
    );

UINT
OcInterfaceRequestPages(
    IN OUT POC_MANAGER           OcManager,
    IN     LONG                  ComponentId,
    IN     WizardPagesType       WhichPages,
    OUT    PSETUP_REQUEST_PAGES *RequestPages
    );

BOOL
OcInterfaceQuerySkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     OcManagerPage WhichPage
    );

BOOL
OcInterfaceNeedMedia(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PSOURCE_MEDIA SourceMedia,
    OUT    LPTSTR        NewPath
    );

BOOL
OcInterfaceFileBusy(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PFILEPATHS    FIlePaths,
    OUT    LPTSTR        NewPath
    );

BOOL
OcInterfaceQueryChangeSelState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        Selected,
    IN     UINT        Flags
    );

UINT
OcInterfaceCalcDiskSpace(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HDSKSPC     DiskSpaceList,
    IN     BOOL        AddingToList
    );

UINT
OcInterfaceQueueFileOps(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HSPFILEQ    FileQueue
    );

UINT
OcInterfaceQueryStepCount(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    OUT    PUINT       StepCount
    );

UINT
OcInterfaceCompleteInstallation(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        PreQueueCommit
    );

VOID
OcInterfaceCleanup(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

DWORD
StandAloneSetupAppInterfaceRoutine(
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Persistent state fetch/store
//
BOOL
pOcFetchInstallStates(
    IN POC_MANAGER OcManager
    );

BOOL
pOcRememberInstallStates(
    IN POC_MANAGER OcManager
    );

BOOL
pOcSetOneInstallState(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    );

BOOL
pOcRemoveComponent(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN DWORD       PhaseId
    );

BOOL
pOcComponentWasRemoved(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId
    );

BOOL
pOcHelperReportExternalError(
    IN POC_MANAGER OcManager,
    IN LONG     ComponentId,
    IN LONG     SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    ...
    );
//
// Use this flag to call OcHelperReportExternalError and use
// a Message ID defined in the OCManage.dll
//
#define ERRFLG_OCM_MESSAGE   0x80000000

BOOL
OcHelperClearExternalError (
    IN POC_MANAGER   OcManager,
    IN LONG ComponentId,
    IN LONG SubcomponentId   OPTIONAL
    );


//
// Debuging stuff
//
#if DBG
#define _OC_DBG
#endif

//
// should not be defined for retail release!!!
//
#if PRERELEASE
#define _OC_DBG
#endif

VOID
_ErrOut(
    IN LPCTSTR Format,
    ...
    );

VOID
_WrnOut(
    IN LPCTSTR Format,
    ...
    );

VOID
_TrcOut(
    IN LPCTSTR Format,
    ...
    );

#define ERR(x)      _ErrOut  x

//
// these guys are switched out in a free build.
//
#ifdef _OC_DBG
    #define TRACE(x)    _TrcOut x
    #define WRN(x)      _WrnOut x
    #define DBGOUT(x)   \
                        if (gDebugLevel >= 100) _TrcOut  x
#else
    #define TRACE(x)
    #define WRN(x)
    #define DBGOUT(x)
#endif

// Normally a call to tmbox is for debug tracing and all such calls
// should be removed before checking in.  However, if called through
// the mbox() macro, this indicates the call is meant to ship.

DWORD
tmbox(
      LPCTSTR fmt,
      ...
      );

#define mbox tmbox
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ntoc\util.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This file implements utility functions.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 3-Dec-1997

--*/

#include "ntoc.h"
#pragma hdrstop

WCHAR gpszError[] = L"Unknown Error";

void
dprintf(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    WCHAR buf[1024];
    DWORD len;
    va_list arg_ptr;


    va_start(arg_ptr, Format);

    _vsnwprintf(buf, sizeof(buf)/sizeof(buf[0]), Format, arg_ptr);
    // make sure we have room to write past the length of the string
    buf[sizeof(buf)/sizeof(buf[0])-3] = L'\0';

    len = wcslen( buf );
    if (len > 0) {
        if (buf[len-1] != L'\n') {
            buf[len] = L'\r';
            buf[len+1] = L'\n';
            buf[len+2] = 0;
        }
    
        OutputDebugString( buf );
    }
}


VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    dprintf(
        L"Assertion error: [%s]  %s @ %d\n",
        Expression,
        File,
        LineNumber
        );

    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
}

/***************************************************************************\
*
*     FUNCTION: FmtMessageBox(HWND hwnd, int dwTitleID, UINT fuStyle,
*                   BOOL fSound, DWORD dwTextID, ...);
*
*     PURPOSE:  Formats messages with FormatMessage and then displays them
*               in a message box
*
*     PARAMETERS:
*               hwnd        - parent window for message box
*               fuStyle     - MessageBox style
*               fSound      - if TRUE, MessageBeep will be called with fuStyle
*               dwTitleID   - Message ID for optional title, "Error" will
*                             be displayed if dwTitleID == -1
*               dwTextID    - Message ID for the message box text
*               ...         - optional args to be embedded in dwTextID
*                             see FormatMessage for more details
* History:
* 22-Apr-1993 JonPa         Created it.
\***************************************************************************/
int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    BOOL fSound,
    DWORD dwTitleID,
    DWORD dwTextID,
    ...
    )
{

    LPTSTR pszMsg;
    LPTSTR pszTitle;
    int idRet;

    va_list marker;

    va_start(marker, dwTextID);

    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,
                       hInstance,
                       dwTextID,
                       0,
                       (LPTSTR)&pszMsg,
                       1,
                       &marker)) {

        pszMsg = gpszError;

    }

    va_end(marker);

    GetLastError();

    pszTitle = NULL;

    if (dwTitleID != -1) {

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_HMODULE |
                          FORMAT_MESSAGE_MAX_WIDTH_MASK |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      hInstance,
                      dwTitleID,
                      0,
                      (LPTSTR)&pszTitle,
                      1,
                      NULL);
                      //(va_list *)&pszTitleStr);

    }

    //
    // Turn on the beep if requested
    //

    if (fSound) {
        MessageBeep(fuStyle & (MB_ICONASTERISK | MB_ICONEXCLAMATION |
                MB_ICONHAND | MB_ICONQUESTION | MB_OK));
    }

    idRet = MessageBox(hwnd, pszMsg, pszTitle, fuStyle);

    if (pszTitle != NULL)
        LocalFree(pszTitle);

    if (pszMsg != gpszError)
        LocalFree(pszMsg);

    return idRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocdskspc.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocdskspc.c

Abstract:

    Routines to ask subcomponents for the approximate amount
    of disk space they take up.

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
pOcGetChildrenApproximateDiskSpace(
    IN     POC_MANAGER  OcManager,
    IN     LONG         TopLevelOcId,
    IN     LONG         CurrentOcId,
    IN     LPCTSTR      DriveSpec
    )

/*++

Routine Description:

    Worker routine for pOcGetApproximateDiskSpace(). This routine recursively
    iterates through a hierarchy of subcomponents, asking leaf components
    for their space (via the OC_CALC_DISK_SPACE interface routine) and amalgamating
    child results at non-leaf nodes.

    We use the OC_CALC_DISK_SPACE interface routine with an the "ignore-on-disk"
    disk space list, to trick the components into telling us how much space their
    files take up.

Arguments:

    OcManager - supplies OC Manager context.

    TopLevelOcId - supplies string id in the component string table for the
        top-level subcomponent at the root of the hierarchy whose disk space
        is being summed.

    CurrentOcId - supplies string id for subcomponent whose disk space is
        being summed.

    DriveSpec - supplies drive spec of drive we care about for space calculations,
        ie, the drive where the system is installed.

    AccumulatedSpace - receives the summed space for all the children of the
        current subcomponent, or the component itself if it's a leaf node.

Return Value:

    None.

--*/

{
    HDSKSPC DiskSpaceList;
    LONGLONG Space = 0;
    LONG Id;
    OPTIONAL_COMPONENT CurrentOc;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        CurrentOcId,
        &CurrentOc,
        sizeof(OPTIONAL_COMPONENT)
        );

    if(CurrentOc.FirstChildStringId == -1) {

        if ( TopLevelOcId == pOcGetTopLevelComponent(OcManager,CurrentOcId) ){

            //
            // only get the approximate disk space if we haven't already retreived it from their inf
            //
            if ((CurrentOc.InternalFlags & OCFLAG_APPROXSPACE) ==0) {

                //
                // This oc is a child/leaf component.
                // Create an ignore-disk disk space list and ask
                // the component dll to add its files to it.
                //
                if(DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_IGNORE_DISK | SPDSL_DISALLOW_NEGATIVE_ADJUST)) {

                    OcInterfaceCalcDiskSpace(
                        OcManager,
                        pOcGetTopLevelComponent(OcManager,CurrentOcId),
                        pSetupStringTableStringFromId(OcManager->ComponentStringTable,CurrentOcId),
                        DiskSpaceList,
                        TRUE
                        );

                    if(!SetupQuerySpaceRequiredOnDrive(DiskSpaceList,DriveSpec,&Space,0,0)) {
                        Space = 0;
                    }
            
                    SetupDestroyDiskSpaceList(DiskSpaceList);
                }
                DBGOUT((
                   TEXT("OCM: pOcGetChildrenApproximateDiskSpace COMP(%s) SUB(%s)\n"),
                    pSetupStringTableStringFromId( OcManager->ComponentStringTable,  TopLevelOcId),
                    pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)
                ));
                DBGOUT((TEXT("OCM: Space=%#lx%08lx\n"),(LONG)(Space>>32),(LONG)Space));

                //
                // Now store the required space we just calculated
                //
                CurrentOc.SizeApproximation = Space;

                pSetupStringTableSetExtraData(
                    OcManager->ComponentStringTable,
                    CurrentOcId,
                    &CurrentOc,
                    sizeof(OPTIONAL_COMPONENT)
                    );
            }
        }

    } else {
        //
        // Parent component. Do all the children, accumulating the result.
        //

        Id = CurrentOc.FirstChildStringId;

        do {
            pOcGetChildrenApproximateDiskSpace(OcManager,TopLevelOcId,Id,DriveSpec);

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                Id,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Id = Oc.NextSiblingStringId;

        } while(Id != -1);

        //
        // Now store the required space we just calculated
        //
        CurrentOc.SizeApproximation = Space;

        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            CurrentOcId,
            &CurrentOc,
            sizeof(OPTIONAL_COMPONENT)
            );
    }

}

VOID
pOcSumApproximateDiskSpace(
    IN     POC_MANAGER  OcManager,
    IN     LONG         CurrentOcId,
    IN OUT LONGLONG    *AccumulatedSpace
    )

/*++

Routine Description:

    Worker routine for pOcGetApproximateDiskSpace(). This routine recursively
    iterates through a hierarchy of subcomponents, adding up leaf components
    for their space via the stored Estimated Amount

Arguments:

    OcManager - supplies OC Manager context.

    CurrentOcId - supplies string id for subcomponent whose disk space is
        being summed.

    AccumulatedSpace - receives the summed space for all the children of the
        current subcomponent, or the component itself if it's a leaf node.

Return Value:

    None.

--*/

{
    LONGLONG Space;
    LONG Id;
    OPTIONAL_COMPONENT CurrentOc;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        CurrentOcId,
        &CurrentOc,
        sizeof(OPTIONAL_COMPONENT)
        );

    if(CurrentOc.FirstChildStringId == -1) {
        DBGOUT((TEXT("Child ")));

        Space = CurrentOc.SizeApproximation;
    } else {
        //
        // Parent component. Do all the children, accumulating the result.
        //
        Space = 0;
        DBGOUT((TEXT("Parent ")));
        DBGOUT((
            TEXT("SUB(%s)"),
            pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)
            ));
        DBGOUT((TEXT("Space=%#lx%08lx\n"),(LONG)(Space>>32),(LONG)Space));

        Id = CurrentOc.FirstChildStringId;

        do {
            pOcSumApproximateDiskSpace(OcManager,Id,&Space);

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                Id,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Id = Oc.NextSiblingStringId;

        } while(Id != -1);

    }

    *AccumulatedSpace += Space;

    CurrentOc.SizeApproximation = Space;
    pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            CurrentOcId,
            &CurrentOc,
            sizeof(OPTIONAL_COMPONENT)
           );

    DBGOUT((TEXT(" SUB(%s)"),
           pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)));

    DBGOUT((TEXT(" Space=%#lx%08lx "),(LONG)(Space>>32),(LONG)Space));
    DBGOUT((TEXT(" AccumulatedSpace=%#lx%08lx\n"),(LONG)(*AccumulatedSpace>>32),(LONG)*AccumulatedSpace));

}


VOID
pOcGetApproximateDiskSpace(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine is used to get an approximate disk space usage number
    for display in the oc page. This number bears no relation to what is
    currently on the disk; rather it merely reflects the approximate of space
    the component takes up in an absolute, independent sense, when installed.

Arguments:

    OcManager - supplies OC Manager context.

Return Value:

    None.

--*/

{
    UINT iChild,n;
    TCHAR Drive[MAX_PATH];
    LONGLONG Space;
    OPTIONAL_COMPONENT Oc;

    // We check the return code of GetWindowsDirectory to make Prefix happy.

    if (0 == GetWindowsDirectory(Drive,MAX_PATH))
        return;

    Drive[2] = 0;

    //
    // Iterate through top-level components. We only care about
    // ones that have per-component infs, since those are the
    // only ones that will show up in the OC Page.
    //
    for(n=0; n<OcManager->TopLevelOcCount; n++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[n],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InfStringId != -1) {
            for(iChild=0;
                iChild<OcManager->TopLevelParentOcCount;
                iChild++)
            {
            //
            // Now call the component dll for each child subcomponent.
            //

                pOcGetChildrenApproximateDiskSpace(
                    OcManager,
                    OcManager->TopLevelOcStringIds[n],
                    OcManager->TopLevelParentOcStringIds[iChild],
                    Drive
                    );
            }
        }
    }

    // Now final pass Sum the all the information in to parent nodes

    for(n=0; n<OcManager->TopLevelParentOcCount; n++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelParentOcStringIds[n],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );
        Space = 0;
        pOcSumApproximateDiskSpace(
                OcManager,
                OcManager->TopLevelParentOcStringIds[n],
                &Space
             );
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ochelper.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ochelper.c

Abstract:

    Helper/callback routines, available to plug-in components
    when processing interface routine calls.

Author:

    Ted Miller (tedm) 13-Sep-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <stdarg.h>

//
// Window handle of wizard dialog. Set when the OC Manager client
// calls OcRememberWizardDialogHandle.
//
HWND WizardDialogHandle;

VOID 
OcHelperShowHideWizardPage(
    IN PVOID OcManagerContext,
    IN BOOL bShow
    )
{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    if (p->Callbacks.ShowHideWizardPage)
    {
        // If we have a callback, hide the wizard.
        p->Callbacks.ShowHideWizardPage(bShow);
    }
}


VOID
OcHelperTickGauge(
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    Function used while processing the OC_COMPLETE_INSTALLATION Interface function
    to step the progress gauge being run by the OC Manager.
    Ignored at other times.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

Return Value:

    None.

--*/

{
    pOcTickSetupGauge(((PHELPER_CONTEXT)OcManagerContext)->OcManager);
}


VOID
#ifdef UNICODE
OcHelperSetProgressTextW(
#else
OcHelperSetProgressTextA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR Text
    )

/*++

Routine Description:

    Function used while processing the OC_COMPLETE_INSTALLATION Interface function
    to change the text associated with the progress gauge being run by
    the OC Manager. Ignored at other times.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    Text - Supplies the text for the progress gauge. The component should try to
        respect the current language parameters established by OC_SET_LANGUAGE.
        The OC Manager will make a copy of the string and truncate it as necessary.

Return Value:

    None.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

#ifdef DEBUGPERFTRACE
    static DWORD lasttickcount = 0;
    static DWORD currenttickcount = 0;
    static DWORD diff, lastdiff;

    if (!lasttickcount)
        lasttickcount = GetTickCount();

    lasttickcount = currenttickcount;
    currenttickcount = GetTickCount();
    lastdiff = diff;
    diff = currenttickcount - lasttickcount;
    TRACE(( TEXT("SetProgressText at %d (last = %d, diff = %d, last diff = %d)\n"), currenttickcount, lasttickcount, diff, lastdiff ));
    if (diff > 1000*3) {
        WRN(( TEXT("It's been > 3 seconds since the last tick count update...the user is getting impatient.\n") ));
    }

#endif

    if(p->ProgressTextWindow) {
        SetWindowText(p->ProgressTextWindow,Text);
    }
}


#ifdef UNICODE
VOID
OcHelperSetProgressTextA(
    IN PVOID  OcManagerContext,
    IN LPCSTR Text
    )

/*++

Routine Description:

    ANSI version of OcHelperSetProgressText().

Arguments:

Return Value:

--*/

{
    LPCWSTR p;

    if(p = pSetupAnsiToUnicode(Text)){
        OcHelperSetProgressTextW(OcManagerContext,p);
        pSetupFree(p);
    }
}
#endif


UINT
_OcHelperSetPrivateData(
    IN PVOID   OcManagerContext,
    IN LPCVOID Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type,
    IN BOOL    IsNativeCharWidth
    )
{
    PHELPER_CONTEXT HelperContext;
    DWORD rc;
    DWORD Disposition;
    HKEY hKey;
    LONG id;

    HelperContext = OcManagerContext;

    //
    // Fetch the component id. If we're processing an interface routine
    // then use the component id of the active component. Otherwise
    // resort to the component id stored in the helper context.
    //
    if(HelperContext->OcManager->CurrentComponentStringId == -1) {
        id = HelperContext->ComponentStringId;
    } else {
        id = HelperContext->OcManager->CurrentComponentStringId;
    }

    rc = RegCreateKeyEx(
            HelperContext->OcManager->hKeyPrivateData,
            pSetupStringTableStringFromId(HelperContext->OcManager->ComponentStringTable,id),
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            &Disposition
            );

    if(rc == NO_ERROR) {
        if(IsNativeCharWidth) {
            rc = RegSetValueEx(hKey,Name,0,Type,Data,Size);
        } else {
            rc = RegSetValueExA(hKey,Name,0,Type,Data,Size);
        }
        RegCloseKey(hKey);
    }

    return(rc);
}


UINT
#ifdef UNICODE
OcHelperSetPrivateDataW(
#else
OcHelperSetPrivateDataA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type
    )

/*++

Routine Description:

    Function to set a named datum that can then be retrieved later
    by the component or by any other component, via the GetPrivateData
    helper routine.

    This routine can be called at any time.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    Name - Supplies a name for the datum. If a datum with this name
        already exists for the component, it is overwritten.

    Data - Supplies the data itself. The OC Manager makes a copy of the data
        so the component need not ensure that this buffer remains valid.

    Size - Supplies the size in bytes of the data.

    Type - Supplies the type of the data. Components should use the standard registry
        type names (REG_SZ, REG_BINARY, etc.) to facilitate inter-component
        data sharing.

Return Value:

    Win32 error code indicating outcome; NO_ERROR means success.

--*/

{
    return(_OcHelperSetPrivateData(OcManagerContext,Name,Data,Size,Type,TRUE));
}


#ifdef UNICODE
UINT
OcHelperSetPrivateDataA(
    IN PVOID  OcManagerContext,
    IN LPCSTR Name,
    IN PVOID  Data,
    IN UINT   Size,
    IN UINT   Type
    )

/*++

Routine Description:

    ANSI version of OcHelperSetPrivateData().

Arguments:

Return Value:

--*/

{
    return(_OcHelperSetPrivateData(OcManagerContext,Name,Data,Size,Type,FALSE));
}
#endif


UINT
_OcHelperGetPrivateData(
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,     OPTIONAL
    IN     LPCVOID Name,
    OUT    PVOID   Data,            OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type,
    IN     BOOL    IsNativeCharWidth
    )
{
    PHELPER_CONTEXT HelperContext;
    PCTSTR ComponentName;
    DWORD rc;
    DWORD Disposition;
    HKEY hKey;
    LONG id;

    HelperContext = OcManagerContext;

    //
    // Figure out the name of the component that owns the data.
    //
    if(ComponentId) {
        ComponentName = ComponentId;
    } else {
        if(HelperContext->OcManager->CurrentComponentStringId == -1) {
            id = HelperContext->ComponentStringId;
        } else {
            id = HelperContext->OcManager->CurrentComponentStringId;
        }
        ComponentName = pSetupStringTableStringFromId(
                            HelperContext->OcManager->ComponentStringTable,
                            id
                            );
        if (!ComponentName) {
           rc = GetLastError();
           goto exit;
        }
    }

    rc = RegCreateKeyEx(
            HelperContext->OcManager->hKeyPrivateData,
            ComponentName,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &Disposition
            );

    if(rc == NO_ERROR) {
        if(IsNativeCharWidth) {
            rc = RegQueryValueEx(hKey,Name,0,Type,Data,Size);
        } else {
            rc = RegQueryValueExA(hKey,Name,0,Type,Data,Size);
        }
        if(rc == ERROR_MORE_DATA) {
            rc = ERROR_INSUFFICIENT_BUFFER;
        }
        RegCloseKey(hKey);
    }

exit:
    return(rc);
}

UINT
#ifdef UNICODE
OcHelperGetPrivateDataW(
#else
OcHelperGetPrivateDataA(
#endif
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,     OPTIONAL
    IN     LPCTSTR Name,
    OUT    PVOID   Data,            OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type
    )

/*++

Routine Description:

    Function to retrieve a named datum that was previously set via
    SetPrivateData by the component or by any other component.

    This routine can be called at any time.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    ComponentId - Supplies the short descriptive name of the component
        (as specified in OC.INF) that set/owns the datum to be retrieved.
        NULL means the current component.

    Name - Supplies the name of the datum to be retrieved.

    Data - If specified, receives the data. If not specified, the routine puts
        the required size in Size and returns NO_ERROR.

    Size - On input, supplies the size of the buffer pointed to by Data
        (ignored if Data is not specified). On output, receives the size of
        the data stored, or the required size if the buffer is not large enough.

    Type - Upon successful completion receives the type of the datum.

Return Value:

    NO_ERROR: If Data was specified, the requested datum had been placed in
        the caller's buffer. If Data was not specified, then the required size
        has been placed in the UINT pointed to by Size.

    ERROR_INSUFFICIENT_BUFFER: the specified buffer size is too small
        to contain the datum. The required size has been placed in the UINT
        pointed to by Size.

    Other Win32 error codes indicate additional error cases, such as the
    datum not being found, etc.

--*/

{
    return(_OcHelperGetPrivateData(OcManagerContext,ComponentId,Name,Data,Size,Type,TRUE));
}


#ifdef UNICODE
UINT
OcHelperGetPrivateDataA(
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,  OPTIONAL
    IN     LPCSTR Name,
    OUT    PVOID  Data,         OPTIONAL
    IN OUT PUINT  Size,
    OUT    PUINT  Type
    )

/*++

Routine Description:

    ANSI version of OcHelperGetPrivateData().

Arguments:

Return Value:

--*/

{
    LPCWSTR component;
    UINT u;

    if(ComponentId) {
        component = pSetupAnsiToUnicode(ComponentId);
        if(!component) {
            u = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }
    } else {
        component = NULL;
    }

    u = _OcHelperGetPrivateData(OcManagerContext,component,Name,Data,Size,Type,FALSE);

    if(component) {
        pSetupFree(component);
    }
c0:
    return(u);
}
#endif


UINT
OcHelperSetSetupMode(
    IN PVOID OcManagerContext,
    IN DWORD SetupMode
    )

/*++

Routine Description:

    Function that can be used at any time while a component is
    processing any Interface function or any of its wizard pages.
    It is used to set the current setup mode. It is expected that if a
    component supplies a setup mode page, it will use this routine to
    inform the OC Manager of the setup mode the user chose.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SetupMode - Supplies a numeric value that indicates the setup mode. This may be
        any of the 4 standard values (minimal, laptop, custom, or typical).
        It can also be any other private value that has meaning to a suite or bundle.
        In that case the low 8 bits are interpreted as one of the standard values
        so the mode can be meaningful to other components and the OC Manager,
        who know nothing about private mode types. The component setting the mode
        should attempt to set this as reasonably as possible. The upper 24 bits are
        essentially private mode data.

Return Value:

    The return value is the previous mode.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    UINT Mode;

    Mode = p->SetupMode;
    p->SetupMode = SetupMode;

    return(Mode);
}


UINT
OcHelperGetSetupMode(
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    Function that can be used at any time while a component is processing
    any Interface function or any of its wizard pages. It is used to query
    the current setup mode. Note that this can be a private mode type,
    in which case the low 8 bits of the mode value can be interpreted as one of
    the standard 4 mode types and the upper 24 bits are private mode data.
    The mode can also be unknown. See section 3.2.1 for a list of standard
    mode types.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

Return Value:

    The return value is the current mode.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    return(p->SetupMode);
}


BOOL
#ifdef UNICODE
OcHelperQuerySelectionStateW(
#else
OcHelperQuerySelectionStateA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR SubcomponentId,
    IN UINT    StateType
    )

/*++

Routine Description:

    Function that can be used at any time.
    It is used determine the selection status of a particular subcomponent.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    StateType - supplies a constant indicating which state is to be returned
        (original or current).

Return Value:

    Boolean value indicating whether the subcomponent is selected
    for installation. If FALSE, GetLastError() will return something other than
    NO_ERROR if an error occurred, such as SubcomponentId being invalid.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    BOOL b;

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (LPTSTR)SubcomponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    switch(StateType) {

    case OCSELSTATETYPE_ORIGINAL:

        b = (Oc.OriginalSelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    case OCSELSTATETYPE_CURRENT:

        b = (Oc.SelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    case OCSELSTATETYPE_FINAL:

        b = (Oc.SelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    default:

        b = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    return(b);
}

#ifdef UNICODE
OcHelperQuerySelectionStateA(
    IN PVOID  OcManagerContext,
    IN LPCSTR SubcomponentId,
    IN UINT   StateType
    )
{
    LPCWSTR id;
    DWORD d;
    BOOL b;

    id = pSetupAnsiToUnicode(SubcomponentId);
    if(!id) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    b = OcHelperQuerySelectionStateW(OcManagerContext,id,StateType);
    d = GetLastError();

    pSetupFree(id);

    SetLastError(d);
    return(b);
}
#endif


UINT
#ifdef UNICODE
OcHelperCallPrivateFunctionW(
#else
OcHelperCallPrivateFunctionA(
#endif
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2,
    OUT    PUINT   Result
    )

/*++

Routine Description:

    Function that can be used at any time while a component is
    processing any Interface function. It is used to call another component's
    interface entry point to perform some private function. This function
    cannot be used to call a standard interface function, nor can it be used
    to call a function in the DLL of the component making the call.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    ComponentId - Supplies the short descriptive name of the component
        (as specified in OC.INF) to be called. This may not be the name of
        the current component.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    Function - Supplies a function code meaningful to the component being called.
        This may not be one of the standard interface function codes.

    Param1, Param2 - Supply values meaningful to the component being called.
        The OC Manager imposes no semantics on these values.

    Result - If the OC Manager is successful in calling the other component,
        then this receives the return value from the other component's
        interface routine.

Return Value:

    Win32 error code indicating outcome. If NO_ERROR, then the other component
    was called and the result is stored in Result. If not NO_ERROR,
    then the other component was not called.

    ERROR_BAD_ENVIRONMENT - the function was called when the component is not
        processing an interface routine, or the caller is attempting to
        call a routine in itself.

    ERROR_INVALID_FUNCTION - Function is less then OC_PRIVATE_BASE.

    ERROR_ACCESS_DENIED - the requested component has no interface entry point.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    BOOL b;
    LONG l;
    UINT i;
    OPTIONAL_COMPONENT OtherOc;
    LONG PreviousCurrentComponentStringId;

    //
    // Validate that we are processing an interface function and
    // that the requested function is not a standard function,
    // and that the caller wants to call a different component.
    //
    if(Function < OC_PRIVATE_BASE) {
        return(ERROR_INVALID_FUNCTION);
    }

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (PTSTR)ComponentId,
            STRTAB_CASE_INSENSITIVE,
            &OtherOc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        return(ERROR_INVALID_FUNCTION);
    }

    //
    // Make sure the component is top-level.
    //
    for(b=FALSE,i=0; !b && (i<p->TopLevelOcCount); i++) {
        if(p->TopLevelOcStringIds[i] == l) {
            b = TRUE;
        }
    }

    if((l == p->CurrentComponentStringId) || (p->CurrentComponentStringId == -1) || !b) {
        return(ERROR_BAD_ENVIRONMENT);
    }

    //
    // Make sure the component has an entry point.
    //
    if(!OtherOc.InstallationRoutine) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Call the other component.
    //

#ifdef UNICODE
    //
    // If necessary, convert component and subcomponent to ansi
    //
    if(OtherOc.Flags & OCFLAG_ANSI) {

        LPCSTR comp,subcomp;

        comp = pSetupUnicodeToAnsi(ComponentId);
        if(!comp) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        if(SubcomponentId) {
            subcomp = pSetupUnicodeToAnsi(SubcomponentId);
            if(!subcomp) {
                pSetupFree(comp);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        } else {
            subcomp = NULL;
        }

        PreviousCurrentComponentStringId = p->CurrentComponentStringId;
        p->CurrentComponentStringId = l;

        *Result = CallComponent(p, &OtherOc, comp, subcomp, Function, Param1, Param2);

        pSetupFree(comp);
        if(subcomp) {
            pSetupFree(subcomp);
        }
    } else
#endif
    {
        PreviousCurrentComponentStringId = p->CurrentComponentStringId;
        p->CurrentComponentStringId = l;

        *Result = CallComponent(p, &OtherOc, ComponentId, SubcomponentId, Function, Param1, Param2);
    }

    p->CurrentComponentStringId = PreviousCurrentComponentStringId;

    return(NO_ERROR);
}


#ifdef UNICODE
UINT
OcHelperCallPrivateFunctionA(
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR SubcomponentId,
    IN     UINT   Function,
    IN     UINT   Param1,
    IN OUT PVOID  Param2,
    OUT    PUINT  Result
    )

/*++

Routine Description:

    ANSI version of OcHelperCallPrivateFunction().

Arguments:

Return Value:

--*/

{
    LPCWSTR comp,subcomp;
    UINT u;

    comp = pSetupAnsiToUnicode(ComponentId);
    if(!comp) {
        u = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    if(SubcomponentId) {
        subcomp = pSetupAnsiToUnicode(SubcomponentId);
        if(!subcomp) {
            u = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }
    } else {
        subcomp = NULL;
    }

    u = OcHelperCallPrivateFunctionW(
            OcManagerContext,
            comp,
            subcomp,
            Function,
            Param1,
            Param2,
            Result
            );

    if(subcomp) {
        pSetupFree(subcomp);
    }
c1:
    pSetupFree(comp);
c0:
    return(u);
}
#endif


BOOL
OcHelperConfirmCancel(
    IN HWND ParentWindow
    )

/*++

Routine Description:

    Ask the user whether he's sure he wants to cancel.

Arguments:

    ParentWindow - supplies window handle of parent window for ui

Return Value:

    TRUE if user wants to cancel. FALSE if not.

--*/

{
    TCHAR Message[1000];
    TCHAR Caption[200];
    int i;

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        MyModuleHandle,
        MSG_QUERY_CANCEL,
        0,
        Message,
        sizeof(Message)/sizeof(TCHAR),
        NULL
        );

    LoadString(MyModuleHandle,IDS_SETUP,Caption,sizeof(Caption)/sizeof(TCHAR));

    i = MessageBox(
            ParentWindow,
            Message,
            Caption,
            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND
            );

    return(i == IDYES);
}


HWND
OcHelperQueryWizardDialogHandle(
    IN PVOID OcManagerContext
    )
{
    UNREFERENCED_PARAMETER(OcManagerContext);

    return(WizardDialogHandle);
}


BOOL
OcHelperSetReboot(
    IN PVOID OcManagerContext,
    IN BOOL  Reserved
    )
{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    UNREFERENCED_PARAMETER(Reserved);

    p->Callbacks.SetReboot();
    return(FALSE);
}


VOID
OcRememberWizardDialogHandle(
    IN PVOID OcManagerContext,
    IN HWND  DialogHandle
    )

/*++

Routine Description:

    This routine is called by the OC Manager client to inform the
    common library of the wizard's dialog handle.

    We will also turn around and notify all top-level components
    of the wizard dialog handle.

    Before doing so, we write the title into the window header.

Arguments:

    OcManagerContext - value returned from OcInitialize().

    DialogHandle - supplies the dialog handle of the wizard.

Return Value:

    None.

--*/

{
    UINT i;
    POC_MANAGER OcManager;

    WizardDialogHandle = DialogHandle;
    OcManager = OcManagerContext;

    if (*OcManager->WindowTitle) {
        SetWindowText(WizardDialogHandle, OcManager->WindowTitle);
    }

    for(i=0; i<OcManager->TopLevelOcCount; i++) {
        OcInterfaceWizardCreated(OcManager,OcManager->TopLevelOcStringIds[i],DialogHandle);
    }
}


HINF
OcHelperGetInfHandle(
    IN UINT  InfIndex,
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    This routine returns a handle to a well-known inf file that
    has been opened by oc manager.

Arguments:

    InfIndex - supplies value indicating which inf's handle is desired

    OcManagerContext - value returned from OcInitialize().

Return Value:

    Handle to INF, NULL if error.

--*/

{
    POC_MANAGER OcManager = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    return((InfIndex == INFINDEX_UNATTENDED) ? OcManager->UnattendedInf : NULL);
}


BOOL
OcHelperClearExternalError (
    IN POC_MANAGER   OcManager,
    IN LONG ComponentId,
    IN LONG SubcomponentId   OPTIONAL
    )
 {
    LONG l;
    DWORD d;
    HKEY hKey;
    LPCTSTR  pValueName;

    //
    // If Subcomponetid is Zero then use the ComponentId
    //
    if ( SubcomponentId ) {
        pValueName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,SubcomponentId);
    } else {
        pValueName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    }

    if (!pValueName) {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Attempt to open the key if successful delete it
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerErrors,
            0,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            &hKey
            );

    //
    // If an errror Key does not exist
    //
    if(l != NO_ERROR) {
        d = l;
        goto c1;
    }

    //
    // Delete this Subcomponent Key
    //
    l = RegDeleteValue( hKey, pValueName);
    d = l;

    RegCloseKey(hKey);

c1:
    SetLastError(d);
    return(d == NO_ERROR);
}

BOOL
_OcHelperReportExternalError(
    IN PVOID    OcManagerContext,
    IN LPCTSTR  ComponentId,
    IN LPCTSTR  SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    IN va_list *arglist,
    IN BOOL     NativeCharWidth
    )
{
    POC_MANAGER OcManager = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    HMODULE Module;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    DWORD d;
    DWORD flags;
    LPTSTR MessageBuffer=NULL;
    LPCTSTR KeyValue;
    TCHAR fallback[20];
    HKEY hKey;
    DWORD Size;
    TCHAR *p;
    BOOL fmErr = FALSE;

    if ( ComponentId == NULL ) {
        //
        // if Component ID is null use the Suite Inf name
        //
        KeyValue = OcManager->SuiteName;

        //
        // if the message isn't preformatted, we have to retreive an error
        // from a component dll.  But if a component id wasn't specified, then
        // we cannot retrieve from a comopnent dll.  In that case, assume
        // that the message is to be retreived from the main OCM dll.
        //
        ZeroMemory( &Oc, sizeof(OPTIONAL_COMPONENT));
        if ((Flags & ERRFLG_PREFORMATTED) == 0) {
           Flags |= ERRFLG_OCM_MESSAGE;
        }

    } else {
        //
        // If SubcomponentId was Optional use the ComponentId
        //
        if ( SubcomponentId ) {
           KeyValue = SubcomponentId;
        } else {
           KeyValue = ComponentId;
        }

        // Look up the string in the master component table.
        // If it's not there, bail now.
        //
        l = pSetupStringTableLookUpStringEx(
            OcManager->ComponentStringTable,
            (PTSTR)ComponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(l == -1) {
            d = ERROR_INVALID_DATA;
            goto c0;
        }
    }

    //
    // Determine flags for FormatMessage
    //
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    if(Flags & ERRFLG_SYSTEM_MESSAGE) {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    } else {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    if(Flags & ERRFLG_IGNORE_INSERTS) {
        flags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    if(Flags & ERRFLG_OCM_MESSAGE) {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;

    }

    //
    // Format the message.
    //
#ifdef UNICODE
    if(!NativeCharWidth) {
        if (Flags & ERRFLG_PREFORMATTED ) {
            MessageBuffer = (LPTSTR) MessageId;
        } else {
            try {
                d = FormatMessageA(
                    flags,
                    Flags & ERRFLG_OCM_MESSAGE?MyModuleHandle:Oc.InstallationDll,         // ignored if system message
                    (DWORD)MessageId,
                    0,
                    (LPSTR)&MessageBuffer,
                    0,
                    arglist
                    );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                fmErr = TRUE;
            }
            if (fmErr) {
                d = ERROR_INVALID_DATA;
                goto c0;
            }
            if(d) {
                //
                // Need to convert resulting message from ansi to unicode
                // so we can deal with it below. The LocalAlloc below overallocates
                // if some of the ansi chars are double-byte chars, too bad.
                //
                l = lstrlen(MessageBuffer)+1;
                if(p = (PVOID)LocalAlloc(LMEM_FIXED,l*sizeof(WCHAR))) {

                    d = MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,(LPSTR)MessageBuffer,-1,p,l);
                    if ( ! (Flags & ERRFLG_PREFORMATTED) ) {
                        LocalFree((HLOCAL)MessageBuffer);
                    }
                    if(d) {
                        MessageBuffer = p;
                    } else {
                        LocalFree((HLOCAL)p);
                    }

                } else {
                    if ( ! (Flags & ERRFLG_PREFORMATTED) ) {
                        LocalFree((HLOCAL)MessageBuffer);
                    }
                    d = 0;
                }
            }
        }

    } else
#endif
    {
        if (Flags & ERRFLG_PREFORMATTED ) {
            MessageBuffer = (LPTSTR) MessageId;
            d = 1;
        } else {
            try {
                d = FormatMessage(
                    flags,
                    Flags & ERRFLG_OCM_MESSAGE?MyModuleHandle:Oc.InstallationDll,         // ignored if system message
                    (DWORD)MessageId,
                    0,
                    (LPTSTR)&MessageBuffer,
                    0,
                    arglist
                    );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                fmErr = TRUE;
            }
            if (fmErr) {
                d = ERROR_INVALID_DATA;
                goto c0;
            }
        }
        if(!d) {
            //
            // Put *something* in there
            //
            wsprintf(
                fallback,
                TEXT("#%s0x%x"),
                (Flags & ERRFLG_SYSTEM_MESSAGE) ? TEXT("SYS") : TEXT(""),
                MessageId
                );

            MessageBuffer = fallback;
        }
    }

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerErrors,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &hKey,
            &d
            );

    if(l != NO_ERROR) {
        d = l;
        goto c1;
    }

    //
    // Figure out how large of a buffer we need to encompass
    // the existing key and the string we're going to add to the end.
    //
    l = RegQueryValueEx(hKey,KeyValue,NULL,NULL,NULL,&Size);
    if(l == NO_ERROR) {
        if(Size == 0) {
            Size = 1;           // terminating nul
        }
    } else {
        Size = sizeof(TCHAR);   // terminating nul
    }

    Size += ((lstrlen(MessageBuffer) + 1) * sizeof(TCHAR));

    //
    // Allocate a buffer, read in the existing entry, and add the string
    // to the end.
    //
    p = (PVOID)LocalAlloc(LMEM_FIXED,Size);
    if(!p) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }

    l = RegQueryValueEx(hKey,KeyValue,NULL,NULL,(BYTE *)p,&Size);
    if(l == NO_ERROR) {
        Size /= sizeof(TCHAR);
        if(Size == 0) {
            Size = 1;
        }
    } else {
        Size = 1;
    }
    lstrcpy(p+(Size-1),MessageBuffer);
    Size += lstrlen(MessageBuffer);
    p[Size++] = 0;

    d = RegSetValueEx(hKey,KeyValue,0,REG_MULTI_SZ,(CONST BYTE *)p,Size*sizeof(TCHAR));

    LocalFree((HLOCAL)p);
c2:
    RegCloseKey(hKey);
c1:
    if(MessageBuffer && MessageBuffer != fallback && MessageBuffer != (LPTSTR)MessageId ) {
        LocalFree((HLOCAL)MessageBuffer);
        d = 0;
    }
c0:
    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
pOcHelperReportExternalError(
    IN POC_MANAGER OcManager,
    IN LONG     ComponentId,
    IN LONG     SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    ...
    )
{
    BOOL b;
    DWORD d;
    va_list arglist;
    HELPER_CONTEXT OcManagerContext;
    OcManagerContext.OcManager = OcManager;

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            &OcManagerContext,
            ComponentId ? pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId):NULL,
            SubcomponentId ? pSetupStringTableStringFromId(OcManager->ComponentStringTable,SubcomponentId):NULL,
            MessageId,
            Flags,
            &arglist,
            TRUE
            );

    d = GetLastError();

    va_end(arglist);

    SetLastError(d);
    return(b);
}



BOOL
#ifdef UNICODE
OcHelperReportExternalErrorW(
#else
OcHelperReportExternalErrorA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR ComponentId,
    IN LPCTSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD   Flags,
    ...
    )
{
    BOOL b;
    DWORD d;

    va_list arglist;

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            OcManagerContext,
            ComponentId,
            SubcomponentId,
            MessageId,
            Flags,
            &arglist,
            TRUE
            );

    d = GetLastError();

    va_end(arglist);

    SetLastError(d);
    return(b);
}


#ifdef UNICODE
BOOL
OcHelperReportExternalErrorA(
    IN PVOID  OcManagerContext,
    IN LPCSTR ComponentId,
    IN LPCSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD  Flags,
    ...
    )
{
    LPCWSTR componentId,subcomponentId;
    DWORD d;
    BOOL b;
    va_list arglist;

    if (ComponentId) {
        componentId = pSetupAnsiToUnicode(ComponentId);
        if(!componentId) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
            goto e0;
        }
    } else {
        componentId = NULL;
    }

    if(SubcomponentId) {
        subcomponentId = pSetupAnsiToUnicode(SubcomponentId);
        if(!subcomponentId) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
            goto e1;
        }
    } else {
        subcomponentId = NULL;
    }

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            OcManagerContext,
            componentId,
            subcomponentId,
            MessageId,
            Flags,
            &arglist,
            FALSE
            );

    d = GetLastError();

    va_end(arglist);


    if(subcomponentId) {
        pSetupFree(subcomponentId);
    }

e1:
    if (componentId) {
        pSetupFree(componentId);
    }
e0:
    SetLastError(d);
    return(b);
}
#endif


#if 0
BOOL
#ifdef UNICODE
OcHelperSetSelectionStateW(
#else
OcHelperSetSelectionStateA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR SubcomponentId,
    IN UINT    WhichState,
    IN UINT    NewState
    )

/*++

Routine Description:

    Function that can be used at any time.
    It is used determine the selection status of a particular subcomponent.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    StateType - supplies a constant indicating which state is to be returned
        (original or current).

Return Value:

    Boolean value indicating whether the subcomponent is selected
    for installation. If FALSE, GetLastError() will return something other than
    NO_ERROR if an error occurred, such as SubcomponentId being invalid.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    BOOL b;
    UINT *state;

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (LPTSTR)SubcomponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    switch (WhichState) {

    case OCSELSTATETYPE_ORIGINAL:
        state = &Oc.
        break;

    case OCSELSTATETYPE_CURRENT:
        state = &Oc.
        break;

    case OCSELSTATETYPE_FINAL:
        state = &Oc.
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NewState != SubcompOn && NewState != SubcompOff) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *state = NewState;

    pOcSetStatesStringWorker(l, NewState, OcPage);

    return(b);
}
#endif

BOOL
#ifdef UNICODE
OcLogErrorW(
#else
OcLogErrorA(
#endif
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCTSTR Msg,
    ...
    )
{
    TCHAR sz[5000];
    va_list arglist;
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    va_start(arglist, Msg);
    _vstprintf(sz, Msg, arglist);
    va_end(arglist);

    return p->Callbacks.LogError(ErrorLevel, sz);
}


#ifdef UNICODE
BOOL
OcLogErrorA(
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCSTR Msg,
    ...
    )
{
    PWSTR p;
    BOOL b;
    char sz[5000];
    va_list arglist;

    va_start(arglist, Msg);
    vsprintf(sz, Msg, arglist);
    va_end(arglist);

    p = pSetupAnsiToUnicode(sz);
    if (p) {
        b = OcLogErrorW(OcManagerContext, ErrorLevel, p);
        pSetupFree(p);
    } else {
        b = FALSE;
    }

    return(b);
}
#endif



//
// Now that we've got all the routines defined, we can build a table
// of routines.
//
OCMANAGER_ROUTINESA HelperRoutinesA = { NULL,                     // Context, filled in later.
                                        OcHelperTickGauge,
                                        OcHelperSetProgressTextA,
                                        OcHelperSetPrivateDataA,
                                        OcHelperGetPrivateDataA,
                                        OcHelperSetSetupMode,
                                        OcHelperGetSetupMode,
                                        OcHelperQuerySelectionStateA,
                                        OcHelperCallPrivateFunctionA,
                                        OcHelperConfirmCancel,
                                        OcHelperQueryWizardDialogHandle,
                                        OcHelperSetReboot,
                                        OcHelperGetInfHandle,
                                        OcHelperReportExternalErrorA,
                                        OcHelperShowHideWizardPage
                                      };

#ifdef UNICODE
OCMANAGER_ROUTINESW HelperRoutinesW = { NULL,                     // Context, filled in later.
                                        OcHelperTickGauge,
                                        OcHelperSetProgressTextW,
                                        OcHelperSetPrivateDataW,
                                        OcHelperGetPrivateDataW,
                                        OcHelperSetSetupMode,
                                        OcHelperGetSetupMode,
                                        OcHelperQuerySelectionStateW,
                                        OcHelperCallPrivateFunctionW,
                                        OcHelperConfirmCancel,
                                        OcHelperQueryWizardDialogHandle,
                                        OcHelperSetReboot,
                                        OcHelperGetInfHandle,
                                        OcHelperReportExternalErrorW,
                                        OcHelperShowHideWizardPage
                                      };
#endif

EXTRA_ROUTINESA ExtraRoutinesA = { sizeof(EXTRA_ROUTINESA),
                                   OcLogErrorA
                                 };

#ifdef UNICODE
EXTRA_ROUTINESW ExtraRoutinesW = { sizeof(EXTRA_ROUTINESW),
                                   OcLogErrorW
                                 };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocmisc.c ===
#include "precomp.h"
#pragma hdrstop

// determines whether trace statements are printed

#define DBL_UNDEFINED   ((DWORD)-1)
#define REGKEY_SETUP    TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup")
#define REGVAL_DBLEVEL  TEXT("OC Manager Debug Level")

DWORD gDebugLevel = DBL_UNDEFINED;

//
// OC_MANAGER pointer for debugging/logging
//
extern POC_MANAGER gLastOcManager;


VOID
_DbgOut(
    DWORD Severity,
    LPCTSTR txt
    );


DWORD
GetDebugLevel(
    VOID
    )
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_SETUP,
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBLEVEL,
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}


UINT
_LogError(
    IN POC_MANAGER  OcManager,
    IN OcErrorLevel ErrorLevel,
    IN UINT         MessageId,
    ...
    )
{
    TCHAR str[5000];
    DWORD d;
    va_list arglist;

    va_start(arglist,MessageId);

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE,
            MyModuleHandle,
            MessageId,
            0,
            str,
            sizeof(str)/sizeof(TCHAR),
            &arglist
            );

    va_end(arglist);

    if(!d) {
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            MyModuleHandle,
            MSG_NOT_FOUND,
            0,
            str,
            sizeof(str)/sizeof(TCHAR),
            (va_list *)&MessageId
            );
    }


    if ( OcManager->SetupData.OperationFlags & SETUPOP_BATCH) {
        ErrorLevel |= OcErrBatch;
    }
    return OcLogError(ErrorLevel,str);
}


VOID
_TrcOut(
    IN LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrTrace,str);
}


VOID
_WrnOut(
    LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrLevWarning,str);

}


VOID
_ErrOut(
    IN LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrLevFatal,str);
}


VOID
_DbgOut(
    DWORD Severity,
    IN LPCTSTR txt
    )
{
#if 0
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);
#endif
    if (gDebugLevel == DBL_UNDEFINED)
        gDebugLevel = GetDebugLevel();

    //
    // for those people that *dont* want to see this debugger output, they can munge the registry
    // to something between 50 and 100 to disable this.
    // if we don't log some information on checked builds then we'll miss too many errors the first
    // time around
    //
    if ( (gDebugLevel > 0) && (gDebugLevel < 50) )
        return;

    if (gLastOcManager) {
        gLastOcManager->Callbacks.LogError(Severity, txt);
    } else {
        OutputDebugString(TEXT("OCMANAGE: "));
        OutputDebugString(txt);
        OutputDebugString(TEXT("\n"));
    }


}


UINT
pOcCreateComponentSpecificMiniIcon(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN LPCTSTR     Subcomponent,
    IN UINT        Width,
    IN UINT        Height,
    IN LPCTSTR     DllName,         OPTIONAL
    IN LPCTSTR     ResourceId       OPTIONAL
    )
{
    HBITMAP BitmapFromComponent;
    HBITMAP NewBitmap;
    HBITMAP MaskBitmap;
    HBITMAP OldBitmap1,OldBitmap2;
    HDC MemDc1,MemDc2;
    COLORREF BackgroundColor;
    UINT Index;
    BITMAP BitmapInfo;
    BOOL b;
    HMODULE hMod;

    Index = DEFAULT_ICON_INDEX;

    //
    // If a dll name is given then fetch the bitmap from there.
    // Otherwise, call down to the component to get the bitmap.
    //
    BitmapFromComponent = NULL;
    if(DllName && ResourceId) {
        if(hMod = LoadLibraryEx(DllName,NULL,LOAD_LIBRARY_AS_DATAFILE)) {
            BitmapFromComponent = LoadBitmap(hMod,ResourceId);
            FreeLibrary(hMod);
        }
    } else {
        //
        // first try OC_QUERY_IMAGE_EX for the bitmap
        //
        BitmapFromComponent = OcInterfaceQueryImageEx(
                        OcManager,
                        ComponentId,
                        Subcomponent,
                        SubCompInfoSmallIcon,
                        Width,
                        Height
                        );

#ifndef _WIN64
        //
        // OC_QUERY_IMAGE is broken for 64 bits, so only call this if we
        // do not get an image reported for the component on 32 bit targets.
        //
        if (!BitmapFromComponent) {

            BitmapFromComponent = OcInterfaceQueryImage(
                                    OcManager,
                                    ComponentId,
                                    Subcomponent,
                                    SubCompInfoSmallIcon,
                                    Width,
                                    Height
                                    );
        }
#else
        if (!BitmapFromComponent) {
            DbgPrintEx(
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "No bitmap defined for component.  Ensure that component is handling OC_QUERY_IMAGE_EX callback\n");
        }
#endif
    }

    if(!BitmapFromComponent) {
        goto c0;
    }

    //
    // Copy the bitmap given to us by the component.
    // At the same time, make sure it's the right size.
    //
    MemDc1 = CreateCompatibleDC(NULL);
    if(!MemDc1) {
        goto c1;
    }
    MemDc2 = CreateCompatibleDC(NULL);
    if(!MemDc2) {
        goto c2;
    }

    if(!GetObject(BitmapFromComponent,sizeof(BitmapInfo),&BitmapInfo)) {
        goto c3;
    }

    NewBitmap = CreateBitmap(Width,Height,BitmapInfo.bmPlanes,BitmapInfo.bmBitsPixel,NULL);
    if(!NewBitmap) {
        goto c3;
    }

    OldBitmap1 = SelectObject(MemDc1,BitmapFromComponent);
    if(!OldBitmap1) {
        goto c4;
    }
    OldBitmap2 = SelectObject(MemDc2,NewBitmap);
    if(!OldBitmap2) {
        goto c5;
    }

    b = StretchBlt(
            MemDc2,
            0,0,
            Width,Height,
            MemDc1,
            0,0,
            BitmapInfo.bmWidth,
            BitmapInfo.bmHeight,
            SRCCOPY
            );

    if(!b) {
        goto c6;
    }

    //
    // Now make the mask.
    //
    // The mask bitmap is monochrome. Pixels in the image bitmap that are
    // the image bitmap's background color will be white in the mask;
    // other pixels in the mask will be black. Assume the upper-left pixel
    // of the image bitmap is the background color.
    //
    BackgroundColor = GetPixel(MemDc2,0,0);
    if(BackgroundColor == CLR_INVALID) {
        goto c6;
    }

    MaskBitmap = CreateBitmap(Width,Height,1,1,NULL);
    if(!MaskBitmap) {
        goto c6;
    }

    if(!SelectObject(MemDc1,MaskBitmap)) {
        goto c7;
    }

    if(SetBkColor(MemDc2,BackgroundColor) == CLR_INVALID) {
        goto c7;
    }
    if(!BitBlt(MemDc1,0,0,Width,Height,MemDc2,0,0,SRCCOPY)) {
        goto c7;
    }

    //
    // Black out all of the transparent parts of the image, in preparation
    // for drawing.
    //
    SetBkColor(MemDc2,RGB(0,0,0));
    SetTextColor(MemDc2,RGB(255,255,255));
    if(!BitBlt(MemDc2,0,0,Width,Height,MemDc1,0,0,SRCAND)) {
        goto c7;
    }

    //
    // Before we call pSetupAddMiniIconToList we have to make sure
    // neither bitmap is selected into a DC.
    //
    SelectObject(MemDc1,OldBitmap1);
    SelectObject(MemDc2,OldBitmap2);
    Index = pSetupAddMiniIconToList(NewBitmap,MaskBitmap);
    if(Index == -1) {
        Index = DEFAULT_ICON_INDEX;
    }

c7:
    DeleteObject(MaskBitmap);
c6:
    SelectObject(MemDc2,OldBitmap2);
c5:
    SelectObject(MemDc1,OldBitmap1);
c4:
    DeleteObject(NewBitmap);
c3:
    DeleteDC(MemDc2);
c2:
    DeleteDC(MemDc1);
c1:
    DeleteObject(BitmapFromComponent);
c0:
    return(Index);
}


BOOL
pConvertStringToLongLong(
    IN  PCTSTR           String,
    OUT PLONGLONG        OutValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    LONGLONG Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    LONGLONG OverflowCheck;
    BOOL b;

    if(!String || !OutValue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*String == TEXT('-')) {
        Neg = TRUE;
        String++;
    } else {
        Neg = FALSE;
        if(*String == TEXT('+')) {
            String++;
        }
    }

    if((*String == TEXT('0')) &&
       ((*(String+1) == TEXT('x')) || (*(String+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        String += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *String; String++) {

        c = (UINT)*String;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(LONGLONG) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*String) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *OutValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


DWORD
tmbox(
      LPCTSTR fmt,
      ...
      )
{
    TCHAR  text[1024];
    TCHAR  caption[256];

    va_list vaList;

    sapiAssert(fmt);

    va_start(vaList, fmt);
    wvsprintf(text, fmt, vaList);
    va_end(vaList);

    *caption = 0;
    LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
    sapiAssert(*caption);

    return MessageBox(WizardDialogHandle,
                      text,
                      caption,
                      MB_ICONINFORMATION | MB_OK);
}

#ifdef PRERELEASE
#ifdef DBG
HRESULT
FTestForOutstandingCoInits(
    VOID
    )
/*++

Routine Description: Determines is there was an unitialized call to OleInitialize()

Arguments:
                NONE

Return Value:
                an HRESULT code

Remarks:
                Don't call this function in the release version.

--*/

{
    HRESULT hInitRes = ERROR_SUCCESS;

#if defined(UNICODE) || defined(_UNICODE)
    // perform a defensive check
    hInitRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        CoUninitialize();
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }

    hInitRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        CoUninitialize();
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }
#endif

    // it worked out OK
    hInitRes = NOERROR;
    goto FTestForOutstandingCoInits_Exit;

FTestForOutstandingCoInits_Exit:
    return hInitRes;
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocmanage.c ===
#include "precomp.h"
#pragma hdrstop


//
// Names of wizard page types, do not change order unless
// the WizardPagesType enum is changed.
//
LPCTSTR WizardPagesTypeNames[WizPagesTypeMax] = { TEXT("Welcome"), TEXT("Mode"),
                                                  TEXT("Early")  , TEXT("Prenet"),
                                                  TEXT("Postnet"), TEXT("Late"),
                                                  TEXT("Final")
                                                };

//
// Name of sections and keys in infs.
//
LPCTSTR szComponents = TEXT("Components");
LPCTSTR szOptionalComponents = TEXT("Optional Components");
LPCTSTR szExtraSetupFiles = TEXT("ExtraSetupFiles");
LPCTSTR szNeeds = TEXT("Needs");
LPCTSTR szExclude = TEXT("Exclude");
LPCTSTR szParent = TEXT("Parent");
LPCTSTR szIconIndex = TEXT("IconIndex");
LPCTSTR szModes = TEXT("Modes");
LPCTSTR szTip = TEXT("Tip");
LPCTSTR szOptionDesc = TEXT("OptionDesc");
LPCTSTR szInstalledFlag = TEXT("InstalledFlag");
LPCTSTR szHide = TEXT("HIDE");
LPCTSTR szOSSetupOnly = TEXT("OSSetupOnly");
LPCTSTR szStandaloneOnly = TEXT("StandaloneOnly");
LPCTSTR szPageTitle = TEXT("PageTitles");
LPCTSTR szSetupTitle = TEXT("SetupPage");
LPCTSTR szGlobal = TEXT("Global");
LPCTSTR szWindowTitle = TEXT("WindowTitle");
LPCTSTR szWindowTitleAlone = TEXT("WindowTitle.StandAlone");
LPCTSTR szSizeApproximation = TEXT("SizeApproximation");
LPCTSTR szWindowTitleInternal = TEXT("*");

//
// Key in registry where private component data is kept.
// We form a unique name within this key for the OC Manager
// instantiation.
//
LPCTSTR szOcManagerRoot   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");
LPCTSTR szPrivateDataRoot = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
LPCTSTR szMasterInfs      = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
LPCTSTR szSubcompList     = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
LPCTSTR szOcManagerErrors = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");

//
// Other string constants.
//
LPCTSTR szSetupDir = TEXT("Setup");

//
// locale information
//
LOCALE locale;

// Structure used for string table callback when
// building a subcomponent list.
//
typedef struct _BUILDSUBCOMPLIST_PARAMS {
    POC_MANAGER OcManager;
    UINT Pass;
} BUILDSUBCOMPLIST_PARAMS, *PBUILDSUBCOMPLIST_PARAMS;

//
// oc manager pointer for debugging/logging
//
POC_MANAGER gLastOcManager = NULL;

UINT
pOcQueryOrSetNewInf(
    IN  PCTSTR MasterOcInfName,
    OUT PTSTR  SuiteName,
    IN  DWORD  Operation
    );

VOID
pOcDestroyPerOcData(
    IN POC_MANAGER OcManager
    );

BOOL
pOcDestroyPerOcDataStringCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              Unused
    );

VOID
pOcClearAllErrorStates(
    IN POC_MANAGER OcManager
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

VOID
pOcFormSuitePath(
    IN  LPCTSTR SuiteName,
    IN  LPCTSTR FileName,   OPTIONAL
    OUT LPTSTR  FullPath
    )

/*++

Routine Description:

    Forms the name of the directory in the OS tree where per-suite
    infs and installation dlls are kept (system32\setup).

    Optionally also appends the name of a file to the path.

Arguments:

    SuiteName - shortname for the suite.

    FileName - optionally specifies the name of a file in the per-suite
        directory.

    FullPath - receives the full path of the per-suite directory (or the
        file within the directory). This buffer should be MAX_PATH TCHAR
        elements.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(SuiteName);

    GetSystemDirectory(FullPath,MAX_PATH);

    pSetupConcatenatePaths(FullPath,szSetupDir,MAX_PATH,NULL);

    //
    // We put all such files in a single flat directory.
    // This makes life easier for components that want to share
    // installation pieces, such as infs, dlls, etc.
    //
    // There are potential name conflict issues but we blow them off.
    //
    //pSetupConcatenatePaths(FullPath,SuiteName,MAX_PATH,NULL);

    if(FileName) {
        pSetupConcatenatePaths(FullPath,FileName,MAX_PATH,NULL);
    }
}


BOOL
pOcBuildSubcomponentListStringCB(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN POC_INF                  OcInf,
    IN UINT                     OcInfSize,
    IN PBUILDSUBCOMPLIST_PARAMS Params
    )

/*++

Routine Description:

    String table callback, worker routine for pOcBuildSubcomponentLists.

    This routine examines the loaded per-component infs and builds the
    subcomponent hierarchies that are described therein via the Parent=
    lines in the various per-component sections.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;
    OPTIONAL_COMPONENT AuxOc;
    INFCONTEXT LineContext;
    INFCONTEXT SublineContext;
    LPCTSTR SubcompName;
    LPCTSTR  ModuleFlags;
    LPCTSTR p;
    LONG l;
    LONG CurrentStringId;
    UINT u,n;
    INT IconIndex;
    POC_MANAGER OcManager = Params->OcManager;

    if(SetupFindFirstLine(OcInf->Handle,szOptionalComponents,NULL,&LineContext)) {

        do {
            if((SubcompName = pSetupGetField(&LineContext,1)) && *SubcompName) {

                l = pSetupStringTableLookUpStringEx(
                        Params->OcManager->ComponentStringTable,
                        (PTSTR)SubcompName,
                        STRTAB_CASE_INSENSITIVE,
                        &OptionalComponent,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if(Params->Pass == 0) {

                    //
                    // First pass. Add subcomponents listed in [Optional Components]
                    // to the string table. Each one has an associated OPTIONAL_COMPONENT
                    // structure. Top-level components already exist in the table,
                    // so we are careful here about how we overwrite existing entries.
                    //
                    if(l == -1) {
                        ZeroMemory(&OptionalComponent,sizeof(OPTIONAL_COMPONENT));

                        OptionalComponent.ParentStringId = -1;
                        OptionalComponent.FirstChildStringId = -1;
                        OptionalComponent.NextSiblingStringId = -1;
                        OptionalComponent.InfStringId = StringId;
                        OptionalComponent.Exists = FALSE;
                    }

                    if (OptionalComponent.Exists) {
                        _LogError(OcManager,
                                  OcErrLevError,
                                  MSG_OC_DUPLICATE_COMPONENT,
                                  SubcompName);
                        continue;
                    }

                    OptionalComponent.Exists = TRUE;

                    // Get the second Field of the Optional components line
                    // Determine if this component is hidden or not

                    ModuleFlags = pSetupGetField(&LineContext,2);
                    if (ModuleFlags) {
                        if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                            p = szOSSetupOnly;
                        else
                            p = szStandaloneOnly;
                        if (!_tcsicmp(ModuleFlags, szHide) || !_tcsicmp(ModuleFlags, p))
                            OptionalComponent.InternalFlags |= OCFLAG_HIDE;
                    }

                    //
                    // Fetch the description, tip, and iconindex.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szOptionDesc,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        lstrcpyn(OptionalComponent.Description,p,MAXOCDESC);
                    } else {
                        OptionalComponent.Description[0] = 0;
                    }

                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szTip,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        lstrcpyn(OptionalComponent.Tip,p,MAXOCTIP);
                    } else {
                        OptionalComponent.Tip[0] = 0;
                    }

                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szIconIndex,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        LPCTSTR p2,p3;

                        //
                        // If we have fields 2 and 3 then assume we've got a dll
                        // and resource name. Otherwise it's an index or *.
                        //
                        if((p2 = pSetupGetField(&SublineContext,2))
                        && (p3 = pSetupGetField(&SublineContext,3))) {

                            lstrcpyn(
                                OptionalComponent.IconDll,
                                p2,
                                sizeof(OptionalComponent.IconDll)/sizeof(TCHAR)
                                );

                            lstrcpyn(
                                OptionalComponent.IconResource,
                                p3,
                                sizeof(OptionalComponent.IconResource)/sizeof(TCHAR)
                                );

                            IconIndex = -2;

                        } else {
                            //
                            // If the icon index is * then stick -1 in there
                            // as a special marker value for later.
                            // Otherwise we call SetupGetIntField because it will
                            // validate the field for us.
                            //
                            if((p[0] == TEXT('*')) && (p[1] == 0)) {
                                IconIndex = -1;
                            } else {
                                if(!SetupGetIntField(&SublineContext,1,&IconIndex)) {
                                    IconIndex = DEFAULT_ICON_INDEX;
                                } else {
                                    // Setupapi will return DEFAULT_ICON_INDEX if out of range.
                                    if (IconIndex < 0) {
                                        IconIndex = DEFAULT_ICON_INDEX;
                                    }
                                }
                            }
                        }
                    } else {
                        //
                        // No icon index.
                        //
                        IconIndex = DEFAULT_ICON_INDEX;
                    }
                    OptionalComponent.IconIndex = IconIndex;

                    //
                    // if the InstalledFlag is specified, check it
                    // and set the original selection state accordingly
                    //
                    OptionalComponent.InstalledState = INSTSTATE_UNKNOWN;
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szInstalledFlag,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {
                        TCHAR regkey[MAXOCIFLAG];
                        lstrcpyn(regkey,p,MAXOCIFLAG);
                        if (p = pSetupGetField(&SublineContext,2)) {
                            TCHAR regval[MAXOCIFLAG];
                            TCHAR buf[MAXOCIFLAG];
                            HKEY  hkey;
                            DWORD size;
                            DWORD type;
                            DWORD rc;
                            lstrcpyn(regval,p,MAXOCIFLAG);
                            if (RegOpenKey(HKEY_LOCAL_MACHINE, regkey, &hkey) == ERROR_SUCCESS) {
                                size = sizeof(buf);
                                rc = RegQueryValueEx(hkey,
                                                     regval,
                                                     NULL,
                                                     &type,
                                                     (LPBYTE)buf,
                                                     &size);
                                RegCloseKey(hkey);
                                if (rc == ERROR_SUCCESS) {
                                    OptionalComponent.InstalledState = INSTSTATE_YES;
                                } else {
                                    OptionalComponent.InstalledState = INSTSTATE_NO;
                                }
                            }
                        }
                    }

                    //
                    // Fetch the list of modes in which the subcomponent should be
                    // on by default. For future expandability, we'll accept any
                    // mode values up to 31, which is the number of bits we can fit
                    // in out UINT bitfield/
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szModes,&SublineContext)) {
                        n = SetupGetFieldCount(&SublineContext);
                        for(u=0; u<n; u++) {
                            if(SetupGetIntField(&SublineContext,u+1,&IconIndex)
                            && ((DWORD)IconIndex < 32)) {

                                OptionalComponent.ModeBits |= (1 << IconIndex);
                            }
                        }
                    }

                    //
                    // As an optimization, fetch the size approximation, if they
                    // supplied one.If they didn't supply this then we have to
                    // query them for disk space
                    //
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szSizeApproximation,&SublineContext)
                       && (p = pSetupGetField(&SublineContext,1))) {
                        //
                        // we have the text version of something that needs to be converted into
                        // a LONGLONG...
                        //
                        pConvertStringToLongLong(p,&OptionalComponent.SizeApproximation);
                        OptionalComponent.InternalFlags |= OCFLAG_APPROXSPACE;
                    }


                    // Find the The "TopLevelParent" for this Node
                    // Search the list if TopLevelComponent looking for
                    // the "INF string id" that matches the Inf String ID
                    // of this component.

                    for(u=0; u<OcManager->TopLevelOcCount; u++) {
                        pSetupStringTableGetExtraData(
                            OcManager->ComponentStringTable,
                            OcManager->TopLevelOcStringIds[u],
                            &AuxOc,
                            sizeof(OPTIONAL_COMPONENT)
                            );

                        if(AuxOc.InfStringId == StringId) {
                            // Found it and save to the current component
                             OptionalComponent.TopLevelStringId = OcManager->TopLevelOcStringIds[u];
                             u=(UINT)-1;
                             break;
                        }
                    }
                       // Check Found the Right String ID.
                    if(u != (UINT)-1) {
                        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                        return(FALSE);
                    }


                } else {

                    // Pass Two - Discover Needs and Parentage
                    // Two passs First to collect all the names second to
                    // create the needs and parent links

                    CurrentStringId = l;

                    //
                    // Deal with the needs.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szNeeds,&SublineContext)) {

                        n = 0;
                        u = 0;
                        while(p = pSetupGetField(&SublineContext,n+1)) {
                            //
                            // Ignore unless the subcomponent is in the string table.
                            //
                            l = pSetupStringTableLookUpStringEx(
                                    Params->OcManager->ComponentStringTable,
                                    (PTSTR)p,
                                    STRTAB_CASE_INSENSITIVE,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            if(l != -1) {
                                //
                                // Grow the needs array and put this item in it.
                                //
                                if(OptionalComponent.NeedsStringIds) {
                                    p = pSetupRealloc(
                                            OptionalComponent.NeedsStringIds,
                                            (OptionalComponent.NeedsCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    OptionalComponent.NeedsCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    OptionalComponent.NeedsStringIds = (PVOID)p;
                                    OptionalComponent.NeedsStringIds[OptionalComponent.NeedsCount++] = l;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                //
                                // Insert this component in the needed component's neededby array.
                                //
                                if(AuxOc.NeededByStringIds) {
                                    p = pSetupRealloc(
                                            AuxOc.NeededByStringIds,
                                            (AuxOc.NeededByCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    AuxOc.NeededByCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    AuxOc.NeededByStringIds = (PVOID)p;
                                    AuxOc.NeededByStringIds[AuxOc.NeededByCount++] = CurrentStringId;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                            n++;
                        }
                    }

                    //
                    // Deal with the excludes.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szExclude,&SublineContext)) {

                        n = 0;
                        u = 0;
                        while(p = pSetupGetField(&SublineContext,n+1)) {
                            //
                            // Ignore unless the subcomponent is in the string table.
                            //
                            l = pSetupStringTableLookUpStringEx(
                                    Params->OcManager->ComponentStringTable,
                                    (PTSTR)p,
                                    STRTAB_CASE_INSENSITIVE,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            if(l != -1) {
                                //
                                // Grow the exclude array and put this item in it.
                                //
                                if(OptionalComponent.ExcludeStringIds) {
                                    p = pSetupRealloc(
                                            OptionalComponent.ExcludeStringIds,
                                            (OptionalComponent.ExcludeCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    OptionalComponent.ExcludeCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    OptionalComponent.ExcludeStringIds = (PVOID)p;
                                    OptionalComponent.ExcludeStringIds[OptionalComponent.ExcludeCount++] = l;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                //
                                // Insert this component in the excluded component's excludedby array.
                                //
                                if(AuxOc.ExcludedByStringIds) {
                                    p = pSetupRealloc(
                                            AuxOc.ExcludedByStringIds,
                                            (AuxOc.ExcludedByCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    AuxOc.ExcludedByCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    AuxOc.ExcludedByStringIds = (PVOID)p;
                                    AuxOc.ExcludedByStringIds[AuxOc.ExcludedByCount++] = CurrentStringId;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                            n++;
                        }
                    }

                    //
                    // Figure out parentage. Ignore specified parent unless it exists
                    // in the string table. We also note in the parent that it has children.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szParent,&SublineContext)
                    && (p = (PVOID)pSetupGetField(&SublineContext,1))) {

                        l = pSetupStringTableLookUpStringEx(
                                Params->OcManager->ComponentStringTable,
                                (PTSTR)p,
                                STRTAB_CASE_INSENSITIVE,
                                &AuxOc,
                                sizeof(OPTIONAL_COMPONENT)
                                );

                        if(l != -1) {
                            //
                            // l is the string id of the parent, and AuxOc is filled with
                            // the parent's optional component data.
                            //
                            OptionalComponent.ParentStringId = l;

                            if(AuxOc.FirstChildStringId == -1) {
                                //
                                // This parent has no children yet.
                                // Set the current component as its (first) child.
                                // Note that in this case the current component does not yet
                                // have any siblings.
                                //
                                AuxOc.FirstChildStringId = CurrentStringId;
                                AuxOc.ChildrenCount = 1;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            } else {
                                //
                                // The parent already has children.
                                // Increment the parent's count of children, then
                                // walk the siblings list and add the new component to the end.
                                //
                                AuxOc.ChildrenCount++;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                                l = AuxOc.FirstChildStringId;

                                pSetupStringTableGetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    AuxOc.FirstChildStringId,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                                while(AuxOc.NextSiblingStringId != -1) {

                                    l = AuxOc.NextSiblingStringId;

                                    pSetupStringTableGetExtraData(
                                        Params->OcManager->ComponentStringTable,
                                        l,
                                        &AuxOc,
                                        sizeof(OPTIONAL_COMPONENT)
                                        );
                                }

                                AuxOc.NextSiblingStringId = CurrentStringId;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                        }
                    } else {    // a node with out a parent a new Top Level node

                        // Finally Add this String ID to the Component Strings list
                        //  UINT TopLevelParentOcCount;
                        //  PLONG TopLevelParentOcStringIds;

                         if(OcManager->TopLevelParentOcStringIds != NULL) {
                         p = pSetupRealloc(
                                OcManager->TopLevelParentOcStringIds,
                                (OcManager->TopLevelParentOcCount+1)
                                    * sizeof(OcManager->TopLevelParentOcStringIds)
                                );
                         } else {
                            OcManager->TopLevelParentOcCount = 0;
                            p = pSetupMalloc(sizeof(LONG));
                         }

                         if(p) {
                            OcManager->TopLevelParentOcStringIds = (PVOID)p;
                            OcManager->TopLevelParentOcStringIds[OcManager->TopLevelParentOcCount++] = CurrentStringId;

                         } else {
                            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                            return(FALSE);

                        }

                    }
                }

                //
                // Now add the subcomponent to the string table.
                // We overwrite the extra data, which is not harmful since
                // we specifically fetched it earlier.
                //

                l = pSetupStringTableAddStringEx(
                        Params->OcManager->ComponentStringTable,
                        (PTSTR)SubcompName,
                        STRTAB_NEW_EXTRADATA | STRTAB_CASE_INSENSITIVE,
                        &OptionalComponent,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if(l == -1) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    return(FALSE);
                }
            }
        } while(SetupFindNextLine(&LineContext,&LineContext));
    }

    return(TRUE);
}


BOOL
pOcBuildSubcomponentLists(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine examines the loaded per-component infs and builds the
    subcomponent hierarchies that are described therein via the Parent=
    lines in the various per-component sections.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    OC_INF OcInf;
    BOOL b;
    BUILDSUBCOMPLIST_PARAMS s;

    s.OcManager = OcManager;

    //
    // We make 2 passes. The first adds all the subcomponent names to
    // the string table. The second computes parentage. If we don't do
    // it this way then we might have ordering problems.
    //
    s.Pass = 0;
    b = pSetupStringTableEnum(
            OcManager->InfListStringTable,
            &OcInf,
            sizeof(OC_INF),
            (PSTRTAB_ENUM_ROUTINE)pOcBuildSubcomponentListStringCB,
            (LPARAM)&s
            );

    if(b) {
        s.Pass = 1;
        b = pSetupStringTableEnum(
                OcManager->InfListStringTable,
                &OcInf,
                sizeof(OC_INF),
                (PSTRTAB_ENUM_ROUTINE)pOcBuildSubcomponentListStringCB,
                (LPARAM)&s
                );
    }
    return(b);
}


BOOL
pOcInitPaths(
    IN OUT POC_MANAGER OcManager,
    IN     PCTSTR MasterInfName
    )
{
    TCHAR  path[MAX_PATH];
    TCHAR *p;

    //
    // 1. look for master INF in specified directory.
    // 2. look in %systemroot%\system32\Setup directory.
    // 3. look in %systemroot%\inf directory.
    //
    if (!FileExists(MasterInfName, NULL)) {
        pOcFormSuitePath(NULL, NULL, path);
        p = _tcsrchr(MasterInfName, TEXT('\\'));
        if (!p)
            p = (TCHAR *)MasterInfName;
        pSetupConcatenatePaths(path, p, MAX_PATH, NULL);
        if (!FileExists(path, NULL)) {
#ifdef UNICODE
            HMODULE hMod;
            FARPROC pGetSystemWindowsDirectory;
            hMod = LoadLibrary(L"kernel32.dll");
            if (hMod) {
                pGetSystemWindowsDirectory = GetProcAddress(hMod,"GetSystemWindowsDirectoryW");
                if (!pGetSystemWindowsDirectory) {
                    pGetSystemWindowsDirectory = GetProcAddress(hMod,"GetWindowsDirectoryW");
                }

                if (pGetSystemWindowsDirectory) {
                    pGetSystemWindowsDirectory( path, MAX_PATH );
                } else {
                    GetWindowsDirectory(path,MAX_PATH);
                }

                FreeLibrary(hMod);
            }

#else
            GetWindowsDirectory(path,MAX_PATH);
#endif
            pSetupConcatenatePaths(path,TEXT("INF"),MAX_PATH,NULL);
            pSetupConcatenatePaths(path,p,MAX_PATH,NULL);
            if (!FileExists(path, NULL))
                return FALSE;
        }
    } else {
        _tcscpy(path, MasterInfName);
    }

    _tcscpy(OcManager->MasterOcInfPath, path);
    return TRUE;
}

BOOL
pOcInstallSetupComponents(
    IN POPTIONAL_COMPONENT Oc,
    IN OUT POC_MANAGER OcManager,
    IN     PCTSTR      Component,
    IN     PCTSTR      DllName,         OPTIONAL
    IN     PCTSTR      InfName,         OPTIONAL
    IN     HWND        OwnerWindow,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine makes sure that all files required for installation of
    a component listed in a master oc inf are properly installed in
    a well-known location.

    If the master OC inf is in the system inf directory, then we assume
    that all files are already in their proper locations and we do nothing.

    Otherwise we copy all installation files into system32\setup.
    Files copied include the per-component inf (if any), the installation dll,
    and all files listed on the ExtraSetupFiles= line in the [<component>]
    section in the master OC inf.

    Do not call this routine if the registry setting indicates that the
    master OC inf has been processed before.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    MasterOcInfName - supplies the full Win32 path of the master OC inf file.

    Component - supplies the shortname of the component we care about.

    DllName - supplies the name of the component's installation dll, if any.

    InfName - supplies the name of the component's per-component inf,
        if any.

    OwnerWindow - supplies the handle of the window to own any UI which may be
        popped up by this routine.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    TCHAR Path[MAX_PATH];
    TCHAR TargetPath[MAX_PATH];
    TCHAR InfPath[MAX_PATH];
    PTCHAR p;
    UINT u;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT InfLine;
    BOOL b;
    TCHAR FileName[MAX_PATH];
    DWORD n;

    b = FALSE;

    //
    // All of the installation files are expected to be sourced
    // in the same directory as the master oc inf itself.
    //
    // We'll stick all the installation files for the component
    // in %windir%\system32\setup so we know where to get at them later.
    //
    // If the master inf is in the inf directory, then we instead
    // assume that the the component is tightly integrated into
    // the system and that the installation files are already in
    // the system32 directory.
    //

    if (!GetWindowsDirectory(Path,MAX_PATH) ||
        !pSetupConcatenatePaths(Path,TEXT("INF"),MAX_PATH,NULL)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c0;
    }

    u = lstrlen(Path);

    pOcFormSuitePath(OcManager->SuiteName,NULL,TargetPath);

    lstrcpy(InfPath, OcManager->MasterOcInfPath);
    if (p = _tcsrchr(InfPath, TEXT('\\')))
        *p = 0;

    if (_tcsicmp(InfPath, Path) && _tcsicmp(InfPath, TargetPath)) {

        //
        // Inf is not in inf directory, so need to copy files.
        //
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c0;
        }

        //
        // We will use the silent feature; no progress gauge but
        // we want errors to be displayed. Pass INVALID_HANDLE_VALUE
        // to get this behavior.
        //
        QueueContext = SetupInitDefaultQueueCallbackEx(OwnerWindow,INVALID_HANDLE_VALUE,0,0,0);
        if(!QueueContext) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c1;
        }

        //
        // Form source and target paths
        //
        lstrcpy(Path,OcManager->MasterOcInfPath);
        if(p = _tcsrchr(Path,TEXT('\\'))) {
            *p = 0;
        }

        //
        // Queue dll, and, if specified, inf
        //
        if (DllName && *DllName) {
            if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                b = SetupQueueDelete(
                    FileQueue,      // handle to the file queue
                    TargetPath,     // path to the file to delete
                    DllName         // optional, additional path info
                );
            } else {

                BOOL bCopyFile = TRUE;
                // check if the file is present, it may not have to be for
                // defered installs, where the suite will provide the Exe usally on demand
                // via Web download

                if (Oc &&  Oc->InterfaceFunctionName[0] == 0 ) {

                    // No functin name means external setup

                    lstrcpy(FileName,Path);
                    pSetupConcatenatePaths(FileName, Oc->InstallationDllName, MAX_PATH, NULL);

                    bCopyFile = (GetFileAttributes(FileName)  == -1) ? FALSE: TRUE;
                    b=TRUE;

                    // bCopyFile=TRUE if we found the file

                }
                if( bCopyFile ) {
                    b = SetupQueueCopy(
                        FileQueue,
                        Path,
                        NULL,
                        DllName,
                        NULL,
                        NULL,
                        TargetPath,
                        NULL,
                        SP_COPY_SOURCEPATH_ABSOLUTE
                        );
                }
            }
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c2;
            }
        }

        if(InfName && *InfName) {
            if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                b = SetupQueueDelete(
                    FileQueue,      // handle to the file queue
                    TargetPath,     // path to the file to delete
                    InfName         // optional, additional path info
                );
            } else {
                b = SetupQueueCopy(
                    FileQueue,
                    Path,
                    NULL,
                    InfName,
                    NULL,
                    NULL,
                    TargetPath,
                    NULL,
                    SP_COPY_SOURCEPATH_ABSOLUTE
                    );
            }
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c2;
            }
        }

        //
        // Queue each extra installation file.
        //
        if(SetupFindFirstLine(OcManager->MasterOcInf,Component,szExtraSetupFiles,&InfLine)) {
            n = 1;
            while(SetupGetStringField(&InfLine,n++,FileName,MAX_PATH,NULL)) {

                if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                    b = SetupQueueDelete(
                        FileQueue,      // handle to the file queue
                        TargetPath,     // path to the file to delete
                        FileName        // optional, additional path info
                    );
                } else {
                     b = SetupQueueCopy(
                            FileQueue,
                            Path,
                            NULL,
                            FileName,
                            NULL,
                            NULL,
                            TargetPath,
                            NULL,
                            SP_COPY_SOURCEPATH_ABSOLUTE
                            );
                }

                if(!b) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    goto c2;
                }
            }
        }

        //
        // Commit the queue.
        //
        b = SetupCommitFileQueue(OwnerWindow,FileQueue,SetupDefaultQueueCallback,QueueContext);
        if(!b) {
            _LogError(OcManager,OcErrLevError,MSG_OC_CANT_COPY_SETUP_FILES,GetLastError());
            goto c2;
        }

        //
        // Make a note that this OC inf is now "known."
        //
        u = pOcQueryOrSetNewInf(OcManager->MasterOcInfPath,OcManager->SuiteName,infSet);
        if(u != NO_ERROR) {
            _LogError(OcManager,OcErrLevWarning,MSG_OC_CANT_WRITE_REGISTRY,u);
        }

c2:
        SetupTermDefaultQueueCallback(QueueContext);
c1:
        SetupCloseFileQueue(FileQueue);
c0:
        ;
    } else {
        b = TRUE;
    }

    return(b);
}


BOOL
pOcLoadMasterOcInf(
    IN OUT POC_MANAGER OcManager,
    IN     DWORD       Flags,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine loads the master OC inf and builds up the list of
    top-level optional components and some of the associated data
    inclucing the name of the installation inf, dll and the entry point.
    The per-components infs and dlls are not actually loaded
    by this routine.

    The wizard page ordering stuff is also initialized in the
    OC Manager data structure.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    Flags - if OCINIT_FORCENEWINF, then behave as if the master OC inf is new.
            if OCINIT_KILLSUBCOMPS, then delete all applicable subcomponent
                entries from the registry before processing.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    BOOL b;
    INFCONTEXT InfContext;
    PCTSTR ComponentName;
    PCTSTR DllName;
    PCTSTR ModuleFlags;
    DWORD OtherFlags;
    PCTSTR EntryName;
    PCTSTR InfName;
    LPCTSTR chkflag;
    OPTIONAL_COMPONENT Oc;
    LONG Id;
    PVOID p;
    UINT i,j;
    UINT ActualCount;
    WizardPagesType ReplacePages[4] = {WizPagesWelcome,WizPagesMode,WizPagesFinal,-1},
                    AddPages[5] = {WizPagesEarly,WizPagesPrenet,WizPagesPostnet,WizPagesLate,-1};
    WizardPagesType *PageList;
    PCTSTR SectionName;
    BOOL NewInf;
    TCHAR ComponentsSection[100];
    TCHAR setupdir[MAX_PATH];


    // First check and see if the setup cache directory exists.
    // If not, then we should create it on this run.

    pOcFormSuitePath(NULL, NULL, setupdir);
    sapiAssert(*setupdir);
    if (!FileExists(setupdir, NULL))
        Flags |= OCINIT_FORCENEWINF;

    //
    // Always run pOcQueryOrSetNewInf in case it has side effects.
    //
    if (Flags & OCINIT_KILLSUBCOMPS)
        pOcQueryOrSetNewInf(OcManager->MasterOcInfPath, OcManager->SuiteName, infReset);
    NewInf = !pOcQueryOrSetNewInf(OcManager->MasterOcInfPath,OcManager->SuiteName,infQuery);
    if(Flags & OCINIT_FORCENEWINF) {
        NewInf = TRUE;
        OcManager->InternalFlags |= OCMFLAG_NEWINF;
    }
    if (Flags & OCINIT_KILLSUBCOMPS)
        OcManager->InternalFlags |= OCMFLAG_KILLSUBCOMPS;
    if (Flags & OCINIT_RUNQUIET)
        OcManager->InternalFlags |= OCMFLAG_RUNQUIET;
    if (Flags & OCINIT_LANGUAGEAWARE)
        OcManager->InternalFlags |= OCMFLAG_LANGUAGEAWARE;

    OcManager->MasterOcInf = SetupOpenInfFile(OcManager->MasterOcInfPath,NULL,INF_STYLE_WIN4,&i);
    if(OcManager->MasterOcInf == INVALID_HANDLE_VALUE) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_OPEN_INF,OcManager->MasterOcInfPath,GetLastError(),i);
        goto c0;
    }

    //
    // Get the number of lines in the [Components] section and allocate
    // arrays in the OC Manager context structure accordingly. This may
    // overallocate the arrays (in case of duplicates, invalid lines, etc)
    // but we won't worry about that here.
    //
    lstrcpy(ComponentsSection,szComponents);
    OcManager->TopLevelOcCount = (UINT)(-1);
#if defined(_AMD64_)
    lstrcat(ComponentsSection,TEXT(".amd64"));
#elif defined(_X86_)
    lstrcat(ComponentsSection,TEXT(".w95"));
    OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        lstrcpy(ComponentsSection,szComponents);
        lstrcat(ComponentsSection,TEXT(".x86"));
    }
#elif defined(_IA64_)
    lstrcat(ComponentsSection,TEXT(".ia64"));
#else
#error Unknown platform!
#endif
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    }
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        lstrcpy(ComponentsSection,szComponents);
        OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    }
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_INF_INVALID_NO_SECTION,OcManager->MasterOcInfPath,szComponents);
        goto c1;
    }

    if (OcManager->TopLevelOcCount < 1) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    if(p = pSetupRealloc(OcManager->TopLevelOcStringIds,OcManager->TopLevelOcCount*sizeof(LONG))) {

        OcManager->TopLevelOcStringIds = p;

        for(i=0; i<WizPagesTypeMax; i++) {

            if(p = pSetupRealloc(OcManager->WizardPagesOrder[i],OcManager->TopLevelOcCount*sizeof(LONG))) {
                OcManager->WizardPagesOrder[i] = p;
            } else {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c1;
            }
        }
    } else {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    // get global info -
    if ((OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) &&
        SetupFindFirstLine(
                  OcManager->MasterOcInf,
                  szGlobal,
                  szWindowTitleAlone,
                  &InfContext)) {
        // the main window title
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->WindowTitle,     // optional, receives the field
                    sizeof(OcManager->WindowTitle)/sizeof(OcManager->WindowTitle[0]), // num char of the provided buffer
                    NULL);
        if( !lstrcmpi( OcManager->WindowTitle, szWindowTitleInternal)) {
            //This will happen when we load sysoc.inf For MUI.
            LoadString(MyModuleHandle,IDS_OCM_WINDOWTITLE,OcManager->WindowTitle,sizeof(OcManager->WindowTitle)/sizeof(TCHAR));
        }
    } else if(SetupFindFirstLine(
                  OcManager->MasterOcInf,
                  szGlobal,
                  szWindowTitle,
                  &InfContext)) {

        // the main window title
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->WindowTitle,     // optional, receives the field
                    sizeof(OcManager->WindowTitle)/sizeof(OcManager->WindowTitle[0]), // num char of the provided buffer
                    NULL);
    } else {
        *OcManager->WindowTitle = 0;
    }

    //
    // Go through the [Components] section. Each line in there is a top-level
    // component spec, giving dll name, entry point name, and optionally
    // the name of the per-component inf.
    //
    if(!SetupFindFirstLine(OcManager->MasterOcInf,ComponentsSection,NULL,&InfContext)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_INF_INVALID_NO_SECTION,OcManager->MasterOcInfPath,ComponentsSection);
        goto c1;
    }

    ActualCount = 0;

    do {
        //
        // Get pointers to each field in each line. Ignore invalid lines.
        //
        if(ComponentName = pSetupGetField(&InfContext,0)) {

            DllName = pSetupGetField(&InfContext,1);
            if(DllName && !*DllName) {
                DllName = NULL;
            }
            EntryName = pSetupGetField(&InfContext,2);
            if(EntryName && !*EntryName) {
                EntryName = NULL;
            }

            //
            // An empty string for the inf name is the same as
            // not specifying the inf at all.
            //
            if((InfName = pSetupGetField(&InfContext,3)) && *InfName) {

                Id = pSetupStringTableAddString(
                        OcManager->InfListStringTable,
                        (PTSTR)InfName,
                        STRTAB_CASE_INSENSITIVE
                        );

                if(Id == -1) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    goto c1;
                }
            } else {
                Id = -1;
            }

            // Get the Flags Field
            ModuleFlags = pSetupGetField(&InfContext,4);
            if(ModuleFlags && !*ModuleFlags) {
                ModuleFlags = NULL;
            }

            OtherFlags = 0;
            SetupGetIntField(&InfContext,5,&OtherFlags);

            ZeroMemory(&Oc,sizeof(OPTIONAL_COMPONENT));

            //
            // These guys are top-level. Also remember the string id
            // of the inf name in the inf string table.
            //
            Oc.FirstChildStringId = -1;
            Oc.NextSiblingStringId = -1;
            Oc.ParentStringId = -1;
            Oc.InfStringId = Id;

            // Show flags allows up to have a component that is hidden
            // Only on one flags now so keep processing simple

            Oc.Exists = FALSE;
            Oc.InternalFlags |= OCFLAG_TOPLEVELITEM;

            if (ModuleFlags) {
                if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                    chkflag = szOSSetupOnly;
                else
                    chkflag = szStandaloneOnly;
                if (!_tcsicmp(ModuleFlags, szHide) || !_tcsicmp(ModuleFlags, chkflag))
                    Oc.InternalFlags |= OCFLAG_HIDE;
            }

            if (OtherFlags & OCFLAG_NOWIZPAGES) {
                Oc.InternalFlags |= OCFLAG_NOWIZARDPAGES;
            }

            if (OtherFlags & OCFLAG_NOQUERYSKIP) {
                Oc.InternalFlags |= OCFLAG_NOQUERYSKIPPAGES;
            }

            if (OtherFlags & OCFLAG_NOEXTRAFLAGS) {
                Oc.InternalFlags |= OCFLAG_NOEXTRAROUTINES;
            }

            if(DllName) {
                lstrcpyn(Oc.InstallationDllName,DllName,MAX_PATH);
            } else {
                Oc.InstallationDllName[0] = 0;
            }

            //
            // Interface Function Name is always ANSI -- there's no
            // Unicode version of GetProcAddress.
            //
            if(EntryName) {
#ifdef UNICODE
                WideCharToMultiByte(CP_ACP,0,EntryName,-1,Oc.InterfaceFunctionName,MAX_PATH,NULL,NULL);
#else
                lstrcpyn(Oc.InterfaceFunctionName,EntryName,MAX_PATH);
#endif
            } else {
                Oc.InterfaceFunctionName[0] = 0;
            }

            Id = pSetupStringTableAddStringEx(
                    OcManager->ComponentStringTable,
                    (PTSTR)ComponentName,
                    STRTAB_CASE_INSENSITIVE | STRTAB_NEW_EXTRADATA,
                    &Oc,
                    sizeof(OPTIONAL_COMPONENT)
                    );

            if(Id == -1) {
                //
                // OOM adding string
                //
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c1;
            }

            OcManager->TopLevelOcStringIds[ActualCount++] = Id;

        }
    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    // Shrink down the various arrays.
    //
    OcManager->TopLevelOcStringIds = pSetupRealloc(OcManager->TopLevelOcStringIds,ActualCount*sizeof(LONG));
    for(i=0; i<WizPagesTypeMax; i++) {
        OcManager->WizardPagesOrder[i] = pSetupRealloc(OcManager->WizardPagesOrder[i],ActualCount*sizeof(LONG));
    }
    OcManager->TopLevelOcCount = ActualCount;

    //
    // Now for each wizard page type figure out the ordering.
    //
    for(i=0; i<2; i++) {

        SectionName = i ? TEXT("PageAdd") : TEXT("PageReplace");

        for(PageList = i ? AddPages : ReplacePages; *PageList != -1; PageList++) {

            b = SetupFindFirstLine(
                    OcManager->MasterOcInf,
                    SectionName,
                    WizardPagesTypeNames[*PageList],
                    &InfContext
                    );

            //
            // Check for the "default" string, which is the same as if the line
            // had not been specified at all.
            //
            if(b
            && (ComponentName = pSetupGetField(&InfContext,1))
            && !lstrcmpi(ComponentName,TEXT("Default"))) {

                b = FALSE;
            }

            if(b) {
                //
                // Make sure the array is padded with -1's,
                //
                FillMemory(
                    OcManager->WizardPagesOrder[*PageList],
                    OcManager->TopLevelOcCount * sizeof(LONG),
                    (BYTE)(-1)
                    );

                //
                // Now process each element on the line, but don't allow
                // overflowing the array.
                //
                j = 1;
                ActualCount = 0;

                while((ActualCount < OcManager->TopLevelOcCount)
                && (ComponentName = pSetupGetField(&InfContext,j)) && *ComponentName) {

                    Id = pSetupStringTableLookUpString(
                            OcManager->ComponentStringTable,
                            (PTSTR)ComponentName,
                            STRTAB_CASE_INSENSITIVE
                            );

                    if(Id == -1) {
                        //
                        // Invalid component. Log error and keep going.
                        //
                        _LogError(OcManager,
                            OcErrLevWarning,
                            MSG_OC_INVALID_COMP_IN_SECT,
                            OcManager->MasterOcInfPath,
                            SectionName,
                            ComponentName
                            );

                    } else {
                        //
                        // Remember the string id for this component.
                        //
                        OcManager->WizardPagesOrder[*PageList][ActualCount++] = Id;
                    }

                    j++;
                }

            } else {
                //
                // Default ordering, which is the order in which the components
                // were listed in the [Components] section
                //
                CopyMemory(
                    OcManager->WizardPagesOrder[*PageList],
                    OcManager->TopLevelOcStringIds,
                    OcManager->TopLevelOcCount * sizeof(LONG)
                    );
            }
        }
    }

    // get the caption for various pages

    if(SetupFindFirstLine(OcManager->MasterOcInf,szPageTitle,szSetupTitle,&InfContext)) {

        // Found it
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->SetupPageTitle,  // optional, receives the field
                    sizeof(OcManager->SetupPageTitle)/sizeof(OcManager->SetupPageTitle[0]), // size of the provided buffer
                    NULL);

    }

    return(TRUE);

c1:
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
c0:
    return(FALSE);
}


BOOL
pOcSetOcManagerDirIds(
    IN HINF    InfHandle,
    IN LPCTSTR MasterOcInfName,
    IN LPCTSTR ComponentName
    )

/*++

Routine Description:

    This routine sets up the pre-defined OC Manager directory ids for
    per-component infs.

    DIRID_OCM_MASTERINF
    DIRID_OCM_MASTERINF_PLAT
    DIRID_OCM_MASTERINF_COMP
    DIRID_OCM_MASTERINF_COMP_PLAT

Arguments:

    InfHandle - supplies handle to open inf file

    MasterOcInfName - win32 path to master oc inf

    ComponentName - simple shortname for the component

Return Value:

    Boolean value indicating outcome. If FALSE, caller can assume OOM.

--*/

{
    TCHAR Path[MAX_PATH];
    TCHAR *p;
#if defined(_AMD64_)
    LPCTSTR Platform = TEXT("AMD64");
#elif defined(_X86_)
    LPCTSTR Platform = (IsNEC_98) ? TEXT("NEC98") : TEXT("I386");
#elif defined(_IA64_)
    LPCTSTR Platform = TEXT("IA64");
#else
#error "No Target Architecture"
#endif


    lstrcpy(Path,MasterOcInfName);
    if(p = _tcsrchr(Path,TEXT('\\'))) {
        *p = 0;
    } else {
        //
        // Something is very broken
        //
        return(FALSE);
    }

    if(!SetupSetDirectoryId(InfHandle,DIRID_OCM_MASTERINF,Path)) {
        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(InfHandle,DIRID_OCM_PLATFORM,Platform,SETDIRID_NOT_FULL_PATH,0,0)) {
        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(
        InfHandle,DIRID_OCM_PLATFORM_ALTERNATE,
#ifdef _X86_
        TEXT("X86"),
#else
        Platform,
#endif
        SETDIRID_NOT_FULL_PATH,0,0)) {

        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(InfHandle,DIRID_OCM_COMPONENT,ComponentName,SETDIRID_NOT_FULL_PATH,0,0)) {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
pOcLoadInfsAndDlls(
    IN OUT POC_MANAGER OcManager,
    OUT    PBOOL       Canceled,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Loads per-component INFs and installation DLLs.

    This includes invoking the preinitialization and initialization
    entry points in the DLLs.

Arguments:

    OcManager - supplies OC manager context structure

    Cancelled - receives a flag that is valid when this routine fails,
        indicating whether the failure was caused by a component
        canceling.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome

--*/

{
    UINT i;
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    UINT ErrorLine;
    UINT Flags;
    UINT ErrorCode;
    PCTSTR InfName;
    PCTSTR ComponentName;
    TCHAR Library[MAX_PATH];
    BOOL b;
    INFCONTEXT Context;

    *Canceled = FALSE;

    //
    // The top-level component strctures have everything we need.
    // Spin through them.
    //
    for(i=0; i<OcManager->TopLevelOcCount; i++) {

        //
        // Get the OC data from the string table.
        //
        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InfStringId == -1) {
            //
            // The master OC inf specified that this component has no per-component inf.
            //
            OcInf.Handle = INVALID_HANDLE_VALUE;

        } else {
            //
            // Load the per-component INF if it has not already been loaded.
            //
            pSetupStringTableGetExtraData(OcManager->InfListStringTable,Oc.InfStringId,&OcInf,sizeof(OC_INF));

            if(!OcInf.Handle) {

               InfName = pSetupStringTableStringFromId(OcManager->InfListStringTable,Oc.InfStringId);
               if (!InfName) {
                  _LogError(OcManager,OcErrLevError,MSG_OC_OOM);
                  return(FALSE);
               }

                if(OcManager->InternalFlags & OCMFLAG_NEWINF) {

                    // First try the directory the master inf is in

               lstrcpy(Library, OcManager->SourceDir);
                    pSetupConcatenatePaths(Library, InfName, MAX_PATH, NULL);

                } else {
                    pOcFormSuitePath(OcManager->SuiteName,InfName,Library);
                }

                if(FileExists(Library, NULL)) {
                   OcInf.Handle = SetupOpenInfFile(Library,NULL,INF_STYLE_WIN4,&ErrorLine);
               } else {
                   //
                   // Use standard inf search rules if the inf can't be found
                   // in the special suite directory.
                   //
                   OcInf.Handle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,&ErrorLine);
               }

               if(OcInf.Handle == INVALID_HANDLE_VALUE) {
                   //
                   // Log error.
                   //
                   _LogError(OcManager,OcErrLevError,MSG_OC_CANT_OPEN_INF,InfName,GetLastError(),ErrorLine);
                   return(FALSE);
               } else {

                   // open the layout file

                   SetupOpenAppendInfFile(NULL, OcInf.Handle, NULL);

                   //
                   // Remember inf handle and set OC Manager DIRIDs.
                   //
                   pSetupStringTableSetExtraData(
                       OcManager->InfListStringTable,
                       Oc.InfStringId,
                       &OcInf,
                       sizeof(OC_INF)
                       );

                   b = pOcSetOcManagerDirIds(
                           OcInf.Handle,
                           OcManager->MasterOcInfPath,
                           pSetupStringTableStringFromId(OcManager->ComponentStringTable,OcManager->TopLevelOcStringIds[i])
                           );

                   if(!b) {
                       _LogError(OcManager,OcErrLevError,MSG_OC_OOM);
                       return(FALSE);
                   }
                   OcManager->SubComponentsPresent = TRUE;
               }
            }
        }

        //
        // Load the DLL and get the entry point address.
        // We make no attempt to track duplicates like we do for infs --
        // the underlying OS does that for us.
        //
        // The dll could be either in the special suite directory for this
        // master oc inf, or in a standard place. LoadLibraryEx does
        // exactly what we want.
        //
        if(Oc.InstallationDllName[0] && Oc.InterfaceFunctionName[0]) {

            if (OcManager->InternalFlags & OCMFLAG_NEWINF) {

                // First try the directory the master inf is in

                lstrcpy(Library, OcManager->SourceDir);
                pSetupConcatenatePaths(Library, Oc.InstallationDllName, MAX_PATH, NULL);
                Oc.InstallationDll = LoadLibraryEx(Library,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);

            }
            // Try the Setup Directory

            if (! Oc.InstallationDll ) {
                pOcFormSuitePath(OcManager->SuiteName,Oc.InstallationDllName,Library);
                Oc.InstallationDll = LoadLibraryEx(Library,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
            }

            // lastly try anywhere in the path
            if ( ! Oc.InstallationDll ) {
                Oc.InstallationDll = LoadLibraryEx(Oc.InstallationDllName,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
            }

            //
            // Failure is taken care of below....
            //
            if (Oc.InstallationDll) {
                Oc.InstallationRoutine = (POCSETUPPROC)GetProcAddress(
                                                Oc.InstallationDll,
                                                Oc.InterfaceFunctionName);
            } else {
                Oc.InstallationRoutine = NULL;
            }
        } else {
            Oc.InstallationDll = MyModuleHandle;
            Oc.InstallationRoutine = StandAloneSetupAppInterfaceRoutine;
        }

        if(Oc.InstallationDll && Oc.InstallationRoutine) {
            //
            // Success. Call the init-related entry points. Note that we can't call
            // any entry point except the preinit one until after we've stored
            // the ansi/unicode flag into the OPTIONAL_COMPONENT structure.
            //
            // Also note that before we do this we have to store the Oc structure,
            // otherwise the interface routine is NULL and we fault.
            //

            pSetupStringTableSetExtraData(
                OcManager->ComponentStringTable,
                OcManager->TopLevelOcStringIds[i],
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Oc.Flags = OcInterfacePreinitialize(OcManager,OcManager->TopLevelOcStringIds[i]);
            if(!Oc.Flags) {
                //
                // If this fails, then assume the DLL is written for a different
                // platform or version, for example a Unicode/ANSI problem.
                //
                _LogError(OcManager,
                    OcErrLevError,
                    MSG_OC_DLL_PREINIT_FAILED,
                    pSetupStringTableStringFromId(
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[i]
                        ),
                    Oc.InstallationDllName
                    );

                return(FALSE);
            }
        } else {

            //
            // Failure, log error.
            //
            _LogError(OcManager,
                OcErrLevError,
                MSG_OC_DLL_LOAD_FAIL,
                Oc.InstallationDllName,
                Oc.InterfaceFunctionName,
                GetLastError()
                );

            return(FALSE);
        }

        //
        // Set the OC data back into the string table.
        // After this we can call other interface entry points since
        // the ansi/unicode flag will now be stored in the OPTIONAL_COMPONENT
        // structure for the component.
        //
        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        ErrorCode = OcInterfaceInitComponent(
                        OcManager,
                        OcManager->TopLevelOcStringIds[i]
                        );

        if(ErrorCode == NO_ERROR) {
            // Send down extra helper routines.
            if ((Oc.InternalFlags & OCFLAG_NOEXTRAROUTINES)==0) {
                ErrorCode = OcInterfaceExtraRoutines(
                                OcManager,
                                OcManager->TopLevelOcStringIds[i]
                                );
            }
        }

        if(ErrorCode == NO_ERROR) {
            if (OcManager->InternalFlags & OCMFLAG_LANGUAGEAWARE) {
                //
                // Send down a set-language request.
                // Ignore the result.
                //
                OcInterfaceSetLanguage(
                    OcManager,
                    OcManager->TopLevelOcStringIds[i],
                    LANGIDFROMLCID(GetThreadLocale())
                    );
            }
        } else {
            if(ErrorCode == ERROR_CANCELLED) {
                // cancel will stop oc manager only if
                // we aren't running in gui-mode setup
                *Canceled = TRUE;
                if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                    return FALSE;
            } else {
                _LogError(OcManager,
                    OcErrLevError,
                    MSG_OC_DLL_INIT_FAILED,
                    pSetupStringTableStringFromId(
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[i]
                        )
                    );
            }

            pOcRemoveComponent(OcManager, OcManager->TopLevelOcStringIds[i], pidLoadComponent);
        }
    }

    //
    // Now go gather additional information about subcomponents
    // (descriptions, parentage, needs=, etc).
    //
    return(pOcBuildSubcomponentLists(OcManager,Log));
}


BOOL
pOcUnloadInfsAndDlls(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Unloads per-component INFs and installation DLLs that were
    previously loaded by pOcLoadInfsAndDlls().

    This routine does NOT call the interface entry points to
    uninitialize the installation DLLs.

Arguments:

    OcManager - supplies OC manager context structure

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome.
    If FALSE, an error will have been logged to indicate what failed.

--*/

{
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    UINT i;

    //
    // Unload Dlls.
    //
    for(i=0; i<OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InstallationDll && (Oc.InstallationDll != MyModuleHandle)) {
            FreeLibrary(Oc.InstallationDll);
            Oc.InstallationDll = NULL;
        }

        Oc.InstallationRoutine = NULL;
        Oc.InstallationDllName[0] = 0;
        Oc.InterfaceFunctionName[0]= 0;

        if(Oc.InfStringId != -1) {

            pSetupStringTableGetExtraData(
                OcManager->InfListStringTable,
                Oc.InfStringId,
                &OcInf,
                sizeof(OC_INF)
                );

            if(OcInf.Handle && (OcInf.Handle != INVALID_HANDLE_VALUE)) {

                SetupCloseInfFile(OcInf.Handle);
                OcInf.Handle = INVALID_HANDLE_VALUE;

                pSetupStringTableSetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                    );
            }

            Oc.InfStringId = -1;
        }

        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );
    }

    return(TRUE);
}


BOOL
pOcManagerInitPrivateDataStore(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Initializes the private data store for components.
    The registry is used as the backing store for private data.
    We make use of volatile keys to help ensure that this data is temporary
    in nature.

Arguments:

    OcManager - supplies OC Manager context stucture.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome. If FALSE an error will have
    been logged.

--*/

{
    LONG l;
    DWORD Disposition;

    //
    // Start out by forming a unique name for this instantiation
    // of the OC Manager.
    //
    wsprintf(OcManager->PrivateDataSubkey,TEXT("%x:%x"),GetCurrentProcessId(),OcManager);

    //
    // Open/create the private data root. Save the handle.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szPrivateDataRoot,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &OcManager->hKeyPrivateDataRoot,
            &Disposition
            );

    if(l != NO_ERROR) {
        OcManager->hKeyPrivateDataRoot = NULL;
        OcManager->hKeyPrivateData = NULL;
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,szPrivateDataRoot,l);
        return(FALSE);
    }

    //
    // Get rid of the private data tree if it already exists for some reason.
    //
    if(Disposition == REG_OPENED_EXISTING_KEY) {
        pSetupRegistryDelnode(OcManager->hKeyPrivateDataRoot,OcManager->PrivateDataSubkey);
    }

    //
    // Create the private data tree. Save the handle.
    //
    l = RegCreateKeyEx(
            OcManager->hKeyPrivateDataRoot,
            OcManager->PrivateDataSubkey,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &OcManager->hKeyPrivateData,
            &Disposition
            );

    if(l != NO_ERROR) {
        RegCloseKey(OcManager->hKeyPrivateDataRoot);
        OcManager->hKeyPrivateDataRoot = NULL;
        OcManager->hKeyPrivateData = NULL;
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,OcManager->PrivateDataSubkey,l);
        return(FALSE);
    }

    return(TRUE);
}


VOID
pOcManagerTearDownPrivateDataStore(
    IN OUT POC_MANAGER OcManager
    )
{
    RegCloseKey(OcManager->hKeyPrivateData);
    pSetupRegistryDelnode(OcManager->hKeyPrivateDataRoot,OcManager->PrivateDataSubkey);
    RegCloseKey(OcManager->hKeyPrivateDataRoot);

    OcManager->hKeyPrivateDataRoot = NULL;
    OcManager->hKeyPrivateData = NULL;
}


UINT
pOcQueryOrSetNewInf(
    IN  PCTSTR MasterOcInfName,
    OUT PTSTR  SuiteName,
    IN  DWORD  operation
    )

/*++

Routine Description:

    Determine whether a master OC inf has been encountered before,
    or remember that a master inf has been encountered.

    This information is stored in the registry.

Arguments:

    MasterOcInfName - supplies the full Win32 path of the master OC inf.

    SuiteName - receives the filename part of the .inf, without any
        extension. This is suitable for use as a tag representing the
        suite that the master INF is for. This buffer should be
        MAX_PATH TCHAR elements.

    QueryOnly - if TRUE, then the routine is to query whether the
        master inf has been previously processed. If FALSE, then
        the routine is to remember that the inf has been processed.

Return Value:

    If QueryOnly is TRUE:

        TRUE if the INF has been encountered before, FALSE if not.

    If QueryOnly is FALSE:

        Win32 error code indicating outcome.

--*/

{
    PTCHAR p;
    HKEY hKey;
    LONG l;
    DWORD Type;
    DWORD Size;
    DWORD Data;

    //
    // Form the suite name. The MasterOcInfName is expected to be
    // a full path so this is pretty easy. We'll try to be at least
    // a little more robust.
    //
    if(p = _tcsrchr(MasterOcInfName,TEXT('\\'))) {
        p++;
    } else {
        p = (PTCHAR)MasterOcInfName;
    }
    lstrcpyn(SuiteName,p,MAX_PATH);
    if(p = _tcsrchr(SuiteName,TEXT('.'))) {
        *p = 0;
    }

    //
    // Look in the registry to see if there is a value entry
    // with the suite name in there.
    //

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szMasterInfs,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (operation == infQuery) ? KEY_QUERY_VALUE : KEY_SET_VALUE,
            NULL,
            &hKey,
            &Type
            );

    if (l != NO_ERROR)
        return (operation == infQuery) ? 0 : l;

    // do the job

    switch (operation) {

    case infQuery:
        Size = sizeof(DWORD);
        l = RegQueryValueEx(hKey,SuiteName,NULL,&Type,(LPBYTE)&Data,&Size);
        if((l == NO_ERROR) && (Type == REG_DWORD) && Data)
            l = TRUE;
        else
            l = FALSE;
        break;

    case infSet:
        Data = 1;
        l = RegSetValueEx(hKey,SuiteName,0,REG_DWORD,(LPBYTE)&Data,sizeof(DWORD));
        break;

    case infReset:
        l = RegDeleteValue(hKey,SuiteName);
        break;
    }

    RegCloseKey(hKey);

    return l;
}


PVOID
OcInitialize(
    IN  POCM_CLIENT_CALLBACKS Callbacks,
    IN  LPCTSTR               MasterOcInfName,
    IN  UINT                  Flags,
    OUT PBOOL                 ShowError,
    IN  PVOID                 Log
    )

/*++

Routine Description:

    Initializes the OC Manager. The master OC INF is loaded and
    processed, which includes INFs, loading setup interface DLLs and
    querying interface entry points. A set of in-memory structures
    is built up.

    If the OC INF hasn't been processed before then we copy the
    installation files for the component(s) into %windir%\system32\setup.
    Files are expected to be in the same directory as the OC inf.

Arguments:

    Callbacks - supplies a set of routines used by the OC Manager
        to perform various functions.

    MasterOcInfName - supplies the full Win32 path of the master OC inf.

    Flags - supplies various flags that control operation.

    ShowError - receives a flag that is valid if this routine fails,
        advising the caller whether he should show an error message.

    Log - supplies a handle to use to log errors.

Return Value:

    Opaque pointer to internal context structure or NULL if failure.
    If NULL, an error will have been logged to indicate what failed.

--*/

{
    POC_MANAGER OcManager;
    UINT i;
    HKEY hKey;
    DWORD DontCare;
    LONG l;
    BOOL Canceled;
    BOOL rc;
    TCHAR *p;

    *ShowError = TRUE;

    // init the wizard handle

    WizardDialogHandle = NULL;

    //
    // Allocate a new OC MANAGER structure
    //
    OcManager = pSetupMalloc(sizeof(OC_MANAGER));
    if(!OcManager) {
        //
        // Make the callback work
        //
        OC_MANAGER ocm;
        ocm.Callbacks = *Callbacks;
        _LogError(&ocm,OcErrLevFatal,MSG_OC_OOM);
        goto c0;
    }
    ZeroMemory(OcManager,sizeof(OC_MANAGER));

    OcManager->Callbacks = *Callbacks;

    OcManager->CurrentComponentStringId = -1;
    OcManager->SetupMode = SETUPMODE_CUSTOM;
    OcManager->UnattendedInf = INVALID_HANDLE_VALUE;

    gLastOcManager = (POC_MANAGER) OcManager;

    if (!pOcInitPaths(OcManager, MasterOcInfName)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_MASTER_INF_LOAD_FAILED);
        goto c1;
    }

    sapiAssert(*OcManager->MasterOcInfPath);

#ifdef UNICODE
    OcFillInSetupDataW(&(OcManager->SetupData));
#else
    OcFillInSetupDataA(&(OcManager->SetupData));
#endif

    // Say the user canceled until we successfully complete an install
    // This will prevent Inf Files from being copied to system32\setup

    OcManager->InternalFlags |= OCMFLAG_USERCANCELED;

    // Make sure the OC Manager key exists in the registry as a non-volatile key.
    // Other parts of the code deal in volatile keys so some care is needed to
    // avoid getting a volatile key under which we want to create non-volatile entries.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerRoot,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &hKey,
            &DontCare
            );

    if(l == NO_ERROR) {
        RegCloseKey(hKey);
    } else {
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,szOcManagerRoot,l);
    }

    // get the locale info

    locale.lcid = GetSystemDefaultLCID();
    GetLocaleInfo(locale.lcid,
                  LOCALE_SDECIMAL,
                  locale.DecimalSeparator,
                  sizeof(locale.DecimalSeparator)/sizeof(TCHAR));

    //
    // Initialize string tables.
    //
    OcManager->InfListStringTable = pSetupStringTableInitializeEx(sizeof(OC_INF),0);
    if(!OcManager->InfListStringTable) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    OcManager->ComponentStringTable = pSetupStringTableInitializeEx(sizeof(OPTIONAL_COMPONENT),0);
    if(!OcManager->ComponentStringTable) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c2;
    }

    //
    // Initialize various arrays. We alloc 0-length blocks here to allow
    // realloc later without special casing.
    //
    OcManager->TopLevelOcStringIds = pSetupMalloc(0);
    if(!OcManager->TopLevelOcStringIds) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c3;
    }

    for(i=0; i<WizPagesTypeMax; i++) {
        OcManager->WizardPagesOrder[i] = pSetupMalloc(0);
        if(!OcManager->WizardPagesOrder[i]) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c4;
        }
    }

    //
    // Initialize the private data store.
    //
    if(!pOcManagerInitPrivateDataStore(OcManager,Log)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_PRIVATEDATASTORE_INIT_FAILED);
        goto c4;
    }

    //
    // Load the master OC inf.
    //
    if(!pOcLoadMasterOcInf(OcManager, Flags, Log)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_MASTER_INF_LOAD_FAILED);
        goto c5;
    }

    // set the source path

    lstrcpy(OcManager->SourceDir, OcManager->MasterOcInfPath);
    if (p = _tcsrchr(OcManager->SourceDir, TEXT('\\')))
        *p = 0;
    else
       GetCurrentDirectory(MAX_PATH, OcManager->SourceDir);

    //
    // Load the unattend file
    //
    if(OcManager->SetupData.UnattendFile[0]) {
        OcManager->UnattendedInf = SetupOpenInfFile(
                                        OcManager->SetupData.UnattendFile,
                                        NULL,
                                        INF_STYLE_WIN4,
                                        NULL
                                        );

        if (OcManager->UnattendedInf == INVALID_HANDLE_VALUE && GetLastError() == ERROR_WRONG_INF_STYLE) {
            OcManager->UnattendedInf = SetupOpenInfFile(
                                            OcManager->SetupData.UnattendFile,
                                            NULL,
                                            INF_STYLE_OLDNT,
                                            NULL
                                            );
        }

        if(OcManager->UnattendedInf == INVALID_HANDLE_VALUE) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_OPEN_INF,OcManager->SetupData.UnattendFile,GetLastError());
            goto c6;
        }
    }


    //
    // Load component infs and DLLs.
    //
    rc = pOcLoadInfsAndDlls(OcManager, &Canceled, Log);

    //
    // Error already logged if necessary
    //
    if (Canceled)
        *ShowError = FALSE;

    if (!rc)
        goto c6;

    pOcClearAllErrorStates(OcManager);

    if(!pOcFetchInstallStates(OcManager)) {
        //
        // Error already logged.
        //
        goto c6;
    }


   //
    // Ask the components to give up a rough estimate
    // of their sizes so we can say something meaningful in the list boxes.
    //

    pOcGetApproximateDiskSpace(OcManager);
    return(OcManager);

c6:
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
    if (OcManager->UnattendedInf != INVALID_HANDLE_VALUE)
        SetupCloseInfFile(OcManager->UnattendedInf);
c5:
    //
    // Tear down private data store.
    //
    pOcManagerTearDownPrivateDataStore(OcManager);

c4:
    if(OcManager->TopLevelOcStringIds) {
        pSetupFree(OcManager->TopLevelOcStringIds);

        for(i=0; OcManager->WizardPagesOrder[i] && (i<WizPagesTypeMax); i++) {
            pSetupFree(OcManager->WizardPagesOrder[i]);
        }
    }

    // free up the list of aborted components

    if (OcManager->AbortedComponentIds) {
        pSetupFree(OcManager->AbortedComponentIds);
    }

c3:
    pOcDestroyPerOcData(OcManager);
    pSetupStringTableDestroy(OcManager->ComponentStringTable);
c2:
    pSetupStringTableDestroy(OcManager->InfListStringTable);
c1:
    pSetupFree(OcManager);
c0:
    return(NULL);
}

VOID
OcTerminate(
    IN OUT PVOID *OcManagerContext
    )

/*++

Routine Description:

    This routine shuts down the OC Manager, including calling the subcomponents
    to clean themselves up, release resources, etc.

Arguments:

    OcManagerContext - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

Return Value:

    None.

--*/

{
    POC_MANAGER OcManager;
    UINT u;
    BOOL b;
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    LPCTSTR ComponentName;
    LPCTSTR InfName;

    sapiAssert(OcManagerContext && *OcManagerContext);
    OcManager = *OcManagerContext;
    *OcManagerContext = NULL;

    //
    // Run down the top-level OCs, calling the dlls to indicate that we're done.
    // We don't tear down any infrastructure until after we've told all the dlls
    // that we're done.
    //
    for(u=0; u<OcManager->TopLevelOcCount; u++) {
        OcInterfaceCleanup(OcManager,OcManager->TopLevelOcStringIds[u]);
    }

    // if the user did not cancel setup
    //
    if (!(OcManager->InternalFlags & OCMFLAG_USERCANCELED)){

        //
        // Remember persistent install state.
        //
        pOcRememberInstallStates(OcManager);

        // copy the master INF file over

        if ( OcManager->InternalFlags & OCMFLAG_NEWINF ) {
            b = pOcInstallSetupComponents(
                        NULL,
                        OcManager,
                        OcManager->SuiteName,
                        NULL,
                        _tcsrchr(OcManager->MasterOcInfPath,TEXT('\\')), //  InfName,
                        NULL,
                        NULL
                );
        }
    }
    //
    // Run down the top-level OCs and free DLLs and per-component infs.
    //
    for(u=0; u<OcManager->TopLevelOcCount; u++) {

        ComponentName =   pSetupStringTableStringFromId(      // ComponentName
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[u]);

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[u],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InstallationDll && (Oc.InstallationDll != MyModuleHandle)) {
            //FreeLibrary(Oc.InstallationDll);
        }

        if(Oc.InfStringId != -1) {

            pSetupStringTableGetExtraData(
                OcManager->InfListStringTable,
                Oc.InfStringId,
                &OcInf,
                sizeof(OC_INF)
                );

            if(OcInf.Handle && (OcInf.Handle != INVALID_HANDLE_VALUE)) {
                SetupCloseInfFile(OcInf.Handle);

                //
                // Mark the handle as closed, is to components are shareing
                // the same INF file, should only close the file once.
                //
                OcInf.Handle = INVALID_HANDLE_VALUE;
                pSetupStringTableSetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                );
            }
        }
        // This is a new install and we did not cancel out of setup
        // copy the setup components to the setup dir otherwise a canceled
        // setup will leave an upgrade dead in the water.

        if ( ( (OcManager->InternalFlags & OCMFLAG_NEWINF )
               || ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) )
             && (! (OcManager->InternalFlags & OCMFLAG_USERCANCELED))){

            if (Oc.InfStringId == -1) {
                InfName = NULL;
            } else {
                InfName = pSetupStringTableStringFromId(OcManager->InfListStringTable,
                                                  Oc.InfStringId);
            }

            b = pOcInstallSetupComponents(
                    &Oc,
                    OcManager,
                    ComponentName,
                    Oc.InstallationDllName,
                    InfName,
                    NULL,
                    NULL
            );
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_INSTALL_SETUP,ComponentName);
            }
        }


    }

    //
    // Free string tables.
    //
    pOcDestroyPerOcData(OcManager);
    pSetupStringTableDestroy(OcManager->ComponentStringTable);
    pSetupStringTableDestroy(OcManager->InfListStringTable);

    //
    // Free the wizard page ordering arrays.
    //
    for(u=0; u<WizPagesTypeMax; u++) {
        if(OcManager->WizardPagesOrder[u]) {
            pSetupFree(OcManager->WizardPagesOrder[u]);
        }
    }

    //
    // Tear down the private data store.
    //
    pOcManagerTearDownPrivateDataStore(OcManager);

    //
    // Free the master oc inf and finally the oc manager context structure itself.
    //
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
    if (OcManager->UnattendedInf && OcManager->UnattendedInf != INVALID_HANDLE_VALUE)
        SetupCloseInfFile(OcManager->UnattendedInf);

    // If this is a remove all then Delete the master inf file too!
    if (    !(OcManager->InternalFlags & OCMFLAG_USERCANCELED)
        &&  ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK)
                == SETUPMODE_REMOVEALL )) {

        TCHAR InFSuitePath[MAX_PATH];

        // Se do it this way, so if you run remove all from the
        // orginal source location we don't blow away that copy of the
        // suite inf file.

        pOcFormSuitePath(NULL,OcManager->MasterOcInfPath,InFSuitePath);
        DeleteFile(InFSuitePath);
    }

    // free up the list of aborted components

    if (OcManager->AbortedComponentIds) {
        pSetupFree(OcManager->AbortedComponentIds);
    }

    if (OcManager->TopLevelOcStringIds) {
        pSetupFree(OcManager->TopLevelOcStringIds);
    }

    if (OcManager->TopLevelParentOcStringIds) {
        pSetupFree(OcManager->TopLevelParentOcStringIds);
    }

    //
    // free the oc manager context structure itself.
    //
    pSetupFree(OcManager);

    gLastOcManager = NULL;
}


BOOL
OcSubComponentsPresent(
    IN PVOID OcManagerContext
   )

/*++

Routine Description:

    This routine tells the caller if there are any
    subcomponents available on the details page.

Arguments:

    OcManager - supplies pointer to OC Manager context structure.

Return Value:

    TRUE = yes, there are subcomponents
    FALSE = no way

--*/

{
    POC_MANAGER OcManager = (POC_MANAGER)OcManagerContext;

    if (!OcManagerContext) {
        return FALSE;
    }
    return OcManager->SubComponentsPresent;
}


VOID
pOcDestroyPerOcData(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine frees all data allocated as part of the per-subcomponent
    data structures. The component list string table is enumerated;
    the OPTIONAL_COMPONENT structures have several pointers for arrays
    that must be freed.

Arguments:

    OcManager - supplies pointer to OC Manager context structure.

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;

    pSetupStringTableEnum(
        OcManager->ComponentStringTable,
        &OptionalComponent,
        sizeof(OPTIONAL_COMPONENT),
        pOcDestroyPerOcDataStringCB,
        0
        );
}


BOOL
pOcDestroyPerOcDataStringCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              Unused
    )

/*++

Routine Description:

    String table callback routine that is the worker routine for
    pOcDestroyPerOcData.

Arguments:

    Standard string table callback arguments.

Return Value:

    Always returns TRUE to continue enumeration.

--*/

{
    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(OcSize);
    UNREFERENCED_PARAMETER(Unused);

    if(Oc->NeedsStringIds) {
        pSetupFree(Oc->NeedsStringIds);
    }
    if(Oc->NeededByStringIds) {
        pSetupFree(Oc->NeededByStringIds);
    }

    if (Oc->ExcludeStringIds){
        pSetupFree(Oc->ExcludeStringIds);
    }
    if(Oc->ExcludedByStringIds){
        pSetupFree(Oc->ExcludedByStringIds);
    }
    if (Oc->HelperContext) {
        pSetupFree(Oc->HelperContext);
    }

    return(TRUE);
}


BOOL
pOcClearAllErrorStatesCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              OcManager
    )
{
    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(OcSize);

    OcHelperClearExternalError ((POC_MANAGER)OcManager, StringId ,0);

    return(TRUE);
}

VOID
pOcClearAllErrorStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine clears out the past registry entries for error reports
    for all components

Arguments:

    OcManagerContext - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

Return Value:

    None.

--*/
{
    OPTIONAL_COMPONENT OptionalComponent;

    pSetupStringTableEnum(
        OcManager->ComponentStringTable,
        &OptionalComponent,
        sizeof(OPTIONAL_COMPONENT),
        pOcClearAllErrorStatesCB,
        (LPARAM)OcManager
        );


}

BOOL
pOcRemoveComponent(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN DWORD       PhaseId
    )

/*++

Routine Description:

    This routine adds a specified component to the list of aborted components,
    preventing it's entry function from being called any more.

Arguments:

    OcManager - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

    ComponentId - in input, this string names the faulty component to be removed

Return Value:

    None.

--*/
{
    PVOID p;
    OPTIONAL_COMPONENT Oc;

    // test for valid component to remove

    if (ComponentId <= 0)
        return FALSE;

    if (pOcComponentWasRemoved(OcManager, ComponentId))
        return FALSE;

    // add component to list of aborted components

    if (!OcManager->AbortedCount) {
        OcManager->AbortedComponentIds = pSetupMalloc(sizeof(UINT));
        if (!OcManager->AbortedComponentIds)
            return FALSE;
    }

    OcManager->AbortedCount++;
    p = pSetupRealloc(OcManager->AbortedComponentIds, sizeof(UINT) * OcManager->AbortedCount);
    if (!p) {
        OcManager->AbortedCount--;
        return FALSE;
    }

    OcManager->AbortedComponentIds = (UINT *)p;
    OcManager->AbortedComponentIds[OcManager->AbortedCount - 1] = ComponentId;

    // stop display of component in the listbox, if it isn't too late

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        ComponentId,
        &Oc,
        sizeof(OPTIONAL_COMPONENT)
        );

    Oc.InternalFlags |= OCFLAG_HIDE;

    pSetupStringTableSetExtraData(
        OcManager->ComponentStringTable,
        ComponentId,
        &Oc,
        sizeof(OPTIONAL_COMPONENT)
        );

    _LogError(OcManager,
              OcErrLevInfo | OcErrBatch,
              MSG_OC_REMOVE_COMPONENT,
              pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
              PhaseId
              );

    return TRUE;
}

BOOL
pOcComponentWasRemoved(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId
    )

/*++

Routine Description:

    This routine indicates if a components has been aborted.

Arguments:

    OcManager - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

    ComponentId - in input, this string names the component to check for

Return Value:

    BOOL - true if it was aborted - else false

--*/
{
    UINT i;

    for (i = 0; i < OcManager->AbortedCount; i++) {
        if (OcManager->AbortedComponentIds[i] == ComponentId) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocinterf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocinterf.c

Abstract:

    Routines to interface with optional components via the OC Manager
    interface routine exported from the component's installation DLL.

Author:

    Ted Miller (tedm) 16-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUGPERFTRACE

#define RES_BUFFER   512
#define MAX_LOGLINE  1024
#define EOL_LENGTH 3
#define BUFFER_SIZE 64*1024

VOID
DebugLogPerf(
    VOID
    )
{
    LPTSTR                      lpProcessName;
    NTSTATUS                    Status;
    ULONG                       Offset1;
    PUCHAR                      CurrentBuffer;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    LPTSTR                      lpTemp;//[RES_BUFFER];
    HMODULE                     hNtDll;
    LONG_PTR                    (*NtQSI)(); // Ptr to NtQuerySystemInformation
    HANDLE                      hProcessName;
    TCHAR                       szLogLine[MAX_LOGLINE+EOL_LENGTH];
    LPCTSTR                     szResBuf = TEXT("%7i%20ws->%10u%10u%10u%10u%10u%10u%10u\r\n");


    if ((hNtDll = LoadLibrary(TEXT("NTDLL.DLL"))) == NULL)
    {
        return;
    }

    NtQSI = GetProcAddress(hNtDll, "NtQuerySystemInformation" );
    if( NtQSI == NULL )
    {
        FreeLibrary(hNtDll);
        return;
    }


    //header for mem area
    TRACE (( TEXT("Proc ID           Proc.Name   Wrkng.Set PagedPool  NonPgdPl  Pagefile    Commit   Handles   Threads\n") ));

    /* grab all process information */
    /* log line format, all comma delimited,CR delimited:
    pid,name,WorkingSetSize,QuotaPagedPoolUsage,QuotaNonPagedPoolUsage,PagefileUsage,CommitCharge<CR>
    log all process information */

    /* from pmon */
    Offset1 = 0;
    if ((CurrentBuffer = VirtualAlloc (NULL,
                                  BUFFER_SIZE,
                                  MEM_COMMIT,
                                  PAGE_READWRITE)) != NULL)
    {
        /* from memsnap */
        /* get commit charge */
        /* get all of the status information */
        Status = (NTSTATUS)(*NtQSI)(
                          SystemProcessInformation,
                          CurrentBuffer,
                          BUFFER_SIZE,
                          NULL );

        if (NT_SUCCESS(Status)){
                for (;;)
                {

                    /* get process info from buffer */
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];
                    Offset1 += ProcessInfo->NextEntryOffset;
                    if (ProcessInfo->ImageName.Buffer) {
                        if (!lstrcmpi(ProcessInfo->ImageName.Buffer, TEXT("sysocmgr.exe")) ||
                            !lstrcmpi(ProcessInfo->ImageName.Buffer, TEXT("setup.exe")) ) {
                            wsprintf(szLogLine,
                             szResBuf,
                             ProcessInfo->UniqueProcessId,
                             ProcessInfo->ImageName.Buffer,
                             ProcessInfo->WorkingSetSize / 1024,
                             ProcessInfo->QuotaPagedPoolUsage / 1024,
                             ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                             ProcessInfo->PagefileUsage / 1024,
                             ProcessInfo->PrivatePageCount / 1024,
                             ProcessInfo->HandleCount,
                             ProcessInfo->NumberOfThreads );

                            TRACE(( szLogLine ));
                        }
                    }
#if 0
                    // if buffer is null then it's idle process or unknown
                    if (!ProcessInfo->ImageName.Buffer)
                    {
                        if (ProcessInfo->UniqueProcessId == (HANDLE)0)
                            lpTemp = TEXT("Idle");
                        else
                            lpTemp = TEXT("Unknown");

                        wsprintf(szLogLine,
                                     szResBuf,
                                     ProcessInfo->UniqueProcessId,
                                     lpTemp,
                                     ProcessInfo->WorkingSetSize / 1024,
                                     ProcessInfo->QuotaPagedPoolUsage / 1024,
                                     ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                                     ProcessInfo->PagefileUsage / 1024,
                                     ProcessInfo->PrivatePageCount / 1024,
                                     ProcessInfo->HandleCount,
                                     ProcessInfo->NumberOfThreads );
                    }
                    else
                    {
                        wsprintf(szLogLine,
                             szResBuf,
                             ProcessInfo->UniqueProcessId,
                             ProcessInfo->ImageName.Buffer,
                             ProcessInfo->WorkingSetSize / 1024,
                             ProcessInfo->QuotaPagedPoolUsage / 1024,
                             ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                             ProcessInfo->PagefileUsage / 1024,
                             ProcessInfo->PrivatePageCount / 1024,
                             ProcessInfo->HandleCount,
                             ProcessInfo->NumberOfThreads );
                    }

                    TRACE(( szLogLine ));
#endif
                    if (ProcessInfo->NextEntryOffset == 0)
                    {
                        break;
                    }
                }
            //status failed
        }
        /* free mem */
        VirtualFree(CurrentBuffer,0,MEM_RELEASE);
    }

    //tail for mem area
    TRACE(( TEXT("\n") ));

    FreeLibrary(hNtDll);

}

#endif

#ifdef UNICODE

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps (
    VOID
    );

#define ASSERT_HEAP_IS_VALID(_x_)  sapiAssert(RtlValidateProcessHeaps && _x_)

#else

#define ASSERT_HEAP_IS_VALID(_x_)

#endif


DWORD gecode;
PVOID geaddr;

DWORD
efilter(
    LPEXCEPTION_POINTERS ep
    )

/*++

Routine Description:

    handles exception during calls to oc component routines


Arguments:

    ep - exception information

Return Value:

    always 1 - execute the handler

--*/

{
    gecode = ep->ExceptionRecord->ExceptionCode;
    geaddr = ep->ExceptionRecord->ExceptionAddress;

    RtlUnhandledExceptionFilter( ep);
    return EXCEPTION_EXECUTE_HANDLER;
}


BOOL
pOcInterface(
    IN  POC_MANAGER  OcManager,
    OUT PUINT        Result,
    IN  LONG         ComponentId,
    IN  LPCTSTR      Subcomponent,      OPTIONAL
    IN  UINT         Function,
    IN  UINT_PTR     Param1,
    IN  PVOID        Param2
    )

/*++

Routine Description:

    Perform the actual call to the OC interface routine.

    Converts Unicode component/subcomponent names to ANSI if needed.

Arguments:

    OcManager - supplies OC Manager context structure.

    Result -

    ComponentId -

    Remaining arguments specify parameters to be passed directly to
    the interface.

Return Value:

    TRUE if the interface routine was successfully called and returned
        without faulting. LastError() is preserved in this case.

    FALSE otherwise.

--*/

{
    LONG OldComponentStringId;
    BOOL b;
    LPCTSTR Component;
    OPTIONAL_COMPONENT Oc;
    LPCVOID comp,subcomp;
#ifdef UNICODE
    CHAR AnsiComp[500];
    CHAR AnsiSub[500];
#endif

    //
    // Get the name of the component and the optional component data
    // from the string table.
    //
    // Though it would be strange, it is possible that this will fail,
    // so we do a little checking for robustness.
    //
    Component = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    b = pSetupStringTableGetExtraData(OcManager->ComponentStringTable,ComponentId,&Oc,sizeof(OPTIONAL_COMPONENT));
    if(!Component || !b || !Oc.InstallationRoutine) {
        return(FALSE);
    }

    OldComponentStringId = OcManager->CurrentComponentStringId;
    OcManager->CurrentComponentStringId = ComponentId;

#ifdef UNICODE
    //
    // If necessary, convert component name and subcomponent name to ANSI.
    //
    if((Function != OC_PREINITIALIZE) && (Oc.Flags & OCFLAG_ANSI)) {

        WideCharToMultiByte(CP_ACP,0,Component,-1,AnsiComp,sizeof(AnsiComp),NULL,NULL);
        comp = AnsiComp;

        if(Subcomponent) {
            WideCharToMultiByte(CP_ACP,0,Subcomponent,-1,AnsiSub,sizeof(AnsiSub),NULL,NULL);
            subcomp = AnsiSub;
        } else {
            subcomp = NULL;
        }
    } else
#endif
    {
        comp = Component;
        subcomp = Subcomponent;
    }

    *Result = CallComponent(OcManager, &Oc, comp, subcomp, Function, Param1, Param2);

    b = (*Result == ERROR_CALL_COMPONENT) ? FALSE : TRUE;

    OcManager->CurrentComponentStringId = OldComponentStringId;

    return b;
}

DWORD
CallComponent(
    IN     POC_MANAGER OcManager,
    IN     POPTIONAL_COMPONENT Oc,
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )

/*++

Routine Description:

    Calls a component's interface routine with a try-except block.

Arguments:

    Oc - supplies a pointer to the component description structure

    ComponentId - string description of the component

    SubcomponentId - string description of the subcomponent

    Function - notification being sent to the component

    Param1 - differs with each function

    Param2 - differs with each function

Return Value:

    Component return value.  Meaning differs with each function.

--*/

{
    DWORD result;
    BOOL  exception = FALSE;
    TCHAR *comp;
    LONG id;
    int i;
#ifdef DEBUGPERFTRACE
    DWORD tick;
#endif

    // don't call dead components

    id = OcManager->CurrentComponentStringId;
    sapiAssert(id > 0);

    if (pOcComponentWasRemoved(OcManager, id))
        return NO_ERROR;

    sapiAssert(Oc->InstallationRoutine);

#ifdef PRERELEASE
#ifdef DBG
    ASSERT_HEAP_IS_VALID("The process heap was corrupted before calling the component.");

#if 0
    if (FTestForOutstandingCoInits() != S_OK) {
        sapiAssert( FALSE && "There is an unbalanced call to CoInitialize()");
    }
#endif

#endif
#endif

#ifdef DEBUGPERFTRACE
    TRACE(( TEXT("before calling component\n") ));
    DebugLogPerf();
    tick = GetTickCount();
    TRACE(( TEXT("calling component, %d:\n"), tick ));
#endif

    try {

        result = Oc->InstallationRoutine(ComponentId, SubcomponentId, Function, Param1, Param2);

    } except(efilter(GetExceptionInformation())) {

        exception = TRUE;
    }

#ifdef DEBUGPERFTRACE
    TRACE(( TEXT("after calling component, %d (time = %d)\n"),GetTickCount(), GetTickCount() - tick));
    DebugLogPerf();
#endif

#ifdef PRERELEASE
#ifdef DBG
    ASSERT_HEAP_IS_VALID("The process heap was corrupted after calling the component.  If you did not get an assertion before calling the component, this indicates an error in the component.  Click yes and get a stack trace to detect the component.");

#if 0
    if (FTestForOutstandingCoInits() != S_OK) {
        sapiAssert( FALSE && "There is an unbalanced call to CoInitialize()");
    }
#endif
#endif
#endif


    if (exception) {

#ifdef UNICODE
        if (Oc->Flags & OCFLAG_ANSI)
            comp = pSetupAnsiToUnicode(ComponentId);
        else
#endif
            comp = (TCHAR *)ComponentId;

        _LogError(
            OcManager,
            OcErrLevError|MB_ICONEXCLAMATION|MB_OK,
            MSG_OC_EXCEPTION_IN_COMPONENT,
             comp,
             Oc->InstallationRoutine,
             Function,
             Param1,
             Param2,
             gecode,
             geaddr
            );

#ifdef UNICODE
        if (Oc->Flags & OCFLAG_ANSI)
            pSetupFree(comp);
#endif

        sapiAssert(0);
        pOcRemoveComponent(OcManager, id, pidCallComponent);
        result = ERROR_CALL_COMPONENT;
    }

    return result;
}

UINT
OcInterfacePreinitialize(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_PREINITIALIZE function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Flags bitfield (OCFLAG_xxx) for the component. 0 means error.

--*/

{
    BOOL b;
    UINT FlagsIn;
    UINT FlagsOut;
    OPTIONAL_COMPONENT Oc;
#ifdef UNICODE
    CHAR AnsiName[250];
    LPCWSTR UnicodeName;
#endif

    TRACE((
        TEXT("OCM: OC_PREINITIALIZE Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Set up input flags.
    //
    FlagsIn = OCFLAG_ANSI;
#ifdef UNICODE
    FlagsIn |= OCFLAG_UNICODE;

    UnicodeName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    if(!UnicodeName) {
        return(0);
    }

    WideCharToMultiByte(CP_ACP,0,UnicodeName,-1,AnsiName,sizeof(AnsiName),NULL,NULL);
#endif

    b = pOcInterface(
            OcManager,
            &FlagsOut,
            ComponentId,
#ifdef UNICODE
            (LPCTSTR)AnsiName,
#else
            NULL,
#endif
            OC_PREINITIALIZE,
            FlagsIn,
            0
            );

    TRACE(( TEXT("...%x (retval %s)\n"), FlagsOut, b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        goto error;
    }

    //
    // If neither flag is set, error.
    //
    if(!(FlagsOut & (OCFLAG_ANSI | OCFLAG_UNICODE))) {
        goto error;
    }

#ifdef UNICODE
    //
    // Use Unicode if it is supported by the component.
    //
    if(FlagsOut & OCFLAG_UNICODE) {
        FlagsOut = OCFLAG_UNICODE;
    }
#else
    //
    // If ANSI is not supported then we've got a problem.
    //
    if(FlagsOut & OCFLAG_ANSI) {
        FlagsOut = OCFLAG_ANSI;
    } else {
        goto error;
    }
#endif

    goto eof;

error:
    pOcRemoveComponent(OcManager, ComponentId, pidPreInit);
    FlagsOut = 0;

eof:
    return(FlagsOut);
}


UINT
OcInterfaceInitComponent(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_INIT_COMPONENT interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Win32 error indicating value returned by the component.

--*/

{
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    BOOL b;
    SETUP_INIT_COMPONENTA InitDataA;
#ifdef UNICODE
    SETUP_INIT_COMPONENTW InitDataW;
#endif
    UINT u;
    PUINT pu;
    PHELPER_CONTEXT HelperContext;

#ifdef UNICODE
    ZeroMemory( &InitDataW, sizeof( InitDataW ));
#else
    ZeroMemory( &InitDataA, sizeof( InitDataA ));
#endif

    TRACE((
        TEXT("OCM: OC_INIT_COMPONENT Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    HelperContext = pSetupMalloc(sizeof(HELPER_CONTEXT));
    if(!HelperContext) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    HelperContext->OcManager = OcManager;
    HelperContext->ComponentStringId = ComponentId;

    //
    // Fetch the optional component data.
    //
    b = pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            ComponentId,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(b) {
        if(Oc.InfStringId == -1) {
            OcInf.Handle = NULL;
            b = TRUE;
        } else {
            b = pSetupStringTableGetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                    );
        }
    }

    if(!b) {
        //
        // Strange case, should never get here.
        //
        pSetupFree(HelperContext);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set up the main part of the initialization structure
    // and the HelperRoutines table.
    //
    // Also set up the SetupData part of the initialization structure.
    // This is specific to the environment in which the OC Manager
    // common library is linked, so we call out to a routine that
    // lives elsewhere to do this part.
    //
#ifdef UNICODE
    if(Oc.Flags & OCFLAG_UNICODE) {
        InitDataW.HelperRoutines = HelperRoutinesW;
        InitDataW.OCManagerVersion = OCMANAGER_VERSION;
        InitDataW.ComponentVersion = 0;
        InitDataW.OCInfHandle = OcManager->MasterOcInf;
        InitDataW.ComponentInfHandle = OcInf.Handle;

        InitDataW.HelperRoutines.OcManagerContext = HelperContext;

        OcFillInSetupDataW(&InitDataW.SetupData);

        pu = &InitDataW.ComponentVersion;

        b = pOcInterface(OcManager,&u,ComponentId,NULL,OC_INIT_COMPONENT,0,&InitDataW);
    } else
#endif
    {
        InitDataA.HelperRoutines = HelperRoutinesA;
        InitDataA.OCManagerVersion = OCMANAGER_VERSION;
        InitDataA.ComponentVersion = 0;
        InitDataA.OCInfHandle = OcManager->MasterOcInf;
        InitDataA.ComponentInfHandle = OcInf.Handle;

        InitDataA.HelperRoutines.OcManagerContext = HelperContext;

        OcFillInSetupDataA(&InitDataA.SetupData);

        pu = &InitDataA.ComponentVersion;

        b = pOcInterface(OcManager,&u,ComponentId,NULL,OC_INIT_COMPONENT,0,&InitDataA);
    }

    TRACE(( TEXT("...returns %d, expect version %x\n"), u, *pu ));

    if(b) {
        if(u == NO_ERROR) {
            //
            // Remember the version of the OC Manager that the
            // component expects to be dealing with.
            //
            Oc.ExpectedVersion = *pu;
            Oc.HelperContext = HelperContext;

            pSetupStringTableSetExtraData(
                OcManager->ComponentStringTable,
                ComponentId,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );
        }
    } else {
        u = ERROR_INVALID_PARAMETER;
    }

    if(u != NO_ERROR) {
        pSetupFree(HelperContext);
        pOcRemoveComponent(OcManager, ComponentId, pidInitComponent);
    }

    return(u);
}


UINT
OcInterfaceExtraRoutines(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_EXTRA_ROUTINES interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Win32 error indicating value returned by the component.

--*/

{
    BOOL b;
    UINT u;
    PVOID param2;
    OPTIONAL_COMPONENT Oc;

    TRACE((
        TEXT("OC: OC_EXTRA_ROUTINES Component %s\n"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Fetch the optional component data.
    //
    b = pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            ComponentId,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(!b) {
        //
        // Strange case, should never get here.
        //
        return ERROR_INVALID_PARAMETER;
    }

#ifdef UNICODE
    if (Oc.Flags & OCFLAG_UNICODE)
        b = pOcInterface(OcManager, &u, ComponentId, NULL, OC_EXTRA_ROUTINES, 0, &ExtraRoutinesW);
    else
#endif
        b = pOcInterface(OcManager, &u, ComponentId, NULL, OC_EXTRA_ROUTINES, 0, &ExtraRoutinesA);

    TRACE(( TEXT("...returns %d (retval %s)\n"),
            u,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if (!b)
        u = ERROR_INVALID_PARAMETER;
    if(u != NO_ERROR)
        pOcRemoveComponent(OcManager, ComponentId, pidExtraRoutines);

    return u;
}


SubComponentState
OcInterfaceQueryState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     UINT        WhichState
    )

/*++

Routine Description:

    Sets up and calls OC_QUERY_STATE interface routine.

Arguments:

    OcManager - supplies oc manager context

    ComponentId - supplies the string id for the top-level component
        whose subcomponent is being detected/queried

    Subcomponent - supplies the name of the subcomponent whose
        state is to be detected/queried.

    WhichState - one of OCSELSTATETYPE_ORIGINAL or OCSELSTATETYPE_CURRENT.

Return Value:

    Member of the SubComponentState enum indicating what to do.
    If an error occurs, SubcompUseOcManagerDefault will be returned.
    There is no error return.

--*/

{
    SubComponentState s;

    TRACE((
        TEXT("OCM: OC_QUERY_STATE Comp(%s) Sub(%s)"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(pOcInterface(OcManager,(PUINT)&s,ComponentId,Subcomponent,OC_QUERY_STATE,WhichState,0)) {
        TRACE(( TEXT("...returns TRUE (%d state)\n"), s ));
        if((s != SubcompOn) && (s != SubcompOff)) {
            s = SubcompUseOcManagerDefault;
        }
    } else {
        TRACE(( TEXT("...returns FALSE\n") ));
        s = SubcompUseOcManagerDefault;
    }

    return(s);
}


BOOL
OcInterfaceSetLanguage(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     WORD        LanguageId
    )

/*++

Routine Description:

    Sets up and calls the OC_SET_LANGUAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    LanguageId - supplies the Win32 language id to pass to the component.

Return Value:

    TRUE if the component indicated it could support the language.
    FALSE otherwise.

--*/

{
    LPCTSTR p;
    BOOL b;
    BOOL Result = FALSE;

    TRACE((
        TEXT("OCM: OC_SET_LANGUAGE Comp(%s)LanguageId %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        LanguageId
        ));

    b = pOcInterface(OcManager,&Result,ComponentId,NULL,OC_SET_LANGUAGE,LanguageId,NULL);

    TRACE(( TEXT("...returns %d (retval %s)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Result = FALSE;
    }

    return(Result);
}


HBITMAP
OcInterfaceQueryImage(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_IMAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent for which
        to request the image.

    WhichImage - specifies which image is desired.

    DesiredWidth - specifies desired width, in pixels, of the bitmap.

    DesiredHeight - specifies desired height, in pixels, of the bitmap.

Return Value:

    GDI handle to the bitmap as returned by the component,
    or NULL if an error occurred.

--*/

{
    LPCTSTR p;
    BOOL b;
    HBITMAP Bitmap = NULL;

    TRACE((
        TEXT("OCM: OC_QUERY_IMAGE Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    b = pOcInterface(
            OcManager,
            (PUINT)&Bitmap,
            ComponentId,
            Subcomponent,
            OC_QUERY_IMAGE,
            WhichImage,
            LongToPtr(MAKELONG(DesiredWidth,DesiredHeight))
            );

    TRACE(( TEXT("...returns %s, (retval 0x%08x)\n"),
            b ? TEXT("TRUE") : TEXT("FALSE"),
            (ULONG_PTR)Bitmap ));

    if(!b) {
        Bitmap = NULL;
    }

    return(Bitmap);
}


HBITMAP
OcInterfaceQueryImageEx(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_IMAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent for which
        to request the image.

    WhichImage - specifies which image is desired.

    DesiredWidth - specifies desired width, in pixels, of the bitmap.

    DesiredHeight - specifies desired height, in pixels, of the bitmap.

Return Value:

    GDI handle to the bitmap as returned by the component,
    or NULL if an error occurred.

--*/

{
    LPCTSTR p;
    BOOL b;
    BOOL Result = FALSE;
    HBITMAP Bitmap = NULL;
    OC_QUERY_IMAGE_INFO QueryImageInfo;

    QueryImageInfo.SizeOfStruct = sizeof(QueryImageInfo);
    QueryImageInfo.ComponentInfo = WhichImage;
    QueryImageInfo.DesiredWidth = DesiredWidth;
    QueryImageInfo.DesiredHeight = DesiredHeight;

    TRACE((
        TEXT("OCM: OC_QUERY_IMAGE_EX Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_QUERY_IMAGE_EX,
            (UINT_PTR)&QueryImageInfo,
            &Bitmap
            );

    TRACE(( TEXT("...returns %s, (retval = %s)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Bitmap = NULL;
    }

    return((Result == TRUE) ? Bitmap : NULL);
}


UINT
OcInterfaceRequestPages(
    IN OUT POC_MANAGER           OcManager,
    IN     LONG                  ComponentId,
    IN     WizardPagesType       WhichPages,
    OUT    PSETUP_REQUEST_PAGES *RequestPages
    )

/*++

Routine Description:

    Sets up and calls the OC_REQUEST_PAGES interface function for a
    given component.

    Note that this routine does not enforce any policy regarding whether
    the component is *supposed* to be asked for pages, ordering, etc.
    The caller is expected to do that.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    WhichPages - specifies which set of pages is to be requested.

    RequestPages - on successful return, receives a pointer to
        a SETUP_REQUEST_PAGES structure containing a count and handles
        for returned pages. The caller can free this structure with
        pSetupFree() when it is no longer needed.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT PageCount;
    PSETUP_REQUEST_PAGES pages;
    PVOID p;
    BOOL b;
    UINT ec;

    //
    // Start with room for 10 pages.
    //
    #define INITIAL_PAGE_CAPACITY  10


    TRACE((
        TEXT("OCM: OC_REQUEST_PAGES Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    pages = pSetupMalloc(offsetof(SETUP_REQUEST_PAGES,Pages)
                + (INITIAL_PAGE_CAPACITY * sizeof(HPROPSHEETPAGE)));

    if(!pages) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pages->MaxPages = INITIAL_PAGE_CAPACITY;

    b = pOcInterface(
            OcManager,
            &PageCount,
            ComponentId,
            NULL,
            OC_REQUEST_PAGES,
            WhichPages,
            pages
            );

    if(b && (PageCount != (UINT)(-1)) && (PageCount > INITIAL_PAGE_CAPACITY)) {

        p = pSetupRealloc(
                pages,
                offsetof(SETUP_REQUEST_PAGES,Pages) + (PageCount * sizeof(HPROPSHEETPAGE))
                );

        if(p) {
            pages = p;
        } else {
            pSetupFree(pages);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pages->MaxPages = PageCount;

        b = pOcInterface(
                OcManager,
                &PageCount,
                ComponentId,
                NULL,
                OC_REQUEST_PAGES,
                WhichPages,
                pages
                );
    }

    TRACE(( TEXT("...returns %d pages (retval %s)\n"),
            PageCount,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        pSetupFree(pages);
        return ERROR_CALL_COMPONENT;
    }

    if(PageCount == (UINT)(-1)) {
        ec = GetLastError();
        pSetupFree(pages);
        pOcRemoveComponent(OcManager, ComponentId, pidRequestPages);
        return(ec);
    }

    //
    // Success. Realloc the array down to its final size and return.
    //
    p = pSetupRealloc(
            pages,
            offsetof(SETUP_REQUEST_PAGES,Pages) + (PageCount * sizeof(HPROPSHEETPAGE))
            );

    if(p) {
        pages = p;
        pages->MaxPages = PageCount;
        *RequestPages = pages;
        return(NO_ERROR);
    }

    pSetupFree(pages);
    return(ERROR_NOT_ENOUGH_MEMORY);
}


BOOL
OcInterfaceQuerySkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     OcManagerPage WhichPage
    )

/*++

Routine Description:

    This routine asks a component dll (identified by a top-level
    component's string id) whether it wants to skip displaying
    a particular page that is owned by the oc manager.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of a top-level component

    WhichPage - supplies a value indicating which page oc manager
        is asking the component about.

Return Value:

    Boolean value indicating whether the component wants to skip
    the page.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_QUERY_SKIP_PAGE Component %s Page %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        WhichPage
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_QUERY_SKIP_PAGE,
            WhichPage,
            NULL
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(b) {
        b = Result;
    } else {
        //
        // Error calling component, don't skip page.
        //
        b = FALSE;
    }

    return(b);
}


BOOL
OcInterfaceNeedMedia(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PSOURCE_MEDIA SourceMedia,
    OUT    LPTSTR        NewPath
    )

/*++

Routine Description:

    This routine invokes the OC_NEED_MEDIA interface entry point
    for a (top-level) component.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of top level component

    SourceMedia - supplies setupapi source media description

    NewPath - receives path where files on media are to be found

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_NEED_MEDIA Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_NEED_MEDIA,
            (UINT_PTR)SourceMedia,
            NewPath
            );

    TRACE(( TEXT("...returns %x (retval %s, NewPath %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE"),
            NewPath ? NewPath : TEXT("NULL")
         ));


    if(b) {
        b = Result;
    }

    return(b);
}

BOOL
OcInterfaceFileBusy(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PFILEPATHS    FilePaths,
    OUT    LPTSTR        NewPath
    )

/*++

Routine Description:

    This routine invokes the OC_FILE_BUSY interface entry point
    for a (top-level) component.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of top level component

    SourceMedia - supplies setupapi source media description

    NewPath - receives path where files on media are to be found

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_FILE_BUSY Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_FILE_BUSY,
            (UINT_PTR)FilePaths,
            NewPath
            );

    TRACE(( TEXT("...returns %x (retval %s, newpath %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE"),
            NewPath ? NewPath : TEXT("NULL") ));

    if(b) {
        b = Result;
    }

    return(b);
}


BOOL
OcInterfaceQueryChangeSelState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        Selected,
    IN     UINT        Flags
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_CHANGE_SEL_STATE interface function
    for a given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose
        selection state is potentially to be changed.

    Selected - if TRUE then the proposed new selection state is
        "selected." If FALSE then the proposed new selection state
        is "unselected."

    Flags - supplies misc flags to be passed to the interface routine
        as param2.

Return Value:

    TRUE if the new selection state should be accepted.

--*/

{
    BOOL b;
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUERY_CHANGE_SEL_STATE Comp(%s) Sub(%s) State %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent,
        Selected
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_QUERY_CHANGE_SEL_STATE,
            Selected,
            UlongToPtr((Flags & (OCQ_ACTUAL_SELECTION | OCQ_DEPENDENT_SELECTION)))
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        //
        // If we can't call the component for some reason,
        // allow the new state.
        //
        Result = TRUE;
    }

    return(Result);
}


VOID
OcInterfaceWizardCreated(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     HWND        DialogHandle
    )

/*++

Routine Description:

    Sets up and calls the OC_WIZARD_CREATED interface function
    for a given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    DialogHandle - Supplies wizard dialog handle.

Return Value:

    None.

--*/

{
    UINT Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_WIZARD_CREATED Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    b = pOcInterface(
                OcManager,
                &Result,
                ComponentId,
                NULL,
                OC_WIZARD_CREATED,
                0,
                DialogHandle
                );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

}


UINT
OcInterfaceCalcDiskSpace(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HDSKSPC     DiskSpaceList,
    IN     BOOL        AddingToList
    )

/*++

Routine Description:

    Sets up and calls the OC_CALC_DISK_SPACE interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose files
        are to be added or removed. This may be NULL, such as when
        there is no per-component inf.

    DiskSpaceList - supplies a SETUPAPI disk space list handle.

    AddingToList - if TRUE, the component is being directed to add
        files for the (sub)component. If FALSE, the component is
        being directed to remove files.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;
    UINT Result;

    TRACE((
        TEXT("OCM: OC_CALC_DISK_SPACE Comp(%s) Sub(%s) AddtoList(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent,
        AddingToList ? TEXT("Yes") : TEXT("No")
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_CALC_DISK_SPACE,
            AddingToList,
            DiskSpaceList
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        pOcRemoveComponent(OcManager, ComponentId, pidCalcDiskSpace);
        Result = ERROR_INVALID_PARAMETER;
    }

    return(Result);
}


UINT
OcInterfaceQueueFileOps(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HSPFILEQ    FileQueue
    )

/*++

Routine Description:

    Sets up and calls the OC_QUEUE_FILE_OPS interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose file ops
        are to be queued. This may be NULL, such as when there is no
        per-component inf.

    FileQueue - supplies a SETUPAPI file queue handle.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUEUE_FILE_OPS Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(!pOcInterface(OcManager,&Result,ComponentId,Subcomponent,OC_QUEUE_FILE_OPS,0,FileQueue)) {
        pOcRemoveComponent(OcManager, ComponentId, pidQueueFileOps);
        TRACE(( TEXT("...(returns %x initially) "), Result ));
        Result = ERROR_INVALID_PARAMETER;
    }

    TRACE(( TEXT("...returns %x\n"), Result ));


    return(Result);
}


UINT
OcInterfaceQueryStepCount(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    OUT    PUINT       StepCount
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_STEP_COUNT interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose step count
        is to be determined. This may be NULL, such as when there is no
        per-component inf.

    StepCount - if the routine returns NO_ERROR then StepCount receives
        the number of steps as returned by the component's interface routine.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUERY_STEP_COUNT Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(pOcInterface(OcManager,StepCount,ComponentId,Subcomponent,OC_QUERY_STEP_COUNT,0,0)) {

        if(*StepCount == (UINT)(-1)) {
            Result = GetLastError();
        } else {
            Result = NO_ERROR;
        }
    } else {
        Result = ERROR_INVALID_PARAMETER;
    }

    TRACE(( TEXT("...returns %s (%d steps)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            *StepCount ));

    if (Result != NO_ERROR) {
        pOcRemoveComponent(OcManager, ComponentId, pidQueryStepCount);
    }

    return(Result);
}


UINT
OcInterfaceCompleteInstallation(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        PreQueueCommit
    )

/*++

Routine Description:

    Sets up and calls the OC_ABOUT_TO_COMMIT_QUEUE or
    OC_COMPLETE_INSTALLATION interface function for a given
    component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose
        installation is to be completed. This may be NULL,
        such as when there is no per-component inf.

    PreQueueCommit - if non-0, then OC_ABOUT_TO_COMMIT_QUEUE is sent.
        If 0, then OC_COMPLETE_INSTALLATION is sent.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;
    BOOL b;
    LPTSTR p;
    TCHAR DisplayText[300],FormatString[200];
    OPTIONAL_COMPONENT Oc;
    HELPER_CONTEXT Helper;

    TRACE((
        TEXT("OCM:%s Comp(%s) Sub(%s)..."),
        PreQueueCommit ? TEXT("OC_ABOUT_TO_COMMIT_QUEUE") : TEXT("OC_COMPLETE_INSTALLATION"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    //
    // update the installation text for this component
    //
    __try {
        if (pSetupStringTableGetExtraData(
                    OcManager->ComponentStringTable,
                    ComponentId,
                    &Oc,
                    sizeof(OPTIONAL_COMPONENT)
                    ) && (*Oc.Description != 0)) {
            p = Oc.Description;
        } else if ((p = pSetupStringTableStringFromId(OcManager->ComponentStringTable, ComponentId)) != NULL) {

        } else {
            p = TEXT("Component");
        }


        LoadString(
               MyModuleHandle,
               PreQueueCommit
                ? IDS_CONFIGURE_FORMAT
                : IDS_INSTALL_FORMAT,
               FormatString,
               sizeof(FormatString)/sizeof(TCHAR)
               );
        wsprintf(DisplayText,FormatString,p);

        Helper.OcManager = OcManager;
        Helper.ComponentStringId = ComponentId;

        #ifdef UNICODE
        HelperRoutinesW.SetProgressText(&Helper,DisplayText);
        #else
        HelperRoutinesA.SetProgressText(&Helper,DisplayText);
        #endif

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ERR(( TEXT("OCM: OcCompleteInstallation exception, ec = 0x%08x\n"), GetExceptionCode() ));
    }


    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            PreQueueCommit ? OC_ABOUT_TO_COMMIT_QUEUE : OC_COMPLETE_INSTALLATION,
            0,
            0
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Result = ERROR_INVALID_PARAMETER;
    }

    // Don't shutdown the component if it returns an error.
    // Let them deal with it in OC_QUERY_STATE(SELSTATETYPE_FINAL)

    return(Result);
}


VOID
OcInterfaceCleanup(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_CLEANUP interface function for a
    given component, to inform the component that it is about to be unloaded.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    None.

--*/

{
    UINT DontCare;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_CLEANUP Comp(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));


    b = pOcInterface(OcManager,&DontCare,ComponentId,NULL,OC_CLEANUP,0,0);

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            DontCare,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocpage.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocpage.c

Abstract:

    Routines to run an optional component selection wizard page
    and friends (details, have disk, etc).

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Maximum number of levels in the OC hierarchy.
// 10 is really generous.
//
#define MAX_OC_LEVELS   10

//
// Max number of depenedent components displayed
// in the remove components Msgbox
//
#define MAX_DISPLAY_IDS 10
//
// Window messages.
//
#define WMX_SELSTATECHANGE  (WM_APP+0)

//
// Internal flag to force routines to turn components on or off
//
#define OCQ_FORCE               0x40000000
#define OCQ_SKIPDISKCALC        0x20000000
#define OCQ_COLLECT_NEEDS       0x10000000
#define OCO_COLLECT_NODEPENDENT OCQ_DEPENDENT_SELECTION

//
// Structure used to track parentage within the optional component page.
//
typedef struct _OCPAGE {
    //
    // OC Manager structure.
    //
    POC_MANAGER OcManager;

    //
    // Parent string id.
    //
    LONG ParentStringId;

    //
    // Information about the dialog controls on main wizard page
    // and on "details" pages.
    //
    OC_PAGE_CONTROLS WizardPageControlsInfo;
    OC_PAGE_CONTROLS DetailsPageControlsInfo;

    //
    // Pointer to actual set of controls in use.
    //
    POC_PAGE_CONTROLS ControlsInfo;

    //
    // Disk space list to use when interacting with OC DLLs.
    //
    HDSKSPC DiskSpaceList;

    //
    // Flag indicating whether we've set initial states.
    //
    BOOL AlreadySetInitialStates;

    //
    // Format string for 'space needed' text, fetched from the
    // dialog at init time (something like "%u.%u MB").
    //
    TCHAR SpaceNeededTextFormat[64];

    //
    // Format string for 'x or y components selected' text, fetched from the
    // dialog at init time (something like "%u of %u components selected").
    //
    TCHAR InstalledCountTextFormat[100];

    //
    // String ids that we collect during selection changes to ask
    // the user if it is Ok to change these as well
    //
    PLONG StringIds;
    UINT  StringIdsCount;

    //
    // Values we sock away in case the user cancels at an OC details page,
    // so we can easily restore things.
    //
    HDSKSPC OldDiskSpaceList;
    PVOID OldComponentStrTab;

} OCPAGE, *POCPAGE;


//
// Structure used when enumerating the component string table to populate
// the list box.
//
typedef struct _POPULATE_ENUM_PARAMS {
    //
    // Master context structure.
    //
    POCPAGE OcPage;

    //
    // List box being populated.
    //
    HWND ListBox;

    //
    // String ID of desired parent. This is how we deal with only
    // those subcomponents we actually care about.
    //
    LONG DesiredParent;

} POPULATE_ENUM_PARAMS, *PPOPULATE_ENUM_PARAMS;

WNDPROC OldListBoxProc;

INT_PTR
CALLBACK
pOcPageDlgProc(
              IN HWND   hdlg,
              IN UINT   msg,
              IN WPARAM wParam,
              IN LPARAM lParam
              );

BOOL
pAskUserOkToChange(
                  IN HWND    hDlg,
                  IN LONG    OcStringId,
                  IN POCPAGE OcPage,
                  IN BOOL   TurningOn
                  );

VOID
pOcDrawLineInListBox(
                    IN POCPAGE         OcPage,
                    IN DRAWITEMSTRUCT *Params
                    );

VOID
pOcListBoxHighlightChanged(
                          IN     HWND    hdlg,
                          IN OUT POCPAGE OcPage,
                          IN     HWND    ListBox
                          );

VOID
pOcSetInstalledCountText(
                        IN HWND                hdlg,
                        IN POCPAGE             OcPage,
                        IN POPTIONAL_COMPONENT OptionalComponent,   OPTIONAL
                        IN LONG                OcStringId
                        );

VOID
pOcListBoxChangeSelectionState(
                              IN     HWND    hdlg,
                              IN OUT POCPAGE OcPage,
                              IN     HWND    ListBox
                              );

VOID
pOcInvalidateRectInListBox(
                          IN HWND    ListBox,
                          IN LPCTSTR OptionalComponent    OPTIONAL
                          );

BOOL
pChangeSubcomponentState(
                        IN  POCPAGE OcPage,
                        IN  HWND    ListBox,
                        IN  LONG    SubcomponentStringId,
                        IN  UINT    Pass,
                        IN  UINT    NewState,
                        IN  UINT    Flags
                        );

VOID
pOcUpdateParentSelectionStates(
                              IN POC_MANAGER OcManager,
                              IN HWND        ListBox,             OPTIONAL
                              IN LONG        SubcomponentStringId
                              );

VOID
pOcUpdateSpaceNeededText(
                        IN POCPAGE OcPage,
                        IN HWND    hdlg
                        );

BOOL
pOcIsDiskSpaceOk(
                IN POCPAGE OcPage,
                IN HWND    hdlg
                );

LRESULT
pOcListBoxSubClassWndProc(
                         IN HWND   hwnd,
                         IN UINT   msg,
                         IN WPARAM wParam,
                         IN LPARAM lParam
                         );

BOOL
pOcPagePopulateListBox(
                      IN POCPAGE OcPage,
                      IN HWND    ListBox,
                      IN LONG    DesiredParent
                      );

BOOL
pOcPopulateListBoxStringTableCB(
                               IN PVOID                 StringTable,
                               IN LONG                  StringId,
                               IN LPCTSTR               String,
                               IN POPTIONAL_COMPONENT   OptionalComponent,
                               IN UINT                  OptionalComponentSize,
                               IN PPOPULATE_ENUM_PARAMS Params
                               );

LONG
pOcGetTopLevelComponent(
                       IN POC_MANAGER OcManager,
                       IN LONG        StringId
                       );

VOID
pOcGetMbAndMbTenths(
                   IN  LONGLONG Number,
                   OUT PUINT    MbCount,
                   OUT PUINT    MbTenthsCount
                   );

VOID
pOcSetStates(
            IN OUT POCPAGE OcPage
            );

BOOL
pOcSetStatesStringWorker(
                        IN LONG         StringId,
                        IN UINT         OverRideState,
                        IN POCPAGE      OcPage
                        );

BOOL
pOcSetStatesStringCB(
                    IN PVOID               StringTable,
                    IN LONG                StringId,
                    IN LPCTSTR             String,
                    IN POPTIONAL_COMPONENT Oc,
                    IN UINT                OcSize,
                    IN LPARAM              lParam
                    );

BOOL
pOcSetStatesStringCB2(
                     IN PVOID               StringTable,
                     IN LONG                StringId,
                     IN LPCTSTR             String,
                     IN POPTIONAL_COMPONENT Oc,
                     IN UINT                OcSize,
                     IN LPARAM              lParam
                     );

BOOL
pOcSetNeededComponentState(
                          IN LONG         StringId,
                          IN UINT         OverRideState,
                          IN POCPAGE      OcPage
                          );

UINT
GetComponentState(
                 IN POCPAGE OcPage,
                 IN LONG    StringId
                 );

#ifdef _OC_DBG
VOID
pOcPrintStates(
              IN POCPAGE OcPage
              );
#endif

HPROPSHEETPAGE
OcCreateOcPage(
              IN PVOID             OcManagerContext,
              IN POC_PAGE_CONTROLS WizardPageControlsInfo,
              IN POC_PAGE_CONTROLS DetailsPageControlsInfo
              )

/*++

Routine Description:

    This routine creates the optional component selection page using
    a particular dialog template.

Arguments:

    OcManagerContext - supplies Optional Component Manager context,
        as returned by OcInitialize().

    WizardPageControlsInfo - supplies information about the controls in the
        template for the top-level/wizard page.

    DetailsPageControlsInfo - supplies information about the controls in the
        template for the top-level/wizard page.

Return Value:

    Handle to newly created property sheet page, or NULL if failure
    (assume out of memory in this case).

--*/

{
    PROPSHEETPAGE Page;
    HPROPSHEETPAGE hPage;
    POCPAGE OcPage;
    TCHAR buffer[256];

    //
    // Allocate and initialize the OCPAGE structure.
    //
    OcPage = pSetupMalloc(sizeof(OCPAGE));
    if (!OcPage) {
        goto c0;
    }
    ZeroMemory(OcPage,sizeof(OCPAGE));

    OcPage->OcManager = OcManagerContext;
    OcPage->WizardPageControlsInfo = *WizardPageControlsInfo;
    OcPage->DetailsPageControlsInfo = *DetailsPageControlsInfo;
    OcPage->ControlsInfo = &OcPage->WizardPageControlsInfo;
    OcPage->ParentStringId = -1;

    //
    // Create the disk space list object.
    //
    OcPage->DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_DISALLOW_NEGATIVE_ADJUST);
    if (!OcPage->DiskSpaceList) {
        goto c1;
    }

    //
    // Initialize the property sheet page parameters.
    //
    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT;
    Page.hInstance = WizardPageControlsInfo->TemplateModule;
    Page.pszTemplate = WizardPageControlsInfo->TemplateResource;
    Page.pfnDlgProc = pOcPageDlgProc;
    Page.lParam = (LPARAM)OcPage;
    Page.pszHeaderTitle = NULL;
    Page.pszHeaderSubTitle = NULL;

    if (WizardPageControlsInfo->HeaderText) {
        if (LoadString(Page.hInstance,
                       WizardPageControlsInfo->HeaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERTITLE;
            Page.pszHeaderTitle = _tcsdup(buffer);
        }
    }

    if (WizardPageControlsInfo->SubheaderText) {
        if (LoadString(Page.hInstance,
                       WizardPageControlsInfo->SubheaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERSUBTITLE;
            Page.pszHeaderSubTitle = _tcsdup(buffer);
        }
    }

    //
    // Create the property sheet page itself.
    //
    hPage = CreatePropertySheetPage(&Page);
    if (!hPage) {
        goto c2;
    }

    return (hPage);

    c2:
    if (Page.pszHeaderTitle) {
        free((LPTSTR)Page.pszHeaderTitle);
    }
    if (Page.pszHeaderSubTitle) {
        free((LPTSTR)Page.pszHeaderSubTitle);
    }
    SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
    c1:
    pSetupFree(OcPage);
    c0:
    return (NULL);
}


INT_PTR
CALLBACK
pOcPageDlgProc(
              IN HWND   hdlg,
              IN UINT   msg,
              IN WPARAM wParam,
              IN LPARAM lParam
              )

/*++

Routine Description:

    Dialog procedure for the OC selection page.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return value.

--*/

{
    BOOL b;
    POCPAGE OcPage;
    NMHDR *NotifyParams;
    HWND ListBox;
    HIMAGELIST ImageList;
    static BOOL UserClickedCancelOnThisPage = FALSE;
    MSG msgTemp;
    HCURSOR OldCursor;

    //
    // Get pointer to OcPage data structure. If we haven't processed
    // WM_INITDIALOG yet, then this will be NULL, but it's still pretty
    // convenient to do this here once instead of all over the place below.
    //
    if (OcPage = (POCPAGE)GetWindowLongPtr(hdlg,DWLP_USER)) {
        ListBox = GetDlgItem(hdlg,OcPage->ControlsInfo->ListBox);
    } else {
        ListBox = NULL;
    }
    b = FALSE;

    switch (msg) {

        case WM_INITDIALOG:

            //
            // Get the pointer to the OC Manager context structure and stick it
            // in a window long.
            //
            OcPage = (POCPAGE)((PROPSHEETPAGE *)lParam)->lParam;
            ListBox = GetDlgItem(hdlg,OcPage->ControlsInfo->ListBox);
            SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)OcPage);

            //
            // Subclass the listview.
            //
            OldListBoxProc = (WNDPROC)SetWindowLongPtr(ListBox,GWLP_WNDPROC,(LONG_PTR)pOcListBoxSubClassWndProc);

            //
            // Populate the listbox.
            //
            pOcPagePopulateListBox(OcPage,ListBox,OcPage->ParentStringId);

            //
            // Fetch the space needed text.
            //
            GetDlgItemText(
                          hdlg,
                          OcPage->ControlsInfo->SpaceNeededText,
                          OcPage->SpaceNeededTextFormat,
                          sizeof(OcPage->SpaceNeededTextFormat)/sizeof(TCHAR)
                          );

            GetDlgItemText(
                          hdlg,
                          OcPage->ControlsInfo->InstalledCountText,
                          OcPage->InstalledCountTextFormat,
                          sizeof(OcPage->InstalledCountTextFormat)/sizeof(TCHAR)
                          );

            pOcUpdateSpaceNeededText(OcPage,hdlg);

            //
            // If this has a parent component, then assume it's a details page
            // and set the window title to the description of the parent.
            // If it has no parent, then assume it's the top-level guy and
            // set the instructions text, which is too long for the rc file.
            //
            if (OcPage->ParentStringId == -1) {

                TCHAR Instr[1024];

                FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                             MyModuleHandle,
                             MSG_OC_PAGE_INSTRUCTIONS,
                             0,
                             Instr,
                             sizeof(Instr)/sizeof(TCHAR),
                             NULL
                             );

                SetDlgItemText(hdlg,OcPage->ControlsInfo->InstructionsText,Instr);

            } else {

                OPTIONAL_COMPONENT Oc;

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       OcPage->ParentStringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                SetWindowText(hdlg,Oc.Description);

                //
                // Set component list header
                //
                {
                    TCHAR FormatString[150];
                    TCHAR Title[1000];

                    LoadString(
                              MyModuleHandle,
                              IDS_SUBCOMP_OF,
                              FormatString,
                              sizeof(FormatString)/sizeof(TCHAR)
                              );

                    wsprintf(Title,FormatString,Oc.Description);
                    SetDlgItemText(hdlg,OcPage->ControlsInfo->ComponentHeaderText,Title);
                }
            }

            b = TRUE;
            break;

        case WM_DESTROY:

            if (OcPage && OcPage->ControlsInfo == &OcPage->WizardPageControlsInfo) {

                if (UserClickedCancelOnThisPage) {

                    pOcFreeOcSetupPage(OcPage->OcManager->OcSetupPage);
                    OcPage->OcManager->OcSetupPage = NULL;
                }

                SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
                OcPage->DiskSpaceList = NULL;

                if (OcPage->StringIds) {
                    pSetupFree(OcPage->StringIds);
                    OcPage->StringIds = NULL;
                }

                pSetupFree(OcPage);
                SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)NULL);
                break;
            }

            break;

        case WM_MEASUREITEM:
            //
            // Height is height of text/small icon, plus space for a border.
            //
            {
                HDC hdc;
                SIZE size;
                int cy;

                hdc = GetDC(hdlg);
                if (hdc) {
                   SelectObject(hdc,(HFONT)SendMessage(GetParent(hdlg),WM_GETFONT,0,0));
                   GetTextExtentPoint32(hdc,TEXT("W"),1,&size);
                   ReleaseDC(hdlg,hdc);
                } else {
                   size.cy = 0;
                }

                cy = GetSystemMetrics(SM_CYSMICON);

                ((MEASUREITEMSTRUCT *)lParam)->itemHeight = max(size.cy,cy)
                                                            + (2*GetSystemMetrics(SM_CYBORDER));
            }
            b = TRUE;
            break;

        case WM_DRAWITEM:

            pOcDrawLineInListBox(OcPage,(DRAWITEMSTRUCT *)lParam);
            b = TRUE;
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDOK:

                    if (HIWORD(wParam) == BN_CLICKED) {
                        //
                        // Only possible from details dialog.
                        //
                        EndDialog(hdlg,TRUE);
                        b = TRUE;
                    }
                    break;

                case IDCANCEL:

                    if (HIWORD(wParam) == BN_CLICKED) {
                        //
                        // Only possible from details dialog.
                        //
                        EndDialog(hdlg,FALSE);
                        b = TRUE;
                    }
                    break;

                default:

                    if ((LOWORD(wParam) == OcPage->ControlsInfo->DetailsButton) && (HIWORD(wParam) == BN_CLICKED)) {
                        //
                        // Details button. Fake out WM_INITDIALOG so lParam is right.
                        //
                        OCPAGE NewOcPage;
                        PROPSHEETPAGE Page;
                        int i;

                        SetCursor(LoadCursor(NULL,IDC_WAIT));

                        i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);

                        NewOcPage = *OcPage;
                        NewOcPage.ControlsInfo = &NewOcPage.DetailsPageControlsInfo;
                        NewOcPage.ParentStringId = (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0);

                        //
                        // Preserve the disk space list and component string table
                        // in case the user cancels the details page. Then we can
                        // easily restore things.
                        //
                        OcPage->OldDiskSpaceList = SetupDuplicateDiskSpaceList(
                                                                              NewOcPage.DiskSpaceList,
                                                                              0,0,0
                                                                              );

                        OcPage->OldComponentStrTab = pSetupStringTableDuplicate(
                                                                         OcPage->OcManager->ComponentStringTable
                                                                         );


                        Page.lParam = (LPARAM)&NewOcPage;

                        i = (int)DialogBoxParam(
                                               NewOcPage.DetailsPageControlsInfo.TemplateModule,
                                               NewOcPage.DetailsPageControlsInfo.TemplateResource,
                                               hdlg,
                                               pOcPageDlgProc,
                                               (LPARAM)&Page
                                               );

                        if (i == TRUE) {

                            SetupDestroyDiskSpaceList(OcPage->OldDiskSpaceList);
                            OcPage->DiskSpaceList = NewOcPage.DiskSpaceList;

                            pSetupStringTableDestroy(OcPage->OldComponentStrTab);
                            OcPage->OldComponentStrTab = NULL;

                            //
                            // Force repaint of the listbox, which redraws the checkboxes.
                            //
                            pOcInvalidateRectInListBox(ListBox,NULL);

                            //
                            // Update count of installed subcomponents.
                            //
                            pOcSetInstalledCountText(
                                                    hdlg,
                                                    OcPage,
                                                    NULL,
                                                    (LONG)SendMessage(ListBox,LB_GETITEMDATA,SendMessage(ListBox,LB_GETCURSEL,0,0),0)
                                                    );

                        } else {

                            pSetupStringTableDestroy(OcPage->OcManager->ComponentStringTable);
                            OcPage->OcManager->ComponentStringTable = OcPage->OldComponentStrTab;

                            SetupDestroyDiskSpaceList(NewOcPage.DiskSpaceList);
                            NewOcPage.DiskSpaceList = NULL;
                            OcPage->DiskSpaceList = OcPage->OldDiskSpaceList;
                        }
                        OcPage->OldDiskSpaceList = NULL;
                        OcPage->OldComponentStrTab = NULL;

                        //
                        // It won't hurt anything to do this even in the cancel/failure case,
                        // and this will update the space available.
                        //
                        pOcUpdateSpaceNeededText(OcPage,hdlg);

                        SetCursor(LoadCursor(NULL,IDC_ARROW));

                        b = TRUE;
                    }

                    if (LOWORD(wParam) == OcPage->ControlsInfo->ListBox) {

                        switch (HIWORD(wParam)) {

                            case LBN_DBLCLK:
                                //
                                // Double-click is the same as hitting the details button.
                                // First make sure the details button is enabled.
                                //
                                if (IsWindowEnabled(GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton))) {

                                    SetCursor(LoadCursor(NULL,IDC_WAIT));

                                    PostMessage(
                                               hdlg,
                                               WM_COMMAND,
                                               MAKEWPARAM(OcPage->ControlsInfo->DetailsButton,BN_CLICKED),
                                               (LPARAM)GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton)
                                               );

                                    SetCursor(LoadCursor(NULL,IDC_ARROW));
                                }
                                b = TRUE;
                                break;

                            case LBN_SELCHANGE:

                                SetCursor(LoadCursor(NULL,IDC_WAIT));
                                pOcListBoxHighlightChanged(hdlg,OcPage,ListBox);
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                b = TRUE;
                                break;
                        }
                    }
            }
            break;

        case WM_NOTIFY:

            NotifyParams = (NMHDR *)lParam;

            switch (NotifyParams->code) {

                case PSN_QUERYCANCEL:
                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {

                        b = FALSE;
                        OcPage->OcManager->InternalFlags |= OCMFLAG_USERCANCELED;
                        UserClickedCancelOnThisPage = TRUE;

                        SetWindowLongPtr(
                                        hdlg,
                                        DWLP_MSGRESULT,
                                        b
                                        );
                    }

                    b = TRUE;
                    break;

                case PSN_SETACTIVE:

                    //
                    // Set states based on mode bits, if necessary.
                    //

                    OldCursor = SetCursor(LoadCursor (NULL, IDC_WAIT));

                    if (!OcPage->AlreadySetInitialStates) {
                        if ( OcPage->DiskSpaceList  ) {
                            SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
                            OcPage->DiskSpaceList=NULL;
                        }
                        OcPage->DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_DISALLOW_NEGATIVE_ADJUST);
                        sapiAssert(OcPage->DiskSpaceList);

                        pOcSetStates(OcPage);
                        OcPage->AlreadySetInitialStates = TRUE;
                    }
#ifdef _OC_DBG
                    pOcPrintStates(OcPage);
#endif
                    pOcUpdateSpaceNeededText(OcPage,hdlg);

                    //
                    // we want to empty the message cue to make sure that
                    // people will see this page, and not accidentally click
                    // next because they were antsy
                    //
                    while (PeekMessage(&msgTemp,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
                    while (PeekMessage(&msgTemp,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));
                    SetCursor(OldCursor);

                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    } else {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    }

                    // turn off 'back' button if this is the first page

                    PropSheet_SetWizButtons(GetParent(hdlg),
                                            (OcPage->OcManager->InternalFlags & OCMFLAG_NOPREOCPAGES) ? PSWIZB_NEXT : PSWIZB_BACK | PSWIZB_NEXT);

                    //
                    // See whether any component wants to skip this page
                    // or if we are running in unattended mode.
                    // If so, disallow activation and move to next page;
                    // if not then fall through to allow activation of the page.
                    //
                    if (((OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH)
                         || pOcDoesAnyoneWantToSkipPage(OcPage->OcManager,OcPageComponentHierarchy))
                        && pOcIsDiskSpaceOk(OcPage,hdlg)) {

                        //
                        // Skiping this page...
                        // Set Initial State to false because when we
                        // back up from the next page we will go to the
                        // Previos page.
                        //
                        OcPage->AlreadySetInitialStates = FALSE;
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                    } else {
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    }
                    b = TRUE;
                    break;

                case PSN_WIZNEXT:
                    //
                    // Check disk space. If not OK, stop here.
                    // Otherwise allow advancing.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,pOcIsDiskSpaceOk(OcPage,hdlg) ? 0 : -1);
                    b = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    //
                    // Restore the wizard's cancel button if we removed it earlier
                    //
                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    }
                    // pass through

                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    //
                    // Allow activation/motion.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;
            }
            break;

        case WMX_SELSTATECHANGE:
            //
            // User changed the selection state of an item.
            //
            SetCursor(LoadCursor(NULL,IDC_WAIT));
            pOcListBoxChangeSelectionState(hdlg,OcPage,ListBox);

            pOcSetInstalledCountText(
                                    hdlg,
                                    OcPage,
                                    NULL,
                                    (LONG)SendMessage(ListBox,LB_GETITEMDATA,SendMessage(ListBox,LB_GETCURSEL,0,0),0)
                                    );

            SetCursor(LoadCursor(NULL,IDC_ARROW));
            b = TRUE;

            break;
    }

    return (b);
}


LRESULT
pOcListBoxSubClassWndProc(
                         IN HWND   hwnd,
                         IN UINT   msg,
                         IN WPARAM wParam,
                         IN LPARAM lParam
                         )

/*++

Routine Description:

    Subclass window procecure for listbox controls to handle the following:

    - Highlighting/selection of an item when the user clicks its state icon

    - Spacebar needs to be interpreted as a click on the state icon.

Arguments:

    Standard window procedure arguments.

Return Value:

    Standard window procedure return value.

--*/

{
    int index;
    LRESULT l;

    if (OldListBoxProc == NULL) {
        OutputDebugString(TEXT("Warning: old list box proc is NULL\n"));
        sapiAssert(FALSE && "Warning: old list box proc is NULL\n");
    }

    switch (msg) {

        case WM_LBUTTONDOWN:
            //
            // We want to let the standard list box window proc
            // set selection regardless of what else we do.
            //
            l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);

            //
            // If we're over a state icon, then toggle selection state.
            //
            if (LOWORD(lParam) < GetSystemMetrics(SM_CXSMICON)) {
                if (SendMessage(hwnd, LB_ITEMFROMPOINT, 0, lParam) < SendMessage(hwnd, LB_GETCOUNT, 0, 0)) {
                    PostMessage(GetParent(hwnd),WMX_SELSTATECHANGE,0,0);
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
            //
            // Ignore double-clicks over the state icon.
            //
            if (LOWORD(lParam) < GetSystemMetrics(SM_CXSMICON)) {
                l = 0;
            } else {
                l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            }
            break;

        case WM_KEYDOWN:
            //
            // Catch space bar and treat as a click on the state icon.
            //
            if (wParam == VK_SPACE) {
                PostMessage(GetParent(hwnd),WMX_SELSTATECHANGE,0,0);
                l = 0;
            } else {
                l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            }
            break;

        default:
            //
            // Let the standard listview window proc handle it.
            //
            l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            break;
    }

    return (l);
}


VOID
pOcDrawLineInListBox(
                    IN POCPAGE         OcPage,
                    IN DRAWITEMSTRUCT *Params
                    )

/*++

Routine Description:

    Paint a line in the owner-draw listbox, including a state icon,
    mini-icon, and text.

Arguments:

    OcPage - supplies OC page context.

    Params - supplies the draw-item structure.

Return Value:

    None.

--*/

{
    TCHAR Text[MAXOCDESC];
    TCHAR Text2[128];
    SIZE Size;
    int OldMode;
    DWORD OldBackColor,OldTextColor;
    OPTIONAL_COMPONENT Oc;
    UINT IconId;
    int x;
    UINT Length;
    UINT Mb,Tenths;
    TCHAR Dll[MAX_PATH];
    LPCTSTR pDll,Resource;
    LPTSTR p;

    if ((int)Params->itemID < 0) {
        return;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           (LONG)Params->itemData,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    Length = (UINT)SendMessage(Params->hwndItem,LB_GETTEXT,Params->itemID,(LPARAM)Text),
             GetTextExtentPoint32(Params->hDC,Text,Length,&Size);

    if (Params->itemAction != ODA_FOCUS) {

        OldMode = GetBkMode(Params->hDC);

        OldBackColor = SetBkColor(
                                 Params->hDC,
                                 GetSysColor((Params->itemState & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
                                 );

        OldTextColor = SetTextColor(
                                   Params->hDC,
                                   GetSysColor((Params->itemState & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
                                   );

        //
        // Fill in the background (before mini-icon is drawn!)
        //
        ExtTextOut(Params->hDC,0,0,ETO_OPAQUE,&Params->rcItem,NULL,0,NULL);

        //
        // Draw check box mini-icon.
        //
        switch (Oc.SelectionState) {

            case SELSTATE_NO:
                IconId = 13;
                break;

            case SELSTATE_YES:
                IconId = 12;
                break;

            case SELSTATE_PARTIAL:
                IconId = 25;
                break;

            default:
                IconId = 0;
                break;
        }

        x = SetupDiDrawMiniIcon(
                               Params->hDC,
                               Params->rcItem,
                               IconId,
                               (Params->itemState & ODS_SELECTED) ? MAKELONG(DMI_BKCOLOR, COLOR_HIGHLIGHT) : 0
                               );

        Params->rcItem.left += x;

        //
        // Draw mini-icon for this OC and move string accordingly
        //
        if ((INT)Oc.IconIndex < 0) {
            //
            // Component-supplied miniicon. We query the component dll for the bitmap,
            // which gets added to the mini icon list in setupapi, and thus we can
            // use SetupDiDrawMiniIcon(). Save the index for future use -- we only
            // go through this code path once per subcomponent.
            //
            if (Oc.IconIndex == (UINT)(-2)) {

                pOcFormSuitePath(OcPage->OcManager->SuiteName,Oc.IconDll,Dll);
                pDll = Dll;
                Resource = MAKEINTRESOURCE(_tcstoul(Oc.IconResource,&p,10));
                //
                // If the char that stopped the conversion in _tcstoul is
                // not the terminating nul then the value is not a valid
                // base-10 number; assume it's a name in string form.
                //
                if (*p) {
                    Resource = Oc.IconResource;
                }
            } else {
                pDll = NULL;
                Resource = NULL;
            }

            Oc.IconIndex = pOcCreateComponentSpecificMiniIcon(
                                                             OcPage->OcManager,
                                                             pOcGetTopLevelComponent(OcPage->OcManager,(LONG)Params->itemData),
                                                             pSetupStringTableStringFromId(
                                                                                    OcPage->OcManager->ComponentStringTable,
                                                                                    (LONG)Params->itemData
                                                                                    ),
                                                             x-2,
                                                             GetSystemMetrics(SM_CYSMICON),
                                                             pDll,
                                                             Resource
                                                             );

            pSetupStringTableSetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   (LONG)Params->itemData,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }

        x = SetupDiDrawMiniIcon(
                               Params->hDC,
                               Params->rcItem,
                               Oc.IconIndex,
                               (Params->itemState & ODS_SELECTED) ? MAKELONG(DMI_BKCOLOR, COLOR_HIGHLIGHT) : 0
                               );

        //
        // Draw the text transparently on top of the background
        //
        SetBkMode(Params->hDC,TRANSPARENT);

        ExtTextOut(
                  Params->hDC,
                  x + Params->rcItem.left,
                  Params->rcItem.top + ((Params->rcItem.bottom - Params->rcItem.top) - Size.cy) / 2,
                  0,
                  NULL,
                  Text,
                  Length,
                  NULL
                  );

        pOcGetMbAndMbTenths(Oc.SizeApproximation,&Mb,&Tenths);
        LoadString(MyModuleHandle,IDS_MB_AND_TENTHS,Text2,sizeof(Text2)/sizeof(TCHAR));
        wsprintf(Text,Text2,Mb,locale.DecimalSeparator,Tenths);
        GetTextExtentPoint32(Params->hDC,Text,lstrlen(Text),&Size);
        Params->rcItem.left = Params->rcItem.right - Size.cx - 8;

        ExtTextOut(
                  Params->hDC,
                  Params->rcItem.left,
                  Params->rcItem.top + ((Params->rcItem.bottom - Params->rcItem.top) - Size.cy) / 2,
                  0,
                  NULL,
                  Text,
                  lstrlen(Text),
                  NULL
                  );

        //
        // Restore hdc colors.
        //
        SetBkColor(Params->hDC,OldBackColor);
        SetTextColor(Params->hDC,OldTextColor);
        SetBkMode(Params->hDC,OldMode);
    }

    if ((Params->itemAction == ODA_FOCUS) || (Params->itemState & ODS_FOCUS)) {
        DrawFocusRect(Params->hDC,&Params->rcItem);
    }
}


VOID
pOcListBoxHighlightChanged(
                          IN     HWND    hdlg,
                          IN OUT POCPAGE OcPage,
                          IN     HWND    ListBox
                          )

/*++

Routine Description:

    This routine handles a change in the highlight in the listbox
    control in the oc page. It enables or disables the details button
    based on whether the newly selected component has children
    subcomponents, and changes the tip text.

Arguments:

    hdlg - supplies window handle of OC page

    OcPage - supplies OC page context structure

    ListBox - supplies window handle of list view control in hdlg

Return Value:

    None.

--*/

{
    int i;
    OPTIONAL_COMPONENT Oc;

    //
    // Fetch the optional component data for the highlighted/slected item.
    //
    i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);
    if (i < 0) {
        return;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0),
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // Enable/disable the details button.
    // The selected item's lParam is the string id for the selected item.
    //
    EnableWindow(
                GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton),
                Oc.FirstChildStringId != -1
                );

    //
    // Change the tip text.
    //
    SetDlgItemText(hdlg,OcPage->ControlsInfo->TipText,Oc.Tip);

    //
    // Set up the count of installed subcomponents.
    //
    pOcSetInstalledCountText(hdlg,OcPage,&Oc,0);
}


VOID
pOcSetInstalledCountText(
                        IN HWND                hdlg,
                        IN POCPAGE             OcPage,
                        IN POPTIONAL_COMPONENT OptionalComponent,   OPTIONAL
                        IN LONG                OcStringId
                        )
{
    TCHAR Text[256];
    UINT TotalCount;
    UINT SelectedCount;
    HWND TextWindow;
    DWORD Args[2];
    OPTIONAL_COMPONENT Oc;
    BOOL b;

    if (OptionalComponent) {
        Oc = *OptionalComponent;
    } else {
        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               OcStringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    TextWindow = GetDlgItem(hdlg,OcPage->ControlsInfo->InstalledCountText);

    //
    // Set up the count ("1 of 3 items selected").
    // If this is not a parent component, then hide that text item.
    //
    if (Oc.FirstChildStringId == -1) {
        ShowWindow(TextWindow,SW_HIDE);
    } else {
        ShowWindow(TextWindow,SW_SHOW);

        //
        // Examine all child components to see how many of them are in
        // a selected state (selected or partially selected). We only count
        // direct children, not children of children, etc.
        //
        TotalCount = 0;
        SelectedCount = 0;
        b = TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               Oc.FirstChildStringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        do {
            TotalCount++;
            if (Oc.SelectionState != SELSTATE_NO) {
                SelectedCount++;
            }

            if (Oc.NextSiblingStringId == -1) {
                b = FALSE;
            } else {
                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NextSiblingStringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        } while (b);

        Args[0] = SelectedCount;
        Args[1] = TotalCount;

        //
        // Use FormatMessage since order of numbers could change from
        // language to language; wsprintf isn't good enough.
        //
        FormatMessage(
                     FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     OcPage->InstalledCountTextFormat,
                     0,
                     0,
                     Text,
                     sizeof(Text)/sizeof(TCHAR),
                     (va_list *)Args
                     );

        SetWindowText(TextWindow,Text);
    }
}


VOID
pOcListBoxChangeSelectionState(
                              IN     HWND    hdlg,
                              IN OUT POCPAGE OcPage,
                              IN     HWND    ListBox
                              )

/*++

Routine Description:

    This routine handles a change in selection state for an item.
    Selection state refers to whether the user has placed or cleared
    a checkbox next to an item in the listbox.

    It is assumed that the currently highlighted item is the one
    we want to operate on.

    Selecting/deselecting a component involves calling through the
    installation DLL interface to inform the component's installation DLL
    that a change in selection state has taken place, updating disk space
    requirements, etc.

Arguments:

    hdlg - supplies window handle of OC page

    OcPage - supplies OC page context structure

    ListBox - supplies window handle of listbox control in hdlg

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT Oc;
    BOOL TurningOn;
    DWORD b;
//  UINT  state;
    int i;
    LONG StringId;

    //
    // Fetch the optional component data for the highlighted/slected item.
    //
    i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);
    if (i < 0) {
        return;
    }

    StringId = (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0);

    //
    // Figure out whether the item is being turned on or off.
    // If the state is deselected then we're turning it on.
    // Otherwise it's partially or fully selected and we're turning it off.
    //
    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    TurningOn = (Oc.SelectionState == SELSTATE_NO);
    //
    // Tell the user about needs and validate that he wants to continue.
    // turn on or off the needed components.
    //

    OcPage->StringIds = NULL;
    OcPage->StringIdsCount = 0;

    //
    // Do it.
    //
    if (TurningOn) {
        b = pChangeSubcomponentState(OcPage,
                                     ListBox,
                                     StringId,
                                     1,
                                     SELSTATE_YES,
                                     OCQ_ACTUAL_SELECTION|OCQ_COLLECT_NEEDS);

        if (b) {
            if (b = pAskUserOkToChange(hdlg, StringId, OcPage, TurningOn)) {
                pChangeSubcomponentState(OcPage,
                                         ListBox,
                                         StringId,
                                         2,
                                         SELSTATE_YES,
                                         OCQ_ACTUAL_SELECTION);
            }
        }
    } else {
        b = pChangeSubcomponentState(OcPage,
                                     ListBox,
                                     StringId,
                                     1,
                                     SELSTATE_NO,
                                     OCQ_ACTUAL_SELECTION|OCQ_COLLECT_NEEDS);

        if (b) {
            if (b = pAskUserOkToChange(hdlg, StringId, OcPage, TurningOn)) {
                pChangeSubcomponentState(OcPage,
                                         ListBox,
                                         StringId,
                                         2,
                                         SELSTATE_NO,
                                         OCQ_ACTUAL_SELECTION);
            }
        }
    }

    if (b) {
        //
        // Refresh space needed text.
        //
        pOcUpdateSpaceNeededText(OcPage,hdlg);
    }
}

BOOL
pAskUserOkToChange(
                  IN HWND    hDlg,
                  IN LONG    SubcomponentStringId,
                  IN POCPAGE OcPage,
                  IN BOOL AddComponents
                  )

/*++

Routine Description:

    This routine asks the user if it ok to turn off all needed subcomponents

Arguments:

    hDlg                 - parent dialog handle for the messagebox
    SubcomponentStringId - string id of the component that is being changed
    OcPage        - supplies OC page context info.
    AddComponents - TRUE if we're adding components, FALSE if they are being
                    removed

Return Value:

    Boolean value indicating whether the routine was successful.

--*/

{
    BOOL b = TRUE;
    UINT n;
    UINT Id;
    TCHAR buffer[2024];
    TCHAR caption[256];
    LPCTSTR pArgs;
    OPTIONAL_COMPONENT OptionalComponent;

    //
    // Only display warning if there are dependents or
    // user is removing components
    //
    if ( OcPage->StringIdsCount == 0 || AddComponents ) {
        return b;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT));

    //
    // Format the first Half of the message with the component name
    //
    pArgs = OptionalComponent.Description;

    n = FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_DEPENDENTS1,
                     0,
                     buffer,
                     sizeof(buffer)/sizeof(TCHAR),
                     (va_list *)&pArgs
                     );


    //
    // Add each dependent component to the message
    // Only add as many components as we have room for
    // Leave roon on the end of buffer for the last message.
    //

    for (Id = 0; Id < OcPage->StringIdsCount
        && n < (sizeof(buffer)/sizeof(TCHAR) - 200 ); Id++)  {

        //
        // Only allow so many components in the messgebox, otherwise will
        // be larger then a VGA display
        //
        if ( Id > MAX_DISPLAY_IDS ) {

            n = lstrlen(buffer);
            FormatMessage(
                         FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         MyModuleHandle,
                         MSG_OC_PAGE_DEPENDENTS2,
                         0,
                         &buffer[n],
                         (sizeof(buffer)-n)/sizeof(TCHAR),
                         (va_list *)NULL
                         );
            break;

        }
        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               OcPage->StringIds[Id],
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Skip this item if it is a dependent of the Parent, we can arrive
        // at this situation when dependents of the parent needs other
        // dependents. The Collection code can not detect this.
        //
        if (  OptionalComponent.ParentStringId != SubcomponentStringId ) {
            OPTIONAL_COMPONENT ParentOc;
            UINT ParentId;

            //
            // Scan the parentenal chain until we find a match or run out of parents
            // if there is a match then this dependent is the same dependent as the
            // the target component
            //
            ParentId = OptionalComponent.ParentStringId;
            while (ParentId != -1) {

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       ParentId,
                                       &ParentOc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                if ( ParentOc.ParentStringId == SubcomponentStringId ) {
                    goto skip;
                }
                ParentId = ParentOc.ParentStringId;
            }


            n += lstrlen(OptionalComponent.Description);
            lstrcat(buffer, OptionalComponent.Description);
            lstrcat(buffer, _T("\n"));
            b = FALSE;
            skip:;

        }
    }

    //
    // Continue if any components got by the Parent and dependent screen
    //
    if ( ! b ) {
        //
        // Add the last half of the message
        //
        n = lstrlen(buffer);
        FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_DEPENDENTS3,
                     0,
                     &buffer[n],
                     (sizeof(buffer)-n)/sizeof(TCHAR),
                     (va_list *)NULL
                     );

        //
        // Returns codes from MessageBox()
        //
        *caption = 0;
        LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
        sapiAssert(*caption);

        b = (MessageBox(hDlg,
                        buffer,
                        caption,
                        MB_APPLMODAL | MB_ICONINFORMATION | MB_YESNO) == IDYES);
    }

    if (OcPage->StringIds) {
        pSetupFree(OcPage->StringIds);
        OcPage->StringIds = NULL;
        OcPage->StringIdsCount = 0;

    }
    return b;
}

BOOL
pChangeSubcomponentState(
                        IN  POCPAGE OcPage,
                        IN  HWND    ListBox,
                        IN  LONG    SubcomponentStringId,
                        IN  UINT    Pass,
                        IN  UINT    NewState,
                        IN  UINT    Flags
                        )

/*++

Routine Description:

    This routine turns on or off a subcomponent and all needed subcomponents
    and child subcomponents.

Arguments:

    OcPage - supplies OC page context info.

    SubcomponentStringId - supplies string id for subcomponent to be turned on.

    Pass - Supplies an ordinal value that controls operation of this routine.

        Pass = 1: do not actually turn on the subcomponents, but instead
                  perform a dry-run wherein subcomponent installation DLLs
                  are asked whether they will allow the selection.

        Pass = 2: actually turn on the subcomponents and update the
                  selection state in the optional component structure.

    NewState - indicates the new state, SELSTATE_YES or SELSTATE_NO.

    Flags - supplies misc flags

Return Value:

    Boolean value indicating whether the routine was successful.

--*/

{
    UINT n;
    BOOL b;
    BOOL any;
    LONG l;
    UINT SaveState;
    UINT state;
    OPTIONAL_COMPONENT Subcomponent;
    OPTIONAL_COMPONENT OptionalComponent;

    state = NewState;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If the subcomponent is already in the desired state, do nothing.
    //
    if ((OptionalComponent.SelectionState == NewState)
        || (OptionalComponent.InternalFlags & OCFLAG_STATECHANGE)) {
        return (TRUE);
    }

    //
    // Save the state so we can back out in case of failure,
    // then set the "state change in progress" flag.
    //
    SaveState = OptionalComponent.SelectionState;
    OptionalComponent.InternalFlags |= OCFLAG_STATECHANGE;
    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    // ask the component whether it will allow being turned on.

    b = OcInterfaceQueryChangeSelState(
                                      OcPage->OcManager,
                                      pOcGetTopLevelComponent(OcPage->OcManager,SubcomponentStringId),
                                      pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,SubcomponentStringId),
                                      (NewState != SELSTATE_NO),
                                      (Pass == 1) ? Flags : Flags  & ~(OCQ_ACTUAL_SELECTION)
                                      );

    if (!b)
        goto Backout_ExtraData;

    //
    // Next, turn on needed/needed-by components.
    // and turn off excluded/excluded-by components
    //
    if (NewState == SELSTATE_YES) {
        for (n=0; n<OptionalComponent.NeedsCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.NeedsStringIds[n],
                                        Pass,
                                        NewState,
                                        Flags & ~(OCQ_ACTUAL_SELECTION|OCO_COLLECT_NODEPENDENT));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    } else if (NewState == SELSTATE_NO) {
        for (n=0; n<OptionalComponent.NeededByCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.NeededByStringIds[n],
                                        Pass,
                                        NewState,
                                        Flags & ~(OCQ_ACTUAL_SELECTION|OCO_COLLECT_NODEPENDENT));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    }

    // handle exclusives

    if (NewState != SELSTATE_NO) {
        for (n=0; n<OptionalComponent.ExcludedByCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.ExcludedByStringIds[n],
                                        Pass,
                                        SELSTATE_NO,
                                        Flags & OCO_COLLECT_NODEPENDENT & ~(OCQ_ACTUAL_SELECTION));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
        for (n=0; n<OptionalComponent.ExcludeCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.ExcludeStringIds[n],
                                        Pass,
                                        SELSTATE_NO,
                                        Flags & OCO_COLLECT_NODEPENDENT & ~(OCQ_ACTUAL_SELECTION));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    }

    //
    // Turn off Collect needs if this is the top level selection or the
    // dependent of the toplevel item
    //
    if ( Flags & OCQ_ACTUAL_SELECTION ) {
        Flags |= OCO_COLLECT_NODEPENDENT;
    }

    //
    // Now turn on/off all subcomponents.
    //
    any = (OptionalComponent.FirstChildStringId == -1) ? TRUE : FALSE;
    for (l = OptionalComponent.FirstChildStringId; l != -1; l = Subcomponent.NextSiblingStringId) {
        b = pChangeSubcomponentState(
                                    OcPage,
                                    ListBox,
                                    l,
                                    Pass,
                                    NewState,
                                    Flags  & ~OCQ_ACTUAL_SELECTION);

        if (b)
            any = TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               l,
                               &Subcomponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    // if all changes were rejected - fail

    if (!any) {
        b = FALSE;
        goto Backout_ExtraData;
    }

    // load the return value and do the work

    b = TRUE;

    switch (Pass) {

        case 1:
            //
            // Component says it's ok add this string ID to the list of Dependents
            // Only if the user is making the selection
            //
            if (    (Flags & OCQ_COLLECT_NEEDS)         // Are we checking
                    &&  !(Flags & OCO_COLLECT_NODEPENDENT ) // dependents of the Selection
                    &&  !(Flags & OCQ_ACTUAL_SELECTION )    // The current selections
               ) {

                LONG *p;
                INT count = (INT)OcPage->StringIdsCount;
                BOOL Found = FALSE;

                //
                // Search the list of dependent components
                // Skip if the current component or the parent of the current component
                // All ready is in the list
                //
                while (count--  ) {

                    if ( (OcPage->StringIds[count] == SubcomponentStringId)
                         || (OcPage->StringIds[count] == OptionalComponent.ParentStringId) ){
                        Found = TRUE;
                        break;
                    }
                }

                if ( !Found ) {
                    if (OcPage->StringIds) {
                        p = pSetupRealloc(
                                     OcPage->StringIds,
                                     (OcPage->StringIdsCount+1) * sizeof(LONG)
                                     );
                    } else {
                        OcPage->StringIdsCount = 0;
                        p = pSetupMalloc(sizeof(LONG));
                    }
                    if (p) {
                        OcPage->StringIds = (PVOID)p;
                        OcPage->StringIds[OcPage->StringIdsCount++] = SubcomponentStringId;
                    } else {
                        _LogError(OcPage->OcManager,OcErrLevFatal,MSG_OC_OOM);
                        return (FALSE);
                    }
                }
            }
            goto Backout_ExtraData;
            break;

        case 2:
            //
            // In pass 2, we update the states in the optional component structures
            // and request the component DLL put its stuff on the disk space list.
            // (The component itself is called only for leaf nodes. We do not call
            // down to the subcomponent's DLL for parent components).
            //

            // check one more time to see if the state change wasn't as expected

            if (OptionalComponent.FirstChildStringId != -1)
                state = GetComponentState(OcPage, SubcomponentStringId);

            OptionalComponent.SelectionState = state;
            OptionalComponent.InternalFlags &= ~OCFLAG_STATECHANGE;

            pSetupStringTableSetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   SubcomponentStringId,
                                   &OptionalComponent,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            if (ListBox) {
                pOcInvalidateRectInListBox(ListBox,OptionalComponent.Description);
            }

            if ((OptionalComponent.FirstChildStringId == -1) && !(Flags & OCQ_SKIPDISKCALC)) {

                OcInterfaceCalcDiskSpace(
                                        OcPage->OcManager,
                                        pOcGetTopLevelComponent(OcPage->OcManager,SubcomponentStringId),
                                        pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,SubcomponentStringId),
                                        OcPage->DiskSpaceList,
                                        (NewState != SELSTATE_NO)
                                        );
            }

            pOcUpdateParentSelectionStates(OcPage->OcManager,ListBox,SubcomponentStringId);
            b = TRUE;
            break;
    }

    return (b);

    Backout_ExtraData:

    OptionalComponent.SelectionState = SaveState;
    OptionalComponent.InternalFlags &= ~OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    return (b);
}


VOID
pOcUpdateParentSelectionStates(
                              IN POC_MANAGER OcManager,
                              IN HWND        ListBox,             OPTIONAL
                              IN LONG        SubcomponentStringId
                              )

/*++

Routine Description:

    Examines parent subcomponents of a given component and determines
    the parent states. For example if only some of a parent's children
    are selected, then the parent's state is partially selected.

    Structures are updated and if necessary the relevent items in the
    list box are invalidated to force their checkboxes to be repainted.

Arguments:

    OcManager - supplies OC Manager page context.

    ListBox - supplies window handle of list box.

    SubcomponentStringId - supplies string identifier in the component
        string table, for the subcomponent whose parent(s) state(s) are
        to be checked and updated.

Return Value:

    None.

--*/

{
    UINT Count;
    UINT FullySelectedCount;
    UINT DeselectedCount;
    LONG l,m;
    OPTIONAL_COMPONENT OptionalComponent,Subcomponent;
    BOOL Changed;

    pSetupStringTableGetExtraData(
                           OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );


    for (l = OptionalComponent.ParentStringId; l != -1; l = OptionalComponent.ParentStringId) {

        pSetupStringTableGetExtraData(
                               OcManager->ComponentStringTable,
                               l,
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Examine all children of this parent subcomponent.
        // If all of them are fully selected, then the parent state is
        // fully selected. If all of them are deselected then the parent state
        // is deselected. Any other case means partially selected.
        //
        Count = 0;
        FullySelectedCount = 0;
        DeselectedCount = 0;

        for (m = OptionalComponent.FirstChildStringId; m != -1; m = Subcomponent.NextSiblingStringId) {

            pSetupStringTableGetExtraData(
                                   OcManager->ComponentStringTable,
                                   m,
                                   &Subcomponent,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            //
            // Only count viewable components
            //
            if (!(Subcomponent.InternalFlags & OCFLAG_HIDE)) {
                Count++;

                if (Subcomponent.SelectionState == SELSTATE_YES) {
                    FullySelectedCount++;
                } else {
                    if (Subcomponent.SelectionState == SELSTATE_NO) {
                        DeselectedCount++;
                    }
                }
            }
        }

        if (Count && (Count == FullySelectedCount)) {
            Changed = (OptionalComponent.SelectionState != SELSTATE_YES);
            OptionalComponent.SelectionState = SELSTATE_YES;
        } else {
            if (Count == DeselectedCount) {
                Changed = (OptionalComponent.SelectionState != SELSTATE_NO);
                OptionalComponent.SelectionState = SELSTATE_NO;
            } else {
                Changed = (OptionalComponent.SelectionState != SELSTATE_PARTIAL);
                OptionalComponent.SelectionState = SELSTATE_PARTIAL;
            }
        }

        pSetupStringTableSetExtraData(
                               OcManager->ComponentStringTable,
                               l,
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Force repaint of the list to get the checkbox state right
        // if the state changed and the item is in the current listbox.
        //
        if (Changed && ListBox) {
            pOcInvalidateRectInListBox(ListBox,OptionalComponent.Description);
        }
    }
}


VOID
pOcInvalidateRectInListBox(
                          IN HWND    ListBox,
                          IN LPCTSTR OptionalComponentName    OPTIONAL
                          )
{
    int i;
    RECT Rect;

    if (OptionalComponentName) {

        i = (int)SendMessage(
                            ListBox,
                            LB_FINDSTRINGEXACT,
                            (WPARAM)(-1),
                            (LPARAM)OptionalComponentName
                            );

        if (i >= 0) {
            SendMessage(ListBox,LB_GETITEMRECT,i,(LPARAM)&Rect);
            InvalidateRect(ListBox,&Rect,FALSE);
        }
    } else {
        InvalidateRect(ListBox,NULL,FALSE);
    }
}


VOID
pOcUpdateSpaceNeededText(
                        IN POCPAGE OcPage,
                        IN HWND    hdlg
                        )

/*++

Routine Description:

    Updates the space needed/space available text on the current
    oc page. Assumes that space needed and available refer to the drive
    where the system is installed.

Arguments:

    OcPage - supplies OC page context.

    hdlg - supplies handle to current oc page dialog.

Return Value:

    None.

--*/

{
    TCHAR Text[128];
    LONGLONG Value;
    DWORD ValueMB;
    DWORD ValueMBTenths;
    TCHAR Drive[MAX_PATH];
    BOOL b;
    DWORD spc,bps,freeclus,totalclus;

    // We check the return code of GetWindowsDirectory to make Prefix happy.

    if (0 == GetWindowsDirectory(Drive,MAX_PATH))
        return;


    //
    // Needed first.
    //
    Drive[2] = 0;
    b = SetupQuerySpaceRequiredOnDrive(OcPage->DiskSpaceList,Drive,&Value,0,0);
    if (!b || (Value < 0)) {
        Value = 0;
    }

    pOcGetMbAndMbTenths(Value,&ValueMB,&ValueMBTenths);
    wsprintf(Text,OcPage->SpaceNeededTextFormat,ValueMB,locale.DecimalSeparator,ValueMBTenths);
    SetDlgItemText(hdlg,OcPage->ControlsInfo->SpaceNeededText,Text);

    //
    // Available next.
    //
    Drive[2] = TEXT('\\');
    Drive[3] = 0;

    if (GetDiskFreeSpace(Drive,&spc,&bps,&freeclus,&totalclus)) {
        Value = ((LONGLONG)(spc*bps)) * freeclus;
    } else {
        Value = 0;
    }

    pOcGetMbAndMbTenths(Value,&ValueMB,&ValueMBTenths);
    wsprintf(Text,OcPage->SpaceNeededTextFormat,ValueMB,locale.DecimalSeparator,ValueMBTenths);
    SetDlgItemText(hdlg,OcPage->ControlsInfo->SpaceAvailableText,Text);
}


BOOL
pOcIsDiskSpaceOk(
                IN POCPAGE OcPage,
                IN HWND    hdlg
                )

/*++

Routine Description:

    This routine checks the space required against the space available,
    for the system drive only (that's the only one the user sees on the
    oc page so it's the only one we check here).

    If there's not enough space, a message box is generated.

Arguments:

    OcPage - supplies OC page context structure.

    hdlg - supplies handle to page in oc manager wizard.

Return Value:

    Boolean value indicating whether disk space is sufficient.

--*/

{
    BOOL b;
    TCHAR Drive[3*MAX_PATH];
    TCHAR caption[256];
    LONGLONG FreeSpace,NeededSpace;
    ULARGE_INTEGER freespace,totalspace,unused;
    DWORD spc,bps,freeclus,totclus;
    HMODULE k32;
    BOOL (WINAPI * pGetSpace)(LPCTSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);

    if (!GetWindowsDirectory(Drive,MAX_PATH)) {
       return(FALSE);
    }

    b = FALSE;

    if (k32 = LoadLibrary(TEXT("KERNEL32"))) {

        pGetSpace = (PVOID)GetProcAddress(
                                         k32,
#ifdef UNICODE
                                         "GetDiskFreeSpaceExW"
#else
                                         "GetDiskFreeSpaceExA"
#endif
                                         );

        if (pGetSpace) {
            if (b = pGetSpace(Drive,&freespace,&totalspace,&unused)) {
                FreeSpace = (LONGLONG)freespace.QuadPart;
            }
        }

        FreeLibrary(k32);
    }

    if (!b) {
        Drive[3] = 0;
        if (GetDiskFreeSpace(Drive,&spc,&bps,&freeclus,&totclus)) {
            FreeSpace = (LONGLONG)(spc * bps * (DWORDLONG)freeclus);
        } else {
            FreeSpace = 0;
        }
    }

    Drive[2] = 0;
    b = SetupQuerySpaceRequiredOnDrive(OcPage->DiskSpaceList,Drive,&NeededSpace,0,0);
    if (!b || (NeededSpace < 0)) {
        NeededSpace = 0;
    }

    if (FreeSpace < NeededSpace) {

        spc = (DWORD)(UCHAR)Drive[0];

        FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_NODISKSPACE,
                     0,
                     Drive,
                     sizeof(Drive)/sizeof(TCHAR),
                     (va_list *)&spc
                     );

        OcPage->OcManager->Callbacks.LogError(OcErrLevInfo, Drive, NULL);

        //
        // If Batch mode log the error and ignore
        //
        if ( OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH ) {
            b = TRUE;
        } else {
            *caption = 0;
            LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
            sapiAssert(*caption);

            MessageBox(WizardDialogHandle,
                       Drive,
                       caption,
                       MB_ICONINFORMATION | MB_OK);

            b = FALSE;
        }

    } else {
        b = TRUE;
    }

    return (b);
}


BOOL
pOcPagePopulateListBox(
                      IN POCPAGE OcPage,
                      IN HWND    ListBox,
                      IN LONG    DesiredParent
                      )

/*++

Routine Description:

    This routine add one item to a listbox control for every subcomponent
    that has a given subcomponent as its parent. (In other words it populates
    the listbox for a specific level in the hierarchy.)

    This includes handling the small icons and selection state icons.

    The 0th element is selected.

Arguments:

    OcPage - supplies OC page context structure.

    List - supplies handle to list box control to be populated.

    DesiredParent - supplies string id of subcomponent that is the parent
        of the level we care about. -1 indicates the topmost level.

Return Value:

    Boolean value indicating whether population was successful.
    If FALSE, the caller can assume OOM.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;
    POPULATE_ENUM_PARAMS EnumParams;
    BOOL b;

    //
    // The string table enum callback does the real work.
    //
    EnumParams.OcPage = OcPage;
    EnumParams.ListBox = ListBox;
    EnumParams.DesiredParent = DesiredParent;

    b = pSetupStringTableEnum(
                       OcPage->OcManager->ComponentStringTable,
                       &OptionalComponent,
                       sizeof(OPTIONAL_COMPONENT),
                       (PSTRTAB_ENUM_ROUTINE)pOcPopulateListBoxStringTableCB,
                       (LPARAM)&EnumParams
                       );

    SendMessage(ListBox,LB_SETCURSEL,0,0);
    PostMessage(
               GetParent(ListBox),
               WM_COMMAND,
               MAKEWPARAM(OcPage->ControlsInfo->ListBox,LBN_SELCHANGE),
               (LPARAM)ListBox
               );
    return (b);
}


BOOL
pOcPopulateListBoxStringTableCB(
                               IN PVOID                 StringTable,
                               IN LONG                  StringId,
                               IN LPCTSTR               String,
                               IN POPTIONAL_COMPONENT   OptionalComponent,
                               IN UINT                  OptionalComponentSize,
                               IN PPOPULATE_ENUM_PARAMS Params
                               )

/*++

Routine Description:

    String table enumeration callback routine, used when populating
    the listbox with items for subcomponents that are relevent at
    a given level in the OC hierarchy.

    We check to see whether the parent of the optional component is
    the parent we care about before processing. If so, we add the item
    to the listbox.

Arguments:

    Standard string table enumeration callback routine arguments.

Return Value:

    Boolean value indicating whether enumeration should continue.

--*/

{
    int i;
    BOOL b;

    //
    // If the parent is not the desired parent, nothing to do.
    //
    if ((OptionalComponent->InfStringId == -1)
        || (OptionalComponent->ParentStringId != Params->DesiredParent)
        || (OptionalComponent->InternalFlags & OCFLAG_HIDE)) {
        return (TRUE);
    }

    //
    // Initialize the item structure that tells the listview control
    // what to do.
    //
    b = FALSE;
    i = (int)SendMessage(Params->ListBox,LB_ADDSTRING,0,(LPARAM)OptionalComponent->Description);
    if (i != -1) {
        b = (SendMessage(Params->ListBox,LB_SETITEMDATA,i,StringId) != LB_ERR);
    }

    return (b);
}


LONG
pOcGetTopLevelComponent(
                       IN POC_MANAGER OcManager,
                       IN LONG        StringId
                       )

/*++

Routine Description:

    Given a string id for an optional component subcomponent,
    locate the top-level component for the subcomponent.

    The top-level component is the subcomponent whose parent is -1.

Arguments:

    OcManager - supplies OC Manager context structure.

    StringId - supplies id for subcomponent whose top-level parent is desired.
        Note that StringId may itself be a top-level subcomponent.

Return Value:

    String ID of top-level subcomponent.

--*/

{
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    // if the result is 0, then the component is
    // a top level component without an inf file

    if (!Oc.TopLevelStringId)
        return StringId;
    else
        return Oc.TopLevelStringId;
}


VOID
pOcGetMbAndMbTenths(
                   IN  LONGLONG Number,
                   OUT PUINT    MbCount,
                   OUT PUINT    MbTenthsCount
                   )

/*++

Routine Description:

    This routine figures out how many MB and how many tenths of a MB
    are in a number. These values are properly rounded (not truncated)
    and are based on 1MB = 1024*1024.

Arguments:

    Number - supplies number to be examined.

    MbCount - receives rounded number of MB units in Number.

    MbTenthsCount - receives rounded number of tenths of MB in Number.

Return Value:

    None. MbCount and MbTenthsCount filled are in.

--*/

{
    UINT ValueMB;
    UINT ValueMBTenths;
    UINT ValueMBHundredths;

#define _1MB    (1024*1024)

    //
    // Figure out how many whole 1MB units are in the number.
    //
    ValueMB = (UINT)(Number / _1MB);

    //
    // Figure out how many whole hundredths of 1MB units are in
    // the number. Do it in such a way as to not lose any accuracy.
    // ValueMBHundredths will be 0-99 and ValueMBTenths will be 0-9.
    //
    ValueMBHundredths = (UINT)(((Number % _1MB) * 100) / _1MB);
    ValueMBTenths = ValueMBHundredths / 10;

    //
    // If the one's place in the number of hundredths is >=5,
    // then round up the tenths. That might in turn cause is to round
    // up the the next whole # of MB.
    //
    if ((ValueMBHundredths % 10) >= 5) {
        if (++ValueMBTenths == 10) {
            ValueMBTenths = 0;
            ValueMB++;
        }
    }

    //
    // Done.
    //
    *MbCount = ValueMB;
    *MbTenthsCount = ValueMBTenths;
}


UINT
OcGetUnattendComponentSpec(
                          IN POC_MANAGER OcManager,
                          IN LPCTSTR     Component
                          )
{
    LPCTSTR p;
    LPCTSTR szOn = TEXT("ON");
    LPCTSTR szOff = TEXT("OFF");
    LPCTSTR szDefault = TEXT("DEFAULT");

    extern LPCTSTR szComponents;    // defined in ocmanage.c
    INFCONTEXT InfLine;

    UINT NewState = SubcompUseOcManagerDefault;

    if (SetupFindFirstLine(OcManager->UnattendedInf,szComponents,Component,&InfLine)) {
        //
        // Get State parameter from as the first field
        //
        if (p = pSetupGetField(&InfLine,1)) {
            //
            // Found Something now Decode it
            //
            if (!lstrcmpi(p,szOn)) {
                NewState = SubcompOn;
            } else if (!lstrcmpi(p,szOff)) {
                NewState = SubcompOff;
            } else if (!lstrcmpi(p,szDefault)) {
                NewState = SubcompUseOcManagerDefault;
            } else {
                WRN((TEXT("OcGetUnattendComponentSpec: Unknown Component State(%s)\n"),p));
            }
        }
    }

    return NewState;
}

BOOL
pOcClearStateChange(
                   IN PVOID               StringTable,
                   IN LONG                StringId,
                   IN LPCTSTR             String,
                   IN POPTIONAL_COMPONENT Oc,
                   IN UINT                OcSize,
                   IN LPARAM              lParam
                   )
{
    POCPAGE OcPage = (POCPAGE) lParam;
    int i;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(OcSize);

    //
    // clear the State change flag
    //
    Oc->InternalFlags &= ~OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    return TRUE;

}

VOID
pOcSetStates(
            IN OUT POCPAGE OcPage
            )

/*++

Routine Description:

    Set current states for all components.

    If all components were initially off (indicating that this is a
    first-time install) then this routine initializes the current states
    of each leaf component based on the mode bits gathered from the
    per-component infs.

    Otherwise (not a first-time install) query the dll if any
    to determine the current state.

    No confirmations are sent to component dlls as subcomponents are
    set to the selected state, but we do send the calcdiskspace
    notifications.

Arguments:

    OcPage - supplies current oc context.

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT Oc;
    UINT i;
    UINT tli;
    UINT StringID;

    //
    // Process each top level parent item in the tree
    //
    for ( tli = 0; tli < OcPage->OcManager->TopLevelOcCount; tli++)

        for (i=0; i<OcPage->OcManager->TopLevelParentOcCount; i++) {

            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   OcPage->OcManager->TopLevelParentOcStringIds[i],
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            //
            // Traverse the list in the order defined inf fil
            //
            if ( OcPage->OcManager->TopLevelOcStringIds[tli]
                 == pOcGetTopLevelComponent(OcPage->OcManager,OcPage->OcManager->TopLevelParentOcStringIds[i])) {
                //
                // Call each top level item, Each top level item then will call it's
                // suboridiates and Needs and or Needed by components
                //
                pOcSetStatesStringWorker(OcPage->OcManager->TopLevelParentOcStringIds[i], SubcompUseOcManagerDefault, OcPage );
            }
        }

    //
    // Clear the OCFLAG_STATECHANGE Flag
    //
    pSetupStringTableEnum(
                   OcPage->OcManager->ComponentStringTable,
                   &Oc,
                   sizeof(OPTIONAL_COMPONENT),
                   pOcSetStatesStringCB2,
                   (LPARAM)OcPage
                   );
}


BOOL
pOcSetStatesStringWorker(
                        IN LONG         StringId,
                        IN UINT         OverRideState,
                        IN POCPAGE      OcPage
                        )
{
    OPTIONAL_COMPONENT Oc, Subcomponent;
    LPCTSTR String;
    SubComponentState s;
    UINT NewState;
    UINT l;


    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );


    //
    // Deal only with leaf components.
    //
    if (Oc.FirstChildStringId != -1) {

        //
        // Now turn on all subcomponents.
        //
        for (l = Oc.FirstChildStringId; l != -1; l = Oc.NextSiblingStringId) {

            pOcSetStatesStringWorker( l, OverRideState, OcPage );
            //
            // Get the next Depenend in the list
            //
            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   l,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
        pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);


    } else {
        //
        // Don't process the same node twice
        //
        if (  Oc.InternalFlags & OCFLAG_STATECHANGE ) {
            return TRUE;
        }

        String =  pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId);
        //
        // Not initial install case. Call out to component dll to find out
        // whether state needs to be set.
        //

        s = OcInterfaceQueryState(
                                 OcPage->OcManager,
                                 pOcGetTopLevelComponent(OcPage->OcManager,StringId),String, OCSELSTATETYPE_CURRENT);

        if ( (OcPage->OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL )
        {
            // If Remove all Override all install states and mark the compoent to be
            // removed
            NewState    =    SELSTATE_NO;

        } else {
            //
            // If needs or Needby relationtionships are driving this path
            // OverRideState May be something other then Default
            //
            if ( OverRideState != SubcompUseOcManagerDefault ) {
                s = OverRideState;
            }
            //
            // If the component returned Default and we are in Batch Mode
            // Get the the Spec from the Unattended file
            //
            if ( s == SubcompUseOcManagerDefault
                 && OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH  ){
                s = OcGetUnattendComponentSpec(OcPage->OcManager, String);
            }

            if (s == SubcompUseOcManagerDefault) {
                if (Oc.InternalFlags & (OCFLAG_ANYORIGINALLYON | OCFLAG_ANYORIGINALLYOFF)) {

                    NewState = Oc.OriginalSelectionState;

                } else {

                    if ((1 << (OcPage->OcManager->SetupMode & SETUPMODE_STANDARD_MASK)) & Oc.ModeBits) {
                        //
                        // Allow Modes= lines to act an override condition if it ON
                        //
                        NewState = SELSTATE_YES;
                        s = SubcompOn;
                    } else {
                        NewState = SELSTATE_NO;
                    }
                }
            } else {
                NewState = (s == SubcompOn ? SELSTATE_YES: SELSTATE_NO);
            }
        }

        DBGOUT((
               TEXT("SubComp=%s, Original=%d, Current=%d, NewState=%s\n"),
               String,
               Oc.OriginalSelectionState,
               s,
               (NewState == SELSTATE_YES) ? TEXT("ON") : TEXT("OFF")
               ));

        //
        // Save the current state of the component
        //
        Oc.SelectionState = NewState;
        Oc.InternalFlags |= OCFLAG_STATECHANGE;

        if ( NewState == SELSTATE_YES ) {
            //
            // Make a pass over the Needs
            //
            for (l=0; l<Oc.NeedsCount; l++) {

                if (!pOcSetNeededComponentState( Oc.NeedsStringIds[l], OverRideState, OcPage ))
                    return TRUE;

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeedsStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        }

        pSetupStringTableSetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               StringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        if ( NewState == SELSTATE_YES ) {
            //
            // Make a pass over the Needs
            //
            for (l=0; l<Oc.NeedsCount; l++) {

                pOcSetStatesStringWorker( Oc.NeedsStringIds[l], s, OcPage );

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeedsStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        } else {
            //
            // Make a pass over the NeedsBy - turning off components
            //
            for (l=0; l<Oc.NeededByCount; l++) {
                pOcSetStatesStringWorker( Oc.NeededByStringIds[l], s, OcPage );

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeededByStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        }
    }

    pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);

    return TRUE;
}


BOOL
pOcSetNeededComponentState(
                          IN LONG         StringId,
                          IN UINT         OverRideState,
                          IN POCPAGE      OcPage
                          )
{
    OPTIONAL_COMPONENT Oc, Subcomponent;
    LPCTSTR String;
    SubComponentState s;
    UINT NewState;
    UINT l;
    BOOL b;

    // first find any components this one needs

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    for (l=0; l<Oc.NeedsCount; l++) {

        if (!pOcSetNeededComponentState( Oc.NeedsStringIds[l], OverRideState, OcPage ))
            return TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               Oc.NeedsStringIds[l],
                               &Subcomponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    // now handle this one

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    String =  pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId);

    b = OcInterfaceQueryChangeSelState(
                                      OcPage->OcManager,
                                      pOcGetTopLevelComponent(OcPage->OcManager,StringId),
                                      String,
                                      TRUE,
                                      0
                                      );

    if (b) {
        NewState = SELSTATE_YES;
        s = SubcompOn;
    } else {
        NewState = SELSTATE_NO;
        s = SubcompOff;
    }

    DBGOUT(( TEXT("SubComp=%s, Original=%d, Current=%d, NewState=%s\n"),
             String,
             Oc.OriginalSelectionState,
             s,
             (NewState == SELSTATE_YES) ? TEXT("ON") : TEXT("OFF")
           ));


    //
    // Save the current state of the component
    //
    Oc.SelectionState = NewState;
    Oc.InternalFlags |= OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);

    return b;
}


BOOL
pOcSetStatesStringCB2(
                     IN PVOID               StringTable,
                     IN LONG                StringId,
                     IN LPCTSTR             String,
                     IN POPTIONAL_COMPONENT Oc,
                     IN UINT                OcSize,
                     IN LPARAM              lParam
                     )
{
    POCPAGE OcPage;
    int i;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(OcSize);

    OcPage = (POCPAGE)lParam;
    //
    // clear the State change flag left over from
    // the pOcSetStatesStringWorker
    //
    Oc->InternalFlags &= ~OCFLAG_STATECHANGE;
    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // Deal only with leaf components.
    //
    if (Oc->FirstChildStringId != -1) {
        return (TRUE);
    }

    i = 0;

    if (OcPage->OcManager->InternalFlags & OCMFLAG_ANYORIGINALLYON) {
        //
        // Not initial install case. Deal with disk space based on
        // original state.
        //
        if (Oc->OriginalSelectionState == SELSTATE_YES) {
            if (Oc->SelectionState == SELSTATE_NO) {
                //
                // Turning off what was previously on
                //
                i = 1;
            }
        } else {
            if (Oc->SelectionState == SELSTATE_YES) {
                //
                // Turning on what was previous off
                //
                i = 2;
            }
        }

    } else {
        //
        // Initial install case. If a component is on, do its disk space calc.
        // If a component is off, we assume it's not already there and so
        // we do nothing relating to its disk space requirements.
        //
        if (Oc->SelectionState == SELSTATE_YES) {
            i = 2;
        }
    }

    if (i) {
        OcInterfaceCalcDiskSpace(
                                OcPage->OcManager,
                                pOcGetTopLevelComponent(OcPage->OcManager,StringId),
                                String,
                                OcPage->DiskSpaceList,
                                i-1
                                );
    }

    return (TRUE);
}


BOOL
pOcDoesAnyoneWantToSkipPage(
                           IN OUT POC_MANAGER   OcManager,
                           IN     OcManagerPage WhichPage
                           )
{
    UINT u;

    for (u=0; u<OcManager->TopLevelOcCount; u++) {

        OPTIONAL_COMPONENT Oc;

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[u],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if ((Oc.InternalFlags & OCFLAG_NOQUERYSKIPPAGES) == 0) {

            if (OcInterfaceQuerySkipPage(OcManager,OcManager->TopLevelOcStringIds[u],WhichPage)) {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

UINT
GetComponentState(
                 IN POCPAGE OcPage,
                 IN LONG    StringId
                 )
{
    LONG id;
    UINT rc;
    UINT state;
    SubComponentState s;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    if (Oc.FirstChildStringId == -1)
        return Oc.SelectionState;

    // We have a parent; do all the children

    rc = SELSTATE_INIT;
    for (id = Oc.FirstChildStringId; id != -1; id = Oc.NextSiblingStringId) {

        state = GetComponentState(OcPage, id);

        if (state == SELSTATE_PARTIAL)
            return state;

        if (rc == SELSTATE_INIT)
            rc = state;

        if (rc != state)
            return SELSTATE_PARTIAL;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               id,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    return rc;
}




#ifdef _OC_DBG

VOID
pOcPrintStatesWorker(
                    IN LPCTSTR Offset,
                    IN POCPAGE OcPage,
                    IN LONG    StringId
                    )
{
    SubComponentState s;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    DBGOUT(( TEXT("%32s\n"),
             pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId)
           ));

    //
    // Deal only with leaf components.
    //
    if (Oc.FirstChildStringId == -1) {

        DBGOUT((
               TEXT("  Orignial(%s) Current(%s) ANYORIGINALLYON (%s) Mode (%d)\n"),
               (Oc.OriginalSelectionState  == SELSTATE_YES ? TEXT("Yes") : TEXT("No")),
               (Oc.SelectionState          == SELSTATE_YES ? TEXT("Yes") : TEXT("No")),
               (Oc.InternalFlags & OCFLAG_ANYORIGINALLYON) ? TEXT("TRUE") : TEXT("FALSE"),
               SETUPMODE_STANDARD_MASK & Oc.ModeBits
               ));

    } else {
        //
        // We have a parent; do all the children
        //
        LONG Id;

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            pOcPrintStatesWorker(
                                Offset,
                                OcPage,
                                Id
                                );

            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }
}


VOID
pOcPrintStates(
              IN POCPAGE OcPage
              )
{
    OPTIONAL_COMPONENT Oc;
    DWORD i;

    for (i=0; i<OcPage->OcManager->TopLevelOcCount; i++) {

        pOcPrintStatesWorker(
                            TEXT(" "),
                            OcPage,
                            OcPage->OcManager->TopLevelOcStringIds[i]
                            );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocsetup.c ===
#include "precomp.h"
#pragma hdrstop
#include <stdio.h>


typedef struct _SETUP_PAGE {
    POC_MANAGER OcManager;
    SETUP_PAGE_CONTROLS ControlsInfo;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    UINT StepCount;

    BOOL ForceExternalProgressIndicator;

    PUINT ComponentTickCounts;
    PUINT ComponentMaxTickCounts;
    LONG CurrentTopLevelComponentIndex;

    BOOL AllowCancel;

    HWND hdlg;

    BOOL UserClickedCancel;

    DWORD RefCount;

// Boolean to track NeedMedia requests. NeedMedia notification is sent always by Setupapi the first time it 
// tries to access a new media. We need to figure out if the media is actually inaccessible by checking if setupapi
// called us a second time on the same media. The Boolean is checked and set in NeedMedia and cleared on an
// SPFILENOTIFY_ENDCOPY or SPFILENOTIFY_STARTSUBQUEUE.

    BOOL SecondNeedMedia;

} SETUP_PAGE, *PSETUP_PAGE;

#define WMX_SETUP           (WM_APP+4537)
#define WMX_TICK            (WM_APP+4538)

#define OCSETUPSTATE_INIT       0
#define OCSETUPSTATE_QUEUE      1
#define OCSETUPSTATE_GETSTEP    2
#define OCSETUPSTATE_DOIT       3
#define OCSETUPSTATE_COPYDONE   4
#define OCSETUPSTATE_DONE       100
#define OCSETUPSTATE_COPYABORT  101


typedef struct _GEN_THREAD_PARAMS {
    HWND hdlg;
    PSETUP_PAGE SetupPage;
    BOOL Async;
} GEN_THREAD_PARAMS, *PGEN_THREAD_PARAMS;

TCHAR g_LastFileCopied[MAX_PATH];

#ifdef UNICODE
HANDLE hSfp = NULL;
#endif

HANDLE WorkerThreadHandle = NULL;

INT_PTR
SetupPageDialogProc(
                   IN HWND   hdlg,
                   IN UINT   msg,
                   IN WPARAM wParam,
                   IN LPARAM lParam
                   );

BOOL
pOcSetupInitialize(
                  IN OUT PSETUP_PAGE SetupPage,
                  IN     HWND        hdlg
                  );

VOID
pOcSetupStartWorkerThread(
                         IN OUT PSETUP_PAGE            SetupPage,
                         IN     HWND                   hdlg,
                         IN     LPTHREAD_START_ROUTINE ThreadRoutine
                         );

DWORD
pOcSetupQueue(
             IN PGEN_THREAD_PARAMS Params
             );

UINT
pOcSetupQueueWorker(
                   IN PSETUP_PAGE SetupPage,
                   IN LONG        StringId,
                   IN LONG        TopLevelStringId
                   );

DWORD
pOcSetupGetStepCount(
                    IN PGEN_THREAD_PARAMS Params
                    );

UINT
pOcSetupGetStepCountWorker(
                          IN PSETUP_PAGE SetupPage,
                          IN LONG        StringId,
                          IN LONG        TopLevelStringId
                          );

DWORD
pOcSetupDoIt(
            IN PGEN_THREAD_PARAMS Params
            );

VOID
pOcPreOrPostCommitProcessing(
                            IN OUT PSETUP_PAGE SetupPage,
                            IN     BOOL        PreCommit
                            );

VOID
pOcTopLevelPreOrPostCommitProcessing(
                                    IN PSETUP_PAGE SetupPage,
                                    IN BOOL        PreCommit
                                    );

VOID
pOcSetupDoItWorker(
                  IN PSETUP_PAGE SetupPage,
                  IN LONG        StringId,
                  IN LONG        TopLevelStringId,
                  IN BOOL        PreCommit
                  );

BOOL
pOcMarkUnprocessedStringCB(
                          IN PVOID               StringTable,
                          IN LONG                StringId,
                          IN PCTSTR              String,
                          IN POPTIONAL_COMPONENT Oc,
                          IN UINT                OcSize,
                          IN LPARAM              Unused
                          );

VOID
_pOcExternalProgressIndicator(
                             IN PSETUP_PAGE SetupPage,
                             IN BOOL        ExternalIndicator,
                             IN HWND        hdlg
                             );


extern POC_MANAGER gLastOcManager;
WNDPROC OldProgressProc;

BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
        case PBM_DELTAPOS:
        case PBM_SETRANGE:
        case PBM_SETRANGE32:
        case PBM_STEPIT:
        case PBM_SETPOS:
        case PBM_SETSTEP:
            // If we have a callback, use it.
            if ((gLastOcManager) &&
                (gLastOcManager->Callbacks.BillboardProgressCallback))
            {
                gLastOcManager->Callbacks.BillboardProgressCallback(msg, wParam, lParam);
            }
            break;
    }
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}

HPROPSHEETPAGE
OcCreateSetupPage(
                 IN PVOID                OcManagerContext,
                 IN PSETUP_PAGE_CONTROLS ControlsInfo
                 )

/*++

Routine Description:

    This routine creates the wizard page used for progress and installation
    completion.

Arguments:

    OcManagerContext - supplies OC Manager context returned by OcInitialize.

    ControlsInfo - supplies information about the dialog template and
        control information.

Return Value:

    Handle to property sheet page, or NULL if error (such as out of memory).

--*/

{
    PROPSHEETPAGE Page;
    HPROPSHEETPAGE PageHandle;
    PSETUP_PAGE SetupPage;
    TCHAR buffer[256];
    POC_MANAGER OcManager = (POC_MANAGER)OcManagerContext;

    SetupPage = pSetupMalloc(sizeof(SETUP_PAGE));
    if (!SetupPage) {
        return (NULL);
    }
    ZeroMemory(SetupPage,sizeof(SETUP_PAGE));

    SetupPage->OcManager = OcManagerContext;
    SetupPage->ControlsInfo = *ControlsInfo;
    SetupPage->CurrentTopLevelComponentIndex = -1;
    SetupPage->ForceExternalProgressIndicator = ControlsInfo->ForceExternalProgressIndicator;
    SetupPage->AllowCancel = ControlsInfo->AllowCancel;
    SetupPage->SecondNeedMedia = FALSE;
    InterlockedIncrement( &SetupPage->RefCount );

    SetupPage->ComponentTickCounts = pSetupMalloc(SetupPage->OcManager->TopLevelOcCount * sizeof(UINT));
    if (!SetupPage->ComponentTickCounts) {
        pSetupFree(SetupPage);
        return (NULL);
    }

    SetupPage->ComponentMaxTickCounts = pSetupMalloc(SetupPage->OcManager->TopLevelOcCount * sizeof(UINT));
    if (!SetupPage->ComponentMaxTickCounts) {
        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage);
        return (NULL);
    }

    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT;
    Page.hInstance = ControlsInfo->TemplateModule;
    Page.pszTemplate = ControlsInfo->TemplateResource;
    Page.pfnDlgProc = SetupPageDialogProc;
    Page.lParam = (LPARAM)SetupPage;
    Page.pszHeaderTitle = NULL;
    Page.pszHeaderSubTitle = NULL;

    if (SetupPage->OcManager->SetupPageTitle[0]) {
        Page.dwFlags |= PSP_USETITLE;
        Page.pszTitle = SetupPage->OcManager->SetupPageTitle;
    }

    if (ControlsInfo->HeaderText) {
        if (LoadString(Page.hInstance,
                       ControlsInfo->HeaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERTITLE;
            Page.pszHeaderTitle = _tcsdup(buffer);
        }
    }

    if (ControlsInfo->SubheaderText) {
        if (LoadString(Page.hInstance,
                       ControlsInfo->SubheaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERSUBTITLE;
            Page.pszHeaderSubTitle = _tcsdup(buffer);
        }
    }

    PageHandle = CreatePropertySheetPage(&Page);
    if (!PageHandle) {
        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage->ComponentMaxTickCounts);
        pSetupFree(SetupPage);
        if (Page.pszHeaderTitle) {
            free((LPTSTR)Page.pszHeaderTitle);
        }
        if (Page.pszHeaderSubTitle) {
            free((LPTSTR)Page.pszHeaderSubTitle);
        }
    } else {
        OcManager->OcSetupPage = (PVOID) SetupPage;

    }



    return (PageHandle);
}

VOID
pOcFreeOcSetupPage(
    IN PVOID pSetupPage
    )
/*++

Routine Description:

    This routine frees the setup page when it's not needed anymore.
    The routine uses a ref-count, and the page is only freed when the
    refcount drops to zero.

Arguments:

    SetupPage - pointer to structure to be freed


Return Value:

    None.

--*/
{
    PSETUP_PAGE SetupPage = (PSETUP_PAGE)pSetupPage;

    sapiAssert( SetupPage != NULL );

//    TRACE(( TEXT("pOcFreeOcSetupPage: Refcount = %d\n"), SetupPage->RefCount ));

    if (!InterlockedDecrement( &SetupPage->RefCount )) {

//        TRACE(( TEXT("pOcFreeOcSetupPage: Refcount = 0, freeing SetupPage\n") ));

        if (SetupPage->QueueContext) {
            SetupTermDefaultQueueCallback(SetupPage->QueueContext);
        }
        if (SetupPage->FileQueue) {
            SetupCloseFileQueue(SetupPage->FileQueue);
        }

        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage->ComponentMaxTickCounts);
        pSetupFree(SetupPage);
    }



    return;
}


BOOL
pOcDisableCancel(
    IN HWND hdlg
    )
/*++

Routine Description:

    This routine disables cancelling of ocm setup.

Arguments:

    hdlg - window handle to the ocm dialog


Return Value:

    TRUE if we succeed, else FALSE

--*/
{
    HMENU hMenu;

    //
    // hide the cancel button
    //
    EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);

    if(hMenu = GetSystemMenu(GetParent(hdlg),FALSE)) {
        EnableMenuItem(hMenu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
    }

    return TRUE;


}


VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}


INT_PTR
SetupPageDialogProc(
                   IN HWND   hdlg,
                   IN UINT   msg,
                   IN WPARAM wParam,
                   IN LPARAM lParam
                   )
{
    BOOL b;
    NMHDR *NotifyParams;
    PSETUP_PAGE SetupPage;
    DWORD Timeout;
    DWORD WaitProcStatus;
    BOOL KeepWaiting = TRUE;

    //
    // Get pointer to SetupPage data structure. If we haven't processed
    // WM_INITDIALOG yet, then this will be NULL, but it's still pretty
    // convenient to do this here once instead of all over the place below.
    //
    SetupPage = (PSETUP_PAGE)GetWindowLongPtr(hdlg,DWLP_USER);
    b = FALSE;

    switch (msg) {

        case WM_INITDIALOG:
            //
            // Get the pointer to the Setup Page context structure and stick it
            // in a window long.
            //
            SetWindowLongPtr(hdlg,DWLP_USER,((PROPSHEETPAGE *)lParam)->lParam);
            b = TRUE;
            //
            // eat any extra press button messages
            // this is necessary because netsetup is broken
            // it is posting an extra PSM_PRESSBUTTON message
            // to the wizard.
            //
            {
                MSG msg;
                HWND hwnd=GetParent(hdlg);
                while (PeekMessage(&msg,hwnd,PSM_PRESSBUTTON,PSM_PRESSBUTTON,PM_REMOVE)){}
            }

            break;

        case WM_SYSCOMMAND:
            if (!SetupPage->AllowCancel && wParam == SC_CLOSE) {
                return TRUE;
            }

            b = FALSE;
            break;
        case WM_DESTROY:

            PumpMessageQueue();

            if (WorkerThreadHandle) {

                BOOL Done = FALSE;

                do{

                    switch (MsgWaitForMultipleObjects( 1, &WorkerThreadHandle, FALSE, 60*1000*20, QS_ALLINPUT)){
                    
                    case WAIT_OBJECT_0+1:
                        //
                        // Messages in the queue.
                        //
                        PumpMessageQueue();
                        break;
                    
                    case WAIT_TIMEOUT:
                    case WAIT_OBJECT_0:
                    default:
                        Done = TRUE;
                        break;
                    }

                }while( !Done );

                CloseHandle( WorkerThreadHandle );
            }

            if (SetupPage) {

                pOcFreeOcSetupPage( SetupPage );

            }

            SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)NULL);

            break;

        case WM_NOTIFY:

            NotifyParams = (NMHDR *)lParam;
            switch (NotifyParams->code) {

                case PSN_SETACTIVE:
#ifdef UNICODE
                    if (SetupPage->OcManager->Callbacks.SetupPerfData)
                        SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",L"OCSetup");
#endif
                    // activate the cancel button accordingly

                    if (SetupPage->AllowCancel) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    } else {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    }

                    if (SetupPage->OcManager->Callbacks.ShowHideWizardPage)
                    {
                        // If we have a callback, hide the wizard.
                        SetupPage->OcManager->Callbacks.ShowHideWizardPage(FALSE);
                    }
                    OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                                                                GWLP_WNDPROC,
                                                                (LONG_PTR)NewProgessProc);

                    //
                    // Post a message that causes us to start the installation process.
                    //
                    PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_INIT,0);

                    //
                    // Accept activation.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    //
                    // Restore the wizard's cancel button if we removed it earlier
                    //
                    if (!SetupPage->AllowCancel) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    }

                    //
                    // Accept deactivation.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;

                case PSN_QUERYCANCEL:

                    if (!SetupPage->AllowCancel) {
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
                        return(TRUE);
                    }
                    if ( (SetupPage->OcManager->InternalFlags & OCMFLAG_FILEABORT )
                         || (OcHelperConfirmCancel(hdlg) )){
                        b = TRUE;

                        SetupPage->OcManager->InternalFlags |= OCMFLAG_USERCANCELED;
                        SetupPage->UserClickedCancel = TRUE;

                    }

                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,!b);
                    b = TRUE;
                    break;
            }
            break;

        case WMX_SETUP:

            switch (wParam) {

                case OCSETUPSTATE_INIT:
                    //
                    // Initialize.
                    //
                    if (SetupPage->ForceExternalProgressIndicator) {
                        _pOcExternalProgressIndicator(SetupPage,TRUE,hdlg);
                    }

                    PropSheet_SetWizButtons(GetParent(hdlg),0);

                    //
                    // If this a remove all, disable the cancel button early
                    //
                    if ((SetupPage->OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL) {
                        if (!SetupPage->AllowCancel) {
                            EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                            ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        }
                    }

                    if (pOcSetupInitialize(SetupPage,hdlg)) {
                        PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_QUEUE,0);
                    } else {
                        PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_COPYABORT,0);
                    }
                    break;

                case OCSETUPSTATE_QUEUE:
                    //
                    // Queue files for installation.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupQueue);
                    break;

                case OCSETUPSTATE_GETSTEP:
                    //
                    // Figure out step counts.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupGetStepCount);
                    break;

                case OCSETUPSTATE_DOIT:

                    //
                    // Quick init of the gas guage here, because the file queue could be
                    // empty, in which case we never get WMX_TICK with wParam=0.
                    //
                    SendDlgItemMessage(
                                      hdlg,
                                      SetupPage->ControlsInfo.ProgressBar,
                                      PBM_SETRANGE,
                                      0,
                                      MAKELPARAM(0,SetupPage->StepCount)
                                      );
                    SendDlgItemMessage(
                                      hdlg,
                                      SetupPage->ControlsInfo.ProgressBar,
                                      PBM_SETPOS,
                                      0,
                                      0
                                      );

                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    //
                    // Commit the file queue and let the OCs install themselves.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupDoIt);
                    break;


                    //
                    // Unrecoverable error in copyfile phase, abort the setup
                    //
                case OCSETUPSTATE_COPYABORT:

                    SetupPage->OcManager->InternalFlags |= OCMFLAG_FILEABORT;

                    if (SetupPage->AllowCancel
                        && SetupPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    } else {
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
                    }

                    break;


                case OCSETUPSTATE_COPYDONE:
                    //
                    // Get rid of the wizard's cancel button
                    //

                    //
                    // AndrewR -- we've already committed the file queue
                    // at this point, so we should not allow the user to cancel
                    // (since:
                    //  a) in an uninstall scenario the file state and
                    // configuration state will be out of sync
                    //  b) we don't call all of the OC components to let them know
                    // about the cancel event, and we don't want only some of the
                    // components to get a complete installation callback
                    //
                    //if(!SetupPage->AllowCancel) {
                    SetupPage->AllowCancel = FALSE;
                    pOcDisableCancel(hdlg);

                    // }
                    break;

                case OCSETUPSTATE_DONE:
                    //
                    // Done. Advance to next page in wizard.
                    //
                    PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
#ifdef UNICODE
                    if (SetupPage->OcManager->Callbacks.SetupPerfData)
                        SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",L"OCSetup");
#endif

                    // un-subclass the progress bar. just in case
                    SetWindowLongPtr(GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                                     GWLP_WNDPROC,
                                     (LONG_PTR)OldProgressProc);
                    //
                    // Clear user canceled flag,
                    //
                    SetupPage->OcManager->InternalFlags &= ~ OCMFLAG_USERCANCELED;
                    break;
            }

            b = TRUE;
            break;

        case WMX_TICK:

            switch (wParam) {

                case 0:
                    //
                    // The setup API queue commit routine is telling us how many 
                    // files are to be copied. We do nothing in this case, as we
                    // set the progress guage manually so that we also count
                    // delete operations in our progress guage.
                    //
                    break;

                case 1:
                    //
                    // File copied.
                    //
                    SendDlgItemMessage(hdlg,SetupPage->ControlsInfo.ProgressBar,PBM_DELTAPOS,1,0);
                    break;

                case 10:

                    //
                    // We got our private message telling us how many files are
                    // to be processed.  see comments above in the 0 case.
                    //
                    SendDlgItemMessage(
                                          hdlg,
                                          SetupPage->ControlsInfo.ProgressBar,
                                          PBM_SETRANGE,
                                          0,
                                          MAKELPARAM(0,lParam)
                                          );
                    break;

                case 500:
                    //
                    // Incoming tick request from component dll. Don't allow a broken component dll
                    // to tick the gauge more than it said it wanted to.
                    //
                    if ((SetupPage->CurrentTopLevelComponentIndex != -1)
                        && (SetupPage->ComponentTickCounts[SetupPage->CurrentTopLevelComponentIndex]
                            < SetupPage->ComponentMaxTickCounts[SetupPage->CurrentTopLevelComponentIndex])) {

                        SetupPage->ComponentTickCounts[SetupPage->CurrentTopLevelComponentIndex]++;

                        SendDlgItemMessage(hdlg,SetupPage->ControlsInfo.ProgressBar,PBM_DELTAPOS,1,0);
                    }
                    break;
            }

            b = TRUE;
            break;
    }

    return (b);
}


VOID
pOcTickSetupGauge(
                 IN POC_MANAGER OcManager
                 )

/*++

Routine Description:

    The tick gauge OC helper/callback routine calls this routine.

Arguments:

    OcManager - supplies OC Manager context.

Return Value:

    None.

--*/

{
    //
    // The ProgressTextWindow is non-NULL if we are in
    // the installation-completion phase.
    //
    if (OcManager->ProgressTextWindow) {
        SendMessage(GetParent(OcManager->ProgressTextWindow),WMX_TICK,500,0);
    }
}


BOOL
pOcSetupInitialize(
                  IN OUT PSETUP_PAGE SetupPage,
                  IN     HWND        hdlg
                  )
{
    TCHAR Text[128];

    LoadString(MyModuleHandle,IDS_INITIALIZING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(hdlg,SetupPage->ControlsInfo.ProgressText,Text);

    // If, update the text on the billboard for the progress bar.
    if (SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }

    //
    // Create a setup file queue.
    //
    SetupPage->FileQueue = SetupOpenFileQueue();
    if (SetupPage->FileQueue == INVALID_HANDLE_VALUE) {

        _LogError(SetupPage->OcManager,OcErrLevFatal,MSG_OC_OOM);

        SetupPage->FileQueue = NULL;
        return (FALSE);
    }

    SetupPage->QueueContext = SetupInitDefaultQueueCallbackEx(hdlg,hdlg,WMX_TICK,0,0);
    if (!SetupPage->QueueContext) {

        _LogError(SetupPage->OcManager,OcErrLevFatal,MSG_OC_OOM);

        SetupCloseFileQueue(SetupPage->FileQueue);
        SetupPage->FileQueue = NULL;
        return (FALSE);
    }

    return (TRUE);
}


VOID
pOcSetupStartWorkerThread(
                         IN OUT PSETUP_PAGE            SetupPage,
                         IN     HWND                   hdlg,
                         IN     LPTHREAD_START_ROUTINE ThreadRoutine
                         )
{
    PGEN_THREAD_PARAMS pParams;
    GEN_THREAD_PARAMS Params;
    HANDLE h;
    DWORD id;

    if (WorkerThreadHandle) {
        CloseHandle( WorkerThreadHandle );
        WorkerThreadHandle = NULL;
    }

    if (pParams = pSetupMalloc(sizeof(GEN_THREAD_PARAMS))) {

        pParams->SetupPage = SetupPage;
        pParams->SetupPage->hdlg = hdlg;
        pParams->hdlg = hdlg;
        pParams->Async = TRUE;

        h = CreateThread(NULL,0,ThreadRoutine,pParams,0,&id);
        if (!h) {
            pSetupFree(pParams);
        } else {
            WorkerThreadHandle = h;
        }

    } else {
        h = NULL;
    }

    if (!h) {

        //
        // Just try it synchronously.
        //
        Params.SetupPage = SetupPage;
        Params.hdlg = hdlg;
        Params.Async = FALSE;
        ThreadRoutine(&Params);
    }
}

//
// a debugging routine that makes it easy to cancel at any phase of setup
//
/*
VOID CancelRoutine(
    VOID
    )
{
    static int i = 0;
    TCHAR dbg[100];

    wsprintf( dbg, TEXT("cancel routine iteration number %i \n"), i);
    OutputDebugString( dbg );

    OutputDebugString( TEXT(" waiting 5 seconds for cancel ... \n" ));
    Sleep( 1000 * 5 );
    OutputDebugString( TEXT(" done waiting for cancel ... \n" ));

    i++;
}
*/

BOOL
CheckForQueueCancel(
                   PSETUP_PAGE SetupPage
                   )
{
    BOOL bRet;

    //CancelRoutine();

    bRet = SetupPage->UserClickedCancel;

    return (bRet);
}

DWORD
pOcSetupQueue(
             IN PGEN_THREAD_PARAMS Params
             )
{
    UINT Err;
    unsigned i,child;
    OPTIONAL_COMPONENT Oc;
    TCHAR Text[128];
    DWORD RetVal;

    InterlockedIncrement( &Params->SetupPage->RefCount );

    LoadString(MyModuleHandle,IDS_BUILDINGCOPYLIST,Text,sizeof(Text)/sizeof(TCHAR));

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);

    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
#endif
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);

    if (CheckForQueueCancel(Params->SetupPage)) {
        RetVal = NO_ERROR;
        goto exit;
    }

    //
    // Handle each component.
    //
    for (i=0; i<Params->SetupPage->OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
                               Params->SetupPage->OcManager->ComponentStringTable,
                               Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Call the component dll once for the entire component.
        //
        Err = OcInterfaceQueueFileOps(
                                     Params->SetupPage->OcManager,
                                     Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                                     NULL,
                                     Params->SetupPage->FileQueue
                                     );

        if (Err != NO_ERROR) {
            //
            // Notify user and continue.
            //
            _LogError(
                     Params->SetupPage->OcManager,
                     OcErrLevError,
                     MSG_OC_CANT_QUEUE_FILES,
                     Oc.Description,
                     Err
                     );
        }

        if (CheckForQueueCancel(Params->SetupPage)) {
            RetVal = NO_ERROR;
            goto exit;
        }

        //
        // Process each top level parent item in the tree
        //
        for (child=0; child<Params->SetupPage->OcManager->TopLevelParentOcCount; child++) {

            Err = pOcSetupQueueWorker(
                                     Params->SetupPage,
                                     Params->SetupPage->OcManager->TopLevelParentOcStringIds[child],
                                     Params->SetupPage->OcManager->TopLevelOcStringIds[i]
                                     );

            if (Err != NO_ERROR) {
                //
                // Notification is handled in the worker routine so nothing to do here.
                //
            }
        }

        if (CheckForQueueCancel(Params->SetupPage)) {
            RetVal = NO_ERROR;
            goto exit;
        }

    }

    if (CheckForQueueCancel(Params->SetupPage)) {
        RetVal = NO_ERROR;
        goto exit;
    }

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_GETSTEP,0);

exit:

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }

    return (RetVal);
}


UINT
pOcSetupQueueWorker(
                   IN PSETUP_PAGE SetupPage,
                   IN LONG        StringId,
                   IN LONG        TopLevelStringId
                   )
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If it's a child, call the component dll.
    // If it's a parent, then spin through its children.
    //
    if (Oc.FirstChildStringId == -1) {

        if (TopLevelStringId == pOcGetTopLevelComponent(SetupPage->OcManager,StringId)) {

            Err = OcInterfaceQueueFileOps(
                                         SetupPage->OcManager,
                                         pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                         pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                         SetupPage->FileQueue
                                         );

            if (Err != NO_ERROR) {
                //
                // Notify user and continue.
                //
                _LogError(
                         SetupPage->OcManager,
                         OcErrLevError,
                         MSG_OC_CANT_QUEUE_FILES,
                         Oc.Description,
                         Err
                         );
            }
        }
    } else {

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            Err = pOcSetupQueueWorker(SetupPage,Id,TopLevelStringId);
            if (Err != NO_ERROR) {
                //
                // Notification is handled in the worker routine so nothing to do here.
                //
            }

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }

    return (NO_ERROR);
}


DWORD
pOcSetupGetStepCount(
                    IN PGEN_THREAD_PARAMS Params
                    )
{
    UINT Err;
    unsigned i,child;
    OPTIONAL_COMPONENT Oc;
    UINT StepCount;
    TCHAR Text[128];
    UINT Count;

    InterlockedIncrement( &Params->SetupPage->RefCount );

    LoadString(MyModuleHandle,IDS_PREPARING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);
#endif

    Params->SetupPage->StepCount = 0;

    //
    // Handle each component.
    //
    for (i=0; i<Params->SetupPage->OcManager->TopLevelOcCount; i++) {

        //
        // Call the component dll once for the entire component.
        // Ignore any error. Later we call per-subcomponent and we'll
        // assume that any component that gives us an error has 1 step.
        //
        Err = OcInterfaceQueryStepCount(
                                       Params->SetupPage->OcManager,
                                       Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                                       NULL,
                                       &Count
                                       );

        StepCount = ((Err == NO_ERROR) ? Count : 0);

        //
        // For each top level parent item in the tree find all the children
        // that belong to this component
        //
        for (child=0; child<Params->SetupPage->OcManager->TopLevelParentOcCount; child++) {

            //
            // Now call the component dll for each child subcomponent.
            //
            StepCount += pOcSetupGetStepCountWorker(
                                                   Params->SetupPage,
                                                   Params->SetupPage->OcManager->TopLevelParentOcStringIds[child],
                                                   Params->SetupPage->OcManager->TopLevelOcStringIds[i]
                                                   );
        }

        if (!StepCount) {
            //
            // Make sure each component has at least one step.
            //
            StepCount = 1;
        }

        Params->SetupPage->StepCount += StepCount;
        Params->SetupPage->ComponentTickCounts[i] = 0;
        Params->SetupPage->ComponentMaxTickCounts[i] = StepCount;
    }

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_DOIT,0);

exit:

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }


    return (0);
}


UINT
pOcSetupGetStepCountWorker(
                          IN PSETUP_PAGE SetupPage,
                          IN LONG        StringId,
                          IN LONG        TopLevelStringId
                          )
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;
    UINT Count;
    UINT TotalCount;

    TotalCount = 0;
    Count = 0;

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If it's a child, call the component dll.
    // If it's a parent, then spin through its children.
    //
    if (Oc.FirstChildStringId == -1) {

        //
        // Only call the leaf node if the top level component matches
        //
        if (TopLevelStringId == pOcGetTopLevelComponent(SetupPage->OcManager,StringId)) {

            Err = OcInterfaceQueryStepCount(
                                           SetupPage->OcManager,
                                           pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                           pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                           &Count
                                           );

            if (Err == NO_ERROR) {
                TotalCount = Count;
            }
        }

    } else {

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            TotalCount += pOcSetupGetStepCountWorker(SetupPage,Id,TopLevelStringId);

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }

    return (TotalCount);
}

BOOL
pOcSetRenamesFlag(
                 IN POC_MANAGER OcManager
                 )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;
#ifdef UNICODE
    rslt = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                       0,
                       KEY_SET_VALUE,
                       &hKey);

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = 1;
        rslt = RegSetValueEx(
                            hKey,
                            OC_ALLOWRENAME,
                            0,
                            REG_DWORD,
                            (LPBYTE)&Value,
                            sizeof(DWORD));

        RegCloseKey(hKey);

        if (rslt != ERROR_SUCCESS) {
            TRACE(( TEXT("couldn't RegSetValueEx, ec = %d\n"), rslt ));
        }

    } else {
        TRACE(( TEXT("couldn't RegOpenKeyEx, ec = %d\n"), rslt ));
    }
#endif

    return (rslt == ERROR_SUCCESS);

}

BOOL
pOcAttemptQueueAbort(
                    IN UINT Notification,
                    IN PUINT rc
                    )
{
    //
    // user has asked to abort installation.  We need to hand this request to
    // setupapi, but setupapi only handles this request from certain
    //  notifications
    //

    BOOL bHandled = FALSE;


    switch (Notification) {
        case SPFILENOTIFY_STARTQUEUE:
        case SPFILENOTIFY_STARTSUBQUEUE:
            SetLastError(ERROR_CANCELLED);
            *rc = 0;
            bHandled = TRUE;
            break;

        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTBACKUP:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
        case SPFILENOTIFY_NEEDMEDIA:
        case SPFILENOTIFY_COPYERROR:
        case SPFILENOTIFY_DELETEERROR:
        case SPFILENOTIFY_RENAMEERROR:
        case SPFILENOTIFY_BACKUPERROR:
            SetLastError(ERROR_CANCELLED);
            *rc = FILEOP_ABORT;
            bHandled = TRUE;
            break;
        case SPFILENOTIFY_FILEEXTRACTED:
        case SPFILENOTIFY_NEEDNEWCABINET:
        case SPFILENOTIFY_QUEUESCAN:
            SetLastError(ERROR_CANCELLED);
            *rc = ERROR_CANCELLED;
            bHandled = TRUE;
            break;
    };

    return (bHandled);

}

UINT
OcManagerQueueCallback1(
                       IN PVOID Context,
                       IN UINT  Notification,
                       IN UINT_PTR Param1,
                       IN UINT_PTR Param2
                       )
{
    PSETUP_PAGE SetupPage = Context;
    UINT i;
    BOOL b;
    TCHAR Text[MAX_PATH*2];
    PFILEPATHS pFile = (PFILEPATHS) Param1;
    PSOURCE_MEDIA sm = (PSOURCE_MEDIA)Param1;
    static BOOL UserClickedCancel;
    UINT rc = 0;
    UINT retval;

    //
    // We handle the user cancelling at the beginning of the queue callback.
    // If the user has cancelled then we don't execute any code, we just return
    // until we get a callback that allows us to cancel.
    //
    // There is a window in this code where the user might cancel after we
    // check for cancelling but before the queue callback code executes.  If we fall into
    // the WM_DESTROY block in our window proc when this occurs, we cannot send any more
    // messages to our window.  Use PostMessage below to guard against that.

    top:
    if (UserClickedCancel) {
        pOcAttemptQueueAbort(Notification,&rc);
        return (rc);
    }

    if (SetupPage->UserClickedCancel) {
        UserClickedCancel = TRUE;
    }

    if (UserClickedCancel) {
        goto top;
    }

    switch (Notification) {

        case SPFILENOTIFY_STARTSUBQUEUE:
            //
            // Tell the user what's going on.
            //
            switch (Param1) {
                case FILEOP_DELETE:
                    i = IDS_DELETING;
                    break;
                case FILEOP_RENAME:
                    i = IDS_RENAME;
                    break;
                case FILEOP_COPY:
                    i = IDS_COPYING;
                    break;
                default:
                    i = (UINT)(-1);
                    break;
            }

            if (i != (UINT)(-1)) {
                LoadString(MyModuleHandle,i,Text,sizeof(Text)/sizeof(TCHAR));
                SetDlgItemText(SetupPage->hdlg,SetupPage->ControlsInfo.ProgressText,Text);

                // If, update the text on the billboard for the progress bar.
                if (SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
                {
                    SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
                }

            }

            //Reset SecondNeedMedia as we are about to begin copying for a particular queue

            SetupPage->SecondNeedMedia = FALSE;

            break;

        case  SPFILENOTIFY_STARTCOPY:
            lstrcpy( g_LastFileCopied, pFile->Target );
#ifdef UNICODE
            // fall through...
        case  SPFILENOTIFY_STARTDELETE:
        case  SPFILENOTIFY_STARTRENAME:
            if ((SetupPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                if (!hSfp) {
                    hSfp = SfcConnectToServer( NULL );
                }
                if (hSfp) {
                    if (SfcIsFileProtected(hSfp,pFile->Target)) {
                        SfcFileException(
                                        hSfp,
                                        (PWSTR) pFile->Target,
                                        SFC_ACTION_REMOVED
                                        );
                    }
                }
            }
#endif
            break;

        case  SPFILENOTIFY_ENDCOPY:
            if (pFile->Win32Error == NO_ERROR) {
                _LogError(SetupPage->OcManager,
                          OcErrLevInfo,
                          MSG_OC_LOG_FILE_COPIED,
                          pFile->Source,
                          pFile->Target);
            } else {
                TRACE(( TEXT("OC:OcManagerQueueCallback Copy Error: %s --> %s (%d)\n"),
                        pFile->Source,
                        pFile->Target,
                        pFile->Win32Error));

                _LogError(SetupPage->OcManager,
                          OcErrLevInfo,
                          MSG_OC_LOG_FILE_COPY_FAILED,
                          pFile->Source,
                          pFile->Target,
                          pFile->Win32Error);
            }

            //Reset SecondNeedMedia as we are at the end of copying files for this media

            SetupPage->SecondNeedMedia = FALSE;

            break;

        case  SPFILENOTIFY_ENDDELETE:   // fall through
        case SPFILENOTIFY_ENDRENAME:
        case SPFILENOTIFY_ENDBACKUP:
            //
            // tick the progress gauge manually since setupapi doesn't do it 
            // for us.
            //
            SendMessage(SetupPage->hdlg,WMX_TICK,1,0);

            break;

        case  SPFILENOTIFY_DELETEERROR:    //    0x00000007
            TRACE(( TEXT("OC:OcManagerQueueCallback Delete Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));
            break;

        case  SPFILENOTIFY_RENAMEERROR:    //    0x0000000a
            TRACE(( TEXT("OC:OcManagerQueueCallback Rename Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));
            break;

        case  SPFILENOTIFY_COPYERROR:      //    0x0000000d
            TRACE(( TEXT("OC:OcManagerQueueCallback Copy Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));

            break;

        case SPFILENOTIFY_NEEDMEDIA:
            TRACE(( TEXT("OC:OcManagerQueueCallback Need Media: %s - %s (%s)\n"),
                    sm->SourcePath,
                    sm->SourceFile,
                    sm->Tagfile));

            if (gLastOcManager && (gLastOcManager->InternalFlags & OCMFLAG_RUNQUIET)) {


                // Check if this is the second time we are getting a 
    
                if (TRUE == SetupPage->SecondNeedMedia) {
                    SetupPage->SecondNeedMedia = FALSE;
                    return (FILEOP_ABORT);
                }else{
                    SetupPage->SecondNeedMedia = TRUE;
                    return (FILEOP_DOIT);
                }
            }

            break;

        case SPFILENOTIFY_FILEOPDELAYED:
            TRACE(( TEXT("OC:OcManagerQueueCallback FileOpDelayed: %s\n"), pFile->Target ));
            //
            // We want to remember that there was at least one file
            // with a delayed-move, but we still want to let the
            // default callback get this notification also.
            //
            SetupPage->OcManager->InternalFlags |= OCMFLAG_ANYDELAYEDMOVES;
            SetupPage->OcManager->Callbacks.SetReboot();
            pOcSetRenamesFlag(SetupPage->OcManager);

            for (i=0; (i<SetupPage->OcManager->TopLevelOcCount); i++) {
                OcInterfaceFileBusy(
                                   SetupPage->OcManager,
                                   SetupPage->OcManager->TopLevelOcStringIds[i],
                                   (PFILEPATHS)Param1,
                                   (LPTSTR)Param2
                                   );
            }

            break;
    }

    return (SetupDefaultQueueCallback(SetupPage->QueueContext, Notification, Param1, Param2));

}


DWORD
pOcSetupDoIt(
            IN PGEN_THREAD_PARAMS Params
            )
{
    BOOL b;
    TCHAR Text[256];
    TCHAR LogText[256];
    OPTIONAL_COMPONENT Oc;
    POC_MANAGER OcManager;
    BOOL AllowCancel;
    UINT LastError = ERROR_SUCCESS;
    DWORD TotalFileCount,PartialCount;

    TRACE(( TEXT("at pOcSetupDoIt entry\n") ));

    InterlockedIncrement( &Params->SetupPage->RefCount );
    //
    // Call components to let them do pre-commit processing.
    //
    LoadString(MyModuleHandle,IDS_PREQUEUECONFIG,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    // Save it, because "Text" is used below and we would not end up with a matchin END_SECTION
    lstrcpy(LogText, Text);
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",LogText);
#endif

    Params->SetupPage->OcManager->ProgressTextWindow = GetDlgItem(
                                                                 Params->hdlg,
                                                                 Params->SetupPage->ControlsInfo.ProgressText
                                                                 );

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    //
    // send OC_ABOUT_TO_COMMIT_QUEUE message
    //
    pOcPreOrPostCommitProcessing(Params->SetupPage,TRUE);

    OcManager = Params->SetupPage->OcManager;
    AllowCancel = Params->SetupPage->AllowCancel;
    OcManager->ProgressTextWindow = NULL;

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    //
    // Commit the file queue. We get the total number of file operations
    // so we can scale the progress indicator properly.  We do this manually
    // as setupapi only returns back the total number of copy operations, and
    // we want status on delete operations as well.
    //
    TotalFileCount = 0;
    PartialCount = 0;
    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_COPY,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    PartialCount = 0;

    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_RENAME,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    PartialCount = 0;

    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_DELETE,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    //
    // if the OC file queue is ever backup aware, add in the count
    // of files to be backed up here.
    //

    TRACE(( TEXT("OCM: %d file operations to complete\n"), TotalFileCount ));

    //
    // scale the progress gauge
    //
    PostMessage(Params->hdlg,
                WMX_TICK,
                10,Params->SetupPage->StepCount + TotalFileCount);
    

    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }

    b = FALSE;

    while (! b) {
        DWORD ScanResult;

        LoadString(MyModuleHandle,IDS_FILESCAN,Text,sizeof(Text)/sizeof(TCHAR));
        SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);

        b = SetupScanFileQueue(Params->SetupPage->FileQueue,
                               SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                               Params->hdlg,
                               NULL,
                               NULL,
                               &ScanResult);

        //
        // if the scan result is 1, then there isn't anything to commit, the entire
        // file queue has been pruned. So we skip it.
        //
        if (ScanResult != 1) {

            if( IsWindow( Params->hdlg ) ){
                LoadString(MyModuleHandle,IDS_FILEOPS,Text,sizeof(Text)/sizeof(TCHAR));
                SetDlgItemText(Params->SetupPage->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
            }

            if (CheckForQueueCancel(Params->SetupPage)) {
                goto exit;
            }

            //Set the SecondNeedMedia to FALSE as we are starting a commit operation.

            Params->SetupPage->SecondNeedMedia = FALSE;

            b = SetupCommitFileQueue(
                                    Params->hdlg,
                                    Params->SetupPage->FileQueue,
                                    OcManagerQueueCallback1,
                                    Params->SetupPage
                                    );

            LastError =  GetLastError();

#ifdef UNICODE
            if (hSfp) {
                SfcClose(hSfp);
            }
#endif

        }

        if (!b) {

            TRACE(( TEXT("OC:SetupCommitFileQueue failed (LE=%d), last file copied was %s\n"),
                    LastError,
                    g_LastFileCopied ));

            pOcHelperReportExternalError(
                                        OcManager,
                                        0,               // defaults to Master Inf file
                                        0,
                                        MSG_OC_CANT_COMMIT_QUEUE,
                                        ERRFLG_OCM_MESSAGE,
                                        LastError
                                        );

            if ( LastError == ERROR_CANCELLED ||
                 LastError == ERROR_CONTROL_ID_NOT_FOUND ||
                 LastError == ERROR_OPERATION_ABORTED) {
                //
                // User canceled from a SetupAPI provided Dialog
                // when CallBack Returns FILEOP_ABORT LastError reports
                // ERROR_CONTROL_ID_NOT_FOUND if User aborts in SetupApi
                // find File Dialog you get ERROR_CANCELLED
                //

                if ( AllowCancel &&
                     (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                    _LogError(
                             OcManager,
                             OcErrLevError|MB_ICONEXCLAMATION|MB_OK,
                             MSG_OC_USER_CANCELED,
                             LastError
                             );
                }
                //
                // this will force the cancel of setup
                //
                LastError = IDCANCEL;

            } else {

                //
                // Warn the user that it might be hazzardous to continue after copy error
                //
                LastError = _LogError(
                                     OcManager,
                                     OcErrLevError|MB_ICONEXCLAMATION|MB_OKCANCEL|MB_DEFBUTTON2,
                                     MSG_OC_CANT_COMMIT_QUEUE,
                                     LastError
                                     );

            }
            //
            // Abort the setup if the user pressed Cancel or
            // Batch mode log the error and cancel out of setup
            //
            if ( LastError == IDCANCEL
                 || OcManager->SetupData.OperationFlags & SETUPOP_BATCH) {
                PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_COPYABORT,0);
                goto exit;
            } else if ( LastError == IDOK ) {
                b = TRUE;
            }

        }

    }

    //
    // put a message in the log so we know we completed all file operations
    //
    _LogError(OcManager,
              OcErrLevInfo,
              MSG_OC_LOG_QUEUE_COMPLETE
             );

    //
    // Tell the UI that we are done with the file operations
    //
    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_COPYDONE,0);
#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",LogText);
#endif

    //
    // Call components to let them do post-commit processing.
    //
    LoadString(MyModuleHandle,IDS_CONFIGURING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);
#endif
    Params->SetupPage->OcManager->ProgressTextWindow = GetDlgItem(
                                                                 Params->hdlg,
                                                                 Params->SetupPage->ControlsInfo.ProgressText
                                                                 );

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    pOcPreOrPostCommitProcessing(Params->SetupPage,FALSE);

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    Params->SetupPage->OcManager->ProgressTextWindow = NULL;

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_DONE,0);

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
exit:

    TRACE(( TEXT("at pOcSetupDoIt exit\n") ));

    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }

    return (0);
}


VOID
pOcPreOrPostCommitProcessing(
                            IN OUT PSETUP_PAGE SetupPage,
                            IN     BOOL        PreCommit
                            )

/*++

Routine Description:

    Handle processing and notification to the component dlls before or after
    the file queue is committed. This involves calling interface dlls once
    for each top-level component, and then once for each subcomponent.

    The ordering for the top-level components is the order that the
    components were listed in the master oc inf.

    The ordering for leaf components is generally random within each
    top-level hierarchy, but 'detours' are taken when components are
    needed by other components. This ensures that components are
    called in the correct order to faciliate uninstall-type actions.

Arguments:

    SetupPage - supplies context data structure.
    PreCommit - TRUE indicates OC_ABOUT_TO_COMMIT_QUEUE is to be called,
                otherwise OC_COMPLETE_INSTALLATION is to be called.

Return Value:

    None. Errors are logged.

--*/

{
    OPTIONAL_COMPONENT Oc,AuxOc;
    unsigned i,child;

    //
    // Call each component at the "top-level" (ie, no subcomponent).
    //
    pOcTopLevelPreOrPostCommitProcessing(SetupPage,PreCommit);

    if (CheckForQueueCancel(SetupPage)) {
        return;
    }

    if (!PreCommit) {
        //
        // Make sure the components are marked as unprocessed.
        //

        MYASSERT(SetupPage->OcManager->ComponentStringTable);
        //
        // if this doesn't exist then something is hosed.
        //
        if (!SetupPage->OcManager->ComponentStringTable) {
            return;
        }
        pSetupStringTableEnum(
                       SetupPage->OcManager->ComponentStringTable,
                       &Oc,
                       sizeof(OPTIONAL_COMPONENT),
                       pOcMarkUnprocessedStringCB,
                       0
                       );
    }

    //
    // Call component dlls for each child subcomponent.
    //
    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {


        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        for (child=0; child<SetupPage->OcManager->TopLevelParentOcCount; child++) {

            pOcSetupDoItWorker(
                              SetupPage,
                              SetupPage->OcManager->TopLevelParentOcStringIds[child],
                              SetupPage->OcManager->TopLevelOcStringIds[i],
                              PreCommit
                              );
        }
    }
}


VOID
pOcTopLevelPreOrPostCommitProcessing(
                                    IN PSETUP_PAGE SetupPage,
                                    IN BOOL        PreCommit
                                    )

/*++

Routine Description:

    Call the OC_COMPLETE_INSTALLATION or OC_ABOUT_TO_COMMIT_QUEUE
    interface routine once for each top-level component.

Arguments:

    SetupPage - supplies context structure.

    PreCommit - if 0, then call OC_COMPLETE_INSTALLATION. Otherwise
        call OC_ABOUT_TO_COMMIT_QUEUE.

Return Value:

    None. Errors are logged.

--*/
{
    unsigned i;
    OPTIONAL_COMPONENT Oc;
    UINT Err;

    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        SetupPage->CurrentTopLevelComponentIndex = i;

        Err = OcInterfaceCompleteInstallation(
                                             SetupPage->OcManager,
                                             SetupPage->OcManager->TopLevelOcStringIds[i],
                                             NULL,
                                             PreCommit
                                             );

        if (Err != NO_ERROR) {
            _LogError(
                     SetupPage->OcManager,
                     OcErrLevError,
                     MSG_OC_COMP_INST_FAIL,
                     Oc.Description,
                     Err
                     );

            pOcHelperReportExternalError(
                                        SetupPage->OcManager,
                                        SetupPage->OcManager->TopLevelOcStringIds[i],
                                        0,
                                        MSG_OC_COMP_INST_FAIL,
                                        ERRFLG_OCM_MESSAGE,
                                        Oc.Description,
                                        Err
                                        );
        }
    }
}


VOID
pOcSetupDoItWorker(
                  IN PSETUP_PAGE SetupPage,
                  IN LONG        StringId,
                  IN LONG        TopLevelStringId,
                  IN BOOL        PreCommit
                  )
/*++

Routine Description:

    Call the OC_COMPLETE_INSTALLATION or OC_ABOUT_TO_COMMIT_QUEUE
    interface routine for each child of a given top-level component.

Arguments:

    SetupPage - supplies context structure.

    StringId - ID for the child component to be called

    TopLevelStringId - ID for the child's parent

    PreCommit - if 0, then call OC_COMPLETE_INSTALLATION. Otherwise
        call OC_ABOUT_TO_COMMIT_QUEUE.

Return Value:

    None. Errors are logged.

--*/
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;
    unsigned i;
    LONG TopLevelIndex;
    UINT SelectionState;
    UINT InstalledState;

    //
    // Figure out the index of the top-level component associated with this
    // subcomponent.
    //
    Id = pOcGetTopLevelComponent(SetupPage->OcManager,StringId);
    TopLevelIndex = -1;
    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {
        if (SetupPage->OcManager->TopLevelOcStringIds[i] == Id) {
            TopLevelIndex = i;
            break;
        }
    }

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    if (Oc.FirstChildStringId == -1) {
        //
        // Leaf subcomponent.
        //
        // In the precommit case, check the subcomponents this subcomponent
        // is needed by; if there are any, process them first.
        //
        // In the postcommit case, check the subcomponents this subcomponent
        // needs; if there are any, process them first.
        //
        if (PreCommit) {
            for (i=0; i<Oc.NeededByCount; i++) {
                pOcSetupDoItWorker(
                                  SetupPage,
                                  Oc.NeededByStringIds[i],
                                  pOcGetTopLevelComponent(SetupPage->OcManager,Oc.NeededByStringIds[i]),
                                  TRUE
                                  );
            }
        } else {
            for (i=0; i<Oc.NeedsCount; i++) {
                if (Oc.NeedsStringIds[i] != StringId) {
                    pOcSetupDoItWorker(
                                      SetupPage,
                                      Oc.NeedsStringIds[i],
                                      pOcGetTopLevelComponent(SetupPage->OcManager,Oc.NeedsStringIds[i]),
                                      FALSE
                                      );
                }
            }
        }

        //
        // Fetch extra data for this subcomponent again as it might have
        // changed in the recursive call we just made.
        //
        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               StringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // If not processed already, process now.
        //
        if (!(Oc.InternalFlags & OCFLAG_PROCESSED)) {

            Oc.InternalFlags |= OCFLAG_PROCESSED;
            pSetupStringTableSetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   StringId,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            SetupPage->CurrentTopLevelComponentIndex = TopLevelIndex;

            //
            // Set current install state to not installed, pending successful
            // outcome of the installation routine.
            //
            if (!PreCommit) {
                SelectionState = Oc.SelectionState;
                Oc.SelectionState = SELSTATE_NO;
                pOcSetOneInstallState(SetupPage->OcManager,StringId);
            }

            Err = OcInterfaceCompleteInstallation(
                                                 SetupPage->OcManager,
                                                 pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                                 pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                                 PreCommit
                                                 );

            // Ignore error and ask the component
            // for the actual installation state.

            if (!PreCommit) {

                Oc.SelectionState = (Err) ? Oc.OriginalSelectionState : SelectionState;

                InstalledState = OcInterfaceQueryState(
                                                      SetupPage->OcManager,
                                                      pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                                      pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                                      OCSELSTATETYPE_FINAL
                                                      );

                switch (InstalledState) {
                    case SubcompOn:
                        SelectionState = SELSTATE_YES;
                        break;
                    case SubcompOff:
                        SelectionState = SELSTATE_NO;
                        break;
                    default:
                        SelectionState = Oc.SelectionState;
                        break;
                }

                Oc.SelectionState = SelectionState;
                pSetupStringTableSetExtraData(
                                       SetupPage->OcManager->ComponentStringTable,
                                       StringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                pOcSetOneInstallState(SetupPage->OcManager,StringId);
            }

        }
    } else {
        //
        // Parent component. Spin through the children.
        //
        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            pOcSetupDoItWorker(SetupPage,Id,TopLevelStringId,PreCommit);

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }
}


BOOL
pOcMarkUnprocessedStringCB(
                          IN PVOID               StringTable,
                          IN LONG                StringId,
                          IN PCTSTR              String,
                          IN POPTIONAL_COMPONENT Oc,
                          IN UINT                OcSize,
                          IN LPARAM              Unused
                          )

/*++

Routine Description:

    String table callback routine. Clears the OCFLAG_PROCESSED flag in
    the OPTIONAL_COMPONENT structure that is passed to it.

Arguments:

    String string table callback arguments.

Return Value:

    Always returns TRUE to continue enumeration.

--*/

{
    Oc->InternalFlags &= ~OCFLAG_PROCESSED;
    pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcSize);
    return (TRUE);
}


VOID
_pOcExternalProgressIndicator(
                             IN PSETUP_PAGE SetupPage,
                             IN BOOL        ExternalIndicator,
                             IN HWND        hdlg
                             )
{
    POC_MANAGER OcManager;
    HWND Animation;

    OcManager = SetupPage->OcManager;

    EnableWindow(
                GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                !ExternalIndicator
                );

    if (SetupPage->ForceExternalProgressIndicator) {
        ShowWindow(
                  GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                  ExternalIndicator ? SW_HIDE : SW_SHOW
                  );

        ShowWindow(
                  GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressLabel),
                  ExternalIndicator ? SW_HIDE : SW_SHOW
                  );
    }

    Animation = GetDlgItem(hdlg,SetupPage->ControlsInfo.AnimationControl);

    sapiAssert( Animation != NULL );

    if (!ExternalIndicator) {
        Animate_Stop(Animation);
        Animate_Close(Animation);
    }

    EnableWindow(Animation,ExternalIndicator);
    ShowWindow(Animation,ExternalIndicator ? SW_SHOW : SW_HIDE);

    if (ExternalIndicator) {
        Animate_Open(Animation,MAKEINTRESOURCE(SetupPage->ControlsInfo.AnimationResource));
        Animate_Play(Animation,0,-1,-1);
    }
}


VOID
pOcExternalProgressIndicator(
                            IN PHELPER_CONTEXT OcManagerContext,
                            IN BOOL            ExternalIndicator
                            )
{
    POC_MANAGER OcManager;
    HWND hdlg;
    PSETUP_PAGE SetupPage;

    OcManager = OcManagerContext->OcManager;

    if (OcManager->ProgressTextWindow
        && (hdlg = GetParent(OcManager->ProgressTextWindow))
        && (SetupPage = (PSETUP_PAGE)GetWindowLongPtr(hdlg,DWLP_USER))
        && !SetupPage->ForceExternalProgressIndicator) {

        _pOcExternalProgressIndicator(SetupPage,ExternalIndicator,hdlg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocstalon.c ===
#include "precomp.h"
#pragma hdrstop
#include <io.h>

typedef struct _STANDALONE_COMP {
    struct _STANDALONE_COMP *Next;
    LPTSTR ComponentId;
    HINF Inf;
    OCMANAGER_ROUTINES HelperRoutines;

} STANDALONE_COMP, *PSTANDALONE_COMP;


PSTANDALONE_COMP StandaloneComponents = NULL;

DWORD
InvokeStandAloneInstaller(
    IN LPCTSTR ComponentId,
    IN BOOL    PreQueueCommit
    );

DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode
    );


void
SetSuiteCurrentDir(
    IN PSTANDALONE_COMP Standalone
        )
{
    TCHAR   NewPath[MAX_PATH];
    LPTSTR p;
    PHELPER_CONTEXT pContext = (PHELPER_CONTEXT) Standalone->HelperRoutines.OcManagerContext;
    
    _tcscpy(NewPath,pContext->OcManager->MasterOcInfPath);
    p = _tcsrchr(NewPath,TEXT('\\'));
    if (p) {
        *p = 0;
    }

    SetCurrentDirectory(NewPath);

}

BOOL
CheckIfExistAndAskForMedia(
    IN PSTANDALONE_COMP Standalone,
    IN LPTSTR ExePath,
    IN LPCTSTR Description
    )
{
    // Check to see if the Exe even exits... if not ask the
    PHELPER_CONTEXT pContext = (PHELPER_CONTEXT) Standalone->HelperRoutines.OcManagerContext;
    SOURCE_MEDIA Media;
    TCHAR   NewPath[MAX_PATH*3];
    LPTSTR p;
    BOOL b = FALSE;
    UINT    i;


    // Prepare Exe file name, Strip off arguments
    // Can't have spaces in Exe name.
    
    _tcscpy(NewPath,ExePath);
    
    p = _tcschr(NewPath,TEXT(' '));
    if(!p) {
        p = _tcschr(NewPath,TEXT('\t'));
    }
    if(p) {
        *p = 0;
    }

    // Check if we can find the file -
    // Assumes that we have right CD or full path
    i = GetFileAttributes(NewPath);

    if ( i == -1 ) {
            
        // now backup to file part, strip off path leave file name.
        
        p = _tcsrchr(NewPath,TEXT('\\'));
        if (!p) {
            p = NewPath;
        }
        
        Media.Reserved = NULL;  //      PCWSTR
        Media.Description= Description; //      PCWSTR
        
        Media.SourcePath = NULL;        //  PCWSTR
        Media.SourceFile = p;       //  PCWSTR
        Media.Tagfile  = p; //      PCWSTR  may be NULL
        Media.Flags = 0;                // DWORD  subset of SP_COPY_xxx

        for(b=FALSE,i=0; (i<pContext->OcManager->TopLevelOcCount) && !b; i++) {

             b = OcInterfaceNeedMedia(
                  pContext->OcManager,
                  pContext->OcManager->TopLevelOcStringIds[i],
                  &Media,
                  (LPTSTR)NewPath
               );
            if (b) {
                // Now we have a new Path to the file
                // get the last segment of the path
                
                p = _tcsrchr(ExePath,TEXT('\\'));
                if (p) {
                    _tcscat(NewPath,p);
                } else {
                    _tcscat(NewPath,TEXT("\\"));
                    _tcscat(NewPath,ExePath);
                }
                // Rewrite path
                _tcscpy(ExePath,NewPath);
                break;
            }
        }
    }
    return b;
}

DWORD
StandAloneSetupAppInterfaceRoutine(
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD d;
    PSTANDALONE_COMP Standalone,Prev;

    switch(Function) {

    case OC_PREINITIALIZE:
        //
        // Run with native character width.
        //
        #ifdef UNICODE
        d = OCFLAG_UNICODE;
        #else
        d = OCFLAG_ANSI;
        #endif
        break;

        
    case OC_INIT_COMPONENT:
        //
        // Inform OC Manager of the version we want.
        //
        ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;

        d = ERROR_NOT_ENOUGH_MEMORY;
        if(Standalone = pSetupMalloc(sizeof(STANDALONE_COMP))) {
            if(Standalone->ComponentId = pSetupMalloc((lstrlen(ComponentId)+1) * sizeof(TCHAR))) {

                lstrcpy(Standalone->ComponentId,ComponentId);

                Standalone->Inf = ((PSETUP_INIT_COMPONENT)Param2)->ComponentInfHandle;
                Standalone->HelperRoutines = ((PSETUP_INIT_COMPONENT)Param2)->HelperRoutines;

                Standalone->Next = StandaloneComponents;
                StandaloneComponents = Standalone;

                d = NO_ERROR;
            } else {
                pSetupFree(Standalone);
            }
        }

        break;

    case OC_SET_LANGUAGE:
        d = TRUE;
        break;

    case OC_QUERY_IMAGE:
        d = 0;
        break;

    case OC_REQUEST_PAGES:
        //
        // This component has no pages.
        //
        d = 0;
        break;

    case OC_QUERY_SKIP_PAGE:

        d = FALSE;
        break;

    case OC_QUERY_STATE:
    {
        DWORD dSetupMode;
        
        //
        // Allow selection state transition.
        //
        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                break;
            }
        }

        dSetupMode = Standalone->HelperRoutines.GetSetupMode(
                    Standalone->HelperRoutines.OcManagerContext);
        //
        // Use default if we have no option...
        //
    
        d = SubcompUseOcManagerDefault;

        if (Param1 == OCSELSTATETYPE_CURRENT) {

            switch(dSetupMode & SETUPMODE_PRIVATE_MASK) {
            default:
                d = SubcompUseOcManagerDefault;
                break;
            case SETUPMODE_REMOVEALL:
                d = SubcompOff;
                break;
                    
            case SETUPMODE_ADDEXTRACOMPS:
            case SETUPMODE_ADDREMOVE:
            case SETUPMODE_UPGRADEONLY:
            case SETUPMODE_REINSTALL:
                d = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                        SubcomponentId,
                        OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
                     break;
            }
       }

        break;
    }
    case OC_QUERY_CHANGE_SEL_STATE:
            d = TRUE;
        break;

    case OC_CALC_DISK_SPACE:

        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                break;
            }
        }

        if(Standalone) {

            INFCONTEXT Context;

            if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("DiskSpaceEstimate"),&Context)) {

                LONGLONG Space;
                int SpaceMB;
                BOOL b;
                TCHAR Path[MAX_PATH];

                if(SetupGetIntField(&Context,1,&SpaceMB)) {

                    Space = (LONGLONG)SpaceMB * (1024*1024);
                    if(!Param1) {
                        Space = 0 - Space;
                    }

                    GetWindowsDirectory(Path,MAX_PATH);
                    Path[3] = 0;

                    b = SetupAdjustDiskSpaceList((HDSKSPC)Param2,Path,Space,0,0);

                    d = b ? NO_ERROR : GetLastError();
                } else {
                    d = ERROR_INVALID_DATA;
                }
            }
        } else {
            d = NO_ERROR;
        }

        break;

    case OC_QUEUE_FILE_OPS:
        //
        // No files to queue.
        //
        d = NO_ERROR;
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = 0;
        break;

    case OC_QUERY_STEP_COUNT:
        //
        // Just use 1 step.
        //
        d = 1;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
    case OC_COMPLETE_INSTALLATION:

        // Figure out whether state changed, and if so, invoke
        // the install/uninstall cmd line. Just to be safe, we ignore
        // any requests that are not for the component as a whole,
        // since these were not supposed to have been specified in the first place.
        //
        d = SubcomponentId
          ? NO_ERROR
          : InvokeStandAloneInstaller(ComponentId,Function == OC_ABOUT_TO_COMMIT_QUEUE);

        break;

    case OC_CLEANUP:
        //
        // Return value is ignored.
        //
        Prev = NULL;
        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {

            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                if(Prev) {
                    Prev->Next = Standalone->Next;
                } else {
                    StandaloneComponents = Standalone->Next;
                }

                pSetupFree(Standalone->ComponentId);
                pSetupFree(Standalone);
                break;
            }

            Prev = Standalone;
        }
        break;

    default:
        //
        // Return something sane.
        //
        d = 0;
        break;
    }

    return(d);
}


DWORD
RunStandaloneCmd(
    IN PSTANDALONE_COMP Standalone,
    IN LPCTSTR          Description,
    IN LPCTSTR          cmd
    )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    TCHAR               ExePath[3*MAX_PATH];
    DWORD               ExitCode;
    BOOL                b;

    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    ZeroMemory(&ProcessInfo,sizeof(PROCESS_INFORMATION));

    StartupInfo.cb = sizeof(STARTUPINFO);

    lstrcpyn(ExePath,cmd,3*MAX_PATH);

    pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,TRUE);

    // We will try two times to invoke the external setup. For both attempt the Current
    // Directory is set the same directory of where the suite.inf file is located.
    // In the first attempt we invoke the command line as we find it from the Standalone
    // inf file. An for almost all cases this will work. If we fail in that invokcation we
    // ask the suite dll for a "Needs Media" can allow them to tell us where the Standalone exe is.

    // This accounts the two following form of commands
    // InstalledCmd = "wpie15-x86.exe /Q:A /R:NG"
    // UninstallCmd = "RunDll32 ADVPACK.DLL,LaunchINFSection %17%\enuwpie.inf,WebPostUninstall,5"

    // Where Wpie15-x86.exe will be found in the Current Directory, and if it's not we will ask the
    // suite to provide it. (Web Download) or in the second case where a system dll must be executed
    // to uninstall the product. What's not covered here is if we fail to do a createProcess on the
    // second form of command.

    b = FALSE;
    while( ! b) {
        b = CreateProcess(
            NULL,
            ExePath,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,               // Sysocmgr set CD to sourcedir
            &StartupInfo,
            &ProcessInfo
            );

        // If we failed to start the external setup, try asking the suite where
        // to find this
        if ( ! b) {
            if ( ! CheckIfExistAndAskForMedia(Standalone, ExePath, Description)) {
                // if the Suite could not locate the exe thengive up
                break;
            }
        }
    }

    if (!b) {
        pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,FALSE);
        return GetLastError();
    }

    CloseHandle(ProcessInfo.hThread);
    WaitOnApp(ProcessInfo.hProcess,&ExitCode);
    CloseHandle(ProcessInfo.hProcess);
    pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,FALSE);

    return NO_ERROR;
}

DWORD
InvokeStandAloneInstaller(
    IN LPCTSTR ComponentId,
    IN BOOL    PreQueueCommit
    )
{
    PSTANDALONE_COMP Standalone;
    BOOL OldState,NewState;
    LPCTSTR Key;
    INFCONTEXT Context;
    LPCTSTR CmdLine;
    TCHAR CurDir[MAX_PATH];
    BOOL b;
    LPCTSTR Description;
    TCHAR Text[150];
    TCHAR Text2[350];
    TCHAR *p;
    DWORD ExitCode;
    DWORD d;
    DWORD dSetupMode;

    //
    // Find the component.
    //
    for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
        if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
            break;
        }
    }

    if(!Standalone) {
        d = NO_ERROR;
        goto c0;
    }

    //
    // Determine whether this component wants to be invoked pre or post-queue.
    // If this doesn't match the notification we're processing then bail.
    //
    b = FALSE;
    if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("InvokeBeforeQueueCommit"),&Context)
    && SetupGetIntField(&Context,1,&d)) {
        b = (d != 0);
    }
    if((b == FALSE) != (PreQueueCommit == FALSE)) {
        d = NO_ERROR;
        goto c0;
    }

    OldState = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                    ComponentId,
                    OCSELSTATETYPE_ORIGINAL
                    );

    NewState = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                    ComponentId,
                    OCSELSTATETYPE_CURRENT
                    );

    dSetupMode = Standalone->HelperRoutines.GetSetupMode(
                    Standalone->HelperRoutines.OcManagerContext);


    // Qualify this setup mode and see if we do anything
    // if no change in state

    // SETUPMODE_UPGRADE
    //                   SETUPMODE_UPGRADEONLY
    //                   SETUPMODE_ADDEXTRACOMPS
    //
    // SETUPMODE_MAINTANENCE
    //                   SETUPMODE_ADDREMOVE
    //                   SETUPMODE_REINSTALL
    //                   SETUPMODE_REMOVEALL
    // SETUPMODE_FRESH


    d = NO_ERROR;

    if ( NewState == OldState ) {

        // no change in slected state What we do depends on the secondary setup modes
        // if Setupmode is AddRemove or Removeall then Skip this

        if ( NewState == 0) {
            goto c0;        // do nothing
        }

        // Mask off Public mode bits
        //
        dSetupMode &= SETUPMODE_PRIVATE_MASK;
        if ( dSetupMode == SETUPMODE_ADDREMOVE || dSetupMode == SETUPMODE_REMOVEALL ) {
            goto c0;        // do nothing
        }
        // What remains here is NewState=1
        // and Reinstall and Upgrade
    }


    Description = NULL;
    if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("OptionDesc"),&Context)) {
        Description = pSetupGetField(&Context,1);
    }
    if(Description) {

        LoadString(
            MyModuleHandle,
            OldState ? (NewState ? IDS_EXTERNAL_UPGRADE : IDS_EXTERNAL_UNINST)
                     : (NewState ? IDS_EXTERNAL_INST : IDS_EXTERNAL_EXAMINE),
            Text,
            sizeof(Text)/sizeof(TCHAR)
            );

        wsprintf(Text2,Text,Description);

        Standalone->HelperRoutines.SetProgressText(
            Standalone->HelperRoutines.OcManagerContext,
            Text2
            );
    } else {
        Standalone->HelperRoutines.SetProgressText(
            Standalone->HelperRoutines.OcManagerContext,
            TEXT("")
            );
    }

    if(OldState == NewState) {
        Key = OldState ? TEXT("InstalledCmd") : TEXT("UninstalledCmd");
    } else {
        Key = OldState ? TEXT("UninstallCmd") : TEXT("InstallCmd");
    }

    d = NO_ERROR;

    if(!SetupFindFirstLine(Standalone->Inf,ComponentId,Key,&Context))
        goto c0;

    // The current Directory to the Suite's Inf Path, with Initial installs "-N" option
    // this may on the CD, with Mainatiance mode it will be the %systemroot%\system32\setup

    SetSuiteCurrentDir(Standalone);

    do {
        if (!(CmdLine = pSetupGetField(&Context,1)))
            break;
        d = RunStandaloneCmd(Standalone, Description, CmdLine);
        if (d != NO_ERROR)
            break;
    } while (SetupFindNextMatchLine(&Context,Key,&Context));

c0:
    Standalone->HelperRoutines.TickGauge(
        Standalone->HelperRoutines.OcManagerContext
        );

    return d;
 }


DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode
    )
{
    DWORD dw;
    BOOL Done;
    MSG msg;

    //
    // Process any messages that may already be in the queue.
    //  
    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

    //
    // Wait for process to terminate or more messages in the queue.
    //
    Done = FALSE;
    do {
        switch(MsgWaitForMultipleObjects(1,&Process,FALSE,INFINITE,QS_ALLINPUT)) {

        case WAIT_OBJECT_0:
            //
            // Process has terminated.
            //
            dw = GetExitCodeProcess(Process,ExitCode) ? NO_ERROR : GetLastError();
            Done = TRUE;
            break;

        case WAIT_OBJECT_0+1:
            //
            // Messages in the queue.
            //
            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                DispatchMessage(&msg);
            }
            break;

        default:
            //
            // Error.
            //
            dw = GetLastError();
            Done = TRUE;
            break;
        }
    } while(!Done);

    return(dw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocstate.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocstate.c

Abstract:

    Routines to remember and restore the install state of subcomponents.

Author:

    Ted Miller (tedm) 17-Oct-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


typedef struct _I_S_PARAMS {
    HKEY hKey;
    BOOL Set;
    BOOL AnyError;
    BOOL Simple;
    POC_MANAGER OcManager;
} I_S_PARAMS, *PI_S_PARAMS;


BOOL
pOcPersistantInstallStatesWorker(
    IN POC_MANAGER OcManager,
    IN BOOL        Set,
    IN LONG        ComponentStringId
    );

BOOL
pOcInitInstallStatesStringTableCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcStructSize,
    IN PI_S_PARAMS         Params
    );


BOOL
pOcFetchInstallStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine retreives stored installation state for all leaf child
    subcomponents, from the registry. It does NOT set or manipulate parent
    selection states.

    Both the selection state and original selection state memebers of the
    optional component structures are set (to the same value) by this routine.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,FALSE,-1));
}


BOOL
pOcRememberInstallStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine stores installation state for all leaf child
    subcomponents, into the registry. It does NOT set or manipulate parent
    selection states.

    The current selection state is stored, and then the original state is
    reset to the current state.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,TRUE,-1));
}


BOOL
pOcSetOneInstallState(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    )

/*++

Routine Description:

    This routine stores installation state for one single leaf child
    subcomponent, into the registry.

    The current selection state is stored. The original selection state
    is not manipulated.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,TRUE,StringId));
}


BOOL
pOcPersistantInstallStatesWorker(
    IN POC_MANAGER OcManager,
    IN BOOL        Set,
    IN LONG        ComponentStringId
    )

/*++

Routine Description:

    Worker routine for fetching and remembering installation states.
    If opens/creates the key used in the registry for persistent state info,
    the enumerates the component string table to examine each subcomponent
    and either fetch or set the install state.

Arguments:

    OcManager - supplies OC Manager context info.

    Set - if 0 then query state from the registry and store in the
        OPTIONAL_COMPONENT structures. If non-0 then set state into registry.
        If 0 then query. Component DLLs will be sent OC_DETECT_INITIAL_STATE
        notifications.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    OPTIONAL_COMPONENT Oc;
    LONG l;
    DWORD Disposition;
    I_S_PARAMS Params;

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szSubcompList,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (Set || (OcManager->InternalFlags & OCMFLAG_KILLSUBCOMPS)) ? KEY_SET_VALUE : KEY_QUERY_VALUE,
            NULL,
            &Params.hKey,
            &Disposition
            );

    if(l != NO_ERROR) {

        _LogError(
            OcManager,
            Set ? OcErrLevError : OcErrLevFatal,
            MSG_OC_CREATE_KEY_FAILED,
            szSubcompList,
            l
            );

        return(FALSE);
    }

    Params.Set = Set;
    Params.AnyError = FALSE;
    Params.OcManager = OcManager;

    if(ComponentStringId == -1) {
        //
        // Enumerate whole table and operate on each leaf node.
        //
        Params.Simple = FALSE;

        pSetupStringTableEnum(
            OcManager->ComponentStringTable,
            &Oc,
            sizeof(OPTIONAL_COMPONENT),
            (PSTRTAB_ENUM_ROUTINE)pOcInitInstallStatesStringTableCB,
            (LPARAM)&Params
            );

    } else {
        //
        // Operate on one single subcomponent.
        //
        Params.Simple = TRUE;

        if (!pOcComponentWasRemoved(OcManager, ComponentStringId)) {

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                ComponentStringId,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            pOcInitInstallStatesStringTableCB(
                OcManager->ComponentStringTable,
                ComponentStringId,
                pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentStringId),
                &Oc,
                sizeof(OPTIONAL_COMPONENT),
                &Params
                );
        }
    }

    RegCloseKey(Params.hKey);

    return(!Params.AnyError);
}


BOOL
pOcInitInstallStatesStringTableCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcStructSize,
    IN PI_S_PARAMS         Params
    )
{
    LONG l;
    DWORD Type;
    DWORD Data;
    DWORD Size;
    SubComponentState s;

    //
    // If this is not a leaf/child component, ignore it.
    //
    if(Oc->FirstChildStringId == -1) {

        if(Params->Set) {

            Data = (Oc->SelectionState == SELSTATE_NO) ? 0 : 1;

            if( ((Params->OcManager)->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {

                RegDeleteValue(Params->hKey,String);

            } else {
                l = RegSetValueEx(Params->hKey,String,0,REG_DWORD,(CONST BYTE *)&Data,sizeof(DWORD));
                if(l != NO_ERROR) {

                   Params->AnyError = TRUE;

                    _LogError(
                        Params->OcManager,
                        OcErrLevError,
                        MSG_OC_CANT_REMEMBER_STATE,
                        Oc->Description,
                        l
                        );
                }
            }
        } else {

            // kill the entry from the registry before starting, if indicated

            if (Params->OcManager->InternalFlags & OCMFLAG_KILLSUBCOMPS)
                l = RegDeleteValue(Params->hKey,String);

            // Check the registery and see if we have dealt with this component before
            // Data should contain 0/1 depending on the current installed state
            //
            // If the entry does not exist the data type/size is not valid
            // then we don't have Prior knowlege of component.
            //
            // also check the inf settting for installation state
            
            Size = sizeof(DWORD);

            l = RegQueryValueEx(Params->hKey,String,NULL,&Type,(LPBYTE)&Data,&Size);

            switch (Oc->InstalledState)
            {
            case INSTSTATE_YES:
                Data = 1;
                break;
            case INSTSTATE_NO:
                Data = 0;
                break;
            }

            if((l != NO_ERROR) || (Size != sizeof(DWORD)) || ((Type != REG_DWORD) && (Type != REG_BINARY))) {

                // Nope, never seen it, Set Data to Uninstalled
                // and flag this item as new

                Data = 0;
                Oc->InternalFlags |= OCFLAG_NEWITEM;

            } else {

                // have seen it before, Data contains it's current install state
                // Flag this component that it had an initial install state
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYON;
            }

            //
            // Now call out to the component dll to ask whether it wants to
            // override the value we decided on.
            //
            s = OcInterfaceQueryState(
                Params->OcManager,
                pOcGetTopLevelComponent(Params->OcManager,StringId),
                String,
                OCSELSTATETYPE_ORIGINAL
                );

            switch(s) {
            case SubcompUseOcManagerDefault:
                Oc->SelectionState = Data ? SELSTATE_YES : SELSTATE_NO;
                break;
            case SubcompOn:
                Oc->SelectionState = SELSTATE_YES;
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYON;
                break;
            case SubcompOff:
                Oc->SelectionState = SELSTATE_NO;
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYOFF;
                break;
            }
        }

        pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcStructSize);

        if(!Params->Simple) {

            Oc->OriginalSelectionState = Oc->SelectionState;
            pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcStructSize);

            pOcUpdateParentSelectionStates(Params->OcManager,NULL,StringId);
        }
    }

    return(TRUE);
}

/*
 * this function is exported to allow external code to
 * access the installation states
 */

UINT
OcComponentState(
    LPCTSTR component,
    UINT    operation,
    DWORD  *val
    )
{
    HKEY hkey;
    LONG rc;
    DWORD dw;
    DWORD size;

    sapiAssert(val);

    rc = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szSubcompList,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (operation == infQuery) ? KEY_QUERY_VALUE : KEY_SET_VALUE,
            NULL,
            &hkey,
            &dw
            );

    if (rc != ERROR_SUCCESS)
        return rc;

    switch (operation) {

    case infQuery:
        rc = RegQueryValueEx(hkey, component, NULL, &dw, (LPBYTE)val, &size);
        if (rc == ERROR_FILE_NOT_FOUND) {
            *val = 0;
            rc = ERROR_SUCCESS;
        }
        break;

    case infSet:
        if (*val == SELSTATE_NO || *val == SELSTATE_YES) {
            dw = (*val == SELSTATE_NO) ? 0 : 1;
            rc = RegSetValueEx(hkey, component, 0, REG_DWORD, (CONST BYTE *)&dw, sizeof(DWORD));
            break;
        }
        // pass through

    default:
        rc = ERROR_INVALID_PARAMETER;
        break;
    }

    RegCloseKey(hkey);

    *val = (*val == 0) ? SELSTATE_NO : SELSTATE_YES;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ansi\precomp.h ===
#include "oc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_INITIALIZING                1
#define IDS_BUILDINGCOPYLIST            2
#define IDS_PREPARING                   3
#define IDS_PREQUEUECONFIG				4
#define IDS_FILEOPS						5
#define IDS_COPYING                     6
#define	IDS_RENAME						7
#define	IDS_DELETING					8
#define IDS_CONFIGURING                 9
#define IDS_MB_AND_TENTHS               10
#define IDS_EXTERNAL_INST               11
#define IDS_EXTERNAL_UNINST             12
#define IDS_EXTERNAL_SETUP              13
#define IDS_SETUP                       14
#define IDS_EXTERNAL_UPGRADE            15
#define IDS_EXTERNAL_EXAMINE            16
#define IDS_SUBCOMP_OF                  17
#define IDS_INSTALL_FORMAT              18
#define IDS_CONFIGURE_FORMAT            19
#define IDS_OCM_DESCRIPTION             20
#define IDS_FILESCAN                    21
#define IDS_OCM_WINDOWTITLE             22

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\ocwizard.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocwizard.c

Abstract:

    Routines to query wizard pages from OC DLLs and manage the results.

    No wizard is actually displayed by this routine -- that is up to
    whoever links to the OC Manager common library.

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


UINT
OcGetWizardPages(
    IN  PVOID                OcManagerContext,
    OUT PSETUP_REQUEST_PAGES Pages[WizPagesTypeMax]
    )

/*++

Routine Description:

    Request wizard pages from OC DLL's, according to ordering and omission
    rules specified in the master OC inf.

    Pages are returned in the form of wizard page handles in SETUP_REQUEST_PAGES
    data structures.

Arguments:

    OcManagerContext - supplies OC Manager context structure, returned by
        OcInitialize().

    Pages - points to a block of memory that can hold WizPagesTypeMax pointers to
        SETUP_REQUEST_PAGES structures. On successful completion, that array is
        filled in with such pointers.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    WizardPagesType PageType;
    UINT n;
    LONG Id;
    UINT e,ErrorCode;
    POC_MANAGER OcManager;
    PSETUP_REQUEST_PAGES p,pages;
    OPTIONAL_COMPONENT Component;

    //
    // The context actually points at the OC_MANAGER structure.
    //
    OcManager = OcManagerContext;

    //
    // The ordering arrays for each wizard page type are
    // stored away for us in the OC_MANAGER data structure.
    //
    ErrorCode = NO_ERROR;
    for(PageType=0; PageType<WizPagesTypeMax; PageType++) {
        //
        // Allocate an empty list of pages for this page type.
        //
        Pages[PageType] = pSetupMalloc(offsetof(SETUP_REQUEST_PAGES,Pages));
        if(Pages[PageType]) {

            Pages[PageType]->MaxPages = 0;

            for(n=0;
                   (n < OcManager->TopLevelOcCount)
                && ((Id = OcManager->WizardPagesOrder[PageType][n]) != -1);
                n++)
            {

                //
                // Call the component and ask for its pages of the current type.
                // If this succeeds, merge the pages of this type from the
                // component into the master list for this component.
                //

                pSetupStringTableGetExtraData(
                        OcManager->ComponentStringTable,
                        Id,
                        &Component,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if ((Component.InternalFlags & OCFLAG_NOWIZARDPAGES) == 0) {

                    e = OcInterfaceRequestPages(OcManager,Id,PageType,&pages);
                    if(e == NO_ERROR) {

                        p = pSetupRealloc(
                                Pages[PageType],
                                  offsetof(SETUP_REQUEST_PAGES,Pages)
                                + ((Pages[PageType]->MaxPages + pages->MaxPages) * sizeof(HPROPSHEETPAGE))
                                );

                        if(p) {
                            Pages[PageType] = p;

                            CopyMemory(
                                &p->Pages[p->MaxPages],
                                pages->Pages,
                                pages->MaxPages * sizeof(HPROPSHEETPAGE)
                                );

                            Pages[PageType]->MaxPages += pages->MaxPages;

                            pSetupFree(pages);

                        } else {
                            e = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                } else {
                    e = NO_ERROR;
                }

                if (e == ERROR_CALL_COMPONENT) {
                    continue;   // could be a dead component, just go on
                }

                if((e != NO_ERROR) && (ErrorCode == NO_ERROR)) {
                    ErrorCode = e;
                }
            }
        } else {
            if(ErrorCode == NO_ERROR) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    // set flag if there are no pages before the oc page

    if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
        if (!Pages[WizPagesWelcome]->MaxPages
                && !Pages[WizPagesMode]->MaxPages) {
            OcManager->InternalFlags |= OCMFLAG_NOPREOCPAGES;
        }
    }

    return(ErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\unicode\precomp.h ===
#include "oc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\ieharden.cpp ===
// This file specilizes two function for IEHardUser subcomponent.
// the change basically takes care of exclusion cases with TS.
// 1) when the IEHardUser component is installed the 1st time, this change will turn if off, if termsrv is also being installed.
// 2) 2nd change in query selection of IeHardenUser, this change will prompt user about the incompatibility.
//


#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include "ocgen.h"


const TCHAR TERMINAL_SERVER_COMPONENT[] = TEXT("TerminalServer");
const TCHAR IEHARDEN_USER_SUBCOMPONENT[] = TEXT("IEHardenUser");
const TCHAR IEHARDEN_COMPONENT[] = TEXT("IEHarden");

PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId);

/*
*  Defaults for IEharduser as decided by Mode=... in ieharden.inf files are ON for all installations.
*  it means, the component will be ON for all configs.
*  But TerminalServer really want this component to be off, if terminal server is selected.
*  Here is a matrix for this component

    if (was installed previously)
    {
        // keep the original setting. goto Done.

        Q:Do we need to turn it off if TS is selected through AnswerFile?
    }
    else
    {
        if (Attended Setup)
        {
            //
            // we cant do much in this case. as administrator can decide for himself this component's setting.
            // terminal will just warn him about the recommended setting for this component.
            //
        }
        else
        {
            //
            // if this is fresh install for this component (this is new compoent)
            // we have to choose defaults depending on the terminal server state.
            //

            if (Terminal server is going to be installed / or retained)
            {
                // our defaults for this component is OFF.
            }
            else
            {
                // let ocmanager choose the defaults per inf file of this component

            }
        }

    }
*
*
*
*   here we apply all the logic above in query state.
*
*/

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, UINT textID, UINT captioniID, UINT type, ... );
BOOL ReadStringFromAnsewerFile (LPCTSTR ComponentId, LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue, DWORD dwBufferSize)
{
    assert(szSection);
    assert(szKey);
    assert(szValue);
    assert(dwBufferSize > 0);

    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return FALSE;



    HINF hInf = cd->HelperRoutines.GetInfHandle(INFINDEX_UNATTENDED,cd->HelperRoutines.OcManagerContext);

    if (hInf)
    {
        INFCONTEXT InfContext;
        if (SetupFindFirstLine(hInf, szSection, szKey, &InfContext))
        {
            return SetupGetStringField (&InfContext, 1, szValue, dwBufferSize, NULL);
        }
    }
    return FALSE;
}

BOOL StateSpecifiedInAnswerFile(LPCTSTR ComponentId, LPCTSTR SubcomponentId, BOOL *pbState)
{
    TCHAR szBuffer[256];
    if (ReadStringFromAnsewerFile(ComponentId, _T("Components"), SubcomponentId, szBuffer, 256))
    {
        *pbState = (0 == _tcsicmp(_T("on"), szBuffer));
        return TRUE;
    }
    return FALSE;
}


BOOL IsNewComponent(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    static BOOL sbNewComponent = TRUE;
    static BOOL sbCalledOnce = FALSE;

    DWORD dwError, Type;

    HKEY hKey;
    if (!sbCalledOnce)
    {
        sbCalledOnce = TRUE;

        if (NO_ERROR == (dwError = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents"),
            0,
            KEY_QUERY_VALUE,
            &hKey)))
        {

            DWORD dwInstalled;
            DWORD dwBufferSize = sizeof (dwInstalled);
            dwError = RegQueryValueEx(
                            hKey,
                            SubcomponentId,
                            NULL,
                            &Type,
                            (LPBYTE)&dwInstalled,
                            &dwBufferSize);

            if (dwError == NOERROR)
            {
                //
                // since the registry already exists for this.
                // this is not a new component.
                //
                sbNewComponent = FALSE;
            }

            RegCloseKey(hKey);
        }
    }

    return sbNewComponent;
}

BOOL IsTerminalServerGettingInstalled(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return FALSE;

     return(
        cd->HelperRoutines.QuerySelectionState(
        cd->HelperRoutines.OcManagerContext,
        TERMINAL_SERVER_COMPONENT,
        OCSELSTATETYPE_CURRENT
        )
        );

}

BOOL IsStandAlone(LPCTSTR ComponentId)
{

    PPER_COMPONENT_DATA cd;
    if (!(cd = LocateComponent(ComponentId)))
        return FALSE;

    return (cd->Flags & SETUPOP_STANDALONE ? TRUE : FALSE);
}

DWORD OnQueryStateIEHardenUser(
                   LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    BOOL bState;


    switch (state)
    {
    case OCSELSTATETYPE_ORIGINAL:
    case OCSELSTATETYPE_FINAL:
        return SubcompUseOcManagerDefault;
        break;


    case OCSELSTATETYPE_CURRENT:
        log(_T("makarp:OnQueryStateIEHardenUser:OCSELSTATETYPE_CURRENT\n"));
        //
        // if this is not the first time installation of this component let OCM decide.
        //
        if (!IsNewComponent(ComponentId, SubcomponentId))
        {
            log(_T("makarp:OnQueryStateIEHardenUser: it's not a newcomp. returning\n"));

            return SubcompUseOcManagerDefault;
        }

        //
        // if admin explicitely choose state in answer file, respect that.
        //
        if (StateSpecifiedInAnswerFile(ComponentId, SubcomponentId, &bState))
        {
            log(_T("makarp:OnQueryStateIEHardenUser: state is specified in anserer file(%s). returning\n"), bState? _T("On") : _T("Off"));
            return SubcompUseOcManagerDefault;
        }


        //
        // if terminal server is not selected, let OCM decide.
        //
        if (!IsTerminalServerGettingInstalled(ComponentId))
        {
            log(_T("makarp:OnQueryStateIEHardenUser: ts comp is not on selected, returning\n"));
            return SubcompUseOcManagerDefault;
        }


        if (IsStandAlone(ComponentId))
        {
            log(_T("makarp:its standalone\n"));
            assert(FALSE); // if its add remove program setup, this cannot be NewComponent
            return SubcompUseOcManagerDefault;
        }


        log(_T("makarp:OnQueryStateIEHardenUser: this the case we want to catch - returning SubcompOff\n"));
        return SubcompOff;

    default:
        assert(FALSE);
        return ERROR_BAD_ARGUMENTS;
    }

}

DWORD OnQuerySelStateChangeIEHardenUser(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{
    HWND hWnd;
    PPER_COMPONENT_DATA cd;
    BOOL bDirectSelection = flags & OCQ_ACTUAL_SELECTION;


    //
    // if the component is not turning on as a result of selection, we dont care
    //
    if (!state)
    {
        log(_T("makarp:OnQuerySelStateChangeIEHardenUser: new state is off, returning\n"));
        return TRUE;
    }

    //
    //  TerminalServer is not recommended with IEHardUser component. Lets notify user about it.
    //

    if (!(cd = LocateComponent(ComponentId)))
    {
        log(_T("makarp:OnQuerySelStateChangeIEHardenUser: LocateComponentit failed, returning\n"));
        return TRUE;    // if we fail to load this, just let selection go through.
    }


    if (!IsTerminalServerGettingInstalled(ComponentId))
    {
        //
        // if terminal server component is not getting installed, then its ok.
        //
        log(_T("makarp:OnQuerySelStateChangeIEHardenUser: TS is not selected, returning\n"));
        return TRUE;
    }

    hWnd = cd->HelperRoutines.QueryWizardDialogHandle(cd->HelperRoutines.OcManagerContext);

    // HACK...
    // For some weird reasons we get called twice if the selection comes from top level component.
    // we dont want to shot the message box twice though. the hacky fix i found was to always skip the 1st message we get
    // and return TRUE TO IT. we will subsequently get one more message, show messagebox on the 2nd message and return the real
    // value.
    //

    static BOOL sbSkipNextMessage = true;

    if (sbSkipNextMessage)
    {
        log(_T("DirectSelection = %s, SKIPPING true\n"), bDirectSelection ? _T("true") : _T("false"));
        sbSkipNextMessage = false;
        return TRUE;

    }
    sbSkipNextMessage = true;



    //
    // information about exclusion
    // IDS_IEHARD_EXCLUDES_TS          "Internet Explorer Enhanced Security for Users on a Terminal Server will substantially limit the users ability to browse the internet from their Terminal Server sessions\n\nContinue the install with this combination?"
    //
    int iMsg = MsgBox(hWnd, IDS_IEHARD_EXCLUDES_TS, IDS_DIALOG_CAPTION_CONFIG_WARN, MB_YESNO | MB_ICONEXCLAMATION);

    if (iMsg == IDYES)
    {
        log(_T("DirectSelection = %s, returning true\n"), bDirectSelection ? _T("true") : _T("false"));
        return TRUE;
    }
    else
    {
        log(_T("DirectSelection = %s, returning false\n"), bDirectSelection ? _T("true") : _T("false"));
        return FALSE;
    }


    assert(false);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\common\sources.inc ===
MAJORCOMP=ocmanage

!include $(PROJECT_ROOT)\ntsetup\sources.inc

TARGETPATH=..\..\$(_OBJ_DIR)
TARGETTYPE=DYNLINK

INCLUDES=..;..\..\inc;$(WINDOWS_INC_PATH);$(BASE_INC_PATH)



DLLDEF=..\ocmanage.def
DLLENTRY=_DllMainCRTStartup

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

SOURCES=\
        ..\dll.c        \
        ..\msg.mc       \
        ..\oc.rc        \
        ..\ocdskspc.c   \
        ..\ochelper.c   \
        ..\ocinterf.c   \
        ..\ocmanage.c   \
        ..\ocmisc.c     \
        ..\ocpage.c     \
        ..\ocsetup.c    \
        ..\ocstalon.c   \
        ..\ocstate.c    \
        ..\ocwizard.c

TARGETLIBS= \
         $(SDK_LIB_PATH)\user32.lib         \
         $(SDK_LIB_PATH)\gdi32.lib          \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
!if $(PRERELEASE)
         $(SDK_LIB_PATH)\ole32.lib          \
!endif
         $(BASE_LIB_PATH)\spapip.lib
         

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

LINKER_FLAGS=/SWAPRUN:CD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\ocgen.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OCGEN_CPP_
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include "ocgen.h"
#pragma hdrstop

// also referred to in ocgen.h        // forward reference

DWORD OnPreinitialize();
DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD OnSetLanguage();
DWORD_PTR OnQueryImage();
DWORD OnSetupRequestPages(UINT type, PVOID srp);
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue();
DWORD OnQueryStepCount();
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnCleanup();
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnNeedMedia();
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage();
DWORD OnWizardCreated();
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId);
PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId);
VOID  RemoveComponent(LPCTSTR ComponentId);
BOOL  StateInfo(PPER_COMPONENT_DATA cd, LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);

DWORD OnQuerySelStateChangeIEHardenUser(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags);

DWORD OnQueryStateIEHardenUser(
                   LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state);


// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;

PPER_COMPONENT_DATA _cd;

void av()
{
    _cd = NULL;
    _cd->hinf = NULL;
}


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}


DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(Param1, Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;

    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount();
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = OnCleanup();
        break;

    case OC_QUERY_STATE:
    rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;

    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/


/* OnPreinitialize()
 *
 * handler for OC_PREINITIALIZE
 */

DWORD
OnPreinitialize(
    VOID
    )
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
}

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

 // assert(0);
 // av();

    // add component to linked list

    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle

    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf

    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags

    cd->HelperRoutines = psc->HelperRoutines;

    cd->Flags = psc->SetupData.OperationFlags;

    cd->SourcePath = NULL;

#if 0
    // Setup the SourcePath.  Read inf and see if we should use the NT setup source.
    // If so, set to null and setupapi will take care of this for us.  If there is
    // something specified in the inf, use it, otherwise use what is passed to us.

    *buf = 0;
    rc = SetupFindFirstLine(cd->hinf,
                            ComponentId,
                            KEYWORD_SOURCEPATH,
                            &context);

    if (rc) {

        rc = SetupGetStringField(&context,
                                 1,
                                 buf,
                                 sizeof(buf) / sizeof(TCHAR),
                                 NULL);

    }

    if (!_tcsicmp(buf, KEYVAL_SYSTEMSRC)) {

        cd->SourcePath = NULL;

    } else {

        cd->SourcePath = (TCHAR *)LocalAlloc(LMEM_FIXED, SBUF_SIZE);
        if (!cd->SourcePath)
            return ERROR_CANCELLED;

        if (!*buf)
            _tcscpy(cd->SourcePath, psc->SetupData.SourcePath);
        else
            ExpandEnvironmentStrings(buf, cd->SourcePath, S_SIZE);
    }

#endif

    // play

    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD OnSetLanguage()
{
    return false;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}

/*
 * OnSetupRequestPages
 *
 * Prepares wizard pages and returns them to the OC Manager
 */

DWORD OnSetupRequestPages(UINT type, PVOID srp)
{
    return 0;
}

/*
 * OnWizardCreated()
 */

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*
 * OnQuerySkipPage()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySkipPage()
{
    return false;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{
    /*
     * IEHarden/IEHardenUser component has some dependancies with TS.
     * Lets handle this subcomp in a seperate function.
     */
    if (SubcomponentId && !_tcsicmp(SubcomponentId, TEXT("IEHardenUser")))
    {
        assert(_tcsicmp(ComponentId, TEXT("IEHarden")) == 0);
        return OnQuerySelStateChangeIEHardenUser(ComponentId, SubcomponentId, state, flags);
    }

    DWORD rc = true;

#if 0
//  if (!(flags & OCQ_ACTUAL_SELECTION)) {
        if (!_tcsicmp(SubcomponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(SubcomponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
//  }
#endif


    if (!rc && (flags & OCQ_ACTUAL_SELECTION))
        MessageBeep(MB_ICONEXCLAMATION);


    return rc;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    _tcscpy(section, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    cd->queue = queue;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(cd->hinf, section, 0);
        SetupInstallFromInfSection(NULL,cd->hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);        
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(cd->hinf,
                                             NULL,
                                             queue,
                                             section,
                                             cd->SourcePath,
                                             state ? SP_COPY_NEWER : 0);
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnNotificationFromQueue()
 *
 * handler for OC_NOTIFICATION_FROM_QUEUE
 *
 * NOTE: although this notification is defined,
 * it is currently unimplemented in oc manager
 */

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*
 * OnQueryStepCount
 *
 * handler forOC_QUERY_STEP_COUNT
 */

DWORD OnQueryStepCount()
{
    return 2;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) {
        //
        // installation
        //

        if (rc) {
            // process the inf file
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            cd->hinf,                            // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct
    
            if (rc) {
                rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);
                Error = GetLastError();        
            
                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }
            
                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(cd, section, state);            
                }
            }
        }

    } else { 
        
        //
        // uninstallation
        //
    
        if (rc)
        {

            rc = RunExternalProgram(cd, section, state);

        }
        if (rc) {
            
            rc = CleanupNetShares(cd, section, state);

        }
    }

    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}

/*
 * OnCleanup()
 *
 * handler for OC_CLEANUP
 */

DWORD OnCleanup()
{
    return NO_ERROR;
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    PPER_COMPONENT_DATA cd;

#if 0
    if (!_tcsicmp(SubcomponentId, TEXT("alone2"))
            || !_tcsicmp(ComponentId, TEXT("alone2"))) {
        if (state == OCSELSTATETYPE_CURRENT) {
            if (!_tcsicmp(SubcomponentId, TEXT("alone2"))) {
                return SubcompOff;
            }
        }
    }
#endif
#if 0
	if (state == OCSELSTATETYPE_FINAL) {
        if (!_tcsicmp(SubcomponentId, TEXT("four"))) {
            tmbox(SubcomponentId);
        }
    }
#endif


    /*
     * IEHarden/IEHardenUser component has some dependancies with TS.
     * Lets handle this subcomp in a seperate function.
     */
    if (SubcomponentId && !_tcsicmp(SubcomponentId, TEXT("IEHardenUser")))
    {
        assert(_tcsicmp(ComponentId, TEXT("IEHarden")) == 0);
        log(_T("makarp:Entering OnQueryStateIEHardenUser, Component=%s, SubComponent=%s, State=%d\n"), ComponentId, SubcomponentId, state);
        return OnQueryStateIEHardenUser(ComponentId, SubcomponentId, state);
    }

    return SubcompUseOcManagerDefault;
}

/*
 * OnNeedMedia()
 *
 * handler for OC_NEED_MEDIA
 */

DWORD OnNeedMedia()
{
    return false;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    //
    // only do stuff on uninstall
    //
    if (state) {
        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    cd->hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    if (rc) 
        rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);

    if (rc) {
        rc = SetupInstallFromInfSection(
                    NULL,
                    cd->hinf,
                    section,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
    }
    
    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        _tcscpy((TCHAR *)data->ComponentId, ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}

/*
 * RemoveComponent()
 *
 * yanks a component from our linked list of components
 */

VOID RemoveComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p, prev;

    for (prev = NULL, p = gcd; p; prev = p, p = p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
        {
            LocalFree((HLOCAL)p->ComponentId);

            if (p->SourcePath)
                LocalFree((HLOCAL)p->SourcePath);

            if (prev)
                prev->Next = p->Next;
            else
                gcd = p->Next;

            LocalFree((HLOCAL)p);

            return;
        }
    }
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

	// otherwise, check for a change in installation state
		
    *state = cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);

    if (*state == cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                         SubcomponentId,
                                                         OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

	// if this is gui mode setup, presume the state has changed to force
	// an installation (or uninstallation)

	if (!(cd->Flags & SETUPOP_STANDALONE) && *state)
		rc = TRUE;

    return rc;
}

#if 0

//
// Andrewr -- get rid of RegisterServices and RegisterServers and have the oc gen component use setupapi instead.
//            this reduces the amount of redundant code
//

DWORD RegisterServices(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    SC_HANDLE   schSystem;

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if ( !schSystem ) {
        DWORD dwError = GetLastError( );

        if( !IsNT() && ( ERROR_CALL_NOT_IMPLEMENTED == dwError ) )
        {
            return( NO_ERROR );
        }
        else
        {
            return( dwError );
        }
    }

    if (state) {
        keyword = KEYWORD_ADDSERVICE;
    } else {
        keyword = KEYWORD_DELSERVICE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        SC_HANDLE   schService;

        CHAR Temp[SBUF_SIZE];
        TCHAR ServiceName[ SBUF_SIZE ];
        TCHAR DisplayName[ SBUF_SIZE ];
        DWORD ServiceType;
        DWORD StartType;
        DWORD ErrorControl;
        TCHAR ImagePath[ SBUF_SIZE ];
        TCHAR LoadOrder[ SBUF_SIZE ];
        TCHAR Dependencies[ SBUF_SIZE ];
        TCHAR StartName[ SBUF_SIZE ];
        TCHAR Password[ SBUF_SIZE ];

        BOOL fDisplayName  = FALSE;
        BOOL fServiceType  = FALSE;
        BOOL fStartType    = FALSE;
        BOOL fErrorControl = FALSE;
        BOOL fLoadOrder    = FALSE;
        BOOL fDependencies = FALSE;
        BOOL fStartName    = FALSE;
        BOOL fPassword     = FALSE;
        BOOL fDontReboot   = FALSE;

        //
        // Must have ServiceName
        //
        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ServiceName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTTYPE, &sic))
        {
            if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
            {
                StartType = atoi( Temp );
                fStartType = TRUE;
            }
        }

        if ( state )
        {
            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DISPLAYNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, DisplayName, SBUF_SIZE, NULL))
                {
                    fDisplayName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICETYPE, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ServiceType = atoi( Temp );
                    fServiceType = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_ERRORCONTROL, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ErrorControl = atoi( Temp );
                    fErrorControl = TRUE;
                }
            }

            //
            // Must have ImagePath
            //
            if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_IMAGEPATH, &sic))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (!SetupGetStringField(&sic, 1, ImagePath, SBUF_SIZE, NULL))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_LOADORDER, &sic))
            {
                if (SetupGetStringField(&sic, 1, LoadOrder, SBUF_SIZE, NULL))
                {
                    fLoadOrder = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DEPENDENCIES, &sic))
            {
                if (SetupGetStringField(&sic, 1, Dependencies, SBUF_SIZE-1, NULL))
                {
                    LPTSTR psz = Dependencies;
                    // needs to be a double-null terminated string
                    Dependencies[ lstrlen(Dependencies) + 1] = TEXT('\0');

                    // change commas into NULL characters
                    while ( *psz )
                    {
                        if ( *psz == TEXT(',') )
                        {
                            *psz = TEXT('\0');
                        }
                        psz++;
                    }
                    fDependencies = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, StartName, SBUF_SIZE, NULL))
                {
                    fStartName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_PASSWORD, &sic))
            {
                if (SetupGetStringField(&sic, 1, Password, SBUF_SIZE, NULL))
                {
                    fPassword = TRUE;
                }
            }

            schService = CreateService(
                        schSystem,
                        ServiceName,
                        ( fDisplayName == TRUE  ? DisplayName   : ServiceName ),
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        ( fServiceType == TRUE  ? ServiceType   : SERVICE_WIN32_OWN_PROCESS),
                        ( fStartType == TRUE    ? StartType     : SERVICE_AUTO_START),
                        ( fErrorControl == TRUE ? ErrorControl  : SERVICE_ERROR_NORMAL),
                        ImagePath,
                        (fLoadOrder == TRUE     ? LoadOrder     : NULL),
                        NULL,   // tag id
                        ( fDependencies == TRUE ? Dependencies  : NULL ),
                        ( fStartName == TRUE    ? StartName     : NULL),
                        ( fPassword == TRUE     ? Password      : NULL ));

            if ( !schService )
            {
                DWORD Error = GetLastError( );
                log( TEXT("OCGEN: CreateService() error 0x%08x\r\n"), Error );
                return Error;
            }

            if ( (!fStartType)
               || ( fStartType && StartType == SERVICE_AUTO_START ))
            {
                if( !StartService( schService, 0, NULL ) )
                {
                    DWORD Error = GetLastError( );
                    switch ( Error )
                    {
                    case ERROR_SERVICE_EXISTS:
                        {
                            log( TEXT("OCGEN: %s was already exists.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    case ERROR_SERVICE_ALREADY_RUNNING:
                        {
                            log( TEXT("OCGEN: %s was already started.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    default:
                        log( TEXT("OCGEN: StartService() error 0x%08x\r\n"), Error );
                        return Error;
                    }
                }
            }
        }
        else
        {
            schService = OpenService( schSystem,
                                      ServiceName,
                                      STANDARD_RIGHTS_REQUIRED | DELETE );
            if ( schService )
            {
                SERVICE_STATUS ss;
                DeleteService( schService );
                ControlService( schService, SERVICE_CONTROL_STOP, &ss );
            }

        }

        //
        // BOOT drivers require a reboot unless they were already started.
        //
        if ( schService
           && fStartType && StartType == SERVICE_BOOT_START
           && fDontReboot == FALSE)
        {
            cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext, NULL);
        }

        if ( schService )
        {
            CloseServiceHandle( schService );
        }
    }

    return NO_ERROR;
}
#endif
#if 0

DWORD
RegisterServers(
    HINF    hinf,
    LPCTSTR component,
    DWORD   state
    )
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    LPCSTR      routine;

    CoInitialize(NULL);

    if (state) {
        keyword = KEYWORD_REGSVR;
        routine = (LPCSTR)gszRegisterSvrRoutine;
    } else {
        keyword = KEYWORD_UNREGSVR;
        routine = (LPCSTR)gszUnregisterSvrRoutine;
    }

    for (section = 1;
         EnumSections(hinf, component, keyword, section, &ic, sname);
         section++)
    {
        if (!SetupGetTargetPath(hinf, NULL, sname, path, sizeof(path), &size))
            continue;
        PathAddBackslash(path);

        do {
            // get fully qualified path to dll to register

            if (!SetupGetStringField(&ic, 0, buf, sizeof(buf)/sizeof(buf[0]), NULL))
                continue;

            _tcscpy(file, path);
            _tcscat(file, buf);

            // call the dll's RegisterServer routine

            if (!(hinst = LoadLibrary(file)))
                continue;

            if (!(pfreg = (pfn)GetProcAddress(hinst, routine)))
                continue;

            hr = pfreg();
            assert(hr == NO_ERROR);

            FreeLibrary(hinst);

            // on to the next

        } while (SetupFindNextLine(&ic, &ic));
    }

	CoUninitialize();

    return TRUE;
}
#endif

                                          /*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, sizeof(section)/sizeof(section[0]), NULL))
        return 0;

    if (name)
        _tcscpy(name, section);

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    assert(cd->ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    _tcscpy(fmt, TEXT("%s: %s"));

    return cd->ExtraRoutines.LogError(cd->HelperRoutines.OcManagerContext,
                                      level,
                                      fmt,
                                      ComponentId,
                                      sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("OCGEN: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("OCGEN: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("OCGEN: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("OCGEN: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("OCGEN: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Pat Styles (patst)  Jan-20-1998

!ENDIF

INCLUDES=..;..\..\inc;..\..\..\inc

MAJORCOMP=ocgen

TARGETPATH=..\..\obj
TARGETTYPE=DYNLINK

DLLDEF=..\ocgen.def
DLLENTRY=DllMain
USE_MSVCRT=1

SOURCES=            \
  ..\ieharden.cpp   \
  ..\ocgen.cpp      \
  ..\util.cpp       \
  ..\ocgen.rc

TARGETLIBS=$(SDK_LIB_PATH)\user32.lib       \
         $(SDK_LIB_PATH)\gdi32.lib          \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
         $(SDK_LIB_PATH)\comctl32.lib       \
         $(SDK_LIB_PATH)\ole32.lib          \
         $(SDK_LIB_PATH)\shlwapi.lib        \
         $(SDK_LIB_PATH)\netapi32.lib       \
         $(SDK_LIB_PATH)\setupapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\util.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Pat Styles (patst) 25-March-1997
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "ocgen.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[OCGEN] ");

// for logging

#define gsLogFile           TEXT("%windir%\\ocgen.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: OCGEN.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    wsprintf(desc, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    _stprintf(buf, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            _tcscpy( caption, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( format, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    tvsprintf(text, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, UINT textID, UINT captioniID, UINT type, ... )
{
    TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    len = LoadString(ghinst, captioniID, caption, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( caption, TEXT("Setup"));
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( format, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    tvsprintf(text, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(hwnd && text && caption && type);

    va_start(vaList, type);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    sprintf(output, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH];
    TCHAR  text[S_SIZE];
    char   output[S_SIZE];
    DWORD  bytes;
    HANDLE hfile;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void AssureTrailingBackslash(TCHAR *path)
{
    TCHAR *p;
    
    assert(path && *path);

    p = path + _tcslen(path) - 1;
    if (*p != TEXT('\\'))
        _tcscat(path, TEXT("\\"));
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for ocgen.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1
#define IDS_IEHARD_EXCLUDES_TS  2
#define IDS_DIALOG_CAPTION_CONFIG_WARN 3

// !!! WARNING !!! Don't change the resource ID, unless you
// also change the corresponding ID in the affected INF files.
// 
#define IDB_ROOT_AUTO_UPDATE                  1001      // DSIE: Bitmap ID for RootAU.INF
#define IDB_ROOT_IE                           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_ERROR                       1
#define IDS_WINNT_SETUP                 2
#define IDS_WIN9X_SETUP                 3
#define IDS_OCPAGE_HEADER               4
#define IDS_OCPAGE_SUBHEAD              5
#define IDS_PROGPAGE_HEADER             6
#define IDS_PROGPAGE_SUBHEAD            7
#define IDS_FINAL_HEADER                8
#define IDS_FINAL_SUBHEAD               9
#define IDS_LOGSEVINFO                  10
#define IDS_LOGSEVWARN                  11
#define IDS_LOGSEVERR                   12
#define IDS_LOGSEVFATAL                 13
#define IDS_SETUP                       14
#define IDD_OC_WIZARD_PAGE              101
#define IDT_COMPONENTS                  102
#define IDI_SETUP                       103
#define IDT_INSTRUCTIONS                103
#define IDT_SELECT_COMPONENTS           104
#define IDD_OC_DETAILS_PAGE             104
#define IDT_SPACE_NEEDED_NUM            105
#define IDD_PROGRESS_PAGE               105
#define IDT_SPACE_AVAIL_NUM             106
#define IDD_FINAL                       106
#define IDT_TIP                         107
#define IDT_INSTALLED_COUNT             108
#define IDA_FILECOPY                    108
#define IDD_STARTING                    110
#define IDD_FINISHING                   111
#define IDB_WATERMARK1_16               112
#define IDB_WATERMARK1_256              113
#define IDB_WELCOME                     114
#define IDC_LISTVIEW                    1000
#define IDB_DETAILS                     1001
#define IDB_RESET                       1003
#define IDC_BUTTON1                     1005
#define IDC_LISTBOX                     1006
#define IDC_PROGRESS                    1009
#define IDA_EXTERNAL_PROGRAM            1010
#define IDT_SUBHEAD                     1013
#define IDT_COMP_TITLE                  1014
#define IDT_THERM_LABEL                 1015
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\log.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Routines for logging actions performed during setup.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

      
#include <tchar.h>
#if 0
#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#endif
#include "setuplog.h"

//
// Severity descriptions. Initialized in InitializeSetupActionLog.
//
PCSTR SeverityDescriptions[LogSevMaximum];

//
// Constant strings used for logging in various places.
//
PCWSTR szWaitForSingleObject        = L"WaitForSingleObject";
PCWSTR szFALSE                      = L"FALSE";
PCWSTR szSetGroupOfValues           = L"SetGroupOfValues";
PCWSTR szSetArrayToMultiSzValue     = L"SetArrayToMultiSzValue";
PCWSTR szCreateProcess              = L"CreateProcess";
PCWSTR szRegOpenKeyEx               = L"RegOpenKeyEx";
PCWSTR szRegQueryValueEx            = L"RegQueryValueEx";
PCWSTR szRegSetValueEx              = L"RegSetValueEx";
PCWSTR szDeleteFile                 = L"DeleteFile";
PCWSTR szRemoveDirectory            = L"RemoveDirectory";

LPCTSTR szErrorFilename             = TEXT("ocmerr.log");
LPCTSTR szActionFilename            = TEXT("ocmact.log");

//
// This structure is passed as the parameter to DialogBoxParam to provide
// initialization data.
//

typedef struct _LOGVIEW_DIALOG_DATA {
    PCWSTR  LogFileName;                        // actual file used
    PCWSTR  WindowHeading;                      // actual title of main window
} LOGVIEW_DIALOG_DATA, *PLOGVIEW_DIALOG_DATA;


LPTSTR
RetrieveAndFormatMessageV(
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    IN va_list  *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    LPTSTR Buffer;
    LPTSTR Message;
    TCHAR ModuleName[MAX_PATH];
    TCHAR ErrorNumber[24];
    PTCHAR p;
    LPTSTR Args[2];

    if(MessageString > SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (LPTSTR)&Buffer,
                0,
                ArgumentList
                );
    } else {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    ((MessageId < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE),
                (PVOID)hInst,
                MessageId,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR)&Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber, TEXT("%x"), MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(hInst, ModuleName, MAX_PATH)) {
            if(p = _tcschr(ModuleName, TEXT('\\'))) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}

LPTSTR
RetrieveAndFormatMessage(
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    LPTSTR p;

    va_start(arglist,MessageId);
    p = RetrieveAndFormatMessageV(MessageString,MessageId,&arglist);
    va_end(arglist);

    return(p);
}

static PVOID
pOpenFileCallback(
    IN  PCTSTR  Filename,
    IN  BOOL    WipeLogFile
    )
{
    TCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile.
    //
    GetWindowsDirectory(CompleteFilename,MAX_PATH);
    ConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}

static BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

#ifdef UNICODE
    if(AnsiBuffer = UnicodeToAnsi (Buffer)) {
#else
    if (AnsiBuffer = Buffer) {
#endif
        SetFilePointer (LogFile, 0, NULL, FILE_END);

        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    return Status;

}

static BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}


LPCTSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    TCHAR Buffer[4096];
    UINT Length;

    Length = LoadString(hInst,StringId,Buffer,sizeof(Buffer)/sizeof(TCHAR));
    if(!Length) {
        Buffer[0] = 0;
    }

    return(DuplicateString(Buffer));
}


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = MyMalloc;
    Context->FreeMem = MyFree;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;
    Context->Lock = pAcquireMutex;
    Context->Unlock = ReleaseMutex;

    Context->Mutex = CreateMutex(NULL,FALSE,TEXT("SetuplogMutex"));

    //
    // Initialize the log severity descriptions.
    //
    for(i=0; i < LogSevMaximum; i++) {
        Context->SeverityDescriptions[i] = MyLoadString(IDS_LOGSEVINFO+i);
    }

    SetuplogInitializeEx(Context,
                         FALSE,
                         szActionFilename,
                         szErrorFilename,
                         0,
                         0);
    
    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_START,
        0,0);

}

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

    Close the Setup log and free resources.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    None.

--*/

{
    UINT    i;

    if(Context->Mutex) {
        CloseHandle(Context->Mutex);
        Context->Mutex = NULL;
    }

    for (i=0; i<LogSevMaximum; i++) {
        if (Context->SeverityDescriptions[i]) {
            MyFree (Context->SeverityDescriptions[i]);
        }
    }

    SetuplogTerminate();
}



// all this stuff is from syssetup's setuplog code


#if 0

DWORD CALLBACK
EditStreamCallback (
    IN HANDLE   hLogFile,
    IN LPBYTE   Buffer,
    IN LONG     cb,
    IN PLONG    pcb
    )

/*++

Routine Description:

    Callback routine used by the rich edit control to read in the log file.

Arguments:

    hLogFile - handle of file to read.  This module provides the value through
        the EDITSTREAM structure.

    Buffer - address of buffer that receives the data

    cb - number of bytes to read

    pcb - address of number of bytes actually read

Return Value:

    0 to continue the stream operation, or nonzero to abort it.

--*/

{
    DWORD error;

    if (!ReadFile (hLogFile, Buffer, cb, pcb, NULL)) {
        error = GetLastError();
        return error;
    }

    return 0;
}

BOOL
FormatText (
    IN HWND hWndRichEdit
    )

/*++

Routine Description:

    Modify the contents of the rich edit control to make the log file look
    prettier.  The modifications are driven by the array FormatStrings.  It
    contains a list of strings to search for, and modifications to make when
    a target string is found.

Arguments:

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{

    //
    // separate items in the log with a horizontal line
    //

    PCWSTR      NewTerm = L"----------------------------------------"
        L"----------------------------------------\r\n\r\n";

    FINDTEXT    FindText;       // target text to change
    INT         Position;       // start of where target was found
    INT         LineIndex;      // index of line containing target
    CHARRANGE   SelectRange;    // range where target was found
    CHARFORMAT  NewFormat;      // structure to hold our format changes
    INT         i;              // loop counter
    PWSTR       pw;             // temporary pointer
    BOOL        Status;         // return status

    //
    // An array of changes we're going to make
    //

    struct tagFormatStrings {
        PCWSTR      Find;       // target string
        PCWSTR      Replace;    // change the target to this
        COLORREF    Color;      // make target text this color
        DWORD       Effects;    // modifications to target's font
    }
    FormatStrings[] = {
        {NULL,  NULL,   RGB(0,150,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(150,150,0), CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE|CFE_ITALIC},
        {NULL,  NULL,   RGB(0,0,255),   0}
    };

    //
    // Number of elements in FormatStrings array
    //

    #define FORMATSTRINGSCOUNT  \
        (sizeof(FormatStrings) / sizeof(struct tagFormatStrings))
    sapiAssert(FORMATSTRINGSCOUNT == LogSevMaximum + 1);


    //
    // Initialize those parts of our data structures that won't change
    //

    Status = TRUE;

    NewFormat.cbSize = sizeof(NewFormat);
    FindText.chrg.cpMax = -1;   // search to the end
    for (i=0; i<LogSevMaximum; i++) {   // load severity strings
        if (!(pw = MyLoadString (IDS_LOGSEVINFO+i))) {
            Status = FALSE;
            goto cleanup;
        }
        FormatStrings[i].Find = MyMalloc((lstrlen(pw)+4)*sizeof(WCHAR));
        if(!FormatStrings[i].Find) {
            MyFree(pw);
            Status = FALSE;
            goto cleanup;
        }
        lstrcpy ((PWSTR)FormatStrings[i].Find, pw);
        lstrcat ((PWSTR)FormatStrings[i].Find, L":\r\n");
        MyFree(pw);

        if(pw = MyMalloc((lstrlen(FormatStrings[i].Find)+3)*sizeof(WCHAR))) {
            lstrcpy(pw,FormatStrings[i].Find);
            lstrcat(pw,L"\r\n");
            FormatStrings[i].Replace = pw;
        } else {
            Status = FALSE;
            goto cleanup;
        }
    }

    FormatStrings[LogSevMaximum].Find =
        DuplicateString(SETUPLOG_ITEM_TERMINATOR);
    if (!FormatStrings[LogSevMaximum].Find) {
        Status = FALSE;
        goto cleanup;
    }
    FormatStrings[LogSevMaximum].Replace = DuplicateString (NewTerm);
    if (!FormatStrings[LogSevMaximum].Replace) {
        Status = FALSE;
        goto cleanup;
    }

    //
    // Change 1 string at a time in the rich edit control
    //

    for (i=0; i<FORMATSTRINGSCOUNT; i++) {
        FindText.chrg.cpMin = 0;    // start search at beginning
        FindText.lpstrText = (PWSTR) FormatStrings[i].Find;

         //
        // Search for current target until we've found each instance
        //

        while ((Position = SendMessage
            (hWndRichEdit, EM_FINDTEXT, FR_MATCHCASE, (LPARAM) &FindText))
            != -1) {

            //
            // Verify that the target is at the beginning of the line
            //

            LineIndex = SendMessage (hWndRichEdit, EM_LINEFROMCHAR,
                Position, 0);

            if (SendMessage (hWndRichEdit, EM_LINEINDEX, LineIndex, 0) !=
                Position) {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
                continue;
            }

            //
            // Select the target text and get its format
            //

            SelectRange.cpMin = Position;
            SelectRange.cpMax = Position + lstrlen (FindText.lpstrText);
            SendMessage (hWndRichEdit, EM_EXSETSEL, 0, (LPARAM) &SelectRange);
            SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
                (LPARAM) &NewFormat);

            //
            // Modify the target's format
            //

            NewFormat.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_ITALIC;
            NewFormat.dwEffects &= ~CFE_AUTOCOLOR;
            NewFormat.crTextColor = FormatStrings[i].Color;
            NewFormat.dwEffects |= FormatStrings[i].Effects;
            SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,
                (LPARAM) &NewFormat);

            //
            // Replace the target with new text.  Set the starting point for
            // the next search at the end of the current string
            //

            if (FormatStrings[i].Replace != NULL) {
                SendMessage (hWndRichEdit, EM_REPLACESEL, FALSE,
                    (LPARAM) FormatStrings[i].Replace);
                FindText.chrg.cpMin = Position +
                    lstrlen (FormatStrings[i].Replace);
            } else {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
            }
        }
    }

cleanup:

    for (i=0; i<=LogSevMaximum; i++) {
        if (FormatStrings[i].Find) {
            MyFree (FormatStrings[i].Find);
        }
        if (FormatStrings[i].Replace) {
            MyFree (FormatStrings[i].Replace);
        }
    }
    return Status;
}

BOOL
ReadLogFile (
    PCWSTR  LogFileName,
    HWND    hWndRichEdit
    )

/*++

Routine Description:

    This routine reads the log file and initializes the contents of the Rich
    Edit control.

Arguments:

    LogFileName - path to the file we're going to read.

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{
    HANDLE      hLogFile;       // handle to log file
    EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

    hLogFile = CreateFile(
        LogFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hLogFile == INVALID_HANDLE_VALUE) {
        hLogFile = NULL;
        return FALSE;
    }

    //
    // Read the file into the Rich Edit control.
    //

    eStream.dwCookie = (DWORD) hLogFile;
    eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
    eStream.dwError = 0;
    SendMessage (hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream);
    CloseHandle (hLogFile);

    if (!FormatText (hWndRichEdit)) {
        return FALSE;
    }
    SendMessage (hWndRichEdit, EM_SETMODIFY, TRUE, 0);
    return TRUE;
}

BOOL
DialogProc (
    IN HWND     hDialog,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    This is the window proc for the dialog box.

Arguments:

    Standard window proc arguments.

Return Value:

    Bool that indicates whether we handled the message.

--*/

{
    HWND    hWndRichEdit;       // handle to rich edit window

    switch (message) {

    case WM_INITDIALOG:
        SetWindowText (hDialog,
            ((LOGVIEW_DIALOG_DATA *)lParam)->WindowHeading);
        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        if (!ReadLogFile (((LOGVIEW_DIALOG_DATA *)lParam)->LogFileName,
            hWndRichEdit)) {
            MessageBoxFromMessage (hDialog, MSG_UNABLE_TO_SHOW_LOG, NULL,
                IDS_ERROR, MB_OK|MB_ICONSTOP);
            EndDialog (hDialog, FALSE);
        }
        CenterWindowRelativeToParent(hDialog);
        PostMessage(hDialog,WM_APP,0,0);
        break;

    case WM_APP:

        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        SendMessage(hWndRichEdit,EM_SETSEL,0,0);
        SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog (hDialog, TRUE);
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
ViewSetupActionLog (
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    )

/*++

Routine Description:

    Formats the setup action log and displays it in a window.
    The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    hOwnerWindow - handle to window that owns the dialog box

    OptionalFileName - full path of the file to be displayed.

    OptionalHeading - text to be shown at the top of the window.

Return Value:

    Boolean value indicating whether the routine was sucessful.

--*/

{
    LOGVIEW_DIALOG_DATA  Global;        // initialization data for dialog box
    WCHAR       TmpFileName[MAX_PATH];  // used to create the log file name
    PCWSTR      TmpHeading;             // used to create the heading
    HANDLE      hRichedDLL;             // DLL used for rich edit
    INT         Status;                 // what we're going to return

    //
    // Form the pathname of the logfile.
    //

    if (!ARGUMENT_PRESENT(OptionalFileName)) {
        GetWindowsDirectory (TmpFileName,MAX_PATH);
        ConcatenatePaths (TmpFileName,SETUPLOG_ERROR_FILENAME,MAX_PATH,NULL);
        Global.LogFileName = DuplicateString (TmpFileName);
    } else {
        if (wcslen(OptionalFileName) > MAX_PATH) {
            Status = 0;
            goto err0;
        }
        Global.LogFileName = DuplicateString (OptionalFileName);
    }

    if (!Global.LogFileName) {
        Status = FALSE;
        goto err0;
    }

    //
    // Form the heading for the dialog box.
    //

    if (!ARGUMENT_PRESENT(OptionalHeading)) {
        TmpHeading = MyLoadString (IDS_LOG_DEFAULT_HEADING);
    } else {
        TmpHeading = DuplicateString (OptionalHeading);
    }
    if (!TmpHeading) {
        Status = FALSE;
        goto err1;
    }

    Global.WindowHeading = FormatStringMessage (IDS_LOG_WINDOW_HEADING,
        TmpHeading, Global.LogFileName);
    if (!Global.WindowHeading) {
        Status = FALSE;
        goto err2;
    }

    //
    // Create the dialog box.
    //

    if (!(hRichedDLL = LoadLibrary (L"RICHED20.DLL"))) {
        Status = FALSE;
        goto err3;
    }
    Status = DialogBoxParam (MyModuleHandle, MAKEINTRESOURCE(IDD_VIEWLOG),
        hOwnerWindow, DialogProc, (LPARAM) &Global);

    //
    // Clean up and return.
    //

    FreeLibrary (hRichedDLL);
err3:
    MyFree (Global.WindowHeading);
err2:
    MyFree (TmpHeading);
err1:
    MyFree (Global.LogFileName);
err0:
    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\rsrcutil.c ===
#include "precomp.h"
#pragma hdrstop


int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR Caption[512];
    TCHAR Buffer[5000];

    if((DWORD_PTR)CaptionString > 0xffff) {
        //
        // It's a string already.
        //
        lstrcpyn(Caption,CaptionString,sizeof(Caption)/sizeof(TCHAR));
    } else {
        //
        // It's a string id
        //
        if(!LoadString(hInst,PtrToUlong(CaptionString),Caption,sizeof(Caption)/sizeof(TCHAR))) {
            Caption[0] = 0;
        }
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        Args
        );

    return(MessageBox(Window,Buffer,Caption,Style|MB_SETFOREGROUND));
}


int
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    int i;

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionString,Style,&arglist);

    va_end(arglist);

    return(i);
}


int
MessageBoxFromMessageAndSystemError(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN DWORD   SystemMessageId,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    TCHAR Caption[512];
    TCHAR Buffer1[1024];
    TCHAR Buffer2[1024];
    int i;

    //
    // Fetch the non-system part. The arguments are for that part of the
    // message -- the system part has no inserts.
    //
    va_start(arglist,Style);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer1,
        sizeof(Buffer1) / sizeof(TCHAR),
        &arglist
        );

    va_end(arglist);

    //
    // Now fetch the system part.
    //
    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        MessageId,
        0,
        Buffer2,
        sizeof(Buffer2) / sizeof(TCHAR),
        &arglist
        );

    //
    // Now display the message, which is made up of two parts that get
    // inserted into MSG_ERROR_WITH_SYSTEM_ERROR.
    //
    i = MessageBoxFromMessage(
            Window,
            MSG_ERROR_WITH_SYSTEM_ERROR,
            FALSE,
            CaptionString,
            Style,
            Buffer1,
            Buffer2
            );

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\generic\ocgen.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OCGEN_H_
 #error "ocgen.h already included!"
#else
 #define _OCGEN_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
void AssureTrailingBackslash(TCHAR *path);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from ocgen.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _OCGEN_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\ansi\precomp.h ===
#include "sysocmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\sysocmgr.c ===
#include "precomp.h"
#pragma hdrstop
#include <tchar.h>
#include <stdlib.h>
#include <CRTDBG.H>
#include <winuserp.h>

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG

//
// App instance.
//
HINSTANCE hInst;

//
// Global version information structure.
//
OSVERSIONINFO OsVersionInfo;

//
// Specification of master inf, from command line.
//
TCHAR InfPath[MAX_PATH];
TCHAR InfDir[MAX_PATH];

//
// Source path for installation files, etc.
//
TCHAR SourcePath[MAX_PATH];
TCHAR UnattendPath[MAX_PATH];

// If Unattened

BOOL bUnattendInstall;

//
// Whether to force the specified master inf to be treated as new
// (from command line)
//
BOOL ForceNewInf;

//
// whether we need to pass language callback to components
//
BOOL LanguageAware;

//
// Whether to run without UI
//
BOOL QuietMode;

//
// Whether to delete all subcomponent entries listed in the master inf
// (from command line)
//
BOOL KillSubcomponentEntries;

// If set and /U then reboot is suppressed
BOOL bNoReboot;

// if this is set and we're running /unattend, then warn on reboot
BOOL bWarnOnReboot;

// if this is set then we want sysocmgr.exe to enforce the admin check.
BOOL bDoAdminCheck = FALSE;

// Flag for Derminineing Starting or Ending message

BOOL bStarting;
//
// OC Manager context 'handle'
//
PVOID OcManagerContext;

//
// Generic app title string id.
//
UINT AppTitleStringId;

BOOL NeedToReboot;
BOOL SkipBillboard;
BOOL ForceExternalProgressIndicator;
BOOL AllowCancel = TRUE;

VOID
OcSetReboot(
           VOID
           );

//
// Callback routines.
//
OCM_CLIENT_CALLBACKS CallbackRoutines = {
    OcFillInSetupDataA,
    OcLogError,
    OcSetReboot
#ifdef UNICODE
    ,OcFillInSetupDataW
#endif
    ,NULL,                     // No callback for show,hide wizard
    NULL,                      // No callback for progress feedback, they are only needed for setup
    NULL,                      // No callback to set the progress text
    NULL                       // No logging callback.
};

BOOL
DoIt(
    VOID
    );

BOOL
ParseArgs(
         IN int argc,
         IN TCHAR *argv[]
         );

DWORD
ExpandPath(
          IN  LPCTSTR lpFileName,
          OUT LPTSTR lpBuffer,
          OUT LPTSTR *lpFilePart
          );

void
ShutDown()
{


    extern void RestartDialogEx(VOID *, VOID *, DWORD, DWORD);
    if (!bNoReboot)  {
        if ( bUnattendInstall && !bWarnOnReboot ) {

            //
            // NT is always UNICODE and W9x is alwasy Ansii
            //
#ifdef UNICODE
            HANDLE hToken; TOKEN_PRIVILEGES tkp;  // Get a token for this process.

            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken))
                sapiAssert("OpenProcessToken");  // Get the LUID for the shutdown privilege.

            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
            tkp.PrivilegeCount = 1;  // one privilege to set
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Get the shutdown privilege for this process.
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

            // Cannot test the return value of AdjustTokenPrivileges.
            if (GetLastError() == ERROR_SUCCESS) {
                sapiAssert("AdjustTokenPrivileges");
            }
#endif
            //
            // Shut down the system and force all applications to close.
            //
            if (! ExitWindowsEx(EWX_REBOOT|EWX_FORCE,
                                SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG) ) {
                _RPT0(_CRT_WARN,"Sysocmgr:Failed to ExitWindows");
                sapiAssert(FALSE);
            }

        } else {
            RestartDialogEx(NULL,NULL,EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG \
                                                  | SHTDN_REASON_FLAG_PLANNED );
        }
    }
}


VOID
__cdecl
#ifdef UNICODE
wmain(
#else
main(
#endif
    IN int argc,
    IN TCHAR *argv[]
    )
{
    INITCOMMONCONTROLSEX ControlInit;

    //
    // Preliminaries
    //
    ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
    ControlInit.dwICC = ICC_LISTVIEW_CLASSES    |
                        ICC_TREEVIEW_CLASSES    |
                        ICC_BAR_CLASSES         |
                        ICC_TAB_CLASSES         |
                        ICC_UPDOWN_CLASS        |
                        ICC_PROGRESS_CLASS      |
                        ICC_HOTKEY_CLASS        |
                        ICC_ANIMATE_CLASS       |
                        ICC_WIN95_CLASSES       |
                        ICC_DATE_CLASSES        |
                        ICC_USEREX_CLASSES      |
                        ICC_COOL_CLASSES;

#if (_WIN32_IE >= 0x0400)

    ControlInit.dwICC = ControlInit.dwICC       |
                        ICC_INTERNET_CLASSES    |
                        ICC_PAGESCROLLER_CLASS;

#endif

    InitCommonControlsEx( &ControlInit );

    hInst = GetModuleHandle(NULL);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);

    AppTitleStringId = IDS_WINNT_SETUP;

    //
    // Parse arguments and do it.
    //
    if (ParseArgs(argc,argv)) {
        DoIt();
    }

    //
    // If we need to reboot, do that now.
    //
    if (NeedToReboot) {
        ShutDown();
    }
}


BOOL
ParseArgs(
         IN int argc,
         IN TCHAR *argv[]
         )

/*++

Routine Description:

    Parse and syntactically validate arguments specified on the comment line.

    The following arguments are valid:

    /a                  forces the external progress indicator on the setup page

    /c                  disallow cancel during final installation phase

    /i:<master_oc_inf>  specifies the master OC inf (required).

    /n                  forces specified master_oc_inf to be treated as new.

    /s:<master_oc_inf>  specifies the source path (required).

    /u:<unattend_spec>  specifies unattended operation parameters.

    /x                  supresses the 'initializing' banner

    /q                  run wizard invisibly

    /r                  supress reboot if need on unattended operation

    /w                  warn on reboot on unattended operation

Arguments:

    Standard main argc/argv.

Return Value:

    Boolean value indicating whether the arguments specified are valid.

    If successful, various global variables will have been filled in.
    If not, the user will have been informed.

--*/

{
    BOOL Valid;
    LPCTSTR SourcePathSpec = NULL;
    LPCTSTR InfSpec = NULL;
    LPCTSTR UnattendSpec = NULL;
    LPTSTR FilePart;
    DWORD u;

    //
    // Skip program name.
    //
    if (argc) {
        argc--;
    }

    Valid = TRUE;
    ForceNewInf = FALSE;
    QuietMode = FALSE;
    KillSubcomponentEntries = FALSE;

    while (Valid && argc--) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {

                case TEXT('a'):
                case TEXT('A'):

                    if (!ForceExternalProgressIndicator && !argv[0][2]) {
                        ForceExternalProgressIndicator = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('c'):
                case TEXT('C'):

                    if (AllowCancel && !argv[0][2]) {
                        AllowCancel = FALSE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('f'):
                case TEXT('F'):

                    ForceNewInf = TRUE;
                    KillSubcomponentEntries = TRUE;
                    break;

                case TEXT('i'):
                case TEXT('I'):

                    if (!InfSpec && (argv[0][2] == TEXT(':')) && argv[0][3]) {

                        InfSpec = &(argv[0][3]);

                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('l'):
                case TEXT('L'):

                    LanguageAware = TRUE;
                    break;

                case TEXT('n'):
                case TEXT('N'):

                    ForceNewInf = TRUE;
                    break;

                case TEXT('q'):
                case TEXT('Q'):

                    if (!QuietMode && !argv[0][2]) {
                        QuietMode = TRUE;
                        SkipBillboard = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('r'):
                case TEXT('R'):

                    bNoReboot = TRUE;
                    break;

                case TEXT('s'):
                case TEXT('S'):

                    if (!SourcePathSpec && (argv[0][2] == TEXT(':')) && argv[0][3]) {

                        SourcePathSpec = &argv[0][3];

                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('u'):
                case TEXT('U'):
                    //
                    // accept unattend, unattended, u all as the same
                    //
                    if(!_tcsnicmp(&argv[0][1],TEXT("unattended"),10)) {
                        u = 11;
                    } else if(!_tcsnicmp(&argv[0][1],TEXT("unattend"),8)) {
                        u = 9;
                    } else if(!_tcsnicmp(&argv[0][1],TEXT("u"),1)) {
                        u = 2;
                    } else {
                        Valid = FALSE;
                        u = 0;
                    }

                    if (!UnattendSpec ) {

                        bUnattendInstall = TRUE;


                        // If you have the : then you must also have the arg
                        if (argv[0][u] == TEXT(':')) {

                            if ( argv[0][u+1]) {
                                UnattendSpec = &argv[0][u+1];
                            } else {
                                Valid = FALSE;
                            }
                        } else {
                            Valid = FALSE;
                        }
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('w'):
                case TEXT('W'):

                    bWarnOnReboot = TRUE;
                    break;

                case TEXT('x'):
                case TEXT('X'):

                    if (!SkipBillboard && !argv[0][2]) {
                        SkipBillboard = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                // For ISSUE NTBUG9:295052 (389583): We want to do a top level admin check so we get a more friendly message.
                // It is possible for people to have been using sysocmgr.exe with their own custom master oc.inf
                // (the one passed in with the /i: switch) and they may not need this admin check. So, we did
                // not want to do this admin check unconditionally. We will have the control panel applet that
                // is launching sysocmgr.exe to pass in this /y switch.
                //
                case TEXT('y'):
                case TEXT('Y'):

                    bDoAdminCheck = TRUE;
                    break;


                case TEXT('z'):
                case TEXT('Z'):
                    // Stop parsing Arguments All other args past this point are
                    // Component Arguments

                    argc = 0;
                    break;

                default:

                    Valid = FALSE;
                    break;
            }

        } else {
            Valid = FALSE;
        }
    }

    if (Valid && !InfSpec) {
        Valid = FALSE;
    }

    if (Valid) {
        //
        // Expand the inf spec to a full path.
        //
        ExpandPath(InfSpec,InfPath,&FilePart);
        _tcscpy(InfDir, InfSpec);
        if (_tcsrchr(InfDir, TEXT('\\')))
            *_tcsrchr(InfDir,TEXT('\\')) = 0;
        else
            GetCurrentDirectory(MAX_PATH, InfDir);

        // If the user specified /s then expand it too, otherwise
        // use the dir in the /i as the /s arg.

        if (SourcePathSpec) {

            ExpandPath(SourcePathSpec,SourcePath,&FilePart);

        } else {
            
            lstrcpy(SourcePath,InfPath);
            if (_tcsrchr(SourcePath,TEXT('\\'))) {
                *_tcsrchr(SourcePath,TEXT('\\')) = 0;
            }
            
        }

        SetCurrentDirectory(InfDir);

        if (UnattendSpec) {
            ExpandPath(UnattendSpec,UnattendPath,&FilePart);
        }else{
            // Allow /Q only if /U was specified

            QuietMode = FALSE;
            SkipBillboard = FALSE;
        }

        

    } else {
        MessageBoxFromMessage(
                             NULL,
                             MSG_ARGS,
                             FALSE,
                             MAKEINTRESOURCE(AppTitleStringId),
                             MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
                             );
    }

    return (Valid);
}


INT_PTR
BillboardDlgProc(
                IN HWND   hdlg,
                IN UINT   msg,
                IN WPARAM wParam,
                IN LPARAM lParam
                )
{
    BOOL b;
    RECT rect1,rect2;
    static HCURSOR hOldCursor;

    switch (msg) {

        case WM_INITDIALOG:

            //
            // Center on-screen.
            //
            GetWindowRect(hdlg,&rect1);
            SystemParametersInfo(SPI_GETWORKAREA,0,&rect2,0);

            MoveWindow(
                      hdlg,
                      rect2.left + (((rect2.right - rect2.left) - (rect1.right - rect1.left)) / 2),
                      rect2.top + (((rect2.bottom - rect2.top) - (rect1.bottom - rect1.top)) / 2),
                      rect1.right - rect1.left,
                      rect1.bottom - rect1.top,
                      FALSE
                      );

            *(HWND *)lParam = hdlg;
            b = TRUE;

            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            break;

        case WM_APP:

            EndDialog(hdlg,0);

            SetCursor( hOldCursor );

            b = TRUE;
            break;

        default:

            b = FALSE;
            break;
    }

    return (b);
}


DWORD
DisplayMessage(
              IN LPVOID ThreadParameter
              )
{
    int i;

    i = (int)DialogBoxParam(
                           hInst,
                           MAKEINTRESOURCE(bStarting?IDD_STARTING:IDD_FINISHING),
                           NULL,
                           BillboardDlgProc,
                           (LPARAM)ThreadParameter
                           );

    if (i == -1) {
        //
        // Force caller out of wait loop
        //
        *(HWND *)ThreadParameter = (HWND)(-1);
    }

    return (0);
}

/*---------------------------------------------------------------------------*\
  Function: RunningAsAdministrator()
|*---------------------------------------------------------------------------*|
  Description: Checks whether we are running as administrator on the machine
  or not.
  Code taken from ntoc.dll
\*---------------------------------------------------------------------------*/
BOOL 
RunningAsAdministrator(
        VOID
        )
{
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    
    // First we must open a handle to the access token for this thread.

    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
}


BOOL
DoIt(
    VOID
    )
{
    BOOL ShowErr;
    HANDLE hThread;
    DWORD ThreadId;
    HANDLE hMutex;
    TCHAR Fname[MAX_PATH];
    TCHAR MutexName[MAX_PATH];
    DWORD Flags;
    HWND StartingMsgWindow = NULL;
    HCURSOR hOldCursor;

    if (bDoAdminCheck && !RunningAsAdministrator()) {
        MessageBoxFromMessage(
             StartingMsgWindow,
             MSG_NOT_ADMIN,
             FALSE,
             MAKEINTRESOURCE(AppTitleStringId),
             MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
             );
        return FALSE;
    }

    //
    // Create a Mutex from the Base Name of the Inf file
    // This will prevent OCM from running on the same inf file
    // in two or more instances
    //
    _tsplitpath( InfPath, NULL, NULL, Fname, NULL );

    lstrcpy( MutexName, TEXT("Global\\"));
    lstrcat( MutexName, Fname );

    hMutex = CreateMutex( NULL, TRUE, MutexName );

    if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError()) {
        MessageBoxFromMessage(
                             NULL,
                             MSG_ONLY_ONE_INST,
                             FALSE,
                             MAKEINTRESOURCE(AppTitleStringId),
                             MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_SYSTEMMODAL
                             );

        ReleaseMutex(hMutex);
        return FALSE;

    }

    //
    // Initialize the OC Manager. Show the user an "initializing setup"
    // dialog while this is happening, as it can take a while.
    //
    if (!SkipBillboard) {
        bStarting = TRUE;
        StartingMsgWindow = NULL;
        hThread = CreateThread(
                              NULL,
                              0,
                              DisplayMessage,
                              &StartingMsgWindow,
                              0,
                              &ThreadId
                              );

        if (hThread) {
            CloseHandle(hThread);
            Sleep(50);
        } else {
            DisplayMessage(0);
        }
    }

    //
    // Make sure the window has actually been created,
    // or we could have a timing window where the PostMessage fails
    // and the billboard shows up on top of the wizard.
    //
    if (!SkipBillboard) {
        while (!StartingMsgWindow) {
            Sleep(50);
        }
    }

    Flags = ForceNewInf ? OCINIT_FORCENEWINF : 0;
    Flags |= KillSubcomponentEntries ? OCINIT_KILLSUBCOMPS : 0;
    Flags |= QuietMode ? OCINIT_RUNQUIET : 0;
    Flags |= LanguageAware ? OCINIT_LANGUAGEAWARE : 0 ;

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    OcManagerContext = OcInitialize(
                                   &CallbackRoutines,
                                   InfPath,
                                   Flags,
                                   &ShowErr,
                                   NULL
                                   );

    if (!OcManagerContext) {

        SetCursor( hOldCursor );

        if (ShowErr) {
            MessageBoxFromMessage(
                                 StartingMsgWindow,
                                 MSG_CANT_INIT,
                                 FALSE,
                                 MAKEINTRESOURCE(AppTitleStringId),
                                 MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
                                 );
        }

        ReleaseMutex(hMutex);
        return (FALSE);
    }

    //
    // Do the wizard.
    //
    DoWizard(OcManagerContext,StartingMsgWindow, hOldCursor);

    SetCursor( hOldCursor );
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // the Terminate can take a while too..
    if (!SkipBillboard) {

        bStarting = FALSE;
        StartingMsgWindow = NULL;
        hThread = CreateThread(
                              NULL,
                              0,
                              DisplayMessage,
                              &StartingMsgWindow,
                              0,
                              &ThreadId
                              );

        if (hThread) {
            CloseHandle(hThread);
            Sleep(50);
        } else {
            DisplayMessage(0);
        }
    }

    //
    // Clean up, we're done.
    //
    OcTerminate(&OcManagerContext);

    if (!SkipBillboard) {
        //
        // Make sure the window has actually been created,
        // or we could have a timing window where the PostMessage fails
        // and the billboard shows up on top of the wizard.
        //
        while (!StartingMsgWindow) {
            Sleep(50);
        }
        SendMessage(StartingMsgWindow,WM_APP,0,0);
    }

    ReleaseMutex(hMutex);

    SetCursor( hOldCursor );
    return (TRUE);
}


VOID
OcSetReboot(
           VOID
           )
{
    NeedToReboot = TRUE;
}

DWORD
ExpandPath(
          IN  LPCTSTR lpFileName,
          OUT LPTSTR lpBuffer,
          OUT LPTSTR *lpFilePart
          )
{
    TCHAR buf[MAX_PATH];

    ExpandEnvironmentStrings(lpFileName, buf, MAX_PATH);
    return GetFullPathName(buf, MAX_PATH, lpBuffer, lpFilePart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\wizard.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Routines to run the wizard for the suite.

Author:

    Ted Miller (tedm) 1-Oct-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HPROPSHEETPAGE
CreateInstallationAndProgressPage(
    VOID
    );

INT_PTR
FinalPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

//
// Bogus global variable necessary because there's no way to get
// a value through to the PropSheetCallback.
//
PVOID _CBx;

int
CALLBACK
PropSheetCallback(
    IN HWND   DialogHandle,
    IN UINT   msg,
    IN LPARAM lparam
    )
{
    DWORD oldp;
    LPDLGTEMPLATE dtemplate;

    switch (msg) {

    case PSCB_PRECREATE:
        dtemplate = (LPDLGTEMPLATE)lparam;
        if (QuietMode) {
            VirtualProtect(dtemplate, sizeof(DLGTEMPLATE), PAGE_READWRITE, &oldp);
            dtemplate->style = dtemplate->style & ~WS_VISIBLE;
        }
        break;

    case PSCB_INITIALIZED:
        OcRememberWizardDialogHandle(_CBx,DialogHandle);
        break;
    }

    return 0;
}



BOOL
DoWizard(
    IN PVOID OcManagerContext,
    IN HWND StartingMsgWindow,
    IN HCURSOR hOldCursor
    )

/*++

Routine Description:

    This routine creates and displays the wizard.

Arguments:

    OcManagerContext - value returned from OcInitialize().

Return Value:

    Boolean value indicating whether the wizard was successfully displayed.

--*/

{
    PSETUP_REQUEST_PAGES PagesFromOcManager[WizPagesTypeMax];
    BOOL b;
    UINT u;
    UINT PageCount;
    UINT i;
    HPROPSHEETPAGE *PageHandles;
    HPROPSHEETPAGE OcPage = NULL;
    HPROPSHEETPAGE SetupPage;
    HPROPSHEETPAGE FinalPage;
    PROPSHEETPAGE PageDescrip;
    PROPSHEETHEADER PropSheet;
    OC_PAGE_CONTROLS WizardPageControlsInfo;
    OC_PAGE_CONTROLS DetailsPageControlsInfo;
    SETUP_PAGE_CONTROLS SetupPageControlsInfo;
    HDC hdc;
    HWND PsHwnd;

    b = FALSE;

    u = OcGetWizardPages(OcManagerContext,PagesFromOcManager);
    if(u != NO_ERROR) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            u,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c0;
    }

    //
    // There must be a final page, because the final page comes right after the
    // setup page, and we don't want the setup page to have to know whether to
    // simulate pressing next or finish to advance.
    //
    if(!PagesFromOcManager[WizPagesFinal] || !PagesFromOcManager[WizPagesFinal]->MaxPages) {

        PageDescrip.dwSize = sizeof(PROPSHEETPAGE);
        PageDescrip.dwFlags = PSP_DEFAULT;
        PageDescrip.hInstance = hInst;
        PageDescrip.pszTemplate = MAKEINTRESOURCE(IDD_FINAL);
        PageDescrip.pfnDlgProc = FinalPageDlgProc;

        FinalPage = CreatePropertySheetPage(&PageDescrip);
        if(!FinalPage) {
            MessageBoxFromMessageAndSystemError(
                NULL,
                MSG_CANT_INIT,
                ERROR_NOT_ENOUGH_MEMORY,
                MAKEINTRESOURCE(AppTitleStringId),
                MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
                );

            goto c1;
        }

    } else {
        FinalPage = NULL;
    }

    //
    // Calculate the number of pages. There's two extra pages (the OC and setup pages).
    // Also leave room for a potential dummy final page.
    //
    PageCount = FinalPage ? 3 : 2;
    for(u=0; u<WizPagesTypeMax; u++) {
        if(PagesFromOcManager[u]) {
            PageCount += PagesFromOcManager[u]->MaxPages;
        }
    }

    //
    // Allocate space for the page structures.
    //
    PageHandles = MyMalloc(PageCount * sizeof(HPROPSHEETPAGE));
    if(!PageHandles) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c1;
    }
    ZeroMemory(PageHandles,PageCount*sizeof(HPROPSHEETPAGE));

    //
    // Create the OC Page.
    //
    WizardPageControlsInfo.TemplateModule = hInst;
    WizardPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_OC_WIZARD_PAGE);
    WizardPageControlsInfo.ListBox = IDC_LISTBOX;
    WizardPageControlsInfo.TipText = IDT_TIP;
    WizardPageControlsInfo.DetailsButton = IDB_DETAILS;
    WizardPageControlsInfo.ResetButton = IDB_RESET;
    WizardPageControlsInfo.InstalledCountText = IDT_INSTALLED_COUNT;
    WizardPageControlsInfo.SpaceNeededText = IDT_SPACE_NEEDED_NUM;
    WizardPageControlsInfo.SpaceAvailableText = IDT_SPACE_AVAIL_NUM;
    WizardPageControlsInfo.InstructionsText = IDT_INSTRUCTIONS;
    WizardPageControlsInfo.HeaderText = IDS_OCPAGE_HEADER;
    WizardPageControlsInfo.SubheaderText = IDS_OCPAGE_SUBHEAD;
    WizardPageControlsInfo.ComponentHeaderText = IDT_COMP_TITLE;


    DetailsPageControlsInfo = WizardPageControlsInfo;
    DetailsPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_OC_DETAILS_PAGE);

    if (OcSubComponentsPresent(OcManagerContext)) {
        OcPage = OcCreateOcPage(OcManagerContext,&WizardPageControlsInfo,&DetailsPageControlsInfo);
        if(!OcPage) {
            MessageBoxFromMessageAndSystemError(
                NULL,
                MSG_CANT_INIT,
                ERROR_NOT_ENOUGH_MEMORY,
                MAKEINTRESOURCE(AppTitleStringId),
                MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
                );

            goto c2;
        }
    }

    SetupPageControlsInfo.TemplateModule = hInst;
    SetupPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_PROGRESS_PAGE);
    SetupPageControlsInfo.ProgressBar = IDC_PROGRESS;
    SetupPageControlsInfo.ProgressLabel = IDT_THERM_LABEL;
    SetupPageControlsInfo.ProgressText = IDT_TIP;
    SetupPageControlsInfo.AnimationControl = IDA_EXTERNAL_PROGRAM;
    SetupPageControlsInfo.AnimationResource = IDA_FILECOPY;
    SetupPageControlsInfo.ForceExternalProgressIndicator = ForceExternalProgressIndicator;
    SetupPageControlsInfo.AllowCancel = AllowCancel;
    SetupPageControlsInfo.HeaderText = IDS_PROGPAGE_HEADER;
    SetupPageControlsInfo.SubheaderText = IDS_PROGPAGE_SUBHEAD;

    SetupPage = OcCreateSetupPage(OcManagerContext,&SetupPageControlsInfo);
    if(!SetupPage) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c2;
    }

    for(PageCount=0,u=0; u<WizPagesTypeMax; u++) {
        //
        // OC Page comes between mode and early pages.
        // Setup page comes right before final page.
        //
        if(u == WizPagesEarly && OcPage) {
            PageHandles[PageCount++] = OcPage;
        } else {
            if(u == WizPagesFinal) {
                PageHandles[PageCount++] = SetupPage;
                if(FinalPage) {
                    PageHandles[PageCount++] = FinalPage;
                }
            }
        }

        if(PagesFromOcManager[u]) {

            CopyMemory(
                PageHandles+PageCount,
                PagesFromOcManager[u]->Pages,
                PagesFromOcManager[u]->MaxPages * sizeof(HPROPSHEETPAGE)
                );

            PageCount += PagesFromOcManager[u]->MaxPages;
        }
    }

    //
    // OK, we're ready. Set up and go.
    //
    PropSheet.dwSize = sizeof(PROPSHEETHEADER);
    PropSheet.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    PropSheet.hwndParent = NULL;
    PropSheet.hInstance = hInst;
    PropSheet.nPages = PageCount;
    PropSheet.nStartPage = 0;
    PropSheet.phpage = PageHandles;
    PropSheet.pfnCallback = PropSheetCallback;
    PropSheet.pszbmHeader    = MAKEINTRESOURCE(IDB_WATERMARK1_16);
    PropSheet.pszbmWatermark = MAKEINTRESOURCE(IDB_WELCOME);
    if(hdc = GetDC(NULL)) {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8) {
            PropSheet.pszbmHeader = MAKEINTRESOURCE(IDB_WATERMARK1_256);
        }
        ReleaseDC(NULL,hdc);
    }

    //
    // Bogus global var used because we need to get a value through to
    // the property sheet callback routine.
    //
    _CBx = OcManagerContext;

    // make sure our new window can hold the focus before killing the wait window

    if(StartingMsgWindow) {
        AllowSetForegroundWindow(GetCurrentProcessId());
        PostMessage(StartingMsgWindow,WM_APP,0,0);
    }

    SetCursor(hOldCursor);

    PsHwnd = (HWND) PropertySheet( &PropSheet );

    if((LONG_PTR)PsHwnd == -1) {

        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

   } else {

        b = TRUE;
    }

c2:
    MyFree(PageHandles);
c1:
    for(u=0; u<WizPagesTypeMax; u++)    {
        if (PagesFromOcManager[u]) {
            pSetupFree(PagesFromOcManager[u]);
        }
    }

c0:
    return(b);
}


INT_PTR
FinalPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{

    BOOL b;
    NMHDR *NotifyParams;
    b = FALSE;

    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:

			// We don't dispaly this page. Just use it to end the Wizard set
			PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_FINISH);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
            // fall through

        case PSN_KILLACTIVE:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow activation/motion.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            b = TRUE;
            break;
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\unicode\precomp.h ===
#include "sysocmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\sysocmgr.h ===
//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <prsht.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <ocmanage.h>

#include <setuplog.h>

#include "ocmgrlib.h"
#include "res.h"
#include "msg.h"


//
// App instance.
//
extern HINSTANCE hInst;

//
// Global version information structure and macro to tell whether
// the system is NT.
//
extern OSVERSIONINFO OsVersionInfo;
#define IS_NT() (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)

//
// Source path for installation files, etc.
//
extern TCHAR SourcePath[MAX_PATH];
extern TCHAR UnattendPath[MAX_PATH];

extern BOOL bUnattendInstall;

//
// OC Manager context 'handle'
//
extern PVOID OcManagerContext;

//
// Generic app title string id.
//
extern UINT AppTitleStringId;

//
// Flag indicating whether a flag was passed on the cmd line
// indicating that the oc setup wizard page should use the
// external-type progress indicator at all times
//
extern BOOL ForceExternalProgressIndicator;

extern BOOL AllowCancel;

//
// Whether to run without UI
//
extern BOOL QuietMode;

//
// Wizard routines.
//
BOOL
DoWizard(
    IN PVOID OcManagerContext,
    IN HWND StartingMsgWindow,
    IN HCURSOR hOldCursor
    );

//
// Misc routines
//
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    );

#ifdef UNICODE
VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    );
#endif

INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCTSTR      FormatString,
    ...
    );

//
// Resource-handling functions.
//
int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    );

int
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    );

int
MessageBoxFromMessageAndSystemError(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN DWORD   SystemMessageId,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    );


#ifdef UNICODE
#define pDbgPrintEx  DbgPrintEx
#else
#define pDbgPrintEx
#endif

#define MyMalloc(sz) ((PVOID)LocalAlloc(LMEM_FIXED,sz))
#define MyFree(ptr) (LocalFree(ptr))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\sysocmgr\setupdat.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setupdat.c

Abstract:

    Module containing implementation for OcFillInSetupData, which the
    common OC Manager library will call to fill in the environment-dependent
    SETUP_DATA structure.

Author:

    tedm 30-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>


UINT
pDetermineProductType(
    VOID
    );



#ifdef UNICODE
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )

/*++

Routine Description:

    Routine to fill in the ANSI SETUP_DATA structure in the Unicode build.

    This routine is merely a thunk to the Unicode implementation.

Arguments:

    SetupData - receives various environment-specific values relating
        to the OC Manager's operation.

Return Value:

    None.

--*/

{
    SETUP_DATAW data;

    OcFillInSetupDataW(&data);

    SetupData->SetupMode = data.SetupMode;
    SetupData->ProductType = data.ProductType;
    SetupData->OperationFlags = data.OperationFlags;

    WideCharToMultiByte(
        CP_ACP,
        0,
        data.SourcePath,
        -1,
        SetupData->SourcePath,
        sizeof(SetupData->SourcePath),
        NULL,
        NULL
        );

    WideCharToMultiByte(
        CP_ACP,
        0,
        data.UnattendFile,
        -1,
        SetupData->UnattendFile,
        sizeof(SetupData->UnattendFile),
        NULL,
        NULL
        );
}
#endif


#ifdef UNICODE
VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    )
#else
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )
#endif

/*++

Routine Description:

    Routine to fill in the SETUP_DATA structure in the "native"
    character width.

Arguments:

    SetupData - receives various environment-specific values relating
        to the OC Manager's operation.

Return Value:

    None.

--*/

{
    TCHAR str[4];
    
    SetupData->SetupMode = (ULONG)SETUPMODE_UNKNOWN;
    SetupData->ProductType = pDetermineProductType();

    //
    // Set up source path stuff, unattend file.
    //
    lstrcpy(SetupData->SourcePath,SourcePath);
    lstrcpy(SetupData->UnattendFile,UnattendPath);

    //
    // Set miscellaneous bit flags and fields.
    //
    SetupData->OperationFlags = SETUPOP_STANDALONE;
    if(bUnattendInstall) {
        SetupData->OperationFlags |= SETUPOP_BATCH;
    }

    //
    // Which files are available?
    //
#if defined(_AMD64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_AMD64_FILES_AVAIL;
#elif defined(_X86_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL;
#elif defined(_IA64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_IA64_FILES_AVAIL;
#else
#error "No Target Architecture"
#endif


}


UINT
pDetermineProductType(
    VOID
    )

/*++

Routine Description:

    Determine the product type suitable for use in the SETUP_DATA structure.
    On Win95 this is always PRODUCT_WORKSTATION. On NT we check the registry
    and use other methods to distinguish among workstation and 3 flavors
    of server.

Arguments:

    None.

Return Value:

    Value suitable for use in the ProductType field of the SETUP_DATA structure.

--*/

{
    UINT ProductType;
    HKEY hKey;
    LONG l;
    DWORD Type;
    TCHAR Buffer[512];
    DWORD BufferSize;
    PSERVER_INFO_101 ServerInfo;

    HMODULE NetApiLib;

    NET_API_STATUS
    (NET_API_FUNCTION *xNetServerGetInfo)(
        IN  LPTSTR  servername,
        IN  DWORD   level,
        OUT LPBYTE  *bufptr
        );

    NET_API_STATUS
    (NET_API_FUNCTION *xNetApiBufferFree)(
        IN LPVOID Buffer
        );

    //
    // Assume workstation.
    //
    ProductType = PRODUCT_WORKSTATION;

    if(IS_NT()) {
        //
        // Look in registry to determine workstation, standalone server, or DC.
        //
        l = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {

            BufferSize = sizeof(Buffer);

            l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Buffer,&BufferSize);
            if((l == NO_ERROR) && (Type == REG_SZ)) {
                //
                // Check for standalone server or DC server.
                //
                if(!lstrcmpi(Buffer,TEXT("SERVERNT"))) {
                    ProductType = PRODUCT_SERVER_STANDALONE;
                } else {
                    if(!lstrcmpi(Buffer,TEXT("LANMANNT"))) {
                        //
                        // PDC or BDC -- determine which. Assume PDC in case of failure.
                        //
                        ProductType = PRODUCT_SERVER_PRIMARY;

                        if(NetApiLib = LoadLibrary(TEXT("NETAPI32"))) {

                            if(((FARPROC)xNetServerGetInfo = GetProcAddress(NetApiLib,"NetServerGetInfo"))
                            && ((FARPROC)xNetApiBufferFree = GetProcAddress(NetApiLib,"NetApiBufferFree"))
                            && (xNetServerGetInfo(NULL,101,(LPBYTE *)&ServerInfo) == 0)) {

                                if(ServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) {
                                    ProductType = PRODUCT_SERVER_SECONDARY;
                                }

                                xNetApiBufferFree(ServerInfo);
                            }

                            FreeLibrary(NetApiLib);
                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    return(ProductType);
}


INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCTSTR      FormatString,
    ...
    )
{
    TCHAR str[4096];
    TCHAR tmp[64];
    TCHAR Title[256];
    va_list arglist;
    UINT Icon;

    va_start(arglist,FormatString);
    wvsprintf(str,FormatString,arglist);
    va_end(arglist);

    // In Batch mode don't display UI
    if ( Level & OcErrBatch ) {

        pDbgPrintEx( 
            DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL,
            "sysocmgr: %S\n",
            str 
            );

        return IDOK;
    }
        //
        // Mask off lower byte to allow us to pass
        // Addtionall "icon" information 
        // 
        
    switch( Level & OcErrMask ) {
    case OcErrLevInfo:
        Icon = MB_ICONINFORMATION;
        break;
    case OcErrLevWarning:
    case OcErrLevError:
        Icon = MB_ICONWARNING;
        break;
    case OcErrTrace:
        pDbgPrintEx( 
            DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL,
            "sysocmgr: %S\n",
            str 
            );
        return(IDOK);
        break;
    default:
        Icon = MB_ICONERROR;
        break;
    }

    pDbgPrintEx( 
        DPFLTR_SETUP_ID, 
        DPFLTR_INFO_LEVEL,
        "sysocmgr: level 0x%08x error: %S\n",
        Level,
        str 
        );

        //
        // If no additional Icon information is specified that's ok since
        // MB_OK is default
        //
        Icon |= (Level & ~OcErrMask);

    if ((Level & OcErrMask) < OcErrLevError)
        return IDOK;


    LoadString(hInst,AppTitleStringId,Title,sizeof(Title)/sizeof(TCHAR));
    return MessageBox(NULL,str,Title,Icon | MB_TASKMODAL | MB_SETFOREGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\ansi\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest.c ===
/*++

Copyright (c) 1997	Microsoft Corporation

Module Name:

	octest.c

Abstract:

	The code for the component setup DLL. This includes ComponentSetupProc, 
	the DLL's entry point that is called by the OC Manager, as well as some 
	routines that test the private data calls and the private functions calls.

Author:

	Bogdan Andreiu (bogdana)  10-Feb-1997  Created.
	Jason Allor    (jasonall) 24-Feb-1998  Took over the project.
	Sean Edmison   (SEdmison) 21-Feb-2000  Took over the project.

Revision History:

	10-Feb-1997    bogdana
		First draft.
	
	20-Feb-1997    bogdana	
		Added multistring testing for the private data
	
	19-Mar-1997    bogdana
		Modified and added routines that test the private functions call
	 
	21-Feb-2000  SEdmison
		Initialized a bunch of variables.
		Added casts to avoid compiler warnings.
		Added a return TRUE to avoid compiler error.

--*/
#include "octest.h"

const static PTCHAR g_atszStringValues[MAX_STRINGS_FOR_PRIVATE_DATA] = 
{
	TEXT("First value to set"),
	TEXT("Second value to set"),
	TEXT("The third and longest value to set"),
	TEXT(""),
	TEXT("A"),
	TEXT("AB"),
	TEXT("ABC"),
	TEXT("The final value : \\//\\//\\//\\")
};

const static PTCHAR g_atszMultiStringValues[MAX_MULTI_STRINGS_FOR_PRIVATE_DATA] = 
{
	TEXT("A\0B\0C\0D\0E\0\0"),
	TEXT("\0\0"),
	TEXT("One\0Two\0Three\0\0"),
	TEXT("String1\0\0"),
	TEXT("0\01\02\03\0\0"),
	TEXT("Multi\0String\0\\0\0\0")
};

/*++

Routine Description: DllMain (1.24)

	main routine

Arguments:

	standard DllMain arguments

Return Value:

	BOOL

--*/
BOOL WINAPI DllMain(IN HINSTANCE hInstance, 
						  IN DWORD		fdwReason, 
						  IN PVOID		pvReserved)
{
	USHORT		  i = 0;
	TCHAR		  tszModulePath[MAX_PATH], szMsg[MAX_MSG_LEN];
	PTCHAR		  tszLogPath = NULL;
	PTCHAR		  tszAux = NULL;
	static UINT uiThreadCount = 0;

	switch (fdwReason)
	{
		case  DLL_PROCESS_ATTACH:
										
			InitializeMemoryManager();
			InitGlobals();
			
			ParseCommandLine();
			
			//
			// Randomize, save the module instance and in initialize the log
			//
			srand((unsigned) time(NULL));
			g_hDllInstance = hInstance;
			InitCommonControls();
			GetModuleFileName(g_hDllInstance, tszModulePath, MAX_PATH);
			break;
		
		case DLL_PROCESS_DETACH:

			CleanUpTest();
			ExitLog();
			CheckAllocs();
			
			break;
		
		case DLL_THREAD_DETACH:
			
			//
			// If we added a participant, we have to remoce it
			//
			break;
		
		case DLL_THREAD_ATTACH:
			
			//
			// Otherwise we won't be able to log on correctly
			//
			uiThreadCount++;
			break;
		
		default: 
		
			break;
	}
	return TRUE;
	
} // DllMain //



//==========================================================================
//
// Functions to set up UI
//
//==========================================================================



/*++

Routine Description: ChooseVersionDlgProc (1.26)

	Dialog procedure that allows the user to choose a component version
	less, equal or greater then the one of the OC Manager's.
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseVersionDlgProc(IN HWND	  hwnd,
											  IN UINT	 uiMsg, 
											  IN WPARAM wParam,
											  IN LPARAM lParam) 
{
	PTSTR tszComponentId = NULL;
	INT    iVersion = 0;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			CheckRadioButton(hwnd, IDC_LESS, IDC_GREATER, IDC_EQUAL);
			tszComponentId = (PTSTR)lParam;
			SetDlgItemText(hwnd, IDC_COMPONENT1, tszComponentId);
			return TRUE;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_LESS))
					{
						iVersion = -1;
					}
					
					if (QueryButtonCheck(hwnd, IDC_EQUAL))
					{
						iVersion = 0;
					}
					
					if (QueryButtonCheck(hwnd, IDC_GREATER))
					{
						iVersion = 1;
					}
					
					//
					// Send the version chosen back to ChooseVersionEx
					//
					EndDialog(hwnd, iVersion);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // ChooseVersionDlgProc //




/*++

Routine Description: ChooseSubcomponentDlgProc (1.27)

	Dialog procedure that allows the user to select a different 
	initial state for a component than the one found by the OC Manager
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseSubcomponentDlgProc(IN HWND    hwnd,
													 IN UINT	uiMsg, 
													 IN WPARAM wParam,
													 IN LPARAM lParam) 
{
	PTSTR					 tszComponentId = NULL;
	SubComponentState	 scsInitialState;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			CheckRadioButton(hwnd, IDC_DEFAULT, IDC_OFF, IDC_DEFAULT);
			tszComponentId = (PTSTR)lParam;
			SetDlgItemText(hwnd, IDC_COMPONENT1, tszComponentId);
			return TRUE;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_DEFAULT))
					{
					  scsInitialState = SubcompUseOcManagerDefault;
					}
					
					if (QueryButtonCheck(hwnd, IDC_OFF))
					{
						scsInitialState = SubcompOff;
					}
					
					if (QueryButtonCheck(hwnd, IDC_ON))
					{
						scsInitialState = SubcompOn;
					}
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // ChooseSubcomponentDlgProc //




/*++

Routine Description: ChooseVersionEx (1.29)

	"Wrapper" routine for the dialog box procedure ChooseVersionDlgProc.
	Retrieves the value chosen by the user and sets the version field of
	pInitComponent accordingly.
	 
Arguments:

	lpcvComponentId: supplies the id for the component. 
	pInitComponent:  supplies the address of the initialization structure.
						  After return the "Version" field of that structure will 
						  reflect the user's selection 

Return Value:

	void

--*/
VOID ChooseVersionEx(IN 	 LPCVOID					lpcvComponentId, 
							IN OUT PSETUP_INIT_COMPONENT psicInitComponent)  
{
	INT iVersion = 0;
	
	//
	// We will display a dialog box so the user can choose the 
	// version he/she wants
	//
	iVersion = DialogBoxParam(g_hDllInstance, 
									  MAKEINTRESOURCE(IDD_DIALOG2), 
									  NULL, 
									  ChooseVersionDlgProc,
									  (LPARAM)lpcvComponentId);
	
	//
	// We set the version choosen in a structure that will be sent 
	// back to the Oc Manager
	//
	psicInitComponent->ComponentVersion = 
		psicInitComponent->OCManagerVersion + iVersion;

	return;

} // ChooseVersionEx //



//==========================================================================
//
// Test functions. The ocmanager will call these functions.
//
//==========================================================================



/*++

Routine Description: ComponentSetupProc (1.6)

	The DLL entry point. This function is called by the OC Manager whenever 
	it wants to send/recieve setup information to/from the component.
	Note that the ComponentId and SubcomponentId are LPCVOID because we 
	don't know in advance if they are ANSI or Unicode.
	 
Arguments:

	lpcvComponentId:	 supplies the id for the component. 
	lpcvSubcomponentId: supplies the id for the subcomponent. 
	uiFunction: 		   one of OC_XXX.
	uiParam1:			   its meaning depends on the function.
	pvParam2:			   its meaning depends on the function.
	
Return Value:

	Depends on the function (e.g. TRUE/FALSE for the language supported, 
	the number of pages supplied by the component, etc.).

--*/
EXPORT DWORD ComponentSetupProc(IN LPCVOID lpcvComponentId,
										  IN LPCVOID lpcvSubcomponentId,
										  IN UINT	  uiFunction,
										  IN UINT	  uiParam1,
										  IN PVOID	  pvParam2) 
{
	double fn = 1.6;
	
	DWORD			   dwRetval = NO_ERROR;
	PTCHAR			   tszComponentId	  = (PTCHAR)lpcvComponentId;
	PTCHAR			   tszSubcomponentId = (PTCHAR)lpcvSubcomponentId;
	TCHAR			   tsz[MAX_MSG_LEN];
	PCOMPONENT_DATA pcdComponentData = NULL; 
	TCHAR			   tszDlgMessage[256];

	PTCHAR			   tszDummy = NULL;
	
	ReturnOrAV		  raValue;
	
	static BOOL 	 bFirstTime = TRUE;
	
	//
	// Log the details about the call
	//
	LogOCFunction(lpcvComponentId, 
					  lpcvSubcomponentId, 
					  uiFunction, 
					  uiParam1, 
					  pvParam2);

	//if (uiFunction == g_uiFunctionToAV && uiFunction != OC_PREINITIALIZE && uiFunction != OC_INIT_COMPONENT) {
	//	  testAV(TRUE);
	//}

	causeAVPerComponent(uiFunction, lpcvComponentId);

	#ifndef UNICODE
	//if (g_bAccessViolation && !g_uiFunctionToAV) {
	//	  causeAV(uiFunction);
	//}
	#endif
	
	//		  
	// Check to see if valid component and subcomponent IDs were received
	//
	if (uiFunction > OC_INIT_COMPONENT && uiFunction < OCP_TEST_PRIVATE_BASE)
	{
		if (!FindSubcomponentInformationNode((PTCHAR)lpcvComponentId,
														 (PTCHAR)lpcvSubcomponentId))
		{
			 Log(fn, SEV2, TEXT("ComponentSetupProc function received %s.%s. ")
								TEXT("This is not a valid component.subcomponent."),
								lpcvComponentId, lpcvSubcomponentId);
		}
	}
	
	//
	// Whenever the user hits the next or back button, check all
	// the needs dependencies, exclude dependencies, 
	// and parent child dependencies
	//	  
	if (uiFunction == OC_QUERY_SKIP_PAGE		 || 
		 uiFunction == OC_QUEUE_FILE_OPS		  ||
		 uiFunction == OC_ABOUT_TO_COMMIT_QUEUE ||
		 uiFunction == OC_COMPLETE_INSTALLATION)
	{	 
		//
		// Check selection status of components to make sure all 
		// dependency relationships are being fulfilled.
		//
		CheckNeedsDependencies();
		CheckExcludeDependencies();
		CheckParentDependencies();
	}
	
	//
	// Enable the use of private functions
	//
	g_bUsePrivateFunctions = TRUE;	  

	if (g_bTestExtended || !bFirstTime){
	
		bFirstTime = FALSE;
		
		// Prepare to call TestReturnValueAndAV
		raValue.tszComponent = NULL;
		raValue.tszSubComponent = NULL;
		raValue.bOverride = FALSE;
		raValue.iReturnValue = 0;
		
		TestReturnValueAndAV(lpcvComponentId, 
									lpcvSubcomponentId, 
									uiFunction, 
									uiParam1, 
									pvParam2,
									&raValue);
	
	}
	
	
	switch (uiFunction)
	{
		case  OC_PREINITIALIZE:
			//testAV(g_bAccessViolation);
#ifdef UNICODE
			testAV(g_bCrashUnicode);
#endif
		
			dwRetval = RunOcPreinitialize(lpcvComponentId, 
													lpcvSubcomponentId, 
													uiParam1);
			break;
			
		case OC_INIT_COMPONENT:
			__ASSERT(pvParam2 != NULL);
			
			//
			// Init the log, now that OC Manager knows whether we 
			// are ANSI or Unicode 
			//
			_stprintf(tsz, TEXT("%s.log"), (PTCHAR)lpcvComponentId);
			InitLog(tsz, TEXT("OCManager Test Log"), TRUE);
						
			dwRetval = RunOcInitComponent(lpcvComponentId,
													lpcvSubcomponentId,
													pvParam2);
#ifdef UNICODE
			if (g_bCloseInf && hInfGlobal != NULL){
				SetupCloseInfFile(pcdComponentData->hinfMyInfHandle);
			}
#endif	  

			// Let's read the INF file and decide the values of some global variables

			if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
				 (pcdComponentData->hinfMyInfHandle != NULL) && 
				 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
			{
				SetGlobalsFromINF(pcdComponentData->hinfMyInfHandle);
			}

			//if (g_bNoWizPage) {
				// Check is there is a default mode specified in [OCTest] section
				SetDefaultMode(pcdComponentData);
			//}
			break;
			
		case OC_QUERY_STATE:			
			dwRetval = RunOcQueryState(lpcvComponentId, 
												lpcvSubcomponentId);
			if (dwRetval == SubcompOn) {
				//MessageBox(NULL, TEXT("Let's turn it on"), TEXT("OC_QUERY_STATE"), MB_OK);
			}
			break;
			
		case OC_SET_LANGUAGE:
			dwRetval = RunOcSetLanguage(lpcvComponentId, 
												 lpcvSubcomponentId, 
												 uiParam1);
			if (g_bNoLangSupport) {
				//MessageBox(NULL, TEXT("No Language Support"), TEXT("OC_SET_LANGUAGE"), MB_OK);
				dwRetval = FALSE;
			}
			break;
			
		case OC_QUERY_IMAGE:
			if (g_bInvalidBitmap){
				dwRetval = 1000;
			}
			else{
				dwRetval = RunOcQueryImage(lpcvComponentId, 
													lpcvSubcomponentId, 
													pvParam2);
			}
			break;
			
		case OC_REQUEST_PAGES:

			if (g_bNoWizPage){
				dwRetval = 0;
			}
			else{
				dwRetval = RunOcRequestPages(lpcvComponentId, 
													  uiParam1, 
													  pvParam2);
			}
			break;
			
		case OC_QUERY_CHANGE_SEL_STATE:
			dwRetval = RunOcQueryChangeSelState(lpcvComponentId, 
															lpcvSubcomponentId, 
															uiParam1);
			break;
			
		case OC_CALC_DISK_SPACE: 
			dwRetval = RunOcCalcDiskSpace(lpcvComponentId, 
													lpcvSubcomponentId, 
													uiParam1, 
													pvParam2);
			break;
			
		case OC_QUEUE_FILE_OPS:
			dwRetval = RunOcQueueFileOps(lpcvComponentId, 
												  lpcvSubcomponentId, 
												  pvParam2);
			break;
			
		case OC_NEED_MEDIA:
			//if (!g_bNoNeedMedia){
			//	  dwRetval = RunOcNeedMedia(lpcvComponentId, 
			//										uiParam1, 
			//										pvParam2);
			//}
			//else{
				dwRetval = NO_ERROR;
				Log(fn, SEV2, TEXT("OC_NEED_MEDIA is passed in for %s.%s. ")
								  TEXT("This should not happen according to the spec."),
								  lpcvComponentId, lpcvSubcomponentId);
				//MessageBox(NULL, TEXT("OC_NEED_MEDIA is passed to the DLL."), TEXT("OC_NEED_MEDIA"), MB_OK);
			//}
			break;
			
		case OC_QUERY_STEP_COUNT:
			dwRetval = RunOcQueryStepCount(lpcvComponentId);
			break;
			
		case OC_COMPLETE_INSTALLATION:
			dwRetval = RunOcCompleteInstallation(lpcvComponentId, 
															 lpcvSubcomponentId);

			if (g_bReboot) {
				if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
					 (pcdComponentData->hinfMyInfHandle != NULL) && 
					 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
				{
					//MessageBox(NULL, TEXT("A reboot is queued"), TEXT("Reboot"), MB_OK);
					//OcHelperSetReboot(pcdComponentData->ocrHelperRoutines.OcManagerContext, NULL);
					pcdComponentData->ocrHelperRoutines.SetReboot(pcdComponentData->ocrHelperRoutines.OcManagerContext,TRUE);
				}				 
			}
			break;
			
		case OC_CLEANUP:
			dwRetval = RunOcCleanup(lpcvComponentId);
			break;
				
		case OCP_TEST_PRIVATE_BASE:
			dwRetval = RunTestOcPrivateBase(lpcvSubcomponentId, 
													  uiParam1, 
													  pvParam2);
			break;

		case OCP_CHECK_NEEDS:
			
			if (pcdComponentData = LocateComponent(lpcvComponentId))
			{
				dwRetval = CheckLocalNeedsDependencies(
											 pcdComponentData->ocrHelperRoutines,
											 (PSUBCOMP)uiParam1,
											 ((PCHECK_NEEDS)pvParam2)->pclNeeds,
											 ((PCHECK_NEEDS)pvParam2)->tszNodesVisited);
			
				((PCHECK_NEEDS)pvParam2)->bResult = (BOOL)dwRetval;
				dwRetval = (DWORD)pvParam2;
			}
			else
			{
				Log(fn, SEV2, TEXT("Could not get component data of %s"),
								  lpcvComponentId);    
			}	 
			break;

		default: 
			dwRetval = (DWORD)FALSE;
	}

	if ((g_bTestExtended || !bFirstTime) && BeginTest() && raValue.bOverride){
		return raValue.iReturnValue;
	}
	else {
		return dwRetval;
	}

} // ComponentSetupProc //




/*++

Routine Description: RunOcPreinitialize (1.7)

	 Code to run if OC_PREINITIALIZE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcPreinitialize(IN LPCVOID lpcvComponentId, 
								 IN LPCVOID lpcvSubcomponentId, 
								 IN UINT	 uiParam1)
{								  
	DWORD dwComponentReturnValue = NO_ERROR;
	
	//
	// If the test is not extended, the return value
	// matches the native character width.
	//
	#ifdef UNICODE
	dwComponentReturnValue = OCFLAG_UNICODE;
	#else
	dwComponentReturnValue = OCFLAG_ANSI;
	#endif

	return dwComponentReturnValue;
	
} // RunOcPreinitialize //




/*++

Routine Description: RunOcInitComponent (1.8)

	 Code to run if OC_INIT_COMPONENT is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcInitComponent(IN LPCVOID lpcvComponentId,
								 IN LPCVOID lpcvSubcomponentId,
								 IN PVOID	 pvParam2)
{								  
	double fn = 1.8;
	
	PSETUP_INIT_COMPONENT psicInitComponent;
	PCOMPONENT_DATA 		pcdComponentData; 

	DWORD dwComponentReturnValue = NO_ERROR;

	TCHAR tszFunctionName[256];
	BOOL bSuccess;

	INFCONTEXT infContext;

	int nRequiredBufferSize = 255;
	
	TCHAR tszMsg[256];
	
	psicInitComponent = (PSETUP_INIT_COMPONENT)pvParam2;
	
	hInfGlobal = psicInitComponent->OCInfHandle;


	if (pcdComponentData = AddNewComponent(lpcvComponentId))
	{
		//
		// Save the INF file handle
		//
		pcdComponentData->hinfMyInfHandle = 
			(psicInitComponent->ComponentInfHandle == INVALID_HANDLE_VALUE)
			? NULL : psicInitComponent->ComponentInfHandle;
				
		if (pcdComponentData->hinfMyInfHandle)
		{
			SetupOpenAppendInfFile(NULL, 
										  pcdComponentData->hinfMyInfHandle, 
										  NULL); 
		}
				
		CreateSubcomponentInformationList(pcdComponentData->hinfMyInfHandle);
		
		_tcscpy(pcdComponentData->tszSourcePath, 
				  psicInitComponent->SetupData.SourcePath);
				
		_tcscpy(pcdComponentData->tszUnattendFile, 
				  psicInitComponent->SetupData.UnattendFile);
				
		pcdComponentData->ocrHelperRoutines = 
			psicInitComponent->HelperRoutines;
		pcdComponentData->dwlFlags = 
			psicInitComponent->SetupData.OperationFlags;
		dwComponentReturnValue = NO_ERROR;

		//
		// Initialize the "witness" file queue
		// 
		if ((g_FileQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE)
		{
			Log(fn, SEV2, TEXT("Unable to create file queue"));
		}

		// Determine where to AV
		bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, TEXT("OCTest"), TEXT("AccessViolation"), &infContext);

		if (bSuccess) {
			pcdComponentData->bAccessViolation = TRUE;
			bSuccess = SetupGetStringField(&infContext, 1, tszFunctionName, 255, &nRequiredBufferSize);
			if (bSuccess) {
				//_stprintf(tszMsg, TEXT("An access violation will be generated at %s of %s"), tszFunctionName, lpcvComponentId);
				//MessageBox(NULL, tszMsg, TEXT("Access Violation"), MB_OK);
				pcdComponentData->uiFunctionToAV = GetOCFunctionName(tszFunctionName);
			}
		}
		else{
			pcdComponentData->bAccessViolation = FALSE;
		}
		 

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}

	if (g_bTestExtended && (dwComponentReturnValue == NO_ERROR))
	{
		//
		// Let the user decide if the component is 
		// compatible with the OC Manager
		//
		ChooseVersionEx(lpcvComponentId, psicInitComponent);
		//ChooseAccessViolationEx();
	} 
	else
	{
		//
		// We put the same component version to be sure that can go on
		//
		psicInitComponent->ComponentVersion = 
			psicInitComponent->OCManagerVersion;
	}

	return dwComponentReturnValue;
	
} // RunOcInitComponent //




/*++

Routine Description: RunOcQueryState (1.9)

	 Code to run if OC_QUERY_STATE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryState(IN LPCVOID lpcvComponentId,
							 IN LPCVOID lpcvSubcomponentId)
{							  
	PCOMPONENT_DATA pcdComponentData = NULL;
			
	DWORD dwComponentReturnValue = NO_ERROR;	

	BOOL bSuccess;

	TCHAR tszKeyName[256];
	
	INFCONTEXT infContext;

	int nRequiredSize;

	TCHAR tszState[256];
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		if (!g_bTestExtended)
		{
			dwComponentReturnValue = SubcompUseOcManagerDefault;
		} 
		else
		{
			dwComponentReturnValue = 
				ChooseSubcomponentInitialState(lpcvComponentId, 
														 lpcvSubcomponentId);
		}
		
		_stprintf(tszKeyName, TEXT("%s.initState"),lpcvSubcomponentId);

		//MessageBox(NULL, TEXT("Going to look for the key"), tszKeyName, MB_OK);

		bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle,
												TEXT("OCTest"),
												tszKeyName,
												&infContext);

		if (bSuccess) {
			//MessageBox(NULL, TEXT("Key Found"), tszKeyName, MB_OK);
			bSuccess = SetupGetStringField(&infContext,
													 1,
													 tszState,
													 255,
													 &nRequiredSize);
			if (bSuccess) {
				//MessageBox(NULL, TEXT("String field fetched"), tszState, MB_OK);
				if (_tcscmp(tszState, TEXT("On")) == 0) {
					dwComponentReturnValue = SubcompOn;
				}
				else if (_tcscmp(tszState, TEXT("Off")) == 0) {
					dwComponentReturnValue = SubcompOff;
				}
				else{
					dwComponentReturnValue = SubcompUseOcManagerDefault;
				}
			}
		}

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = SubcompUseOcManagerDefault;
	}

	return dwComponentReturnValue;
	
} // RunOcQueryState //




/*++

Routine Description: RunOcSetLanguage (1.11)

	 Code to run if OC_SET_LANGUAGE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcSetLanguage(IN LPCVOID lpcvComponentId,
							  IN LPCVOID lpcvSubcomponentId,
							  IN UINT	  uiParam1)
{							   
	DWORD			   dwComponentReturnValue = NO_ERROR;
	PCOMPONENT_DATA pcdComponentData; 
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		//
		// If we won't support the language, the OC Manager won't 
		// continue, so we have to return TRUE
		//
		dwComponentReturnValue = (DWORD)TRUE;
		pcdComponentData->LanguageId = (LANGID)uiParam1;
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = (DWORD)FALSE;
	}

	return dwComponentReturnValue;
	
} // RunOcSetLanguage //




/*++

Routine Description: RunOcQueryImage (1.12)

	 Code to run if OC_QUERY_IMAGE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryImage(IN LPCVOID lpcvComponentId,
							 IN LPCVOID lpcvSubcomponentId,
							 IN PVOID	 pvParam2)
{							  
	double fn = 1.12;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	BOOL				bAux;
	TCHAR			   tszMsg[MAX_MSG_LEN]; 
	TCHAR			   tszResourceName[MAX_PATH]; 
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
			
	
	#ifdef DEBUG
	Log(fn, INFO, TEXT("Height = %d, Width = %d"), 
					  HIWORD(pvParam2), LOWORD(pvParam2)); 
	#endif
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) && 
		 (pcdComponentData->hinfMyInfHandle))
	{
		__ASSERT(LOWORD(uiParam1) == SubCompInfoSmallIcon);
		
		_stprintf(tszMsg, TEXT("%s.%s"), lpcvComponentId, lpcvSubcomponentId);
				
		if (SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, tszMsg, 
									  TEXT("Bitmap"), &infContext))
		{
			bAux = SetupGetStringField(&infContext, 1, tszResourceName, 
												sizeof(tszResourceName) / 
												sizeof(TCHAR), NULL);
					
			if (bAux)
			{
				//
				// Try to use Param1 and Param2 to resize the icon
				//
				dwComponentReturnValue = (DWORD)LoadBitmap(g_hDllInstance, 
																		 tszResourceName);
				  
				bAux = SetBitmapDimensionEx((HBITMAP)dwComponentReturnValue, 
													 LOWORD(pvParam2),	
													 HIWORD(pvParam2), 
													 NULL);
				#ifdef DEBUG
				if (bAux)
				{
					Log(fn, PASS, TEXT("Success"));
				} 
				else
				{
					_stprintf(tszMsg, TEXT("Can't resize %d"), 
											GetLastError());
					Log(fn, PASS, tszMsg);
				}
				#endif
			}
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	}

	return dwComponentReturnValue;

} // RunOcQueryImage //




/*++

Routine Description: RunOcRequestPages (1.13)

	 Code to run if OC_REQUEST_PAGES is called.
	 
Arguments:

	 lpcvComponentId:  supplies the id for the component. 
	 uiParam1:			  its meaning depends on the function.
	 pvParam2:			  its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcRequestPages(IN LPCVOID lpcvComponentId,
								IN UINT 	uiParam1,
								IN PVOID	pvParam2)
{
	DWORD			   dwComponentReturnValue = NO_ERROR;
	PCOMPONENT_DATA pcdComponentData; 
	TCHAR			   tsz[256];
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		dwComponentReturnValue = DoPageRequest(
													 pcdComponentData->tszComponentId, 
													 uiParam1, 
													 (PSETUP_REQUEST_PAGES)pvParam2, 
													 pcdComponentData->ocrHelperRoutines);
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		//
		// Some kind of error, 0 pages 
		//
		dwComponentReturnValue = -1;
	}
	
	return dwComponentReturnValue;

} // RunOcRequestPages //




/*++

Routine Description: RunOcQueryChangeSelState (1.14)

	 Code to run if OC_QUERY_CHANGE_SEL_STATE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryChangeSelState(IN LPCVOID lpcvComponentId, 
										 IN LPCVOID lpcvSubcomponentId, 
										 IN UINT	 uiParam1)
{										  
	DWORD			   dwComponentReturnValue = TRUE;
	TCHAR			   tszText[MAX_MSG_LEN];
	TCHAR			   tszSectionName[MAX_MSG_LEN];
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
		 (pcdComponentData->hinfMyInfHandle != NULL) && 
		 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
	{
		//
		// Check to see if this component should refuse to enable or
		// disable. The component should refuse if there is a field
		// called "RefuseSelect" or "RefuseDeselect" in the INF file.
		//
		if (lpcvSubcomponentId == NULL || 
			 _tcscmp((PTCHAR)lpcvSubcomponentId, TEXT("(null)")) == 0 ||
			 ((PTCHAR)lpcvSubcomponentId)[0] == TEXT('\0'))
		{
			_stprintf(tszSectionName, (PTCHAR)lpcvComponentId);
		}
		else
		{
			_stprintf(tszSectionName, (PTCHAR)lpcvSubcomponentId);
		}
		
		if (SetupFindFirstLine(
						  pcdComponentData->hinfMyInfHandle, 
						  tszSectionName,
						  uiParam1 ? TEXT("RefuseSelect") : TEXT("RefuseDeselect"),
						  &infContext))
		{
			dwComponentReturnValue = FALSE;
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = FALSE;
	}

	return dwComponentReturnValue;

} // RunOcQueryChangerSelState //




/*++

Routine Description: RunOcCalcDiskSpace (1.15)

	 Code to run if OC_CALC_DISK_SPACE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCalcDiskSpace(IN LPCVOID lpcvComponentId, 
								 IN LPCVOID lpcvSubcomponentId, 
								 IN UINT	 uiParam1,
								 IN PVOID	 pvParam2)
{								  
	DWORD			   dwComponentReturnValue = TRUE;
	BOOL				bAux, bRetval;
	TCHAR			   tszSectionName[MAX_PATH];
	TCHAR			   tszMsg[MAX_MSG_LEN];
	PCOMPONENT_DATA pcdComponentData; 
	INFCONTEXT		  infContext;
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
		 (pcdComponentData->hinfMyInfHandle))
	{
		//
		// Check to see if the file to be copied in this section is called
		// "hugefile.txt"  If it is, don't add the real size of this file.
		// Instead, add a gigantic file size so large that there won't
		// be enough disk space to complete the operation.
		//
		_stprintf(tszMsg, TEXT("%s.%s.copyfiles"),
								lpcvComponentId, lpcvSubcomponentId);
								
		bAux = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
										  tszSectionName, 
										  TEXT("hugefile.txt"),
										  &infContext);

		bAux = bAux && g_bHugeSize;
		 
		if (bAux)
		{
			//
			// hugefile.txt is present. 
			//
			if (uiParam1)
			{
				//
				// Add gigantic file size
				//
				bRetval = SetupAddToDiskSpaceList((HDSKSPC)pvParam2, 
															 TEXT("c:\\file.big"), 
															 ONE_HUNDRED_GIG, 
															 FILEOP_COPY,
															 0, 0);
			}
			else
			{
				//
				// Remove a gigantic file size
				//
				bRetval = SetupAddToDiskSpaceList((HDSKSPC)pvParam2, 
															 TEXT("c:\\file.big"), 
															 ONE_HUNDRED_GIG, 
															 FILEOP_COPY,
															 0, 0);
			}
		}
		else
		{
			//
			// Get the section name
			//
			_stprintf(tszMsg, TEXT("%s.%s"), lpcvComponentId, lpcvSubcomponentId);
				
			if (uiParam1)
			{
				//
				// Adding
				//
				bRetval = SetupAddInstallSectionToDiskSpaceList(
														 (HDSKSPC)pvParam2,
														 pcdComponentData->hinfMyInfHandle,
														 NULL, tszMsg, 0, 0);
			} 
			else
			{
				//
				// Removing
				//
				bRetval = SetupRemoveInstallSectionFromDiskSpaceList(
														 (HDSKSPC)pvParam2, 
														 pcdComponentData->hinfMyInfHandle,
														 NULL, tszMsg, 0, 0);
			}
		}
		
		dwComponentReturnValue = bRetval ? NO_ERROR : GetLastError();

				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}
 
	return dwComponentReturnValue;
 
} // RunOcCalcDiskSpace //




/*++				  

Routine Description: RunOcQueueFileOps (1.16)

	 Code to run if OC_QUEUE_FILE_OPS is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueueFileOps(IN LPCVOID lpcvComponentId, 
								IN LPCVOID lpcvSubcomponentId, 
								IN PVOID	pvParam2)
{								 
	double fn = 1.16;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	BOOL				bAux;
	BOOL				bCurrentState, bOriginalState;
	TCHAR			   tszMsg[MAX_MSG_LEN];
	TCHAR			   tszSectionName[MAX_PATH];
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
	PSUBCOMP		  pscTemp;
			
	//
	// Check to make sure this subcomponent is allowed to do work.
	// If the subcomponent is not a bottom leaf on the subcomponent
	// tree, it is not allowed to do any work. So we will check to 
	// see if it has any children.
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (lpcvSubcomponentId && _tcscmp(pscTemp->tszSubcomponentId, 
													 (PTCHAR)lpcvSubcomponentId) == 0)
		{
			if (pscTemp->pclChildren)
			{
				//
				// This subcomponent has children. OcManager should not be
				// try to queue file ops for this subcomponent. This is
				// a failure.
				//
				Log(fn, SEV2, TEXT("OC Manager is trying to queue file ops ")
								  TEXT("for subcomponent %s of component %s. ")
								  TEXT("This subcomponent has children and ")
								  TEXT("should not be allowed to do any work."),
								  lpcvSubcomponentId, lpcvComponentId);
				
				return NO_ERROR;
			}
		}
	}
	
	if (lpcvSubcomponentId && 
		 (pcdComponentData = LocateComponent(lpcvComponentId)))
	{
		//
		// Get original and current state. If the state didn't change,
		// nothing to do.
		//
		bOriginalState = 
			pcdComponentData->ocrHelperRoutines.QuerySelectionState(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								lpcvSubcomponentId,
								OCSELSTATETYPE_ORIGINAL);

		bCurrentState = 
			pcdComponentData->ocrHelperRoutines.QuerySelectionState(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								lpcvSubcomponentId,
								OCSELSTATETYPE_CURRENT);

		_stprintf(tszSectionName, TEXT("%s.%s"), 
										  lpcvComponentId, lpcvSubcomponentId);

		bAux = TRUE;
																				
		if (!bCurrentState)
		{
			//
			// Being uninstalled. Fetch uninstall section name.
			//
			bAux = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
											  tszSectionName, 
											  TEXT("Uninstall"),
											  &infContext);

			if (bAux)
			{
				bAux = SetupGetStringField(&infContext, 1, tszSectionName, 
													sizeof(tszSectionName) / 
													sizeof(TCHAR), NULL);
			}
		}

		if (bAux)
		{
			bAux = SetupInstallFilesFromInfSection(
												 pcdComponentData->hinfMyInfHandle, 
												 NULL, 
												 pvParam2,
												 tszSectionName, 
												 pcdComponentData->tszSourcePath,
												 bCurrentState ? SP_COPY_NEWER : 0);
					
			SetupInstallFilesFromInfSection(
												 pcdComponentData->hinfMyInfHandle,
												 NULL, 
												 g_FileQueue, 
												 tszSectionName, 
												 pcdComponentData->tszSourcePath,
												 bCurrentState ? SP_COPY_NEWER : 0);
					
			dwComponentReturnValue = bAux ? NO_ERROR : GetLastError();
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	}

	return dwComponentReturnValue;

} // RunOcQueueFileOps //




/*++

Routine Description: RunOcNeedMedia (1.17)

	 Code to run if OC_NEED_MEDIA is called.
	 
Arguments:

	 lpcvComponentId:  supplies the id for the component. 
	 uiParam1:			  its meaning depends on the function.
	 pvParam2:			  its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcNeedMedia(IN LPCVOID lpcvComponentId, 
							IN UINT 	uiParam1, 
							IN PVOID	pvParam2)
{			 
	PVOID pvQueueContext;
	DWORD dwComponentReturnValue;
	
	//
	// Nothing special to do if media is needed
	// Call the default queue routine
	//
	pvQueueContext = SetupInitDefaultQueueCallback(NULL);
	dwComponentReturnValue = SetupDefaultQueueCallback(pvQueueContext, 
																		SPFILENOTIFY_NEEDMEDIA, 
																		uiParam1, 
																		(UINT)pvParam2);
			
	 SetupTermDefaultQueueCallback(pvQueueContext);

	 return dwComponentReturnValue;
	 
} // RunOcNeedMedia //




/*++

Routine Description: RunOcQueryStepCount (1.18)

	 Code to run if OC_QUERY_STEP_COUNT is called.
	 
Arguments:

	 lpcvComponentId: supplies the id for the component. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryStepCount(IN LPCVOID lpcvComponentId)
{
	PCOMPONENT_DATA pcdComponentData; 
			 
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 

	return NO_STEPS_FINAL;

} // RunOcQueryStepCount //



			
/*++

Routine Description: RunOcCompleteInstallation (1.19)

	 Code to run if OC_COMPLETE_INSTALLATION is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCompleteInstallation(IN LPCVOID lpcvComponentId, 
										  IN LPCVOID lpcvSubcomponentId)
{										   
	double fn = 1.19;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	DWORD			   dwResult;
	INT 				iCount;
	BOOL				bAux;
	TCHAR			   tszMsg[MAX_MSG_LEN];
	PVOID			   pvCallbackContext;
	PCOMPONENT_DATA pcdComponentData; 
	
	//
	// Output the name of the component that is currently working
	//
	_stprintf(tszMsg, TEXT("OC_COMPLETE_INSTALLATION: Copying files for %s\n"), lpcvSubcomponentId);
	OutputDebugString(tszMsg);
			
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		// 
		// We perform the check for the top-level component 
		// We will scan the witness queue
		//
		pvCallbackContext = SetupInitDefaultQueueCallback(NULL);
				
		bAux = SetupScanFileQueue(g_FileQueue, 
										  SPQ_SCAN_FILE_PRESENCE, 
										  NULL, 
										  SetupDefaultQueueCallback, 
										  pvCallbackContext, 
										  &dwResult);
				
		SetupTermDefaultQueueCallback(pvCallbackContext);
				
		if (!dwResult)
		{
			Log(fn, SEV2, TEXT("Not all the files are on the target!"));
		}

		//
		// Check the helper routines
		//
		for (iCount = 0; iCount < nStepsFinal; iCount++)
		{
			//
			// From time to time (every 3 "ticks") change the progress text 
			//
			pcdComponentData->ocrHelperRoutines.TickGauge(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext);
					
			if (iCount % 3 == 1)
			{
				_stprintf(tszMsg, TEXT("%s Progress Text Changed Step %d "), 
										lpcvSubcomponentId, iCount); 
				
				pcdComponentData->ocrHelperRoutines.SetProgressText(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								tszMsg);
			}
					
			Sleep(10 * TICK_TIME);
		} 

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}

	return dwComponentReturnValue;

} // RunOcCompleteInstallation //




/*++

Routine Description: RunOcCleanup (1.21)

	 Code to run if OC_CLEANUP is called.
	 
Arguments:

	 lpcvComponentId: supplies the id for the component. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCleanup(IN LPCVOID lpcvComponentId)
{
	UINT uiCount;
	
	RemoveComponent(lpcvComponentId);	 
			
	g_bFirstTime = TRUE;
			
	//
	// Close the witness file queue
	//
	SetupCloseFileQueue(g_FileQueue);

	return NO_ERROR;
	
} // RunOcCleanup //




/*++

Routine Description: RunTestOcPrivateBase (1.22)

	 Code to run if OCP_TEST_PRIVATE_BASE is called.
	 
Arguments:

	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunTestOcPrivateBase(IN LPCVOID lpcvSubcomponentId, 
									IN UINT 	uiParam1, 
									IN PVOID	pvParam2)
{							   
	//
	// Will send back the value in Param1.
	// But first, assert that the subcomponent is NULL, 
	// as well as the Param2
	//
	__ASSERT((lpcvSubcomponentId == NULL) && (pvParam2 == NULL));

	return uiParam1;

} // RunTestOcPrivateBase //			




/*++

Routine Description: TestHelperRoutines (1.5)

	Tests the helper routines, using the functions above.
	
Arguments:

	OCManagerRoutines: the helper routines.
	
Return Value:

	DWORD: error return

--*/
DWORD TestHelperRoutines(IN LPCVOID lpcvComponentId,
								 IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.5;
	
	DWORD dwPreviousMode, dwSetPreviousMode, dwSetupMode, dwRandomSetupMode;
	DWORD dwComponentReturnValue;
	DWORD dwError;
	TCHAR tszMsg[MAX_MSG_LEN];
	BOOL  bQueryReturn;

	//
	// Test TickGauge - the call is ignored except when the component
	// is allowed to perform its own (final) setup and informs the OC Manager
	// about the number of steps this setup will require. 
	// For each such step, the OC Manager ticks the gauge once.
	//
	OCManagerRoutines.TickGauge(OCManagerRoutines.OcManagerContext);

	//
	// Test SetProgressText - the call is ignored except the final stage
	// (the text above the tick gauge is set this way)
	//
	OCManagerRoutines.SetProgressText(OCManagerRoutines.OcManagerContext, 
												 TEXT("Progress text"));
	
	//
	// Test Get/SetPrivateData
	//
	TestPrivateData(OCManagerRoutines);

	//
	// Test Get/SetSetupMode
	//
	
	//
	// Get the original mode first
	//
	dwPreviousMode = OCManagerRoutines.GetSetupMode(
													  OCManagerRoutines.OcManagerContext);
	
	dwRandomSetupMode = (DWORD)rand();
	
	//
	// The return value should be the previous mode
	//
	dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwRandomSetupMode);

	if (dwPreviousMode != dwSetPreviousMode)
	{
		Log(fn, SEV2, TEXT("SetSetupMode failed. Return value is not equal ")
						  TEXT("to previous mode: Previous = %lu Return = %lu ") 
						  TEXT("New Mode = %lu"), 
						  dwPreviousMode, dwSetPreviousMode, dwRandomSetupMode);
	}
	else
	{
		//
		// Set the mode again
		// The first 24 bits are private data, the last 8 are the mode
		//
		dwSetupMode = ((DWORD)rand()) << 8;
	
		//
		// So, get the last 8 bits from PreviousMode
		//
		dwSetupMode |= (dwPreviousMode & 0xFF);
		dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwSetupMode);
	
		if (dwRandomSetupMode != dwSetPreviousMode)
		{
			Log(fn, SEV2, TEXT("SetSetupMode failed. Return value is not ")
							  TEXT("equal to previous mode: Previous = %lu ")
							  TEXT("Return = %lu New Mode = %lu"), 
							  dwRandomSetupMode, dwSetPreviousMode, dwSetupMode);
		}
	}
	
	//
	// Leave the mode back at its original state
	//
	dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwPreviousMode);
	
	//
	// Test QuerySelectionState
	//
	
	//
	// Perform negative testing first : use an inexistent component name
	// Expect to get ERROR_INVALID_NAME
	//
	bQueryReturn = OCManagerRoutines.QuerySelectionState(
														OCManagerRoutines.OcManagerContext, 
														TEXT("Phony component"), 
														OCSELSTATETYPE_ORIGINAL);
	
	if ((bQueryReturn == FALSE) && 
		 ((dwError = GetLastError()) != ERROR_INVALID_NAME ))
	{
		Log(fn, SEV2, TEXT("QuerySelectionState returned error %lu ")
						  TEXT("when called with phony name"), dwError);
	}
	
	bQueryReturn = OCManagerRoutines.QuerySelectionState(
														OCManagerRoutines.OcManagerContext, 
														TEXT("Phony component"), 
														OCSELSTATETYPE_CURRENT);
	
	if ((bQueryReturn == FALSE) && 
		 ((dwError = GetLastError()) != ERROR_INVALID_NAME ))
	{
		Log(fn, SEV2, TEXT("QuerySelectionState returned error %lu ")
						  TEXT("when called with phony name"), dwError); 
	}

	SetLastError(NO_ERROR);
	
	//
	// Tests the private function calls
	// Save the return value first : this is done because another 
	// component is called and the return value is modified
	//
	dwComponentReturnValue = TestPrivateFunction(lpcvComponentId,
																OCManagerRoutines);

	return dwComponentReturnValue;

} // TestHelperRountines //




/*++

Routine Description: TestPrivateFunction (1.4)

	Tests the private function calls 
	(these are used for inter-component communication)
	
Arguments:

	OCManagerRoutines: the helper routines (CallPrivateFunction is a member 
														 of this structure)
	
Return Value:

	DWORD: error value

--*/
DWORD TestPrivateFunction(IN LPCVOID lpcvComponentId,
								  IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.4;
	
	DWORD	  dwComponentReturnValue = ERROR_SUCCESS;
	UINT	  uiRemoteResult = 0;
	UINT	  uiLocalResult = 0;
	UINT	  uiRandomValue = 0;
	BOOL	  bBlank = FALSE;
	BOOL	  bOtherComponent = FALSE;
	TCHAR	  tszComponent[MAX_PATH];
	TCHAR	  tszOtherComponent[MAX_PATH];
	TCHAR	  tszStandalone[MAX_PATH];
	TCHAR	  tszMsg[MAX_MSG_LEN];
	TCHAR	  tszSubComp[] = TEXT("");
	PSUBCOMP pscTemp;

	//
	// Copy the current component
	//
	_tcscpy(tszComponent, (PTCHAR)lpcvComponentId);
	
	//
	// Find another component, if one exists
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (_tcscmp(tszComponent, pscTemp->tszComponentId) != 0)
		{
			bOtherComponent = TRUE;
			_tcscpy(tszOtherComponent, pscTemp->tszComponentId);
			break;
		}
	}

	//
	// 1. Call the same component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszComponent,
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_BAD_ENVIRONMENT)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_BAD_ENVIRONMENT, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}

	//
	// 2. Call a non-existing component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														TEXT("No component"), 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_INVALID_FUNCTION)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}
	
	//
	// 3. Call the standalone component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszStandalone, 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_INVALID_FUNCTION)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}
	
	if (bOtherComponent)
	{
		//
		// 4. Call the other component with OC_PRIVATE_BASE - 1
		//
		uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszOtherComponent,
														tszSubComp, 
														OC_PRIVATE_BASE - 1, 
														0, 0, &uiRemoteResult);
	
		if (uiLocalResult != ERROR_INVALID_FUNCTION)
		{
			Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
							  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
							  uiLocalResult);
			bBlank = TRUE;
		}

		//
		// 5. A normal call : we will supply a random number and will expect 
		//	   to receive as a result the same value. This is true if the 
		//	   private calls are allowed	  
		//
		uiRandomValue = (UINT)(rand() + 1);
	
		//
		// To be sure the two values are not equal
		//
		uiRemoteResult = 0;
		uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszOtherComponent, 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														uiRandomValue, 
														0, 
														&uiRemoteResult);
	
		if (uiLocalResult != ERROR_ACCESS_DENIED)
		{
			if (g_bUsePrivateFunctions && (uiLocalResult != NO_ERROR))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction called on %s for ")
								  TEXT("OCP_TEST_PRIVATE_BASE returned %lu"),
								  tszOtherComponent, uiLocalResult);
				bBlank = TRUE;
			}
	
			if (!g_bUsePrivateFunctions && 
				 (uiLocalResult != ERROR_BAD_ENVIRONMENT))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
								  TEXT("ERROR_BAD_ENVIRONMENT, received %lu"),
								  uiLocalResult);
				bBlank = TRUE;
			}
	
			if (g_bUsePrivateFunctions && (uiRemoteResult != uiRandomValue))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction: received invalid data ")
								  TEXT("from routine. Expected %lu, received %lu"),
								  uiRandomValue, uiRemoteResult);
				bBlank = TRUE;
			}
		}
	}
	
	if (bBlank) LogBlankLine();

	return dwComponentReturnValue;
	
} // TestPrivateFunction //




/*++

Routine Description: TestPrivateData (1.3)

	Checks all the OC Manager values against the local ones,
	then it randomly changes one value. 

Arguments:

	OCManagerRoutines: the helper routines (Get/SetPrivateData are members 
														 of this structure)
	
Return Value:

	void

--*/
VOID TestPrivateData(IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.3;
	
	PVOID		  pvBuffer;
	UINT		  uiCount, uiRandomValue;
	BOOL		  bResult;
	
	PRIVATE_DATA aPrivateDataTable[] = 
	{
		{TEXT("Binary value"),			  REG_BINARY,	 0, NULL, NULL},
		{TEXT("Binary value 2"),		 REG_BINARY,	0, NULL, NULL},
		{TEXT("String value"),			  REG_SZ,		  0, NULL, NULL},
		{TEXT("String value 2"),		 REG_SZ,		 0, NULL, NULL},
		{TEXT("Multi String value"),	REG_MULTI_SZ, 0, NULL, NULL},
		{TEXT("Multi String value 2"), REG_MULTI_SZ, 0, NULL, NULL},
		{TEXT("DWORD value"),			  REG_DWORD,	 0, NULL, NULL},
		{TEXT("DWORD value 2"), 		 REG_DWORD, 	0, NULL, NULL}
	};
	
	//
	// Set all the values
	//
	for (uiCount = 0; uiCount < MAX_PRIVATE_VALUES; uiCount++)
	{
		bResult = SetAValue(OCManagerRoutines, uiCount, aPrivateDataTable);
	}
		
	//
	// Check all the values against the local table
	//
	CheckPrivateValues(OCManagerRoutines, aPrivateDataTable);

	free(aPrivateDataTable[0].pvBuffer);
	free(aPrivateDataTable[1].pvBuffer);
	free(aPrivateDataTable[2].pvBuffer);
	free(aPrivateDataTable[3].pvBuffer);
	free(aPrivateDataTable[4].pbBuffer);
	free(aPrivateDataTable[5].pbBuffer);
	free(aPrivateDataTable[6].pvBuffer);
	free(aPrivateDataTable[7].pvBuffer);
	
	return;

} // TestPrivateData //




/*++

Routine Description: CheckPrivateValues (1.2)

	Checks the values of the private data stored by the OC Manager against
	those stored internally by the application.
	
Arguments:

	OCManagerRoutines: the helper routines (GetPrivateData is a member of 
														 this structure)
	
Return Value:

	void

--*/
VOID CheckPrivateValues(IN OCMANAGER_ROUTINES OCManagerRoutines,
								IN PRIVATE_DATA 		*aPrivateDataTable)
{
	double fn = 1.2;
	
	UINT	uiCount, uiSize, uiType;
	DWORD  dwErrorCode;
	PVOID  pvBuffer = NULL;
	PTCHAR tszBuffer;
	TCHAR  tszMsg[MAX_MSG_LEN];
	TCHAR  tszError[MAX_ERROR_LEN];

	for (uiCount = 0; uiCount < MAX_PRIVATE_VALUES; uiCount++)
	{
		//
		// First call is used only to get the size of the data
		// Only the second one will actually retrieve it
		//
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													  OCManagerRoutines.OcManagerContext,
													  NULL,
													  aPrivateDataTable[uiCount].tszName,
													  NULL,
													  &uiSize,
													  &uiType);
		
		if (dwErrorCode != NO_ERROR)
		{
			Log(fn, SEV2, TEXT("GetPrivateData failed for %s: %s"), 
							  aPrivateDataTable[uiCount].tszName, 
							  ErrorMsg(dwErrorCode, tszError));
			continue;
		}
		
		
		if (pvBuffer) __Free(&pvBuffer);
		__Malloc(&pvBuffer, uiSize);
		
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													 OCManagerRoutines.OcManagerContext,
													 NULL,
													 aPrivateDataTable[uiCount].tszName,
													 pvBuffer,
													 &uiSize,
													 &uiType);
		
		if (dwErrorCode != NO_ERROR)
		{
			Log(fn, SEV2, TEXT("GetPrivateData failed for %s: %s"),
							  aPrivateDataTable[uiCount].tszName, 
							  ErrorMsg(dwErrorCode, tszError));
			continue;
		}

		//
		// Now perform the actual checking
		// The type first
		//
		if (uiType != aPrivateDataTable[uiCount].uiType)
		{
			Log(fn, SEV2, TEXT("GetPrivateData: Retrieved type %d ")
							  TEXT("instead of %d"), 
							  uiType, aPrivateDataTable[uiCount].uiType);
		}
		
		//
		// Then the size 
		//
		if (uiSize != aPrivateDataTable[uiCount].uiSize)
		{
			if (uiType == REG_SZ)
			{
				tszBuffer = (PTCHAR)pvBuffer;
				_stprintf(tszMsg, TEXT("GetPrivateData: Size retrieved %d ")
										TEXT("expected %d, ")
										TEXT("pvBuffer = %s, known buffer = %s, ") 
										TEXT("Chars %u %u %u %u"), 
										uiSize, 
										aPrivateDataTable[uiCount].uiSize, 
										tszBuffer, 
										aPrivateDataTable[uiCount].pvBuffer, 
										tszBuffer[uiSize - 4], 
										tszBuffer[uiSize - 3], 
										tszBuffer[uiSize - 2], 
										tszBuffer[uiSize - 1]);
			} 
			else
			{
				if (uiType == REG_MULTI_SZ)
				{
					TCHAR tszAux[MAX_MSG_LEN];

					_stprintf(tszMsg, TEXT("MULTI_SZ Size retrieved %d, ")
											TEXT("expected %d, pvBuffer = "), 
											uiSize, aPrivateDataTable[uiCount].uiSize); 
					tszBuffer = (PTCHAR)pvBuffer;
					MultiStringToString(tszBuffer, tszAux);
					_tcscat(tszMsg, tszAux);

					_tcscat(tszMsg, TEXT(" and known buffer = "));

					tszBuffer = (PTCHAR)aPrivateDataTable[uiCount].pvBuffer;
					MultiStringToString(tszBuffer, tszAux);
					_tcscat(tszMsg, tszAux);
				} 
				else
				{
					_stprintf(tszMsg, TEXT("Size retrieved %d instead %d"), 
											uiSize, aPrivateDataTable[uiCount].uiSize);
				}				  
			}

			Log(fn, SEV2, tszMsg);
		}

		if (uiType == REG_BINARY)
		{
			if (memcmp(pvBuffer, 
						  aPrivateDataTable[uiCount].pbBuffer, 
						  aPrivateDataTable[uiCount].uiSize))
			{
				Log(fn, SEV2, TEXT("Private data %s, Received %s expected %s"), 
								  aPrivateDataTable[uiCount].tszName, 
								  (PTSTR)pvBuffer, 
								  (PTSTR)aPrivateDataTable[uiCount].pbBuffer);
			}
		}
		else
		{
			if (memcmp(pvBuffer, 
						  aPrivateDataTable[uiCount].pvBuffer, 
						  aPrivateDataTable[uiCount].uiSize))
			{
				Log(fn, SEV2, TEXT("Private data %s, Received %s expected %s"), 
								  aPrivateDataTable[uiCount].tszName, 
								  (PTSTR)pvBuffer, 
								  (PTSTR)aPrivateDataTable[uiCount].pvBuffer);
			}
		}
		
		//
		// Try to use a smaller buffer - should get an error code
		//
		uiSize--;
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													  OCManagerRoutines.OcManagerContext,
													  NULL,
													  aPrivateDataTable[uiCount].tszName,
													  pvBuffer,
													  &uiSize,
													  &uiType);
		
		if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER)
		{
			Log(fn, SEV2, TEXT("GetPrivateData returned %s when called ")
							  TEXT("with small buffer size for %s"),
							  ErrorMsg(dwErrorCode, tszError), 
							  aPrivateDataTable[uiCount].tszName);
			continue;
		}
		__Free(&pvBuffer);
	} 

	if (pvBuffer) __Free(&pvBuffer);
	
} // CheckPrivateValues //




/*++

Routine Description: SetAValue (1.1)

	 Sets the value of a variable from the private data. The variable 
	 that will be changed is randomly selected.
	
Arguments:

	OCManagerRoutines: the helper routines (SetPrivateData is a member 
							 of this structure)
	
	uiIndex:			  the index of the variable to change
	
Return Value:

	BOOL: TRUE if value is set, FALSE if not

--*/
BOOL SetAValue(IN	   OCMANAGER_ROUTINES OCManagerRoutines,
					IN		UINT					uiIndex,
					IN OUT PRIVATE_DATA 		*aPrivateDataTable)
{
	double fn = 1.1;
	
	UINT	uiAuxIndex;
	UINT	uiOffset;
	DWORD  dwRandomValue;
	PTCHAR tszBuffer;
	TCHAR  tszMsg[MAX_MSG_LEN];

	switch (aPrivateDataTable[uiIndex].uiType)
	{
		case REG_DWORD:
			
			aPrivateDataTable[uiIndex].uiSize = sizeof(DWORD);
	
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
											 
			//
			// Fill in the buffer
			//
			dwRandomValue = (DWORD)rand();
			memcpy(aPrivateDataTable[uiIndex].pvBuffer, 
					 &dwRandomValue, 
					 aPrivateDataTable[uiIndex].uiSize);
			
			//
			// Set the private data "with" the OC Manager
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pvBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;

		case REG_BINARY:
			
			aPrivateDataTable[uiIndex].uiSize = 
				(UINT)(rand() % MAX_PRIVATE_DATA_SIZE) + 1;
			
			aPrivateDataTable[uiIndex].pbBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
				
			//
			// Fill in the buffer
			//
			for (uiAuxIndex = 0; 
				  uiAuxIndex < aPrivateDataTable[uiIndex].uiSize; 
				  uiAuxIndex++)
			{
				aPrivateDataTable[uiIndex].pbBuffer[uiAuxIndex] = (BYTE)rand();
			} 
			
			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pbBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;
		
		case REG_SZ:
			
			uiAuxIndex = (UINT)(rand() % MAX_STRINGS_FOR_PRIVATE_DATA);
			
			aPrivateDataTable[uiIndex].uiSize = 
				(_tcslen(g_atszStringValues[uiAuxIndex]) + 1) * sizeof(TCHAR);
			
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
			
			//
			// Fill in the buffer
			//
			_tcscpy((PTSTR)aPrivateDataTable[uiIndex].pvBuffer, 
					  g_atszStringValues[uiAuxIndex]);

			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													 OCManagerRoutines.OcManagerContext,
													 aPrivateDataTable[uiIndex].tszName,
													 aPrivateDataTable[uiIndex].pvBuffer,
													 aPrivateDataTable[uiIndex].uiSize,
													 aPrivateDataTable[uiIndex].uiType);
			break;

		case REG_MULTI_SZ:
			
			uiAuxIndex = (UINT)(rand() % MAX_MULTI_STRINGS_FOR_PRIVATE_DATA);
			
			aPrivateDataTable[uiIndex].uiSize = 
				MultiStringSize(g_atszMultiStringValues[uiAuxIndex]);
			
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
				
			//
			// Fill in the buffer
			//
			CopyMultiString((PTSTR)aPrivateDataTable[uiIndex].pvBuffer, 
								 g_atszMultiStringValues[uiAuxIndex]);

			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pvBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;

		default: 
			break;
	}

	return TRUE;

} // SetAValue //




/*++

Routine Description: ChooseSubcomponentInitialState (1.31)

	"Wrapper" routine for the dialog box procedure ChooseSuncomponentDlgProc.
	 
Arguments:

	lpcvComponentId:	 supplies the id for the component. 
	lpcvSubcomponentId: supplies the id for the subcomponent.
	
Return Value:

	void

--*/
DWORD ChooseSubcomponentInitialState(IN LPCVOID lpcvComponentId,
												 IN LPCVOID lpcvSubcomponentId) 
{
	TCHAR  tszDlgBoxMessage[MAX_MSG_LEN];
	
	//							   
	// We will display a dialog box so the user can choose the 
	// initial state he/she wants
	//
	_stprintf(tszDlgBoxMessage, TEXT("%s, %s"), 
										 lpcvComponentId, lpcvSubcomponentId);
	
	return DialogBoxParam(g_hDllInstance, 
								 MAKEINTRESOURCE(IDD_DIALOG3), 
								 NULL, 
								 ChooseSubcomponentDlgProc,
								 (LPARAM)tszDlgBoxMessage);

} // ChooseSubcomponentInitialState //




/*++

Routine Description: AddNewComponent (1.32)

	Add a new component to the list
	
Arguments:

	tszComponentId: supplies id of component to be added to the list.

Return Value:

	Pointer to new per-component data structure or NULL if no memory.
	The structure will be zeroed out except for the ComponentId field.

--*/
PCOMPONENT_DATA AddNewComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux;

	if (__Malloc(&pcdAux, sizeof(COMPONENT_DATA)))
	{
		__Malloc(&(PTCHAR)(pcdAux->tszComponentId), 
					(_tcslen(tszComponentId) + 1) * sizeof(TCHAR));
		
		if (pcdAux->tszComponentId)
		{
			_tcscpy((PTSTR)pcdAux->tszComponentId, tszComponentId);
			
			//
			// Prepend at the begining
			//
			pcdAux->Next  = g_pcdComponents;
			g_pcdComponents = pcdAux;
		} 
	}

	return pcdAux;

} // AddNewComponent //




/*++

Routine Description: LocateComponent (1.33)

	Locate a component by name from the list of components
	that this dll has been assigned to handle via
	OC_INIT_COMPONENT.

Arguments:

	tszComponentId: supplies the id for the component to look up.

Return Value:

	Pointer to component data or NULL if not found.

--*/
PCOMPONENT_DATA LocateComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux;

	for (pcdAux = g_pcdComponents; pcdAux; pcdAux = pcdAux->Next)
	{
		if (!(_tcscmp(pcdAux->tszComponentId, tszComponentId)))
		{
			break;
		}
	}
	return pcdAux;

} // LocateComponent //




/*++

Routine Description: RemoveComponent (1.34)

	Locate a component by name from the list of components and
	then remove it from the list of components.

Arguments:

	tszComponentId: supplies the id for the component to remove.

Return Value:

	void

--*/
VOID RemoveComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux, pcdPrev;

	for (pcdPrev = NULL, pcdAux = g_pcdComponents; 
		  pcdAux; 
		  pcdPrev = pcdAux, pcdAux = pcdAux->Next)
	{
		if (!(_tcscmp(pcdAux->tszComponentId, tszComponentId)))
		{
			__Free(&(PTCHAR)(pcdAux->tszComponentId));
			if (pcdPrev)
			{
				pcdPrev->Next = pcdAux->Next;
			} 
			else
			{
				g_pcdComponents = pcdAux->Next;
			}
			__Free(&pcdAux);
			break;
		}
	}
	return;

} // RemoveComponent //




/*++

Routine Description: CleanUpTest (1.35)

	 Frees globally allocated memory before the test exits

Arguments:

	 none

Return Value:

	 void

--*/
VOID CleanUpTest()
{
	USHORT i;
	PCOMPONENT_DATA pcdAux = g_pcdComponents, pcdNext;
	
	while (pcdAux)
	{
		pcdNext = pcdAux->Next;
		
		__Free(&(PTCHAR)(pcdAux->tszComponentId));
		__Free(&pcdAux);
			
		pcdAux = pcdNext;
	}
	
	FreeSubcomponentInformationList();
	
	return;
	
} // CleanUpTest //




/*++

Routine Description: CreateSubcomponentInformationList (1.23)

	 Creates a linked list of every subcomponent. For each subcomponent,
	 tells the parent of the subcomponent and whether or not the 
	 subcomponent has any children.

Arguments:

	 hinf: handle to inf file

Return Value:

	 BOOL: TRUE if function succeeds, FALSE if it fails

--*/
BOOL CreateSubcomponentInformationList(IN HINF hinf)
{
	double fn = 1.23;
	
	int 				i, j;
	USHORT			   usIdLen;
	USHORT			   usParentIndex;
	LONG				lLine, lLineCount;
	DWORD			   dwSize;
	BOOL				bRetval;
	BOOL				bFound;
	TCHAR			   tszSubcomponent[MAX_PATH];
	TCHAR			   tszParent[MAX_PATH];
	TCHAR			   tszError[MAX_ERROR_LEN];
	TCHAR			   tszNeeds[MAX_PATH];
	TCHAR			   tszExclude[MAX_PATH];
	INFCONTEXT		  infContext;
	PSUBCOMP		  pscSubcomponent, pscTemp, pscParent, pscChild;
	PCOMPLIST		  pclNeeds, pclExclude, pclChild, pclTemp;
			
	lLineCount = SetupGetLineCount(hinf, TEXT("Optional Components"));
											 
	if (lLineCount < 0)
	{
		Log(fn, SEV2, TEXT("Could not get number of lines in Optional ")
						  TEXT("Components section of inf file: %s"),
						  ErrorMsg(GetLastError(), tszError));
		return FALSE;
	}											  
	
	for (lLine = 0; lLine < lLineCount; lLine++)
	{
		bRetval = SetupGetLineByIndex(hinf,
												TEXT("Optional Components"),
												lLine,
												&infContext);
												
		if (!bRetval)
		{
			Log(fn, SEV2, TEXT("Could not get line %d from Optional ")
							  TEXT("Components section of inf file: %s"),
							  lLine, ErrorMsg(GetLastError(), tszError));
			return FALSE;
		}	 
		
		bRetval = SetupGetLineText(&infContext,
											NULL,
											NULL,
											NULL,
											tszSubcomponent,
											MAX_PATH,
											&dwSize);
											
		if (!bRetval)
		{
			Log(fn, SEV2, TEXT("Could not get text of line %d from ")
							  TEXT("Optional Components section of inf file: %s"),
							  lLine, ErrorMsg(GetLastError(), tszError));
			return FALSE;
		}	 
											
		//
		// Allocate a new subcomponent structure
		//
		if (!__Malloc(&pscSubcomponent, sizeof(SUBCOMP)))
		{
			Log(fn, SEV2, TEXT("Could not allocate space for ")
							  TEXT("pscSubcomponent"));
			return FALSE;
		}
		
		pscSubcomponent->pclNeeds = NULL;
		pscSubcomponent->pclExclude = NULL;
		pscSubcomponent->pclChildren = NULL;
		pscSubcomponent->Next = NULL;
		
		//
		// Find out the subcomponent id's length
		//
		usIdLen = (USHORT) _tcslen(tszSubcomponent);
	
		//
		// Copy the ComponentId. All of the test inf's use a special
		// SubcomponentId naming format, so that the subcomponent is a 
		// superset of the ComponentId. For example, if the component
		// name is "component" the subcomponet names will be
		// "component_1", "component_2", "component_1_2", etc.
		//
		for (i = 0; i < usIdLen; i++)
		{
			if (tszSubcomponent[i] == TEXT('_'))
			{
				break;
			}
			else
			{
				pscSubcomponent->tszComponentId[i] = tszSubcomponent[i];
			}
		}
		pscSubcomponent->tszComponentId[i] = TEXT('\0');
			
		
		//
		// if the subcomponent has a parent, get the name of the parent, store
		// it, and then search for this parent amongst the subcomponents
		// we've already processed. If the parent is found, mark the parent
		// so we know that the parent has children.
		// 
		
		//
		// Record the name of the parent.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Parent"), 
									  &infContext))
		{
			bRetval = SetupGetStringField(&infContext, 
													1, 
													tszParent, 
													MAX_PATH,
													NULL);
			if (!bRetval)
			{
				//
				// Parent name is empty. This is an invalid INF, but 
				// we'll go with it.
				//
				ZeroMemory(tszParent, MAX_PATH);
			}
			else
			{
				//
				// Search through the subcomponent list for this parent
				//
				for (pscParent = g_pscHead; 
					  pscParent != NULL; 
					  pscParent = pscParent->Next)
				{
					if (_tcscmp(tszParent, pscParent->tszSubcomponentId) == 0)
					{
						//
						// Found the parent subcomponent node. Add the current
						// subcomponent to the parent node's children list,
						// if it isn't there already
						//
						bFound = FALSE;
						for (pclTemp = pscParent->pclChildren;
							  pclTemp != NULL;
							  pclTemp = pclTemp->Next)
						{
							if (_tcscmp(pclTemp->tszSubcomponentId, 
											tszSubcomponent) == 0)
							{
								bFound = TRUE;				   
							}
						}
					  
						if (!bFound)
						{
							if (!__Malloc(&pclChild, sizeof(COMPLIST)))
							{
								Log(fn, SEV2, TEXT("Out of memory"));
								break;
							}

							_tcscpy(pclChild->tszSubcomponentId, tszSubcomponent);
							pclChild->Next = pscParent->pclChildren;
							pscParent->pclChildren = pclChild;
						}
					}
				}
			}
		}
		else
		{
			//
			// This component has no parent. Assume this is the top-level
			// component and assign it's parent's name as itself
			//
			_tcscpy(tszParent, tszSubcomponent);
		}	 
	
		_tcscpy(pscSubcomponent->tszParentId, tszParent);
		
		//
		// Now search through the list to see if any of the subcomponents
		// in the list are children of this new subcomponent
		//
		for (pscChild = g_pscHead; pscChild != NULL; pscChild = pscChild->Next)
		{
			if (_tcscmp(tszSubcomponent, pscChild->tszParentId) == 0)
			{
				//
				// Found a node that is the child of the current
				// node. Add this child to the current node's
				// child list, if it isn't there already
				//
				bFound = FALSE;
				for (pclTemp = pscSubcomponent->pclChildren;
					  pclTemp != NULL;
					  pclTemp = pclTemp->Next)
				{
					if (_tcscmp(pclTemp->tszSubcomponentId, 
									pscChild->tszSubcomponentId) == 0)
					{
						bFound = TRUE;				   
					}
				}
				
				if (!bFound)
				{	 
					if (!__Malloc(&pclChild, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclChild->tszSubcomponentId, 
							  pscChild->tszSubcomponentId);
					pclChild->Next = pscSubcomponent->pclChildren;
					pscSubcomponent->pclChildren = pclChild;
				}	 
			}
		}
	
		//
		// Fill in the rest of the data for the new node
		//
		_tcscpy(pscSubcomponent->tszSubcomponentId, tszSubcomponent);
	
		//
		// See if this node has any needs relationships. If it does,
		// record them.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Needs"), 
									  &infContext))
		{
			for (i = 1, bRetval = TRUE; bRetval; i++)
			{
				bRetval = SetupGetStringField(&infContext, 
														i, 
														tszNeeds, 
														MAX_PATH,
														NULL);
		
				if (bRetval)
				{
					if (!__Malloc(&pclNeeds, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclNeeds->tszSubcomponentId, tszNeeds);
					pclNeeds->Next = pscSubcomponent->pclNeeds;
					pscSubcomponent->pclNeeds = pclNeeds;
				}
			}
		}
				
		//
		// See if this node has any exclude relationships. If it does,
		// record them.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Exclude"), 
									  &infContext))
		{
			for (i = 1, bRetval = TRUE; bRetval; i++)
			{
				bRetval = SetupGetStringField(&infContext, 
														i, 
														tszExclude, 
														MAX_PATH,
														NULL);
		
				if (bRetval)
				{
					if (!__Malloc(&pclExclude, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclExclude->tszSubcomponentId, tszExclude);
					pclExclude->Next = pscSubcomponent->pclExclude;
					pscSubcomponent->pclExclude = pclExclude;
				}
			}
		}
		
		//
		// Add the new component to the beginning of the linked list
		//
		pscSubcomponent->Next = g_pscHead;
		g_pscHead = pscSubcomponent;
	
	} // for (lLine...
	
	return TRUE;
	
} // CreateSubcomponentInformationList //




/*++

Routine Description: FreeSubcomponentInformationList (1.36)

	 Frees the global linked list of subcomponent information.

Arguments:

	 none

Return Value:

	 void

--*/
VOID FreeSubcomponentInformationList()
{
	PSUBCOMP  pscTemp = g_pscHead;
	PSUBCOMP  pscNext;
	PCOMPLIST pclTemp, pclNext;
	
	//
	// Delete all the SUBCOMP nodes
	//
	while (pscTemp)
	{
		pscNext = pscTemp->Next;
		
		//
		// Delete all the COMPLIST pclNeeds nodes
		//
		pclTemp = pscTemp->pclNeeds;
		while (pclTemp)
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}
		
		//
		// Delete all the COMPLIST pcdExclude nodes
		//
		pclTemp = pscTemp->pclExclude;
		while (pclTemp) 
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}

		//
		// Delete all the COMPLIST pclChildren nodes
		//
		pclTemp = pscTemp->pclChildren;
		while (pclTemp)
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}
		
		__Free(&pscTemp);
		
		pscTemp = pscNext;
	}
	
	g_pscHead = NULL;
	
} // FreeSubcomponentInformationList //




/*++

Routine Description: ClearSubcomponentInformationMarks (1.37)

	 Clears the marks on each of the subcomponent information nodes

Arguments:

	 none

Return Value:

	 void

--*/
VOID ClearSubcomponentInformationMarks()
{
	PSUBCOMP pscTemp;

	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		pscTemp->bMarked = FALSE;
	}
	
} // ClearSubcomponentInformationMarks //




/*++

Routine Description: CheckSubcomponentInformationMarks (1.38)

	 Clears the marks on each of the subcomponent information nodes

Arguments:

	 none

Return Value:

	 void

--*/
VOID CheckSubcomponentInformationMarks()
{
	double fn = 1.38;
	
	PSUBCOMP pscTemp;

	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (!(pscTemp->pclChildren) && !(pscTemp->bMarked))
		{
			Log(fn, SEV2, TEXT("%s.%s was not processed"),
							  pscTemp->tszComponentId, 
							  pscTemp->tszSubcomponentId);
		}
	}
	
} // CheckSubcomponentInformationMarks //




/*++

Routine Description: FindSubcomponentInformationNode (1.39)

	 Tries to find a node with matching ComponentId and SubcomponentId

Arguments:

	 tszComponentId:	 name of the component
	 tszSubcomponentId: name of the subcomponent

Return Value:

	 PSUBCOMP: if node is found, returns pointer to node.
				  if node is not found, returns NULL
	 
--*/
PSUBCOMP FindSubcomponentInformationNode(IN PTCHAR tszComponentId,
													  IN PTCHAR tszSubcomponentId)
{
	PSUBCOMP pscTemp;
	TCHAR	  tszSubcomp[MAX_PATH];

	__ASSERT(tszComponentId != NULL);

	//
	// If subcomponent is null, this is probably the master component.
	// In this case, subcomponent name should be same as component name.
	//
	if (tszSubcomponentId == NULL || 
		 _tcscmp(tszSubcomponentId, TEXT("(null)")) == 0 ||
		 tszSubcomponentId[0] == TEXT('\0'))
	{
		_tcscpy(tszSubcomp, tszComponentId);
	}
	else
	{
		_tcscpy(tszSubcomp, tszSubcomponentId);
	}
	
	//
	// Look for the node
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (_tcscmp(tszComponentId, pscTemp->tszComponentId) == 0 &&
			 _tcscmp(tszSubcomp, pscTemp->tszSubcomponentId) == 0)
		{
			return pscTemp;
		}
	}

	return NULL;
	
} // FindSubcomponentInformationNode //




/*++

Routine Description: CheckNeedsDependencies (1.41)

	 Checks the selection status of every component and subcomponent to
	 make sure all needs relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckNeedsDependencies()
{
	PSUBCOMP		  pscSubcomponent;
	PCOMPONENT_DATA pcdComponentData; 
	TCHAR			   tszNodesVisited[NODES_VISITED_LENGTH];
	
	ZeroMemory(tszNodesVisited, NODES_VISITED_LENGTH);
				
	//
	// Go through each subcomponent, check its selection state
	// and the selection state of any subcomponents that it needs
	//
	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// If this component is selected, check out its needs
			// dependencies
			//
			if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
			{
				CheckNeedsDependenciesOfSubcomponent(
													 pcdComponentData->ocrHelperRoutines,
													 pscSubcomponent,
													 pscSubcomponent,
													 tszNodesVisited);
			}
		}
	}

} // CheckNeedsDependencies //
				
										


/*++

Routine Description: CheckNeedsDependenciesOfSubcomponent (1.42)

	 Receives a subcomponent ID. Checks to see if this subcomponent is
	 checked, and if it is, recurses to check all the subcomponents
	 that are needed by this subcomponent (if any)
	
Arguments:

	 ocrHelper: 		 helper routines 
	 pscSubcomponent:  contains data about subcomponent being checked
	 pscWhoNeedsMe: 	tells who needs this subcomponent

Return Value:

	 BOOL: TRUE if all needs dependencies check out, FALSE if not
	 
--*/
BOOL CheckNeedsDependenciesOfSubcomponent(IN	  OCMANAGER_ROUTINES ocrHelper,
														IN		PSUBCOMP			  pscSubcomponent,
														IN		PSUBCOMP			  pscWhoNeedsMe,
														IN OUT PTCHAR				  tszNodesVisited)
{
	double fn = 1.42;
	
	PCOMPLIST	 pclNeeds;
	PSUBCOMP	 pscNeeds;
	UINT		  uiRemoteResult;
	CHECK_NEEDS cnCheckNeeds;
	TCHAR		  tsz[MAX_PATH];
	ULONG		  ulError;
	
	if (ocrHelper.QuerySelectionState(ocrHelper.OcManagerContext,
												 pscSubcomponent->tszSubcomponentId,
												 OCSELSTATETYPE_CURRENT))
	{
		//
		// Check to see if we've already checked out this node
		//
		if (!AlreadyVisitedNode(pscSubcomponent->tszSubcomponentId,
										tszNodesVisited))
		{
			//
			// Add this node to the list of nodes we've already checked
			//
			_tcscat(tszNodesVisited, pscSubcomponent->tszSubcomponentId);
			_tcscat(tszNodesVisited, TEXT(" "));
			
			//
			// Go through each subcomponent that is needed by this subcomponent
			//
			for (pclNeeds = pscSubcomponent->pclNeeds;
				  pclNeeds != NULL;
				  pclNeeds = pclNeeds->Next)
			{
				//
				// Check to see if this needed subcomponent belongs to the
				// current component. If it does, just check here.
				// If it doesn't, call private function of the component
				// that it does belong to. This private function will
				// do the checking and return the result
				//
				if (_tcsncmp(pscSubcomponent->tszSubcomponentId, 
								 pclNeeds->tszSubcomponentId,
								 _tcslen(pscSubcomponent->tszComponentId)) == 0)
				{
					if (!CheckLocalNeedsDependencies(ocrHelper,
																pscSubcomponent,
																pclNeeds,
																tszNodesVisited))
					{
						return FALSE;
					}
				}
				else
				{
					cnCheckNeeds.pclNeeds = pclNeeds;
					cnCheckNeeds.tszNodesVisited = tszNodesVisited;
					
					ulError = ocrHelper.CallPrivateFunction(
										ocrHelper.OcManagerContext, 
										GetComponent(pclNeeds->tszSubcomponentId, tsz),
										pclNeeds->tszSubcomponentId,
										OCP_CHECK_NEEDS, 
										(UINT)pscSubcomponent, 
										&cnCheckNeeds, 
										(PUINT)&cnCheckNeeds);
					
					if (ulError != NO_ERROR)
					{
						Log(fn, SEV2, TEXT("CallPrivateFunction failed for ")
										  TEXT("%s called from %s: %lu"),
										  pclNeeds->tszSubcomponentId,
										  pscSubcomponent->tszComponentId,
										  ulError);
						return FALSE;
					}
				
					if (!cnCheckNeeds.bResult) return FALSE;
				}	 
			}
		}
	
		//
		// All the needs dependencies checked out
		//
		return TRUE;
	}
	
	//
	// This component is not selected, return FALSE
	//
	Log(fn, SEV2, TEXT("%s needs %s. %s is selected, ")
					  TEXT("but %s is not."),
					  pscWhoNeedsMe->tszSubcomponentId,
					  pscSubcomponent->tszComponentId,
					  pscWhoNeedsMe->tszSubcomponentId,
					  pscSubcomponent->tszComponentId);
	return FALSE;
	
} // CheckNeedsDependenciesOfSubcomponent //




/*++

Routine Description: CheckLocalNeedsDependencies (1.43)

	 Receives a subcomponent ID. Checks to see if this subcomponent is
	 checked, and if it is, recurses to check all the subcomponents
	 that are needed by this subcomponent (if any)
	
Arguments:

	 ocrHelper: 		 helper routines 
	 pscSubcomponent:  contains data about subcomponent being checked
	 pclNeeds:			  tells who this subcomponent needs

Return Value:

	 BOOL: TRUE if all needs dependencies check out, FALSE if not
	 
--*/
BOOL CheckLocalNeedsDependencies(IN 	 OCMANAGER_ROUTINES ocrHelper,
											IN		PSUBCOMP			  pscSubcomponent,
											IN		PCOMPLIST			  pclNeeds,
											IN OUT PTCHAR				  tszNodesVisited)
{
	PSUBCOMP pscNeeds;
	
	//
	// Find the PSUBCOMP node for this subcomponent
	//
	for (pscNeeds = g_pscHead;
		  pscNeeds != NULL;
		  pscNeeds = pscNeeds->Next)
	{
		if (_tcscmp(pscNeeds->tszSubcomponentId, 
						pclNeeds->tszSubcomponentId) == 0)
		{
			if (!CheckNeedsDependenciesOfSubcomponent(ocrHelper,
																	pscNeeds,
																	pscSubcomponent,
																	tszNodesVisited))	 
			{
				return FALSE;
			}
			break;
		}
	}

	return TRUE;
} // CheckLocalNeedsDependencies //




/*++

Routine Description: CheckExcludeDependencies (1.46)

	 Checks the selection status of every component and subcomponent to
	 make sure all exclude relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckExcludeDependencies()
{
	double fn = 1.46;
	
	PSUBCOMP		  pscSubcomponent;
	PCOMPLIST		  pclExclude;
	PCOMPONENT_DATA pcdComponentData; 
				
	//
	// Go through each subcomponent, check its selection state
	// and the selection state of any subcomponents that it excludes
	//
	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// If this component is selected, check out its exclude
			// dependencies
			//
			if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
			{
				//
				// Go through each subcomponent that is
				// excluded by this subcomponent
				//
				for (pclExclude = pscSubcomponent->pclExclude;
					  pclExclude != NULL;
					  pclExclude = pclExclude->Next)
				{
					if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pclExclude->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
					{
						Log(fn, SEV2, TEXT("%s excludes %s. Both are selected"),
										  pscSubcomponent->tszSubcomponentId,
										  pclExclude->tszSubcomponentId);
					}
				}
			}
		}
	}
					
} // CheckExcludeDependencies //




/*++

Routine Description: CheckParentDependencies (1.47)

	 Checks the selection status of every component and subcomponent to
	 make sure all parent relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckParentDependencies()
{
	double fn = 1.47;
	
	PSUBCOMP		  pscSubcomponent;
	PCOMPONENT_DATA pcdComponentData; 
	BOOL				bState;
	PCOMPLIST		  pclChildren;			  

	PCOMPONENT_DATA pcdSubComponentData;

	BOOL				bParentState;
	BOOL				bAllCleared;

	PSUBCOMP		  pscParent;

	TCHAR			   tszMsg[256];

	static BOOL 	 bInformed1 = FALSE;
	static BOOL 	 bInformed2 = FALSE;

	// QuerySelectionState returns TRUE when the component's state
	// does not equal SELSTATE_NO
	// This means it returns TRUE when the component is selected
	// or partially selected

	//
	// Go through each subcomponent, check its selection state
	// and the selection state of its parent
	//

	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		bState = TRUE;
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// Check to see if this subcomponent is selected
			//
			bState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT);

			// Let pass a NULL pointer to the helper routine
			//pcdComponentData->ocrHelperRoutines.QuerySelectionState(
			//	  NULL, NULL, OCSELSTATETYPE_CURRENT);

			if (bState == TRUE) {

				// The component is selected

				//if (GetLastError() == ERROR_INVALID_NAME) {				 
				//	  MessageBox(NULL, TEXT("There is an error when calling QuerySelectionState"), TEXT("CheckParentDependencies"), MB_OK);
				//	  break;
				//}

				//
				// Check to see if its parent is selected
				//	  
				bParentState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
									pcdComponentData->ocrHelperRoutines.OcManagerContext,
									pscSubcomponent->tszParentId,
									OCSELSTATETYPE_CURRENT);

				// If the component is selected, its parent should
				// be selected or partially selected, thus bParentState
				// should be TRUE

				if (!bParentState)				   
				{
					Log(fn, SEV2, TEXT("%s is selected but its parent, %s, ")
									  TEXT("is not"),
									  pscSubcomponent->tszSubcomponentId,
									  pscSubcomponent->tszParentId);
				}
			}

			else if (bState == FALSE) {
				//
				// The child is not selected, this means none of its children 
				// should be selected, and its parent should be greyed or
				// unselected
				//
				// This will check its siblings to determine whether they
				// are selected or not
				// if none of its siblings are selected, the parent should be 
				// cleared.
				
				// First find its parent in the list

				if (_tcscmp(pscSubcomponent->tszSubcomponentId, pscSubcomponent->tszParentId) == 0) {
					// This is a top level component
					// we will skip the following test
					continue;
				}
				for (pscParent = g_pscHead; pscParent != NULL; pscParent = pscParent->Next) {
					if (_tcscmp(pscParent->tszSubcomponentId, pscSubcomponent->tszParentId) == 0) {
						break;
					}
				}

				pclChildren = pscParent->pclChildren;

				bAllCleared = TRUE;

				for (pclChildren = pscParent->pclChildren; pclChildren != NULL; pclChildren = pclChildren->Next) {
					// Locate the child component
					//pcdSubComponentData = LocateComponent(pclChildren->tszSubcomponentId);
					//if (!pcdSubComponentData) {
					//	  MessageBox(NULL, TEXT("Error locating subcomponent that is in the list"), TEXT("CheckParentDependencies"), MB_OK);
					//	  break;
					//}
					// Now query the state of this subcomponent
					if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pclChildren->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT)){
						bAllCleared = FALSE;
						break;
					}
				}

				//pcdSubComponentData = LocateComponent(pscParent->tszComponentId);
				//if (!pcdSubComponentData) {
				//	  MessageBox(NULL, TEXT("Error locating subcomponent that is in the list"), TEXT("CheckParentDependencies"), MB_OK);
				//	  break;
				//}

				bParentState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
									pcdComponentData->ocrHelperRoutines.OcManagerContext,
									pscParent->tszSubcomponentId,
									OCSELSTATETYPE_CURRENT);
								
				if (bAllCleared) {
					// None of the subcomponent is selected
					// Check the state of the parent component
					if (bParentState != FALSE) {
						Log(fn, SEV2, TEXT("%s.%s is (partially) selected, but none")
										  TEXT(" of its subcomponent is selected"),
										  pscParent->tszParentId,
										  pscParent->tszComponentId);
						if (!bInformed1) {
							_stprintf(tszMsg, TEXT("%s is (partially) selected, but none of child is selected"), pscParent->tszSubcomponentId);
							MessageBox(NULL,tszMsg, TEXT("CheckParentDependencies"), MB_OK); 
							bInformed1 = TRUE;
						}
					}
				}

				else{
					// At least one of the subcomponent is selected
					// Parent should be (partially) selected
					if (bParentState == FALSE) {
						Log(fn, SEV2, TEXT("%s.%s is not selected, but one")
										  TEXT(" of its subcomponent is selected"),
										  pscParent->tszParentId,
										  pscParent->tszComponentId);
						if (!bInformed2) {
							_stprintf(tszMsg, TEXT("%s is not selected, but at least one of child is selected"), pscParent->tszSubcomponentId);
							MessageBox(NULL,tszMsg, TEXT("CheckParentDependencies"), MB_OK);
							bInformed2 = TRUE;
						}
					}
				}

			}
		}
	}
					
} // CheckParentDependencies //




/*++

Routine Description: AlreadyVisitedNode (1.44)

	 Receives a subcomponent ID and a list of subcomponents that 
	 have already been checked. Looks in the list to see if this
	 subcomponent has already been checked. 
	
Arguments:

	 tszSubcomponentId: the new subcomponent
	 tszNodesVisited:	 list of what's already been checked

Return Value:

	 BOOL: TRUE if this subcomponent has already been checked, FALSE if not
	 
--*/
BOOL AlreadyVisitedNode(IN PTCHAR tszSubcomponentId,
								IN PTCHAR tszNodesVisited)
{
	PTCHAR tszMarker;
	TCHAR  tszName[MAX_PATH];
	USHORT usCount, i;
	
	tszMarker = tszNodesVisited;
	
	for (usCount = 0; usCount < _tcslen(tszNodesVisited);)
	{
		for (i = 0; i < _tcslen(tszMarker); i++)
		{
			if (tszMarker[i] == TEXT(' ')) break;
			tszName[i] = tszMarker[i];
		}
		tszName[i] = TEXT('\0');
		
		if (_tcscmp(tszName, tszSubcomponentId) == 0)
		{
			return TRUE;
		}
		
		usCount += _tcslen(tszName) + 1;
	
		tszMarker += _tcslen(tszName) + 1;
	}
	
	return FALSE;
	
} // AlreadyVisitedNode //




/*++

Routine Description: GetComponent (1.45)

	 Receives a subcomponent ID and returns the ID of the master component
	 that owns this subcomponent
	
Arguments:

	 tszSubcomponentId: the subcomponent
	 tszComponentId:	 returns component ID using this string.
							  must be a valid buffer

Return Value:

	 PTCHAR: returns component ID
	 
--*/
PTCHAR GetComponent(IN		PTCHAR tszSubcomponentId,
						  IN OUT PTCHAR tszComponentId)
{
	USHORT i;
	
	__ASSERT(tszComponentId != NULL);
	
	for (i = 0; i < _tcslen(tszSubcomponentId); i++)
	{
		if (tszSubcomponentId[i] == TEXT('_'))
		{
			break;
		}
			
		tszComponentId[i] = tszSubcomponentId[i];
	}
	
	tszComponentId[i] = TEXT('\0');
	
	return tszComponentId;
	
} // GetComponent //							  




/*++

Routine Description: ParseCommandLine (1.47)

	 Checks the command line to see if there are any arguments that
	 pertain to the component DLLs
	
Arguments:

	 none

Return Value:

	 VOID
	 
--*/
VOID ParseCommandLine()
{
	USHORT i;
	USHORT usMarker;
	//TCHAR  usMarker;
	BOOL	bCheckArgs = FALSE;
	PTCHAR tszCommandLine;
	PTCHAR tszMarker;
	TCHAR  tszArg[MAX_PATH];

	TCHAR tszDlgMessage[256];
		
	tszCommandLine = GetCommandLine();
	tszMarker = tszCommandLine;
	usMarker = (USHORT)tszMarker;

	while ((USHORT)((USHORT)tszMarker - usMarker) < (USHORT)_tcslen(tszCommandLine) * sizeof(TCHAR))
	{	 
		for (i = 0; i < _tcslen(tszMarker); i++)
		{
			if (tszMarker[i] == TEXT(' ') || 
				 tszMarker[i] == TEXT('\0'))
			{
				break;
			}
			tszArg[i] = tszMarker[i];
		}
		tszArg[i] = TEXT('\0');

		tszMarker += _tcslen(tszArg) + 1;
		
		while (tszMarker[0] == TEXT(' ')) tszMarker++;
		
		if (bCheckArgs)
		{
			//
			// Check the value of this argument 
			//
			if (_tcscmp(tszArg, TEXT("/av")) == 0 ||
				 _tcscmp(tszArg, TEXT("/AV")) == 0 ||
				 _tcscmp(tszArg, TEXT("-av")) == 0 ||
				 _tcscmp(tszArg, TEXT("-AV")) == 0)
			{
				g_bAccessViolation = TRUE;
			}

			//
			// Check the value of this argument 
			//
			if (_tcscmp(tszArg, TEXT("/e")) == 0 ||
				 _tcscmp(tszArg, TEXT("/E")) == 0 ||
				 _tcscmp(tszArg, TEXT("-e")) == 0 ||
				 _tcscmp(tszArg, TEXT("-E")) == 0)
			{ 
				g_bTestExtended = TRUE;
			}

			//
			// negstep make the return value of OC_QUERY_STEP_COUNT negative one
			//
			if (_tcscmp(tszArg, TEXT("/negstep")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NEGSTEP")) == 0 ||
				 _tcscmp(tszArg, TEXT("-negstep")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NEGSTEP")) == 0)
			{ 
				nStepsFinal = -1;
			}

			if (_tcscmp(tszArg, TEXT("/nowiz")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NOWIZ")) == 0 ||
				 _tcscmp(tszArg, TEXT("-nowiz")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NOWIZ")) == 0)
			{ 
				g_bNoWizPage = TRUE;
			}
			
			if (_tcscmp(tszArg, TEXT("/crashunicode")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CRASHUNICODE")) == 0 ||
				 _tcscmp(tszArg, TEXT("-crashunicode")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CRASHUNICODE")) == 0)
			{ 
				g_bCrashUnicode = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/invalidbitmap")) == 0 ||
				 _tcscmp(tszArg, TEXT("/INVALIDBITMAP")) == 0 ||
				 _tcscmp(tszArg, TEXT("-invalidbitmap")) == 0 ||
				 _tcscmp(tszArg, TEXT("-INVALIDBITMAP")) == 0)
			{ 
				g_bInvalidBitmap = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/closeinf")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CLOSEINF")) == 0 ||
				 _tcscmp(tszArg, TEXT("-closeinf")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CLOSEINF")) == 0)
			{ 
				g_bCloseInf = TRUE;
			}
						
			if (_tcscmp(tszArg, TEXT("/hugesize")) == 0 ||
				 _tcscmp(tszArg, TEXT("/HUGESIZE")) == 0 ||
				 _tcscmp(tszArg, TEXT("-hugesize")) == 0 ||
				 _tcscmp(tszArg, TEXT("-HUGESIZE")) == 0)
			{ 
				g_bHugeSize = TRUE;
			}	   

			if (_tcscmp(tszArg, TEXT("/noneedmedia")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NONEEDMEDIA")) == 0 ||
				 _tcscmp(tszArg, TEXT("-noneedmedia")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NONEEDMEDIA")) == 0)
			{ 
				g_bNoNeedMedia = TRUE;
			}				  
			
			if (_tcscmp(tszArg, TEXT("/reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("/reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("-reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("-reboot")) == 0)
			{ 
				g_bReboot = TRUE;
			}				  


			if (_tcscmp(tszArg, TEXT("/cleanreg")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CLEANREG")) == 0 ||
				 _tcscmp(tszArg, TEXT("-cleanreg")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CLEANREG")) == 0)
			{ 
				g_bCleanReg = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/nolang")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NOLANG")) == 0 ||
				 _tcscmp(tszArg, TEXT("-nolang")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NOLANG")) == 0)
				{ 
					g_bNoLangSupport = TRUE;
				}
			
		}			 
		
		if (_tcscmp(tszArg, TEXT("/z")) == 0 ||
			 _tcscmp(tszArg, TEXT("/Z")) == 0)
		{
			bCheckArgs = TRUE;
		}
	}
	
} // ParseCommandLine //  

/*++

Routine Description: testAV (1.0)

	Procedure to generate an access violation
	
Argument:
	
	If true, an access violation is generated
	
Return Value:

	None
	
--*/  
VOID testAV(BOOL bDoIt){

	/* The Following variables are used for access violation test */
	COMPONENT_DATA *g_pcdAccessViolation;
	
	if (bDoIt){
		g_pcdAccessViolation = NULL;
		g_pcdAccessViolation->hinfMyInfHandle = NULL;
	}
}


/*++

Routine Description: TestReturnValueAndAV (1.0)

	Procdefure to give the user control of what to return and when to cause an access violation
	
Argument:

	Arguments to ComponentSetupProc plus and bOverride
	
Return Value:

	The return value that user gives.
	
--*/
BOOL TestReturnValueAndAV(IN LPCVOID lpcvComponentId,
								  IN LPCVOID lpcvSubcomponentId,
								  IN UINT	  uiFunction,
								  IN UINT	  uiParam1,
								  IN PVOID	  pvParam2,
								  IN OUT PReturnOrAV	 praValue)
{
	int returnValue;

	if (!BeginTest()){
		praValue->bOverride = FALSE;
		return ((DWORD)0);
	}

	//ChooseAccessViolationEx();

	//Now fill in the fields of raValue
	praValue->tszComponent = (PTCHAR)lpcvComponentId;
	praValue->tszSubComponent = (PTCHAR)lpcvSubcomponentId;
		
	switch(uiFunction){
		case  OC_PREINITIALIZE:
		praValue->tszSubComponent[0]=TEXT('\0');
		_tcscpy(praValue->tszAPICall, TEXT("OC_PREINITIALIZE"));	 
		break;
			
		case OC_INIT_COMPONENT:
		_tcscpy(praValue->tszAPICall, TEXT("OC_INIT_COMPONENT"));
		break;
			
		case OC_QUERY_STATE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_STATE"));
		break;
			
		case OC_SET_LANGUAGE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_SET_LANGUAGE"));
		break;
			
		case OC_QUERY_IMAGE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_IMAGE"));
		break;
			
		case OC_REQUEST_PAGES:
		_tcscpy(praValue->tszAPICall, TEXT("OC_REQUEST_PAGES"));
		break;
			
		case OC_QUERY_CHANGE_SEL_STATE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_CHANGE_SEL_STATE"));
		break;
			
		case OC_CALC_DISK_SPACE: 
		_tcscpy(praValue->tszAPICall, TEXT("OC_CALC_DISK_SPACE"));
		break;
			
		case OC_QUEUE_FILE_OPS:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUEUE_FILE_OPS"));
		break;
			
		case OC_NEED_MEDIA:
		_tcscpy(praValue->tszAPICall, TEXT("OC_NEED_MEDIA"));
		break;
			
		case OC_QUERY_STEP_COUNT:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_STEP_COUNT"));
		break;
			
		case OC_COMPLETE_INSTALLATION:
		_tcscpy(praValue->tszAPICall, TEXT("OC_COMPLETE_INSTALLATION"));
		break;
			
		case OC_CLEANUP:
		_tcscpy(praValue->tszAPICall, TEXT("OC_CLEANUP"));
		break;
			
		case OCP_TEST_PRIVATE_BASE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_TEST_PRIVATE_BASE"));
		break;
			
		case OCP_CHECK_NEEDS:
		_tcscpy(praValue->tszAPICall, TEXT("OC_CHECK_NEEDS"));
		break;
			
		default:
		_tcscpy(praValue->tszAPICall, TEXT("Unknown call"));
		break;
	}
	
	//Now everything is ready, let's make the call
	returnValue = DialogBoxParam(g_hDllInstance, 
								  MAKEINTRESOURCE(IDD_CHOOSERETURNANDAV), 
								  NULL, 
								  ChooseReturnOrAVDlgProc,
								  (LPARAM)praValue);

	praValue = (PReturnOrAV)returnValue;

	return TRUE;
}

/*++

Routine Description: BeginTest (1.0)

	Let the user decide whether to test the return values of each API 
	

Arguments:
	
	None
	
Return Value:

	Whether to do extended test
--*/
BOOL BeginTest(){ 
	static BOOL bStart = FALSE;
	static BOOL bFirstTime = TRUE;
	static int iMsgReturn;
		
	TCHAR tszDlgMessage[256];
	TCHAR tszDlgTitle[256];

	if (bFirstTime){
		bFirstTime = FALSE;
#ifdef UNICODE	   
		_stprintf(tszDlgMessage, TEXT("Do you want to test return values and/or access violations of each API call in the UNICODE DLL? It may take a long long time"));
		_stprintf(tszDlgTitle, TEXT("Begin Test For UNICODE?"));
#else
		_stprintf(tszDlgMessage, TEXT("Do you want to test return values and/or access violations of each API call in the ANSI DLL? It may take a long long time"));
		_stprintf(tszDlgTitle, TEXT("Begin Test For ANSI?"));
#endif		  
		iMsgReturn = MessageBox(NULL, tszDlgMessage, tszDlgTitle, MB_YESNO|MB_ICONQUESTION);
		
		if (iMsgReturn == IDNO){
			bStart = FALSE;
			return (FALSE);
		}
		else{
			bStart = TRUE;
			return (TRUE);
		}
	}
	else{
		return bStart;
	}
		
}  

/*++

Routine Description: ChooseReturnOrAVDlgProc (1.27)

	Dialog procedure that allows the user to select a different 
	return value of an API call, and/or to cause a access violation
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseReturnOrAVDlgProc(IN HWND	 hwnd,
									  IN UINT	 uiMsg, 
									  IN WPARAM wParam,
									  IN LPARAM lParam) 
{
	
	BOOL					 bSuccess = FALSE;
	PReturnOrAV 		   praValue = NULL;
	static HWND 		   hOldWnd = NULL;
	
	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			hOldWnd = hwnd;
			CheckRadioButton(hwnd, IDC_USE_OLDVALUE, IDC_USE_NEWVALUE, IDC_USE_OLDVALUE);
			CheckDlgButton(hwnd, IDC_CAUSEAV, 0);
		
			praValue = (PReturnOrAV)lParam;
			if (praValue){
				if (praValue->tszComponent){
					SetDlgItemText(hwnd, IDC_STATIC_COMPONENT, praValue->tszComponent);
				}
				else{
					SetDlgItemText(hwnd, IDC_STATIC_COMPONENT, TEXT("null"));
				}
				if (praValue->tszSubComponent && praValue->tszSubComponent[0]!=TEXT('\0')){ 			 
					SetDlgItemText(hwnd, IDC_STATIC_SUBCOMPONENT, praValue->tszSubComponent);
				}
				else{
					SetDlgItemText(hwnd, IDC_STATIC_SUBCOMPONENT, TEXT("null"));
				}
				SetDlgItemText(hwnd, IDC_STATIC_APICALL, praValue->tszAPICall);
			}
			
			return TRUE;
			break;

		case WM_COMMAND:
		
			switch (LOWORD(wParam))
			{
				case IDOK:
				
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_USE_NEWVALUE))
					{
						praValue->iReturnValue = GetDlgItemInt(hwnd, IDC_NEWVALUE, &bSuccess, TRUE);
						if (bSuccess){
							praValue->bOverride = TRUE;
						}
						else{
							praValue->bOverride = FALSE;
							praValue->iReturnValue = 0;
						}
					}
					
					if (QueryButtonCheck(hwnd, IDC_USE_OLDVALUE))
					{
						praValue->bOverride = FALSE;
						praValue->iReturnValue = 0;
					}
					
					if (QueryButtonCheck(hwnd, IDC_CAUSEAV))
					{
						praValue->bOverride = FALSE;
						praValue->iReturnValue = 0;
						testAV(TRUE);
					}
					
					EndDialog(hOldWnd, (int)praValue);
					return TRUE;
					
				case IDCANCEL:
			
					praValue->bOverride = FALSE;
					EndDialog(hOldWnd, 0);
					return TRUE;
					
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;
	
} // ChooseReturnOrAVDlgProc //

/*++
	Routine: causeAV
	
	Description: pops up a dialog box and ask the user where to av
	
	Argument: Function that the DLL receives from ComponentSetupProc

--*/

void causeAV(IN UINT uiFunction){
	static BOOL bFirstTime = TRUE;
	static UINT uiFunctionToAV = 0;

	if (bFirstTime) {
		// Display dialog box, asks the user where to av
		bFirstTime = FALSE;

		uiFunctionToAV = DialogBoxParam(g_hDllInstance, 
										  MAKEINTRESOURCE(IDD_DIALOG4), 
										  NULL, 
										  CauseAVDlgProc,
										  (LPARAM)NULL);
	}
	if (uiFunction == uiFunctionToAV) {
		testAV(TRUE);
	}
}


/*++

Routine Description: CauseAVDlgProc (1.26)

	Dialog Procedure to allow the user to choose where to cause an access violation
		
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK CauseAVDlgProc(IN HWND	hwnd,
											  IN UINT	 uiMsg, 
											  IN WPARAM wParam,
											  IN LPARAM lParam) 
{
	UINT uiFunction;
	TCHAR tszFunctionName[256];
	BOOL bSuccess;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			break;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current text in the edit box
					//
					GetDlgItemText(hwnd, IDC_FUNCTION, tszFunctionName, 255);
					if (*tszFunctionName) {
						uiFunction = GetOCFunctionName(tszFunctionName);
					}

					//
					// Send the version chosen back to ChooseVersionEx
					//
					EndDialog(hwnd, uiFunction);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, -1);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // CauseAVDlgProc //

UINT GetOCFunctionName(IN PTCHAR tszFunctionName){

	// Now tszFunctionName should contains the function name that user wants to cause an AV
	if (!_tcsicmp(tszFunctionName, TEXT("OC_PREINITIALIZE"))) {
		return(OC_PREINITIALIZE); 
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_INIT_COMPONENT"))) {
		return(OC_INIT_COMPONENT);
			}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_STATE"))) {
		return(OC_QUERY_STATE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_SET_LANGUAGE"))) {
		return(OC_SET_LANGUAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_IMAGE"))) {
		return(OC_QUERY_IMAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_REQUEST_PAGES"))) {
		return(OC_REQUEST_PAGES);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_SKIP_PAGE"))) {
		return(OC_QUERY_SKIP_PAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_CHANGE_SEL_STATE"))) {
		return(OC_QUERY_CHANGE_SEL_STATE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_CALC_DISK_SPACE"))) {
		return(OC_CALC_DISK_SPACE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUEUE_FILE_OPS"))) {
		return(OC_QUEUE_FILE_OPS);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_NEED_MEDIA"))) {
		return(OC_NEED_MEDIA);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_STEP_COUNT"))) {
		return(OC_QUERY_STEP_COUNT);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_ABOUT_TO_COMMIT_QUEUE"))) {
		return(OC_ABOUT_TO_COMMIT_QUEUE);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_COMPLETE_INSTALLATION"))) {
		return(OC_COMPLETE_INSTALLATION);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_CLEANUP"))) {
		return(OC_CLEANUP);
	}
	else{
		MessageBox(NULL, TEXT("Unknown Function"), TEXT("Test Routine"), MB_OK);
		return(0);
	}

}

void SetGlobalsFromINF(HINF hinfHandle){
	PTCHAR tszOCTestSection = TEXT("OCTest");
	PTCHAR tszAccessViolation = TEXT("AccessViolation");
	PTCHAR tszNoWizard = TEXT("NoWizardPage");
	TCHAR  tszFunctionName[256];
	int 	nRequiredBufferSize; 

	INFCONTEXT infContext;

	BOOL bSuccess = TRUE;

	TCHAR tszMsg[256];

	int nError;

	/*
	bSuccess = SetupFindFirstLine(hinfHandle, tszOCTestSection, tszAccessViolation, &infContext);

	if (bSuccess) {
		#ifdef DEBUG
		MessageBox(NULL, TEXT("AccessViolation Found in INF File"), TEXT("AccessViolation"), MB_OK);
		#endif
		g_bAccessViolation = TRUE;
		bSuccess = SetupGetStringField(&infContext, 1, tszFunctionName, 255, &nRequiredBufferSize);
		if (bSuccess) {
			g_uiFunctionToAV = GetOCFunctionName(tszFunctionName);
		}
	}
	*/
	bSuccess = SetupFindFirstLine(hinfHandle, TEXT("OCTest"), TEXT("NoWizardPage"), &infContext);

	if (bSuccess) {
		#ifdef DEBUG
		MessageBox(NULL, TEXT("NoWizard Found in INF File"), TEXT("NoWizard"), MB_OK);
		#endif
		g_bNoWizPage = TRUE;
	}
	else{	  
		#ifdef DEBUG
		nError = GetLastError();
		MessageBox(NULL, TEXT("NoWizard NOT Found in INF File"), TEXT("NoWizard"), MB_OK);
		_stprintf(tszMsg, TEXT("The Last Error value for SetupFIndFirstLine is %d"), nError);
		MessageBox(NULL, tszMsg, TEXT("GetLastError"), MB_OK);
		#endif
	}

	bSuccess = SetupFindFirstLine(hinfHandle, TEXT("OCTest"), TEXT("Reboot"), &infContext);
	if (bSuccess) {
		g_bReboot = TRUE;
	}
}

void causeAVPerComponent(IN UINT uiFunction, IN LPCVOID lpcvComponentId){

	PCOMPONENT_DATA pcdComponentData;

	TCHAR tszMsg[256];
		
	if (uiFunction != OC_PREINITIALIZE && uiFunction != OC_INIT_COMPONENT) {
		pcdComponentData = LocateComponent(lpcvComponentId);
		//MessageBox(NULL, TEXT("Component Found"), TEXT("Fount"), MB_OK);
		if (pcdComponentData->bAccessViolation) {
			//MessageBox(NULL, TEXT("It allows use to cause AV"), TEXT("Cause AV"), MB_OK);
			if (pcdComponentData->uiFunctionToAV == uiFunction) {
				//MessageBox(NULL, TEXT("Start to cause access violation"), TEXT("Starting"), MB_OK);
				testAV(TRUE);
			}
		}
	}
}

void SetDefaultMode(PCOMPONENT_DATA pcdComponentData){
	BOOL bSuccess;
	INFCONTEXT infContext;
	TCHAR tszMode[256];

	bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
											TEXT("OCTest"), 
											TEXT("DefaultMode"),
											&infContext);
	if (bSuccess) {
		//MessageBox(NULL, TEXT("DefaultMode= found in OCTest section"), TEXT("DefaultMode"), MB_OK);
		bSuccess = SetupGetStringField(&infContext, 1, tszMode, 255, NULL);
		if (bSuccess) {
			//MessageBox(NULL, TEXT("The default Mode should be in the title"), tszMode, MB_OK);
			if (!_tcscmp(tszMode, TEXT("TYPICAL"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_TYPICAL);
			}
			else if (!_tcscmp(tszMode, TEXT("MINIMAL"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_MINIMAL);
			}
			else if (!_tcscmp(tszMode, TEXT("LAPTOP"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_LAPTOP);
			}
			else if (!_tcscmp(tszMode, TEXT("CUSTOM"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_CUSTOM);
			}
		}
	}
}

/*++
	Routine description: 
	  
		Go through the list of component list, determine
		whether the initial states are valid for each of them
		
	Argument:
	  
		None
		
	Return value:
	
		None (error will be logged)

--*/

void CheckInitialState()
{
	double fn = 1.0;

	UINT uiCurrentMode; 				// Current Mode of the setup
	static BOOL bFirstTime = TRUE;	// we only need to fill the above array once

	PSUBCOMP pscSubcomponent = NULL;

	PCOMPONENT_DATA pcdComponentData = NULL;

	OCMANAGER_ROUTINES ocHelper;

	int nLoop = 0;

	INFCONTEXT infContext;

	HINF hinfHandle;

	TCHAR tszMsg[256];

	BOOL bInitState;
	BOOL bInitStateShouldBe;

	// Get a handle to a component
	// so that we can use the OC Manager
	// helper routines

	if (!g_pscHead) {
		MessageBox(NULL, TEXT("The component list is empty"), TEXT("CheckInitialState"), MB_OK);
		return;
	}

	pcdComponentData = LocateComponent(g_pscHead->tszComponentId);

	if (!pcdComponentData) {
		MessageBox(NULL, TEXT("Can not locate component"), TEXT("CheckInitialState"), MB_OK);
		return;
	}

	ocHelper = pcdComponentData->ocrHelperRoutines;

	// Get the current mode

	uiCurrentMode = ocHelper.GetSetupMode(ocHelper.OcManagerContext);
	
	
	// Now we will loop through each component
	// and its initial state


	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL; 
		  pscSubcomponent = pscSubcomponent->Next) {
		
		// If this is the first time that this function is called
		// array uiModeToBeOn[] should be filled in

		if (bFirstTime) {
			bFirstTime = FALSE;

			for (nLoop = 0; nLoop < 4; nLoop++) {
				pscSubcomponent->uiModeToBeOn[nLoop] = (UINT)(-1);
			}

			// Get the INF file handle
			pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId);
	
			if (!pcdComponentData) {
				MessageBox(NULL, TEXT("Can't locate a component"), TEXT("CheckInitialState"), MB_OK);
				return;
			}
	
			hinfHandle = pcdComponentData->hinfMyInfHandle;
	
			SetupFindFirstLine(hinfHandle, pscSubcomponent->tszSubcomponentId, TEXT("Modes"), &infContext);
	
			pscSubcomponent->nNumMode = SetupGetFieldCount(&infContext);
	
			for (nLoop = 1; nLoop < pscSubcomponent->nNumMode; nLoop++){
				SetupGetIntField(&infContext, nLoop, &(pscSubcomponent->uiModeToBeOn[nLoop - 1]));
			}
		}

		// Now get the initial state of this component
		bInitState = ocHelper.QuerySelectionState(ocHelper.OcManagerContext,
																pscSubcomponent->tszSubcomponentId,
																OCSELSTATETYPE_ORIGINAL);

		// Now determine what initial state this component should have
		bInitStateShouldBe = FALSE;
		for (nLoop = 0; nLoop < pscSubcomponent->nNumMode; nLoop++) {
			if (pscSubcomponent->uiModeToBeOn[nLoop] == uiCurrentMode) {
				// This component should be on
				bInitStateShouldBe = TRUE;
				break;
			}
		}
		if (bInitStateShouldBe != bInitState && bInitStateShouldBe){
			// We got a problem here
			Log(fn, SEV2, TEXT("%s has incorrect initial state"),
				 pscSubcomponent->tszSubcomponentId);
			
			_stprintf(tszMsg, TEXT("%s should be on, but it is not"), 
						 pscSubcomponent->tszSubcomponentId);
			MessageBox(NULL, tszMsg, TEXT("CheckInitialState"), MB_OK);
		}

	}
}




// Some security Stuff
// From NT Security FAQ
/*
BOOLEAN __stdcall InitializeChangeNotify(){
	DWORD wrote;
	fh = CreateFile("C:\\tmp\\pwdchange.out", GENERIC_WRITE, 
						 FILE_SHARE_READ|FILE_SHARE_WRITE, 0, CREATE_ALWAYS,
						 FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH, 0);
	WriteFile(fh, "InitializeChangeNotify started\n", 31, &wrote, 0);
	return TRUE;
}

LONG __stdcall PasswordChangeNotify(struct UNI_STRING *user, ULONG rid, struct UNI_STRING *passwd){
	DWORD wrote;
	WCHAR wbuf[200];
	char buf[512];
	char bufl[200];
	DWORD len;

	memcpy(wbuf, user->buff, user->len);
	len = user->len / sizeof(WCHAR);
	wbuf[len] = 0;
	wcstombs(bufl, wbuf, 199);
	sprintf(buf, "User = %s : ", bufl);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	memcpy(wbuf, passwd->buff, passwd->len);
	len = passwd->len / sizeof(WCHAR);
	wbuf[len] = 0;
	wcstombs(bufl, wbuf, 199);
	sprintf(buf, "Password = %s : ", bufl);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	sprintf(buf, "RID = %x \n", rid);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	return 0L;
}



// End of security stuff
*/

// File number = 1
// Last function number = 47
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	octest.h

Abstract:

	Contains include directives and structures common for all the modules 
   for the component's setup DLL.
	

Author:

	Bogdan Andreiu (bogdana)  10-Feb-1997
    Jason Allor    (jasonall) 24-Feb-1998   (took over the project)

Revision History:

	10-Feb-1997   bogdana
	  
	  First draft: include directives, structure and common function headers.
	
	20_Feb-1997   bogdana  
	  
	  Added three multistring processing functions.
	
	19-Mar-1997   bogdana
	  
	  Renamed some functions.     
	
	
 --*/
#ifndef _OCTEST_H
#define _OCTEST_H

#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <string.h>
#include <wtypes.h>
#include <string.h>
#include <tchar.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <crtdbg.h>
#include <regstr.h>
#include <winuser.h>
#include <ntlog.h>
#include <commctrl.h>
#include <richedit.h>
#include <winreg.h>

#include "hcttools.h"
#include "logutils.h"
#include "resource.h"
#include "msg.h"

//=====================================================================
// #defines
//=====================================================================

//
// These are used for the functions in ntlog.dll
//
#define PASS                TLS_PASS
#define FAIL                TLS_SEV1
#define TLS_CUSTOM          0x00008000 
#define PASS_VARIATION      TLS_PASS   | TL_VARIATION
#define FAIL_VARIATION      TLS_SEV1   | TL_VARIATION
#define WARN_VARIATION      TLS_WARN   | TL_VARIATION
#define BLOCK_VARIATION     TLS_BLOCK  | TL_VARIATION
#define ABORT_VARIATION     TLS_ABORT  | TL_VARIATION
#define LOG_VARIATION       TLS_CUSTOM | TL_VARIATION

//
// Defining the EXPORT qualifier
//
#define EXPORT __declspec (dllexport)

#define MAX_MSG_LEN                        256  // String length
#define MAX_OC_FUNCTIONS                   20   // Number of OC functions
#define TICK_TIME                          3    // Size of the time slot
#define NO_STEPS_FINAL                     7    // Num steps component will report in final stage
#define MAX_PRIVATE_DATA_SIZE              64   // Maximum size of stored private data
#define MAX_PRIVATE_VALUES                 8    // Maximum number of values to be tested
#define MAX_STRINGS_FOR_PRIVATE_DATA       8    // Dimension of the table to choose the strings from
#define MAX_MULTI_STRINGS_FOR_PRIVATE_DATA 6    // Dimension of the table to choose the multi-strings from
#define MAX_WIZPAGE_TYPES                  7    // Number pages types
#define MAX_WIZARD_PAGES                   5    // Number of pages returned by a component
#define NODES_VISITED_LENGTH               5000
#define ONE_HUNDRED_GIG                    0x4876E800

#define OCP_TEST_PRIVATE_BASE  OC_PRIVATE_BASE
#define OCP_CHECK_NEEDS        OC_PRIVATE_BASE + 1

//#define DEBUG

//=====================================================================
// structure definitions
//=====================================================================

//
// A structure needed for printing the OC functions
//
typedef struct   _OCText 
{
	UINT     uiOCFunction;
	PTSTR    tszOCText;   
} OCTEXT, *POCTEXT;


//
// The table used for printing OC function names
//
static const OCTEXT octFunctionNames[] = 
{ 
   {OC_PREINITIALIZE,           TEXT("OC_PREINITIALIZE")},
   {OC_INIT_COMPONENT,          TEXT("OC_INIT_COMPONENT")},
   {OC_SET_LANGUAGE,            TEXT("OC_SET_LANGUAGE")},
   {OC_QUERY_IMAGE,             TEXT("OC_QUERY_IMAGE")},
   {OC_REQUEST_PAGES,           TEXT("OC_REQUEST_PAGES")},
   {OC_QUERY_CHANGE_SEL_STATE,  TEXT("OC_QUERY_CHANGE_SEL_STATE")},
   {OC_CALC_DISK_SPACE,         TEXT("OC_CALC_DISK_SPACE")},
   {OC_QUEUE_FILE_OPS,          TEXT("OC_QUEUE_FILE_OPS")},
   {OC_NOTIFICATION_FROM_QUEUE, TEXT("OC_NOTIFICATION_FROM_QUEUE")},
   {OC_QUERY_STEP_COUNT,        TEXT("OC_QUERY_STEP_COUNT")},
   {OC_COMPLETE_INSTALLATION,   TEXT("OC_COMPLETE_INSTALLATION")},
   {OC_CLEANUP,                 TEXT("OC_CLEANUP")},
   {OC_QUERY_STATE,             TEXT("OC_QUERY_STATE")},
   {OC_NEED_MEDIA,              TEXT("OC_NEED_MEDIA")},
   {OC_ABOUT_TO_COMMIT_QUEUE,   TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
   {OC_QUERY_SKIP_PAGE,         TEXT("OC_QUERY_SKIP_PAGE")},
   {OC_WIZARD_CREATED,          TEXT("OC_WIZARD_CREATED")},
   {OC_FILE_BUSY,               TEXT("OC_FILE_BUSY")},
   {OCP_TEST_PRIVATE_BASE,      TEXT("OCP_TEST_PRIVATE_BASE")},
   {OCP_CHECK_NEEDS,            TEXT("OCP_CHECK_NEEDS")}
};

//
// Data structures
//
typedef struct _COMPONENT_DATA
{
   struct _COMPONENT_DATA *Next;

   //
   // Name of the component
   //
   LPCTSTR tszComponentId;

   //
   // Open inf handle to per-component inf for this component.
   //
   HINF hinfMyInfHandle;

   //
   // Operation flags from the SETUP_DATA structure we get at init time
   //
   DWORDLONG dwlFlags;

   //
   // Language ID we're supposed to use.
   //
   LANGID LanguageId;

   //
   // These things will not typically be per-component
   // since the DLL gets loaded multiple times within the
   // context of one suite/master OC inf.
   //
   // But just in case and for completeness, we include them here.
   //
   TCHAR tszSourcePath[MAX_PATH];
   TCHAR tszUnattendFile[MAX_PATH];
   OCMANAGER_ROUTINES ocrHelperRoutines;

   UINT uiFunctionToAV;

   BOOL bAccessViolation;

} COMPONENT_DATA, *PCOMPONENT_DATA;

typedef  struct   _PRIVATE_DATA
{
   TCHAR  tszName[MAX_MSG_LEN]; // The name of the data value

   UINT   uiType;               // The data type REG_DWORD, REG_SZ, 
                                //               REG_MULTI_SZ, REG_BINARY

   UINT   uiSize;               // The size of the data

   PVOID  pvBuffer;             // The buffer to hold the data

   PBYTE  pbBuffer;

} PRIVATE_DATA, *PPRIVATE_DATA;

typedef struct _MYWIZPAGE 
{
   //
   // Number of pages of this type
   //
   UINT uiCount;
   //
   // The page's index within the same type 
   //
   UINT uiOrdinal;
   //
   // The page's type
   //
   WizardPagesType wpType;
   //
   // The string that identifies the component queryed
   //
   TCHAR tszComponentId[MAX_PATH];

} MYWIZPAGE, *PMYWIZPAGE;

typedef struct _COMPLIST
{
   struct _COMPLIST *Next;
   TCHAR tszSubcomponentId[MAX_PATH];

} COMPLIST, *PCOMPLIST; // nd, *pnd

typedef struct _SUBCOMP
{
   struct _SUBCOMP *Next;
   
   TCHAR tszSubcomponentId[MAX_PATH];     // Name of this subcomponent
   TCHAR tszComponentId[MAX_PATH];        // Name of master component
   
   TCHAR tszParentId[MAX_PATH];           // Name of this subcomp's parent

   BOOL bMarked;                          // Used to mark this node

   UINT uiModeToBeOn[4];
   int nNumMode;
 
   PCOMPLIST pclNeeds;
   PCOMPLIST pclExclude;
   PCOMPLIST pclChildren;
   
} SUBCOMP, *PSUBCOMP; // sc, *psc

typedef struct _CHECK_NEEDS
{
   PCOMPLIST pclNeeds;
   PTCHAR    tszNodesVisited;
   BOOL      bResult;
   
} CHECK_NEEDS, *PCHECK_NEEDS; // cn, *pcn


/* This structure is used to pass parameters into the dialogbox */
typedef struct _ReturnOrAV
{
	TCHAR *tszComponent;
	TCHAR *tszSubComponent;
	TCHAR tszAPICall[256];
	BOOL bOverride;
	INT iReturnValue;
} ReturnOrAV, *PReturnOrAV;

// Some security stuff
// From NT security FAQ

struct UNI_STRING{
   USHORT len;
   USHORT maxlen;
   WCHAR *buff;
};

static HANDLE fh;

// End of security stuff

//=====================================================================
// Global variables
//=====================================================================
HINSTANCE          g_hDllInstance;         // File log handle and dll instance handle
PCOMPONENT_DATA    g_pcdComponents;        // linked list of components
BOOL               g_bUsePrivateFunctions; // Flag to allow/disallow the use of private functions
WizardPagesType    g_wpCurrentPageType;    // Current wizard page type
UINT               g_uiCurrentPage;        // Index of currend page
OCMANAGER_ROUTINES g_ocrHelperRoutines;    // Helper routines
UINT               g_auiPageNumberTable[MAX_WIZPAGE_TYPES];

static PSUBCOMP    g_pscHead;

//
// The "witness" file queue : all the files queued "with" the
// OCManager (as a response at OC_QUEUE_FILE_OPS) will be also
// queued here.
// Finally, we will perform a SetupScanFileQueue to determine
// if all the file operations are done.
//
HSPFILEQ g_FileQueue;

//
// We have to set the OC Manager Routines first time
// The first call to TestPrivateData must set all the values first.
// All the subsequent calls will query the values and reset
// one of them randomly.
//
static BOOL g_bFirstTime;

//
// If TRUE,  allow the user to select initial values for the component.
// If FALSE, default to preselected initial values
//
static BOOL g_bTestExtended;                  
static BOOL g_bAccessViolation;
static int g_nTestDialog;
static BOOL g_bNoWizPage;
static BOOL g_bCrashUnicode;
static BOOL g_bInvalidBitmap;
static int nStepsFinal;
static BOOL g_bHugeSize;
static BOOL g_bCloseInf;
static BOOL g_bNoNeedMedia;
static BOOL g_bCleanReg;
static UINT g_uiFunctionToAV;
HINF hInfGlobal;
static BOOL g_bNoLangSupport;
static BOOL g_bReboot;


//=====================================================================
// Function Prototypes for octest.c
//=====================================================================
BOOL CALLBACK ChooseVersionDlgProc(IN HWND   hwnd,
                                   IN UINT   uiMsg, 
                                   IN WPARAM wParam,
                                   IN LPARAM lParam);
                                   
BOOL CALLBACK ChooseSubcomponentDlgProc(IN HWND   hwnd,
                                        IN UINT   uiMsg, 
                                        IN WPARAM wParam,
                                        IN LPARAM lParam);
                                        
VOID ChooseVersionEx(IN     LPCVOID               lpcvComponentId, 
                     IN OUT PSETUP_INIT_COMPONENT psicInitComponent);
                     
EXPORT DWORD ComponentSetupProc(IN LPCVOID lpcvComponentId,
                                IN LPCVOID lpcvSubcomponentId,
                                IN UINT    uiFunction,
                                IN UINT    uiParam1,
                                IN PVOID   pvParam2);
                                
DWORD RunOcPreinitialize(IN LPCVOID lpcvComponentId, 
                         IN LPCVOID lpcvSubcomponentId, 
                         IN UINT    uiParam1);
                         
DWORD RunOcInitComponent(IN LPCVOID lpcvComponentId,
                         IN LPCVOID lpcvSubcomponentId,
                         IN PVOID   pvParam2);
                         
DWORD RunOcQueryState(IN LPCVOID lpcvComponentId,
                      IN LPCVOID lpcvSubcomponentId);
                      
DWORD RunOcSetLanguage(IN LPCVOID lpcvComponentId,
                       IN LPCVOID lpcvSubcomponentId,
                       IN UINT    uiParam1);
                       
DWORD RunOcQueryImage(IN LPCVOID lpcvComponentId,
                      IN LPCVOID lpcvSubcomponentId,
                      IN PVOID   pvParam2);
                      
DWORD RunOcRequestPages(IN LPCVOID lpcvComponentId,
                        IN UINT    uiParam1,
                        IN PVOID   pvParam2);
                        
DWORD RunOcQueryChangeSelState(IN LPCVOID lpcvComponentId, 
                               IN LPCVOID lpcvSubcomponentId, 
                               IN UINT    uiParam1);
                               
DWORD RunOcCalcDiskSpace(IN LPCVOID lpcvComponentId, 
                         IN LPCVOID lpcvSubcomponentId, 
                         IN UINT    uiParam1,
                         IN PVOID   pvParam2);
                         
DWORD RunOcQueueFileOps(IN LPCVOID lpcvComponentId, 
                        IN LPCVOID lpcvSubcomponentId, 
                        IN PVOID   pvParam2);
                        
DWORD RunOcNeedMedia(IN LPCVOID lpcvComponentId, 
                     IN UINT    uiParam1, 
                     IN PVOID   pvParam2);
                     
DWORD RunOcQueryStepCount(IN LPCVOID lpcvComponentId);

DWORD RunOcCompleteInstallation(IN LPCVOID lpcvComponentId, 
                                IN LPCVOID lpcvSubcomponentId);
                                
DWORD RunOcCleanup(IN LPCVOID lpcvComponentId);

DWORD RunTestOcPrivateBase(IN LPCVOID lpcvSubcomponentId, 
                           IN UINT    uiParam1, 
                           IN PVOID   pvParam2);
                       
DWORD TestHelperRoutines(IN LPCVOID lpcvComponentId,
                         IN OCMANAGER_ROUTINES OCManagerRoutines);

DWORD TestPrivateFunction(IN LPCVOID lpcvComponentId,
                          IN OCMANAGER_ROUTINES OCManagerRoutines);

VOID TestPrivateData(IN OCMANAGER_ROUTINES OCManagerRoutines);

VOID CheckPrivateValues(IN OCMANAGER_ROUTINES OCManagerRoutines,
                        IN PRIVATE_DATA       *aPrivateDataTable);

BOOL SetAValue(IN     OCMANAGER_ROUTINES OCManagerRoutines,
               IN     UINT               uiIndex,
               IN OUT PRIVATE_DATA       *aPrivateDataTable);
               
DWORD ChooseSubcomponentInitialState(IN LPCVOID lpcvComponentId,
                                     IN LPCVOID lpcvSubcomponentId);
                                     
PCOMPONENT_DATA AddNewComponent(IN LPCTSTR tszComponentId);

PCOMPONENT_DATA LocateComponent(IN LPCTSTR tszComponentId);

VOID RemoveComponent(IN LPCTSTR tszComponentId);

VOID CleanUpTest();

BOOL CreateSubcomponentInformationList(IN HINF hinf);

VOID FreeSubcomponentInformationList();

VOID ClearSubcomponentInformationMarks();

PSUBCOMP FindSubcomponentInformationNode(IN PTCHAR tszComponentId,
                                         IN PTCHAR tszSubcomponentId);

VOID CheckNeedsDependencies();

VOID CheckExcludeDependencies();

VOID CheckParentDependencies();

BOOL CheckNeedsDependenciesOfSubcomponent(IN     OCMANAGER_ROUTINES ocrHelper,
                                          IN     PSUBCOMP           pscSubcomponent,
                                          IN     PSUBCOMP           pscWhoNeedsMe,
                                          IN OUT PTCHAR             tszNodesVisited);

BOOL CheckLocalNeedsDependencies(IN     OCMANAGER_ROUTINES ocrHelper,
                                 IN     PSUBCOMP           pscSubcomponent,
                                 IN     PCOMPLIST          pclNeeds,
                                 IN OUT PTCHAR             tszNodesVisited);

BOOL AlreadyVisitedNode(IN PTCHAR tszSubcomponentId,
                        IN PTCHAR tszNodesVisited);

PTCHAR GetComponent(IN     PTCHAR tszSubcomponentId,
                    IN OUT PTCHAR tszComponentId);

VOID ParseCommandLine();

VOID testAV(BOOL);

BOOL TestReturnValueAndAV(IN     LPCVOID     lpcvComponentId,
							 	  IN     LPCVOID     lpcvSubcomponentId,
							 	  IN     UINT        uiFunction,
								  IN     UINT        uiParam1,
								  IN     PVOID       pvParam2,
								  IN OUT PReturnOrAV raValue);

BOOL BeginTest();

BOOL CALLBACK ChooseReturnOrAVDlgProc(IN HWND   hwnd,
                                       IN UINT   uiMsg, 
                                       IN WPARAM wParam,
                                       IN LPARAM lParam);  

void causeAV(IN UINT uiFunction);


BOOL CALLBACK CauseAVDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg, 
                             IN WPARAM wParam,
                             IN LPARAM lParam);


UINT GetOCFunctionName(IN PTCHAR tszFunctionName);

void SetGlobalsFromINF(HINF infHandle);

void causeAVPerComponent(IN UINT uiFunction, IN LPCVOID lpcvComponentId);

void SetDefaultMode(PCOMPONENT_DATA pcdComponentData);

//=====================================================================
// Function Prototypes for utils.c
//=====================================================================
VOID LogOCFunction(IN  LPCVOID lpcvComponentId,
                   IN  LPCVOID lpcvSubcomponentId,
                   IN  UINT    uiFunction,
                   IN  UINT    uiParam1,
                   IN  PVOID   pvParam2); 

BOOL QueryButtonCheck(IN HWND hwndDlg,
                      IN INT  iCtrlID);

VOID PrintSpaceOnDrives(IN HDSKSPC DiskSpace);

VOID MultiStringToString(IN  PTSTR   tszMultiStr,
                         OUT PTSTR   tszStr);

INT MultiStringSize(IN PTSTR tszMultiStr);

VOID CopyMultiString(OUT PTSTR tszMultiStrDestination,
                     IN  PTSTR tszMultiStrSource);
                     
VOID InitGlobals();
                     
//=====================================================================
// Function Prototypes for wizpage.c
//=====================================================================
DWORD DoPageRequest(IN     LPCTSTR              tszComponentId,
                    IN     WizardPagesType      wpWhichOnes,
                    IN OUT PSETUP_REQUEST_PAGES psrpSetupPages,
                    IN     OCMANAGER_ROUTINES   ocrOcManagerHelperRoutines);

VOID PrintModeInString(OUT PTCHAR tszString,
                       IN  UINT   uiSetupMode);

INT ButtonIdFromSetupMode(IN DWORD dwSetupMode);

DWORD SetupModeFromButtonId(IN INT iButtonId);

BOOL CALLBACK WizPageDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg,
                             IN WPARAM wParam,
                             IN LPARAM lParam);

#endif   // _OCTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\wizpage.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   wizpage.c

Abstract:

   This module contains the function that loads the wizard pages, as well as
   the wizard page dialog procedure.

Author:

   Bogdan Andreiu (bogdana)  10-Feb-1997
   Jason Allor    (jasonall) 23-Feb-1998  (took over the project)

Revision History:

   10-Feb-1997   bogdana
     
      First draft.
   
   20-Feb-1997   bogdana  
     
      Added more complex page "negotiation"
     
 --*/
#include "octest.h"


/*++

Routine Description: WizPageDlgProc (2.2)

   The wizard page dialog procedure.    
   
Arguments:

   Standard dialog procedure parameters.
   
Return Value:

   Standard dialog procedure return value.

--*/
BOOL CALLBACK WizPageDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg,
                             IN WPARAM wParam,
                             IN LPARAM lParam)
{
   double fn = 2.2;
   
   BOOL            bResult;
   TCHAR           tszText[MAX_MSG_LEN];
   PMYWIZPAGE      pPage;
   static DWORD    s_dwCurrentMode = (DWORD)SETUPMODE_TYPICAL;
   static DWORD    s_dwFutureMode  = (DWORD)SETUPMODE_TYPICAL;
   static BOOL     s_bChangeMode = FALSE;
   static BOOL     s_bSkipPages = FALSE;

   switch (uiMsg)
   {
      case WM_INITDIALOG:
         {
            LPCTSTR tszPageType;

            pPage = (PMYWIZPAGE)(((LPPROPSHEETPAGE)lParam)+1);
            
            //
            // Set up various text controls as an indicator of what
            // this page is.
            //
            SetDlgItemText(hwnd, IDC_COMPONENT, pPage->tszComponentId);

            switch (pPage->wpType)
            {
               case WizPagesWelcome:
                  tszPageType = TEXT("Welcome");
                  break;

               case WizPagesMode:
                  tszPageType = TEXT("Mode");
                  break;

               case WizPagesEarly:
                  tszPageType = TEXT("Early");
                  break;

               case WizPagesPrenet:
                  tszPageType = TEXT("Prenet");
                  break;

               case WizPagesPostnet:
                  tszPageType = TEXT("Postnet");
                  break;

               case WizPagesLate:
                  tszPageType = TEXT("Late");
                  break;

               case WizPagesFinal:
                  tszPageType = TEXT("Final");
                  break;

               default:
                  tszPageType = TEXT("(unknown)");
                  break;
            }

            SetDlgItemText(hwnd, IDC_PAGE, tszPageType);

            _stprintf(tszText, TEXT("(page %u of %u for this component ")
                               TEXT("and page type)"),
                               pPage->uiOrdinal, pPage->uiCount);

            SetDlgItemText(hwnd, IDC_COUNT, tszText);
         }
         
         //
         // Set the type for the current page
         //
         g_wpCurrentPageType = pPage->wpType;
         
         //
         // Set the ordinal number for the current page
         //
         g_uiCurrentPage = pPage->uiOrdinal;
         
         //
         // Check if the page count received is identical with the one stored
         //
         if (pPage->uiCount != 
             g_auiPageNumberTable[pPage->wpType - WizPagesWelcome])
         {
            Log(fn, SEV2, TEXT("Different page types"));
         }

         bResult = TRUE;
         break;

      case WM_COMMAND:

         switch (LOWORD(wParam))
         {
            HWND hwndSheet;

            case IDC_MINIMAL:
            case IDC_CUSTOM:
            case IDC_TYPICAL:
            case IDC_LAPTOP:
               s_dwFutureMode = SetupModeFromButtonId(LOWORD(wParam));
               s_bChangeMode  = TRUE;
               CheckRadioButton(hwnd, 
                                IDC_MINIMAL, 
                                IDC_LAPTOP, 
                                LOWORD(wParam));
               break;
            
            case IDC_SKIP_PAGES:
            
            default:  
               break;
         }

         bResult = TRUE;
         break;

      case WM_NOTIFY:
         bResult = FALSE;
         __ASSERT((g_uiCurrentPage >= 1) && 
                  (g_uiCurrentPage <= PageNumberTable[g_wpCurrentPageType - 
                                                     WizPagesWelcome]));
         
         switch (((NMHDR *)lParam)->code)
         {
            case PSN_SETACTIVE:
               
               //
               // Accept activation and set buttons.
               //
               if ((g_wpCurrentPageType == WizPagesFinal) && 
                   (g_uiCurrentPage == 
                    g_auiPageNumberTable[g_wpCurrentPageType - 
                                         WizPagesWelcome]))
               {
                  PropSheet_SetWizButtons(GetParent(hwnd), 
                                          PSWIZB_BACK | PSWIZB_NEXT);
               }
               else
               {
                  PropSheet_SetWizButtons(GetParent(hwnd), 
                                          PSWIZB_BACK | PSWIZB_NEXT);
               }
               
               //
               // If it is a mode page, display the current mode
               //
               if (g_wpCurrentPageType == WizPagesMode)
               {
                  //
                  // Display the current selected mode
                  //
                  s_dwCurrentMode = g_ocrHelperRoutines.GetSetupMode(
                                       g_ocrHelperRoutines.OcManagerContext);
                  
                  PrintModeInString(tszText, s_dwCurrentMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
                  
                  //
                  // By default, we want no changes 
                  //
                  s_bChangeMode = FALSE;
               }
               
               if (g_wpCurrentPageType == WizPagesMode)
               {
                  CheckRadioButton(hwnd, 
                                   IDC_MINIMAL, 
                                   IDC_LAPTOP, 
                                   ButtonIdFromSetupMode(s_dwCurrentMode));
               }
               
               //
               // Check the buttons appropiately
               //
               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  CheckDlgButton(hwnd, IDC_SKIP_PAGES, s_bSkipPages?1:0);
               }
               
               SetDlgItemText(hwnd, IDC_TEST, TEXT(""));

               if (s_bSkipPages && (g_uiCurrentPage == 2))
               {
                  SetWindowLong(hwnd, DWL_MSGRESULT, -1);
               }
               else
               {
                  SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               }
               bResult = TRUE;
               break;

            case PSN_APPLY:
               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;
            
            case PSN_WIZBACK:
               if (g_uiCurrentPage > 1)
               {
                  g_uiCurrentPage--;
               }
               else
               {
                  if (g_wpCurrentPageType != WizPagesWelcome)
                  {
                     g_wpCurrentPageType--;
                     g_uiCurrentPage = 
                        g_auiPageNumberTable[g_wpCurrentPageType - 
                                             WizPagesWelcome];
                  }
               }

               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  //
                  // Check the state of the "Skip pages"button
                  //
                  s_bSkipPages = QueryButtonCheck(hwnd, IDC_SKIP_PAGES);
               }

               //
               // Apply the changes resulted from the dialog box
               //
               if ((g_wpCurrentPageType == WizPagesMode) && s_bChangeMode)
               {
                  g_ocrHelperRoutines.SetSetupMode(
                                        g_ocrHelperRoutines.OcManagerContext, 
                                        s_dwFutureMode);
                  
                  PrintModeInString(tszText, s_dwFutureMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
               }

               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;

            case PSN_WIZNEXT:
               if (g_uiCurrentPage < 
                   g_auiPageNumberTable[g_wpCurrentPageType - 
                                        WizPagesWelcome])
               {
                  g_uiCurrentPage++;
               }
               else
               {
                  if (g_wpCurrentPageType != WizPagesFinal)
                  {
                     g_wpCurrentPageType++;
                     g_uiCurrentPage = 1;
                  }
               }
               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  //
                  // Check the state of the "Skip pages"button
                  //
                  s_bSkipPages = QueryButtonCheck(hwnd, IDC_SKIP_PAGES);
               }

               //
               // Apply the changes resulted from the dialog box
               //
               if ((g_wpCurrentPageType == WizPagesMode) && s_bChangeMode)
               {
                  g_ocrHelperRoutines.SetSetupMode(
                                        g_ocrHelperRoutines.OcManagerContext, 
                                        s_dwFutureMode);

                  PrintModeInString(tszText, s_dwFutureMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
               }

               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;

            case PSN_WIZFINISH:
            case PSN_KILLACTIVE:
               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;
            
            case PSN_QUERYCANCEL:
               {
                  BOOL  bCancel;

                  bCancel = g_ocrHelperRoutines.ConfirmCancelRoutine(hwnd);
                  SetWindowLong(hwnd, DWL_MSGRESULT, !bCancel);
                  bResult = TRUE;

                  break;
               }
            
            default: 
               break;
         }

         break;

      default:
         bResult = FALSE;
         break;
   }

   return bResult;

} // WizPageDlgProc //




/*++

Routine Description: DoPageRequest (2.1)

   This routine handles the OC_REQUEST_PAGES interface routine.

   For illustrative purposes we return a random number of pages
   between 1 and MAX_WIZARD_PAGES, each with some text that indicates which
   page type and component is involved.

Arguments:

   tszComponentId:    supplies id for component. 
   wpWhichOnes:       supplies type of pages fo be supplied.
   psrpSetupPages:    receives page handles.
   ocrHelperRoutines: OC Manager - provided helper routines

Return Value:

   Count of pages returned, or -1 if error, in which case SetLastError()
   will have been called to set extended error information.

--*/
DWORD DoPageRequest(IN     LPCTSTR              tszComponentId,
                    IN     WizardPagesType      wpWhichOnes,
                    IN OUT PSETUP_REQUEST_PAGES psrpSetupPages,
                    IN     OCMANAGER_ROUTINES   ocrOcManagerHelperRoutines)
{
   double fn = 2.1;
   
   UINT            uiCount;
   UINT            uiIndex;
   static UINT     uiBigNumberOfPages = 0;
   TCHAR           tszMsg[MAX_MSG_LEN];
   PMYWIZPAGE      MyPage;
   LPPROPSHEETPAGE Page = NULL;

   //
   // Save the helper routines for further use
   //
   g_ocrHelperRoutines = ocrOcManagerHelperRoutines;    

   if (wpWhichOnes == WizPagesFinal)
   {
      uiCount = 0;
      g_auiPageNumberTable[wpWhichOnes - WizPagesWelcome] = uiCount;
      return uiCount;
   }
   //
   // For two types of pages, we will "negotiate" with the OC Manager 
   // the number of pages. We need the second condition because 
   // otherwise we will "negotiate" forever...
   //
   if ((wpWhichOnes == WizPagesEarly) || (wpWhichOnes == WizPagesLate))
   {
      if (uiBigNumberOfPages == 0)
      {
         //
         // First time : we will store the number of pages requested
         //
         uiBigNumberOfPages = uiCount = psrpSetupPages->MaxPages + 1;
      }
      else
      {
         if (uiBigNumberOfPages != psrpSetupPages->MaxPages)
         {
            //
            // We requested a number of pages that was not supplied 
            // we will log an error
            //
            Log(fn, SEV2, TEXT("Incorrect number of pages received"));
         }
         //
         // We will lie about the number of pages for the late pages
         //
         if (wpWhichOnes == WizPagesLate)
         {
            uiBigNumberOfPages = 0;
            uiCount = (rand() % MAX_WIZARD_PAGES) + 1;
         }
         else
         {
            //
            // The second time, for the Early pages, 
            // we return InitialSize + 1 (that is BigNumberOfPages)
            //
            uiCount = uiBigNumberOfPages;
         }

      }
   }
   else
   {
      uiCount = (rand() % MAX_WIZARD_PAGES) + 1;
      uiBigNumberOfPages = 0;
   }
   
   //
   // Fill in the local page table
   //
   g_auiPageNumberTable[wpWhichOnes - WizPagesWelcome] = uiCount;

   //
   // Make sure there's enough space in the array OC Manager sent us.
   // If not then tell OC Manager that we need more space.
   //
   if (uiCount > psrpSetupPages->MaxPages)
   {
      return(uiCount);
   }

   for (uiIndex = 0; uiIndex < uiCount; uiIndex++)
   {
      if (Page) __Free(&Page);
      
      //
      // The wizard common control allows the app to place private data
      // at the end of the buffer containing the property sheet page
      // descriptor. We make use of this to remember info we want to
      // use to set up text fields when the pages are activated.
      //
      if (!__Malloc(&Page, sizeof(PROPSHEETPAGE) + sizeof(MYWIZPAGE)))
      {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         return((DWORD)(-1));
      }

      Page->dwSize = sizeof(PROPSHEETPAGE) + sizeof(MYWIZPAGE);

      Page->dwFlags = PSP_DEFAULT;

      Page->hInstance = g_hDllInstance;

      //
      // We will use a different template for the Mode and Welcome pages
      //
      switch (wpWhichOnes)
      {
         case  WizPagesWelcome:
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZWELCOME);
            break;
         case  WizPagesMode: 
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZMODE);
            break;
         default: 
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZPAGE);
            break;
      }
      
      //
      // The dialog procedure is the same
      //
      Page->pfnDlgProc = WizPageDlgProc;
      MyPage = (PMYWIZPAGE)(Page + 1);

      //
      // Fill in the "private" fields
      //
      MyPage->uiCount = uiCount;
      MyPage->uiOrdinal = uiIndex + 1;
      MyPage->wpType = wpWhichOnes;
      _tcscpy(MyPage->tszComponentId, tszComponentId);
      
      //
      // OK, now create the page.
      //
      psrpSetupPages->Pages[uiIndex] = CreatePropertySheetPage(Page);

      if (!psrpSetupPages->Pages[uiIndex])
      {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         
         if (Page) __Free(&Page);
         return (DWORD)(-1);
      }
   }

   if (Page) __Free(&Page);
   return uiCount;

} // DoPageRequest //




/*++

Routine Description: PrintModeInString

   Prints the mode in "readable" string to be further displayed
   on the wizard page.

Arguments:

   tszString:   receives the string.
   uiSetupMode: supplies the mode.

Return Value:

   None.
   
---*/
VOID PrintModeInString(OUT PTCHAR tszString,
                       IN  UINT   uiSetupMode)  
{
   switch (uiSetupMode)
   {
      case SETUPMODE_MINIMAL:
         _stprintf(tszString, TEXT("Current mode is MINIMAL"));
         break;
      
      case SETUPMODE_TYPICAL:
         _stprintf(tszString, TEXT("Current mode is TYPICAL"));
         break;
      
      case SETUPMODE_LAPTOP:
         _stprintf(tszString, TEXT("Current mode is LAPTOP"));
         break;
      
      case SETUPMODE_CUSTOM:
         _stprintf(tszString, TEXT("Current mode is CUSTOM"));
         break;
      
      default:
         _stprintf(tszString, TEXT("Current mode is <%u>"), uiSetupMode);
         break;
   }

   return;                

} // PrintModeInString //




/*++

Routine Description: ButtonIdFromSetupMode

    Converts a setup mode to a button id

Arguments:

    dwSetupMode: the setup mode to convert

Return Value:

   INT: returns button id
   
---*/
INT ButtonIdFromSetupMode(IN DWORD dwSetupMode)  
{
   switch (dwSetupMode)
   {
      case SETUPMODE_MINIMAL: return IDC_MINIMAL;
      case SETUPMODE_LAPTOP:  return IDC_LAPTOP;
      case SETUPMODE_TYPICAL: return IDC_TYPICAL;
      case SETUPMODE_CUSTOM:  return IDC_CUSTOM;
      default:                return IDC_TYPICAL;
   }

} // ButtonIdFromSetupMode //

                             
                             

/*++

Routine Description: SetupModeFromButtonid

    Converts a button id to a setup mode

Arguments:

    iButtonId: the button id to convert

Return Value:

    DWORD: returns setup mode
   
---*/
DWORD SetupModeFromButtonId(IN INT iButtonId)  
{
   switch (iButtonId)
   {
      case IDC_MINIMAL: return SETUPMODE_MINIMAL;
      case IDC_LAPTOP:  return SETUPMODE_LAPTOP;
      case IDC_TYPICAL: return SETUPMODE_TYPICAL;
      case IDC_CUSTOM:  return SETUPMODE_CUSTOM;
      default:          return SETUPMODE_TYPICAL;
   }

} // SetupModeFromButtonId //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\sources.inc ===
NTDEBUG=ntsd
NTDEBUGTYPE=both

TARGETPATH=..\octest
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1
USE_MSVCRT=1

UMLIBS=$(SDK_LIB_PATH)\libc.lib\
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\user32.lib

SOURCES= ..\octest.c  \
         ..\utils.c     \
         ..\wizpage.c   \
         ..\octest.rc \
         ..\msg.mc

INCLUDES=..\hctlib;..
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\checkinf.cpp ===
#include <iostream.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <tchar.h>
#include <wchar.h>
#include "CheckINF.h"
#include "hcttools.h"
#include "logutils.h"

// The master INF is opened first
// Then all the infs that are pointed to in the master are opened
// Then all the infs that are pointed to in the subcomp infs are opened
// All these things make a big open INF file

// bunch of section names
const PTSTR tszOptionalComponents = TEXT("Optional Components");      
const PTSTR tszComponents         = TEXT("Components");
const PTSTR tszLayoutFile         = TEXT("LayoutFile");
const PTSTR tszIconIndex          = TEXT("IconIndex");

/*++

   Routine description: 
   
      Check the validity of a set of INF files
      used by OC Manager
      
   Argument:
   
      Standard main argument
      
   Return Value:
   
      None
      
--*/

VOID __cdecl main(INT   argc, 
                   TCHAR *argv[])
{
   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("main");

   if (argc < 2) {
      _stprintf(tszMsg, 
                TEXT("Correct Usage: %s INFFileNameToCheck [/l] [/m]"), 
                argv[0]);

      MessageBox(NULL, 
                 tszMsg, 
                 TEXT("Incorrect argument"), 
                 MB_ICONERROR | MB_OK);

      return;
   }

   g_bUseLog = FALSE;
   g_bUseMsgBox = FALSE;
   g_bUseConsole = TRUE;
   g_bMasterInf = TRUE;

   // Parse the argument and set global variables
   for (INT i = 1; i < argc; i++) {
      if (_tcscmp(argv[i], TEXT("/m")) == 0 ||
          _tcscmp(argv[i], TEXT("/M")) == 0 ||
          _tcscmp(argv[i], TEXT("-m")) == 0 ||
          _tcscmp(argv[i], TEXT("-M")) == 0 ) {

         g_bUseMsgBox = TRUE;
      }
      if (_tcscmp(argv[i], TEXT("/l")) == 0 ||
          _tcscmp(argv[i], TEXT("/L")) == 0 ||
          _tcscmp(argv[i], TEXT("-l")) == 0 ||
          _tcscmp(argv[i], TEXT("-L")) == 0 ) {

         g_bUseLog = TRUE;
      }
   }

   // we will see if there is any path seperator in the filename
   // if there is, we assume it is the full path
   // if there is not, we assume it is in the current directory

   PTSTR tszFilename = argv[1];

   while (*tszFilename) {
      if (*tszFilename == TEXT('\\')) {
         break;
      }
      tszFilename++;
   }

   // Let's initialize the log
   if (g_bUseLog) {
      InitLog(TEXT("checkinf.log"), TEXT("Inf File Check Log"), TRUE);
   }

   TCHAR tszDir[MaxStringSize];

   if (!*tszFilename) {
      // Get the currect path
      GetCurrentDirectory(MaxBufferSize, tszDir);

      if (tszDir[_tcslen(tszDir)-1] != TEXT('\\')) {
         tszDir[_tcslen(tszDir)+1] = 0;
         tszDir[_tcslen(tszDir)] = TEXT('\\');         
      }

      CheckINF(tszDir, argv[1]);
   }

   else {
      CheckINF(NULL, argv[1]);
   }

   if (g_bUseLog) {
      ExitLog();
   }

   return;
}

/*++
   Routine description: 
      
      Check the validity of an INF file
      
   Argument:
      
      TCHAR *tszDir      : Where the Inf files are
      TCHAR *tszFilename : file name of the inf file to check
      
   Return value:
   
      FALSE means there is something wrong
      TRUE means everything going well
      
--*/

BOOL CheckINF(IN TCHAR *tszDir, 
              IN TCHAR *tszFilename)
{
   UINT uiError;
   HINF hinfHandle;

   TCHAR tszMsg[256];

   TCHAR tszSubINFName[256][MaxStringSize];
   UINT uiNumComponents;

   INFCONTEXT infContext;

   BOOL bSuccess;

   const PTSTR tszFunctionName = TEXT("CheckINF");

   // Open the INF Files
   if (tszDir && *tszDir) {
      _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszFilename);
      hinfHandle = SetupOpenInfFile(tszMsg, 
                                    NULL, 
                                    INF_STYLE_WIN4, 
                                    &uiError);
   }

   else {
      hinfHandle = SetupOpenInfFile(tszFilename, 
                                    NULL, 
                                    INF_STYLE_WIN4, 
                                    &uiError);
   }

   if (hinfHandle == INVALID_HANDLE_VALUE) {
      // If the openning failed, try the system default path
      if (!tszDir) {
         hinfHandle = SetupOpenInfFile(tszFilename,
                                       NULL,
                                       INF_STYLE_WIN4,
                                       &uiError);
         if (hinfHandle != INVALID_HANDLE_VALUE) {
            LogError(TEXT("File openned in system path"),
                     INFO,
                     tszFunctionName);
         }
      }
      if (hinfHandle == INVALID_HANDLE_VALUE) {
         _stprintf(tszMsg, 
                   TEXT("Error opeing INF file %s"), 
                   tszFilename);

         MessageBox(NULL, tszMsg, tszFunctionName, MB_OK);
         
         return FALSE;
      }
   }

   _stprintf(tszMsg, TEXT("%s opened"), tszFilename);
   LogError(tszMsg, INFO, tszFunctionName);

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszComponents, 
                                 NULL, 
                                 &infContext);

   if (!bSuccess) {
      // This is not a master inf file
      g_bMasterInf = FALSE;
      LogError(TEXT("[Components] section not found."),
               INFO, 
               tszFunctionName);                         
   }

   else {

      // in the [Components] section, get all the INF file names
      // and using SetupOpenAppendFile to append to the current handle

      uiNumComponents = SetupGetLineCount(hinfHandle, tszComponents);

      if (uiNumComponents < 1) {

         LogError(TEXT("Too few components in the [Components] section"), 
                  SEV2, 
                  tszFunctionName);

         return TRUE;
      }

      for (UINT i = 0; i < uiNumComponents; i++) {
         UINT uiNumFieldCount;

         uiNumFieldCount = SetupGetFieldCount(&infContext);

         if (uiNumFieldCount < 3) {
            tszSubINFName[i][0] = 0;
            SetupFindNextLine(&infContext, &infContext);

            continue;
         }

         SetupGetStringField(&infContext, 
                             3, 
                             tszSubINFName[i], 
                             MaxBufferSize, 
                             NULL);

         SetupFindNextLine(&infContext, &infContext);
      }

      // It is assumed that the master INF doesn't contain path
      for (UINT j = 0; j < uiNumComponents; j++) {
         if (tszSubINFName[j][0]) {
            _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszSubINFName[j]); 

            bSuccess = SetupOpenAppendInfFile(tszMsg, hinfHandle, NULL);

            if (!bSuccess) {
               _stprintf(tszMsg, TEXT("Error opening %s"), tszMsg);
               LogError(tszMsg, SEV2, tszFunctionName);
            }

            else {
               _stprintf(tszMsg, TEXT("%s opened"), tszMsg);
               LogError(tszMsg, INFO, tszFunctionName);

            }
         }
      }
   }

   // Now the file is opened
   ComponentList clList;

   FillList(hinfHandle, &clList, tszDir);

   CheckIconIndex(hinfHandle, &clList);

   CheckNeedRelationship(&clList);

   CheckExcludeRelationship(&clList);

   CheckParentRelationship(&clList);

   CheckCopyFiles(hinfHandle, &clList);

   CheckSuspicious(hinfHandle, &clList);

   CheckSameId(&clList);

   CheckDescription(hinfHandle, &clList);

   CheckModes(hinfHandle, &clList);

   SetupCloseInfFile(hinfHandle);

   if (g_bMasterInf) {
      CheckLayoutFile(tszSubINFName, uiNumComponents, tszDir);
   }
   else{
      _tcscpy(tszSubINFName[0], tszFilename);
      CheckLayoutFile(tszSubINFName, 1, tszDir);

   }

   return TRUE;

}

/*++

   Routine Description:
   
      This routine creates the component list
      and fill the relation list of each component on the list
      
   Argument:
   
      HINF hinfHandle    : a handle to the Inf file
      Component *pclList : a pointer to the component list
      TCHAR *tszDir      : current working directory
      
   Return Value:
   
      The return value is not used
      
--*/ 
BOOL FillList(IN OUT HINF hinfHandle, 
              IN OUT ComponentList *pclList, 
              IN     TCHAR *tszDir)
{
   INFCONTEXT infContext;
   BOOL bSuccess;

   UINT uiNumComponents;

   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("FillList");

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszOptionalComponents, 
                                 NULL, 
                                 &infContext);

   if (!bSuccess) {
      LogError(TEXT("There is no [Optional Components] section"),
               SEV2, 
               tszFunctionName);

      return FALSE;
   }

   // Get the number of components in this INF file
   uiNumComponents = SetupGetLineCount(hinfHandle, tszOptionalComponents);

   if (uiNumComponents <= 0) {
      LogError(TEXT("There is no optional component"),
               SEV2,
               tszFunctionName);

      return FALSE;
   }

   // Build a array of all the component names listed
   TCHAR Components[256][MaxStringSize];

   UINT count = 0;
   for (UINT l = 0; l < uiNumComponents; l++) {
      bSuccess = SetupGetStringField(&infContext, 
                                     0, 
                                     Components[count], 
                                     MaxBufferSize, 
                                     NULL);
      if (bSuccess) {
         SetupFindNextLine(&infContext, &infContext);
         count++;
      }
      else {
         LogError(TEXT("Error getting component name"),
                  SEV2, 
                  tszFunctionName);
         return TRUE;
      }
   }

   // For each component listed here
   // There should be a section with the same name
   // otherwise there is an error
   Component *pcNewComponent;

   for (UINT i = 0; i < uiNumComponents; i++) {

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[i], 
                                    NULL, 
                                    &infContext);

      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Can't find the section [%s]"), 
                   Components[i]);

         LogError(tszMsg, SEV2, tszFunctionName);

         return FALSE;
      }

      // add the component to the list
      pcNewComponent = pclList->AddComponent(Components[i]);

      // Figure out the parent id from the INF File
      pcNewComponent->GetParentIdFromINF(hinfHandle);

   }

   // Now go through the list and fill the prlChildrenList
   // of each component
   Component *pcComponent;

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();
      pcComponent->BuildChildrenList(pclList);
   }

   // Now go through the INF for a second time
   // This time the need and exclude relationlist is filled

   TCHAR tszId[MaxStringSize];

   for (UINT k = 0; k < uiNumComponents; k++) {

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    NULL, 
                                    &infContext);

      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Can't find the section [%s]"), 
                   Components[k]);

         LogError(tszMsg, SEV2, tszFunctionName);

         return TRUE;
      }

      // Get the needs= line 
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    TEXT("Needs"), 
                                    &infContext);

      if (bSuccess) {
         UINT uiNumNeeds = SetupGetFieldCount(&infContext);

         if (uiNumNeeds == 0) {
            _stprintf(tszMsg, 
                      TEXT("Too few field for the Needs key in [%s]"), 
                      Components[k]);

            LogError(tszMsg, SEV2, tszFunctionName);
         }

         for (UINT j = 1; j <= uiNumNeeds; j++) {
            SetupGetStringField(&infContext, 
                                j, 
                                tszId, 
                                MaxBufferSize, 
                                NULL);

            Component *pcTemp = pclList->LookupComponent(Components[k]);

            if (!pcTemp) {
               // Can't find Components[k]
               // This can only happen if there is something wrong
               // in the code

               LogError(TEXT("Something wrong in the code"), 
                        SEV2, 
                        tszFunctionName);

               return TRUE;
            }

            else {
               pcTemp->GetNeedList()->AddRelation(tszId);
            }
         }
      }

      // Get the exclude
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    TEXT("Exclude"), 
                                    &infContext);

      if (bSuccess) {
         UINT uiNumExcludes = SetupGetFieldCount(&infContext);

         if (uiNumExcludes == 0) {
            _stprintf(tszMsg, 
                      TEXT("Too few field for Exclude= in section [%s]"),
                      Components[k]);

            LogError(tszMsg, SEV2, tszFunctionName);

         }

         for (UINT l = 1; l <= uiNumExcludes; l++) {
            SetupGetStringField(&infContext, 
                                l, 
                                tszId, 
                                MaxBufferSize, 
                                NULL);

            Component *pcTmp = NULL;
            pcTmp = pclList->LookupComponent(tszId);

            if (!pcTmp) {
               _stprintf(tszMsg, 
                         TEXT("Unknown component %s in section [%s]"),
                         tszId, Components[k]);

               LogError(tszMsg, SEV2, tszFunctionName);
            }
            else {
               pcTmp->GetExcludeList()->AddRelation(Components[k]);
               pcTmp = pclList->LookupComponent(Components[k]);
               pcTmp->GetExcludeList()->AddRelation(tszId);
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine to check the IconIndex key of each component
      
   Argument:
   
      HINF hinfHandle        : A handle to the Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckIconIndex(IN HINF          hinfHandle, 
                    IN ComponentList *pclList)
{
   // Go through each of the component in the list

   PTSTR tszId;

   TCHAR tszMsg[MaxStringSize];

   BOOL bSuccess;

   INFCONTEXT infContext;

   INT nIconIndex;

   TCHAR tszTemp[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckIconIndex");

   pclList->ResetList();

   while (!pclList->Done()) {
      tszId = pclList->GetNext()->GetComponentId();

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    tszId, 
                                    tszIconIndex, 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("IconIndex not present for component %s"), 
                   tszId);

         LogError(tszMsg, SEV2, tszFunctionName);
         continue;
      }

      UINT uiNumField = SetupGetFieldCount(&infContext);

      if (uiNumField < 1) {
         _stprintf(tszMsg, 
                   TEXT("%s has less than 2 fields for component %s"),
                   tszIconIndex, 
                   tszId);
         LogError(tszMsg, SEV2, tszFunctionName);

      }

      else if (uiNumField > 1) {
         _stprintf(tszMsg, 
                   TEXT("%s has more than 2 fields for component %s"),
                   tszIconIndex, 
                   tszId);
         LogError(tszMsg, SEV2, tszFunctionName);
      }
      else {
         bSuccess = SetupGetIntField(&infContext, 1, &nIconIndex);
         if (bSuccess) {
            // Check the range of the iconindex returned
            if (nIconIndex < 0 || nIconIndex > 66) {
               _stprintf(tszMsg, 
                         TEXT("Invalid icon index %d for component %s"),
                         nIconIndex, 
                         tszId);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else if (nIconIndex == 12 ||
                     nIconIndex == 13 || 
                     nIconIndex == 25) {
               _stprintf(tszMsg, 
                         TEXT("Component %s is using icon index %d"), 
                         tszId, 
                         nIconIndex);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
         else {
            bSuccess = SetupGetStringField(&infContext, 
                                           1, 
                                           tszTemp, 
                                           MaxBufferSize, 
                                           NULL);

            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Error reading the value of %s in [%s]"), 
                         tszIconIndex, tszId);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               if (_tcscmp(tszTemp, TEXT("*")) != 0 ) {
                  _stprintf(tszMsg, 
                            TEXT("Invalid value of %s in [%s]"),
                            tszIconIndex, tszId);
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the need relationship amond component
      
   Argument:
   
      ComponentList *pclList : A pointer to the list of component
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckNeedRelationship(IN ComponentList *pclList)
{
   Component *pcComponent;

   TCHAR tszMsg[MaxStringSize];

   BOOL bNonExist = FALSE;

   const PTSTR tszFunctionName = TEXT("CheckNeedRelationship");

   // First thing to check
   // There should not be a component that needs
   // a categorical component

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() && 
          pcComponent->IsNeededByOthers(pclList)) {

         _stprintf(tszMsg,
                   TEXT("%s has subcomponent and is needed by others"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);


      }
   }

   // Second thing to check
   // There should not be a categorical component
   // that needs another component

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->NeedOthers() != NULL) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent, and needs another component"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);


      }
   }

   // Third thing to check
   // There should not be Need and Exclude at the same time

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->NeedAndExcludeAtSameTime(pclList)) {
         _stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
   }

   // Fouth thing to check
   // Every component should need an existent component
   // if the argument is a master inf file

   Relation *prNeed;

   if (g_bMasterInf) {
      pclList->ResetList();

      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();

         pcComponent->GetNeedList()->ResetList();

         while (!pcComponent->GetNeedList()->Done()) {

            prNeed = pcComponent->GetNeedList()->GetNext();
            
            if (!pclList->LookupComponent(prNeed->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s needs %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prNeed->GetComponentId());

               LogError(tszMsg, SEV2, tszFunctionName);

               bNonExist = TRUE;
            }
         }
      }
   }

   // Fifth thing to check
   // There should not be cycles 

   if (g_bMasterInf && !bNonExist) {

      pclList->ResetList();
   
      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();
   
         // Recursive calls to find the cycle
         CheckNeedCycles(pcComponent, pclList);
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the exclude relation among components
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
   
--*/

BOOL CheckExcludeRelationship(IN ComponentList *pclList)
{
   TCHAR tszMsg[MaxStringSize];

   Component *pcComponent;

   const PTSTR tszFunctionName = TEXT("CheckExcludeRelationship");

   // Can't exclude a categorical component
   // a categorical component can't exclude another component

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->IsExcludedByOthers(pclList)) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent and is excluded by other componennts"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->ExcludeOthers() != NULL) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent and excludes other components"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }

   }

   // Component should exclude an existent component

   Relation *prExclude;

   if (g_bMasterInf) {
      pclList->ResetList();

      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();

         pcComponent->GetExcludeList()->ResetList();

         while (!pcComponent->GetExcludeList()->Done()) {

            prExclude = pcComponent->GetExcludeList()->GetNext();
            
            if (!pclList->LookupComponent(prExclude->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s excludes %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prExclude->GetComponentId());

               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the parent relationship among components
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckParentRelationship(IN ComponentList *pclList)
{
   TCHAR tszMsg[MaxStringSize];

   Component *pcComponent;

   BOOL bNonExist = FALSE;

   const PTSTR tszFunctionName = TEXT("CheckParentRelationship");

   // The child should always be valid
   // otherwise there is something seriously wrong in the code
   // I will add this checking code in anyway

   Relation *prChild;

   if (g_bMasterInf) {
      pclList->ResetList();
   
      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();
   
         pcComponent->GetChildrenList()->ResetList();
   
         while (!pcComponent->GetChildrenList()->Done()) {
   
            prChild = pcComponent->GetChildrenList()->GetNext();
            
            if (!pclList->LookupComponent(prChild->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s is parent of %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prChild->GetComponentId());
   
               LogError(tszMsg, SEV2, tszFunctionName);
   
               bNonExist = TRUE;
            }
         }
      }
   }
   
   
   // There should not be any cycles

   if (!bNonExist && g_bMasterInf) {

      pclList->ResetList();
   
      while (!pclList->Done()) {
   
         pcComponent = pclList->GetNext();
   
         CheckParentCycles(pcComponent, pclList);
      }
   }


   return TRUE;
}

/*++

   Routine Description:
   
      Routine that makes sure categorical component doesn't have a
      CopyFiles key
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file 
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckCopyFiles(IN HINF          hinfHandle, 
                    IN ComponentList *pclList)
{
   Component *pcComponent = NULL;

   BOOL bSuccess;

   INFCONTEXT infContext;

   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckCopyFiles");

   // A categorical component can't have a [CopyFiles] section

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers()) {

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       pcComponent->GetComponentId(),
                                       TEXT("CopyFiles"),
                                       &infContext);
         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("%s has subcomponent, and has copyfiles section"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks for suspicious keys in the component section
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckSuspicious(IN HINF          hinfHandle, 
                     IN ComponentList *pclList)
{
   // A categorical component can't have any code 
   // associated with it, which includes add registry
   // register services, etc.

   // Go through all the component that has subcomponent
   // read the lines in its section, looking for anything suspicious

   INFCONTEXT infContext;
   BOOL bSuccess;
   Component *pcComponent;

   TCHAR tszMsg[MaxStringSize];

   UINT uiNumLineCount;

   TCHAR tszTemp[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckSuspicious");

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers()) {
         // This component has children
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       pcComponent->GetComponentId(), 
                                       NULL, 
                                       &infContext);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to locate the component %s in Inf file"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
         uiNumLineCount = SetupGetLineCount(hinfHandle, 
                                            pcComponent->GetComponentId());
         if (uiNumLineCount < 1) {
            _stprintf(tszMsg, 
                      TEXT("%s has too few lines in its section"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         for (UINT i = 0; i < uiNumLineCount; i++) {
            // Go through each line 
            // see if there is something we don't know
            SetupGetStringField(&infContext, 
                                0, 
                                tszTemp, 
                                MaxBufferSize, 
                                NULL);

            // We only understand: OptionDesc, Tip, IconIndex, 
            // Parent, Needs, Excludes, SubCompInf, Modes
            if (_tcscmp(tszTemp, TEXT("OptionDesc")) != 0 &&
                _tcscmp(tszTemp, TEXT("Tip")) != 0 &&
                _tcscmp(tszTemp, TEXT("IconIndex")) != 0 &&
                _tcscmp(tszTemp, TEXT("Parent")) != 0 &&
                _tcscmp(tszTemp, TEXT("SubCompInf")) != 0 &&
                _tcscmp(tszTemp, TEXT("ExtraSetupFiles")) != 0) {

               // Hit something we don't understand
               _stprintf(tszMsg, 
                         TEXT("In section [%s], I don't understand key %s"),
                         pcComponent->GetComponentId(), 
                         tszTemp);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            SetupFindNextLine(&infContext, 
                              &infContext);
         }
      }
   }
   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks if there is any need relation cycles
      among components (not implemented)
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckNeedCycles(IN Component     *pcComponent, 
                     IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckNeedCycles");

   // We can't change the value of pclList,
   // or we will mess up the CheckNeedRelationship function

   RelationList *prlStack = new RelationList();

   RecursiveCheckNeedCycles(pcComponent, pclList, prlStack);

   delete prlStack;

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that is to be called recursively to determine if
      there is any cycles in the need relationship
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      RelationList *prlStack : A list of nodes that have been visited
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL RecursiveCheckNeedCycles(IN Component     *pcComponent,
                              IN ComponentList *pclList,
                              IN RelationList  *prlStack)
{
   Component *pcNeeded;

   const PTSTR tszFunctionName = TEXT("RecursiveCheckNeedCycles");

   Relation *prNeed = NULL;

   TCHAR tszMsg[MaxStringSize];

   pcComponent->GetNeedList()->ResetList();

   while (!pcComponent->GetNeedList()->Done()) {
      prNeed = pcComponent->GetNeedList()->GetNext();
      pcNeeded = pclList->LookupComponent(prNeed->GetComponentId());

      if (!pcNeeded) {
         _stprintf(tszMsg, 
                   TEXT("%s needs component %s, which is not in the list"),
                   pcComponent->GetComponentId(), 
                   prNeed->GetComponentId());

         LogError(tszMsg, SEV2, tszFunctionName);

         return TRUE;
      }

      // if pcNeeded is already in the stack,
      // state the error and returns
      // Otherwise add pcNeeded to the stack,
      // call CheckNeedCycles with pcNeeded and pclList

      prlStack->ResetList();

      while (!prlStack->Done()) {
         if (_tcscmp(prlStack->GetNext()->GetComponentId(), 
                     pcNeeded->GetComponentId()) == 0) {

            _stprintf(tszMsg, 
                      TEXT("need relation cycle exists starting from %s"), 
                      pcNeeded->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);
            return TRUE;
         }
      }

      prlStack->AddRelation(pcNeeded->GetComponentId());

      RecursiveCheckNeedCycles(pcNeeded, pclList, prlStack);
   }

   // Before returning from this function
   // pop out the node added into the stack

   pcComponent->GetNeedList()->ResetList();

   while (!pcComponent->GetNeedList()->Done()) {
      
      prNeed = pcComponent->GetNeedList()->GetNext();
      prlStack->RemoveRelation(prNeed->GetComponentId());
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if there is any parent relation cycles
      among components (not implemented)
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckParentCycles(IN Component     *pcComponent, 
                       IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckParentCycles");

   RelationList *prlStack = new RelationList();

   RecursiveCheckParentCycles(pcComponent, pclList, prlStack);

   delete prlStack;

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that is to be called recursively to determine if
      there is any cycles in the parent relationship
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      RelationList *prlStack : A list of nodes that have been visited
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL RecursiveCheckParentCycles(IN Component     *pcComponent,
                                IN ComponentList *pclList,
                                IN RelationList  *prlStack)
{

   Component *pcChild;

   const PTSTR tszFunctionName = TEXT("RecursiveCheckParentCycles");

   Relation *prChild = NULL;

   TCHAR tszMsg[MaxStringSize];

   pcComponent->GetChildrenList()->ResetList();

   while (!pcComponent->GetChildrenList()->Done()) {
      prChild = pcComponent->GetChildrenList()->GetNext();
      pcChild = pclList->LookupComponent(prChild->GetComponentId());

      if (!pcChild) {
         _stprintf(tszMsg, 
                   TEXT("%s has component %s as child, which is not in the list"),
                   pcComponent->GetComponentId(), 
                   prChild->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);
         return TRUE;
      }

      // if pcChild is already in the stack,
      // state the error and returns
      // Otherwise add pcChild to the stack,
      // call CheckNeedCycles with pcNeeded and pclList

      prlStack->ResetList();

      while (!prlStack->Done()) {
         if (_tcscmp(prlStack->GetNext()->GetComponentId(), 
                     pcChild->GetComponentId()) == 0) {
            _stprintf(tszMsg, 
                      TEXT("Parent relation cycle exists starting from %s"),
                      pcChild->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);
            return TRUE;
         }
      }

      prlStack->AddRelation(pcChild->GetComponentId());

      RecursiveCheckParentCycles(pcChild, pclList, prlStack);
   }

   pcComponent->GetChildrenList()->ResetList();

   while (!pcComponent->GetChildrenList()->Done()) {
      
      prChild = pcComponent->GetChildrenList()->GetNext();
      prlStack->RemoveRelation(prChild->GetComponentId());

   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if there are components with the same ID
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckSameId(IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckSameId");

   pclList->ResetList();

   Component *pcComponent;

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      pcComponent->IsThereSameId(pclList);
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if the top level components are the ones
      that are listed in the master INF file
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckTopLevelComponent(IN HINF          hinfHandle, 
                            IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckTopLevelComponent");

   Component *pcComponent;

   BOOL bSuccess;

   INFCONTEXT infContext;

   TCHAR tszMsg[MaxStringSize];

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsTopLevelComponent()) {
         // Check if this component exists in the [Components] section
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       tszComponents, 
                                       pcComponent->GetComponentId(),
                                       &infContext);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Component %s doesn't have a parent, but it is not listed in the [Components] section"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if every component has a description
      and tip, and that no two components have the same 
      description if they share a common parent
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckDescription(IN HINF          hinfHandle,
                      IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckDescription");

   Component *pcComponent;

   BOOL bSuccess;

   TCHAR tszMsg[MaxStringSize];

   INFCONTEXT infContext;

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      // We probably have to add two members to the class
      // but let's how this works out

      // Allocate a new structure for this node
      pcComponent->pDescAndTip = new DescAndTip;

      // Get the data from the inf file
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(), 
                                    TEXT("OptionDesc"), 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Unable to find OptionDesc for component %s"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
      else {
         bSuccess = SetupGetStringField(&infContext, 1, 
                                        pcComponent->pDescAndTip->tszDesc,
                                        MaxBufferSize, 
                                        NULL);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to read OptionDesc field of component %s"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         // Now see if it is a real description or a string
         if (pcComponent->pDescAndTip->tszDesc[0] == TEXT('%')) {
            bSuccess = SetupFindFirstLine(hinfHandle, 
                                          TEXT("Strings"),
                                          Strip(pcComponent->pDescAndTip->tszDesc),
                                          NULL);
            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Unable to find key %s in [Strings] section"),
                         pcComponent->pDescAndTip->tszDesc);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               bSuccess = SetupGetStringField(&infContext, 
                                              1, 
                                              pcComponent->pDescAndTip->tszDesc,
                                              MaxBufferSize, 
                                              NULL);
            }
         }
         else {
            // Do nothing
            
         }
      }

      // Now Get the tip stuff, it is basically the same as desc
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(), 
                                    TEXT("Tip"), 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Unable to find Tip key for component %s"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
      else {
         bSuccess = SetupGetStringField(&infContext, 1, 
                                        pcComponent->pDescAndTip->tszTip,
                                        MaxBufferSize, 
                                        NULL);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to read Tip field for component %s"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         // Now see if it is a real description or a string
         if (pcComponent->pDescAndTip->tszTip[0] == TEXT('%')) {
            bSuccess = SetupFindFirstLine(hinfHandle, 
                                          TEXT("Strings"),
                                          Strip(pcComponent->pDescAndTip->tszTip),
                                          NULL);
            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Unable to find key %s in [Strings] section"),
                         pcComponent->pDescAndTip->tszTip);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               bSuccess = SetupGetStringField(&infContext, 
                                              1, 
                                              pcComponent->pDescAndTip->tszTip,
                                              MaxBufferSize, 
                                              NULL);
            }
         }
         else {
            // Do nothing
            
         }
      }
   }

   // Now all the tip and desc thing is filled
   // Loop through the component, see if there are two components with 
   // the same description

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      pcComponent->IsThereSameDesc(pclList);
   }

   // Now go through the list and delete the field
   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();
      delete (pcComponent->pDescAndTip);
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks if every component has the correct mode value
      Toplevel component should not have Modes= line, and the modes value 
      should only be 0 through 3
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckModes(IN HINF          hinfHandle,
                IN ComponentList *pclList)
{
   // Go through each component, two things to check

   // a component with children should not have a mode line

   // the value of the fields should be between 0 and 3
   //SETUPMODE_MINIMAL = 0;
   //SETUPMODE_TYPICAL = 1;
   //SETUPMODE_LAPTOP  = 2;
   //SETUPMODE_CUSTOM  = 3;

   TCHAR tszMsg[MaxStringSize];
   INFCONTEXT infContext;
   BOOL bSuccess;

   UINT uiNumFields;

   const PTSTR tszFunctionName = TEXT("CheckModes");

   INT nMode;

   Component *pcComponent;

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(),
                                    TEXT("Modes"), 
                                    &infContext);
      if (bSuccess) {
         // Found the mode line
         // first check if this a component with children
         if (pcComponent->IsParentOfOthers()) {
            _stprintf(tszMsg, 
                      TEXT("%s has subcomponent, and has Modes = line"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
         else {
            // Check the validity of the fields
            uiNumFields = SetupGetFieldCount(&infContext);
            if (uiNumFields < 1 || uiNumFields > 4) {
               _stprintf(tszMsg, 
                         TEXT("Invalid number of fields in section [%s]"),
                         pcComponent->GetComponentId());
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            for (UINT i = 1; i <= uiNumFields; i++) {
               bSuccess = SetupGetIntField(&infContext, i, &nMode);
               if (!bSuccess) {
                  _stprintf(tszMsg, 
                            TEXT("Failed to get Mode value in section [%s]"),
                            pcComponent->GetComponentId());
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
               if (nMode < 0 || nMode > 3) {
                  _stprintf(tszMsg, 
                            TEXT("Invalid mode value %d in section [%s]"), 
                            nMode, 
                            pcComponent->GetComponentId());
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if the every INF file has a line
      LayoutFile = layout.inf  No file should ever use 
      [SourceDisksFiles] or [SourceDisksNames] section
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/


BOOL CheckLayoutFile(IN TCHAR tszSubINFName[MaxStringSize][MaxStringSize],
                     IN UINT  uiNumComponents,
                     IN TCHAR *tszDir)
{
   TCHAR tszMsg[MaxStringSize];

   BOOL bSuccess;

   HINF hinfHandle;

   INFCONTEXT infContext;

   UINT uiError;

   TCHAR tszLine[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckLayoutFile");

   // Now check the LayoutFile in each INF file

   for (UINT m = 0; m < uiNumComponents; m++) {
      if (tszSubINFName[m][0]) {
         _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszSubINFName[m]); 
         hinfHandle = SetupOpenInfFile(tszMsg, 
                                       NULL, 
                                       INF_STYLE_WIN4, 
                                       &uiError);

         // We assume the hinf handle is valid

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("Version"), 
                                       tszLayoutFile, 
                                       &infContext);

         if (!bSuccess) {

            _stprintf(tszMsg, 
                      TEXT("LayoutFile not found in file %s"), 
                      tszSubINFName[m]);

            LogError(tszMsg, SEV2, tszFunctionName);

            SetupCloseInfFile(hinfHandle);

            continue;

         }

         // Check if the value of the key is Layout.inf

         TCHAR tszLayoutFileName[MaxStringSize];

         bSuccess = SetupGetStringField(&infContext, 
                                        1, 
                                        tszLayoutFileName, 
                                        MaxBufferSize, 
                                        NULL);

         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Error reading the value of the %s in %s"), 
                      tszLayoutFile, 
                      tszSubINFName[m]);
         }
         if ( _tcsicmp(tszLayoutFileName, TEXT("Layout.inf")) != 0 ) {
            _stprintf(tszMsg, 
                      TEXT("The value of LayoutFile= %s in %s is invalid"),
                      tszLayoutFileName, 
                      tszSubINFName[m]);
         }

         if (!bSuccess || 
             _tcsicmp(tszLayoutFileName, TEXT("Layout.inf")) != 0 ) {

            LogError(tszMsg, SEV2, tszFunctionName);
         }

         // Now check that we should not have SourceDisksNames
         // or SourceDisksFiles sections
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("SourceDisksNames"), 
                                       NULL, 
                                       &infContext);

         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("[SourceDisksNames] section presents in %s"), 
                      tszSubINFName[m]);

            LogError(tszMsg, SEV2, tszFunctionName);

         }

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("SourceDisksFiles"), 
                                       NULL, 
                                       &infContext);

         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("[SourceDisksFiles] section presents in %s"), 
                      tszSubINFName[m]);
            LogError(tszMsg, SEV2, tszFunctionName);
         }

         SetupCloseInfFile(hinfHandle);

      }
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that logs an error depending on the ways some
      global variables are set
      
   Argument:
   
      TCHAR *tszMsg:          Error Message to log
      DWORD dwErrorLevel:     How serious the error is      
      TCHAR *tszFunctionName: the function name this error is detected
      
   Return Value:
   
      The return value is not used
      
--*/

VOID LogError(IN TCHAR *tszMsg, 
              IN DWORD dwErrorLevel,
              IN TCHAR *tszFunctionName)
{
   double fn = 1.00;

   if (g_bUseLog) {
      Log(fn, dwErrorLevel, tszMsg);
   }
   if (g_bUseMsgBox) {
      if (dwErrorLevel == INFO) {
         // We will not put up anything            
         
      }

      else {
         MessageBox(NULL, tszMsg, tszFunctionName, MB_ICONERROR | MB_OK);
      }
   }
   if (g_bUseConsole) {

      TCHAR tszContent[MaxStringSize];

      _tcscpy(tszContent, tszMsg);
      _tcscat(tszContent, TEXT("\n"));
      _ftprintf(stdout, tszContent);

   }

}

/*++

   Routine Description:
   
      Routine that gets rid of the first and last char of a string
      
   Argument:
   
      TCHAR *tszString:  Error Message to log
   
   Return Value:
   
      The return value is not used
      
--*/

TCHAR *Strip(TCHAR *tszString)
{
   TCHAR tszTemp[MaxStringSize];

   _tcscpy(tszTemp, (tszString+1));

   tszTemp[_tcslen(tszTemp)-1] = 0;

   _tcscpy(tszString, tszTemp);

   return tszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by octest.rc
//
#define IDD_WIZPAGE                     101
#define IDD_WIZWELCOME                  102
#define IDD_WIZMODE                     103
#define IDD_DIALOG1                     104
#define IDD_DIALOG2                     105
#define IDD_DIALOG3                     106
#define IDD_CHOOSERETURNANDAV           107
#define IDD_DIALOG4                     108
#define IDC_COMPONENT                   1001
#define IDC_PAGE                        1002
#define IDC_COUNT                       1003
#define IDC_TEST                        1004
#define IDC_MINIMAL                     1005
#define IDC_TYPICAL                     1006
#define IDC_CUSTOM                      1007
#define IDC_LAPTOP                      1008
#define IDC_STATIC_COMPONENT            1009
#define IDC_CURRENT_MODE                1010
#define IDC_SKIP_PAGES                  1011
#define IDC_FUNCTION                    1013
#define IDC_ANSI                        2000
#define IDC_UNICODE                     2001
#define IDC_ANSI_AND_UNICODE            2002
#define IDC_COMPONENT1                  2010
#define IDC_LESS                        3000
#define IDC_EQUAL                       3001
#define IDC_GREATER                     3002
#define IDC_DEFAULT                     4000
#define IDC_ON                          4001
#define IDC_OFF                         4002
#define IDC_ZERO                        6000
#define IDC_NEGONE                      6001
#define IDC_SEVEN                       6002
#define IDC_CAUSEAV                     7006
#define IDC_USE_OLDVALUE                7007
#define IDC_USE_NEWVALUE                7008
#define IDC_STATIC_APICALL              7010
#define IDC_STATIC_SUBCOMPONENT         7011
#define IDC_NEWVALUE                    7012
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\checkinf.h ===
#ifndef _CHECKINF_H_
#define _CHECKINF_H_

#include "Component.h"
#include <setupapi.h>

// Function prototype

BOOL CheckCopyFiles(IN HINF hinfHandle, 
                    IN ComponentList *pclList);

BOOL CheckExcludeRelationship(IN ComponentList *pclList);

BOOL CheckIconIndex(IN HINF hinfHandle, 
                    IN ComponentList *pclList);

BOOL CheckINF(IN TCHAR *tszDir, 
              IN TCHAR *tszFilename);

BOOL CheckNeedRelationship(IN ComponentList *pclList);

BOOL CheckParentRelationship(IN ComponentList *pclList);

BOOL CheckSuspicious(IN HINF hinfHandle, 
                     IN ComponentList *pclList);

BOOL FillList(IN OUT HINF hinfHandle, 
              IN OUT ComponentList *pclList, 
              IN     TCHAR *tszDir);

BOOL CheckNeedCycles(IN Component *pcComponent, 
                     IN ComponentList *pclList);

BOOL CheckParentCycles(IN Component *pcComponent, 
                       IN ComponentList *pclList);

BOOL CheckSameId(IN ComponentList *pclList);

BOOL CheckDescription(IN HINF hinfHandle,
                      IN ComponentList *pclList);

TCHAR *Strip(IN OUT TCHAR *tszString);

BOOL CheckModes(IN HINF hinfHandle,
                IN ComponentList *pclList);

BOOL CheckLayoutFile(IN TCHAR tszSubINFName[MaxStringSize][MaxStringSize],
                     IN UINT uiNumComponents,
                     IN TCHAR *tszDir);

BOOL RecursiveCheckNeedCycles(IN Component *pcComponent,
                              IN ComponentList *pclList,
                              IN RelationList *prlStack);


BOOL RecursiveCheckParentCycles(IN Component *pcComponent,
                                IN ComponentList *pclList,
                                IN RelationList *prlStack);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   utils.c

Abstract:

   Contains some functions used by all modules.
   

Author:

   Bogdan Andreiu (bogdana)  10-Feb-1997
   Jason Allor    (jasonall) 24-Feb-1998   (took over the project)

Revision History:

   10-Feb-1997   bogdana
     
     First draft: the greatest part of the functions
   
   20_Feb-1997   bogdana  
     
     Added three multistring processing functions
   
   19-Mar-1997   bogdana
     
    Added LogLine and modified LogOCFunction
   
   12-Apr-1997   bogdana
    
    Modified the multistring processing routines 
      
--*/

#include "octest.h"

/*++

Routine Description: (3.1)

   Logs information about the OC Function received from the OC Manager
   
Arguments:

   lpcvComponentId:    the name of the component (PVOID because it might be 
                                                  ANSI or Unicode)
   lpcvSubcomponentId: the subcomponent's name (NULL if none)
   uiFunction:         one of OC_XXX functions
   uiParam1:           the first param of the call
   pvParam2:           the second param of the call
   
Return Value:

   void

--*/
VOID LogOCFunction(IN  LPCVOID lpcvComponentId,
                   IN  LPCVOID lpcvSubcomponentId,
                   IN  UINT    uiFunction,
                   IN  UINT    uiParam1,
                   IN  PVOID   pvParam2) 
{
   double fn = 3.1;
   
   UINT  uiCount; 
   TCHAR tszMsg[MAX_MSG_LEN];
   WCHAR wszFromANSI[MAX_MSG_LEN];
   CHAR  cszFromUnicode[MAX_MSG_LEN];
   DWORD dwEndVariation;

   PSETUP_INIT_COMPONENT psicInitComp;
   SYSTEMTIME st;
   
   //
   // Don't log OC_PRIVATE_BASE calls. There are too many of them
   // and they just clutter up the log. Failures will still be logged.
   //
   if (uiFunction >= OC_PRIVATE_BASE) return;
   
   //
   // Display the current time. This is a way of checking if the 
   // notifications are received in the proper sequence.
   //
   GetLocalTime(&st);
   _stprintf (tszMsg, TEXT("[%02.2d:%02.2d:%02.2d] "),
              (INT)st.wHour, (INT)st.wMinute, (INT)st.wSecond);

   //
   // The second line contains the function and the return value
   //
   for (uiCount = 0; uiCount < MAX_OC_FUNCTIONS; uiCount++)
   {
      if (octFunctionNames[uiCount].uiOCFunction == uiFunction)
      {
         _stprintf(tszMsg, TEXT("%s %s"), 
                   tszMsg, octFunctionNames[uiCount].tszOCText); 
         break;
      }
   } 
   Log(fn, INFO, TEXT("-----------------------------------"));
   LogBlankLine();
   Log(fn, INFO, tszMsg);

   if (uiFunction != OC_PREINITIALIZE)
   {
      if (!lpcvComponentId || _tcscmp((PTSTR)lpcvComponentId, TEXT("")) == 0)
      {
         _stprintf(tszMsg, TEXT("Component = (null)   "));
      }
      else
      {
         _stprintf(tszMsg, TEXT("Component = %s   "), (PTSTR)lpcvComponentId);
      }
      if (!lpcvSubcomponentId || 
          _tcscmp((PTSTR)lpcvSubcomponentId, TEXT("")) == 0)
      {
         _stprintf(tszMsg, TEXT("%sSubcomponent = (null)"), tszMsg);
      }
      else
      {
         _stprintf(tszMsg, TEXT("%sSubcomponent = %s"), 
                           tszMsg, (PTSTR)lpcvSubcomponentId);
      }
   }
   else
   {
      //
      // The SubcomponentId should be the non-native version, 
      // if it is supported by the OC Manager
      //
      #ifdef UNICODE
      
      if (uiParam1 & OCFLAG_UNICODE)
      {
         //
         // The ComponentId is Unicode
         //
         if (uiParam1 & OCFLAG_ANSI)
         {
            //
            // The second param is ANSI, convert to Unicode for 
            // printing it
            //
            mbstowcs(wszFromANSI, 
                     (PCHAR)lpcvSubcomponentId, 
                     strlen((PCHAR)lpcvSubcomponentId));
         
            wszFromANSI[strlen((PCHAR)lpcvSubcomponentId)] = L'\0';
         }
         else
         {
            //
            //  Nothing to do if ANSI not supported
            //
            wszFromANSI[0] = TEXT('\0');
         }
         _stprintf(tszMsg, TEXT("Component = %s (Unicode) %s (ANSI)"), 
                           lpcvComponentId, wszFromANSI);
      }
      else
      {
         //
         // Only ANSI supported
         //
         mbstowcs(wszFromANSI, 
                  (PCHAR)lpcvComponentId, 
                  strlen((PCHAR)lpcvComponentId));
         
         wszFromANSI[strlen((PCHAR)lpcvSubcomponentId)] = L'\0';
         
         _stprintf(tszMsg, TEXT("Component = %s (ANSI only)"), wszFromANSI); 
      }

      #else
      
      //
      // ANSI
      //
      if (uiParam1 & OCFLAG_UNICODE)
      {
         //
         // The ComponentId is Unicode
         //
         wcstombs(cszFromUnicode, 
                  (PWCHAR)lpcvComponentId, 
                  wcslen((PWCHAR)lpcvComponentId));
         
         cszFromUnicode[wcslen((PWCHAR)lpcvComponentId)] = '\0';
         
         sprintf(tszMsg, "Component = %s (ANSI) %s (Unicode)", 
                        (PCHAR)lpcvSubcomponentId, cszFromUnicode);
      }
      else
      {

         sprintf(tszMsg, "Component = %s (ANSI only)", 
                         (PCHAR)lpcvSubcomponentId);
      }

      #endif
   }
   //
   // Log this first line of information
   //
   Log(fn, INFO, tszMsg);

   //
   // Check if the function is in range
   //
   __ASSERT(uiCount < MAX_OC_FUNCTION);

   //
   // Now we're ready to print the details
   //
   switch (uiFunction)
   {
      case OC_PREINITIALIZE:
         break;
      
      case OC_INIT_COMPONENT:
         //
         // We have a bunch of information to print here
         //
         psicInitComp = (PSETUP_INIT_COMPONENT)pvParam2;
         
         //
         // Assert that the Param2 is not NULL, we can dereference it
         //
         __ASSERT(psicInitComp != NULL);
         Log(fn, INFO, TEXT("OCManagerVersion = %d"),
                       psicInitComp->OCManagerVersion);
         Log(fn, INFO, TEXT("ComponentVersion = %d"), 
                       psicInitComp->ComponentVersion);

         //
         // The mode first
         //
         _tcscpy(tszMsg, TEXT("Mode "));
         switch (psicInitComp->SetupData.SetupMode)
         {
            case SETUPMODE_UNKNOWN:
               _tcscat(tszMsg, TEXT("Unknown"));
               break;
            case SETUPMODE_MINIMAL:
               _tcscat(tszMsg, TEXT("Minimal"));
               break;
            case SETUPMODE_TYPICAL:
               _tcscat(tszMsg, TEXT("Typical"));
               break;
            case SETUPMODE_LAPTOP:
               _tcscat(tszMsg, TEXT("Laptop"));
               break;
            case SETUPMODE_CUSTOM:
               _tcscat(tszMsg, TEXT("Custom"));
               break;
            default:  
               break;
         }

         //
         // ... then the product type
         //
         _tcscat(tszMsg, TEXT(" ProductType "));
         switch (psicInitComp->SetupData.ProductType)
         {
            case PRODUCT_WORKSTATION:
               _tcscat(tszMsg, TEXT("Workstation"));
               break;
            case PRODUCT_SERVER_PRIMARY:
               _tcscat(tszMsg, TEXT("Server Primary"));
               break;
            case PRODUCT_SERVER_STANDALONE:
               _tcscat(tszMsg, TEXT("Server Standalone"));
               break;
            case PRODUCT_SERVER_SECONDARY:
               _tcscat(tszMsg, TEXT("Server Secondary"));
               break;
            default:  
               break;
         }

         //
         // ... then the operation
         //
         _tcscat(tszMsg, TEXT(" Operation "));
         switch (psicInitComp->SetupData.OperationFlags)
         {
            case SETUPOP_WIN31UPGRADE:
               _tcscat(tszMsg, TEXT("Win 3.1"));
               break;
            case SETUPOP_WIN95UPGRADE:
               _tcscat(tszMsg, TEXT("Win95"));
               break;
            case SETUPOP_NTUPGRADE:
               _tcscat(tszMsg, TEXT("NT"));
               break;
            case SETUPOP_BATCH:
               _tcscat(tszMsg, TEXT("Batch"));
               break;
            case SETUPOP_STANDALONE:
               _tcscat(tszMsg, TEXT("Standalone"));
               break;
            default:  
               break;
         }

         Log(fn, INFO, tszMsg);
         
         ZeroMemory(tszMsg, MAX_MSG_LEN);
         if (psicInitComp->SetupData.SourcePath[0] != TEXT('\0'))
         {
            _stprintf(tszMsg, TEXT("Source Path = %s"),
                              psicInitComp->SetupData.SourcePath);
         }
         if (psicInitComp->SetupData.UnattendFile[0] != TEXT('\0'))
         {
            _stprintf(tszMsg, TEXT("%s, UnattendedFile = %s"),
                              tszMsg, psicInitComp->SetupData.UnattendFile);
         }
         break;

      case  OC_SET_LANGUAGE:
         Log(fn, INFO, TEXT("Primary = %d Secondary = %d"), 
                       PRIMARYLANGID((WORD)uiParam1), 
                       SUBLANGID((WORD)uiParam1));
         break;
      
      case  OC_QUERY_IMAGE:
         break;
      
      case  OC_REQUEST_PAGES:
         
         switch (uiParam1)
         {
            case  WizPagesWelcome:
               _tcscpy(tszMsg, TEXT("Welcome Pages "));
               break;
            case  WizPagesMode:
               _tcscpy(tszMsg, TEXT("Mode Pages"));
               break;
            case  WizPagesEarly:
               _tcscpy(tszMsg, TEXT("Early Pages"));
               break;
            case  WizPagesPrenet:
               _tcscpy(tszMsg, TEXT("Prenet Pages"));
               break;
            case  WizPagesPostnet:
               _tcscpy(tszMsg, TEXT("Postnet Pages"));
               break;
            case  WizPagesLate:
               _tcscpy(tszMsg, TEXT("Late Pages"));
               break;
            case  WizPagesFinal:
               _tcscpy(tszMsg, TEXT("Final Pages"));
               break;
            default:  
               break;
         }
         Log(fn, INFO, TEXT("Maximum %s = %d"), 
                       tszMsg, ((PSETUP_REQUEST_PAGES)pvParam2)->MaxPages);
         break;

      case OC_QUERY_CHANGE_SEL_STATE:
         Log(fn, INFO, TEXT("Component %s %s"), 
                       ((uiParam1 == 0)?TEXT("unselected"):TEXT("selected")),
                       (((INT)pvParam2 == OCQ_ACTUAL_SELECTION)?TEXT("Now"):TEXT("")));
         break;
      
      default:  
         break;
   }
   
   LogBlankLine();
   
   return;

} // LogOCFunction //




/*++

Routine Description:

   Check if a radio button is checked or not.

Arguments:

   hwndDialog - handle to the dialog box.

   CtrlId - the Control ID.

Return Value:

   TRUE if the button is checked, FALSE if not.

--*/
BOOL QueryButtonCheck(IN HWND hwndDlg,
                      IN INT  iCtrlID) 
{
   HWND  hwndCtrl = GetDlgItem(hwndDlg, iCtrlID);
   INT   iCheck   = (INT)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

   return (iCheck == BST_CHECKED);

} // QueryButtonCheck //




/*++

Routine Description:

   Prints the space required on each drive. 
   
Arguments:

   DiskSpace - the structure that describes the disk space required.
   
Return Value:

   None.

--*/
VOID PrintSpaceOnDrives(IN HDSKSPC DiskSpace)
{
   DWORD    dwRequiredSize, dwReturnBufferSize;
   PTCHAR   tszReturnBuffer, tszPointerToStringToFree;
   TCHAR    tszMsg[MAX_MSG_LEN];
   LONGLONG llSpaceRequired;

   SetupQueryDrivesInDiskSpaceList(DiskSpace, NULL, 0, &dwRequiredSize);
   dwReturnBufferSize = dwRequiredSize;

   __Malloc(&tszReturnBuffer, (dwReturnBufferSize * sizeof(TCHAR)));
   SetupQueryDrivesInDiskSpaceList(DiskSpace, 
                                   tszReturnBuffer, 
                                   dwReturnBufferSize, 
                                   &dwRequiredSize);
   
   //
   // We need to do this because we'll modify ReturnBuffer
   //
   tszPointerToStringToFree = tszReturnBuffer;
   if (GetLastError() == NO_ERROR)
   {
      //
      // Parse the ReturnBuffer
      //
      while (*tszReturnBuffer != TEXT('\0'))
      {
         SetupQuerySpaceRequiredOnDrive(DiskSpace, 
                                        tszReturnBuffer, 
                                        &llSpaceRequired, 
                                        0, 0);
         
         _stprintf(tszMsg, TEXT("Drive: %s Space required = %I64x, %I64d\n"), 
                           tszReturnBuffer, llSpaceRequired, llSpaceRequired);
         OutputDebugString(tszMsg);
         
         //
         // The next string is ahead
         //
         tszReturnBuffer += _tcslen(tszReturnBuffer) + 1;
      }

   }
   __Free(&tszPointerToStringToFree);
   return;

} // PrintSpaceOnDrives //


//
// Routines that deal with multistrings.
// All assume that the multistring is double NULL terminated
//


/*++

Routine Description:

   Converts a multistring to a string, by replacing the '\0' characters with
   blanks. Both strings should be properly allocated.
   
Arguments:

   MultiStr - supplies the multi string.

   Str - recieves the string.

Return Value:

   None.

--*/
VOID MultiStringToString(IN  PTSTR   tszMultiStr,
                         OUT PTSTR   tszStr)  
{
   PTSTR tszAux;

   __ASSERT((tszMultiStr != NULL) && (tszStr != NULL));

   tszAux = tszMultiStr;
   while (*tszAux != TEXT('\0'))
   {
      _tcscpy(tszStr, tszAux);
      
      //
      // Replace the '\0' with ' ' and terminate correctly Str
      //
      tszStr[tszAux - tszMultiStr + _tcslen(tszAux)] = TEXT(' ');
      tszStr[tszAux - tszMultiStr + _tcslen(tszAux) + 1] = TEXT('\0');
      tszAux += _tcslen(tszAux) + 1;
   }
   
   //
   // End properly Str (the last ' ' is useless)
   //
   tszStr[tszAux - tszMultiStr + _tcslen(tszAux)] = TEXT('\0');

   return;

} // MultiStringToString //




/*++

Routine Description:

   Calculates the size of a multi string (we can't use _tcslen). 
   Note that the size is in BYTES 
   
Arguments:

   tszMultiStr - the multi string.

Return Value:

   The length (in bytes) of the multi string.

--*/
INT MultiStringSize(IN PTSTR tszMultiStr)  
{
   PTSTR tszAux;   
   UINT  uiLength = 0;

   __ASSERT(tszMultiStr != NULL);

   tszAux = tszMultiStr;

   while (*tszAux != TEXT('\0'))
   {
      //
      // We should count the '\0' after the string
      //
      uiLength += _tcslen(tszAux) + 1;
      tszAux += _tcslen(tszAux) + 1;
   }
   
   //
   // We didn't count the ending '\0', so add it now
   //
   return ((uiLength + 1) * sizeof(TCHAR));

} // MultiStringSize //




/*++

Routine Description:

   Copies a multistring.

Arguments:

   tszMultiStrDestination: the destination multi string.
   tszMultiStrSource:      the source multi string.

Return Value:

   None.

--*/
VOID CopyMultiString(OUT PTSTR tszMultiStrDestination,
                     IN  PTSTR tszMultiStrSource)  
{
   UINT  uiCount = 0;
   PTSTR tszAuxS, tszAuxD;

   __ASSERT((tszMultiStrSource != NULL) && (tszMultiStrDestination != NULL));

   tszAuxS = tszMultiStrSource;
   tszAuxD = tszMultiStrDestination;

   //
   // Copies the multi string
   //
   while (*tszAuxS != TEXT('\0'))
   {
      _tcscpy(tszAuxD, tszAuxS);
      tszAuxD += _tcslen(tszAuxD) + 1;
      tszAuxS += _tcslen(tszAuxS) + 1;
   }
   //
   // Add the terminating NULL
   //
   *tszAuxD = TEXT('\0');

   return;

} // CopyMultiString //




/*++

Routine Description: InitGlobals

   Initializes global variables

Arguments:

    none

Return Value:

    void

--*/
VOID InitGlobals()
{
   g_bUsePrivateFunctions = FALSE;
   
   g_bFirstTime = TRUE;
   
   g_uiCurrentPage = 0;
   
   g_bAccessViolation = FALSE;
   
   g_bTestExtended = FALSE;
   
   nStepsFinal = NO_STEPS_FINAL;
   
   g_bNoWizPage = FALSE;
   
   g_bCrashUnicode = FALSE;
   
   g_bInvalidBitmap = FALSE;
   
   g_bHugeSize = FALSE;
   
   g_bCloseInf = FALSE;
   
   hInfGlobal = NULL;
   
   g_bNoNeedMedia = TRUE;

   g_bCleanReg = FALSE;

   g_uiFunctionToAV = 32574;

   g_bNoLangSupport = FALSE;

   g_bReboot = FALSE;
   
} // InitGlobals //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\hcttools.cpp ===
#include "..\hctlib\hcttools.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\component.h ===
#ifndef _COMPONENT_H_
#define _COMPONENT_H_

#include <iostream.h>
#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <tchar.h>
#include "logutils.h"
#include "hcttools.h"

const INT MaxStringSize = 256;
const INT MaxBufferSize = 255;      

// Global variables
static BOOL g_bUseLog;
static BOOL g_bUseMsgBox;
static BOOL g_bUseConsole;
static BOOL g_bMasterInf;

// Global function definitions

VOID LogError(IN TCHAR *tszMsg,
              IN DWORD dwErrorLevel,
              IN TCHAR *tszFunctionName);

// Some structures to hold temporary data

typedef struct _DescAndTip{
   TCHAR tszDesc[MaxStringSize];
   TCHAR tszTip[MaxStringSize];
}DescAndTip;
                        
class ComponentList;
class RelationList;

class Component{

private:
   // ComponentId is the real ID
   TCHAR tszComponentId[MaxStringSize];
   
   // ParentId is the ID of the its parent
   // It is the same as its own ID if it is a
   // top level component
   TCHAR tszParentId[MaxStringSize];

   RelationList *prlNeedList;
   RelationList *prlExcludeList;
   RelationList *prlChildrenList;

   Component *Next;

public:

   // Constructors and destructors
   Component();
   ~Component();
   Component(TCHAR *tszId);
   
   // Copy constructor
   Component(const Component& source);

   // Assignment operator
   const Component& operator=(const Component& source);

   // Get this component's ID
   TCHAR *GetComponentId(){
      return tszComponentId;
   }

   // Get this component's parent's ID
   TCHAR *GetParentId(){
      return tszParentId;
   }

   // Get a pointer to the parent component of this component
   // It returns NULL if this is a top-level component
   Component *GetParent(ComponentList *pclHead);
   
   RelationList *GetNeedList(){
      return prlNeedList;
   }

   RelationList *GetExcludeList(){
      return prlExcludeList;
   }

   RelationList *GetChildrenList(){
      return prlChildrenList;
   }

   // TRUE if this component is the parent of the parameter
   BOOL IsParent(Component *pcChild);

   // TRUE if this component is the child of the parameter
   BOOL IsChild(Component *pcParent);

   // TRUE if this component is needed by the parameter
   BOOL IsNeededBy(Component *pcComponent);

   // TRUE if this component is excluded by the parameter
   BOOL IsExcludeBy(Component *pcComponent);
   
   // The following function is to be called when only
   // the component ID is known
   BOOL BuildChildrenList(ComponentList *pclList);

   BOOL GetParentIdFromINF(HINF hinfHandle);

   BOOL IsTopLevelComponent();

   BOOL IsBottomComponent();

   BOOL IsNeededByOthers(ComponentList *pclList);

   BOOL IsExcludedByOthers(ComponentList *pclList);

   BOOL IsParentOfOthers();

   BOOL NeedAndExcludeAtSameTime(ComponentList *pclList);

   BOOL NeedOthers();
   BOOL ExcludeOthers();

   BOOL IsThereSameId(ComponentList *pclList);

   UINT GetDiskSpaceRequirement(HINF hinfHandle);

   // Doesn't matter if this is a public member
   // It will only be used once
   DescAndTip *pDescAndTip;

   BOOL IsThereSameDesc(ComponentList *pclList);

   BOOL HasSameParentWith(Component *pcComponent);

   friend class ComponentList;
};

class ComponentList{

private:

   Component *pcHead;   

   Component *pcCurrent;

public:

   // Constructor and destructor
   ComponentList();
   ~ComponentList();

   void ResetList();

   Component *GetNext();

   BOOL Done();

   Component* AddComponent(TCHAR *tszId);

   BOOL RemoveComponent(TCHAR *tszId);

   Component *LookupComponent(TCHAR *tszId);

   friend class Component;

};

class Relation{

   TCHAR tszComponentId[MaxStringSize];
   Relation *Next;

public:

   TCHAR *GetComponentId(){ 
      return tszComponentId;
   }
   friend class Component;
   friend class ComponentList;
   friend class RelationList;
};

class RelationList{

   Relation *prHead;
   Relation *prCurrent;

public:

   RelationList();
   ~RelationList();

   void ResetList();
   BOOL Done();
   Relation *GetNext();

   Relation* AddRelation(TCHAR *tszId);
   BOOL RemoveRelation(TCHAR *tszId);

   friend class Component;
   friend class ComponentList;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\component.cpp ===
#include "component.h"
#include <wchar.h>
#include <tchar.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

//////////////////////////////////////////////////////////////////
// Implementation of the Component Class
//////////////////////////////////////////////////////////////////     

// Constructor     
Component::Component(){
   
   tszComponentId[0] = 0;
   tszParentId[0] = 0;
   prlNeedList = new RelationList;
   prlExcludeList = new RelationList;
   prlChildrenList = new RelationList;

}

// Another constructor
Component::Component(TCHAR *tszId){
   _tcscpy(tszComponentId, tszId);
   tszParentId[0] = 0;
   prlNeedList = new RelationList;
   prlExcludeList = new RelationList;
   prlChildrenList = new RelationList;
}

// Destructor 
Component::~Component(){

   if (prlNeedList) {
      delete prlNeedList;
   }

   if (prlExcludeList) {
      delete prlExcludeList;
   }

   if (prlChildrenList) {
      delete prlChildrenList;
   }
}

// Copy constructor
Component::Component(const Component& source){

   _tcscpy(tszComponentId, source.tszComponentId);
   _tcscpy(tszParentId, source.tszParentId);

   prlNeedList = source.prlNeedList;
   prlExcludeList = source.prlExcludeList;
   prlChildrenList = source.prlChildrenList;

}

// Assignment operator
const Component& Component::operator=(const Component& source){

   _tcscpy(tszComponentId, source.tszComponentId);
   _tcscpy(tszComponentId, source.tszParentId);

   if (prlNeedList) {
      delete prlNeedList;
   }

   if (prlExcludeList) {
      delete prlExcludeList;
   }

   if (prlChildrenList) {
      delete prlChildrenList;
   }

   prlNeedList = source.prlNeedList;
   prlExcludeList = source.prlExcludeList;
   prlChildrenList = source.prlChildrenList;

   return *this;

}

// Find the parent of this component
// by searching a component list
Component* Component::GetParent(ComponentList *pclHead){

   Component *pcTemp = pclHead->pcCurrent;

   pclHead->ResetList();

   while (!pclHead->Done()) {

	  if (pclHead->GetNext()->IsParent(this)){
		  
		  pclHead->pcCurrent = pcTemp;
		  return (pclHead->GetNext());
	  }
   }

   pclHead->pcCurrent = pcTemp;

   return NULL;
}

// If this component is the parent of the parameter
BOOL Component::IsParent(Component* pcChild){

   if (_tcscmp(pcChild->tszParentId, this->tszComponentId) == 0) {
      if (_tcscmp(pcChild->tszComponentId, pcChild->tszParentId) == 0) {
         
         // the parameter is a top-level component
         
         return FALSE;
      }
      return TRUE;
   }

   return FALSE;
}


// If this component is the child of the parameter
BOOL Component::IsChild(Component* pcParent){

   if (_tcscmp(this->tszParentId, pcParent->tszComponentId) == 0) {
      if (_tcscmp(this->tszParentId, this->tszComponentId) == 0 ) {

         // This is a top-level component

         return FALSE;
      }
      return TRUE;
   }

   return FALSE;
}

// Check if this component is needed by the parameter
BOOL Component::IsNeededBy(Component *pcComponent){

   pcComponent->prlNeedList->ResetList();

   while (!pcComponent->prlNeedList->Done()) {

      if (_tcscmp(pcComponent->prlNeedList->GetNext()->tszComponentId, 
                  this->tszComponentId) == 0){
         return TRUE;
      }
   }

   return FALSE;
}

// Check if this component is excluded by the parameter
BOOL Component::IsExcludeBy(Component *pcComponent){

   pcComponent->prlExcludeList->ResetList();

   while (!pcComponent->prlExcludeList->Done()) {

      if (_tcscmp(pcComponent->prlNeedList->GetNext()->tszComponentId, 
                  this->tszComponentId) == 0) {
         return TRUE;
      }
   }

   return FALSE;
}

// Get this component's parent id from INF file
BOOL Component::GetParentIdFromINF(HINF hinfHandle){

   INFCONTEXT infContext;

   BOOL bSuccess;

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszComponentId, 
                                 TEXT("Parent"), 
                                 &infContext);

   if (bSuccess) {
      // Find the line
      bSuccess = SetupGetStringField(&infContext, 
                                     1, 
                                     tszParentId, 
                                     MaxBufferSize, 
                                     NULL);
      if (bSuccess) {
         return TRUE;
      }
      else{
         MessageBox(NULL, 
                    TEXT("Unexpected error happened"), 
                    TEXT("GetParentIdFromINF"), 
                    MB_ICONERROR | MB_OK);

         return FALSE;
      }
   }
   else{
      // This is a top-level component
      _tcscpy(tszParentId, tszComponentId);
      return TRUE;
   }
}

// Check if this component is a toplevel compoent
// Toplevel component means no parent
BOOL Component::IsTopLevelComponent(){
   if (_tcscmp(tszComponentId, tszParentId) == 0) {
      return TRUE;
   }
   return FALSE;
}

// Check if this component is a bottomlevel component
// bottom level component doesn't have any child
BOOL Component::IsBottomComponent(){
   if (prlChildrenList == NULL ||
       prlChildrenList->prHead == NULL) {
      return TRUE;
   }

   return FALSE;
}

// Check if this component is needed by others
BOOL Component::IsNeededByOthers(ComponentList *pclList){
   Component *pcTemp = pclList->pcCurrent;

   pclList->ResetList();
   while (!pclList->Done()) {
      if (IsNeededBy(pclList->GetNext())){
		  pclList->pcCurrent = pcTemp;	
		  return TRUE;
      }
   }

   pclList->pcCurrent = pcTemp;

   return FALSE;
}

// Check if this component is excluded by others
BOOL Component::IsExcludedByOthers(ComponentList *pclList){

   Component *pcTemp = pclList->pcCurrent;
   
   pclList->ResetList();
   while (!pclList->Done()) {
      if (IsExcludeBy(pclList->GetNext())){
          pclList->pcCurrent = pcTemp;
		  return TRUE;
      }
   }

   pclList->pcCurrent = pcTemp;

   return FALSE;
}

// Check if this component is parent of other components
BOOL Component::IsParentOfOthers(){
   if (prlChildrenList != NULL &&
       prlChildrenList->prHead != NULL) {
      return TRUE;
   }

   return FALSE;
}

// Build the children list for this component
BOOL Component::BuildChildrenList(ComponentList *pclList){
   // We can't use the enumerate facility of pclList here
   
   Component *pcComponent = pclList->pcHead;

   while (pcComponent) {
      if (IsParent(pcComponent)) {
         if (!prlChildrenList) {
            prlChildrenList = new RelationList;
         }
         prlChildrenList->AddRelation(pcComponent->tszComponentId);
      }
      pcComponent = pcComponent->Next;
   }

   return TRUE;

}

// Check if this component has a need and exclude relation with other
// component at the same time
BOOL Component::NeedAndExcludeAtSameTime(ComponentList *pclList){
	
	TCHAR tszMsg[MaxStringSize];

	Component *pcComponent;
                                 
   const PTSTR tszFunctionName = TEXT("Component::NeedAndExcludeAtSameTime");

	// Go through the list of component it excludes
	// check if any of them needs this one

	prlExcludeList->ResetList();

	while (!prlExcludeList->Done()){
		
		pcComponent = pclList->LookupComponent(prlExcludeList->GetNext()->GetComponentId());

		// Check if this needs pcComponent
		
		if (pcComponent->IsNeededBy(this)){
			_stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   this->tszComponentId);
         LogError(tszMsg, SEV2, tszFunctionName);

		   return TRUE;
      }

		// Check if pcComponent needs this

		if (this->IsNeededBy(pcComponent)){
			_stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   this->tszComponentId);
         LogError(tszMsg, SEV2, tszFunctionName);

		   return TRUE;
      }
	}

	return FALSE;
}

// Check if this component needs other components
BOOL Component::NeedOthers(){
   
   if (prlNeedList != NULL && prlNeedList->prHead != NULL) {
      
      return TRUE;
   }
   return FALSE;
}

// Check if this component excludes other components
BOOL Component::ExcludeOthers(){
   
   if (prlExcludeList != NULL && prlExcludeList->prHead != NULL) {
      
      return TRUE;
   
   }
   
   return FALSE;   
}

// Check if there is another component with the same
// id as this component
BOOL Component::IsThereSameId(ComponentList *pclList){

   Component *pcCur;
   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("Component::IsThereSameId");

   pcCur = pclList->pcHead;

   while (pcCur) {
      if (pcCur != this) {
         if (_tcscmp(pcCur->tszComponentId, this->tszComponentId) == 0) {
            _stprintf(tszMsg, 
                      TEXT("There are two component with the same ID %s"), 
                      this->tszComponentId);
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
      pcCur = pcCur->Next;
   }

	return TRUE;
}

// Not implemented yet
UINT Component::GetDiskSpaceRequirement(HINF hinfHandle){

   // Not implemented yet.

   return 0;
}

// Check if this another component with the same description
BOOL Component::IsThereSameDesc(ComponentList *pclList){

   const PTSTR tszFunctionName = TEXT("Component::IsThereSameDesc");

   TCHAR tszMsg[MaxStringSize];

   Component *pcCur = pclList->pcHead;

   while (pcCur) {
      if (pcCur != this) {
         if (_tcscmp(pcCur->pDescAndTip->tszDesc, 
                     this->pDescAndTip->tszDesc) == 0) {
            if ((this->IsTopLevelComponent() && 
                 pcCur->IsTopLevelComponent()) ||
                this->HasSameParentWith(pcCur)) {

               // ahha, found one
               _stprintf(tszMsg, 
                         TEXT("Two components with the same description %s"),
                         pDescAndTip->tszDesc);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
      }
      pcCur = pcCur->Next;
   }

   return TRUE;
}

// Check if this component has the same parent as the parameter
BOOL Component::HasSameParentWith(Component *pcComponent){
   if (_tcscmp(tszParentId, pcComponent->tszParentId) == 0) {
      return TRUE;
   }
   else{
      return FALSE;
   }
}

/////////////////////////////////////////////////////////////////////
// Implementation of the ComponentList class
/////////////////////////////////////////////////////////////////////

// Constructor
ComponentList::ComponentList(){

   pcHead = NULL;

   pcCurrent = NULL;
}

// destructor
ComponentList::~ComponentList(){

   // Go through the list and delete each component

   Component *pcComponent;

   if (pcHead == NULL) {
      // Empty list
      return;
   }

   while(pcHead != NULL){
  
      pcComponent = pcHead->Next;

      delete pcHead;

      pcHead = pcComponent;

   }   
}

// List iteration facility
// reset the iterator
void ComponentList::ResetList(){

    pcCurrent = pcHead;
}

// Check if the iterator has reached the end
BOOL ComponentList::Done(){

   return (pcCurrent == NULL);
}

// Get the next node in the list
Component* ComponentList::GetNext(){

   Component *pcReturn;
   pcReturn = pcCurrent;
 
   if (pcCurrent != NULL) {
      pcCurrent = pcReturn->Next;
      return pcReturn;
   }

   else{
      MessageBox(NULL, 
                 TEXT("Something is seriously wrong"), 
                 TEXT("ComponentList.GetNext()"), 
                 MB_ICONERROR | MB_OK);

      return NULL;
   }
}
 
// Add a component into the list
Component* ComponentList::AddComponent(TCHAR *tszId){

   if (tszId == NULL) {
      return NULL;
   }

   Component *pcNewComponent = new Component(tszId);

   if (!pcHead) {
      pcHead = pcNewComponent;
      pcNewComponent->Next = NULL;
      return pcNewComponent;
   }

   pcNewComponent->Next = pcHead;
   pcHead = pcNewComponent;
   return pcNewComponent;
}

// Remove a component from the list according to the id given
BOOL ComponentList::RemoveComponent(TCHAR *tszId){
   if (tszId == NULL) {
      return NULL;
   }

   // Find the component in the list
   Component *pcPrev = pcHead;
   Component *pcCur = pcHead;

   while (pcCur) {
      if (_tcscmp(pcCur->tszComponentId, tszId) == 0) {
         // Found the node to delete
         pcPrev->Next = pcCur->Next;
         delete pcCur;
         return TRUE;
      }
      pcPrev = pcCur;
      pcCur = pcCur->Next;
   }
   return FALSE;
}

// Find a component from the list
Component* ComponentList::LookupComponent(TCHAR *tszId){
   if (tszId == NULL) {
      return NULL;
   }

   Component *pcCur = pcHead;

   while (pcCur) {
      if (_tcscmp(pcCur->tszComponentId, tszId) == 0) {
         return pcCur;
      }
      pcCur = pcCur->Next;
   }

   return NULL;
}

//////////////////////////////////////////////////////////////////////
// Implementation of RelationList
//////////////////////////////////////////////////////////////////////

// Constructor
RelationList::RelationList(){

   prHead = NULL;
   prCurrent = NULL;
}

// destructor
RelationList::~RelationList(){

   // deallocate all the memory

   Relation *prNext;

   if (prHead == NULL) {
      // The list is empty
      return;

   }

   while (prNext = prHead->Next) {
      delete prHead;
      prHead = prNext;
   }
}

// List iteration facility
// reset the iterator
void RelationList::ResetList(){
   prCurrent = prHead;
}

// Check if the iterator has reached the end of the list
BOOL RelationList::Done(){
   if (prCurrent == NULL) {
      return TRUE;
   }
   else{
      return FALSE;
   }
}

// Get the next node in the list
Relation* RelationList::GetNext(){
   Relation *prReturn = prCurrent;

   if (prCurrent != NULL) {
      prCurrent = prCurrent->Next;
      return prReturn;
   }
   else{
      MessageBox(NULL, 
                 TEXT("Something is seriously wrong"), 
                 TEXT("RelationList::GetNext()"), 
                 MB_ICONERROR | MB_OK);

      return NULL;
   }
   
}

// Add a node to the list
Relation* RelationList::AddRelation(TCHAR *tszId){
   Relation *newRelation = new Relation;

   _tcscpy(newRelation->tszComponentId, tszId);

   if (!prHead) {
      prHead = newRelation;
      newRelation->Next = NULL;
      return newRelation;
   }

   newRelation->Next = prHead;

   prHead = newRelation;

   return newRelation;
}

// Remove a node from the list
BOOL RelationList::RemoveRelation(TCHAR *tszId){
   // First find the node from the list
   Relation *prPrev = prHead;   
   prCurrent = prHead;

   while (prCurrent) {
      if (_tcscmp(prCurrent->tszComponentId, tszId) == 0) {
         prPrev->Next = prCurrent->Next;
         delete prCurrent;
         return TRUE;
      }
      prPrev = prCurrent;
      prCurrent = prCurrent->Next;
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\logutils.cpp ===
#include "..\hctlib\logutils.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\hcttools.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    hcttools.c

Abstract:

    This module contains helpful functions and wrappers for debugging and
    tools commonly used throughout hct programs.

Environment:

    User mode

Revision History:

    05-Sep-1997 : Jason Allor (jasonall)

--*/
#include "hcttools.h"

#ifdef DEBUG

static PBLOCKINFO g_pbiHead;

static USHORT g_usMalloc;
static USHORT g_usFree;

#endif

/*++

Routine Description: InitializeMemoryManager

    Initializes globals used by this module

Arguments:

    none

Return Value:

    VOID

--*/
VOID InitializeMemoryManager()
{
#ifdef DEBUG

   g_pbiHead  = NULL;
   g_usMalloc = 0;
   g_usFree   = 0;

#else

   return;
   
#endif

} // InitializeMemoryManager //



#ifdef DEBUG

/*++

Routine Description: GetBlockInfo

    Searches the memory log to find the block that pb points into and
    returns a pointer to the corresponding blockinfo structure of the
    memory log. Note: pb must point into an allocated block or you
    will get an assertion failure. The function either asserts or
    succeeds -- it never returns an error.

Arguments:

    pb: block to get info about

Return Value:

    BLOCKINFO: returns the information

--*/
static PBLOCKINFO GetBlockInfo(IN PBYTE pb)
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      PBYTE pbStart = pbi->pb;
      PBYTE pbEnd   = pbi->pb + pbi->size - 1;

      if (PtrGrtrEq(pb, pbStart) && PtrLessEq(pb, pbEnd))
      {
         break;
      }
   }

   //
   // Couldn't find pointer? It is garbage, pointing to a block that was
   // freed, or pointing to a block that moved when it was resized?
   //
   __ASSERT(pbi != NULL);

   return (pbi);

} // GetBlockInfo //




/*++

Routine Description: CreateBlockInfo

    Creates a log entry for the memory block defined by pbNew:sizeNew.

Arguments:

    pbNew:   new block
    sizeNew: the size of the new block
    cszFile: the file name the code is located in \ these tell what code
    iLine:   the line number of the assertion     / called the malloc

Return Value:

    BOOL: TRUE if it successfully creates the log information,
          FALSE otherwise

--*/
BOOL CreateBlockInfo(OUT PBYTE  pbNew,
                     IN  size_t sizeNew,
                     IN  PCHAR  cszFile,
                     IN  UINT   iLine)
{
   PBLOCKINFO pbi;

   __ASSERT(pbNew != NULL && sizeNew != 0);

   pbi = (PBLOCKINFO)malloc(sizeof(BLOCKINFO));
   if (pbi != NULL)
   {
      pbi->pb = pbNew;
      pbi->size = sizeNew;
      pbi->pbiNext = g_pbiHead;
      pbi->iLine = iLine;
      strcpy(pbi->cszFile, cszFile);
      g_pbiHead = pbi;
   }

   return (pbi != NULL);

} // CreateBlockInfo //




/*++

Routine Description: FreeBlockInfo

    Destroys the log entry for the memory block that pbToFree
    points to. pbToFree must point to the start of an allocated
    block or you will get an assertion failure

Arguments:

    pbToFree: the block to free

Return Value:

    void

--*/
void FreeBlockInfo(IN PBYTE pbToFree)
{
   PBLOCKINFO pbi, pbiPrev;

   pbiPrev = NULL;
   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      if (PtrEqual(pbi->pb, pbToFree))
      {
         if (pbiPrev == NULL)
         {
            g_pbiHead = pbi->pbiNext;
         }
         else
         {
            pbiPrev->pbiNext = pbi->pbiNext;
         }
         break;
      }
      pbiPrev = pbi;
   }

   //
   // If pbi is NULL, the pbToFree is invalid
   //
   __ASSERT(pbi != NULL);

   //
   // Destroy the contents of *pbi before freeing them
   //
   memset(pbi, GARBAGE, sizeof(BLOCKINFO));

   free(pbi);

} // FreeBlockInfo //




/*++

Routine Description: UpdateBlockInfo

    UpdateBlockInfo looks up the log information for the memory
    block that pbOld points to. The function then updates the log
    information to reflect the fact that the block new lives at pbNew
    and is "sizeNew" bytes long. pbOld must point to the start of an
    allocated block or you will get an assertion failure

Arguments:

    pbOld:   old location
    pbNew:   new location
    sizeNew: the new size

Return Value:

    void

--*/
void UpdateBlockInfo(IN PBYTE  pbOld,
                     IN PBYTE  pbNew,
                     IN size_t sizeNew)
{
   PBLOCKINFO pbi;

   __ASSERT(pbNew != NULL && sizeNew);

   pbi = GetBlockInfo(pbOld);
   __ASSERT(pbOld == pbi->pb);

   pbi->pb   = pbNew;
   pbi->size = sizeNew;

} // UpdateBlockInfo //




/*++

Routine Description: SizeOfBlock

    Returns the size of the block that pb points to. pb must point to
    the start of an allocated block or you will get an assertion failure

Arguments:

    pb: the block to find the size of

Return Value:

    size_t: returns the size

--*/
size_t SizeOfBlock(IN PBYTE pb)
{
   PBLOCKINFO pbi;

   pbi = GetBlockInfo(pb);
   __ASSERT(pb == pbi->pb);

   return (pbi->size);
   return 1;
   
} // SizeOfBlock //




/*++

Routine Description: ClearMemoryRefs

    ClearMemoryRefs marks all blocks in the memory log as
    being unreferenced

Arguments:

    void

Return Value:

    void

--*/
void ClearMemoryRefs()
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      pbi->boolReferenced = FALSE;
   }

} // ClearMemoryRefs //




/*++

Routine Description: NoteMemoryRef

    Marks the block that pv points into as being referenced.
    Note: pv does not have to point to the start of a block; it may
    point anywhere withing an allocated block

Arguments:

    pv: the block to mark

Return Value:

    void

--*/
void NoteMemoryRef(IN PVOID pv)
{
   PBLOCKINFO pbi;

   pbi = GetBlockInfo((PBYTE)pv);
   pbi->boolReferenced = TRUE;

} // NoteMemoryRef //




/*++

Routine Description: CheckMemoryRefs

    Scans the memory log looking for blocks that have not been
    marked with a call to NoteMemoryRef. It this function finds an
    unmarked block, it asserts.

Arguments:

    void

Return Value:

    void

--*/
void CheckMemoryRefs()
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      //
      // A simple check for block integrity. If this assert fires, it
      // means that something is wrong with the debug code that manages
      // blockinfo or, possibly, that a wild memory store has thrashed
      // the data structure. Either way, there's a bug
      //
      __ASSERT(pbi->pb != NULL && pbi->size);

      //
      // A check for lost or leaky memory. If this assert fires, it means
      // that the app has either lost track of this block or that not all
      // global pointers have been accounted for with NoteMemoryRef.
      //
      __ASSERT(pbi->boolReferenced);
   }

} // CheckMemoryRefs //




/*++

Routine Description: ValidPointer

    Verifies that pv points into an allocated memory block and that there
    are at least "size" allocated bytes from pv to the end of a block. If
    either condition is not met, ValidPointer will assert.

Arguments:

    pv:   the block to check out
    size: the size to match against

Return Value:

    BOOL: Always returns TRUE.

    The reason this always returns TRUE is to allow you to call the
    function within an __ASSERT macro. While this isn't the most efficient
    method to use, using the macro neatly handles the debug-vs-ship
    version control issue without your having to resort to #ifdef
    DEBUGS or to introducing other __ASSERT-like macros.

--*/
BOOL ValidPointer(IN PVOID  pv,
                  IN size_t size)
{
   PBLOCKINFO pbi;
   PBYTE      pb = (PBYTE)pv;

   __ASSERT(pv != NULL && size);

   pbi = GetBlockInfo(pb);

   //
   // size isn't valid if pb+size overflows the block
   //
   __ASSERT(PtrLessEq(pb + size, pbi->pb + pbi->size));

   return TRUE;

} // ValidPointer //




/*++

Routine Description: _Assert

    My assert function. Simply outputs the file name and line number
    to a MessageBox and then kills the program. Note: this should only
    be called by the __ASSERT macro above

Arguments:

    cszFile: the file name the code is located in
    iLine:   the line number of the assertion

Return Value:

     void

--*/
void MyAssert(IN PCHAR cszFile,
              IN UINT  iLine)
{
   WCHAR wszFile[100];
   TCHAR tszMessage[100];
   
   fflush(NULL);

   _stprintf(tszMessage, TEXT("Assertion failed: %s, line %u"),
                         ConvertAnsi(cszFile, wszFile, 100), iLine);
   MessageBox(NULL, tszMessage, NULL, MB_OK);
   
   abort();

} // MyAssert //

#endif  // DEBUG




/*++

Routine Description: __MALLOC

    Don't call this function. Instead, call the macro MyMalloc, 
    which calls this function. 
    
    Wrapper for malloc function. Provides better calling convention
    and debug syntax. Calling example:

    malloc:   pbBlock = (byte *)malloc(sizeof(pbBlock));
    MyMalloc: MyMalloc(&pbBlock, sizeof(pbBlock));

Arguments:

    ppv:    variable to be malloced
    size:   the memory size to use
    cszFile: the file name the code is located in  \ these tell what code
    iLine:   the line number of the assertion      / called the malloc

Return Value:

    BOOL: TRUE if malloc succeeds, FALSE if it does not

--*/
BOOL __MALLOC(IN OUT void   **ppv,
              IN     size_t size,
              IN     PCHAR  cszFile,
              IN     UINT   iLine)
{
   BYTE **ppb = (BYTE **)ppv;

   __ASSERT(ppv != NULL && size != 0);

   *ppb = (BYTE *)malloc(size);

   #ifdef DEBUG
   g_usMalloc++;
   
   if (*ppb != NULL)
   {
      //
      // Shred the memory
      //
      memset(*ppb, GARBAGE, size);

      //
      // Record information about this block in memory
      //
      if (!CreateBlockInfo(*ppb, size, cszFile, iLine))
      {                
         free(*ppb);
         *ppb = NULL;
      }
   }
   #endif

   return (*ppb != NULL);

} // __MALLOC //




/*++

Routine Description: __FREE

    Wrapper for free function. Provides debug syntax.
    Sets the pointer to NULL after it is done freeing it.
    This should always be called in a format such as:
    
    Old syntax: free(pVariable);
    New syntax: MyFree(&pVariable);

Arguments:

    ppv:  variable to be freed

Return Value:

    void

--*/
void __FREE(IN void **ppv)
{
   //
   // *ppv should never be NULL. This is technically legal
   // but it's not good behavior
   //
   __ASSERT (*ppv != NULL);

   #ifdef DEBUG
   g_usFree++;
   
   //
   // Shred the memory
   //
   memset(*ppv, GARBAGE, SizeOfBlock(*ppv));
   FreeBlockInfo(*ppv);
   #endif

   free(*ppv);
   *ppv = NULL;
   
} // __FREE //




/*++

Routine Description: CheckAllocs

    Checks to make sure that everything has been freed. This
    should be called right before the program ends.

Arguments:

    none
    
Return Value:

    VOID: If this function finds any allocated memory that
    has not been freed, it will __ASSERT.

--*/
VOID CheckAllocs()
{
   #ifndef DEBUG
   
   return;
   
   #else
   
   PBLOCKINFO pbi;
   TCHAR      tszInvalidMemoryLocations[10000];
   USHORT     usCounter = 0;
   BOOL       bBadMemFound = FALSE;
   WCHAR      wszUnicode[100];
   
   _stprintf(tszInvalidMemoryLocations, 
             TEXT("Unfreed Malloc Locations: \n\n"));
   
   _stprintf(tszInvalidMemoryLocations, 
             TEXT("%sMallocs = %d Frees = %d\n\n"),
             tszInvalidMemoryLocations, g_usMalloc, g_usFree);
   
   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      bBadMemFound = TRUE;
      
      //
      // Only print out the first 20 unfreed blocks we
      // find, so the messagebox won't be too huge
      //
      if (usCounter++ < 20)
      {
         _stprintf(tszInvalidMemoryLocations,
                   TEXT("%sFile = %s \t Line = %d\n"),
                   tszInvalidMemoryLocations,
                   ConvertAnsi(pbi->cszFile, wszUnicode, 100),
                   pbi->iLine);
      }
   }
   
   if (bBadMemFound)
   {
      MessageBox(NULL, tszInvalidMemoryLocations, NULL, 
                 MB_OK | MB_ICONERROR);
                 
      __ASSERT(TRUE);
   }
   
   #endif
   
} // CheckAllocs //




/*++

Routine Description: StrNCmp

    Compares two TCHAR strings. Both strings length must be >= ulLength

Arguments:

    tszString1: the first string
    tszString2: the second string
    ulLength:  the length to compare

Return Value:

    BOOL: TRUE if strings are equal, FALSE if not

--*/
BOOL StrNCmp(IN PTCHAR tszString1,
             IN PTCHAR tszString2,
             IN ULONG  ulLength)
{
   ULONG ulIndex;

   //
   // Both strings must be valid and ulLength must be > 0
   //
   __ASSERT(tszString1 != NULL);
   __ASSERT(tszString2 != NULL);
   __ASSERT(ulLength > 0);
   
   if (_tcslen(tszString1) < ulLength ||
       _tcslen(tszString2) < ulLength)
   {
      goto RetFALSE;
   }
   
   for (ulIndex = 0; ulIndex < ulLength; ulIndex++)
   {
      if (tszString1[ulIndex] != tszString2[ulIndex])
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} // StrNCmp //




/*++

Routine Description: StrCmp

    Compares two TCHAR strings

Arguments:

    tszString1: the first string
    tszString2: the second string

Return Value:

    BOOL: TRUE if strings are equal, FALSE if not

--*/
BOOL StrCmp(IN PTCHAR tszString1,
            IN PTCHAR tszString2)
{
   ULONG ulIndex;
   ULONG ulLength;
   
   //
   // Both strings must be valid
   //
   __ASSERT(tszString1 != NULL);
   __ASSERT(tszString2 != NULL);
   
   ulLength = _tcslen(tszString1);
   
   if (ulLength != _tcslen(tszString2))
   {
      goto RetFALSE;
   }
   
   for (ulIndex = 0; ulIndex < ulLength; ulIndex++)
   {
      if (tszString1[ulIndex] != tszString2[ulIndex])
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} // StrCmp //


        

/*++

Routine Description: AnsiToUnicode

    Converts an Ansi string to a Unicode string.
    
Arguments:

    cszAnsi:    the Ansi string to convert
    wszUnicode: unicode buffer to store new string. Must not be NULL    
    ulSize:     must be set to the size of the wszUnicode buffer
    
Return Value:

    PWCHAR: returns the wszUnicode buffer

--*/
PWCHAR AnsiToUnicode(IN  PCHAR  cszAnsi,
                     OUT PWCHAR wszUnicode,
                     IN  ULONG  ulSize)
{                     
   USHORT i;
   USHORT usAnsiLength;
   CHAR   cszTemp[2000];
   CHAR   cszTemp2[2000];
   
   //
   // Clear out the new Unicode string
   //
   ZeroMemory(wszUnicode, ulSize);
   
   //
   // Record the length of the original Ansi string
   //
   usAnsiLength = strlen(cszAnsi);
   
   //
   // Copy the unicode string to a temporary buffer
   //
   strcpy(cszTemp, cszAnsi);
   
   for (i = 0; i < usAnsiLength && i < ulSize - 1; i++)
   {
      //
      // Copy the current character
      //
      wszUnicode[i] = (WCHAR)cszTemp[i];
   }
   
   wszUnicode[i] = '\0';
   return wszUnicode;
   
} // AnsiToUnicode //




/*++

Routine Description: UnicodeToAnsi

    Converts a Unicode string to an Ansi string.
    
Arguments:

    wszUnicode: the Unicode string to convert
    cszAnsi:    Ansi buffer to store new string. Must not be NULL    
    ulSize:     must be set to the size of the cszAnsi buffer
    
Return Value:

    PCHAR: returns the cszAnsi buffer

--*/
PCHAR UnicodeToAnsi(IN  PWCHAR wszUnicode,
                    OUT PCHAR  cszAnsi,
                    IN  ULONG  ulSize)  
{
   USHORT i;
   USHORT usUnicodeLength;
   WCHAR  wszTemp[2000];
   
   //
   // Record the length of the original Unicode string
   //
   usUnicodeLength = wcslen(wszUnicode);
   
   //
   // Copy the unicode string to a temporary buffer
   //
   wcscpy(wszTemp, wszUnicode);
   
   for (i = 0; i < usUnicodeLength && i < ulSize - 1; i++)
   {
      //
      // Copy the current character
      //
      cszAnsi[i] = (CHAR)wszTemp[0];
      
      //
      // Shift the unicode string up by one position
      //
      wcscpy(wszTemp, wszTemp + 1);
   }
   
   //
   // Add a null terminator to the end of the new ansi string
   //
   cszAnsi[i] = '\0';

   return cszAnsi;
   
} // UnicodeToAnsi //




/*++

Routine Description: ConvertAnsi

    Receives an Ansi string. Returns the equivalent string in Ansi or
    Unicode, depending on the current environment
    
Arguments:

    cszAnsi:    the Ansi string to convert
    wszUnicode: unicode buffer to store new string (if needed). 
                Must not be NULL    
    ulSize:     must be set to the size of the wszUnicode buffer
    
Return Value:

    TCHAR: returns the ANSI or Unicode string

--*/
PTCHAR ConvertAnsi(IN OUT PCHAR  cszAnsi,
                   IN OUT PWCHAR wszUnicode,
                   IN     ULONG  ulSize)
{                     
   //
   // If Unicode, we need to convert the string
   //
   #ifdef UNICODE
   
   return AnsiToUnicode(cszAnsi, wszUnicode, ulSize);
   
   //
   // If not Unicode, just return the original Ansi string
   //
   #else   
 
   return cszAnsi;
   
   #endif
   
} // ConvertAnsi //




/*++

Routine Description: ConvertUnicode

    Receives a Unicode string. Returns the equivalent string in Ansi or
    Unicode, depending on the current environment
    
Arguments:

    wszUnicode: the Unicode string to convert
    cszAnsi:    ANSI buffer to store new string (if needed). 
                Must not be NULL    
    ulSize:     must be set to the size of the cszAnsi buffer
    
Return Value:

    TCHAR: returns the ANSI or Unicode string

--*/
PTCHAR ConvertUnicode(IN OUT PWCHAR wszUnicode,
                      IN OUT PCHAR  cszAnsi,
                      IN     ULONG  ulSize)
{                     
   //
   // If Unicode, just return the original Unicode string
   //
   #ifdef UNICODE
 
   return wszUnicode;
   
   //
   // If not Unicode, need to convert to Ansi
   //
   #else   
   
   return UnicodeToAnsi(wszUnicode, cszAnsi, ulSize);
   
   #endif
   
} // ConvertUnicode //




/*++

Routine Description: ErrorMsg

    Converts a numerical winerror into it's string value

Arguments:

    ulError:   the error number
    tszBuffer: this buffer is used to return the string interpretation
               must be declared of size MAX_ERROR_LEN

Return Value:

    PTCHAR: returns the string value of the message stored in tszBuffer

--*/
PTCHAR ErrorMsg(IN     ULONG  ulError,
                IN OUT PTCHAR tszBuffer)  
{
   USHORT i, usLen;
   ULONG  ulSuccess;
   
   __ASSERT(tszBuffer != NULL);
   
   ZeroMemory(tszBuffer, MAX_ERROR_LEN);
   
   ulSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             ulError,
                             0,
                             tszBuffer,
                             MAX_ERROR_LEN,
                             NULL);
                             
   if (!ulSuccess)
   {
      // 
      // Couldn't get a description of this error. Just return the number
      //
      _itot(ulError, tszBuffer, MAX_ERROR_LEN);
   }
   else
   {
      //
      // Strip out returns from tszBuffer string
      //
      for (usLen = _tcslen(tszBuffer), i = 0; i < usLen; i++)
      {
         if (tszBuffer[i] == RETURN_CHAR1 || tszBuffer[i] == RETURN_CHAR2)
         {
            tszBuffer[i] = SPACE;
         }
      }
   }
   
   return tszBuffer;
   
} // ErrorMsg //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\cleanreg\cleanreg.c ===
#include <windows.h>
#include <winreg.h>
#include <winuser.h>

//#define DEBUG

VOID __cdecl main(){

   LONG        lDeleteRegResult;
   //LPCTSTR     tszKeyErrors = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");
   //LPCTSTR     tszKeyMasterInfs = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
   //LPCTSTR     tszKeySubcomponents = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
   //LPCTSTR     tszKeyTemporaryData = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
   //LPCTSTR     tszKeyOCManager = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");

   #ifdef DEBUG
   HKEY        hkeyResult = 0;

   // Let's see if I can open the key
   lDeleteRegResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors", 0, KEY_ALL_ACCESS, &hkeyResult);
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Can not open error key"), TEXT("Open"), MB_OK);
   }
   #endif
    
   // Do something to clean OC Manager's registry
   // the whole key will be deleted
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Error Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("MasterInfs Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Subcomponents Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("TemporaryData Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("OCManager Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegFlushKey(HKEY_LOCAL_MACHINE);
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Registry not flushed sucessfully"), TEXT("CleanReg"), MB_OK);
   }
   #endif

         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\hcttools.h ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    hctytools.h

Abstract:

    Contains the definitions used by hcttools.c

Environment:

    User mode

Revision History:

    05-Sep-1997 : Jason Allor (jasonall)

--*/
#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "tchar.h"

#ifndef _MYTOOLS_H
#define _MYTOOLS_H

   #define MAX_ERROR_LEN 256   
   #define RETURN_CHAR1  0x0d
   #define RETURN_CHAR2  0x0a
   #define SPACE         0x20
   
   BOOL __MALLOC(IN OUT void   **ppv,
                 IN     size_t size,
                 IN     PCHAR  cszFile,
                 IN     UINT   iLine);

   void __FREE(IN void **pv);

   VOID CheckAllocs();
   
   VOID InitializeMemoryManager();
   
   #ifdef DEBUG
      
      typedef struct _BLOCKINFO
      {
         struct _BLOCKINFO *pbiNext;
         BYTE   *pb;
         size_t size;   
         BOOL   boolReferenced;
         UINT   iLine;
         CHAR   cszFile[MAX_PATH];
      } BLOCKINFO, *PBLOCKINFO;

      #define Ptrless(pLeft, pRight)    ((pLeft  <  (pRight))
      #define PtrGrtr(pLeft, pRight)    ((pLeft) >  (pRight))
      #define PtrEqual(pLeft, pRight)   ((pLeft) == (pRight))
      #define PtrLessEq(pLeft, pRight)  ((pLeft) <= (pRight))
      #define PtrGrtrEq(pLeft, pRight)  ((pLeft) >= (pRight))

      void MyAssert(PCHAR, unsigned);
      BOOL CreateBlockInfo(OUT PBYTE  pbNew,
                           IN  size_t sizeNew,
                           IN  PCHAR  cszFile,
                           IN  UINT   iLine);
      void UpdateBlockInfo(PBYTE pbOld, PBYTE pbNew, size_t sizeNew);
      size_t SizeOfBlock(PBYTE pb);
      void ClearMemoryRegs();
      void NoteMemoryRef(PVOID pv);
      void CheckMemoryRefs();
      BOOL ValidPointer(PVOID pv, size_t size);
   
      #define GARBAGE 0xCC // used for shredding memory during Malloc and Free
   
   #endif

   //
   // Define __ASSERT macro
   //
   #ifdef DEBUG
      
      #define __ASSERT(f) \
         if (f)         \
            {}          \
         else           \
            MyAssert(__FILE__, __LINE__) 
   
   #else
      
      #define __ASSERT(f)
   
   #endif

   //
   // Define __Malloc macro. This gives the MALLOC function
   // the file name and line number of the line calling MyMalloc
   //
   #define __Malloc(one, two) __MALLOC(one, two, __FILE__, __LINE__) 
   
   //
   // Define the __Free macro. This is only here for consistency with __Malloc
   //
   #define __Free(one) __FREE(one)

   BOOL StrNCmp(IN PTCHAR tszString1,
                IN PTCHAR tszString2,
                IN ULONG  ulLength);

   BOOL StrCmp(IN PTCHAR tszString1,
               IN PTCHAR tszString2);

   PWCHAR AnsiToUnicode(IN  PCHAR  cszAnsi,
                        OUT PWCHAR wszUnicode,
                        IN  ULONG  ulSize);
                        
   PCHAR UnicodeToAnsi(IN  PWCHAR wszUnicode,
                       OUT PCHAR  cszAnsi,
                       IN  ULONG  ulSize);
                       
   PTCHAR ConvertAnsi(IN     PCHAR  cszAnsi,
                      IN OUT PWCHAR wszUnicode,
                      IN     ULONG  ulSize);
                     
   PTCHAR ConvertUnicode(IN     PWCHAR wszUnicode,
                         IN OUT PCHAR  cszAnsi,
                         IN     ULONG  ulSize);
                     
   PTCHAR ErrorMsg(IN ULONG  ulError,
                   IN PTCHAR tszBuffer);

#endif // _MYTOOLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\logutils.c ===
//3456789012345678901234567890123456789012345678901234567890123456789012345678
/*++

Copyright (c) 1997  Microsoft Corporation.

Module Name:

    logutils.c

Abstract:

    Contains functions that deal with ntlog.dll

Author:

    Jason Allor (JasonAll) 5/27/97

Revision History:


--*/
#include "logutils.h"

static HANDLE g_hSemaphore;
static ULONG  g_ulPass;
static ULONG  g_ulFail;
static ULONG  g_ulInfo;

/*++

Routine Description: LoadDLLs

    Tries to dynamically load ntlog.dll functions

Arguments:

    DLLName: the name of the DLL to load, ntlog.dll in this case

Return Value:

    void

--*/
void LoadDLLs(IN PTCHAR DLLName)
{
   HINSTANCE Library;

   //
   // Set global handle to logfile to NULL
   //
   gPnPTestLog = NULL;

   //
   // Load the engine DLL
   //
   Library = LoadLibrary(DLLName);

   if ((UINT) Library > 32)
   {
#ifdef UNICODE
      _tlLog               = (Dll_tlLog) \
                             GetProcAddress(Library, "tlLog_W");

      _tlCreateLog         = (Dll_tlCreateLog) \
                             GetProcAddress(Library, "tlCreateLog_W");
#else
      _tlLog               = (Dll_tlLog) \
                             GetProcAddress(Library, "tlLog_A");

      _tlCreateLog         = (Dll_tlCreateLog) \
                             GetProcAddress(Library, "tlCreateLog_A");
#endif
      
      _tlAddParticipant    = (Dll_tlAddParticipant) \
                             GetProcAddress(Library, "tlAddParticipant");

      _tlDestroyLog        = (Dll_tlDestroyLog) \
                             GetProcAddress(Library, "tlDestoryLog");

      _tlEndVariation      = (Dll_tlEndVariation) \
                             GetProcAddress(Library, "tlEndVariation");

      _tlRemoveParticipant = (Dll_tlRemoveParticipant) \
                             GetProcAddress(Library, "tlRemoveParticipant");

      _tlStartVariation    = (Dll_tlStartVariation) \
                             GetProcAddress(Library, "tlStartVariation");

      _tlReportStats       = (Dll_tlReportStats) \
                             GetProcAddress(Library, "tlReportStats");

      gNtLogLoaded = TRUE;
   }
   else
   {
      gNtLogLoaded = FALSE;
   }

   return;

} // LoadDLLs //




/*++

Routine Description: InitLog

    This routine will import the NtLog DLL functions and initialize them

Arguments:

    none

Return Value:

    HANDLE: handle to the log file

--*/
HANDLE InitLog(IN PTCHAR tszLogName,
               IN PTCHAR tszTitle,
               IN BOOL   bConsole)
{
   gPnPTestLog = NULL;
   gPnPTestLogFile = NULL;

   g_ulPass = 0;
   g_ulFail = 0;
   g_ulInfo = 0;

   //
   // Initialize Semaphore
   //
   g_hSemaphore = CreateSemaphore(NULL, 1, 9999, NULL);

   if (g_hSemaphore == NULL)
   {
      _ftprintf(stderr, TEXT("WARNING!  Could not create semaphore!\n"));
   }

   CreateConsoleWindow(bConsole, tszTitle);
   
   //
   // Set up console window for log output
   //
   g_hConsole = CreateConsoleScreenBuffer(GENERIC_WRITE,
                                          0,
                                          NULL,
                                          CONSOLE_TEXTMODE_BUFFER,
                                          NULL);

   if (g_hConsole == INVALID_HANDLE_VALUE) 
   {
      return INVALID_HANDLE_VALUE;
   }
     
   //
   // Load ntlog.dll
   //
   LoadDLLs(TEXT("ntlog.dll"));

   if (gNtLogLoaded)
   {
      g_LogLineLen = NTLOG_LINE_LEN;
      gPnPTestLog = _tlCreateLog((LPCWSTR)(tszLogName), LOG_OPTIONS);

      if (!gPnPTestLog)
      {
         _ftprintf(stderr, TEXT("WARNING!  Log file could not be created!\n"));
      }
      else
      {
         _tlStartVariation(gPnPTestLog);
         _tlAddParticipant(gPnPTestLog, 0, 0);
      }
   }
   else
   {
      SetConsoleActiveScreenBuffer(g_hConsole);
     
      g_LogLineLen =  NO_NTLOG_LINE_LEN;
      gPnPTestLogFile = _tfopen(tszLogName, TEXT("w"));

      if (!gPnPTestLogFile)
      {
         _ftprintf(stderr, TEXT("WARNING! Log file could not be created!\n"));
      }
   }

   return gPnPTestLog;

} // InitLog //




/*++

Routine Description: ExitLog

    Processes clean-up work before exiting the program

Arguments:

    none

Return Value:

    void

--*/
void ExitLog()
{
   double dTotal;
   double dPass;
   double dFail;
   USHORT usPassPerc;
   USHORT usFailPerc;
   
   CloseHandle(g_hConsole);
   CloseHandle(g_hSemaphore);
   
   if (gNtLogLoaded)
   {
      if (gPnPTestLog)
      {
         _tlReportStats(gPnPTestLog);
         _tlRemoveParticipant(gPnPTestLog);
         _tlEndVariation(gPnPTestLog);

         gPnPTestLog = NULL;
      }
   }
   else
   {
      //
      // Print out statistics
      //
      dTotal = g_ulPass + g_ulFail;

      dPass = (double)g_ulPass / dTotal;
      dFail = (double)g_ulFail / dTotal;
      
      usPassPerc = (USHORT)(dPass * 100);
      usFailPerc = (USHORT)(dFail * 100);

      LogBlankLine();
      LogBlankLine();
      Log(0, INFO, TEXT("Log Statistics:"));
      LogBlankLine();

      Log(0, INFO, TEXT("Pass:  %lu\t%lu%%%%%%%%%%%%%%%"), g_ulPass, usPassPerc);

      Log(0, INFO, TEXT("Fail:  %lu\t%lu%%%%%%%%%%%%%%%"), g_ulFail, usFailPerc);

      Log(0, INFO, TEXT("Total: %lu"), dTotal);
      
      if (gPnPTestLog)
      {
         fclose(gPnPTestLogFile);

         gPnPTestLogFile = NULL;
      }
   }

} // ExitLog //




/*++

Routine Description: WriteLog

    Wrapper function to write to the log

Arguments:

    dwLoglevel: specifies the log level such as TLS_INF, TLS_WARN, or TLS_SEV2
    tszBuffer:  the string to write to the log

Return Value:

    void

--*/
void WriteLog(IN DWORD  dwLogLevel,
              IN PTCHAR tszBuffer)
{
   USHORT i;
   HANDLE hConsole;
   DWORD  dwDummy;
   TCHAR  tszLogLine[2000];
   CHAR   cszAnsi[2000];
   CHAR   cszLogLine[2000];
   
   if (gNtLogLoaded)
   {
      if (gPnPTestLog)
      {
         _tlLog(gPnPTestLog, dwLogLevel | TL_VARIATION, tszBuffer);
      }
   }
   else
   {
      //
      // Convert tszBuffer to an ANSI string
      //
#ifdef UNICODE
   
      _tcscpy(tszLogLine, tszBuffer);
   
      for (i = 0; i < _tcslen(tszBuffer) && i < 1999; i++)
      {
         cszAnsi[i] = (CHAR)tszLogLine[0];
         _tcscpy(tszLogLine, _tcsinc(tszLogLine));
      }
      cszAnsi[i] = '\0';

#else

      strcpy(cszAnsi, tszBuffer);
   
#endif   
   
      switch (dwLogLevel)
      {
         case INFO:
            sprintf(cszLogLine, "INFO  ");
            g_ulInfo++;
            break;
         case SEV1:
            sprintf(cszLogLine, "SEV1  ");
            g_ulFail++;
            break;
         case SEV2:
            sprintf(cszLogLine, "SEV2  ");
            g_ulFail++;
            break;
         case SEV3:
            sprintf(cszLogLine, "SEV3  ");
            g_ulFail++;
             break;
         case PASS:
            sprintf(cszLogLine, "PASS  ");
            g_ulPass++;
            break;
         default:
            sprintf(cszLogLine, "      ");
      }
   
      if (gPnPTestLogFile)
      {
         sprintf (cszLogLine, "%s%s\n", cszLogLine, cszAnsi);
         
         WaitForSingleObject(g_hSemaphore, INFINITE);
         
         //
         // Print to log file
         //
         fprintf(gPnPTestLogFile, cszLogLine);
         fflush(gPnPTestLogFile);

         //
         // Print to screen
         //
         WriteFile(g_hConsole, 
                   cszLogLine, 
                   strlen(cszLogLine), 
                   &dwDummy, 
                   NULL);
         
         ReleaseSemaphore(g_hSemaphore, 1, NULL);
      }
   }

   return;

} // WriteLog //




/*++

Routine Description: Log

    Wrapper to the Log function. It divides a long string into
    shorter strings and puts each one on a separate line to avoid running
    over the end of a console window

Arguments:

    dFunctionNumber: shows which function this log output is coming from.
                     Used to track function progress
    dwLoglevel:      specifies the log level such as TLS_INF, TLS_WARN, 
                     or TLS_SEV2
    tszLogString:    printf() style format string

Return Value:

    void

--*/
void Log(IN double dFunctionNumber,
         IN DWORD  dwLogLevel,
         IN PTCHAR tszLogString,
         IN  ...)
{
   va_list va;
   TCHAR   tszBuffer[LOG_STRING_LEN];
   TCHAR   tszBufferToPrint[LOG_STRING_LEN];
   TCHAR   tszTmpString[LOG_STRING_LEN + LOG_SPACE_LEN];
   ULONG   ulIndex, i, j;
   BOOL    boolFirstTime = TRUE;
   int     iInteger, iFunctionNumber;      
   double  dDecimal;      

   //
   // Prints the list to a buffer
   //
   va_start(va, tszLogString);
   if (!_vsntprintf (tszBuffer, LOG_STRING_LEN, tszLogString, va))
   {
      _ftprintf(stderr, TEXT("Log: Failed\n"));
      ExitLog();
      exit(1);
   }
   va_end(va);

   switch (dwLogLevel)
   {
      case INFO:
         SetConsoleTextAttribute(g_hConsole, GREY);
         break;
      case SEV1:
         SetConsoleTextAttribute(g_hConsole, RED);
         break;
      case SEV2:
         SetConsoleTextAttribute(g_hConsole, RED);
         break;
      case SEV3:
         SetConsoleTextAttribute(g_hConsole, RED);
          break;
      case PASS:
         SetConsoleTextAttribute(g_hConsole, GREEN);
         break;
      default:
         SetConsoleTextAttribute(g_hConsole, GREY);
   }
   
   while (_tcslen(tszBuffer))
   {
      ZeroMemory(tszBufferToPrint, LOG_STRING_LEN);

      if (_tcslen(tszBuffer) > g_LogLineLen)
      {
         //
         // If the LogString is longer than the console length, start at the
         // maximum console length and work backwards until we hit a space
         // to find out where to cut off the string
         //
         for (ulIndex = g_LogLineLen; ulIndex > 0; ulIndex--)
         {
            if (tszBuffer[ulIndex] == ' ')
            {
               break;
            }
         }

         //
         // index now sits on the last char that we want to print. Create
         // two strings - one to print now and one with the leftovers.
         //
         for (i = 0; i < ulIndex; i++)
         {
            tszBufferToPrint[i] = tszBuffer[i];
         }

         ulIndex++;
         for (i = 0; i < LOG_STRING_LEN; i++)
         {
            //
            // Shift the remaining string up to the front
            //
            if (i < LOG_STRING_LEN - ulIndex)
            {
               tszBuffer[i] = tszBuffer[i + ulIndex];
            }
            else
            {
               tszBuffer[i] = '\0';
            }
         }
      }
      else
      {
         //
         // Just print out the entire string since it contains no spaces
         //
         _stprintf(tszBufferToPrint, tszBuffer);
         ZeroMemory(tszBuffer, LOG_STRING_LEN);
      }

      if (boolFirstTime)
      {
         {
            _stprintf(tszTmpString, TEXT("(%.2f) "), dFunctionNumber);
         }
         _tcscat(tszTmpString, tszBufferToPrint);
         _tcscpy(tszBufferToPrint, tszTmpString);
         WriteLog(dwLogLevel, tszBufferToPrint);
      }
      else
      {
         _stprintf(tszTmpString, TEXT("       "));
         _tcscat(tszTmpString, tszBufferToPrint);
         _tcscpy(tszBufferToPrint, tszTmpString);
         WriteLog(INFO, tszBufferToPrint);
      }

      boolFirstTime = FALSE;
   }

   return;

} // Log //




/*++

Routine Description: LogBlankLine

    Print a blank line to the log

Arguments:

    none

Return Value:

    void

--*/
VOID LogBlankLine()
{
   SetConsoleTextAttribute(g_hConsole, GREY);
   WriteLog(INFO, TEXT(" "));

} // LogBlankLine //




/*++

Routine Description: CreateConsoleWindow

    Creates a console window for this process to dump the log output into.
    Gives the console window a title and uses this title to get a handle
    to the console window. Then disables the cancel button on the window.

Arguments:

    bConsole: TRUE if a new console window needs to be created.
              FALSE if there is already a console that can be used
    tszTitle: title to give the console window

Return Value:

    none

--*/
VOID CreateConsoleWindow(IN BOOL   bConsole,
                         IN PTCHAR tszTitle)
{
   HWND gConsole;

   if (bConsole)
   {
      //
      // Create a console window to dump the log output in
      //
      if (!AllocConsole())
      {
         goto RETURN;
      }
   }
   
   if (!SetConsoleTitle(tszTitle))
   {
      goto RETURN;
   }

   RETURN:
   return;

} // CreateConsoleWindow //




VOID AddLogParticipant(IN HANDLE hLog)
{
   if (gNtLogLoaded)
   {
      _tlAddParticipant(hLog, 0, 0);                  
   }

} // AddLogParticipant //




VOID RemoveLogParticipant(IN HANDLE hLog)
{
   if (gNtLogLoaded)
   {
      _tlRemoveParticipant(hLog);
   }

} // RemoveLogParticipant //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\logutils.h ===
#ifndef _LOGUTILS_H_
#define _LOGUTILS_H_

#include <windows.h>
#include <ntlog.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

//
// Definitions
//
#define LOG_STRING_LEN    256
#define LOG_SPACE_LEN     6
#define NTLOG_LINE_LEN    42
#define NO_NTLOG_LINE_LEN 65
#define MAX_FUNC_NUM      100
#define INFO TLS_INFO
#define PASS TLS_PASS
#define SEV1 TLS_SEV1
#define SEV2 TLS_SEV2
#define SEV3 TLS_SEV3

#define GREY  0x7	
#define GREEN 0xa
#define RED   0xc

//
// Globals
//
static HANDLE gPnPTestLog;           // Handle to NTLog - "pnptest.log"
static FILE   *gPnPTestLogFile;      // Handle if ntlog.dll couldn't load
static BOOL   gNtLogLoaded;          // Tells whether ntlog.dll was loaded
static USHORT g_LogLineLen;
HANDLE g_hConsole;

//
// Function definitions
//
void LoadDLLs(IN PTCHAR DLLName);

HANDLE InitLog(IN PTCHAR tszLogName,
               IN PTCHAR tszTitle,
               IN BOOL   bConsole);

void ExitLog();

void WriteLog(IN DWORD  dwLogLevel,
              IN PTCHAR tszBuffer);

void Log(IN double dFunctionNumber,
         IN DWORD  dwLogLevel,
         IN PTCHAR tszLogString,
         IN  ...);

VOID LogBlankLine();

VOID CreateConsoleWindow(IN BOOL   bConsole,
                         IN PTCHAR tszTitle);

VOID AddLogParticipant(IN HANDLE hLog);

VOID RemoveLogParticipant(IN HANDLE hLog);

//
// NtLog definitions
//
typedef HANDLE (*Dll_tlCreateLog) (LPCWSTR, DWORD);
typedef BOOL   (*Dll_tlAddParticipant) (HANDLE, DWORD, int);
typedef BOOL   (*Dll_tlStartVariation) (HANDLE);
typedef BOOL   (*Dll_tlLog) (HANDLE, DWORD, PTCHAR, int, PTCHAR, ...);
typedef DWORD  (*Dll_tlEndVariation) (HANDLE);
typedef BOOL   (*Dll_tlRemoveParticipant) (HANDLE);
typedef BOOL   (*Dll_tlDestroyLog) (HANDLE);
typedef VOID   (*Dll_tlReportStats) (HANDLE);

Dll_tlCreateLog         _tlCreateLog;
Dll_tlAddParticipant    _tlAddParticipant;
Dll_tlDestroyLog        _tlDestroyLog;
Dll_tlEndVariation      _tlEndVariation;
Dll_tlLog               _tlLog;
Dll_tlRemoveParticipant _tlRemoveParticipant;
Dll_tlStartVariation    _tlStartVariation;
Dll_tlReportStats       _tlReportStats;

#define LOG_OPTIONS (TLS_REFRESH | TLS_SEV2 | TLS_WARN | TLS_PASS | \
                     TLS_MONITOR | TLS_VARIATION | \
                     TLS_SYSTEM  | TLS_INFO )


#endif // _LOGUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|
\*---------------------------------------------------------------------------*/


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL       // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L       // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL       // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L       // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L       // Log information.
#define TLS_ABORT     0x00000001L       // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L       // Log at Severity 1 level
#define TLS_SEV2      0x00000004L       // Log at Severity 2 level
#define TLS_SEV3      0x00000008L       // Log at Severity 3 level
#define TLS_WARN      0x00000010L       // Log at Warn level
#define TLS_PASS      0x00000020L       // Log at Pass level
#define TLS_BLOCK     0x00000400L       // Block the variation.
#define TLS_BREAK     0x00000800L       // Debugger break;
#define TLS_CALLTREE  0x00000040L       // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L       // Log System debug.
#define TLS_TESTDEBUG 0x00001000L       // Debug level.
#define TLS_TEST      0x00000100L       // Log Test information (user).
#define TLS_VARIATION 0x00000200L       // Log testcase level.

#define TLS_REFRESH   0x00010000L       // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L       // Sort file output by instance.
#define TLS_DEBUG     0x00040000L       // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L       // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L       // Prolog line information.
#define TLS_WINDOW    0x00400000L       // Log to windows.
#define TLS_ACCESSON  0x00800000L       // Keep log-file open.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_WARN      TLS_WARN     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_PASS      TLS_PASS     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_INFO      TLS_INFO     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,(LPTSTR)__FILE__,(int)__LINE__
#define TL_TEST      TLS_TEST     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_VARIATION TLS_VARIATION,(LPTSTR)__FILE__,(int)__LINE__


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPSTR,DWORD);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPWSTR,int,LPWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPSTR,int,LPSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPWSTR,int,LPWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPSTR,int,LPSTR,...);


#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK

#define TESTDATA                 HANDLE hLog;

#define TESTOTHERDATA            extern HANDLE hLog;
#define TESTBEGIN(cmd)           TCHAR  log[100];                                                        \
                                 DWORD  tlFlags;                                                         \
                                 tlFlags = tlParseCmdLine(cmd,log);                                      \
                                 hLog    = tlCreateLog(log,tlFlags);                                     \
                                 tlAddParticipant(hLog,0,0);

#define TESTEND                  tlRemoveParticipant(hLog);                                              \
                                 tlDestroyLog(hLog);

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                              \
                                 {                                                                       \
                                     DWORD  dwResult;                                                    \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);


#define ENDVARIATION                 dwResult = tlEndVariation(hLog);                                    \
                                     tlLog(hLog,dwResult | TL_VARIATION,TEXT("End Variation reported")); \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                       \
                                    LPTSTR _lpFN = _szNM;                                                \
                                    tlAddParticipant(_hLG,0,0);                                          \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                           \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);         \
                                    tlRemoveParticipant(_hLG);                                           \
                                    return(_ret);                                                        \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                            \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);        \
                                     tlRemoveParticipant(_hLG);                                          \
                                     return;                                                             \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    tlLog((expr ? L_PASS : L_FAIL),TEXT("%s"),(LPTSTR)msg);
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_FAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_FAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_FAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_PASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_WARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_BLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\sources.inc ===
C_DEFINES= -DDEBUG

NTDEBUG=ntsd
NTDEBUGTYPE=both

TARGETPATH=..\lib
TARGETTYPE=LIBRARY

TARGETLIBS=$(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib \


UMLIBS=$(SDK_LIB_PATH)\libc.lib \
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\user32.lib 

SOURCES= ..\logutils.c ..\hcttools.c

INCLUDES= ..;

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\unicode\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oeminf\oeminf.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <string.h>

typedef int BOOL;
#define TRUE  1
#define FALSE 0

typedef struct _linklist
{
    struct _linklist *Next;
    char data[1000];
}
LINKLIST;

void trim( char * s )
{
    int n;
    char *tmp;
    int i;
    for (n=strlen(s) -1;n>=0;n--)
    {
        if ( s[n]!=' '&&s[n]!='\t'&&s[n]!='\n') break;
    }
    s[n+1]='\0';
    tmp = s;

    for( ;isspace(*tmp); tmp++);
    i=0;
    do{
        s[i]=tmp[i];
        i++;
    }
    while (s[i]!='\0');

}

void AddItem( LINKLIST **ppLinkList, char * psz )
{
    if ( *ppLinkList == NULL )
    {
        *ppLinkList = (LINKLIST *)malloc(sizeof( LINKLIST));
        if( *ppLinkList ) {
            (*ppLinkList)->Next = NULL;
            trim( psz );
            strcpy( (*ppLinkList)->data,psz );
        }
    }
    else
        AddItem ( &((*ppLinkList)->Next), psz );
}

void PrintItem( LINKLIST *pLinkList )
{
    if ( pLinkList != NULL )
    {
        printf( "%s\n", pLinkList->data);
        PrintItem( pLinkList->Next );
    }
}

void DeleteList( LINKLIST **ppLinkList )
{

    while ( *ppLinkList != NULL )
    {
        DeleteList (&((*ppLinkList)->Next));
        free (*ppLinkList);
        *ppLinkList = NULL;
    }
}


int
__cdecl
main ( int argc, char * argv[], char * envp[] )
{
    LINKLIST *Options = NULL;
    LINKLIST *OptionsText = NULL;
    LINKLIST *LLfilename = NULL;
    LINKLIST *OpenFile = NULL;
    char buf[1000];
    char platbuf[1000];
    FILE *fp;
    char OptionBuf[100];
    sprintf(OptionBuf,"[%sOptions]",argv[2]);
    AddItem( &Options, OptionBuf);
    sprintf(OptionBuf,"[%sOptionsTextENG]",argv[2]);
    AddItem( &OptionsText, OptionBuf);
    sprintf(OptionBuf,"[%sFilename]",argv[2]);
    AddItem( &LLfilename, OptionBuf);

    if ( argc > 1 )
    {
        FILE *ffilename = fopen(argv[1],"r");
        LINKLIST *tmpFile;
        if ( ffilename != NULL)
        {
            char filename[1000];
            while (fgets(filename,1000,ffilename))
            {
                AddItem(&OpenFile, filename);
            }
            fclose(ffilename);
        }
        tmpFile=OpenFile;
        while(tmpFile!= NULL )
        {
            LINKLIST *LocOptions = NULL;
            LINKLIST *LocOptionsText = NULL;
            LINKLIST *LocPlatform = NULL;
            LINKLIST *tmp = NULL;
            BOOL ffind;
            trim(tmpFile->data);
            fp = fopen(tmpFile->data,"r");
            if ( fp != NULL )
            {
                BOOL fRecordPlatform = FALSE;
                BOOL fRecordOptions = FALSE;
                BOOL fRecordOptionsText = FALSE;
                while (fgets(buf,1000,fp))
                {
                    // get the platform
                        trim(buf);
                    if (strcmp(buf,"")==0)
                    {
                        continue;
                    }
                    if ( strchr( buf, ';') != NULL )
                    {
                        continue;
                    }
                    if ( strchr( buf, '[') != NULL )
                    {
                        fRecordPlatform = FALSE;
                        fRecordOptions = FALSE;
                        fRecordOptionsText = FALSE;
                    }
                    if ( strstr( buf, "[PlatformsSupported]" ) != NULL )
                    {
                        fRecordPlatform = TRUE;
                        continue;
                    }
                    if ( strstr( buf, "[Options]" ) != NULL )
                    {
                        fRecordOptions = TRUE;
                        continue;
                    }

                    if ( strstr( buf, "[OptionsText" ) != NULL )
                    {
                        fRecordOptionsText = TRUE;
                        continue;
                    }


                    if ( fRecordPlatform)
                    {
                        AddItem(&LocPlatform, buf );
                    }
                    if ( fRecordOptions)
                    {
                        AddItem(&LocOptions, buf );
                    }
                    if ( fRecordOptionsText)
                    {
                        AddItem(&LocOptionsText, buf );
                    }
                }
                fclose(fp);

                tmp = LocPlatform;
                ffind = FALSE;
                platbuf[0]='\0';
                while  (tmp != NULL )
                {
                    if (strstr( tmp->data,argv[2]))
                    {
                        if ((strcmp( argv[2],"ISA")==0) && (strcmp(tmp->data,"EISA")==0))
                        {
                            // not mathc
                        }
                        else
                        {
                            ffind = TRUE;
                        }
                    }
tmp=tmp->Next;
                }
                if (!ffind)
                    goto NextFile;
                tmp = LocOptions;
                while  (tmp != NULL )
                {
                    AddItem(&Options,tmp->data);
                    AddItem(&LLfilename,&(tmpFile->data[2]));
                    tmp=tmp->Next;
                }
                tmp = LocOptionsText;
                while  (tmp != NULL )
                {
                    AddItem(&OptionsText,tmp->data);
                    tmp=tmp->Next;
                }
            }
NextFile:
            DeleteList(&LocOptions);
            DeleteList(&LocOptionsText);
            DeleteList(&LocPlatform);
            tmpFile = tmpFile->Next;
        }
    }
    PrintItem(Options);
    PrintItem(LLfilename);
    PrintItem(OptionsText);

    DeleteList (&Options);
    DeleteList (&OptionsText);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies project-wide macros for OOBE.

Author:

    Dan Elliott (dane)

!ENDIF

OOBELIB=$(PROJECT_ROOT)\ntsetup\oobe\lib
OOBEINC=$(PROJECT_ROOT)\ntsetup\oobe\inc;$(PROJECT_ROOT)\ntsetup\oobe\idl\$(O);

USE_MSVCRT=1
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\inf\auto.cpp ===
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <windows.h>
#include <winbase.h>

const DWORD MaxStrLength = 256;
const char ComponentSectionTitle[] = "[Components]";

/*++

Description:

  Program to do setup testing automatically

Argument:

  argv[1]: test case directory
  argv[2]: Windows NT installation directory, where server is to be installed
  argv[3]: generate the test case from a standalone test case

Return value:
  None

--*/

void main(int argc, char *argv[])
{
	bool bFromStandalone;
	char pchTestCaseDir[MaxStrLength];
	char pchNTDir[MaxStrLength];

	char pchOcFileName[MaxStrLength];
	char pchSysocFileName[MaxStrLength];

	LPSTR lpBuffer;

	if (argc != 3 && argc != 4){
		cout << "Usage: " << argv[0] << " TestCaseDir NTDir IfFromStandalone" << endl;
		exit(1);
	}

	if (argc == 4){
		bFromStandalone = true;
		cout << "Start test from a standalone test case is not supported yet" << endl;
	}
	else{
		bFromStandalone = false;
	}

	// Now we need to form an absolute path.
	// It is assumed that test case directory is relative to the current directory
	// and NT directory is an absolute path

	strcpy(pchNTDir, argv[2]);
	strcpy(pchTestCaseDir, argv[1]);

	if (pchNTDir[strlen(pchNTDir)-1] == '\\'){
		strcat(pchNTDir, "system32\\");
	}
	else{
		strcat(pchNTDir, "\\system32\\");
	}

	lpBuffer = (LPSTR)malloc(sizeof(char) * MaxStrLength);
	
	GetCurrentDirectory(MaxStrLength, lpBuffer);

	if (lpBuffer[strlen(lpBuffer) - 1] != '\\'){
		strcat(lpBuffer, "\\");
	}

	strcat(lpBuffer, pchTestCaseDir);
	
	strcpy(pchTestCaseDir, lpBuffer);

	free(lpBuffer);

	if (pchTestCaseDir[strlen(pchTestCaseDir) - 1] != '\\'){
		strcat(pchTestCaseDir, "\\");
	}

	// Now we will open oc.inf from test directory
	// and sysoc.inf from NT directory
	// and put something from oc.inf into sysoc.inf

	strcpy(pchOcFileName, pchTestCaseDir);
	strcat(pchOcFileName, "oc.inf");

	strcpy(pchSysocFileName, pchNTDir);
	strcat(pchSysocFileName, "sysoc.inf");
	
	FILE *pfSysoc, *pfOc, *pfTemp;

	if ((pfSysoc = fopen(pchSysocFileName, "r")) == NULL){
		cout << "Error opening sysoc.inf " << endl;
	 	exit(1);
	}

	if ((pfOc = fopen(pchOcFileName, "r")) == NULL){
		cout << "Error opening oc.inf " << endl;
		exit(1);
	}

	if ((pfTemp = fopen("temp.inf", "w")) == NULL){
		cout << "Error opening temp.inf " << endl;
		exit(1);
	}

	char pchOcLine[MaxStrLength];
	char pchSysocLine[MaxStrLength];	

	bool bNotFound = true;

	while (fgets(pchSysocLine, MaxStrLength, pfSysoc) != NULL){

		fputs(pchSysocLine, pfTemp);


		if (strstr(pchSysocLine, ComponentSectionTitle) != NULL){
			// Read from oc.inf and paste important information
			bNotFound = true;

			while (fgets(pchOcLine, MaxStrLength, pfOc) != NULL){
				if (bNotFound){
					if (strstr(pchOcLine, ComponentSectionTitle) == NULL){
						continue;
					}
					else{
						bNotFound = false;
					}
				}
				else{
					if (pchOcLine[0] != '['){
						fputs(pchOcLine, pfTemp);
					}
					else{
						bNotFound = true;
					}
				}
			}
			fclose(pfOc);
		}
	}

	fclose(pfSysoc);
	fclose(pfTemp);

	// Now copy the temporary file onto sysoc.inf

	char pchCmdLine[MaxStrLength];

	sprintf(pchCmdLine, "copy temp.inf %s /Y", pchSysocFileName);
	system(pchCmdLine);

	system("del temp.inf");

	// We are now done with the file stuff
	// We will begin copying files

	sprintf(pchCmdLine, "copy %s*.dll %s /Y", pchTestCaseDir, pchNTDir);
	system(pchCmdLine);

	// We will assume it is not from a standalone.
	//if (!bFromStandalone || true){
		sprintf(pchCmdLine, "copy %s*.inf %s /Y", pchTestCaseDir, pchNTDir);
		system(pchCmdLine);
	//}
	
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\common\cfactory.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CFACTORY.CPP - Implementation of IClassFactory
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Base class for reusing a single class factory for all
//  components in a DLL.

#include <objbase.h>
#include "cfactory.h"
#include "registry.h"

///////////////////////////////////////////////////////////
// Static variables
//
LONG    CFactory::s_cServerLocks = 0 ;      // Count of locks
HMODULE CFactory::s_hModule      = NULL;    // DLL Module Handle.

#ifdef _OUTPROC_SERVER_
DWORD CFactory::s_dwThreadID = 0;
#endif

///////////////////////////////////////////////////////////
// CFactory implementation
//
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData;
}

///////////////////////////////////////////////////////////
//              IUnknown implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// QueryInterface
//
HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        pI = this; 
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef();
    *ppv = pI;
    return S_OK;
}

///////////////////////////////////////////////////////////
// AddRef
//
ULONG __stdcall CFactory::AddRef() 
{
    return ::InterlockedIncrement(&m_cRef); 
}

///////////////////////////////////////////////////////////
// Release
//
ULONG __stdcall CFactory::Release() 
{
    if (::InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this; 
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////
//              IClassFactory Implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// CreateInstance
//
HRESULT __stdcall CFactory::CreateInstance( IUnknown* pOuterUnknown,
                                            const IID& iid,
                                            void** ppv) 
{

    // Aggregate only if the requested iid is IID_IUnknown
    if ((pOuterUnknown != NULL) && (iid != IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create the component.
    CUnknown* pNewComponent ;
    HRESULT hr = m_pFactoryData->CreateInstance(pOuterUnknown, 
                                                &pNewComponent);
    if (FAILED(hr))
    {
        return hr;
    }

    // Initialize the component.
    hr = pNewComponent->Init();
    if (FAILED(hr))
    {
        // Initialization failed. Release the component.
        pNewComponent->NondelegatingRelease();
        return hr ;
    }

    // Get the requested interface.
    hr = pNewComponent->NondelegatingQueryInterface(iid, ppv);

    // Release the reference held by the class factory.
    pNewComponent->NondelegatingRelease();
    return hr ;
}

///////////////////////////////////////////////////////////
// LockServer
//
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
    if (bLock) 
    {
        ::InterlockedIncrement(&s_cServerLocks); 
    }
    else
    {
        ::InterlockedDecrement(&s_cServerLocks);
    }
    // If this is an outproc server check to see if we should shut down.
    CloseExe() ;  //@local

    return S_OK;
}


//////////////////////////////////////////////////////////
// GetClassObject - Creates a class factory based on CLSID
//
HRESULT CFactory::GetClassObject(const CLSID& clsid, 
                                 const IID& iid, 
                                 void** ppv)
{
    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
    {
            return E_NOINTERFACE;
    }

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++)
    {
        const CFactoryData* pData = &g_FactoryDataArray[i];
        if (pData->IsClassID(clsid))
        {

            // Found the ClassID in the array of components we
            // can create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData);
            if (*ppv == NULL)
            {
                return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

//////////////////////////////////////////////////////////
// CanUnloadNow - Determine if component can be unloaded.
//
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked())
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

//////////////////////////////////////////////////////////
//  CFactory Member Function
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Register all components.
//
HRESULT CFactory::RegisterAll()
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
    {
        RegisterServer( s_hModule,
                        *(g_FactoryDataArray[i].m_pCLSID),
                        g_FactoryDataArray[i].m_RegistryName,
                        g_FactoryDataArray[i].m_szVerIndProgID, 
                        g_FactoryDataArray[i].m_szProgID ); 

        // Perform any additional registration.
        if (g_FactoryDataArray[i].SpecialRegistration != NULL)
        {
            g_FactoryDataArray[i].SpecialRegistration(TRUE);
        }
    }

    return S_OK ;
}

//////////////////////////////////////////////////////////
// Unregister all components.
//
HRESULT CFactory::UnregisterAll()
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)   
    {
        // Undo any additional registration.
        if (g_FactoryDataArray[i].SpecialRegistration != NULL)
        {
            g_FactoryDataArray[i].SpecialRegistration(FALSE);
        }

        UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
                                g_FactoryDataArray[i].m_szVerIndProgID, 
                                g_FactoryDataArray[i].m_szProgID );
    }
    return S_OK;
}

#ifndef _OUTPROC_SERVER_

//////////////////////////////////////////////////////////
// Exported functions
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// DllCanUnloadNow
//
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow(); 
}

//////////////////////////////////////////////////////////
// Get class factory
//
STDAPI DllGetClassObject(   const CLSID& clsid,
                            const IID& iid,
                            void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv);
}

//////////////////////////////////////////////////////////
// Server Registration
//
STDAPI DllRegisterServer()
{
    return CFactory::RegisterAll();
}


//////////////////////////////////////////////////////////
// Unregistration
//
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterAll();
}

///////////////////////////////////////////////////////////
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule, 
                             DWORD dwReason, 
                             void* lpReserved )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CFactory::s_hModule = (HMODULE) hModule;
    }
    return TRUE;
}

#else

//////////////////////////////////////////////////////////
//          Out of process Server support
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Start factories
//
BOOL CFactory::StartFactories()
{
    CFactoryData* pStart = &g_FactoryDataArray[0];
    const CFactoryData* pEnd = &g_FactoryDataArray[g_cFactoryDataEntries-1];

    for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Initialize the class factory pointer and cookie.
        pData->m_pIClassFactory = NULL ;
        pData->m_dwRegister = NULL ;

        // Create the class factory for this component.
        IClassFactory* pIFactory = new CFactory(pData);

        // Register the class factory.
        DWORD dwRegister ;
        HRESULT hr = ::CoRegisterClassObject(   *pData->m_pCLSID,
                                            (IUnknown*)pIFactory,
                                            CLSCTX_LOCAL_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            //REGCLS_MULTI_SEPARATE, //@Multi
                                            &dwRegister) ;
        if (FAILED(hr))
        {
            pIFactory->Release() ;
            return FALSE ;
        }

        // Set the data.
        pData->m_pIClassFactory = pIFactory ;
        pData->m_dwRegister = dwRegister ;
    }
    return TRUE ;
}

//////////////////////////////////////////////////////////
// Stop factories
//
void CFactory::StopFactories()
{
    CFactoryData* pStart = &g_FactoryDataArray[0];
    const CFactoryData* pEnd = &g_FactoryDataArray[g_cFactoryDataEntries-1];

    for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Get the magic cookie and stop the factory from running.
        DWORD dwRegister = pData->m_dwRegister ;
        if (dwRegister != 0) 
        {
            ::CoRevokeClassObject(dwRegister) ;
        }

        // Release the class factory.
        IClassFactory* pIFactory  = pData->m_pIClassFactory;
        if (pIFactory != NULL) 
        {
            pIFactory->Release() ;
        }
    }
}

#endif //_OUTPROC_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\common\cunknown.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CUNKNOWN.CPP - Implementation of IUnknown 
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// IUnknown Base class

#include "cunknown.h"
#include "cfactory.h"
#include "util.h"

///////////////////////////////////////////////////////////
// Count of active objects. Use to determine if we can unload the DLL.
//
long CUnknown::s_cActiveComponents = 0;

///////////////////////////////////////////////////////////
// Constructor
//
CUnknown::CUnknown(IUnknown* pOuterUnknown)
:   m_cRef(1)
{ 
   // Set pOuterUnknown pointer.
   if (pOuterUnknown == NULL)
   {
      TRACE(L"CUnknown: Using nondelegating IUnknown.") ;
      m_pOuterUnknown = reinterpret_cast<IUnknown*>(static_cast<INondelegatingUnknown*>(this)) ; // notice cast
   }
   else
   {
        TRACE(L"CUnknown: Aggregating. Using delegating IUnknown.") ;
        m_pOuterUnknown = pOuterUnknown;
   }

   // Increment count of active components.
   ::InterlockedIncrement(&s_cActiveComponents) ;
} 

///////////////////////////////////////////////////////////
// Destructor
//
CUnknown::~CUnknown()
{
    ::InterlockedDecrement(&s_cActiveComponents) ;
    // If this is an exe server shut it down.
    CFactory::CloseExe(); //@local server
}

///////////////////////////////////////////////////////////
// FinalRelease -- called by Release before it deletes the component.
//
void CUnknown::FinalRelease()
{
    TRACE(L"FinalRelease\n") ;
    m_cRef = 1;
}

///////////////////////////////////////////////////////////
// NonDelegatingIUnknown - Override to handle custom interfaces.
//
HRESULT __stdcall 
CUnknown::NondelegatingQueryInterface(const IID& riid, void** ppv)
{
    // CUnknown only supports IUnknown.
    if (riid == IID_IUnknown)
    {
        return FinishQI(reinterpret_cast<IUnknown*>(static_cast<INondelegatingUnknown*>(this)), ppv) ;
    }   
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
}

///////////////////////////////////////////////////////////
//
// AddRef
//
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
    return ::InterlockedIncrement(&m_cRef) ;
}

///////////////////////////////////////////////////////////
//
// Release
//
ULONG __stdcall CUnknown::NondelegatingRelease()
{
    ::InterlockedDecrement(&m_cRef) ;
    if (m_cRef == 0)
    {
        FinalRelease() ;
        delete this ;
        return 0 ;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////
// FinishQI - 
//
// Helper function to simplify overriding NondelegatingQueryInterface
//
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
    // Copy pointer into out parameter.
    *ppv = pI ;
    // Increment reference count for this interface.
    pI->AddRef() ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\common\registry.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  REGISTRY.CPP - Implementation of functions to register components.
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
// registry functions.

#include <objbase.h>
#include <assert.h>
#include <appdefs.h>
#include "registry.h"


////////////////////////////////////////////////////////
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const WCHAR* pszPath,
                    const WCHAR* szSubkey,
                    const WCHAR* szValue,
                    const WCHAR* szName = NULL);

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid,
                 WCHAR* szCLSID,
                 int   length);

// Determine if a particular subkey exists.
BOOL SubkeyExists(const WCHAR* pszPath,
                  const WCHAR* szSubkey);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const WCHAR* szKeyChild);

/////////////////////////////////////////////////////////
// Public function implementation
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// Register the component in the registry.
//
HRESULT RegisterServer( HMODULE hModule,                // DLL module handle
                        const CLSID& clsid,             // Class ID
                        const WCHAR* szFriendlyName,     // Friendly Name
                        const WCHAR* szVerIndProgID,     // Programmatic
                        const WCHAR* szProgID)           //  IDs
{
    // Get server location.
    WCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
                            szModule,
                            MAX_CHARS_IN_BUFFER(szModule)) ;
    assert(dwResult != 0) ;

    // Convert a CLSID into a char string.
    WCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

    // Build the key CLSID\\{...}
    WCHAR szKey[64] ;
    lstrcpy(szKey, L"CLSID\\");
    lstrcat(szKey, szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add server filename key
#ifdef _OUTPROC_SERVER_
    setKeyAndValue(szKey, L"LocalServer32", szModule) ;
#else
    setKeyAndValue(szKey, L"InprocServer32", szModule) ;
#endif

    // Add the ProgID subkey under the CLSID key.
    setKeyAndValue(szKey, L"ProgID", szProgID) ;

    // Add the version-independent ProgID subkey under CLSID key.
    setKeyAndValue( szKey, L"VersionIndependentProgID",
                    szVerIndProgID) ;

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szVerIndProgID, NULL, szFriendlyName);
    setKeyAndValue(szVerIndProgID, L"CLSID", szCLSID) ;
    setKeyAndValue(szVerIndProgID, L"CurVer", szProgID) ;

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szProgID, NULL, szFriendlyName);
    setKeyAndValue(szProgID, L"CLSID", szCLSID) ;

    return S_OK;
}

/////////////////////////////////////////////////////////
// Remove the component from the registry.
//
LONG UnregisterServer(  const CLSID& clsid,
                        const WCHAR* szVerIndProgID,
                        const WCHAR* szProgID)
{
    // Convert the CLSID into a char.
    WCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

    // Build the key CLSID\\{...}
    WCHAR szKey[80] ;
    lstrcpy(szKey, L"CLSID\\");
    lstrcat(szKey, szCLSID) ;

    // Check for a another server for this component.
#ifdef _OUTPROC_SERVER_
    if (SubkeyExists(szKey, L"InprocServer32"))
#else
    if (SubkeyExists(szKey, L"LocalServer32"))
#endif
    {
        // Delete only the path for this server.
#ifdef _OUTPROC_SERVER_
        lstrcat(szKey, L"\\LocalServer32") ;
#else
        lstrcat(szKey, L"\\InprocServer32") ;
#endif
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert(lResult == ERROR_SUCCESS) ;
    }
    else
    {
        // Delete all related keys.
        // Delete the CLSID Key - CLSID\{...}
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the version-independent ProgID Key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the ProgID key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
// Internal helper functions
///////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// Convert a CLSID to a char string.
//
void CLSIDtochar(   const CLSID& clsid,
                    WCHAR* szCLSID,
                    int length)
{
    assert(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
    LPOLESTR sz = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &sz) ;
    assert(SUCCEEDED(hr)) ;
    assert(NULL != sz);

    // Convert from wide characters to non-wide characters.
    lstrcpyn(szCLSID, sz, length);

    // Free memory.
    CoTaskMemFree(sz) ;
}

/////////////////////////////////////////////////////////
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const WCHAR* lpszKeyChild)   // Key to delete.
{
    // Open the child.
    HKEY hKeyChild;
    LONG lRes = RegOpenKeyEx(   hKeyParent, lpszKeyChild, 0,
                                KEY_ALL_ACCESS, &hKeyChild);
    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time;
    WCHAR szBuffer[256];
    DWORD dwSize = 256;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer);
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return lRes;
        }
        dwSize = 256;
    }

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild);
}

/////////////////////////////////////////////////////////
// Determine if a particular subkey exists.
//
BOOL SubkeyExists(const WCHAR* pszPath,    // Path of key to check
                  const WCHAR* szSubkey)   // Key to check
{
    HKEY hKey ;
    WCHAR szKeyBuf[80] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, pszPath) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\") ;
        lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Determine if key exists by trying to open it.
    LONG lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                  szKeyBuf,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey) ;
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hKey) ;
        return TRUE ;
    }
    return FALSE ;
}

/////////////////////////////////////////////////////////
// Create a key and set its value.
//
// This helper function was borrowed and modifed from Kraig Brockschmidt's
// book Inside OLE.
//
BOOL setKeyAndValue(const WCHAR* szKey,
                    const WCHAR* szSubkey,
                    const WCHAR* szValue,
                    const WCHAR* szName)
{
    HKEY hKey;
    WCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey);

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\");
        lstrcat(szKeyBuf, szSubkey );
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(  HKEY_CLASSES_ROOT,
                                    szKeyBuf,
                                    0, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS, NULL,
                                    &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
         RegSetValueEx(hKey, szName, 0, REG_SZ,
                            (BYTE *)szValue,
                            BYTES_REQUIRED_BY_SZ(szValue)
                            );
    }

    RegCloseKey(hKey);
    return TRUE;
}

// value must be at least 1024 in size;
BOOL getKeyAndValue(const WCHAR* szKey,
                    const WCHAR* szSubkey,
                    const WCHAR* szValue,
                    const WCHAR* szName)
{
    HKEY hKey;
    WCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey);

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\");
        lstrcat(szKeyBuf, szSubkey );
    }

        // open key and subkey.
    long lResult = RegOpenKeyEx(  HKEY_CLASSES_ROOT,
                                    szKeyBuf,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hKey) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Get the Value.
    if (szValue != NULL)
    {
                DWORD   dwType, dwBufferSize = GETKEYANDVALUEBUFFSIZE;
                lResult = RegQueryValueEx(hKey, szName, NULL, &dwType, (LPBYTE) szValue, &dwBufferSize);
                if (lResult != ERROR_SUCCESS)
                {
                    RegCloseKey(hKey);
                    return FALSE;
                }
    }

    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\common\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  UTIL.CPP - utilities
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Common utilities for printing out messages

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "util.h"
#include "appdefs.h"
#include <shlwapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <wchar.h>
#include <winsvcp.h>    // for SC_OOBE_MACHINE_NAME_DONE
#include <safeboot.h>   // for SAFEBOOT_DSREPAIR_STR_W


///////////////////////////////////////////////////////////
// Print out the COM/OLE error string for an HRESULT.
//
void ErrorMessage(LPCWSTR message, HRESULT hr)
{
    const WCHAR* sz ;
    if (message == NULL)
    {
        sz = L"The following error occured." ;
    }
    else
    {
        sz = message ;
    }

    void* pMsgBuf;

    ::FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
         NULL,
         hr,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
         (LPWSTR) &pMsgBuf,
         0,
         NULL
    );

    WCHAR buf[256] ;
    wsprintf(buf, L"%s\r\nError: (%x) - %s", sz, hr, (LPWSTR)pMsgBuf) ;

    MessageBox(NULL, buf, L"Utility Error Message Box.", MB_OK) ;

    // Free the buffer.
    LocalFree( pMsgBuf );
}

////////////////////////////////////////////////////////////
//  Check to see if both interfaces are on the same component.
//
BOOL InterfacesAreOnSameComponent(IUnknown* p1, IUnknown* p2)
{
    HRESULT hr = S_OK ;

    // Get the real IUnknown for the first interface.
    IUnknown* pReal1 = NULL ;
    hr = p1->QueryInterface(IID_IUnknown, (void**)&pReal1) ;
    assert(SUCCEEDED(hr)) ;

    // Get the real IUnknown for the second interface.
    IUnknown* pReal2 = NULL ;
    hr = p2->QueryInterface(IID_IUnknown, (void**)&pReal2) ;
    assert(SUCCEEDED(hr)) ;

    // Compare the IUnknown pointers.
    BOOL bReturn = (pReal1 == pReal2) ;

    // Cleanup
    pReal1->Release() ;
    pReal2->Release() ;

    // Return the value.
    return bReturn;
}


///////////////////////////////////////////////////////////
//  IsValidAddress
//
BOOL IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    return (lp != NULL && !::IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !::IsBadWritePtr((LPVOID)lp, nBytes)));
}


///////////////////////////////////////////////////////////
//  MyDebug
//
#if ASSERTS_ON
VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s%s",
        LineNumber,
        FileName,
        Condition,
        "\n\nCall DebugBreak()?"
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}
#endif


///////////////////////////////////////////////////////////
//  Trace
//
void __cdecl MyTrace(LPCWSTR lpszFormat, ...)
{
    USES_CONVERSION;
    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512];

    nBuf = _vsnwprintf(szBuffer, MAX_CHARS_IN_BUFFER(szBuffer), lpszFormat, args);

    // was there an error? was the expanded string too long?
    assert(nBuf > 0);

#if DBG
    DbgPrintEx( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, W2A(szBuffer) );
#endif

    va_end(args);
}


//BUGBUG need bettter default
bool GetString(HINSTANCE hInstance, UINT uiID, LPWSTR szString, UINT uiStringLen)
{
    // BUGBUG: Should this assume current module if hInstance is NULL??
    MYASSERT(NULL != hInstance);
    if (NULL != hInstance)
            return (0 < LoadString(hInstance, uiID, szString, uiStringLen));
    else
            return (false);
}


// the goal of this function is to be able to able to get to
// c:\windows dir\system dir\oobe\oobeinfo.ini
// c:\windows dir\system dir\oeminfo.ini
// c:\windows dir\oemaudit.oem
// the canonicalize allows the specification for oemaudit.oem to be ..\oemaudit.oem

bool GetCanonicalizedPath(LPWSTR szCompletePath, LPCWSTR szFileName)
{
    if (0 < GetSystemDirectory(szCompletePath, MAX_PATH))
    {
                lstrcat(szCompletePath, szFileName);

        WCHAR szLocal[MAX_PATH];
                lstrcpy(szLocal, szCompletePath);
                return PathCanonicalize(szCompletePath, (LPCWSTR) szLocal) ? true : false;
    }

    return false;
}

bool GetOOBEPath(LPWSTR szOOBEPath)
{
    if (0 < GetSystemDirectory(szOOBEPath, MAX_PATH))
    {
                lstrcat(szOOBEPath, L"\\OOBE");

                return true;
    }

    return false;
}

// This returns the path for the localized OOBE files on a system with MUI.
//
bool GetOOBEMUIPath(LPWSTR szOOBEPath)
{
    LANGID  UILang;
    WCHAR   szMUIPath[MAX_PATH];

    if (GetOOBEPath(szOOBEPath))
    {
                UILang = GetUserDefaultUILanguage();
                if ( UILang != GetSystemDefaultUILanguage() ) {
                    wsprintf( szMUIPath, L"\\MUI\\%04x", UILang );
                    lstrcat(szOOBEPath, szMUIPath );
                }

                return true;
    }

    return false;
}

HRESULT GetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    WCHAR szSectionName[MAX_PATH], szKeyName[MAX_PATH];
    WCHAR szItem[1024]; //bugbug bad constant

        if (GetString(hInstance, uiSectionName, szSectionName) && GetString(hInstance, uiKeyName, szKeyName))
        {
                WCHAR szINIPath[MAX_PATH];
                if (GetCanonicalizedPath(szINIPath, szINIFileName))
                {
                        if (VT_I4 == V_VT(pvResult))
                        {
                                V_I4(pvResult) = GetPrivateProfileInt(szSectionName, szKeyName, 0, szINIPath);
                                return S_OK;
                        }
                        else
                        {
                                if (GetPrivateProfileString(
                                                szSectionName,
                                                szKeyName,
                                                L"",
                                                szItem,
                                                MAX_CHARS_IN_BUFFER(szItem),
                                                szINIPath))
                                {
                                    V_BSTR(pvResult) = SysAllocString(szItem);
                                    return S_OK;
                                }
                        }
                }
        }

        if (VT_BSTR == V_VT(pvResult))
                V_BSTR(pvResult) = SysAllocString(L"\0");
    else
                V_I4(pvResult) = 0;

        return S_OK;
}


HRESULT GetINIKeyBSTR(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    VariantInit(pvResult);
    V_VT(pvResult) = VT_BSTR;

        return (GetINIKey(hInstance, szINIFileName, uiSectionName, uiKeyName, pvResult));
}


HRESULT GetINIKeyUINT(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    VariantInit(pvResult);
    V_VT(pvResult) = VT_I4;

        return (GetINIKey(hInstance, szINIFileName, uiSectionName, uiKeyName, pvResult));
}


HRESULT SetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
	WCHAR szSectionName[MAX_PATH], szKeyName[MAX_PATH];

    VariantInit(pvResult);
    V_VT(pvResult) = VT_BSTR;

        if (GetString(hInstance, uiSectionName, szSectionName) && GetString(hInstance, uiKeyName, szKeyName))
        {
            if (WritePrivateProfileString(V_BSTR(pvResult), szKeyName,
                                          V_BSTR(pvResult), szINIFileName))
            {
                    return S_OK;
            }
        }

        return E_FAIL;
}



void WINAPI URLEncode(WCHAR* pszUrl, size_t bsize)
{
    if (!pszUrl)
        return;
    WCHAR* pszEncode = NULL;
    WCHAR* pszEStart = NULL;
    WCHAR* pszEEnd   = (WCHAR*)wmemchr( pszUrl, L'\0', bsize );
    int   iUrlLen   = (int)(pszEEnd-pszUrl);
    pszEEnd = pszUrl;

    WCHAR  c;
    size_t cch = (iUrlLen+1) * sizeof(WCHAR) * 3;

    assert( cch <= bsize );
    if (cch <= bsize)
    {

        pszEncode = (WCHAR*)malloc(BYTES_REQUIRED_BY_CCH(cch));
        if(pszEncode)
        {
            pszEStart = pszEncode;
            ZeroMemory(pszEncode, BYTES_REQUIRED_BY_CCH(cch));

            for(; c = *(pszUrl); pszUrl++)
            {
                switch(c)
                {
                    case L' ': //SPACE
                        memcpy(pszEncode, L"+", 1*sizeof(WCHAR));
                        pszEncode+=1;
                        break;
                    case L'#':
                        memcpy(pszEncode, L"%23", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'&':
                        memcpy(pszEncode, L"%26", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'%':
                        memcpy(pszEncode, L"%25", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'=':
                        memcpy(pszEncode, L"%3D", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'<':
                        memcpy(pszEncode, L"%3C", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'+':
                        memcpy(pszEncode, L"%2B", 3*sizeof(WCHAR));
                        pszEncode += 3;
                        break;

                    default:
                        *pszEncode++ = c;
                        break;
                }
            }
            *pszEncode++ = L'\0';
            memcpy(pszEEnd ,pszEStart, (size_t)(pszEncode - pszEStart));
            free(pszEStart);
        }
    }
}


//BUGBUG:  Need to turn spaces into "+"
void WINAPI URLAppendQueryPair
(
    LPWSTR   lpszQuery,
    LPWSTR   lpszName,
    LPWSTR   lpszValue  OPTIONAL
)
{
    // Append the Name
    lstrcat(lpszQuery, lpszName);
    lstrcat(lpszQuery, cszEquals);

    // Append the Value
    if ( lpszValue ) {
        lstrcat(lpszQuery, lpszValue);
    }

    // Append an Ampersand if this is NOT the last pair
    lstrcat(lpszQuery, cszAmpersand);
}


void GetCmdLineToken(LPWSTR *ppszCmd, LPWSTR pszOut)
{
    LPWSTR  c;
    int     i = 0;
    BOOL    fInQuote = FALSE;

    c = *ppszCmd;

    pszOut[0] = *c;
    if (!*c)
        return;
    if (*c == L' ')
    {
        pszOut[1] = L'\0';
        *ppszCmd = c+1;
        return;
    }
    else if( L'"' == *c )
    {
        fInQuote = TRUE;
    }

NextChar:
    i++;
    c++;
    if( !*c || (!fInQuote && (*c == L' ')) )
    {
        pszOut[i] = L'\0';
        *ppszCmd = c;
        return;
    }
    else if( fInQuote && (*c == L'"') )
    {
        fInQuote = FALSE;
        pszOut[i] = *c;

        i++;
        c++;
        pszOut[i] = L'\0';
        *ppszCmd = c;
        return;
    }
    else
    {
        pszOut[i] = *c;
        goto NextChar;
    }
}


BOOL IsOEMDebugMode()
{
    HKEY   hKey      = NULL;
    DWORD  dwIsDebug = 0;
    DWORD  dwSize    = sizeof(dwIsDebug);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    OOBE_MAIN_REG_KEY,
                    0,
                    KEY_QUERY_VALUE,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                        OOBE_OEMDEBUG_REG_VAL,
                        0,
                        NULL,
                        (LPBYTE)&dwIsDebug,
                        &dwSize);
        RegCloseKey(hKey);
    }
#ifdef DEBUG
    return (BOOL)1;
#else
    return (BOOL)dwIsDebug;
#endif
}

VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg, NULL, 0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}

BOOL
IsThreadActive(
    HANDLE              hThread
    )
{
    DWORD               dwExitCode = 0;

    return (NULL != hThread
            && GetExitCodeThread(hThread, &dwExitCode)
            && STILL_ACTIVE == dwExitCode
            );
}

void GetDesktopDirectory(WCHAR* pszPath)
{
    WCHAR pszFolder[MAX_PATH];
    *pszFolder = L'\0';
    HRESULT hRet = SHGetFolderPath(NULL, CSIDL_COMMON_DESKTOPDIRECTORY,
                                   NULL, 0, pszFolder
                                   );
    if (S_OK != hRet)
    {
        hRet = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY,
                               NULL, 0, pszFolder
                               );
    }

    if (S_OK == hRet)
    {
        lstrcpy(pszPath , pszFolder);
    }


}

void RemoveDesktopShortCut
(
    LPWSTR lpszShortcutName
)
{
    WCHAR szShortcutPath[MAX_PATH] = L"\0";

    GetDesktopDirectory(szShortcutPath);

    if(szShortcutPath[0] != L'\0')
    {
        lstrcat(szShortcutPath, L"\\");
        lstrcat(szShortcutPath, lpszShortcutName);
        lstrcat(szShortcutPath, L".LNK");
        DeleteFile(szShortcutPath);
    }
}

BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    )

/*++

Routine Description:

    Invokes an external program, which is optionally detached.

Arguments:

    ApplicationName - supplies app name. May be a partial or full path,
        or just a filename, in which case the standard win32 path search
        is performed. If not specified then the first element in
        CommandLine must specify the binary to execute.

    CommandLine - supplies the command line to be passed to the
        application.

    ExitCode - If specified, the execution is synchronous and this value
        receives the exit code of the application. If not specified,
        the execution is asynchronous.

Return Value:

    Boolean value indicating whether the process was started successfully.

--*/

{
    PWSTR FullCommandLine;
    BOOL b;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    DWORD d;

    b = FALSE;
    //
    // Form the command line to be passed to CreateProcess.
    //
    if(ApplicationName) {
        FullCommandLine =
            (PWSTR) malloc(BYTES_REQUIRED_BY_SZ(ApplicationName)+BYTES_REQUIRED_BY_SZ(CommandLine)+BYTES_REQUIRED_BY_CCH(2));
        if(!FullCommandLine) {
            goto err0;
        }

        lstrcpy(FullCommandLine, ApplicationName);
        lstrcat(FullCommandLine, L" ");
        lstrcat(FullCommandLine, CommandLine);
    } else {
        FullCommandLine =
            (PWSTR) malloc(BYTES_REQUIRED_BY_SZ(CommandLine));
        if(!FullCommandLine) {
	    goto err0;
        }
        lstrcpy(FullCommandLine, CommandLine);
    }

    //
    // Initialize startup info.
    //
    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    //
    // Create the process.
    //
    b = CreateProcess(
            NULL,
            FullCommandLine,
            NULL,
            NULL,
            FALSE,
            ExitCode ? 0 : DETACHED_PROCESS,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInfo
            );

    if(!b) {
        goto err1;
    }

    //
    // If execution is asynchronus, we're done.
    //
    if(!ExitCode) {
        goto err2;
    }

err2:
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
err1:
    free(FullCommandLine);
err0:
    return(b);
}



//////////////////////////////////////////////////////////////////////////////
//
//  InSafeMode
//
//  Determine whether the system is running in safe mode or clean mode.
//
//  parameters:
//      None.
//
//  returns:
//      TRUE        if the system was booted in safe mode
//      FALSE       if the system was booted in clean mode
//
//////////////////////////////////////////////////////////////////////////////
BOOL
InSafeMode()
{
    if (BOOT_CLEAN != GetSystemMetrics(SM_CLEANBOOT))
    {
        TRACE(L"Running in SAFEMODE...");
        return TRUE;
    }
    return FALSE;

}   //  InSafeMode



//////////////////////////////////////////////////////////////////////////////
//
//  InDsRestoreMode
//
//  Determine whether the system is running in Directory Services Restore Mode
//
//  parameters:
//      None.
//
//  returns:
//      TRUE        if the system was booted in restore mode
//      FALSE       if the system was not booted in restore mode
//
//////////////////////////////////////////////////////////////////////////////
BOOL
InDsRestoreMode()
{
    WCHAR SafeBootEnvVar[ARRAYSIZE(SAFEBOOT_DSREPAIR_STR_W)] = L"\0";


    if ( GetEnvironmentVariableW( L"SAFEBOOT_OPTION",
                                  SafeBootEnvVar,
                                  ARRAYSIZE(SafeBootEnvVar) ) )
    {
        if ( wcscmp( SafeBootEnvVar, SAFEBOOT_DSREPAIR_STR_W ) == 0 )
        {
            TRACE(L"Running in DS Restore Mode...");
            return TRUE;
        }
    }

    return FALSE;

}   //  InDsRestoreMode



// Signal winlogon that the computer name has been changed.  WinLogon waits to
// start services that depend on the computer name until this event is
// signalled.
//
BOOL
SignalComputerNameChangeComplete()
{
    BOOL                fReturn = TRUE;

    // Open event with EVENT_ALL_ACCESS so that synchronization and state
    // change can be done.
    //
    HANDLE              hevent = OpenEvent(EVENT_ALL_ACCESS,
                                           FALSE,
                                           SC_OOBE_MACHINE_NAME_DONE
                                           );

    // It is not fatal for OpenEvent to fail: this synchronization is only
    // required when OOBE will be run in OEM mode.
    //
    if (NULL != hevent)
    {
        if (! SetEvent(hevent))
        {
            // It is fatal to open but not set the event: services.exe will not
            // continue until this event is signalled.
            //
            TRACE2(L"Failed to signal SC_OOBE_MACHINE_NAME_DONE(%s): 0x%08X\n",
                  SC_OOBE_MACHINE_NAME_DONE, GetLastError());
            fReturn = FALSE;
        }
        MYASSERT(fReturn);  // Why did we fail to set an open event??
    }

    return fReturn;
}


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;


    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}

#define MyMalloc(s)                  GlobalAlloc(GPTR, s)
#define MyFree(p)                    GlobalFree(p)

static LPTSTR
pDuplicateString(
    LPCTSTR szText
    )
{
    int    cchText;
    LPTSTR szOutText;

    if (szText == NULL)
    {
        return NULL;
    }

    cchText = lstrlen(szText);
    szOutText = (LPTSTR) MyMalloc(sizeof(TCHAR) * (cchText + 1));
    if (szOutText)
    {
        lstrcpyn(szOutText, szText, cchText + 1);
    }

    return szOutText;
}


PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    )
{
    PSTRINGLIST p = (PSTRINGLIST) MyMalloc (sizeof (STRINGLIST));
    if (p) {
        ZeroMemory (p, sizeof (STRINGLIST));
        if (String) {
            p->String = pDuplicateString (String);
            if (!p->String) {
                MyFree (p);
                p = NULL;
            }
        } else {
            p->String = NULL;
        }
    }
    return p;
}

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    )
{
    if (Cell) {
        MyFree (Cell->String);
        MyFree (Cell);
    }
}


BOOL
InsertList (
    IN OUT  PSTRINGLIST* List,
    IN      PSTRINGLIST NewList
    )
{
    PSTRINGLIST p;

    if (!NewList) {
        return FALSE;
    }
    if (*List) {
        for (p = *List; p->Next; p = p->Next) ;
        p->Next = NewList;
    } else {
        *List = NewList;
    }
    return TRUE;
}

VOID
DestroyList (
    IN      PSTRINGLIST List
    )
{
    PSTRINGLIST p, q;

    for (p = List; p; p = q) {
        q = p->Next;
        DeleteStringCell (p);
    }
}

BOOL
RemoveListI(
    IN OUT  PSTRINGLIST* List,
    IN      PCTSTR       String
    )
{
    PSTRINGLIST p = *List;
    BOOL        b = FALSE;

    if (p)
    {
        if (!lstrcmpi(p->String, String))
        {
            *List = p->Next;
            DeleteStringCell(p);
            b = TRUE;
        }
        else
        {
            PSTRINGLIST q;
            for (q = p->Next; q; p = q, q = q->Next)
            {
                if (!lstrcmpi(q->String, String))
                {
                    p->Next = q->Next;
                    DeleteStringCell(q);
                    b = TRUE;
                    break;
                }
            }
        }
    }

    return b;
}

BOOL
ExistInListI(
    IN PSTRINGLIST List,
    IN PCTSTR      String
    )
{
    PSTRINGLIST p;

    for (p = List; p; p = p->Next)
    {
        if (!lstrcmpi(p->String, String))
        {
            break;
        }
    }

    return (p != NULL);
}

BOOL IsDriveNTFS(IN TCHAR Drive)
{
    TCHAR       DriveName[4];
    TCHAR       Filesystem[256];
    TCHAR       VolumeName[MAX_PATH];
    DWORD       SerialNumber;
    DWORD       MaxComponent;
    DWORD       Flags;
    BOOL        bIsNTFS = FALSE;

    DriveName[0] = Drive;
    DriveName[1] = TEXT(':');
    DriveName[2] = TEXT('\\');
    DriveName[3] = 0;

    if (GetVolumeInformation(
            DriveName,
            VolumeName,MAX_PATH,
            &SerialNumber,
            &MaxComponent,
            &Flags,
            Filesystem,
            sizeof(Filesystem)/sizeof(TCHAR)
            ))
    {
        bIsNTFS = (lstrcmpi(Filesystem,TEXT("NTFS")) == 0);
    }

    return bIsNTFS;
}

BOOL
HasTablet()
{
    TCHAR szPath[MAX_PATH+1];

    ZeroMemory(szPath, sizeof(szPath));

    if (FAILED(SHGetFolderPath(
        NULL,
        CSIDL_PROGRAM_FILES_COMMON,
        NULL,
        SHGFP_TYPE_DEFAULT,
        szPath)))
    {
        return FALSE;
    }

    StrCatBuff(szPath, TEXT("\\Microsoft Shared\\Ink\\tabtip.exe"), MAX_PATH+1);

    return PathFileExists(szPath);
}

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    )
{
    DWORD d = GetModuleFileName (Module, Buffer, BufferLength);

    if (BufferLength > 0)
    {
        Buffer[BufferLength - 1] = 0;
    }

    if (d < BufferLength)
    {
        return d;
    }
    else
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\html\makefile.inc ===
.SUFFIXES: .csx .htx .jsx

{}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{}.jsx{$O\}.js:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{error\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{actsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{actsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\dslmain\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\iconnect\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\ispsgnup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\isptype\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\migwiz\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\mouse\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemcust\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemhw\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemreg\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\sconnect\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{icserror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{isperror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnerror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{newoobe\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{newoobe\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regerror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{sample\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{setup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\appdefs.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  APPDEFS.H - Header for application wide defines, typedefs, etc
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
// Header for application wide defines, typedefs, etc

#ifndef _APPDEFS_H_
#define _APPDEFS_H_

#include <windows.h>
#include <wtypes.h>
#include <oleauto.h>
#include <malloc.h>

#define OOBE_DIR                        L"\\OOBE"
#define OOBE_SHELL_DLL                  L"MSOBSHEL.DLL"
#define OOBE_MAIN_DLL                   L"MSOBMAIN.DLL"
#define OOBE_WEB_DLL                    L"MSOBWEB.DLL"
#define OOBE_COMM_DLL                   L"MSOBCOMM.DLL"
#define OOBE_EXE                        L"MSOOBE.EXE"
#define OOBEBALN_EXE                    L"OOBEBALN.EXE"
#define ICW_APP_TITLE                   L"INETWIZ.EXE"

#define OOBE_MAIN_CLASSNAME             L"MSOBMAIN_AppWindow"
#define OOBE_MAIN_WINDOWNAME            L"Microsoft Out of Box Experience"
#define OBSHEL_MAINPANE_CLASSNAME       L"MSOBSHEL_MainPane"
#define OBSHEL_MAINPANE_WINDOWNAME      L"ObShellMainPane"
#define OBSHEL_STATUSPANE_CLASSNAME     L"MSOBSHEL_StatPane"
#define OBSHEL_STATUSPANE_WINDOWNAME    L"CObShellStatusPane"

#define OBSHEL_STATUSPANE_MINITEM       0
#define OBSHEL_STATUSPANE_MAXITEM       8

//Window size for standalone operation
#define MSN_WIDTH                       640
#define MSN_HEIGHT                      530

//These MUST be ANSI for GetProcAddress
#define MSOBMAIN_ENTRY                  "LaunchMSOOBE"
#define REG_SERVER                      "DllRegisterServer"
#define UNREG_SERVER                    "DllUnregisterServer"

#define DEFAULT_FRAME_NAME              L"msoobeMain"
#define DEFAULT_FRAME_PAGE              L"msobshel.htm"
#define MSN_FRAME_PAGE                  L"dtsgnup.htm"
#define REG_FRAME_PAGE                  L"regshell.htm"
#define ISP_FRAME_PAGE                  L"ispshell.htm"
#define ACT_FRAME_PAGE                  L"actshell.htm"
#define DEFAULT_START_PAGE              L"\\setup\\welcome.htm"
#define DEFAULT_STATUS_PAGE             L"/STATPANE_RESOURCE"
#define IFRMSTATUSPANE                  L"ifrmStatusPane"
#define WINNT_INF_FILENAME              L"\\$winnt$.inf"
#define OOBE_PATH                       L"\\oobe\\msoobe.exe"
#define OOBE_BALLOON_REMINDER           L"\\oobe\\oobebaln.exe"
#define DATA_SECTION                    L"data"
#define WINNT_UPGRADE                   L"winntupgrade"
#define WIN9X_UPGRADE                   L"win9xupgrade"
#define YES_ANSWER                      L"yes"
#define OOBE_PROXY_SECTION              L"OobeProxy"
#define OOBE_ENABLE_OOBY_PROXY          L"Enable"
#define OOBE_FLAGS                      L"Flags"
#define OOBE_PROXY_SERVER               L"Proxy_Server"
#define OOBE_PROXY_BYPASS               L"Proxy_Bypass"
#define OOBE_AUTOCONFIG_URL             L"Autoconfig_URL"
#define OOBE_AUTODISCOVERY_FLAGS        L"Autodiscovery_Flag"
#define OOBE_AUTOCONFIG_SECONDARY_URL   L"Autoconfig_Secondary_URL"


#define OOBE_MAIN_REG_KEY               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE"
#define REG_KEY_OOBE_TEMP               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\Temp"
#define REG_KEY_OOBE_CKPT               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\CKPT"
#define REG_KEY_OOBE_ICS                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\ics"
#define REG_KEY_OOBE_STATUS             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\status"
#define REG_KEY_WINDOWS                 L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define REG_KEY_SETUP                   L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define RUNONCE_REGKEY                  L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define IE_APP_PATH_REGKEY              L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"
#define NOEULA_REGKEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define REG_KEY_CONFIG_DISPLAY          L"Config\\0001\\Display\\Settings"
#define RUNONCE_IE_ENTRY                L"^BrowseNow"
#define OOBE_OEMDEBUG_REG_VAL           L"OEMDebug"
#define OOBE_MSDEBUG_REG_VAL            L"MsDebug"
#define REG_VAL_OOBE                    L"OOBE"
#define REG_VAL_REBOOT                  L"DontReboot"
#define REG_VAL_RES                     L"Resolution"
#define REG_VAL_ISPSIGNUP               L"ISPSignup"
#define REG_VAL_NOEULA                  L"WelcomeHelpString"
#define OOBE_SKIP_EULA_VAL              L"Welcome to Microsoft Windows."
#define REG_VAL_COMPUTERDESCRIPTION     L"ComputerDescription"

#define OOBE_EVENT_NOEXITCODE           L"OOBE_Event_NoExitCode"

////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
//??? This is for OOBEINFO.INI

#define INI_SETTINGS_FILENAME           L"\\oobe\\OOBEINFO.INI"
#define OEMINFO_INI_FILENAME            INI_SETTINGS_FILENAME
#define DEFAULT_WINDOW_TEXT             L"Microsoft Out of Box Experience"
#define MSN_WINDOW_TEXT                 L"MSN Setup"

////////////////////////////////////
////////////////////////////////////
//SECTION :: StartupOptions
#define STARTUP_OPTIONS_SECTION         L"StartupOptions"
//KEYS:
#define OOBE_FULLSCREEN_MODE            L"FullScreenMode"
#define OOBE_FULLSCREEN_MODE_DEFAULT    1
#define OOBE_DESKTOP_URL               L"DesktopStartUrl"
#define OOBE_DESKTOP_URL_DEFAULT        MSN_FRAME_PAGE
#define OOBE_DESKTOP_TITLE             L"DesktopWindowTitle"
#define OOBE_DESKTOP_TITLE_DEFAULT     DEFAULT_WINDOW_TEXT
#define OOBE_DESKTOP_HEIGHT            L"DesktopWindowHeight"
#define OOBE_DESKTOP_HEIGHT_DEFAULT    MSN_HEIGHT
#define OOBE_DESKTOP_WIDTH             L"DesktopWindowWidth"
#define OOBE_DESKTOP_WIDTH_DEFAULT     MSN_WIDTH
#define OOBE_SCREEN_RES_CHECK          L"ScreenResolutionCheck"
#define OOBE_SCREEN_RES_CHECK_DEFAULT  1
#define OOBE_OEMAUDITBOOT              L"OEMAuditBoot"

////////////////////////////////////
////////////////////////////////////
//SECTION :: StartupOptions
#define STATUS_PANE_SECTION             L"StatusPane"
//KEYS:
#define STATUS_PANE_ITEM                L"Item_text_%d"
#define STATUS_PANE_LOGO                L"Logo"
#define STATUS_PANE_LOGO_BACKGROUND     L"LogoBackground"
#define REGISTRATION                    L"Registration"

////////////////////////////////////
////////////////////////////////////
//SECTION :: WindowsLogon
#define WINDOWS_LOGON_SECTION           L"WindowsLogon"
//KEYS:
#define AUTOLOGON                       L"AutoLogon"
#define DEFAULT_USER_NAME               L"DefaultUserName"

////////////////////////////////////
////////////////////////////////////
//SECTION :: HardwareOptions
#define OPTIONS_SECTION                L"Options"
//KEYS:
#define TONEPULSE                      L"TonePulse"
#define CHECK_KEYBOARD                 L"USBKeyboard"
#define CHECK_MOUSE                    L"USBMouse"
#define AREACODE                       L"Areacode"
#define OUTSIDELINE                    L"OutsideLine"
#define DISABLECALLWAITING             L"DisableCallWaiting"
#define DEFAULT_REGION                 L"DefaultRegion"
#define DEFAULT_LANGUAGE               L"DefaultLanguage"
#define DEFAULT_KEYBOARD               L"DefaultKeyboard"
#define CHECK_MODEMGCI                 L"CheckModemGCI"
#define USE_1394_AS_LAN                L"Use1394AsLan"

#define NOUSBKBD_FILENAME              L"\\oobe\\setup\\nousbkbd.htm"
#define NOUSBMS_FILENAME               L"\\oobe\\setup\\nousbms.htm"
#define NOUSBKM_FILENAME               L"\\oobe\\setup\\nousbkm.htm"

////////////////////////////////////
////////////////////////////////////
//SECTION :: DesktopReminders
#define DESKTOPREMINDERS_SECTION       L"DesktopReminders"
//KEYS:
#define REGREMINDERX                   L"RegRemind%1d"
#define ISPREMINDERX                   L"ISPRemind%1d"



////////////////////////////////////
////////////////////////////////////
//SECTION :: UserInfo
#define USER_INFO_KEYNAME                L"UserInfo"


////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
//??? ISP file

////////////////////////////////////
////////////////////////////////////
//SECTION :: URL
#define ISP_FILE_URL_SECTION            L"URL"
//KEYS:
#define ISP_FILE_SIGNUP_URL             L"Signup"

////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
// These are the command line option used by MSoobe.exe

#define CMD_FULLSCREENMODE              L"/F"
#define CMD_MSNMODE                     L"/x"
#define CMD_ICWMODE                     L"/xicw"
#define CMD_PRECONFIG                   L"/preconfig"
#define CMD_OFFLINE                     L"/offline"
#define CMD_SHELLNEXT                   L"/shellnext"
#define CMD_SETPWD                      L"/setpwd"
#define CMD_OOBE                        L"/oobe"
#define CMD_REG                         L"/r"
#define CMD_ISP                         L"/i"
#define CMD_ACTIVATE                    L"/a"
#define CMD_1                           L"/1"
#define CMD_2                           L"/2"
#define CMD_3                           L"/3"
#define CMD_RETAIL                      L"/retail"
#define CMD_2NDINSTANCE                 L"/2ND"

const WCHAR cszEquals[]               = L"=";
const WCHAR cszAmpersand[]            = L"&";
const WCHAR cszPlus[]                 = L"+";
const WCHAR cszQuestion[]             = L"?";
const WCHAR cszFormNamePAGEID[]       = L"PAGEID";
const WCHAR cszFormNameBACK[]         = L"BACK";
const WCHAR cszFormNamePAGETYPE[]     = L"PAGETYPE";
const WCHAR cszFormNameNEXT[]         = L"NEXT";
const WCHAR cszFormNamePAGEFLAG[]     = L"PAGEFLAG";
const WCHAR cszPageTypeTERMS[]        = L"TERMS";
const WCHAR cszPageTypeCUSTOMFINISH[] = L"CUSTOMFINISH";
const WCHAR cszPageTypeFINISH[]       = L"FINISH";
const WCHAR cszPageTypeNORMAL[]       = L"";
const WCHAR cszOLSRegEntries[]        = L"regEntries";
const WCHAR cszKeyName[]              = L"KeyName";
const WCHAR cszEntry_Name[]           = L"Entry_Name";
const WCHAR cszEntryName[]            = L"EntryName";
const WCHAR cszEntryValue[]           = L"EntryValue";
const WCHAR cszOLSDesktopShortcut[]   = L"DesktopShortcut";
const WCHAR cszSourceName[]           = L"SourceName";
const WCHAR cszTargetName[]           = L"TargetName";

//Htm pagetype flags
#define PAGETYPE_UNDEFINED                     E_FAIL
#define PAGETYPE_NOOFFERS                      0x00000001
#define PAGETYPE_MARKETING                     0x00000002
#define PAGETYPE_BRANDED                       0x00000004
#define PAGETYPE_BILLING                       0x00000008
#define PAGETYPE_CUSTOMPAY                     0x00000010
#define PAGETYPE_ISP_NORMAL                    0x00000020
#define PAGETYPE_ISP_TOS                       0x00000040
#define PAGETYPE_ISP_FINISH                    0x00000080
#define PAGETYPE_ISP_CUSTOMFINISH              0x00000100
#define PAGETYPE_OLS_FINISH                    0x00000200

//Htm page flags
#define PAGEFLAG_SAVE_CHKBOX                   0x00000001  // Display ISP HTML with checkbox to save info at the bottom

//??????????????????????????????????????????????????????????????
////////////////////////////////////////////////////////////////

#define WM_OBCOMM_ONDIALERROR           WM_USER + 42
#define WM_OBCOMM_ONDIALING             WM_USER + 43
#define WM_OBCOMM_ONCONNECTING          WM_USER + 44
#define WM_OBCOMM_ONCONNECTED           WM_USER + 45
#define WM_OBCOMM_ONDISCONNECT          WM_USER + 46
#define WM_OBCOMM_ONSERVERERROR         WM_USER + 47
#define WM_OBCOMM_DOWNLOAD_PROGRESS     WM_USER + 50
#define WM_OBCOMM_DOWNLOAD_DONE         WM_USER + 51
#define WM_AGENT_HELP                   WM_USER + 52
#define WM_OBCOMM_ONICSCONN_STATUS      WM_USER + 53
#define WM_OBCOMM_DIAL_DONE             WM_USER + 54
#define WM_OBCOMM_NETCHECK_DONE         WM_USER + 56

#define WM_OBMAIN_QUIT                  WM_USER + 48
#define WM_OBMAIN_SERVICESSTART_DONE    WM_USER + 55
#define WM_OBMAIN_ASYNCINVOKE_DONE      WM_USER + 57
#define WM_OBMAIN_ASYNCINVOKE_FAILED    WM_USER + 58

#define WM_OBBACKGROUND_EXIT            WM_USER + 60
#define WM_OBMY_STATUS                  WM_USER + 61

#define WM_SKIP                         WM_USER + 0x3000


#define TIMER_DELAY                     100

#define IDT_OBMAIN_HANDSHAKE_TIMER      1001
#define IDT_OBMAIN_LICENSE_TIMER        1002


#define MAX_DISP_NAME                   50
#define MAX_RES_LEN                     256

// APP Mode enumeration.
typedef enum
{
    APMD_DEFAULT,
    APMD_OOBE,
    APMD_REG,
    APMD_ISP,
    APMD_MSN,
    APMD_ACT
} APMD;

// APP properties
#define PROP_FULLSCREEN     0x80000000
#define PROP_OOBE_OEM       0x00000001
#define PROP_SETCONNECTIOD  0x10000000
#define PROP_2NDINSTANCE    0x20000000
#define PROP_CALLFROM_MSN   0x40000000

// Registration post defines.
#define POST_TO_OEM                     0x0000001
#define POST_TO_MS                      0x0000002

// reminder types.
#define REMIND_REG          0
#define REMIND_ISP          1

// Activation errors
#define ERR_ACT_UNINITIALIZED          -1
#define ERR_ACT_SUCCESS                 0
#define ERR_ACT_INACCESSIBLE            1
#define ERR_ACT_INVALID_PID             2
#define ERR_ACT_USED_PID                3
#define ERR_ACT_INTERNAL_WINDOWS_ERR    4
#define ERR_ACT_BLOCKED_PID             5
#define ERR_ACT_CORRUPTED_PID           6
#define ERR_ACT_NETWORK_FAILURE         7

// Audit mode values
#define NO_AUDIT            0
#define NONE_RESTORE_AUDIT  1
#define RESTORE_AUDIT       2
#define SIMULATE_ENDUSER    3

#define ICW_OS_VER                             L"01"
#define ICW_ISPINFOPath                        L"download\\ispinfo.csv"

//various flags for the icw including branding stuff
#define ICW_CFGFLAG_OFFERS                     0x00000001  // 0 = No offer;        1 = offers
#define ICW_CFGFLAG_AUTOCONFIG                 0x00000002  // 0 = No;              1 = Yes
#define ICW_CFGFLAG_CNS                        0x00000004  // 0 = No star;         1 = Star
#define ICW_CFGFLAG_SIGNUP_PATH                0x00000008  // 0 = Jump to Finish;  1 = Continue down sign up path
#define ICW_CFGFLAG_USERINFO                   0x00000010  // 0 = Hide name/addr;  1 = Show name/addr page
#define ICW_CFGFLAG_BILL                       0x00000020  // 0 = Hide bill        1 = Show bill page
#define ICW_CFGFLAG_PAYMENT                    0x00000040  // 0 = Hide payment;    1 = Show payment page
#define ICW_CFGFLAG_SECURE                     0x00000080  // 0 = Not secure;      1 = Secure
#define ICW_CFGFLAG_IEAKMODE                   0x00000100  // 0 = No IEAK;         1 = IEAK
#define ICW_CFGFLAG_BRANDED                    0x00000200  // 0 = No branding;     1 = Branding
#define ICW_CFGFLAG_SBS                        0x00000400  // 0 = No SBS           1 = SBS
#define ICW_CFGFLAG_ALLOFFERS                  0x00000800  // 0 = Not all offers   1 = All offers
#define ICW_CFGFLAG_USE_COMPANYNAME            0x00001000  // 0 = Not use          1 = Use company name
#define ICW_CFGFLAG_ISDN_OFFER                 0x00002000  // 0 = Non-ISDN offer   1 = ISDN offer
#define ICW_CFGFLAG_OEM_SPECIAL                0x00004000  // 0 = non OEM special offer    1 = OEM special offer
#define ICW_CFGFLAG_OEM                        0x00008000  // 0 = non OEM offer    1 = OEM offer
#define ICW_CFGFLAG_MODEMOVERRIDE              0x00010000
#define ICW_CFGFLAG_ISPURLOVERRIDE             0x00020000
#define ICW_CFGFLAG_PRODCODE_FROM_CMDLINE      0x00040000
#define ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE     0x00080000
#define ICW_CFGFLAG_OEMCODE_FROM_CMDLINE       0x00100000
#define ICW_CFGFLAG_SMARTREBOOT_NEWISP         0x00200000
#define ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG     0x00400000  // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
#define ICW_CFGFLAG_SMARTREBOOT_MANUAL         0x00800000
#define ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS  0x01000000
#define ICW_CFGFLAG_SMARTREBOOT_LAN            0x02000000

#define CONNECTED_REFFERAL                     0x00000001
#define CONNECTED_ISP_SIGNUP                   0x00000002
#define CONNECTED_ISP_MIGRATE                  0x00000003
#define CONNECTED_REGISTRATION                 0x00000004
#define CONNECTED_TYPE_MAX                     5

// Default strings for oem, prod, and promo code
#define DEFAULT_OEMCODE                        L"Default"
#define DEFAULT_PRODUCTCODE                    L"Desktop"
#define DEFAULT_PROMOCODE                      L"Default"

#define UPGRADETYPE_NONE                       0
#define UPGRADETYPE_WIN9X                      1
#define UPGRADETYPE_WINNT                      2


const UINT MAXSTATUSITEMS = 10;

typedef struct  dispatchList_tag
{
    WCHAR szName [MAX_DISP_NAME];
    DWORD dwDispID;

}  DISPATCHLIST;

// These macros calculate the bytes required by a string.  The null-terminator
// is accounted for.
//
#define BYTES_REQUIRED_BY_CCH(cch) ((cch + 1) * sizeof(WCHAR))
#define BYTES_REQUIRED_BY_SZ(sz)   ((lstrlen(sz) + 1) * sizeof(WCHAR))

// These macros calculate the number of characters that will fit in a buffer.
// The null-terminator is accounted for.
//
#define MAX_CHARS_IN_BUFFER(buf)    ((sizeof(buf) / sizeof(WCHAR)) - 1)
#define MAX_CHARS_IN_CB(cb)         (((cb) / sizeof(WCHAR)) - 1)

#define ARRAYSIZE(a)                (sizeof(a) / sizeof(a[0]))

#define SZ_EMPTY L"\0"



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
////////
//////// A2W -- AnsiToWide Helper
////////
////////

#define USES_CONVERSION int _convert = 0

inline LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    lpw[0] = L'\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

inline LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA((LPSTR)lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), (LPSTR)lpa, _convert)))


#define A2CW(lpa) ((LPCWSTR)A2W(lpa))

#define A2COLE A2CW

#endif //_APPDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\commerr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  COMMERR.H - Header for the communication manager error definitions
//
//  HISTORY:
//  
//  2/10/99 vyung Created.
// 
//  

#ifndef _COMMERR_H_
#define _COMMERR_H_

//window.external.CheckDialReady
#define ERR_COMM_NO_ERROR             0x00000000        // There is no error
#define ERR_COMM_OOBE_COMP_MISSING    0x00000001        // Some OOBE component is missing
#define ERR_COMM_UNKNOWN              0x00000002        // Unknow error, check input parameters
#define ERR_COMM_NOMODEM              0x00000003        // There is no modem installed
#define ERR_COMM_RAS_TCP_NOTINSTALL   0x00000004        // TCP/IP or RAS is not installed
#define ERR_COMM_ISDN                 0x00000005
#define ERR_COMM_PHONE_AND_ISDN       0x00000006

//window.external.Dial -- RAS events
#define ERR_COMM_RAS_PHONEBUSY        0x00000001
#define ERR_COMM_RAS_NODIALTONE       0x00000002
#define ERR_COMM_RAS_NOMODEM          ERR_COMM_NOMODEM
#define ERR_COMM_RAS_SERVERBUSY       0x00000004
#define ERR_COMM_RAS_UNKNOWN          0x00000005

//window.external.navigate/submit/processins -- server errors
#define ERR_COMM_SERVER_BINDFAILED    0x00000001

//Server errors
#define ERR_SERVER_DNS               0x00000002
#define ERR_SERVER_SYNTAX            0x00000003
#define ERR_SERVER_HTTP_400          0x00000190
#define ERR_SERVER_HTTP_403          0x00000193
#define ERR_SERVER_HTTP_404          0x00000194
#define ERR_SERVER_HTTP_405          0x00000195
#define ERR_SERVER_HTTP_406          0x00000196
#define ERR_SERVER_HTTP_408          0x00000198
#define ERR_SERVER_HTTP_410          0x0000019A
#define ERR_SERVER_HTTP_500          0x000001F4
#define ERR_SERVER_HTTP_501          0x000001F5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\cfactory.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CFACTORY.H - Header file for the Implementation of IClassFactory
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Base class for reusing a single class factory for all
//  components in a DLL.

#ifndef __CFactory_h__
#define __CFactory_h__

#include "cunknown.h"

///////////////////////////////////////////////////////////
// Forward reference.
//
class CFactoryData;

// Global data used by CFactory.
extern CFactoryData g_FactoryDataArray[];
extern int g_cFactoryDataEntries;

//////////////////////////////////////////////////////////////////////////////////////
//  Component creation function pointer.
//
typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**);

//////////////////////////////////////////////////////////////////////////////////////
// typedefs
//
// The special registration function is used to add custom registration and
// unregistration code to the component. It takes a single parameter.
// TRUE = Reg and FALSE = UnReg.
typedef void (*FPSPECIALREGISTRATION)(BOOL);

//////////////////////////////////////////////////////////////////////////////////////
// CFactoryData -
//
// Information CFactory needs to create a component supported
// by the DLL.

class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* m_pCLSID;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;

    // Name of the component to register in the registry
    const WCHAR* m_RegistryName;

    // ProgID
    const WCHAR* m_szProgID;

    // Version independent ProgID
    const WCHAR* m_szVerIndProgID;

    // Helper function for finding the class id
    BOOL IsClassID(const CLSID& clsid) const
        {return (*m_pCLSID == clsid) ;}

    // Function for performing special registration
    FPSPECIALREGISTRATION SpecialRegistration ;

    //----- Out of process server support -----
    
    // Pointer running class factory associated with this component.
    IClassFactory* m_pIClassFactory ;

    // Magic cookie to identify running object
    DWORD m_dwRegister ;
} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:
    // IUnknown
    virtual HRESULT __stdcall QueryInterface(   const IID& iid,
                                                void** ppv) ;
    virtual ULONG   __stdcall AddRef() ;
    virtual ULONG   __stdcall Release() ;
    
    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(   IUnknown* pUnkOuter,
                                                const IID& iid,
                                                void** ppv) ;
    virtual HRESULT __stdcall LockServer(BOOL bLock); 

    // Constructor - Pass pointer to data of component to create.
    CFactory(const CFactoryData* pFactoryData) ;

    // Destructor
    ~CFactory() {/*empty*/ }

    // ----- static FactoryData support functions. -----

    // DllGetClassObject Support
    static HRESULT GetClassObject(  const CLSID& clsid, 
                                    const IID& iid, 
                                    void** ppv);
    
    // Helper function for DllCanUnloadNow 
    static BOOL IsLocked()
        { return (s_cServerLocks > 0) ; }

    // Functions to [Un]Register all components.
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();

    // Functions to determine if component can be unloaded.
    static HRESULT CanUnloadNow();


#ifdef _OUTPROC_SERVER_
    // ----- Out of process server support -----

    static BOOL StartFactories() ;
    static void StopFactories() ;

    static DWORD s_dwThreadID;

    // Shut down the application.
    static void CloseExe()
    {
        if (CanUnloadNow() == S_OK)
        {
            ::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0);
        }
    }
#else
    // CloseExe doesn't do anything if we are in process.
    static void CloseExe() {/*Empty*/} 
#endif

public:
    // Reference Count
    LONG m_cRef;

    // Pointer to information about class this factory creates.
    const CFactoryData* m_pFactoryData;

    // Count of locks
    static LONG s_cServerLocks ;   

    // Module handle
    static HMODULE s_hModule ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\msobstub.h ===
#ifndef     _MSOBSTUB_H_
#define _MSOBSTUB_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: msobstub.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Whistler
//
//  Revision History:
//      000210  dane    Created.
//
//////////////////////////////////////////////////////////////////////////////


#include <windows.h>

// Setup
//
BOOL
ValidateEula(
    LPWSTR              szEulaPath,
    int                 cchEulaPath
    );


#endif  //  _MSOBSTUB_H_

//
///// End of file: msobstub.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\msobdl.h ===
// ############################################################################
#ifndef _ICWDL_H
#define _ICWDL_H

// These are the types of info that are passed back through the callback
#define CALLBACK_TYPE_URL       100
#define CALLBACK_TYPE_PROGRESS  99

// ############################################################################
#define DOWNLOAD_LIBRARY     L"msobdl.dll"
#define DOWNLOADINIT         "DownLoadInit"
#define DOWNLOADEXECUTE      "DownLoadExecute"
#define DOWNLOADCLOSE        "DownLoadClose"
#define DOWNLOADSETSTATUS    "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS      "DownLoadProcess"
#define DOWNLOADCANCEL       "DownLoadCancel"

// ############################################################################
typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPWSTR pszURL, DWORD FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hwndParent);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);

// jmazner  10/2/96  Normandy #8493
// WRONG PROTOTYPE!! This should match icwdl/download.cpp:DownLoadSetStatusCallBack!!
//typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback, DWORD dwContext);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback);

typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

#endif // _ICWDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\setupx32.h ===
/****************************************************************************\

    SETUPX32.H

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

\****************************************************************************/


#ifndef _SETUPX32_H_
#define _SETUPX32_H_

// BUGBUG: IS THIS FILE NECESSARY??

//
// Exporting (this gets rid of the .def)
//

#ifdef SETUPX32_EXPORT
#define DLLExportImport         __declspec(dllexport)
#else
#define DLLExportImport         __declspec(dllimport)
#endif

//
// Audit mode flags.
//

#define SX_AUDIT_NONE           0x00000000
#define SX_AUDIT_NONRESTORE     0x00000001
#define SX_AUDIT_RESTORE        0x00000002
#define SX_AUDIT_ENDUSER        0x00000003
#define SX_AUDIT_AUTO           0x00000100
#define SX_AUDIT_RESTORATIVE    0x00000200
#define SX_AUDIT_ALLOWMANUAL    0x00000400
#define SX_AUDIT_ALLOWENDUSER   0x00000800
#define SX_AUDIT_MODES          0x000000FF
#define SX_AUDIT_FLAGS          0x0000FF00
#define SX_AUDIT_INVALID        0xFFFFFFFF

#endif // _SETUPX32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\cunknown.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CUNKNOWN.H - Header file for IUnknown Implementation.
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// IUnknown Implementation.

#ifndef __CUnknown_h__
#define __CUnknown_h__

#include <objbase.h>

///////////////////////////////////////////////////////////
// Nondelegating version of IUnknown.
//
struct INondelegatingUnknown
{
    virtual HRESULT  __stdcall 
        NondelegatingQueryInterface(const IID& iid, void** ppv) = 0;
    virtual ULONG    __stdcall NondelegatingAddRef() = 0;
    virtual ULONG    __stdcall NondelegatingRelease() = 0;
};

/////////////////////////////////////////////////////////////////////
// Declaration of CUnknown 
//
// Base class for implementing IUnknown.
//

class CUnknown : public INondelegatingUnknown
{
public:
    // Internal IUnknown Implementation...
    virtual HRESULT  __stdcall NondelegatingQueryInterface( const IID&, 
                                                            void**) ;
    virtual ULONG    __stdcall NondelegatingAddRef() ;
    virtual ULONG    __stdcall NondelegatingRelease();
    
    // Constructor
    CUnknown(IUnknown* pOuterUnknown) ;
    
    // Destructor
    virtual ~CUnknown() ;
    
    // Initialization (esp for aggregates)
    virtual HRESULT Init() 
        {return S_OK;}

    // Notify derived classes that we are releasing.
    virtual void FinalRelease() ;

    // Support for delegation
    IUnknown* GetOuterUnknown() const
    { return m_pOuterUnknown; }

    // Count of currently active components.
    static long ActiveComponents() 
    {return s_cActiveComponents;}
    
    // QueryInterface Helper Function
    HRESULT FinishQI(IUnknown* pI, void** ppv) ;
    
private:
    // Reference Count for this object.
    long m_cRef;

    // Outer IUnknown pointer.
    IUnknown* m_pOuterUnknown;

    // Count of all active instances.
    static long s_cActiveComponents ; 
} ;


///////////////////////////////////////////////////////////
// Delegating IUnknown - 
//
// Delegates to the nondelegating IUnknown interface if 
// not aggregated. If aggregated, delegates to the outer unknown.
//
#define DECLARE_IUNKNOWN                                    \
    virtual HRESULT __stdcall                               \
    QueryInterface(const IID& iid, void** ppv)              \
    {                                                       \
        return GetOuterUnknown()->QueryInterface(iid,ppv);  \
    };                                                      \
    virtual ULONG __stdcall AddRef()                        \
    {                                                       \
        return GetOuterUnknown()->AddRef();                 \
    };                                                      \
    virtual ULONG __stdcall Release()                       \
    {                                                       \
        return GetOuterUnknown()->Release();                \
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\registry.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  REGISTRY.H - Header for implementation of functions to register components.
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// functions to register components.

#ifndef __Registry_H__
#define __Registry_H__

////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

////////////////////////////////////////////////////////
// Function Prototypes
////////////////////////////////////////////////////////

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer( HMODULE hModule, 
                        const CLSID& clsid, 
                        const WCHAR*  szFriendlyName,
                        const WCHAR*  szVerIndProgID,
                        const WCHAR*  szProgID);

// This function will unregister a component. Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(   const CLSID& clsid,
                            const WCHAR* szVerIndProgID,
                            const WCHAR* szProgID);

// Converts a CLSID into a char string.
void CLSIDtochar(   const CLSID& clsid, 
                    WCHAR* szCLSID,
                    int length) ;

BOOL setKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName);

CONST UINT GETKEYANDVALUEBUFFSIZE = 1024;

// value must be at least 1024 in size;
BOOL getKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\dispids.h ===
#ifndef _DISPIDS_H
#define _DISPIDS_H

//MSOBCOMM
#define DISPID_DIALING                              0x420000
#define DISPID_CONNECTING                           0x420001
#define DISPID_DIALINGERROR                         0x420002
#define DISPIP_CONNECTIONCOMPLETE                   0x420003
#define DISPIP_DOWNLOADCOMPLETE                     0x420004

//MSOBSHEL
#define DISPID_MAINPANE_NAVCOMPLETE                 0x420100
#define DISPID_STATPANE_NAVCOMPLETE                 0x420101

//window.external
#define DISPID_EXTERNAL_POWERDOWN                   0x420200
#define DISPID_EXTERNAL_ENABLECANCEL                0x420201
#define DISPID_EXTERNAL_MOVENEXT                    0x420202
#define DISPID_EXTERNAL_MOVEPREVIOUS                0x420203
#define DISPID_EXTERNAL_DIAL                        0x420204
#define DISPID_EXTERNAL_HANGUP                      0x420205
#define DISPID_EXTERNAL_PROCESSINS                  0x420206
#define DISPID_EXTERNAL_USERINFO                    0x420208
// #define DISPID_EXTERNAL_UNUSED                      0x420209
#define DISPID_EXTERNAL_FINISH                      0x42020A
#define DISPID_EXTERNAL_CHECKDIALREADY              0x42020B
#define DISPID_EXTERNAL_BTN_CANCEL                  0x42020C
#define DISPID_EXTERNAL_BTN_EXISTING                0x42020D
// #define DISPID_EXTERNAL_UNUSED                      0x42020E
// #define DISPID_EXTERNAL_UNUSED                      0x42020F
#define DISPID_EXTERNAL_TAPILOC                     0x420210
#define DISPID_EXTERNAL_PRODUCTID                   0x420211
// #define DISPID_EXTERNAL_UNUSED                      0x420212
#define DISPID_EXTERNAL_PRECONFIGINS                0x420213
#define DISPID_EXTERNAL_LANGUAGE                    0x420214
#define DISPID_EXTERNAL_EULA                        0x420215
#define DISPID_EXTERNAL_SYSTEMCLOCK                 0x420216
#define DISPID_EXTERNAL_HIDECANCEL                  0x420217
#define DISPID_EXTERNAL_SIGNUP                      0x420218
#define DISPID_EXTERNAL_STATUS                      0x420219
#define DISPID_EXTERNAL_DIRECTIONS                  0x42021A
#define DISPID_EXTERNAL_API                         0x42021B
#define DISPID_EXTERNAL_BROWSENOW                   0x42021C
#define DISPID_EXTERNAL_LOADSTATUSITEMS             0x42021D
#define DISPID_EXTERNAL_EXECSCRIPTFN                0x42021E
#define DISPID_EXTERNAL_GET_STATUSINDEX             0x42021F
#define DISPID_EXTERNAL_REDIAL                      0x420220
#define DISPID_EXTERNAL_GETRECONNECTURL             0x420221
#define DISPID_EXTERNAL_GETFILE                     0x420222
#define DISPID_EXTERNAL_GETDIALNUMBER               0x420223
#define DISPID_EXTERNAL_CHECKPHONEBOOK              0x420224
#define DISPID_EXTERNAL_REGISTER                    0x420225
#define DISPID_EXTERNAL_SETDIALNUMBER               0x420226
#define DISPID_EXTERNAL_GETCONNECTIONTYPE           0x420227
#define DISPID_EXTERNAL_CONNECT                     0x420228
#define DISPID_EXTERNAL_RECONNECT                   0x420229
#define DISPID_EXTERNAL_SET_STATUSINDEX             0x42022A
// #define DISPID_EXTERNAL_UNUSED                      0x42022B
// #define DISPID_EXTERNAL_UNUSED                      0x42022c
// #define DISPID_EXTERNAL_UNUSED                      0x42022D
// #define DISPID_EXTERNAL_UNUSED                      0x42022E
// #define DISPID_EXTERNAL_UNUSED                      0x42022F
#define DISPID_EXTERNAL_RUNMANUALICW                0x420230
#define DISPID_EXTERNAL_CHECKKEYBOARD               0x420231
#define DISPID_EXTERNAL_CHECKMOUSE                  0x420232
#define DISPID_EXTERNAL_GETAPPLCID                  0x420233
#define DISPID_EXTERNAL_GETISPLIST                  0x420234
#define DISPID_EXTERNAL_SETSELECTISP                0x420235
#define DISPID_EXTERNAL_WALK                        0x420236
#define DISPID_EXTERNAL_GETPAGETYPE                 0x420237
#define DISPID_EXTERNAL_GETPAGEFLAG                 0x420238
#define DISPID_EXTERNAL_GETPAGEID                   0x420239
// #define DISPID_EXTERNAL_UNUSED                      0x42023A
// #define DISPID_EXTERNAL_UNUSED                      0x42023B
// #define DISPID_EXTERNAL_UNUSED                      0x42023c
// #define DISPID_EXTERNAL_UNUSED                      0x42023D
// #define DISPID_EXTERNAL_UNUSED                      0x42023E
// #define DISPID_EXTERNAL_UNUSED                      0x42023F
#define DISPID_EXTERNAL_GETURL                      0x420240
#define DISPID_EXTERNAL_MIGRATEGONEXT               0x420241
#define DISPID_EXTERNAL_MIGRATEGOBACK               0x420242
#define DISPID_EXTERNAL_GETISPNAME                  0x420243
#define DISPID_EXTERNAL_SAVEISPFILE                 0x420244
#define DISPID_EXTERNAL_CHECKONLINESTATUS           0x420245
#define DISPID_EXTERNAL_GETREGSTATUS                0x420246
#define DISPID_EXTERNAL_CHECKSTAYCONNECTED          0x420247
#define DISPID_EXTERNAL_DIALEX                      0x420248
#define DISPID_EXTERNAL_REDIALEX                    0x420249
// #define DISPID_EXTERNAL_UNUSED                      0x42024A
// #define DISPID_EXTERNAL_UNUSED                      0x42024B
// #define DISPID_EXTERNAL_UNUSED                      0x42024c
// #define DISPID_EXTERNAL_UNUSED                      0x42024D
// #define DISPID_EXTERNAL_UNUSED                      0x42024E
// #define DISPID_EXTERNAL_UNUSED                      0x42024F
#define DISPID_EXTERNAL_CONNECTEX                   0x420250
#define DISPID_EXTERNAL_RECONNECTEX                 0x420251
#define DISPID_EXTERNAL_POSTREGDATA                 0x420252
#define DISPID_EXTERNAL_STOP_REMIND                 0x420253
#define DISPID_EXTERNAL_DELETE_REMIND               0x420254
#define DISPID_EXTERNAL_GETOEMEULATEXT              0x420255
#define DISPID_EXTERNAL_GETOEMEULA                  0x420256
#define DISPID_EXTERNAL_ISICSAVAILABLE              0x420257
#define DISPID_EXTERNAL_ISICSUSED                   0x420258
#define DISPID_EXTERNAL_GETSUPPHONENUM              0x420259
#define DISPID_EXTERNAL_GETPHBKNUMBER               0x42025A
#define DISPID_EXTERNAL_TRIGGERICSCALLBACK          0x42025B
#define DISPID_EXTERNAL_ISICSHOSTREACHABLE          0x42025C
#define DISPID_EXTERNAL_NOWELCOMEFINISH             0x42025D
#define DISPID_EXTERNAL_NOISPPRECONFIG              0x42025E
#define DISPID_EXTERNAL_NOEULA                      0x42025F
#define DISPID_EXTERNAL_SHOWOOBEWIN                 0x420260
#define DISPID_EXTERNAL_PROCESSEVENTS               0x420261
#define DISPID_EXTERNAL_DEBUG                       0x420262
#define DISPID_EXTERNAL_GETLOCALUSERCOUNT           0x420263
#define DISPID_EXTERNAL_CREATEMODEMCONNECTOID       0x420264
#define DISPID_EXTERNAL_ISSETUPUPGRADE              0x420265
#define DISPID_EXTERNAL_COMPUTERNAMECHANGECOMPLETE  0x420266
#define DISPID_EXTERNAL_GET_RETAILOOBE              0x420267
#define DISPID_EXTERNAL_ISPROFESSIONALSKU           0x420268
#define DISPID_EXTERNAL_JOINDOMAIN                  0x420269
// #define DISPID_EXTERNAL_UNUSED                      0x42026A
// #define DISPID_EXTERNAL_UNUSED                      0x42026B
// #define DISPID_EXTERNAL_UNUSED                      0x42026C
// #define DISPID_EXTERNAL_UNUSED                      0x42026D
// #define DISPID_EXTERNAL_UNUSED                      0x42026E
// #define DISPID_EXTERNAL_UNUSED                      0x42026F
#define DISPID_EXTERNAL_ISSELECTVARIATION           0x420270
#define DISPID_EXTERNAL_SETADMINPASSWORD            0x420271
#define DISPID_EXTERNAL_GETCONNECTIONCAPABILITIES   0x420272
#define DISPID_EXTERNAL_GETPREFERREDCONNECTION      0x420273
#define DISPID_EXTERNAL_SETPREFERREDCONNECTION      0x420274
#define DISPID_EXTERNAL_CONNECTEDTOINTERNET         0x420275
#define DISPID_EXTERNAL_NEEDACTIVATION              0x420276
#define DISPID_EXTERNAL_ACTIVATE                    0x420277
#define DISPID_EXTERNAL_GETINSTALLATIONID           0x420278
#define DISPID_EXTERNAL_CREATEPPPOECONNECTOID       0x420279
#define DISPID_EXTERNAL_SETPREFERREDCONNECTIONTCPIPPROPERTIES 0x42027A
#define DISPID_EXTERNAL_SETCONFIRMATIONID           0x42027B
#define DISPID_EXTERNAL_INTERNETAUTODIAL            0x42027C
#define DISPID_EXTERNAL_GETACTIVATIONDAYSLEFT       0x42027D
#define DISPID_EXTERNAL_GETNETJOINSTATUS            0x42027E
#define DISPID_EXTERNAL_INHIGHCONTRASTMODE          0x42027F
#define DISPID_EXTERNAL_SETDIALALTERNATIVE          0x420280
#define DISPID_EXTERNAL_CONNECTEDTOINTERNETEX       0x420281
#define DISPID_EXTERNAL_ASYNCCONNECTEDTOINTERNETEX  0x420282
#define DISPID_EXTERNAL_ISUPGRADE                   0x420283
#define DISPID_EXTERNAL_FIREWALLPREFERREDCONNECTION 0x420284
#define DISPID_EXTERNAL_COMPUTERNAMEDIFFERENT       0x420285
#define DISPID_EXTERNAL_GETDEFAULTACCOUNT           0x420286
#define DISPID_EXTERNAL_GETOOBEMUIPATH              0x420287
#define DISPID_EXTERNAL_OEMPASSWORD                 0x420288
#define DISPID_EXTERNAL_INTERNETAUTODIALHANGUP      0x420289
#define DISPID_EXTERNAL_VERIFYCHECKDIGITS           0x42028A
#define DISPID_EXTERNAL_ISOEMSKU                    0x42028B
#define DISPID_EXTERNAL_GETPROXYSETTINGS            0x42028C
#define DISPID_EXTERNAL_SETPROXYSETTINGS            0x42028D
#define DISPID_EXTERNAL_PLAYBACKGROUNDMUSIC         0x42028E
#define DISPID_EXTERNAL_CALLED_FROM_MSN             0x42028F
#define DISPID_EXTERNAL_USEFADEEFFECT               0x420290
#define DISPID_EXTERNAL_SETICWCOMPLETED             0x420291
#define DISPID_EXTERNAL_ISSERVERSKU                 0x420292
#define DISPID_EXTERNAL_RESETLICENSEAGENT           0x420293
#define DISPID_EXTERNAL_HASTABLET                   0x420294
#define DISPID_EXTERNAL_GETPUBLICLANCOUNT           0x420295
#define DISPID_EXTERNAL_ASYNCGETPUBLICLANCOUNT      0x420296

//window.external.UserInfo
#define DISPID_USERINFO_GET_FIRSTNAME               0x420300
#define DISPID_USERINFO_SET_FIRSTNAME               0x420301
#define DISPID_USERINFO_GET_MIDDLEINITIAL           0x420302
#define DISPID_USERINFO_SET_MIDDLEINITIAL           0x420303
#define DISPID_USERINFO_GET_LASTNAME                0x420304
#define DISPID_USERINFO_SET_LASTNAME                0x420305
#define DISPID_USERINFO_GET_COMPANYNAME             0x420306
#define DISPID_USERINFO_SET_COMPANYNAME             0x420307
#define DISPID_USERINFO_GET_ADDRESS1                0x420308
#define DISPID_USERINFO_SET_ADDRESS1                0x420309
#define DISPID_USERINFO_GET_CITY                    0x42030A
#define DISPID_USERINFO_SET_CITY                    0x42030B
#define DISPID_USERINFO_GET_STATE                   0x42030C
#define DISPID_USERINFO_SET_STATE                   0x42030D
#define DISPID_USERINFO_GET_ZIP                     0x42030E
#define DISPID_USERINFO_SET_ZIP                     0x42030F
#define DISPID_USERINFO_GET_PRIMARYEMAIL            0x420310
#define DISPID_USERINFO_SET_PRIMARYEMAIL            0x420311
#define DISPID_USERINFO_GET_SECONDARYEMAIL          0x420312
#define DISPID_USERINFO_SET_SECONDARYEMAIL          0x420313
#define DISPID_USERINFO_GET_AREACODE                0x420314
#define DISPID_USERINFO_SET_AREACODE                0x420315
#define DISPID_USERINFO_GET_PHONENUMBER             0x420318
#define DISPID_USERINFO_SET_PHONENUMBER             0x420319
#define DISPID_USERINFO_GET_FURIGANANAME            0x42031A
#define DISPID_USERINFO_SET_FURIGANANAME            0x42031B
#define DISPID_USERINFO_GET_ADDRESS2                0x42031C
#define DISPID_USERINFO_SET_ADDRESS2                0x42031D
#define DISPID_USERINFO_GET_COUNTRY                 0x42031E
#define DISPID_USERINFO_SET_COUNTRY                 0x42031F
#define DISPID_USERINFO_GET_IDENTITY                0x420320
#define DISPID_USERINFO_SET_IDENTITY                0x420321
#define DISPID_USERINFO_GET_IDENTITIESMAX           0x420322
#define DISPID_USERINFO_CHECK_IDENTITY              0x420323
#define DISPID_USERINFO_SUGGESTIDENTITY0            0x420324
#define DISPID_USERINFO_GET_USEIDENTITIES           0x420325
#define DISPID_USERINFO_SET_USEIDENTITIES           0x420326
#define DISPID_USERINFO_GET_OEMIDENTITIES           0x420327
#define DISPID_USERINFO_SET_OWNERNAME               0x420328
#define DISPID_USERINFO_GET_OWNERNAME               0x420329
#define DISPID_USERINFO_GET_MSUPDATE                0x42032A
#define DISPID_USERINFO_SET_MSUPDATE                0x42032B
#define DISPID_USERINFO_GET_MSOFFER                 0x42032C
#define DISPID_USERINFO_SET_MSOFFER                 0x42032D
#define DISPID_USERINFO_GET_OTHEROFFER              0x42032E
#define DISPID_USERINFO_SET_OTHEROFFER              0x42032F
#define DISPID_USERINFO_GET_COUNTRYID               0x420330
#define DISPID_USERINFO_SET_COUNTRYID               0x420331
#define DISPID_USERINFO_GET_DEFAULTNEWUSER          0x420332

//window.external.Tapi
#define DISPID_TAPI_INITTAPI                        0x420401
#define DISPID_TAPI_GETCOUNTRYINDEX                 0x420402
#define DISPID_TAPI_SETCOUNTRYINDEX                 0x420403
#define DISPID_TAPI_GETNUMOFCOUNTRY                 0x420404
#define DISPID_TAPI_GETCOUNTRYNAME                  0x420405
#define DISPID_TAPI_GETAREACODE                     0x420406
#define DISPID_TAPI_SETAREACODE                     0x420407
#define DISPID_TAPI_GETDIALOUT                      0x420408
#define DISPID_TAPI_SETDIALOUT                      0x420409
#define DISPID_TAPI_GETPHONESYS                     0x42040A
#define DISPID_TAPI_SETPHONESYS                     0x42040B
#define DISPID_TAPI_GETCALLWAITING                  0x42040C
#define DISPID_TAPI_SETCALLWAITING                  0x42040D
#define DISPID_TAPI_GETALLCNTRYNAME                 0x42040E
#define DISPID_TAPI_ISACODEREQUIRED                 0x42040F
#define DISPID_TAPI_GETCOUNTRYID                    0x420410
#define DISPID_TAPI_TAPISERVICERUNNING              0x420411

//window.external.ProductID
#define DISPID_PRODUCTID_GET_PID                    0x420500
#define DISPID_PRODUCTID_SET_PID                    0x420501
#define DISPID_PRODUCTID_VALIDATEPID                0x420502
#define DISPID_PRODUCTID_GET_ACCEPTED               0x420503

//window.external.Signup
#define DISPID_SIGNUP_GET_LOCALE                    0x420600
#define DISPID_SIGNUP_GET_IDLOCALE                  0x420601
#define DISPID_SIGNUP_GET_TEXT1                     0x420602
#define DISPID_SIGNUP_GET_TEXT2                     0x420603
#define DISPID_SIGNUP_GET_OEMNAME                   0x420604
#define DISPID_SIGNUP_GET_OEMCODE                   0x420605

//window.external.Language
#define DISPID_GETNUMOFREGIONS                      0x420700
#define DISPID_GETREGIONNAME                        0x420701
#define DISPID_GETREGIONINDEX                       0x420702
#define DISPID_SETREGIONINDEX                       0x420703
#define DISPID_GETNUMOFKEYLAYOUTS                   0x420704
#define DISPID_GETKEYNAME                           0x420705
#define DISPID_GETKEYLAYOUTINDEX                    0x420706
#define DISPID_SETKEYLAYOUTINDEX                    0x420707
#define DISPID_LANGUAGE_GETREBOOTSTATE              0x420708
#define DISPID_LANGUAGE_SAVESETTINGS                0x420709
#define DISPID_GETNUMOFLANGS                        0x42070A
#define DISPID_GETLANGNAME                          0x42070B
#define DISPID_GETLANGINDEX                         0x42070C
#define DISPID_SETLANGINDEX                         0x42070D
#define DISPID_GETPHONECOUNTRIES                    0x42070E

//window.external.Eula
#define DISPID_EULA_GET_ACCEPTED                    0x420800
#define DISPID_EULA_SET_ACCEPTED                    0x420801
#define DISPID_EULA_VALIDATEEULA                    0x420802

//window.external.SystemClock
#define DISPID_SYSTEMCLOCK_SETTIMEZONE              0x420900
#define DISPID_SYSTEMCLOCK_SETTIME                  0x420901
#define DISPID_SYSTEMCLOCK_SETDATE                  0x420902
#define DISPID_SYSTEMCLOCK_GETTIMEZONE              0x420903
#define DISPID_SYSTEMCLOCK_GETALLTIMEZONES          0x420904
#define DISPID_SYSTEMCLOCK_GETTIMEZONEIDX           0x420905
#define DISPID_SYSTEMCLOCK_SETTIMEZONEIDX           0x420906
#define DISPID_SYSTEMCLOCK_INIT                     0x420907
#define DISPID_SYSTEMCLOCK_SETAUTODAYLIGHT          0x420908
#define DISPID_SYSTEMCLOCK_GETAUTODAYLIGHT          0x420909
#define DISPID_SYSTEMCLOCK_GETTIMEZONEWASPRESET     0x42090A
#define DISPID_SYSTEMCLOCK_GETDAYLIGHT_ENABLED      0x42090B

//window.external.Status
#define DISPID_STATUS_GET_PID_COMPLETED             0x421000
#define DISPID_STATUS_SET_PID_COMPLETED             0x421001
#define DISPID_STATUS_GET_TAPI_COMPLETED            0x421002
#define DISPID_STATUS_SET_TAPI_COMPLETED            0x421003
#define DISPID_STATUS_GET_LANGUAGE_COMPLETED        0x421004
#define DISPID_STATUS_SET_LANGUAGE_COMPLETED        0x421005
#define DISPID_STATUS_GET_EULA_COMPLETED            0x421006
#define DISPID_STATUS_SET_EULA_COMPLETED            0x421007
#define DISPID_STATUS_GET_MOUSETUTOR_COMPLETED      0x421008
#define DISPID_STATUS_SET_MOUSETUTOR_COMPLETED      0x421009
#define DISPID_STATUS_GET_USERINFO_POSTED           0x42100A
#define DISPID_STATUS_SET_USERINFO_POSTED           0x42100B
#define DISPID_STATUS_GET_USERINFO_STAMPED          0x42100C
#define DISPID_STATUS_SET_USERINFO_STAMPED          0x42100D
#define DISPID_STATUS_GET_OEMINFO_COMPLETED         0x42100E
#define DISPID_STATUS_SET_OEMINFO_COMPLETED         0x42100F
#define DISPID_STATUS_GET_ISPSIGNUP_COMPLETED       0x421010
#define DISPID_STATUS_SET_ISPSIGNUP_COMPLETED       0x421011
#define DISPID_STATUS_GET_SIGNATURE_COMPLETED       0x421012
#define DISPID_STATUS_SET_SIGNATURE_COMPLETED       0x421013
#define DISPID_STATUS_GET_TIMEZONE_COMPLETED        0x421014
#define DISPID_STATUS_SET_TIMEZONE_COMPLETED        0x421015
#define DISPID_STATUS_GET_STATUS                    0x421016
#define DISPID_STATUS_SET_STATUS                    0x421017

//window.external.Directions
#define DISPID_DIRECTIONS_GET_DOMOUSETUTORIAL       0x421100
#define DISPID_DIRECTIONS_GET_DOOEMREGISTRATION     0x421101
#define DISPID_DIRECTIONS_GET_DOREGIONALKEYBOARD    0x421102
#define DISPID_DIRECTIONS_GET_DOOEMHARDWARECHECK    0x421103
#define DISPID_DIRECTIONS_GET_DOBROWSENOW           0x421104
#define DISPID_DIRECTIONS_GET_ISPSIGNUP             0x421105
#define DISPID_DIRECTIONS_GET_OFFLINE               0x421106
#define DISPID_DIRECTIONS_GET_OFFERCODE             0x421107
#define DISPID_DIRECTIONS_GET_APPMODE               0x421108
#define DISPID_DIRECTIONS_GET_OEMCUST               0x421109
#define DISPID_DIRECTIONS_GET_DOOEMADDREGISTRATION  0x42110A
#define DISPID_DIRECTIONS_GET_DOTIMEZONE            0x42110B
#define DISPID_DIRECTIONS_GET_TIMEZONEVALUE         0x42110C
#define DISPID_DIRECTIONS_GET_DOIMETUTORIAL         0x42110D
#define DISPID_DIRECTIONS_GET_DOSKIPANIMATION       0x42110E
#define DISPID_DIRECTIONS_GET_DOWELCOMEFADEIN       0x42110F
#define DISPID_DIRECTIONS_GET_INTROONLY             0x421111
#define DISPID_DIRECTIONS_GET_AGENTDISABLED         0x421112
#define DISPID_DIRECTIONS_GET_SHOWISPMIGRATION      0x421113
#define DISPID_DIRECTIONS_GET_DOJOINDOMAIN          0x421114
#define DISPID_DIRECTIONS_GET_DOADMINPASSWORD       0x421115

//window.external.API
#define DISPID_API_SAVEFILE                         0x421200
#define DISPID_API_SAVEFILEBYCSIDL                  0x421201
#define DISPID_API_GET_INIKEY                       0x421202
#define DISPID_API_GET_REGVALUE                     0x421203
#define DISPID_API_SET_REGVALUE                     0x421204
#define DISPID_API_DELETEREGVALUE                   0x421205
#define DISPID_API_DELETEREGKEY                     0x421206
#define DISPID_API_GET_SYSTEMDIRECTORY              0x421207
#define DISPID_API_GET_CSIDLDIRECTORY               0x421208
#define DISPID_API_LOADFILE                         0x421209
#define DISPID_API_GET_USERDEFAULTLCID              0x42120A
#define DISPID_API_GET_COMPUTERNAME                 0x42120B
#define DISPID_API_SET_COMPUTERNAME                 0x42120C
#define DISPID_API_FLUSHREGKEY                      0x42120D
#define DISPID_API_VALIDATECOMPUTERNAME             0x42120E
#define DISPID_API_FORMATMESSAGE                    0x42120F
#define DISPID_API_OEMCOMPUTERNAME                  0x421210
#define DISPID_API_SET_COMPUTERDESC                 0x421211
#define DISPID_API_GET_USERDEFAULTUILANGUAGE        0x421212

//window.external.Register
#define DISPID_REGISTER_POSTTOMSN                    0x421300
#define DISPID_REGISTER_POSTTOOEM                    0x421301
#define DISPID_REGISTER_REGPOSTURL                   0x421302
#define DISPID_REGISTER_OEMADDREGPAGE                0x421303

//window.external.Debug
#define DISPID_DEBUG_TRACE                           0x421400
#define DISPID_DEBUG_ISMSDEBUGMODE                   0x421401
#define DISPID_DEBUG_ISOEMDEBUGMODE                  0x421402

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\atmcfg.h ===
//****************************************************************************
//
//  File:       atmcfg.h
//  Content:    This file contains the ATM device specific configuration
//
//  Copyright (c) 1997-1998, Microsoft Corporation, all rights reserved
//
//  History:
//      Thurs 5-28-98   BJohnson        Created
//
//****************************************************************************

#ifndef _ATMCFG_H_
#define _ATMCFG_H_
//
// #ifndef HKEY
// #define HKEY PVOID
// #endif
//
//
// ATM Configuration info
//

typedef struct tagATMCONFIG {
    ULONG   cbSize;                 /* size of structure */
    ULONG   cbTotalSize;            /* Total mem used by struct & var data */
    ULONG   ulFlags;                /* flags for the device */
    ULONG   ulCircuitFlags;         /* flags for the circuit */

    HKEY    hkeyDriver;             /* handle to driver registry key */
    ULONG   ulVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    ULONG   cbVendorSize;           /* size of the vendor specific data
                                       field */
    ULONG   ulReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    ULONG   cbReservedSize;         /* size of the reserved data field */

    WCHAR   wcData[1];              /* variable data */
    } ATMCONFIG, FAR * LPATMCONFIG;


//
//  ATM Phone book data.  This data is stored on a per connection basis
//  and is the structure returned for get and set dev config.
//

typedef struct tagATMPBCONFIG {
    ULONG   ulGeneralOpt;           /* General options */
    ULONG   ulCircuitOpt;           /* Circuit options */
    ULONG	ulCircuitSpeed;         /* Circuit Speed */
    USHORT  usPvcVpi;               /* PVC: VPI */
    USHORT  usPvcVci;               /* PVC: VCI */
} ATMPBCONFIG, FAR * LPATMPBCONFIG;


//
// Flags for ATM Phone Book entry
//

//
// ATM General Options
//
#define ATM_GENERAL_OPT_VENDOR_CONFIG   0x00000001L
#define ATM_GENERAL_OPT_SHOW_STATUS     0x00000002L
#define ATM_GENERAL_OPT_ENABLE_LOG      0x00000004L

#define ATM_GENERAL_OPT_MASK            0x0000000FL
#define ATM_GENERAL_OPT_DEFAULT         0x00000000L


//
// ATM Circuit Options
//
#define ATM_CIRCUIT_OPT_QOS_ADJUST      0x00000010L
#define ATM_CIRCUIT_OPT_SPEED_ADJUST    0x00000020L
#define ATM_CIRCUIT_OPT_SVC             0x00000040L
#define ATM_CIRCUIT_OPT_PVC             0x00000080L

#define ATM_CIRCUIT_OPT_MASK            0x000000F0L
#define ATM_CIRCUIT_OPT_DEFAULT         (ATM_CIRCUIT_OPT_SVC | ATM_CIRCUIT_OPT_QOS_ADJUST | ATM_CIRCUIT_OPT_SPEED_ADJUST)


//
// ATM QOS Flags
//
#define ATM_CIRCUIT_QOS_VBR             0x00000100L
#define ATM_CIRCUIT_QOS_CBR             0x00000200L
#define ATM_CIRCUIT_QOS_ABR             0x00000400L
#define ATM_CIRCUIT_QOS_UBR             0x00000800L

#define ATM_CIRCUIT_QOS_MASK            0x00000F00L
#define ATM_CIRCUIT_QOS_DEFAULT         (ATM_CIRCUIT_QOS_UBR)

//
// ATM Speed Flags
//
#define ATM_CIRCUIT_SPEED_LINE_RATE     0x00001000L
#define ATM_CIRCUIT_SPEED_USER_SPEC     0x00002000L
#define ATM_CIRCUIT_SPEED_512KB         0x00004000L
#define ATM_CIRCUIT_SPEED_1536KB        0x00008000L
#define ATM_CIRCUIT_SPEED_25MB          0x00010000L
#define ATM_CIRCUIT_SPEED_155MB         0x00020000L

#define ATM_CIRCUIT_SPEED_MASK          0x000FF000L
#define ATM_CIRCUIT_SPEED_DEFAULT       (ATM_CIRCUIT_SPEED_LINE_RATE)

//
// ATM Encapsulation Flags
//
#define ATM_CIRCUIT_ENCAP_NULL          0x00100000L
#define ATM_CIRCUIT_ENCAP_LLC           0x00200000L

#define ATM_CIRCUIT_ENCAP_MASK          0x00F00000L
#define ATM_CIRCUIT_ENCAP_DEFAULT       (ATM_CIRCUIT_ENCAP_NULL)

#endif  //_ATMCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\util.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  UTIL.H - utilities
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
// Common utilities for printing out messages

#ifndef _UTIL_H_
#define _UTIL_H_

#include <assert.h>
#include <tchar.h>
#include <windows.h>
#include <ole2.h>
#include <setupapi.h>
#include <syssetup.h>

//////////////////////////////////////////////////////////////////////////////
//
// System boot mode
//

// Constants for values returned by GetSystemMetrics(SM_CLEANBOOT)
//
#define BOOT_CLEAN              0
#define BOOT_SAFEMODE           1
#define BOOT_SAFEMODEWITHNET    2

BOOL InSafeMode();
BOOL InDsRestoreMode();

// Displays a message box with an error string in it.
void ErrorMessage(LPCWSTR str, HRESULT hr) ;

// Determine if two interfaces below to the same component.
BOOL InterfacesAreOnSameComponent(IUnknown* pI1, IUnknown* pI2) ;
bool GetOOBEPath(LPWSTR szOOBEPath);
bool GetOOBEMUIPath(LPWSTR szOOBEPath);

// Displays messages using OutputDebugString
void __cdecl MyTrace(LPCWSTR lpszFormat, ...);

// Determine if an address is accessable.
BOOL IsValidAddress(const void* lp, UINT nBytes = 1, BOOL bReadWrite = FALSE) ;

bool GetCanonicalizedPath(LPWSTR szCompletePath, LPCWSTR szFileName);

bool GetString(HINSTANCE hInstance, UINT uiID, LPWSTR szString, UINT uiStringLen = MAX_PATH);
HRESULT GetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT GetINIKeyBSTR(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT GetINIKeyUINT(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT SetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
void WINAPI URLEncode(WCHAR* pszUrl, size_t bsize);

void WINAPI URLAppendQueryPair
(
    LPWSTR   lpszQuery,
    LPWSTR   lpszName,
    LPWSTR   lpszValue
);
void GetCmdLineToken(LPWSTR *ppszCmd, LPWSTR pszOut);
VOID PumpMessageQueue( );
BOOL IsOEMDebugMode();
BOOL IsThreadActive(HANDLE hThread);
void GetDesktopDirectory(WCHAR* pszPath);
void RemoveDesktopShortCut(LPWSTR lpszShortcutName);
BOOL InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    );
BOOL SignalComputerNameChangeComplete();
BOOL IsUserAdmin(VOID);

typedef struct tagSTRINGLIST {
    struct tagSTRINGLIST* Next;
    PTSTR String;
} STRINGLIST, *PSTRINGLIST;

PSTRINGLIST
CreateStringCell(
    IN PCTSTR String
    );

VOID
DeleteStringCell(
    IN PSTRINGLIST Cell
    );

BOOL
InsertList(
    IN OUT PSTRINGLIST* List,
    IN     PSTRINGLIST NewList
    );

VOID
DestroyList(
    IN PSTRINGLIST List
    );

BOOL
RemoveListI(
    IN OUT  PSTRINGLIST* List,
    IN      PCTSTR       String
    );

BOOL
ExistInListI(
    IN PSTRINGLIST List,
    IN PCTSTR      String
    );

BOOL IsDriveNTFS(IN TCHAR Drive);

BOOL
HasTablet();

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    );

// Determine if interface pointer is accessable.
inline BOOL IsValidInterface(IUnknown* p)
{
    return (p != NULL) && IsValidAddress(p, sizeof(IUnknown*), FALSE) ;
}

// Determine if the out parameter for an interface pointer is accessable.
template <class T>
inline BOOL IsValidInterfaceOutParam(T** p)
{
    return (p != NULL) && IsValidAddress(p, sizeof(IUnknown*), TRUE) ;
}

inline VARIANT_BOOL Bool2VarBool(BOOL b)
{
    return (b) ? -1 : 0;
}

inline BOOL VarBool2Bool(VARIANT_BOOL b)
{
    return (0 == b) ? 0 : 1;
}


///////////////////////////////////////////////////////////
// Diagnostic support
//
#if defined(DBG) && !defined(ASSERTS_ON)
#define ASSERTS_ON  1
#endif

#if ASSERTS_ON
VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }
#define VERIFY(x)       MYASSERT(x)
#else
#define MYASSERT(x)
#define VERIFY(f)           ((void)(f))
#endif

// Helper function for checking HRESULTs.
#ifdef DBG
inline void CheckResult(HRESULT hr)
{
    if (FAILED(hr))
    {
        ErrorMessage(NULL, hr) ;
        assert(FAILED(hr)) ;
    }
}

#define ASSERT_HRESULT      CheckResult
#else
#define ASSERT_HRESULT
#endif

///////////////////////////////////////////////////////////
//
// More Diagnostic support which mimics MFC
//
#ifndef __AFX_H__   // Only define these if MFC has not already been included

#define TRACE(_fmt_)                                            \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_)
#define TRACE1(_fmt_,_arg1_)                                    \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_)
#define TRACE2(_fmt_,_arg1_,_arg2_)                             \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_)
#define TRACE3(_fmt_,_arg1_,_arg2_,_arg3_)                      \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_)
#define TRACE4(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)               \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)
#define TRACE5(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)        \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)
#define TRACE6(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_,_arg6_) \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_,_arg6_)

#define ASSERT_POINTER(p, type) \
    MYASSERT(((p) != NULL) && IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    MYASSERT(((p) == NULL) || IsValidAddress((p), sizeof(type), FALSE))

#endif // TRACE

//////////////////////////////////////////////////////////////////////////////
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG(IType, ppType)
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_PPV_ARG_NULL(IType, ppType)
//

#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

//////////////////////////////////////////////////////////////////////////////
//
//  Types of actions OOBE requires after shutdown.  The type and amount of
//  cleanup done by OOBE on exit are dependent on these.  This includes
//  notifying WinLogon of the necessity of reboot, deleting persistent data,
//  and setting the keys in HKLM\System\Setup.
//
typedef enum _OOBE_SHUTDOWN_ACTION
{
    SHUTDOWN_NOACTION,
    SHUTDOWN_LOGON,
    SHUTDOWN_REBOOT,
    SHUTDOWN_POWERDOWN,
    SHUTDOWN_MAX        // this entry must always be last
} OOBE_SHUTDOWN_ACTION;


#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for comma seperated files
class CCSVFile 
{
    
    public: 
        void far * operator new( size_t cb ) { return GlobalAlloc(GPTR, cb); };
        void operator delete( void far * p ) {GlobalFree(p); };

        CCSVFile();
        ~CCSVFile();
        BOOLEAN Open(LPCWSTR pszFileName);
        BOOLEAN ReadToken(LPWSTR pszDest, DWORD cbMax);  // reads up to comma or newline, returns fFalse on EOF
        BOOLEAN SkipTillEOL(void);  // reads up to EOL
        void Close(void);
        inline int ILastRead(void)
            {
            return m_iLastRead;
            }

    private:
        BOOL    FReadInBuffer(void);
        inline int  ChNext(void);
        CHAR    m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
        WCHAR   m_rgwchBuf[CCSVFILE_BUFFER_SIZE];
        LPWSTR  m_pchBuf;           //pointer to the next item in the buffer to read
        LPWSTR  m_pchLast;          //pointer to the last item in the buffer
        int     m_iLastRead;        //the character last read.
        DWORD   m_cchAvail;
        HANDLE  m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\ccsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// ############################################################################
// INCLUDES
#include "appdefs.h"
#include "ccsv.h"

// ############################################################################
// DEFINES
#define chComma L','
#define chNewline L'\n'
#define chReturn L'\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    //AssertMsg(!m_hFile, L"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCWSTR pszFileName)
{
    //AssertMsg(!m_hFile, L"a file is already open.");
        
    m_hFile = CreateFile((LPCWSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPWSTR psz, DWORD cchMax)
{
    LPWSTR    pszLast;
    int      ch;

    ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    pszLast = psz + (cchMax - 1);
    while ( psz < pszLast &&
            chComma != ch &&
            chNewline != ch &&
            chReturn != ch &&
            -1 != ch)
    {
        *psz++ = (WCHAR)ch;
        ch = ChNext(); //Read in the next WCHARacter
    }

    *psz++ = L'\0';

    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::SkipTillEOL()
{
    int ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    while ( chNewline != ch &&
            -1 != ch)
    {
        ch = ChNext(); //Read in the next character
    }
    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);

    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
    if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        return FALSE;     //nothing more to read

    // Convert ANSI to UNICODE
    MultiByteToWideChar(CP_ACP, 0, m_rgchBuf, m_cchAvail, m_rgwchBuf, m_cchAvail);

    m_pchBuf = m_rgwchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\cntpoint.h ===
#ifndef __CConnectionPoint_h__ 
#define __CConnectionPoint_h__ 
///////////////////////////////////////////////////////////
//
// CntPoint.h - CTangramModelConnectionPoint 
// 
// Defines the connection point object used by CTangramModel.
//
#include <ocidl.h> //For IConnectionPoint
//#include "ConData.h"

///////////////////////////////////////////////////////////
//
// CConnectionPoint
//
class CConnectionPoint : public IConnectionPoint 
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;			
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// Interface IConnectionPoint methods.
	virtual HRESULT __stdcall GetConnectionInterface(IID*);
	virtual HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer**);
	virtual HRESULT __stdcall Advise(IUnknown*, DWORD*);
	virtual HRESULT __stdcall Unadvise(DWORD);
	virtual HRESULT __stdcall EnumConnections(IEnumConnections**);

	// Construction
	CConnectionPoint(IConnectionPointContainer*, const IID*) ;

	// Destruction
	~CConnectionPoint() ;

// Member variables
public:
	
	// Interface ID of the outgoing interface supported by this connection point.
	const IID* m_piid ;

	// Point to the ConnectionPointerContainer
	IConnectionPointContainer* m_pIConnectionPointContainer ;

	// Cookie Incrementor
	DWORD m_dwNextCookie ;

	// Reference Count
	// Not required --- delegated to container long m_cRef;	   

	// STL List which holds points to the interfaces to call
	CONNECTDATA m_Cd;
};

#endif //__CConnectionPoint_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\cntpoint.cpp ===
///////////////////////////////////////////////////////////
//
// CConnectionPoint 
// 
// Defines the connection point object used by CTangramModel.
//
//
#include <windows.h>
#include <olectl.h>
#include <assert.h>

#include "CntPoint.h"
//#include "EnumCon.h"

///////////////////////////////////////////////////////////
//
// Construction
CConnectionPoint::CConnectionPoint(IConnectionPointContainer* pIConnectionPointContainer, const IID* piid)
:	m_dwNextCookie(0)
{
	assert(piid != NULL) ;
	assert(pIConnectionPointContainer != NULL) ;

	m_pIConnectionPointContainer = pIConnectionPointContainer ; // AddRef is not needed.
	m_piid = piid ;
}

///////////////////////////////////////////////////////////
//
// Destruction
CConnectionPoint::~CConnectionPoint()
{
	// The array should be empty before this is called.
}

///////////////////////////////////////////////////////////
//
//			Interface IUnknown Methods
//
///////////////////////////////////////////////////////////
//
// QueryInterface
//
HRESULT __stdcall 
CConnectionPoint::QueryInterface(const IID& iid, void** ppv)
{
	if ((iid == IID_IUnknown) ||(iid == IID_IConnectionPoint))
	{
		*ppv = static_cast<IConnectionPoint*>(this) ; 
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	(reinterpret_cast<IUnknown*>(*ppv))->AddRef() ;
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// AddRef
//
ULONG __stdcall CConnectionPoint::AddRef() 
{
	// Delegate AddRefss
	return m_pIConnectionPointContainer->AddRef() ;
}

///////////////////////////////////////////////////////////
//
// Release
//
ULONG __stdcall CConnectionPoint::Release() 
{
	// Delegate Releases
	return m_pIConnectionPointContainer->Release() ;
}

///////////////////////////////////////////////////////////
//
//			Interface IConnectionPoint Methods
//
///////////////////////////////////////////////////////////
//
// GetConnectionInterface
//
HRESULT __stdcall 
CConnectionPoint::GetConnectionInterface(IID* piid)
{
	assert( m_piid != NULL);

	if (piid == NULL)
	{
		return E_POINTER ;
	}

	// Cast away Cast away Cast away Const!
	*piid = *(const_cast<IID*>(m_piid)) ;
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetConnectionPointContainer
//
HRESULT __stdcall 
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer** ppIConnectionPointContainer)
{
	assert( m_pIConnectionPointContainer != NULL);

	if (ppIConnectionPointContainer == NULL)
	{
		return E_POINTER ;
	}

	*ppIConnectionPointContainer = m_pIConnectionPointContainer ;
	m_pIConnectionPointContainer->AddRef() ;
	return S_OK ;
}
///////////////////////////////////////////////////////////
//
// Advise
//
HRESULT __stdcall 
CConnectionPoint::Advise(IUnknown* pIUnknownSink, DWORD* pdwCookie )
{
	if (pIUnknownSink == NULL || pdwCookie == NULL)
	{
		*pdwCookie = 0;
		return E_POINTER;
	}

	IUnknown* pI = NULL ;
	HRESULT hr = pIUnknownSink->QueryInterface(*m_piid, (void**)&pI) ;
	if (SUCCEEDED(hr))
	{		
		m_Cd.dwCookie = ++m_dwNextCookie ;
		m_Cd.pUnk = pI ;
        if (pI)
            pI->Release();

		// Return cookie
		*pdwCookie = m_Cd.dwCookie ;
		return S_OK ;
	}
	else
	{
		return CONNECT_E_CANNOTCONNECT ;
	}
}
///////////////////////////////////////////////////////////
//
// Unadvise
//
HRESULT __stdcall 
CConnectionPoint::Unadvise(DWORD dwCookie)
{
	if (m_Cd.dwCookie == dwCookie)
	{
		// Found sink point.
		IUnknown* pSink = m_Cd.pUnk;

        // Release the interface pointer.
		pSink->Release() ;

		return S_OK ;
	}
	return CONNECT_E_NOCONNECTION;;
}

///////////////////////////////////////////////////////////
//
// EnumConnections
//
HRESULT __stdcall 
CConnectionPoint::EnumConnections(IEnumConnections** ppIEnum)
{
	//if (ppIEnum == NULL)
	{
	//	return E_POINTER ;
	}

	// Construct the enumerator object.
	//IEnumConnections* pIEnum = new CEnumConnections(m_SinkList) ;
	// The contructor AddRefs for us.
	//*ppIEnum = pIEnum ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\connmgr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: ConnMgr.cpp  
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Neptune
//
//  Revision History:
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <netcon.h>
#include <wininet.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <devguid.h>
#include <mswsock.h>
#include <util.h>
#include <commerr.h>
#include "connmgr.h"
#include "msobcomm.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

const static int MAX_NUM_NET_COMPONENTS = 128;
const static int MAX_GUID_LEN = 40;

const DWORD CConnectionManager::RAS_AUTODIAL_ENABLED   = 0;
const DWORD CConnectionManager::RAS_AUTODIAL_DISABLED  = 1;
const DWORD CConnectionManager::RAS_AUTODIAL_DONT_KNOW = 2;

////////////////////////////////
//  Wininet/URL Helpers
////////////////////////////////

STDAPI InternetOpenWrap(
    LPCTSTR pszAgent,
    DWORD dwAccessType,
    LPCTSTR pszProxy,
    LPCTSTR pszProxyBypass,
    DWORD dwFlags,
    HINTERNET * phFileHandle
    );

STDAPI InternetOpenUrlWrap(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    LPCTSTR   pszHeaders,
    DWORD     dwHeadersLength,
    DWORD     dwFlags,
    DWORD_PTR dwContext,
    HINTERNET * phFileHandle
    );

STDAPI HttpQueryInfoWrap(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex
    );

BOOL
IsGlobalOffline(
    VOID
    );

VOID
SetOffline(
    IN BOOL fOffline
    );

STDAPI PingWebServer(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    BOOL*     pfConnected
    );

static NLA_BLOB* _NLABlobNext(
    IN NLA_BLOB* pnlaBlob
    );

static int _AllocWSALookupServiceNext(
    IN HANDLE hQuery,
    IN DWORD dwControlFlags,
    OUT LPWSAQUERYSET* ppResults
    );

static int StringCmpGUID(
    IN LPCWSTR szGuid,
    IN const GUID* pguid
    );

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager
//
//  Default constructor
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CConnectionManager::CConnectionManager()
:   m_dwConnectionCapabilities(CONNECTIONTYPE_INVALID),
    m_dwPreferredConnection(CONNECTIONTYPE_INVALID),
    m_pPreferredConnection(NULL),
    m_cLanConnections(0),
    m_cPhoneConnections(0),
    m_hInternetPing(NULL),
    m_bProxySaved(FALSE),
    m_bProxyApplied(FALSE),
    m_bUseProxy(FALSE),
    m_dwRasAutodialDisable(RAS_AUTODIAL_DONT_KNOW),
    m_bForceOnline(FALSE),
    m_bExclude1394(FALSE)
{
    ZeroMemory(&m_CurrentProxySettings, sizeof(m_CurrentProxySettings));
}   //  CConnectionManager::CConnectionManager



//////////////////////////////////////////////////////////////////////////////
//
//  ~CConnectionManager
//
//  Destructor.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CConnectionManager::~CConnectionManager()
{
    if (m_hInternetPing)
    {
        InternetCloseHandle(m_hInternetPing);
    }

    if (m_bProxySaved)
    {
        RestoreProxySettings();
        FreeProxyOptionList(&m_CurrentProxySettings);
    }

    if (m_bForceOnline)
    {
        SetOffline(TRUE);
        TRACE(L"Set wininet back to offline");
    }
    
    if (m_pPreferredConnection)
    {
        m_pPreferredConnection->Release();
    }
}   //  CConnectionManager::~CConnectionManager



//////////////////////////////////////////////////////////////////////////////
//
//  GetCapabilities
//
//  Queries the system for network connection capabilities.  In addition, the
//  number of phone and LAN connections are counted and a preferred connection
//  type is determined.
//
//  parameters:
//      None.
//
//  returns:
//      A bitmask indicating the capabilities that are present.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::GetCapabilities(
    DWORD*              pdwCapabilities
    )
{
    TRACE(L"CConnectionManager::GetCapabilities\n");
    HRESULT             hr = S_OK;

    if (NULL == pdwCapabilities)
    {
        MYASSERT(NULL != pdwCapabilities);
        return E_POINTER;
    }

#ifndef     CONNMGR_INITFROMREGISTRY
    // The #else part of this directive contains test code that retrieves
    // connection capabilities and preference settings from the registry
    //

    DWORD               m_cLanConnections = 0;
    DWORD               m_cPhoneConnections = 0;

    // Initialize the net connection enumeration.  For each interface
    // retrieved, SetProxyBlanket must be called to set the authentication for
    // the interface proxy handle because the Network Connection Manager lives
    // in a remote process with a different security context.
    //
    INetConnectionManager* pmgr = NULL;

    if (   SUCCEEDED(hr = CoCreateInstance(
                                CLSID_ConnectionManager, 
                                NULL, 
                                CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                                IID_PPV_ARG(INetConnectionManager, &pmgr)
                                ) 
                     )
        && SUCCEEDED(hr = SetProxyBlanket(pmgr))
        )
    {
        TRACE(L"INetConnectionManager\n");
        IEnumNetConnection* penum = NULL;
        if (   SUCCEEDED(hr = pmgr->EnumConnections(NCME_DEFAULT, &penum))
            && SUCCEEDED(hr = SetProxyBlanket(penum))
            )
        {
            TRACE(L"IEnumNetConnection\n");

            hr = penum->Reset();
            while (S_OK == hr)
            {
                INetConnection* pnc = NULL;
                ULONG ulRetrieved;
                if (   S_OK == (hr = penum->Next(1, &pnc, &ulRetrieved))
                    && SUCCEEDED(hr = SetProxyBlanket(pnc))
                    )
                {
                    NETCON_PROPERTIES*  pprops = NULL;
                    hr = pnc->GetProperties(&pprops);
                    
                    if (SUCCEEDED(hr))
                    {
                        // Log the network connectivity detected
                        TRACE4(L"INetConnection: %s--%s--%d--%d\n",
                            pprops->pszwName,
                            pprops->pszwDeviceName,
                            pprops->MediaType,
                            pprops->Status);

                        if (IsEnabledConnection(pprops))
                        {
                            switch(pprops->MediaType)    
                            {
                            case NCM_LAN:
                                m_cLanConnections++;
                                if (! (HasConnection(
                                            CONNECTIONTYPE_LAN_INDETERMINATE
                                            )
                                        )
                                    )
                                {
                                    if (HasBroadband())
                                    {
                                        AddConnectionCapability(
                                            CONNECTIONTYPE_LAN_INDETERMINATE
                                            );
                                        ClearConnectionCapability(
                                            CONNECTIONTYPE_LAN_BROADBAND
                                            );
                                    }
                                    else
                                    {
                                        AddConnectionCapability(
                                            CONNECTIONTYPE_LAN_BROADBAND
                                            );
                                    }
                                }
                                break;
                            case NCM_SHAREDACCESSHOST_LAN:
                            case NCM_SHAREDACCESSHOST_RAS:
                                // Do not increment LAN connection count here.
                                // This media type is in addition to the NCM_LAN
                                // for the NIC.
                                //
                                AddConnectionCapability(CONNECTIONTYPE_LAN_ICS);
                                break;
                            case NCM_PHONE:
#ifdef      BLACKCOMB
    // For Whistler, determination of modem capability is done via
    // CObCommunicationManager::CheckDialReady.
                                m_cPhoneConnections++;
                                AddConnectionCapability(CONNECTIONTYPE_MODEM);
#endif  //  BLACKCOMB
                                break;
                            case NCM_ISDN:
                            case NCM_PPPOE:
                                AddConnectionCapability(CONNECTIONTYPE_OTHER);
                                break;
                            }   // switch
                        }
                        NcFreeNetconProperties(pprops);
                    }
                }
                
                if (NULL != pnc)
                {
                    pnc->Release();
                }
            }

            if (S_FALSE == hr)
            {
                // IEnumNetConnection::Next returned S_FALSE to indicate
                // that no more elements were available.
                hr = S_OK;
            }

        }

        if (NULL != penum)
        {
            penum->Release();
        }
    }

    if (NULL != pmgr)
    {
        pmgr->Release();
    }

    DeterminePreferredConnection();

#else
    HKEY                hKey = NULL;
    DWORD               dwSize;

    if(ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                OOBE_MAIN_REG_KEY,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hKey)
            )
        )
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS != (lResult = RegQueryValueEx(hKey,
                                            L"ConnectionCapabilities",
                                            0,
                                            NULL,
                                            (LPBYTE)&m_dwConnectionCapabilities,
                                            &dwSize)
                )
            )
        {
            m_dwConnectionCapabilities = CONNECTIONTYPE_INVALID;
        }
        if (ERROR_SUCCESS != (lResult = RegQueryValueEx(hKey,
                                            L"PreferredConnection",
                                            0,
                                            NULL,
                                            (LPBYTE)&m_dwPreferredConnection,
                                            &dwSize
                                            )
                )
            )
        {
            m_dwPreferredConnection = CONNECTIONTYPE_INVALID;
        }

        RegCloseKey(hKey);
    }
    else
    {
        m_dwConnectionCapabilities = CONNECTIONTYPE_INVALID;
        m_dwPreferredConnection = CONNECTIONTYPE_INVALID;
    }
#endif  //  CONNMGR_INITFROMREGISTRY
    TRACE(L"Exiting CConnectionManager::GetCapabilities\n");
    *pdwCapabilities = m_dwConnectionCapabilities;
    return hr;

}   //  CConnectionManager::GetCapabilities




//////////////////////////////////////////////////////////////////////////////
//
//  SetPreferredConnection
//
//  Set the preferred connection type.  This allows an override of the
//  internally determined preference.
//
//  parameters:
//      dwType          one of the CONNECTIONTYPE_* values from obcomm.h.
//
//  returns:
//      Boolean indicating whether the preferred connection was set.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::SetPreferredConnection(
    const DWORD         dwType,
    BOOL*               pfSupportedType
    )
{
    BOOL            fSupportedType = FALSE;

    switch (dwType)
    {
    case CONNECTIONTYPE_NONE:
        fSupportedType = TRUE;
        break;
    case CONNECTIONTYPE_MODEM:
#ifdef      BLACKCOMB
// Modem capability for Whistler is handled via
// CObCommunicationManager::CheckDialReady.  However, CONNECTIONTYPE_MODEM is a
// valid enum value to pass to this function so we don't want to hit the
// default and assert.  Hence, the case and break aren't ifdef'd.
        if (HasModem())
        {
            fSupportedType = TRUE;
        }
#endif  //  BLACKCOMB
        break;
    case CONNECTIONTYPE_LAN_ICS:
        if (HasIcs())
        {
            fSupportedType = TRUE;
        }
        break;
    case CONNECTIONTYPE_LAN_BROADBAND:
        if (HasBroadband())
        {
            fSupportedType = TRUE;
        }
        break;
    default:
        // Unsupported connection type or multiple connection types
        MYASSERT(FALSE);
    }   //  switch

    if (fSupportedType)
    {
        TRACE1(L"SetPreferredConnection %d", dwType);
        
        m_dwPreferredConnection = dwType;
        GetPreferredConnection();
    }
    else
    {
        TRACE1(L"Unsupported Connection type %d", dwType);
    }
    
    if (NULL != pfSupportedType)
    {
        *pfSupportedType = fSupportedType;
    }

    return fSupportedType;

}   //  CConnectionManager::SetPreferredConnection


//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternet
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if system is connected to the internet via LAN or 
//                      dial-up or can be connected via dial-up
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::ConnectedToInternet(
    BOOL*               pfConnected
    )
{
    DWORD               dwFlags;

    if (NULL == pfConnected)
    {
        MYASSERT(NULL != pfConnected);
        return E_POINTER;
    }

    *pfConnected = InternetGetConnectedState(&dwFlags, 0);

    // Log the network connectivity detected
    TRACE2(L"InternetGetConnectedState %d, 0x%08lx", *pfConnected, dwFlags);
    
    return S_OK;
}   //  CConnectionManager::ConnectedToInternet


///////////////////////////////////////////////////////////
//
// SetPreferredConnectionTcpipProperties
//
STDMETHODIMP 
CConnectionManager::SetPreferredConnectionTcpipProperties(
    BOOL fAutoIpAddress,
    DWORD StaticIp_A,
    DWORD StaticIp_B,
    DWORD StaticIp_C,
    DWORD StaticIp_D,
    DWORD SubnetMask_A,
    DWORD SubnetMask_B,
    DWORD SubnetMask_C,
    DWORD SubnetMask_D,
    DWORD DefGateway_A,
    DWORD DefGateway_B,
    DWORD DefGateway_C,
    DWORD DefGateway_D,
    BOOL fAutoDns,
    DWORD DnsPref_A,
    DWORD DnsPref_B,
    DWORD DnsPref_C,
    DWORD DnsPref_D,
    DWORD DnsAlt_A,
    DWORD DnsAlt_B,
    DWORD DnsAlt_C,
    DWORD DnsAlt_D
    )
{
    HRESULT             hr;
    REMOTE_IPINFO       ipInfo;
    struct in_addr      inaddr;
    WCHAR               rgchStaticIp[INET_ADDRSTRLEN];
    WCHAR               rgchSubnetMask[INET_ADDRSTRLEN];
    WCHAR               rgchDefGateway[2 * INET_ADDRSTRLEN] = L"DefGw=";
    WCHAR               rgchGatewayMetric[2 * INET_ADDRSTRLEN] = L"GwMetric=";
    WCHAR               rgchDnsAddr[3 * INET_ADDRSTRLEN] = L"DNS=";
    WCHAR*              pch = NULL;
    NETCON_PROPERTIES*  pncProps = NULL;

    memset(&ipInfo, 0, sizeof(REMOTE_IPINFO));
    
    hr = m_pPreferredConnection->GetProperties(&pncProps);
    if (FAILED(hr))
    {
        TRACE1(L"Failed to retrieve preferred connection properties (0x%08X)\n", hr);
        goto SetPreferredConnectionTcpipPropertiesExit;
    }

    ipInfo.dwEnableDhcp = fAutoIpAddress;

    if (! fAutoIpAddress)
    {
        // if a static ip address was specified, convert it to a string and add
        // it to the REMOTE_IPINFO structure
        //
        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)StaticIp_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)StaticIp_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)StaticIp_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)StaticIp_D;
        if (! INetNToW(inaddr, rgchStaticIp))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        ipInfo.pszwIpAddrList = rgchStaticIp;

        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)SubnetMask_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)SubnetMask_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)SubnetMask_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)SubnetMask_D;

        if (! INetNToW(inaddr, rgchSubnetMask))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        ipInfo.pszwSubnetMaskList = rgchSubnetMask;

        pch = rgchDefGateway + lstrlen(rgchDefGateway);
        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)DefGateway_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DefGateway_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DefGateway_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DefGateway_D;

        if (! INetNToW(inaddr, pch))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }
        lstrcat(rgchGatewayMetric, L"1");


        TRACE4(L"Tcpip StaticIp %d.%d.%d.%d",
            StaticIp_A, StaticIp_B, StaticIp_C, StaticIp_D);

        TRACE4(L"Tcpip SubnetMask %d.%d.%d.%d",
            SubnetMask_A, SubnetMask_B, SubnetMask_C, SubnetMask_D);

        TRACE4(L"Tcpip DefGateway %d.%d.%d.%d",
            DefGateway_A, DefGateway_B, DefGateway_C, DefGateway_D);

        //ipInfo.pszwIpAddrList = rgchDefGateway;

    }

    if (! fAutoDns)
    {
        // if dns addresses were specified, convert them to strings and add
        // them to the REMOTE_IPINFO structure
        //
       
        pch = rgchDnsAddr + lstrlen(rgchDnsAddr);

        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)DnsPref_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DnsPref_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DnsPref_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DnsPref_D;
        if (! INetNToW(inaddr, pch))
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create dns address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }
        pch += lstrlen(pch);
        *pch++ = L',';

        inaddr.S_un.S_un_b.s_b1 = (BYTE)DnsAlt_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DnsAlt_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DnsAlt_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DnsAlt_D;
        if (! INetNToW(inaddr, pch))
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create alternate dns address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        TRACE4(L"Tcpip DnsPref %d.%d.%d.%d",
            DnsPref_A, DnsPref_B, DnsPref_C, DnsPref_D);
        
        TRACE4(L"Tcpip DnsAlt %d.%d.%d.%d",
            DnsAlt_A, DnsAlt_B, DnsAlt_C, DnsAlt_D);
        
    }

    // plus 4 for 3 semi-colons and the null-terminator
    ipInfo.pszwOptionList = (WCHAR*) malloc((lstrlen(rgchDefGateway) 
                                             + lstrlen(rgchGatewayMetric) 
                                             + lstrlen(rgchDnsAddr) 
                                             + 4)
                                             * sizeof(WCHAR)
                                             );
    if (NULL == ipInfo.pszwOptionList)
    {
        TRACE(L"Failed to allocate memory for option list\n");
        goto SetPreferredConnectionTcpipPropertiesExit;
    }

    wsprintf(ipInfo.pszwOptionList, L"%s;%s;%s;", 
             rgchDefGateway, rgchGatewayMetric, rgchDnsAddr
             );

    hr = SetTcpipProperties(pncProps->guidId, &ipInfo);
    if (FAILED(hr))
    {
        TRACE1(L"Failed to set TCPIP info (0x%08X)\n", hr);
    }

SetPreferredConnectionTcpipPropertiesExit:

    if (NULL != ipInfo.pszwOptionList)
    {
        free(ipInfo.pszwOptionList);
        ipInfo.pszwOptionList = NULL;
    }

    if (NULL != pncProps)
    {
        NcFreeNetconProperties(pncProps);
        pncProps = NULL;
    }

    return hr;

}   //  CObCommunicationManager::SetPreferredConnectionTcpipProperties


///////////////////////////////////////////////////////////
//
// SetTcpipProperties
//
HRESULT 
CConnectionManager::SetTcpipProperties(
    GUID                guid,
    REMOTE_IPINFO*      pipInfo
    )
{
    HRESULT             hr;
    INetCfg*            pNetCfg = NULL;
    ITcpipProperties*   pTcpipProps = NULL;

    hr = GetNetCfgInterface(TRUE, &pNetCfg);
    if (SUCCEEDED(hr))
    {
        hr = GetTcpipPrivateInterface(pNetCfg, &pTcpipProps);
        if (SUCCEEDED(hr))
        {
            hr = pTcpipProps->SetIpInfoForAdapter(&guid, pipInfo);
            TRACE1(L"SetIpInfoForAdapter 0x%08lx", hr);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfg->Apply();
                TRACE1(L"INetCfg::Apply 0x%08lx", hr);
            }
            pTcpipProps->Release();
        }
        ReleaseNetCfgInterface(pNetCfg, TRUE);
    }

    return hr;

}   //  CObCommunicationManager::SetTcpipProperties

//////////////////////////////////////////////////////////////////////////////
//
//  LanConnectionReady
//
//  Determines whether the system has a LAN connection that is connected to the
//  Internet.
//
//  parameters:
//      None.
//
//  returns:
//      Boolean indicating whether or not their is a ready connection.
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::LanConnectionReady()
{
    BOOL                fReady = FALSE;

#ifndef     CONNMGR_INITFROMREGISTRY
    if (HasBroadband() || HasIcs())
    {
        DWORD           dwFlags = 0;
        if (   InternetGetConnectedState(&dwFlags, 0)
            && (INTERNET_CONNECTION_LAN & dwFlags)
            )    
        {
            fReady = TRUE;
        }
    }
#else
    DWORD               dwLanConnectionReady;
    DWORD               dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                OOBE_MAIN_REG_KEY,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hKey)
                         )
        )
    {
        lResult = RegQueryValueEx(hKey,
                                  L"LanConnectionReady",
                                  0,
                                  NULL,
                                  (LPBYTE)&dwLanConnectionReady,
                                  &dwSize
                                  );
        RegCloseKey(hKey);
    }

    fReady = (ERROR_SUCCESS == lResult) ? (BOOL)dwLanConnectionReady : FALSE;
#endif  //  CONNMGR_INITFROMREGISTRY

    return fReady;

}   //  CConnectionManager::LanConnectionReady


//////////////////////////////////////////////////////////////////////////////
//
//  SetProxyBlanket
//
//  Set the authentication settings for the binding handle for the
//  interface proxy.  This is necessary for setting up security for interface
//  pointers returned by a remote process, such as the Network Connections
//  Manager (netman.dll).
//
//  parameters:
//      pUnk            pointer to the interface for which the proxy will be
//                      bound.
//
//  returns:
//      HRESULT returned by CoSetProxyBlanket.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CConnectionManager::SetProxyBlanket(
    IUnknown*           pUnk
    )
{
    HRESULT hr;
    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(IID_PPV_ARG(IUnknown, &pUnkSet));
        if(SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
            pUnkSet->Release();
        }
    }
    return hr;
}   //  CConnectionManager::SetProxyBlanket




//////////////////////////////////////////////////////////////////////////////
//
//  DeterminePreferredConnection
//
//  Determine the preferred connection.  The order of preference is
//  * ICS
//  * Broadband (DSL, cable modem, etc.)
//  * Modem
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::DeterminePreferredConnection()
{
    // REVIEW: Differences between full-screen and desktop in using default
    // connectoid.
    //
    if (HasIcs())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_LAN_ICS;
    }
    else if (HasBroadband())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_LAN_BROADBAND;
    }
#ifdef      BLACKCOMB
// Modem capability for Whistler is handled via
// CObCommunicationManager::CheckDialReady
    else if (HasModem())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_MODEM;
    }
#endif  //  BLACKCOMB
    else    // CONNECTIONTYPE_NONE || CONNECTIONTYPE_LAN_INDETERMINATE
    {
        m_dwPreferredConnection = CONNECTIONTYPE_NONE;
    }

    GetPreferredConnection();

}   //  CConnectionManager::DeterminePreferredConnection


//////////////////////////////////////////////////////////////////////////////
//
//  GetPreferredConnection
//
//  Determine the name of the connectoid for the preferred connection.  
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::GetPreferredConnection()
{
    HRESULT             hr;
    NETCON_MEDIATYPE    ncMediaType = NCM_NONE; // assume no connection

    switch (m_dwPreferredConnection)
    {
    case CONNECTIONTYPE_LAN_ICS:
        ncMediaType = NCM_SHAREDACCESSHOST_LAN;
        break;
    case CONNECTIONTYPE_LAN_BROADBAND:
        ncMediaType = NCM_LAN;
        break;
    }   //  switch(m_dwPreferredConnection)

    // Free up previous preferred connection properties
    //
    if (NULL != m_pPreferredConnection)
    {
        m_pPreferredConnection->Release();
        m_pPreferredConnection = NULL;
    }

    if (NCM_NONE != ncMediaType)
    {
        
        INetConnectionManager* pmgr = NULL;

        if (   SUCCEEDED(hr = CoCreateInstance(
                                    CLSID_ConnectionManager, 
                                    NULL, 
                                    CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                                    IID_PPV_ARG(INetConnectionManager, &pmgr)
                                    ) 
                         )
            && SUCCEEDED(hr = SetProxyBlanket(pmgr))
            )
        {
            TRACE(L"INetConnectionManager\n");
            IEnumNetConnection* penum = NULL;
            if (   SUCCEEDED(hr = pmgr->EnumConnections(NCME_DEFAULT, &penum))
                && SUCCEEDED(hr = SetProxyBlanket(penum))
                )
            {
                TRACE(L"IEnumNetConnection\n");

                MYASSERT(NULL == m_pPreferredConnection);
                hr = penum->Reset();

                // Find the first connection matching the preferred type. This
                // works because the only types we are concerned with are
                // broadband and ICS.  By definition, we should not be here if
                // there are more than 1 of these connections.  If there are
                // more than 1 of these we should be deferring to the HomeNet
                // Wizard.  
                //
                // ONCE THIS OBJECT SUPPORTS MODEM CONNECTIONS OR MULTIPLE
                // BROADBAND CONNECTIONS we'll need a more sophisticated method
                // of determining that we've found the correct connection.
                //
                while (S_OK == hr && NULL == m_pPreferredConnection)
                {
                    INetConnection* pnc = NULL;
                    ULONG ulRetrieved;
                    if (   S_OK == (hr = penum->Next(1, &pnc, &ulRetrieved))
                        && SUCCEEDED(hr = SetProxyBlanket(pnc))
                        )
                    {
                        NETCON_PROPERTIES*  pprops = NULL;
                        hr = pnc->GetProperties(&pprops);
                        
                        // Log the network connectivity detected
                        TRACE4(L"INetConnection: %s--%s--%d--%d\n",
                            pprops->pszwName,
                            pprops->pszwDeviceName,
                            pprops->MediaType,
                            pprops->Status);
                        
                        if (SUCCEEDED(hr))
                        {
                            if (IsEnabledConnection(pprops))
                            {
                                if (ncMediaType == pprops->MediaType)
                                {
                                    m_pPreferredConnection = pnc;
                                    pnc = NULL;
                                }
                            }
                            NcFreeNetconProperties(pprops);
                        }
                    }
                    
                    if (NULL != pnc)
                    {
                        pnc->Release();
                    }
                }

                if (S_FALSE == hr)
                {
                    // IEnumNetConnection::Next returned S_FALSE to indicate
                    // that no more elements were available.
                    hr = S_OK;
                }

            }

            if (NULL != penum)
            {
                penum->Release();
            }
        }

        if (NULL != pmgr)
        {
            pmgr->Release();
        }
    }
}   //  CConnectionManager::GetPreferredConnection

//////////////////////////////////////////////////////////////////////////////
//
//  GetPreferredConnectionName
//
//  Fills in a user-allocated buffer with the name of the connectoid for the
//  preferred connection.
//
//  parameters:
//      szConnectionName    buffer that will recieve the name of the preferred
//                          connectoid
//      cchConnectionName   count of characters that the buffer can hold
//
//  returns:
//      S_OK                if the name is retrieved successfully
//      S_FALSE             if there is no default connectoid
//      E_INVALIDARG        if there is no buffer or if the buffer size is 0
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::GetPreferredConnectionName(
    LPWSTR              szConnectionName,
    DWORD               cchConnectionName
    )
{

    HRESULT             hr = S_FALSE;

    if (NULL == szConnectionName || 0 == cchConnectionName)
    {
        MYASSERT(NULL != szConnectionName);
        MYASSERT(0 < cchConnectionName);
        return E_INVALIDARG;
    }

    if (NULL != m_pPreferredConnection)
    {
        NETCON_PROPERTIES* pprops = NULL;
        hr = m_pPreferredConnection->GetProperties(&pprops);
        if (SUCCEEDED(hr))
        {
            MYASSERT(NULL != pprops);
            if (NULL == pprops->pszwName)
            {
                hr = S_FALSE;
            }

            if (S_OK == hr)
            {
                lstrcpyn(szConnectionName, 
                         pprops->pszwName, 
                         cchConnectionName
                         );        
            }
            NcFreeNetconProperties(pprops);
        }
    }

    return hr;

}   //  CConnectionManager::GetPreferredConnectionName

HRESULT
CConnectionManager::GetNetCfgInterface(
    BOOL                fNeedWriteLock,
    INetCfg**           ppNetCfg
    )
{
    HRESULT             hr;
    INetCfg*            pNetCfg = NULL;

    if (NULL == ppNetCfg)
    {
        ASSERT(NULL != ppNetCfg);
        return E_INVALIDARG;
    }

    *ppNetCfg = NULL;

    hr = CoCreateInstance(CLSID_CNetCfg, 
                          NULL, 
                          CLSCTX_SERVER, 
                          IID_INetCfg, 
                          (LPVOID*)&pNetCfg
                          );
    if (SUCCEEDED(hr))
    {
        INetCfgLock*    pNetCfgLock = NULL;
        if (fNeedWriteLock)
        {
            hr = pNetCfg->QueryInterface(IID_INetCfgLock, (VOID**)&pNetCfgLock);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfgLock->AcquireWriteLock(
                                        5,         // millisec timeout
                                        L"Out-of-Box Experience", 
                                        NULL       // name of previous holder
                                        );
                if (S_FALSE == hr)
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
                    TRACE(L"AcquireWriteLock failed");
                }
                pNetCfgLock->Release();
            }
            else
            {
                TRACE1(L"QueryInterface IID_INetCfgLock 0x%08lx", hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pNetCfg->Initialize(NULL);
            if (SUCCEEDED(hr))
            {
                *ppNetCfg = pNetCfg;
            }
            else
            {
                TRACE1(L"INetCfg Initialize 0x%08lx", hr);
            }
        }
    }
    else
    {
        TRACE1(L"CoCreateInstance CLSID_CNetCfg IID_INetCfg 0x%08lx", hr);
    }

    if (FAILED(hr))
    {
        if (pNetCfg != NULL)
        {
            pNetCfg->Release();
        }
    }

    return hr;

}   //  CConnectionManager::GetNetCfgInterface

void
CConnectionManager::ReleaseNetCfgInterface(
    INetCfg*            pNetCfg,
    BOOL                fHasWriteLock
    )
{
    HRESULT             hr = S_OK;

    if (NULL != pNetCfg)
    {
        hr = pNetCfg->Uninitialize();

        INetCfgLock*    pNetCfgLock = NULL;
        if (fHasWriteLock)
        {
            hr = pNetCfg->QueryInterface(IID_INetCfgLock, (VOID**)&pNetCfgLock);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfgLock->ReleaseWriteLock();
                pNetCfgLock->Release();
            }
        }
        pNetCfg->Release();
    }

    
}   //  CConnectionManager::ReleaseNetCfgInterface

HRESULT
CConnectionManager::GetTcpipPrivateInterface(
    INetCfg*            pNetCfg,
    ITcpipProperties**  ppTcpipProperties
    )
{
    HRESULT             hr;

    if (NULL == ppTcpipProperties)
    {
        return E_INVALIDARG;
    }

    INetCfgClass*   pncclass = NULL;

    hr = pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS, 
                                   IID_INetCfgClass,
                                   (void**)&pncclass
                                   );
    if (SUCCEEDED(hr))
    {
        INetCfgComponent*   pnccItem = NULL;

        hr = pncclass->FindComponent(NETCFG_TRANS_CID_MS_TCPIP, &pnccItem);
        if (SUCCEEDED(hr))
        {
            INetCfgComponentPrivate*    pinccp = NULL;
            hr = pnccItem->QueryInterface(IID_INetCfgComponentPrivate,
                                          (void**) &pinccp
                                          );
            if (SUCCEEDED(hr))
            {
                hr = pinccp->QueryNotifyObject(IID_ITcpipProperties,
                                               (void**) ppTcpipProperties
                                               );
                if (FAILED(hr))
                {
                    TRACE1(L"QueryNotifyObject IID_ITcpipProperties 0x%08lx", hr);
                }
                pinccp->Release();
                pinccp = NULL;
            }
            else
            {
                TRACE1(L"QueryInterface IID_INetCfgComponentPrivate 0x%08lx", hr);
            }

            pnccItem->Release();
            pnccItem = NULL;
        }
        else
        {
            TRACE1(L"FindComponent NETCFG_TRANS_CID_MS_TCPIP 0x%08lx", hr);
        }
        
        pncclass->Release();
        pncclass = NULL;
    }
    else
    {
        TRACE1(L"QueryNetCfgClass IID_INetCfgClass 0x%08lx", hr);
    }
    
    return hr;
}   //  CConnectionManager::GetTcpipPrivateInterface

STDAPI InternetOpenWrap(
    LPCTSTR pszAgent,
    DWORD dwAccessType,
    LPCTSTR pszProxy,
    LPCTSTR pszProxyBypass,
    DWORD dwFlags,
    HINTERNET * phFileHandle
    )
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        TRACE1(L"InternetOpen failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


STDAPI InternetOpenUrlWrap(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    LPCTSTR   pszHeaders,
    DWORD     dwHeadersLength,
    DWORD     dwFlags,
    DWORD_PTR dwContext,
    HINTERNET * phFileHandle
    )
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        TRACE1(L"InternetOpenUrl failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

STDAPI HttpQueryInfoWrap(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex
    )
{
    HRESULT hr = S_OK;

    if (!HttpQueryInfo(hRequest, dwInfoLevel, lpvBuffer, lpdwBufferLength, lpdwIndex))
    {
        DWORD dwError;

        dwError = GetLastError();
        TRACE1(L"HttpQueryInfo failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

BOOL
IsGlobalOffline(
    VOID
    )

/*++

Routine Description:

    Determines whether wininet is in global offline mode

Arguments:

    None

Return Value:

    BOOL
        TRUE    - offline
        FALSE   - online

--*/

{
    DWORD   dwState = 0;
    DWORD   dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(
        NULL,
        INTERNET_OPTION_CONNECTED_STATE,
        &dwState,
        &dwSize
        ))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
        {
            fRet = TRUE;
        }
    }

    return fRet;
}



VOID
SetOffline(
    IN BOOL fOffline
    )

/*++

Routine Description:

    Sets wininet's offline mode

Arguments:

    fOffline    - online or offline

Return Value:

    None.

--*/

{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    
    if (fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

STDAPI PingWebServer(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    BOOL*     pfConnected
    )
{    
    HRESULT hr = E_FAIL;
    HINTERNET hOpenUrlSession;
 
    *pfConnected = FALSE;

    hr = InternetOpenUrlWrap(
        hInternet, 
        pszUrl,
        NULL,
        0,
        INTERNET_FLAG_NO_UI |
            INTERNET_FLAG_PRAGMA_NOCACHE |
            INTERNET_FLAG_NO_CACHE_WRITE |
            INTERNET_FLAG_RELOAD,
        NULL,
        &hOpenUrlSession);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwStatusCode;
        
        hr = HttpQueryInfoWrap(
            hOpenUrlSession,
            HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
            (LPVOID) &dwStatusCode,
            &dwSize,
            NULL);

        if (SUCCEEDED(hr))
        {
            // HTTP status code greater than or equal to 500 means server
            // or network problem occur
            *pfConnected = (dwStatusCode < 500);

            TRACE1(L"HTTP status code from WPA HTTP server %d", dwStatusCode);
        }

        InternetCloseHandle(hOpenUrlSession);
    }

    return hr;
}

BOOL
CConnectionManager::GetInternetHandleForPinging(
    HINTERNET* phInternet
    )
{
    static const WCHAR OOBE_HTTP_AGENT_NAME[] =  
        L"Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)";
    static const int   TIMEOUT_IN_MILLISEC = 30000;
        
    if (m_hInternetPing == NULL)
    {
        HINTERNET hInternet;
        
        if (SUCCEEDED(InternetOpenWrap(
            OOBE_HTTP_AGENT_NAME,
            PRE_CONFIG_INTERNET_ACCESS,
            NULL,
            NULL,
            0,
            &hInternet
            )))
        {
            DWORD     dwValue;

            dwValue = TIMEOUT_IN_MILLISEC;
            InternetSetOption(
                hInternet,
                INTERNET_OPTION_CONNECT_TIMEOUT,
                &dwValue,
                sizeof(DWORD));

            m_hInternetPing = hInternet;
        }

    }

    *phInternet = m_hInternetPing;

    return (m_hInternetPing != NULL);
    
}

//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternetEx
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if the system is connected to the internet. Note it may
//                      trigger autodial if it is enabled and no connection is
//                      available when this is called
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::ConnectedToInternetEx(
    BOOL*               pfConnected
    )
{
    const WCHAR MS_URL[] = L"http://WPA.one.microsoft.com";
    
    HINTERNET hInternet;
    HRESULT   hr = E_FAIL;
    
    *pfConnected = FALSE;

    TRACE(L"tries to connect to the WPA HTTP server");

    if (IsGlobalOffline())
    {
        SetOffline(FALSE);
        m_bForceOnline = TRUE;
        TRACE(L"Force wininet to go online");
    }
    
    DisableRasAutodial();
    
    //
    // Try to use the proxy settings from winnt32.exe first because it is
    // quite likely a proper configuration. If the settings
    // is not available or if we failed to connect to the web server 
    // using these settings, use the original settings and check the web
    // server connectivity once more.
    //

    if (GetInternetHandleForPinging(&hInternet))
    {
        DWORD     dwDisable = 0;
        DWORD     dwSize = sizeof(DWORD);
        DWORD     dwOrigDisable;

        if (!InternetQueryOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            (LPVOID) &dwOrigDisable,
            &dwSize))
        {
            // Assume the orginal state is autodial-enabled.
            dwOrigDisable = 0;
        }

        // InternetSetOption for INTERNET_OPTION_DISABLE_AUTODIAL affects the
        // behavior of an application, e.g. it cause InternetAutodial 
        // elsewhere to fail. It does not affect other applications, however.
        dwDisable = 1;
        InternetSetOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            &dwDisable,
            sizeof(DWORD));
        
        if (m_bUseProxy)
        {
            //
            // If we have already applied or we can successfully apply the
            // proxy settings
            //
            if (ApplyWinntProxySettings())
            {
                // User or we may have update the proxy and other settings in
                // registry
                InternetSetOption(
                    hInternet,
                    INTERNET_OPTION_REFRESH,
                    NULL,
                    0); 
                
                hr = PingWebServer(hInternet, MS_URL, pfConnected);         
            }
        }

        if (*pfConnected == FALSE)
        {
            //
            // Restore proxy setting if it is already applied
            //
            if (m_bUseProxy)
            {
                // Don't revert the change by SetProxySettings call.
                RestoreProxySettings();
            }

            // User or we may have update the proxy and other settings in
            // registry
            InternetSetOption(
                hInternet,
                INTERNET_OPTION_REFRESH,
                NULL,
                0); 

            hr = PingWebServer(hInternet, MS_URL, pfConnected);
        }
        
        InternetSetOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            &dwOrigDisable,
            sizeof(DWORD));        
    }

    RestoreRasAutoDial();

    TRACE1(L"%s connect to WPA HTTP server",
        (*pfConnected) ? L"could" : L"could not");

    return hr;
}   //  CConnectionManager::ConnectedToInternetEx

typedef struct tagConnmgrPARAM
{
    HWND                  hwnd;
    CConnectionManager    *pConnmgr;
} CONNMGRPARAM, *PCONNMGRPARAM;

DWORD WINAPI ConnectedToInternetExThread(LPVOID vpParam)
{
    BOOL          fConnected = FALSE;
    PCONNMGRPARAM pParam = (PCONNMGRPARAM) vpParam;
    HRESULT       hr = S_OK;
    
    hr = pParam->pConnmgr->ConnectedToInternetEx(&fConnected);

    PostMessage(pParam->hwnd, WM_OBCOMM_NETCHECK_DONE, fConnected, hr);
    
    GlobalFree(pParam);
    
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  AsyncConnectedToInternetEx
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if the system is connected to the internet. Note it may
//                      trigger autodial if it is enabled and no connection is
//                      available when this is called
//      FALSE           otherwise
//
//  note:
//      Deprecated.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::AsyncConnectedToInternetEx(
    const HWND          hwnd
    )
{
    DWORD         threadId;
    HANDLE        hThread;
    PCONNMGRPARAM pParam = NULL;
    HRESULT       hr = S_OK;
    DWORD         dwError;

    pParam = (PCONNMGRPARAM) GlobalAlloc(GPTR, sizeof(CONNMGRPARAM));
    if (pParam)
    {
        pParam->hwnd = hwnd;
        pParam->pConnmgr = this;
        
        hThread = CreateThread(NULL, 0, ConnectedToInternetExThread, pParam, 0, &threadId);
        if (hThread == NULL)
        {
            dwError = GetLastError();
            hr = HRESULT_FROM_WIN32(dwError);        
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        // Notify the script so that it won't hang
        PostMessage(hwnd, WM_OBCOMM_NETCHECK_DONE, FALSE, hr);
    }
    
    return hr;
}   //  CConnectionManager::AsyncConnectedToInternetEx

//////////////////////////////////////////////////////////////////////////////
//
//  IsEnabledConnection
//
//  Determines whether a connection should be considered as having Internet
//  capability or not, based on its media type and current status.
//
//  parameters:
//      ncMedia         The media type of the connection
//      ncStatus        The current status of the connection
//
//  returns:
//      TRUE            We should not considered it as having Internet capability
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::IsEnabledConnection(
    NETCON_PROPERTIES* pprops
    )
{
    BOOL bRet;
    
    switch (pprops->MediaType)
    {
    case NCM_LAN:
        bRet = (pprops->Status != NCS_DISCONNECTED);
        if (bRet && m_bExclude1394 && Is1394Adapter(&(pprops->guidId)))
        {
            TRACE1(L"%s not considered as LAN", pprops->pszwName);
            bRet = FALSE;
        }
        break;
        
    case NCM_SHAREDACCESSHOST_LAN:
    case NCM_SHAREDACCESSHOST_RAS:
        bRet = (pprops->Status != NCS_DISCONNECTED);
        break;
    default:
        bRet = TRUE;
        
    }

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
//  SaveProxySettings
//
//  Save existing proxy settings for current user.  
//
//  returns:
//      TRUE            The value is successfully saved
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::SaveProxySettings()
{
    if (!m_bProxySaved)
    {
        TRACE(TEXT("try to save the existing proxy settings"));
        
        if (AllocProxyOptionList(&m_CurrentProxySettings))
        {
            DWORD dwBufferLength = sizeof(m_CurrentProxySettings);
            
            if (InternetQueryOption(
                NULL,
                INTERNET_OPTION_PER_CONNECTION_OPTION,
                &m_CurrentProxySettings,
                &dwBufferLength
                ))
            {
                m_bProxySaved = TRUE;
                TRACE(TEXT("successfully save the proxy settings"));
            }
            else
            {
                FreeProxyOptionList(&m_CurrentProxySettings);
            }
        }

        if (!m_bProxySaved)
        {
            TRACE1(
                TEXT("fail to save the proxy settings (Error %d)"),
                GetLastError()
                );
        }
    }

    return m_bProxySaved;
    
}

//////////////////////////////////////////////////////////////////////////////
//
//  RestoreProxySettings
//
//  Restore the setting captured by SaveProxySettings.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::RestoreProxySettings()
{   

    BOOL bRestored = FALSE;

    if (m_bProxyApplied)
    {
        TRACE(TEXT("try to restore the original proxy settings"));
        
        bRestored = InternetSetOption(
            NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION,
            &m_CurrentProxySettings,
            sizeof(m_CurrentProxySettings)
            );

        if (bRestored)
        {
            m_bProxyApplied = FALSE;
            TRACE(TEXT("successfully restored the proxy settings"));
        }
        else
        {
            TRACE1(
                TEXT("failed to restore the proxy settings (WININET Error %d)"),
                GetLastError()
                );
        }
    }

}

static LPTSTR
pDuplicateString(
    LPCTSTR szText
    )
{
    int    cchText;
    LPTSTR szOutText;
    
    if (szText == NULL)
    {
        return NULL;
    }

    cchText = lstrlen(szText);
    szOutText = (LPTSTR) GlobalAlloc(GPTR, sizeof(TCHAR) * (cchText + 1));
    if (szOutText)
    {
        lstrcpyn(szOutText, szText, cchText + 1);
    }

    return szOutText;
}


//////////////////////////////////////////////////////////////////////////////
//
//  ApplyWinntProxySettings
//
//  Apply the proxy settings for NIC saved during winnt32.exe to the current user.
//  Before the values is applied, it makes sure that existing settings is saved.
//
//  returns:
//      TRUE            the proxy settings was successfully applied
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::ApplyWinntProxySettings()
{
    #define MAX_URL_LENGTH 2048

    DWORD     dwProxyFlags = 0;
    LPTSTR    szProxyList = NULL;
    TCHAR     szWinntPath[MAX_PATH];

    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();

    //
    // Apply proxy settings if it has not been applied.
    //
    if (m_bProxySaved && !m_bProxyApplied)
    {
        TRACE1(TEXT("tries to apply proxy settings, saved in %s"),
            WINNT_INF_FILENAME);

        if (GetCanonicalizedPath(szWinntPath, WINNT_INF_FILENAME))
        {
            DWORD dwEnableOobeProxy;
            
            dwEnableOobeProxy = GetPrivateProfileInt(
                OOBE_PROXY_SECTION,
                OOBE_ENABLE_OOBY_PROXY,
                0,
                szWinntPath
                );

            if (dwEnableOobeProxy)
            {
                INTERNET_PER_CONN_OPTION_LIST PrevProxySettings;
                
                if (AllocProxyOptionList(&PrevProxySettings))
                {
                    INTERNET_PER_CONN_OPTION* pOption = PrevProxySettings.pOptions;
                    DWORD                     dwBufferLength = sizeof(PrevProxySettings);
                    TCHAR                     szBuffer[MAX_URL_LENGTH];

                    pOption[0].Value.dwValue = GetPrivateProfileInt(
                        OOBE_PROXY_SECTION,
                        OOBE_FLAGS,
                        0,
                        szWinntPath
                        );
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_PROXY_SERVER,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[1].Value.pszValue = pDuplicateString(szBuffer);
                    }
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_PROXY_BYPASS,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[2].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTOCONFIG_URL,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[3].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    pOption[4].Value.dwValue = GetPrivateProfileInt(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTODISCOVERY_FLAGS,
                        0,
                        szWinntPath
                        );
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTOCONFIG_SECONDARY_URL,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[5].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    m_bProxyApplied = InternetSetOption(
                        NULL,
                        INTERNET_OPTION_PER_CONNECTION_OPTION,
                        &PrevProxySettings,
                        sizeof(PrevProxySettings)
                        );

                    FreeProxyOptionList(&PrevProxySettings);
                    
                }
            }

        }

        if (m_bProxyApplied)
        {
            TRACE(TEXT("successfully load the proxy settings"));
        }
        else
        {
            TRACE1(TEXT("could not load the proxy settings (WIN32 Error %d)"),
                GetLastError());
        }
    }
    
    return m_bProxyApplied;
}

void
CConnectionManager::UseWinntProxySettings()
{
    m_bUseProxy = TRUE;
}

void
CConnectionManager::DisableWinntProxySettings()
{
    TCHAR szWinntPath[MAX_PATH];
    
    if (GetCanonicalizedPath(szWinntPath, WINNT_INF_FILENAME))
    {
        WritePrivateProfileString(
            OOBE_PROXY_SECTION,
            OOBE_ENABLE_OOBY_PROXY,
            TEXT("0"),
            szWinntPath
            );
        
        TRACE1(TEXT("disabled the proxy settings in %s"),
            WINNT_INF_FILENAME);
    }
}

BOOL
CConnectionManager::AllocProxyOptionList(
    INTERNET_PER_CONN_OPTION_LIST *pList
    )
{
    INTERNET_PER_CONN_OPTION*     pOption;        

    pOption = (INTERNET_PER_CONN_OPTION*) GlobalAlloc(
        GPTR,
        sizeof(INTERNET_PER_CONN_OPTION) * NUM_PROXY_OPTIONS);

    if (pOption)
    {
        pList->dwSize = sizeof(*pList);
        pList->pszConnection = NULL;
        pList->dwOptionCount = NUM_PROXY_OPTIONS;
        pList->pOptions = pOption;
    
        pOption[0].dwOption = INTERNET_PER_CONN_FLAGS;
        pOption[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
        pOption[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
        pOption[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
        pOption[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
        pOption[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    }
    else
    {
        pList->pOptions = NULL;
    }

    return (pOption != NULL);
}

void
CConnectionManager::FreeProxyOptionList(
    INTERNET_PER_CONN_OPTION_LIST *pList
    )
{
    INTERNET_PER_CONN_OPTION* pOption = pList->pOptions;
    if (pOption)
    {
        if (pOption[1].Value.pszValue)
        {
            GlobalFree(pOption[1].Value.pszValue);
        }

        if (pOption[2].Value.pszValue)
        {
            GlobalFree(pOption[2].Value.pszValue);
        }

        if (pOption[3].Value.pszValue)
        {
            GlobalFree(pOption[3].Value.pszValue);
        }

        if (pOption[5].Value.pszValue)
        {
            GlobalFree(pOption[5].Value.pszValue);
        }

        GlobalFree(pOption);

        pList->pOptions = NULL;
    }
}

void CConnectionManager::DisableRasAutodial()
{
    DWORD dwValue = RAS_AUTODIAL_DISABLED;
    
    if (m_dwRasAutodialDisable == RAS_AUTODIAL_DONT_KNOW)
    {         
        DWORD dwSize = sizeof(m_dwRasAutodialDisable);
        
        if (RasGetAutodialParam(
            RASADP_LoginSessionDisable,
            &m_dwRasAutodialDisable,
            &dwSize
            ) != ERROR_SUCCESS)
        {
            m_dwRasAutodialDisable = RAS_AUTODIAL_ENABLED;
        }
        else
        {
            TRACE1(
                L"Save value of RASADP_LoginSessionDisable %d",
                m_dwRasAutodialDisable
                );
        }
    }

    if (RasSetAutodialParam(
        RASADP_LoginSessionDisable,
        &dwValue,
        sizeof(dwValue)
        ) == ERROR_SUCCESS)
    {
        TRACE(L"Disabled RAS Autodial for current logon session");
    }
}

void CConnectionManager::RestoreRasAutoDial()
{
    if (m_dwRasAutodialDisable != RAS_AUTODIAL_DONT_KNOW)
    {
        if (RasSetAutodialParam(
            RASADP_LoginSessionDisable,
            &m_dwRasAutodialDisable,
            sizeof(m_dwRasAutodialDisable)
            ) == ERROR_SUCCESS)
        {
            TRACE(L"Restore value of RAS Autodial for current logon session");
        }
    }
}

HRESULT CConnectionManager::GetProxySettings(
    BOOL* pbUseAuto,
    BOOL* pbUseScript,
    BSTR* pszScriptUrl,
    BOOL* pbUseProxy,
    BSTR* pszProxy
    )
{
    HRESULT hr = E_FAIL;

    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();
    
    if (m_bProxySaved)
    {
        INTERNET_PER_CONN_OPTION* pOption = m_CurrentProxySettings.pOptions;
        
        *pbUseAuto = pOption[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT;
        *pbUseScript = pOption[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL;
        *pbUseProxy = pOption[0].Value.dwValue & PROXY_TYPE_PROXY;

        if (pOption[1].Value.pszValue)
        {
            *pszProxy = SysAllocString(pOption[1].Value.pszValue);
        }
        else
        {
            *pszProxy = NULL;
        }

        if (pOption[3].Value.pszValue)
        {
            *pszScriptUrl = SysAllocString(pOption[3].Value.pszValue);
        }
        else
        {
            *pszScriptUrl = NULL;
        }
        
        hr = S_OK;
    }

    return hr;

}

HRESULT CConnectionManager::SetProxySettings(
    BOOL bUseAuto,
    BOOL bUseScript,
    BSTR szScriptUrl,
    BOOL bUseProxy,
    BSTR szProxy
    )
{
    HRESULT hr = E_FAIL;

    //
    // We don't behavior correctly in this->ConnectedToInternetEx if we
    // also use proxy settings saved in winnt32.
    //
    MYASSERT(!m_bUseProxy);
    
    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();
        
    if (m_bProxySaved)
    {
        INTERNET_PER_CONN_OPTION_LIST ProxySettings;
        
        if (AllocProxyOptionList(&ProxySettings))
        {
            INTERNET_PER_CONN_OPTION* pOption = ProxySettings.pOptions;

            pOption[0].Value.dwValue = PROXY_TYPE_DIRECT;
            if (bUseAuto)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
            }
            if (bUseScript)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
            }
            if (bUseProxy)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_PROXY;
            }

            pOption[1].Value.pszValue = szProxy;

            pOption[2].Value.pszValue = NULL;

            pOption[3].Value.pszValue = szScriptUrl;

            pOption[4].Value.dwValue = m_CurrentProxySettings.pOptions[4].Value.dwValue;
            if (bUseAuto)
            {
                pOption[4].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;
            }
            
            pOption[5].Value.pszValue = m_CurrentProxySettings.pOptions[5].Value.pszValue;

            TRACE5(TEXT("tries to set LAN proxy: %d, %s, %s, %d"),
                pOption[0].Value.dwValue,
                pOption[1].Value.pszValue,
                pOption[3].Value.pszValue,
                pOption[4].Value.dwValue,
                pOption[5].Value.pszValue
                );

            if (InternetSetOption(
                NULL,
                INTERNET_OPTION_PER_CONNECTION_OPTION,
                &ProxySettings,
                sizeof(ProxySettings)
                ))
            {
                m_bProxyApplied = TRUE;
                hr = S_OK;
            }

            // so that we don't free the memory from the caller in
            // FreeProxyOptionList
            pOption[1].Value.pszValue = NULL;
            pOption[3].Value.pszValue = NULL;
            pOption[5].Value.pszValue = NULL;
            
            FreeProxyOptionList(&ProxySettings);
        }
    }

    if (SUCCEEDED(hr))
    {
        TRACE(TEXT("successfully set the proxy settings"));
    }
    else
    {
        TRACE1(TEXT("could not set the proxy settings (WIN32 Error %d)"),
            GetLastError());
    }


    return hr;
}

STDMETHODIMP
CConnectionManager::GetPublicLanCount(int* pcPublicLan)
{
    PSTRINGLIST PubList = NULL;
    HRESULT hr = S_OK;
    
    EnumPublicAdapters(&PubList);

    int i = 0;

    for (PSTRINGLIST p = PubList; p; p = p->Next)
    {
        i++;
    }

    *pcPublicLan = i;        

    if (PubList)
    {
        DestroyList(PubList);
    }
    
    retur