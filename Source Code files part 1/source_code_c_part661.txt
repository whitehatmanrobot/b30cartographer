       DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvSysPacket: Packet Size %lx.%lx\n",
                                        pktLen, PacketSize));

                return;
        }

        if ((pktLen == SPX_CR_PKTLEN) &&
                (destConnId == 0xFFFF) &&
                (pHdr->hdr_ConnCtrl & SPX_CC_CR))
        {
                spxConnHandleConnReq(
                        pHdr,
                        pRemoteAddr);

                return;
        }

        //
        // [SA] Bug #14917
        // Some SPX SYS packets (no extended ack field) may come in with the SPX2 bit set.
        // Make sure we don't discard these packets.
        //

        // if ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) && (pktLen < MIN_IPXSPX2_HDRSIZE))
        // {
        //         return;
        // }

        GETSHORT2SHORT(&ackNum, &pHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pHdr->hdr_SrcConnId;

        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnSysPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnSysPacket: packet received dest %lx src %lx\n",
                                pHdr->hdr_DestSkt, pHdr->hdr_SrcSkt));

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnSysPacket: Id %lx NOT FOUND\n", destConnId));
                return;
        }

        do
        {

                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnSysPacket: Id %lx Conn %lx\n",
                                        destConnId, pSpxConnFile));

                //      This could be one of many packets. Connection ack/Session negotiate/
                //      Session setup, Data Ack, Probe/Ack, Renegotiate/Ack. We shunt
                //      off all the packets to different routines but process the data
                //      ack packets here.
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
               //
               // We have the connection.  We should update the dest. sock # in
               // it in case it changed.  Unix machines do do that sometimes.
               // SCO bug 7676
               //
                SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAddr);

                lockHeld = TRUE;

                //      Restart watchdog timer if started.
                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                {
                        //      This will either successfully restart or not affect the timer
                        //      if it is currently running.
                        SpxTimerCancelEvent(
                                pSpxConnFile->scf_WTimerId,
                                TRUE);

                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                switch (SPX_MAIN_STATE(pSpxConnFile))
                {
                case SPX_CONNFILE_CONNECTING:

                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                        lockHeld = FALSE;

                        spxConnHandleSessPktFromSrv(
                                pHdr,
                                pRemoteAddr,
                                pSpxConnFile);

                        break;

                case SPX_CONNFILE_LISTENING:

                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                        lockHeld = FALSE;

                        spxConnHandleSessPktFromClient(
                                pHdr,
                                pRemoteAddr,
                                pSpxConnFile);

                        break;

                case SPX_CONNFILE_ACTIVE:
                case SPX_CONNFILE_DISCONN:

                        //      NOTE:   Our ack to a session setup might get dropped.
                        //                      But the SS Ack is similar to a normal SPX2 ack.
                        //                      We dont have to do anything special.

                        //      Received ack/nack/reneg/reneg ack/disc associated packet.
                        //      Disc packets except ordrel ack have non-zero datastream type.
                        if ((pHdr->hdr_ConnCtrl &
                                        (SPX_CC_SYS | SPX_CC_ACK | SPX_CC_NEG | SPX_CC_SPX2)) ==
                    (SPX_CC_SYS | SPX_CC_ACK | SPX_CC_NEG | SPX_CC_SPX2))
                        {
                                //      We received a renegotiate packet. Ignore all ack values
                                //      in a reneg req.
                                SpxConnProcessRenegReq(pSpxConnFile, pHdr, pRemoteAddr, lockHandle);
                                lockHeld = FALSE;
                                break;
                        }

                        //      Set ack numbers for connection.
            SPX_SET_ACKNUM(
                                pSpxConnFile, ackNum, allocNum);

                        //      Check if we are an ack/nack packet in which case call process
                        //      ack. Note that the spx2 orderly release ack is a normal spx2 ack.
                        if (((pHdr->hdr_ConnCtrl & SPX_CC_ACK) == 0) &&
                                (pHdr->hdr_DataType == 0))
                        {
                                SpxConnProcessAck(pSpxConnFile, pHdr, lockHandle);
                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      Just process the numbers we got.
                                SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                                lockHeld = FALSE;
                        }

                        //      If the remote wants us to send an ack, do it.
                        if (pHdr->hdr_ConnCtrl & SPX_CC_ACK)
                        {
                                //      First copy the remote address in connection.
                                SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                                if (!lockHeld)
                                {
                                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                                        lockHeld = TRUE;
                                }

                                SpxConnSendAck(pSpxConnFile, lockHandle);
                                lockHeld = FALSE;
                                break;
                        }

                        break;

                default:

                        //      Ignore this packet.
                        DBGPRINT(RECEIVE, WARN,
                                        ("SpxConnSysPacket: Ignoring packet, state is not active\n"));
                        break;
                }

        } while (FALSE);

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Remove reference added on connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvDiscPacket(
    IN  PUCHAR              LookaheadBuffer,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
    IN  UINT                LookaheadSize
    )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/
{
        NTSTATUS                                status;
        PIPXSPX_HDR                             pHdr;
        USHORT                                  srcConnId, destConnId,
                                                        pktLen, seqNum, ackNum, allocNum;
        PSPX_CONN_FILE                  pSpxConnFile;
        CTELockHandle                   lockHandle;
        BOOLEAN                                 lockHeld;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (LookaheadSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pHdr->hdr_AllocNum);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pHdr->hdr_PktType != SPX_PKT_TYPE))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvDiscPacket: Packet Size %lx\n",
                                        pktLen));

                return;
        }

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pHdr->hdr_SrcConnId;
        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDiscPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnDiscPacket: packet received dest %lx src %lx\n",
                                pHdr->hdr_DestSkt, pHdr->hdr_SrcSkt));

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnDiscPacket: Id %lx NOT FOUND", destConnId));

                return;
        }

        do
        {
                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnDiscPacket: Id %lx Conn %lx DiscType %lx\n",
                                        destConnId, pSpxConnFile, pHdr->hdr_DataType));

                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                lockHeld = TRUE;

                //      Unless we are in the active/disconnecting, but send state = idle
                //      and recv state = idle/recv posted, we ignore all disconnect packets.
                if (((SPX_MAIN_STATE(pSpxConnFile) != SPX_CONNFILE_ACTIVE)      &&
                         (SPX_MAIN_STATE(pSpxConnFile) != SPX_CONNFILE_DISCONN))        ||
                        ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE)                &&
                         (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE))          ||
                        ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_IDLE)                &&
                         (SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_POSTED))             ||
                        !(IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                      ||
                        (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT)))
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx, %lx, %lx.%lx, %d.%d\n",
                    pSpxConnFile,
                                        SPX_MAIN_STATE(pSpxConnFile),
                                        SPX_SEND_STATE(pSpxConnFile), SPX_RECV_STATE(pSpxConnFile),
                    (IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage)),
                    (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT))));

                        break;
                }

                //      If we have received a disconnect, process received ack to complete any
                //      pending sends before we allow the disconnect. This ack number will be
                //      the last word on this session.
                SPX_SET_ACKNUM(
                        pSpxConnFile, ackNum, allocNum);

                SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                switch (pHdr->hdr_DataType)
                {
        case SPX2_DT_ORDREL:

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: Recd ORDREl!\n"));

                        //      Need to deal with all sthe states.
                        //      Restart watchdog timer if started.
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                        {
                                //      This will either successfully restart or not affect the timer
                                //      if it is currently running.
                                SpxTimerCancelEvent(
                                        pSpxConnFile->scf_WTimerId,
                                        TRUE);

                                pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                        }

                        //      On receive, we do check the seq num for the orderly release, just
                        //      like for a data packet.
                        //      If this was not already indicated, indicate it now. That is all
                        //      we do for an orderly release. When our client does a orderly rel
                        //      and we receive the ack for that, call abortive with success.

                        //      Verify ord rel packet, this checks if seq nums match also.
                        if ((pktLen  != MIN_IPXSPX2_HDRSIZE) ||
                                ((pHdr->hdr_ConnCtrl &
                                        (SPX_CC_ACK | SPX_CC_EOM | SPX_CC_SPX2)) !=
                                                (SPX_CC_ACK | SPX_CC_EOM | SPX_CC_SPX2)) ||
                                (pHdr->hdr_DataType != SPX2_DT_ORDREL) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, DBG1,
                                                ("SpxConnDiscPacket: OR Failed/Ignored %lx, %lx.%lx.%lx\n",
                                                pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum,
                                                pSpxConnFile->scf_RecvListTail));

                                break;
                        }

                        //      If it passed above test, but seq number is incorrect, schedule
                        //      to send an ack.
                        if (seqNum != pSpxConnFile->scf_RecvSeqNum)
                        {
                                USHORT  NumToResend;

                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDiscPacket: Unexpected seq on %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                //      Calculate number to be resent. If we expect sequence 1 and receive
                                //      2 for eg., we need to send a nack, else we send an ack.
                                if (SPX2_CONN(pSpxConnFile) &&
                                        UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_RecvSeqNum) &&
                                        !UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_SentAllocNum))
                                {
                                        NumToResend = (USHORT)(seqNum - pSpxConnFile->scf_RecvSeqNum + 1);
                                        SpxConnSendNack(pSpxConnFile, NumToResend, lockHandle);
                                        lockHeld = FALSE;
                                }

                                break;
                        }

                        //      Copy address for when ack is to be sent.
                        SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                        if (pSpxConnFile->scf_RecvListHead == NULL)
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, INFO,
                                                ("SpxConnDiscPacket: NO DATA ORDREL %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                SpxConnProcessOrdRel(pSpxConnFile, lockHandle);
                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, DBG1,
                                                ("SpxConnDiscPacket: DATA ORDREL %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                //      Set flag in last recd buffer
                pSpxConnFile->scf_RecvListTail->rr_State |= SPX_RECVPKT_ORD_DISC;
                        }

                        break;

        case SPX2_DT_IDISC:

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx Recd IDISC %lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_RefCount));

                        DBGPRINT(RECEIVE, INFO,
                                        ("SpxConnDiscPacket: SEND %d. RECV %d.%lx!\n",
                                                IsListEmpty(&pSpxConnFile->scf_ReqLinkage),
                                                IsListEmpty(&pSpxConnFile->scf_RecvLinkage),
                                                pSpxConnFile->scf_RecvDoneLinkage));

                        if (!((pktLen  == MIN_IPXSPX_HDRSIZE) ||
                                        ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  == MIN_IPXSPX2_HDRSIZE))) ||
                                !(pHdr->hdr_ConnCtrl & SPX_CC_ACK) ||
                                (pHdr->hdr_DataType != SPX2_DT_IDISC) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDiscPacket:IDISC Ignored %lx.%lx.%lx.%lx\n",
                                                        pSpxConnFile, seqNum,
                                                        pSpxConnFile->scf_RecvSeqNum,
                                                        pSpxConnFile->scf_RecvListTail));
                                break;
                        }

                        //      Copy address for when ack is to be sent.
                        SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                        if (pSpxConnFile->scf_RecvListHead == NULL)
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, INFO,
                                                ("SpxConnDiscPacket: NO RECV DATA IDISC %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                SpxConnProcessIDisc(pSpxConnFile, lockHandle);

                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      Set flag in last recd buffer

                pSpxConnFile->scf_RecvListTail->rr_State |= SPX_RECVPKT_IDISC;
                        }

                        break;

        case SPX2_DT_IDISC_ACK:

                        //      Done with informed disconnect. Call abort connection with
                        //      status success. That completes the pending disconnect request
                        //      with status_success.

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx Recd IDISC ack!\n", pSpxConnFile));

                        if (!((pktLen == MIN_IPXSPX_HDRSIZE) ||
                                        ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  == MIN_IPXSPX2_HDRSIZE))) ||
                                (pHdr->hdr_DataType != SPX2_DT_IDISC_ACK) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDiscPacket:Ver idisc ack Failed %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));
                                break;
                        }

                        //      We should be in the right state to accept this.
                        if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_IDISC))
                        {
                                spxConnAbortiveDisc(
                                        pSpxConnFile,
                                        STATUS_SUCCESS,
                                        SPX_CALL_RECVLEVEL,
                                        lockHandle,
                                        FALSE);     // [SA] bug #15249

                                lockHeld = FALSE;
                        }

                        break;

                default:

                        KeBugCheck(0);
                }


        } while (FALSE);

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Remove reference added on connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvBufferPkt(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  UINT                LookaheadOffset,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN  UINT                PacketSize,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/
{
        PNDIS_PACKET    pNdisPkt;
        PSPX_RECV_RESD  pRecvResd;
        ULONG                   bytesCopied;
        BOOLEAN                 fEom;
        NDIS_STATUS             ndisStatus = NDIS_STATUS_SUCCESS;
        PBYTE                   pData = NULL;
        PNDIS_BUFFER    pNdisBuffer = NULL;

        if (PacketSize > 0)
        {
                //      Allocate memory for this data.
                if (pData = (PBYTE)SpxAllocateMemory(PacketSize))
                {
                        //      Describe memory with a ndis buffer descriptor.
                        NdisAllocateBuffer(
                                &ndisStatus,
                                &pNdisBuffer,
                                SpxDevice->dev_NdisBufferPoolHandle,
                                pData,
                                PacketSize);
                }
                else
                {
                        ndisStatus = NDIS_STATUS_RESOURCES;
                }
        }

        if (ndisStatus == NDIS_STATUS_SUCCESS)
        {
                //      Allocate a ndis receive packet.
                SpxAllocRecvPacket(SpxDevice, &pNdisPkt, &ndisStatus);
                if (ndisStatus == NDIS_STATUS_SUCCESS)
                {
                        //      Queue the buffer into the packet if there is one.
                        if (pNdisBuffer)
                        {
                                NdisChainBufferAtBack(
                                        pNdisPkt,
                                        pNdisBuffer);
                        }

                        fEom            = ((SPX_CONN_MSG(pSpxConnFile) &&
                                                   (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM)) ||
                                                   SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR));

                        pRecvResd                               = RECV_RESD(pNdisPkt);
                        pRecvResd->rr_DataOffset= 0;

#if DBG
                        //      Store seq number
                        GETSHORT2SHORT(&pRecvResd->rr_SeqNum , &pIpxSpxHdr->hdr_SeqNum);
#endif

                        pRecvResd->rr_State             =
                                (SPX_RECVPKT_BUFFERING |
                                (SPX_CONN_FLAG2(
                                        pSpxConnFile, SPX_CONNFILE2_PKT_NOIND) ? SPX_RECVPKT_INDICATED : 0) |
                                (fEom ? SPX_RECVPKT_EOM : 0) |
                                ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) ? SPX_RECVPKT_SENDACK : 0));

                        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK)
                        {
                                //      copy the remote address in connection.
                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;
                        }

                        pRecvResd->rr_Request   = NULL;
                        pRecvResd->rr_ConnFile  = pSpxConnFile;

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxRecvBufferPkt: %lx Len %lx DataPts %lx F %lx\n",
                                                pSpxConnFile, PacketSize, pData, pRecvResd->rr_State));

                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                        //      Call ndis transfer data. Copy ENTIRE packet. copySize has
                        //      been modified so use original values.
                        ndisStatus      = NDIS_STATUS_SUCCESS;
                        bytesCopied = 0;
                        if (PacketSize > 0)
                        {
                                (*IpxTransferData)(
                                        &ndisStatus,
                                        MacBindingHandle,
                                        MacReceiveContext,
                                        LookaheadOffset,
                                        PacketSize,
                                        pNdisPkt,
                                        &bytesCopied);
                        }

                        if (ndisStatus != STATUS_PENDING)
                        {
                                SpxTransferDataComplete(
                                        pNdisPkt,
                                        ndisStatus,
                                        bytesCopied);
                        }

                        //      BUG: FDDI returns pending which messes us up here. 
                        ndisStatus      = NDIS_STATUS_SUCCESS;
                }
        }

        //      ASSERT: Lock will be freed in the success case.
        if (ndisStatus != NDIS_STATUS_SUCCESS)
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvBufferPkt: FAILED!\n"));

                END_PROCESS_PACKET(pSpxConnFile, FALSE, FALSE);
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                if (pData != NULL)
                {
                        SpxFreeMemory(pData);
                }

                if (pNdisBuffer != NULL)
                {
                        NdisFreeBuffer(pNdisBuffer);
                }
        }

        return;
}




VOID
SpxRecvDataPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadSize,
        IN  UINT                LookaheadOffset,
        IN  UINT                PacketSize
        )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/

{
        NTSTATUS                        status;
        PIPXSPX_HDR                     pIpxSpxHdr;
        USHORT                          srcConnId, destConnId,
                                                pktLen, seqNum, ackNum, allocNum;
        ULONG                           receiveFlags;
        PSPX_CONN_FILE          pSpxConnFile;
        PTDI_IND_RECEIVE        pRecvHandler;
        PVOID                           pRecvCtx;
        PIRP                            pRecvIrp;
        ULONG                           bytesTaken, iOffset, copySize, bytesCopied;
        CTELockHandle           lockHandle;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PSPX_RECV_RESD          pRecvResd;
        NDIS_STATUS                     ndisStatus;
        PREQUEST                        pRequest = NULL;
        BOOLEAN                         fEom,
                                                fImmedAck = FALSE, fLockHeld = FALSE, fPktDone = FALSE;

        pIpxSpxHdr      = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (PacketSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pktLen > PacketSize)                   ||
                (pIpxSpxHdr->hdr_PktType != SPX_PKT_TYPE))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDataPacket: Packet Size %lx.%lx\n",
                                        pktLen, PacketSize));

                return;
        }

        //      We keep and use the remote id in the net format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDataPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnDataPacket: packet received dest %lx src %lx seq %lx\n",
                                pIpxSpxHdr->hdr_DestSkt, pIpxSpxHdr->hdr_SrcSkt, seqNum));

        if ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                (pktLen < MIN_IPXSPX2_HDRSIZE))
        {
                return;
        }

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnDataPacket: Id %lx NOT FOUND", destConnId));
                return;
        }
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

#if 0
        //
        // We have the connection.  We should update the dest. sock # in
        // it in case it changed.  Unix machines do do that sometimes.
        // SCO bug 7676
        //
        SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAddr);
#endif

        fLockHeld = TRUE;
        do
        {
                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnDataPacket: Id %lx Conn %lx\n",
                                        destConnId, pSpxConnFile));

                //      Restart watchdog timer if started.
                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                {
                        //      This will either successfully restart or not affect the timer
                        //      if it is currently running.
                        SpxTimerCancelEvent(
                                pSpxConnFile->scf_WTimerId,
                                TRUE);

                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                if (SPX_CONN_ACTIVE(pSpxConnFile))
                {
                        //      Verify data packet, this checks if seq nums match also.
                        if ((pIpxSpxHdr->hdr_SrcConnId != pSpxConnFile->scf_RemConnId) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId) ||
                                !((pktLen  >= MIN_IPXSPX_HDRSIZE) ||
                                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  >= MIN_IPXSPX2_HDRSIZE))))
                        {
                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDataPacket: Failed %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                break;
                        }

                        //      If it passed above test, but seq number is incorrect, schedule
                        //      to send an ack.
                        if (seqNum != pSpxConnFile->scf_RecvSeqNum)
                        {
                                USHORT  NumToResend;

                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDataPacket: Unexpected seq on %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                ++SpxDevice->dev_Stat.DataFramesRejected;
                ExInterlockedAddLargeStatistic(
                    &SpxDevice->dev_Stat.DataFrameBytesRejected,
                    pktLen - (SPX2_CONN(pSpxConnFile) ?
                                                                        MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));

                                //
                                // Bug #16975: Set the remote ack addr for use in SpxConnSendAck()
                                //
                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;

                                //      Calculate number to be resent. If we expect sequence 1 and receive
                                //      2 for eg., we need to send a nack, else we send an ack.
                                if (SPX2_CONN(pSpxConnFile) &&
                                        UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_RecvSeqNum) &&
                                        !UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_SentAllocNum))
                                {
                                        NumToResend = (USHORT)(seqNum - pSpxConnFile->scf_RecvSeqNum + 1);
                                        SpxConnSendNack(pSpxConnFile, NumToResend, lockHandle);
                                        fLockHeld = FALSE;
                                }
                                else
                                {
                                        SpxConnSendAck(pSpxConnFile, lockHandle);
                                        fLockHeld = FALSE;
                                }

                                break;
                        }

                        //      If we have received an orderly release, we accept no more data
                        //      packets.
                        if (SPX_CONN_FLAG(
                                        pSpxConnFile,
                    (SPX_CONNFILE_IND_IDISC |
                     SPX_CONNFILE_IND_ODISC))

                                ||

                                ((pSpxConnFile->scf_RecvListTail != NULL) &&
                 ((pSpxConnFile->scf_RecvListTail->rr_State &
                                                SPX_RECVPKT_DISCMASK) != 0)))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDataPacket: After ord rel %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                break;
                        }

                        //      We are processing a packet OR a receive is about to complete.
                        if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT))
                        {
                BEGIN_PROCESS_PACKET(pSpxConnFile, seqNum);
                        }
                        else
                        {
                                //      Already processing a packet. Or a receive is waiting to
                                //      complete. Get out.
                                break;
                        }

                        //      Set ack numbers for connection.
            SPX_SET_ACKNUM(
                                pSpxConnFile, ackNum, allocNum);

                        SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

            iOffset = MIN_IPXSPX2_HDRSIZE;
                        if (!SPX2_CONN(pSpxConnFile))
                        {
                                iOffset = 0;
                                if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR))
                                {
                                        iOffset = MIN_IPXSPX_HDRSIZE;
                                }
                        }

                        copySize        = pktLen - iOffset;
                        fEom            = ((SPX_CONN_MSG(pSpxConnFile) &&
                                                   (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM)) ||
                                                   SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR));

                        //      Do we attempt to piggyback? If not, fImmedAck is true.
                        //      For SPX1 we dont piggyback.
                        //      Bug #18253
                        fImmedAck       = (!SPX2_CONN(pSpxConnFile)     ||
                                                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM) == 0));

                        //      If we do not have EOM to indicate AND we are a zero-sized packet
                        //      then just consume this packet.
                        if (!fEom && (copySize == 0))
                        {
                                DBGPRINT(RECEIVE, ERR,
                                                ("SpxConnDataPacket: ZERO LENGTH PACKET NO EOM %lx.%lx\n",
                                                        pSpxConnFile, seqNum));

                                fPktDone = TRUE;
                                break;
                        }

                        receiveFlags     = TDI_RECEIVE_NORMAL;
            receiveFlags        |= ((fEom ? TDI_RECEIVE_ENTIRE_MESSAGE : 0) |
                                                                (((MacOptions &
                                                                        NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) != 0) ?
                                                                                TDI_RECEIVE_COPY_LOOKAHEAD : 0));

            ++SpxDevice->dev_Stat.DataFramesReceived;
            ExInterlockedAddLargeStatistic(
                &SpxDevice->dev_Stat.DataFrameBytesReceived,
                copySize);

                        //      Ok, we accept this packet. Depending on our state.
                        switch (SPX_RECV_STATE(pSpxConnFile))
                        {
                        case SPX_RECV_PROCESS_PKTS:

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: recv completions on %lx\n",
                                                                pSpxConnFile));

                                        goto BufferPacket;

                        case SPX_RECV_IDLE:

                                //      If recv q is non-empty we are buffering data.
                                //      Also, if no receive handler goto buffer data. Also, if receives
                                //      are being completed, buffer this packet.
                                if ((pSpxConnFile->scf_RecvListHead != NULL)                                    ||
                                        !(IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                      ||
                                        !(pRecvHandler = pSpxConnFile->scf_AddrFile->saf_RecvHandler))
                                {
                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: RecvListHead non-null %lx\n",
                                                                pSpxConnFile));

                                        goto BufferPacket;
                                }

                                if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND))
                                {
                                        pRecvCtx = pSpxConnFile->scf_AddrFile->saf_RecvHandlerCtx;

                                        //      Don't indicate this packet again.
                    SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND);

#if DBG
                                        CTEAssert(pSpxConnFile->scf_CurRecvReq == NULL);

                                        //      Debug code to ensure we dont reindicate data/indicate
                                        //      when previously indicated data waiting with afd.

                                        //
                                        // Comment this out for Buf # 10394. we'r hitting this assert
                                        // even when there was no data loss.
                                        //
                                        // CTEAssert(pSpxConnFile->scf_IndBytes == 0);
                                        CTEAssert(pSpxConnFile->scf_PktSeqNum != seqNum);

                                        pSpxConnFile->scf_PktSeqNum     = seqNum;
                                        pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                                        pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;

                                        pSpxConnFile->scf_IndBytes  = copySize;
                                        pSpxConnFile->scf_IndLine       = __LINE__;


#endif
                                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                                        bytesTaken = 0;
                                        status = (*pRecvHandler)(
                                                        pRecvCtx,
                                                                        pSpxConnFile->scf_ConnCtx,
                                                                        receiveFlags,
                                    LookaheadSize - iOffset,
                                                                        copySize,
                                    &bytesTaken,
                                                                    LookaheadBuffer + iOffset,
                                                                        &pRecvIrp);

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: IND Flags %lx.%lx ConnID %lx,\
                                                                %lx Ctx %lx SEQ %lx Size %lx . %lx .%lx IND Status %lx\n",
                                                                pIpxSpxHdr->hdr_ConnCtrl,
                                                                receiveFlags,
                                                                destConnId,
                                                                pSpxConnFile,
                                                                pSpxConnFile->scf_ConnCtx,
                                seqNum,
                                                                LookaheadSize - iOffset,
                                                                copySize,
                                                                bytesTaken,
                                                                status));

                                        DBGPRINT(RECEIVE, INFO,
                                                        ("SpxConnDataPacket: %x %x %x %x %x %x %x %x %x %x %x %x\n",
                                                                *(LookaheadBuffer+iOffset),
                                                                *(LookaheadBuffer+iOffset+1),
                                                                *(LookaheadBuffer+iOffset+2),
                                                                *(LookaheadBuffer+iOffset+3),
                                                                *(LookaheadBuffer+iOffset+4),
                                                                *(LookaheadBuffer+iOffset+5),
                                                                *(LookaheadBuffer+iOffset+6),
                                                                *(LookaheadBuffer+iOffset+7),
                                                                *(LookaheadBuffer+iOffset+8),
                                                                *(LookaheadBuffer+iOffset+9),
                                                                *(LookaheadBuffer+iOffset+10),
                                                                *(LookaheadBuffer+iOffset+11)));

                                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                                        if (status == STATUS_SUCCESS)
                                        {
                                                //      Assume all data accepted.
                                                CTEAssert((bytesTaken != 0) || fEom);
                                                fPktDone        = TRUE;

#if DBG
                                                //      Set this to 0, since we just indicated, there could
                                                //      not have been other data.
                                                pSpxConnFile->scf_IndBytes  = 0;
#endif

                                                break;
                                        }

                                        if (status == STATUS_MORE_PROCESSING_REQUIRED)
                                        {

                                                //      Queue irp into connection, change state to receive
                                                //      posted and fall thru.
                                                pRequest        = SpxAllocateRequest(
                                                                                SpxDevice,
                                                                                pRecvIrp);

                                                IF_NOT_ALLOCATED(pRequest)
                                                {
                                                        pRecvIrp->IoStatus.Status =
                                                                                        STATUS_INSUFFICIENT_RESOURCES;
                                                        IoCompleteRequest (pRecvIrp, IO_NETWORK_INCREMENT);
                                                        break;
                                                }

                                                //      If there was indicated but not received data waiting
                                                //      (which in this path there will never be, the request
                                                //      could be completed given the data filled it up, and
                                                //      the lock released.
                                                SpxConnQueueRecv(
                                                        pSpxConnFile,
                                                        pRequest);

                                                CTEAssert(pRequest == pSpxConnFile->scf_CurRecvReq);
                                        }
                                        else if (IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
                                        {
                                                //      Data was not accepted. Need to buffer data and
                                                //      reduce window.
                                                goto BufferPacket;
                                        }

                                        //      Fall through to recv_posted.
                                }
                                else
                                {
                                        DBGPRINT(RECEIVE, WARN,
                                                        ("SpxConnDataPacket: !!!Ignoring %lx Seq %lx\n",
                                                                pSpxConnFile,
                                                                seqNum));

                                        break;
                                }

                        case SPX_RECV_POSTED:

                                if (pSpxConnFile->scf_RecvListHead != NULL)
                                {
                                        //      This can happen also. Buffer packet if it does.
                                        goto BufferPacket;
                                }

                                //      If a receive irp is posted, then process the receive irp. If
                                //      we fell thru we MAY already will have an irp.
                                if (pRequest == NULL)
                                {
                                        CTEAssert(!IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
                                        CTEAssert(pSpxConnFile->scf_CurRecvReq != NULL);
                                        pRequest = pSpxConnFile->scf_CurRecvReq;
                                }

                                //      Process receive. Here we do not need to worry about
                                //      indicated yet not received data. We just deal with
                                //      servicing the current packet.
                                CTEAssert(pRequest == pSpxConnFile->scf_CurRecvReq);
                                if ((LookaheadSize == PacketSize) &&
                                        (pSpxConnFile->scf_CurRecvSize >= copySize))
                                {
                                        bytesCopied = 0;
                                        status          = STATUS_SUCCESS;
                                        if (copySize > 0)
                                        {
                                                status = TdiCopyBufferToMdl(
                                                                        LookaheadBuffer,
                                                                        iOffset,
                                                                        copySize,
                                                                        REQUEST_TDI_BUFFER(pRequest),
                                                                        pSpxConnFile->scf_CurRecvOffset,
                                                                        &bytesCopied);

                                                CTEAssert(NT_SUCCESS(status));
                                                if (!NT_SUCCESS(status))
                                                {
                                                        //      Abort request with this status. Reset request
                                                        //      queue to next request if one is available.
                                                }

                                                DBGPRINT(RECEIVE, DBG,
                                                                ("BytesCopied %lx CopySize %lx, Recv Size %lx.%lx\n",
                                                                        bytesCopied, copySize,
                                                                        pSpxConnFile->scf_CurRecvSize,
                                                                        pSpxConnFile->scf_CurRecvOffset));
                                        }

                                        //      Update current request values and see if this request
                                        //      is to be completed. Either zero or fEom.
                                        pSpxConnFile->scf_CurRecvOffset += bytesCopied;
                                        pSpxConnFile->scf_CurRecvSize   -= bytesCopied;

#if DBG
                                        //      Decrement indicated data count
                                        if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND))
                                        {
                                                if (bytesCopied != 0)
                                                {
                                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                                        pSpxConnFile->scf_IndBytes      -= bytesCopied;
                                                }
                                        }
#endif

                                        if (SPX_CONN_STREAM(pSpxConnFile)                       ||
                                                (pSpxConnFile->scf_CurRecvSize == 0)    ||
                                                fEom)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Set status
                                                REQUEST_STATUS(pRequest) = STATUS_SUCCESS;
                                                REQUEST_INFORMATION(pRequest)=
                                                                                                pSpxConnFile->scf_CurRecvOffset;

                                                if (!SPX_CONN_STREAM(pSpxConnFile)               &&
                                                        (pSpxConnFile->scf_CurRecvSize == 0) &&
                                                        !fEom)
                                                {
                                                        REQUEST_STATUS(pRequest) = STATUS_RECEIVE_PARTIAL;
                                                }

                                                DBGPRINT(RECEIVE, DBG,
                                                                ("spxConnData: Completing recv %lx with %lx.%lx\n",
                                                                        pRequest, REQUEST_STATUS(pRequest),
                                    REQUEST_INFORMATION(pRequest)));

                                                //      Dequeue this request, Set next recv if one exists.
                                                SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_RecvDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                        }

                                        fPktDone = TRUE;
                                }
                                else
                                {
                                        //      Need to allocate a ndis receive packet for transfer
                                        //      data.
                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: %lx.%lx Tranfer data needed!\n",
                                                                copySize, pSpxConnFile->scf_CurRecvSize));

                                        if (copySize > pSpxConnFile->scf_CurRecvSize)
                                        {
                                                //      Partial receive. Buffer and then deal with it.
                                                goto BufferPacket;
                                        }

                                        //      Allocate a ndis receive packet.
                                        SpxAllocRecvPacket(SpxDevice, &pNdisPkt, &ndisStatus);
                                        if (ndisStatus != NDIS_STATUS_SUCCESS)
                                        {
                                                break;
                                        }

                                        //      Describe the receive irp's data with a ndis buffer
                                        //      descriptor.
                                        if (copySize > 0)
                                        {
                                                SpxCopyBufferChain(
                                                        &ndisStatus,
                                                        &pNdisBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        REQUEST_TDI_BUFFER(pRequest),
                                                        pSpxConnFile->scf_CurRecvOffset,
                                                        copySize);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        //      Free the recv packet
                                                        SpxPktRecvRelease(pNdisPkt);
                                                        break;
                                                }

                                                //      Queue the buffer into the packet
                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisBuffer);
                                        }

                                        //      Don't care about whether this is indicated or not here
                                        //      as it is not a buffering packet.
                                        pRecvResd                               = RECV_RESD(pNdisPkt);
                                        pRecvResd->rr_Id        = IDENTIFIER_SPX;
                                        pRecvResd->rr_State             =
                                                ((fEom ? SPX_RECVPKT_EOM : 0) |
                                                (SPX_CONN_FLAG2(
                                                        pSpxConnFile, SPX_CONNFILE2_PKT_NOIND) ? SPX_RECVPKT_INDICATED : 0) |
                                                 (fImmedAck ? SPX_RECVPKT_IMMEDACK : 0) |
                                                 ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) ?
                                                        SPX_RECVPKT_SENDACK : 0));

                                        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK)
                                        {
                                                //      copy the remote address in connection.
                                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;
                                        }

                                        pRecvResd->rr_Request   = pRequest;
                                        pRecvResd->rr_ConnFile  = pSpxConnFile;

                                        //      reference receive request
                                        REQUEST_INFORMATION(pRequest)++;

                                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                                        fLockHeld = FALSE;

                                        //      Call ndis transfer data.
                                        ndisStatus      = NDIS_STATUS_SUCCESS;
                                        bytesCopied = 0;
                                        if (copySize > 0)
                                        {
                                                (*IpxTransferData)(
                                                        &ndisStatus,
                                                        MacBindingHandle,
                                                        MacReceiveContext,
                                                        iOffset + LookaheadOffset,
                                                        copySize,
                                                        pNdisPkt,
                                                        &bytesCopied);
                                        }

                                        if (ndisStatus != STATUS_PENDING)
                                        {
                                                SpxTransferDataComplete(
                                                        pNdisPkt,
                                                        ndisStatus,
                                                        bytesCopied);
                                        }
                                }

                                break;

                        default:

                                KeBugCheck(0);
                                break;
                        }

                        break;

BufferPacket:

                        SpxRecvBufferPkt(
                                pSpxConnFile,
                                MacBindingHandle,
                                MacReceiveContext,
                                iOffset + LookaheadOffset,
                                pIpxSpxHdr,
                                copySize,
                                RemoteAddress,
                                lockHandle);

                        fLockHeld = FALSE;
                }

        } while (FALSE);

        //      Here we process a received ack.
        if (!fLockHeld)
        {
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                fLockHeld = TRUE;
        }

        //      Send an ack if one was asked for. And we are done with this packet.
        if (fPktDone)
        {
                END_PROCESS_PACKET(pSpxConnFile, FALSE, TRUE);
        }

        if ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) && fPktDone)
        {
                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        fLockHeld = TRUE;
                }

                //      First copy the remote address in connection.
                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;

                //      #17564
                if (fImmedAck                                                                                     ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT) ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK))
                {
                        SpxConnSendAck(pSpxConnFile, lockHandle);
                        fLockHeld = FALSE;
                }
                else
                {
                        SpxConnQWaitAck(pSpxConnFile);
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Deref the connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvFlushBytes(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      ULONG                           BytesToFlush,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PNDIS_PACKET                            pNdisPkt;
        PNDIS_BUFFER                            pNdisBuffer;
        PSPX_RECV_RESD                          pRecvResd;
        PBYTE                                           pData;
        ULONG                                           dataLen, copyLen;
        BOOLEAN                                         fLockHeld = TRUE, fWdwOpen = FALSE;
        USHORT                                          discState       = 0;
        int                                                     numPkts = 0, numDerefs = 0;

        DBGPRINT(RECEIVE, DBG,
                        ("SpxRecvFlushBytes: %lx Flush %lx\n",
                                pSpxConnFile, BytesToFlush));

        while (((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL) &&
                   ((BytesToFlush > 0) ||
                    ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)))
        {
                //      A buffering recv packet will have ATMOST one ndis buffer descriptor
                //      queued in, which will describe a segment of memory we have
                //      allocated. An offset will also be present indicating the data
                //      to start reading from (or to indicate from to AFD).
                CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
                pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                        pRecvResd, NDIS_PACKET, ProtocolReserved);

                NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);

                //      Initialize pData
                pData = NULL;
                dataLen = 0;

                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                        CTEAssert(pData != NULL);
                        CTEAssert((LONG)dataLen >= 0);
                }

                if ((BytesToFlush == 0) && (dataLen != 0))
                {
                        //      Don't flush this packet.
                        break;
                }

                //      Allow for zero data, eom only packets.
                copyLen = MIN((dataLen - pRecvResd->rr_DataOffset), BytesToFlush);

                DBGPRINT(RECEIVE, DBG,
                                ("SpxRecvFlushBytes: %lx Pkt %lx DataLen %lx Copy %lx Flush %lx\n",
                                        pSpxConnFile, pNdisPkt, dataLen, copyLen, BytesToFlush));

                //      Adjust various values to see whats done whats not
        pRecvResd->rr_DataOffset                        += (USHORT)copyLen;
                BytesToFlush                                            -= (ULONG)copyLen;

#if DBG
                if (copyLen != 0)
                {
                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                        pSpxConnFile->scf_IndBytes      -= copyLen;
                }
#endif

                if (pRecvResd->rr_DataOffset == dataLen)
                {
                        //      Packet consumed. Free it up. Check if disc happened.
                        discState = (pRecvResd->rr_State & SPX_RECVPKT_DISCMASK);
                        CTEAssert((discState == 0) ||
                                                (pRecvResd == pSpxConnFile->scf_RecvListTail));

                        numDerefs++;
                        SpxConnDequeueRecvPktLock(pSpxConnFile, pNdisPkt);
                        if (pNdisBuffer != NULL)
                        {
                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                CTEAssert(pNdisBuffer != NULL);
                                NdisFreeBuffer(pNdisBuffer);
                                SpxFreeMemory(pData);
                        }

                        SpxPktRecvRelease(pNdisPkt);

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxRecvFlushBytes: !!!ALL INDICATED on %lx.%lx.%lx.%lx\n",
                                                pSpxConnFile, pNdisPkt, pNdisBuffer, pData));

            INCREMENT_WINDOW(pSpxConnFile);
                        fWdwOpen = TRUE;
                }
                else
                {
                        //      Took only part of this packet. Get out.
                        break;
                }
        }

        if (fWdwOpen && (pSpxConnFile->scf_RecvListHead == NULL))
        {
                //      Send an ack as our windows probably opened up. Dont wait to
                //      piggyback here...
                DBGPRINT(RECEIVE, DBG,
                                ("spxRecvFlushBytes: Send ACK %lx\n",
                                        pSpxConnFile));

#if DBG_WDW_CLOSE
                //      If packets been indicated we have started buffering. Also
                //      check if window is now zero.
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        li = pSpxConnFile->scf_WdwCloseTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                //      Set new average close time
                                pSpxConnFile->scf_WdwCloseAve += value;
                                pSpxConnFile->scf_WdwCloseAve /= 2;
                                DBGPRINT(RECEIVE, DBG,
                                                ("V %ld AVE %ld\n",
                                                        value, pSpxConnFile->scf_WdwCloseAve));
                        }
                }
#endif

                SpxConnSendAck(pSpxConnFile, LockHandleConn);
                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
        }

        //      Check if disconnect happened
        switch (discState)
        {
        case SPX_RECVPKT_IDISC:

                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered IDISC %lx\n",
                                        pSpxConnFile));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case SPX_RECVPKT_ORD_DISC:

                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered ORDREL %lx\n",
                                        pSpxConnFile));

                SpxConnProcessOrdRel(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case (SPX_RECVPKT_IDISC | SPX_RECVPKT_ORD_DISC):

                //      IDISC has more priority.
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered IDISC *AND* ORDREL %lx\n",
                                        pSpxConnFile));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        default:

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




BOOLEAN
SpxRecvIndicatePendingData(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

        BOOLEAN - Receive was queued => TRUE

--*/
{
        ULONG                           indicateFlags;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PREQUEST                        pRequest;
        PIRP                            pRecvIrp;
        ULONG                           bytesTaken, totalSize, bufSize;
        PTDI_IND_RECEIVE        pRecvHandler;
        PVOID                           pRecvCtx;
        PSPX_RECV_RESD          pRecvResd;
        NTSTATUS                        status;
        PBYTE                           lookaheadData;
        ULONG                           lookaheadSize;
        BOOLEAN                         fLockHeld = TRUE, fRecvQueued = FALSE;


        while  ((pRecvHandler = pSpxConnFile->scf_AddrFile->saf_RecvHandler)    &&
                        ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL)                  &&
                        (IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                               &&
                        ((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0)                    &&
                        ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) == 0))
        {
                //      Once a receive is queued we better get out.
                CTEAssert(!fRecvQueued);

                //      Initialize lookahead values
                lookaheadData = NULL;
                lookaheadSize = 0;

                //      We have no indicated but pending data, and there is some data to
                //      indicate. Figure out how much. Indicate upto end of message or as
                //      much as we have.

                //      A buffering recv packet will have ATMOST one ndis buffer descriptor
                //      queued in, which will describe a segment of memory we have
                //      allocated. An offset will also be present indicating the data
                //      to start reading from (or to indicate from to AFD).
                CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
                pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                        pRecvResd, NDIS_PACKET, ProtocolReserved);

                NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);
                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &lookaheadData, &lookaheadSize);
                        CTEAssert(lookaheadData != NULL);
                        CTEAssert((LONG)lookaheadSize >= 0);
                }

                //      Allow for zero data, eom only packets.
                lookaheadSize -= pRecvResd->rr_DataOffset;
                totalSize          = lookaheadSize;
                lookaheadData += pRecvResd->rr_DataOffset;

                //      If this packet contained data then eom must also have been
                //      indicated at the time all the data was consumed.
                CTEAssert((lookaheadSize > 0) ||
                                        ((pRecvResd->rr_DataOffset == 0) &&
                                         ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)));

#if DBG
                CTEAssert (pSpxConnFile->scf_CurRecvReq == NULL);

                //      Debug code to ensure we dont reindicate data/indicate
                //      when previously indicated data waiting with afd.
                CTEAssert(pSpxConnFile->scf_IndBytes == 0);
                CTEAssert(pSpxConnFile->scf_PktSeqNum != pRecvResd->rr_SeqNum);

                pSpxConnFile->scf_PktSeqNum     = pRecvResd->rr_SeqNum;
                pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;
#endif

                pRecvResd->rr_State     |= SPX_RECVPKT_INDICATED;

                //      Go ahead and walk the list of waiting packets. Get total size.
                while ((pRecvResd->rr_Next != NULL) &&
                           ((pRecvResd->rr_State & SPX_RECVPKT_EOM) == 0))
                {
                        //      Check next packet.
                        pRecvResd = pRecvResd->rr_Next;

#if DBG
                        CTEAssert(pSpxConnFile->scf_PktSeqNum != pRecvResd->rr_SeqNum);

                        pSpxConnFile->scf_PktSeqNum     = pRecvResd->rr_SeqNum;
                        pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                        pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;
#endif

                        pRecvResd->rr_State     |= SPX_RECVPKT_INDICATED;

                        pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                                pRecvResd, NDIS_PACKET, ProtocolReserved);

                        NdisQueryPacket(pNdisPkt, NULL, NULL, NULL, &bufSize);
                        CTEAssert((LONG)bufSize >= 0);

                        //      Allow for zero data, eom only packets.
                        totalSize       += bufSize;
                }

#if DBG
        pSpxConnFile->scf_IndBytes  = totalSize;
                pSpxConnFile->scf_IndLine       = __LINE__;

                //      There better not be any pending receives. If so, we have data
                //      corruption about to happen.
                if (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))
                {
                        DBGBRK(FATAL);
                        KeBugCheck(0);
                }
#endif

                indicateFlags = TDI_RECEIVE_NORMAL | TDI_RECEIVE_COPY_LOOKAHEAD;
                if ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)
                {
                        indicateFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
                }

                pRecvCtx = pSpxConnFile->scf_AddrFile->saf_RecvHandlerCtx;
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                bytesTaken = 0;
                status = (*pRecvHandler)(
                                                pRecvCtx,
                                                pSpxConnFile->scf_ConnCtx,
                                                indicateFlags,
                                                lookaheadSize,
                                                totalSize,
                                                &bytesTaken,
                                                lookaheadData,
                                                &pRecvIrp);

                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnIndicatePendingData: IND Flags %lx Size %lx .%lx IND Status %lx\n",
                                        indicateFlags,
                                        totalSize,
                                        bytesTaken,
                                        status));

                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                if (status == STATUS_SUCCESS)
                {
                        //      Assume all data accepted. Free bytesTaken worth of data packets.
                        //      Sometimes AFD returns STATUS_SUCCESS to just flush the data, so
                        //      we can't assume it took only one packet (since lookahead only
                        //      had that information).
                        CTEAssert(bytesTaken == totalSize);
                        SpxRecvFlushBytes(pSpxConnFile, totalSize, LockHandleConn);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        continue;
                }
                else if (status == STATUS_MORE_PROCESSING_REQUIRED)
                {

                        //      Queue irp into connection, change state to receive
                        //      posted and fall thru.
                        pRequest        = SpxAllocateRequest(
                                                        SpxDevice,
                                                        pRecvIrp);

                        IF_NOT_ALLOCATED(pRequest)
                        {
                                pRecvIrp->IoStatus.Status =
                                                                STATUS_INSUFFICIENT_RESOURCES;
                                IoCompleteRequest (pRecvIrp, IO_NETWORK_INCREMENT);
                                return (FALSE);
                        }

                        SpxConnQueueRecv(
                                pSpxConnFile,
                                pRequest);

                        fRecvQueued = TRUE;
                }

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        return fRecvQueued;
}




VOID
SpxRecvProcessPkts(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        Handle buffered data, complete irp if necessary. Set state to idle
        if list becomes empty.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

        BOOLEAN: More data left to indicate => TRUE

--*/
{
        ULONG                                           remainingDataLen, copyLen, bytesCopied;
        PREQUEST                                        pRequest;
        NTSTATUS                                        status;
        BOOLEAN                                         fEom;
        PNDIS_PACKET                            pNdisPkt;
        PNDIS_BUFFER                            pNdisBuffer;
        PSPX_RECV_RESD                          pRecvResd;
        ULONG                                           dataLen;
        PBYTE                                           pData;
        LIST_ENTRY                                      *p;
        BOOLEAN                                         fLockHeld = TRUE, fMoreData = TRUE, fWdwOpen = FALSE;
        USHORT                                          discState       = 0;
        int                                                     numDerefs       = 0;

        if (SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS)
        {
        SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_PROCESS_PKTS);

ProcessReceives:

                while ((pSpxConnFile->scf_CurRecvReq != NULL) &&
                                ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL))
                {
                        //      A buffering recv packet will have one ndis buffer descriptor
                        //      queued in, which will describe a segment of memory we have
                        //      allocated. An offset will also be present indicating the data
                        //      to start reading from (or to indicate from to AFD).
                        CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);

                        pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                                pRecvResd, NDIS_PACKET, ProtocolReserved);

                        NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);


                        //      Initialize pData
                        pData = NULL;
                        dataLen = 0;

                        if (pNdisBuffer != NULL)
                        {
                                NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                                CTEAssert(pData != NULL);
                                CTEAssert((LONG)dataLen >= 0);
                        }

                        //      Allow for zero data, eom only packets.
                        remainingDataLen = dataLen - pRecvResd->rr_DataOffset;

                        //      If this packet contained data then eom must also have been
                        //      indicated at the time all the data was consumed.
                        CTEAssert((remainingDataLen > 0) ||
                                                ((pRecvResd->rr_DataOffset == 0) &&
                                                 ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)));

                        status  = STATUS_SUCCESS;
                        copyLen = 0;
                        if (remainingDataLen > 0)
                        {
                                copyLen = MIN(remainingDataLen, pSpxConnFile->scf_CurRecvSize);
                                status = TdiCopyBufferToMdl(
                                                        pData,
                                                        pRecvResd->rr_DataOffset,
                                                        copyLen,
                                                        REQUEST_TDI_BUFFER(pSpxConnFile->scf_CurRecvReq),
                                                        pSpxConnFile->scf_CurRecvOffset,
                                                        &bytesCopied);

                                CTEAssert(NT_SUCCESS(status));
                                if (!NT_SUCCESS(status))
                                {
                                        //      Abort request with this status. Reset request
                                        //      queue to next request if one is available.
                                        copyLen = pSpxConnFile->scf_CurRecvSize;
                                }
                        }

                        DBGPRINT(RECEIVE, DBG,
                                        ("spxConnProcessRecdPkts: %lx Pkt %lx Data %lx Size %lx F %lx\n",
                                                pSpxConnFile, pNdisPkt, pData, copyLen, pRecvResd->rr_State));

                        //      Adjust various values to see whats done whats not
                        pRecvResd->rr_DataOffset                        += (USHORT)copyLen;
                        pSpxConnFile->scf_CurRecvSize           -= (USHORT)copyLen;
                        pSpxConnFile->scf_CurRecvOffset         += (USHORT)copyLen;

#if DBG
                        //      If this packet was part of indicated data count, decrement.
                        if ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)
                        {
                                if (copyLen != 0)
                                {
                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                        pSpxConnFile->scf_IndBytes      -= copyLen;
                                }
                        }
#endif

                        //      Set fEom/discState (init to 0)  only if all of packet was consumed.
                        fEom = FALSE;
                        if (pRecvResd->rr_DataOffset == dataLen)
                        {
                                fEom    = (BOOLEAN)((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0);

                                //      Remember if disconnect needed to happen. If set, this better be
                                //      last packet received. Again, only if entire pkt was consumed.
                                discState = (pRecvResd->rr_State & SPX_RECVPKT_DISCMASK);
                                CTEAssert((discState == 0) ||
                                                        (pRecvResd == pSpxConnFile->scf_RecvListTail));

                                //      Packet consumed. Free it up.
                                numDerefs++;

                                SpxConnDequeueRecvPktLock(pSpxConnFile, pNdisPkt);
                                INCREMENT_WINDOW(pSpxConnFile);

                fWdwOpen = TRUE;

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Pkt %lx Data %lx DEQUEUED\n",
                                                        pSpxConnFile, pNdisPkt, pData));

                                if (pNdisBuffer != NULL)
                                {
                                        NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                        NdisFreeBuffer(pNdisBuffer);
                                        SpxFreeMemory(pData);
                                }

                                SpxPktRecvRelease(pNdisPkt);
                        }
                        else
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Pkt %lx PARTIAL USE %lx.%lx\n",
                                                        pSpxConnFile, pNdisPkt, pRecvResd->rr_DataOffset, dataLen));
                        }

                        //      Don't complete until we are out of all packets and stream mode or...
                        if (((pSpxConnFile->scf_RecvListHead == NULL) &&
                                        SPX_CONN_STREAM(pSpxConnFile))                          ||
                                (pSpxConnFile->scf_CurRecvSize == 0)                    ||
                                fEom)
                        {
                                //      Done with receive, move to completion or complete depending on
                                //      call level.
                                pRequest = pSpxConnFile->scf_CurRecvReq;

                                //      Set status. Complete with error from TdiCopy if so.
                                REQUEST_INFORMATION(pRequest)   = pSpxConnFile->scf_CurRecvOffset;
                                REQUEST_STATUS(pRequest)                = status;

                                //      Ensure we dont overwrite an error status.
                                if (!SPX_CONN_STREAM(pSpxConnFile)               &&
                                        (pSpxConnFile->scf_CurRecvSize == 0) &&
                                        !fEom &&
                                        NT_SUCCESS(status))
                                {
                                        REQUEST_STATUS(pRequest) = STATUS_RECEIVE_PARTIAL;
                                }

                                //      Dequeue this request, set next recv if one exists.
                                SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Recv %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

#if DBG
                                if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                        (REQUEST_INFORMATION(pRequest) == 0))
                                {
                                        DBGPRINT(TDI, DBG,
                                                        ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));
                                }
#endif

                                //      Request is done. Move to receive completion list. There
                                //      could already be previously queued requests in here.
                                InsertTailList(
                                        &pSpxConnFile->scf_RecvDoneLinkage,
                                        REQUEST_LINKAGE(pRequest));
                        }

                        CTEAssert((discState == 0) ||
                                                (pSpxConnFile->scf_RecvListHead == NULL));
                }

                //      Complete any completed receives
                while ((p = pSpxConnFile->scf_RecvDoneLinkage.Flink) !=
                                                                                        &pSpxConnFile->scf_RecvDoneLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                        DBGPRINT(TDI, DBG,
                                        ("SpxConnDiscPkt: PENDING REQ COMP %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

#if DBG
                        if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                (REQUEST_INFORMATION(pRequest) == 0))
                        {
                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif

                        SpxCompleteRequest(pRequest);
                        numDerefs++;
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                fMoreData = ((pSpxConnFile->scf_RecvListHead != NULL)                           &&
                                         ((pSpxConnFile->scf_RecvListHead ->rr_State    &
                                                                                SPX_RECVPKT_BUFFERING) != 0)            &&
                                         ((pSpxConnFile->scf_RecvListHead->rr_State     &
                                                                                SPX_RECVPKT_INDICATED) == 0));

                while (fMoreData)
                {
                        //      Bug #21036
                        //      If there is a receive waiting to be processed, we better not
                        //      indicate data before we finish it.
                        if (pSpxConnFile->scf_CurRecvReq != NULL)
                                goto ProcessReceives;

                        //      If a receive was queued the goto beginning again.
                        if (SpxRecvIndicatePendingData(pSpxConnFile, LockHandleConn))
                        {
                                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                                goto ProcessReceives;
                        }

                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        fMoreData = ((pSpxConnFile->scf_RecvListHead != NULL)                           &&
                                                 ((pSpxConnFile->scf_RecvListHead ->rr_State    &
                                                                                        SPX_RECVPKT_BUFFERING) != 0)            &&
                                                 ((pSpxConnFile->scf_RecvListHead->rr_State     &
                                                                                        SPX_RECVPKT_INDICATED) == 0));
                }

                //      Set state
                SPX_RECV_SETSTATE(
                        pSpxConnFile,
                        (pSpxConnFile->scf_CurRecvReq == NULL) ?
                                SPX_RECV_IDLE : SPX_RECV_POSTED);
        }
#if DBG
        else
        {
                DBGPRINT(RECEIVE, ERR,
                                ("spxConnProcessRecdPkts: Already processing pkts %lx\n",
                                        pSpxConnFile));
        }
#endif

        if (fWdwOpen && (pSpxConnFile->scf_RecvListHead == NULL))
        {
                //      Send an ack as our windows probably opened up. Dont wait to
                //      piggyback here...
                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Send ACK %lx\n",
                                        pSpxConnFile));

#if DBG_WDW_CLOSE
                //      If packets been indicated we have started buffering. Also
                //      check if window is now zero.
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        li = pSpxConnFile->scf_WdwCloseTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                //      Set new average close time
                                pSpxConnFile->scf_WdwCloseAve += value;
                                pSpxConnFile->scf_WdwCloseAve /= 2;
                                DBGPRINT(RECEIVE, DBG,
                                                ("V %ld AVE %ld\n",
                                                        value, pSpxConnFile->scf_WdwCloseAve));
                        }
                }
#endif

                SpxConnSendAck(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
        }

        //      Check if disconnect happened
        switch (discState)
        {
        case SPX_RECVPKT_IDISC:

                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Buffered IDISC %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case SPX_RECVPKT_ORD_DISC:

                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Buffered ORDREL %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessOrdRel(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case (SPX_RECVPKT_IDISC | SPX_RECVPKT_ORD_DISC):

                //      IDISC has more priority.
                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, ERR,
                                ("spxConnProcessRecdPkts: Buffered IDISC *AND* ORDREL %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        default:

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxpkt.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxpkt.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

//	Use our own NDIS packets
//#define	SPX_OWN_PACKETS		1



//
// List of NDIS_PACKETS stored...
//
extern SLIST_HEADER    SendPacketList;  
extern SLIST_HEADER    RecvPacketList;  
EXTERNAL_LOCK(RecvHeaderLock);
EXTERNAL_LOCK(SendHeaderLock);

//  Offsets into the IPX header
#define IPX_HDRSIZE         30  // Size of the IPX header
#define IPX_CHECKSUM        0   // Checksum
#define IPX_LENGTH          2   // Length
#define IPX_XPORTCTL        4   // Transport Control
#define IPX_PKTTYPE         5   // Packet Type
#define IPX_DESTADDR        6   // Dest. Address (Total)
#define IPX_DESTNET         6   // Dest. Network Address
#define IPX_DESTNODE        10  // Dest. Node Address
#define IPX_DESTSOCK        16  // Dest. Socket Number
#define IPX_SRCADDR         18  // Source Address (Total)
#define IPX_SRCNET          18  // Source Network Address
#define IPX_SRCNODE         22  // Source Node Address
#define IPX_SRCSOCK         28  // Source Socket Number

#define IPX_NET_LEN         4
#define IPX_NODE_LEN        6


#include <packon.h>

// Definition of the IPX/SPX header.
typedef struct _IPXSPX_HEADER
{
    USHORT 	hdr_CheckSum;
    USHORT 	hdr_PktLen;
    UCHAR 	hdr_XportCtrl;
    UCHAR 	hdr_PktType;
    UCHAR 	hdr_DestNet[4];
    UCHAR 	hdr_DestNode[6];
    USHORT 	hdr_DestSkt;
    UCHAR 	hdr_SrcNet[4];
    UCHAR 	hdr_SrcNode[6];
    USHORT 	hdr_SrcSkt;

	//	SPX Header Elements
	UCHAR	hdr_ConnCtrl;
	UCHAR	hdr_DataType;
	USHORT	hdr_SrcConnId;
	USHORT	hdr_DestConnId;
	USHORT	hdr_SeqNum;
	USHORT	hdr_AckNum;
	USHORT	hdr_AllocNum;

	//	For non-CR SPXII packets only
	USHORT	hdr_NegSize;

} IPXSPX_HDR, *PIPXSPX_HDR;

#include <packoff.h>

//	NDIS Packet size - two more ulongs added... 11/26/96
#define		NDIS_PACKET_SIZE	48+8
	
//	Minimum header size (doesnt include neg size)
#define		MIN_IPXSPX_HDRSIZE	(sizeof(IPXSPX_HDR) - sizeof(USHORT))
#define		MIN_IPXSPX2_HDRSIZE	sizeof(IPXSPX_HDR)
#define		SPX_CR_PKTLEN		42

//	SPX packet type
#define		SPX_PKT_TYPE		0x5

//	Connection control fields
#define		SPX_CC_XHD		0x01
#define		SPX_CC_RES1		0x02
#define		SPX_CC_NEG		0x04
#define		SPX_CC_SPX2		0x08
#define		SPX_CC_EOM		0x10
#define		SPX_CC_ATN		0x20
#define		SPX_CC_ACK		0x40
#define		SPX_CC_SYS		0x80

#define		SPX_CC_CR		(SPX_CC_ACK | SPX_CC_SYS)

//	Data stream types
#define		SPX2_DT_ORDREL		0xFD
#define		SPX2_DT_IDISC		0xFE
#define		SPX2_DT_IDISC_ACK	0xFF

//	Negotiation size
#define	SPX_MAX_PACKET			576
#define	SPX_NEG_MIN				SPX_MAX_PACKET
#define	SPX_NEG_MAX				65535

//	No packet references connection. But if the sends are being aborted, and
//	the packet happens to be owned by ipx at the time, the pkt is dequeued from
//	conn, the ABORT flag is set and conn is referenced for packet.
//
//	Send packet states
//	ABORT	: Used for aborted packet. Calls AbortSendPkt().
//	IPXOWNS	: Currently owned by ipx
//	FREEDATA: Frees the data associated with second ndis buffer desc
//	ACKREQ	: Only for sequenced packets. Set by retry timer in packets it wants
//			  resent (1 for spx1, all pending for spx2) with ack bit set.
//	DESTROY	: Only for non-sequenced packets, dequeue packet from list and free.
//	REQ		: For both seq/non-seq. A request is associated with the packet
//	SEQ		: Packet is a sequenced packet.
//	LASTPKT	: Packet is last packet comprising the request, if acked req is done.
//	EOM		: Send EOM with the last packet for this request
//	ACKEDPKT: Send completion must only deref req with pkt and complete if zero.
//

#define	SPX_SENDPKT_IDLE        0
#define	SPX_SENDPKT_ABORT		0x0002
#define SPX_SENDPKT_IPXOWNS		0x0004
#define	SPX_SENDPKT_FREEDATA    0x0008
#define	SPX_SENDPKT_ACKREQ		0x0010
#define	SPX_SENDPKT_DESTROY		0x0020
#define	SPX_SENDPKT_REQ			0x0040
#define	SPX_SENDPKT_SEQ			0x0080
#define	SPX_SENDPKT_LASTPKT		0x0100
#define	SPX_SENDPKT_ACKEDPKT	0x0200
#define	SPX_SENDPKT_EOM			0x0400
#define	SPX_SENDPKT_REXMIT		0x0800

//	Packet types
#define	SPX_TYPE_CR		 		0x01
#define	SPX_TYPE_CRACK			0x02
#define	SPX_TYPE_SN				0x03
#define	SPX_TYPE_SNACK			0x04
#define	SPX_TYPE_SS				0x05
#define	SPX_TYPE_SSACK			0x06
#define	SPX_TYPE_RR				0x07
#define	SPX_TYPE_RRACK			0x08
#define	SPX_TYPE_IDISC			0x09
#define	SPX_TYPE_IDISCACK		0x0a
#define	SPX_TYPE_ORDREL			0x0b
#define	SPX_TYPE_ORDRELACK		0x0c
#define	SPX_TYPE_DATA			0x0d
#define	SPX_TYPE_DATAACK		0x0e
#define	SPX_TYPE_DATANACK		0x0f
#define	SPX_TYPE_PROBE			0x10

// Definition of the protocol reserved field of a send packet.
// Make Len/HdrLen USHORTS, move to the end before the
//		   sr_SentTime so we dont use padding space.
typedef struct _SPX_SEND_RESD
{
	UCHAR					sr_Id;						// Set to SPX
	UCHAR					sr_Type;					// What kind of packet
	USHORT					sr_State;					// State of send packet
	PVOID					sr_Reserved1;				// Needed by IPX
	PVOID					sr_Reserved2;				// Needed by IPX
#if     defined(_PNP_POWER)
    PVOID                   sr_Reserved[SEND_RESERVED_COMMON_SIZE-2]; // needed by IPX for local target
#endif  _PNP_POWER
	ULONG					sr_Len;						// Length of packet
	ULONG					sr_HdrLen;					// Included header length

	struct _SPX_SEND_RESD *	sr_Next;					// Points to next packet
														// in send queue in conn.
    PREQUEST 				sr_Request;              	// request associated
	ULONG					sr_Offset;					// Offset in mdl for sends

#ifndef SPX_OWN_PACKETS
    PVOID					sr_FreePtr;              	// Ptr to use in free chunk
#endif

    struct _SPX_CONN_FILE * sr_ConnFile; 				// that this send is on
	USHORT					sr_SeqNum;					// Seq num for seq pkts

														// Quad word aligned.
	LARGE_INTEGER			sr_SentTime;				// Time packet was sent
														// Only valid for data pkt
														// with ACKREQ set.
    SINGLE_LIST_ENTRY       Linkage;
} SPX_SEND_RESD, *PSPX_SEND_RESD;



//	Recv packet states
#define	SPX_RECVPKT_IDLE		0
#define	SPX_RECVPKT_BUFFERING	0x0001
#define	SPX_RECVPKT_IDISC		0x0002
#define	SPX_RECVPKT_ORD_DISC	0x0004
#define	SPX_RECVPKT_INDICATED	0x0008
#define	SPX_RECVPKT_SENDACK		0x0010
#define	SPX_RECVPKT_EOM			0x0020
#define	SPX_RECVPKT_IMMEDACK	0x0040

#define	SPX_RECVPKT_DISCMASK	(SPX_RECVPKT_ORD_DISC | SPX_RECVPKT_IDISC)

// Definition of the protocol reserved field of a receive packet.
typedef struct _SPX_RECV_RESD
{
	UCHAR					rr_Id;						// Set to SPX
	USHORT					rr_State;					// State of receive packet
	struct _SPX_RECV_RESD *	rr_Next;					// Points to next packet
	ULONG					rr_DataOffset;				// To indicate/copy from

#ifndef SPX_OWN_PACKETS
    PVOID					rr_FreePtr;              	// Ptr to use in free chunk
#endif

#if DBG
	USHORT					rr_SeqNum;					// Seq num of packet
#endif
    SINGLE_LIST_ENTRY       Linkage;
    PREQUEST 				rr_Request;            		// request waiting on xfer
    struct _SPX_CONN_FILE * rr_ConnFile; 				// that this recv is on

} SPX_RECV_RESD, *PSPX_RECV_RESD;


//	Destination built as an assign of 3 ulongs.
#define	SpxBuildIpxHdr(pIpxSpxHdr, PktLen, pRemAddr, SrcSkt)					\
		{																		\
			PBYTE	pDestIpxAddr = (PBYTE)pIpxSpxHdr->hdr_DestNet;				\
			(pIpxSpxHdr)->hdr_CheckSum	= 0xFFFF;								\
			PUTSHORT2SHORT((PUSHORT)(&(pIpxSpxHdr)->hdr_PktLen), (PktLen));		\
			(pIpxSpxHdr)->hdr_XportCtrl	= 0;									\
			(pIpxSpxHdr)->hdr_PktType		= SPX_PKT_TYPE;						\
			*((UNALIGNED ULONG *)pDestIpxAddr) =								\
				*((UNALIGNED ULONG *)pRemAddr);									\
			*((UNALIGNED ULONG *)(pDestIpxAddr+4)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+4));								\
			*((UNALIGNED ULONG *)(pDestIpxAddr+8)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+8));								\
			*((UNALIGNED ULONG *)((pIpxSpxHdr)->hdr_SrcNet))=					\
				*((UNALIGNED ULONG *)(SpxDevice->dev_Network));					\
			*((UNALIGNED ULONG *)((pIpxSpxHdr)->hdr_SrcNode)) = 				\
				*((UNALIGNED ULONG *)SpxDevice->dev_Node);						\
			*((UNALIGNED USHORT *)((pIpxSpxHdr)->hdr_SrcNode+4)) = 				\
				*((UNALIGNED USHORT *)(SpxDevice->dev_Node+4));					\
			*((UNALIGNED USHORT *)&((pIpxSpxHdr)->hdr_SrcSkt)) = 				\
				SrcSkt;															\
		}

#define	SpxCopyIpxAddr(pIpxSpxHdr, pDestIpxAddr)								\
		{																		\
			PBYTE	pRemAddr = (PBYTE)pIpxSpxHdr->hdr_SrcNet;					\
			*((UNALIGNED ULONG *)pDestIpxAddr) =								\
				*((UNALIGNED ULONG *)pRemAddr);									\
			*((UNALIGNED ULONG *)(pDestIpxAddr+4)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+4));								\
			*((UNALIGNED ULONG *)(pDestIpxAddr+8)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+8));								\
		}

#ifdef UNDEFINDED

#define SpxAllocRecvPacket(_Device,_RecvPacket,_Status)							\
	{ 							                                                \
        PSINGLE_LIST_ENTRY  Link;                                               \ 
                                                                                \       
        Link = ExInterlockedPopEntrySList(                                      \
                     &PacketList,                                               \ 
                     &HeaderLock                                                \       
                     );											                \
                                                                                 \
        if (Link != NULL) {                                                      \         
           Common = STRUCT_OF(struct PCCommon, Link, pc_link);                   \
           PC = STRUCT_OF(PacketContext, Common, pc_common);                     \      
           (*_RecvPacket) = STRUCT_OF(NDIS_PACKET, PC, ProtocolReserved);        \
           (*_Status) = NDIS_STATUS_SUCCESS;                                     \
        } else {                                                                 \
                                                                                 \
           (*_RecvPacket) = GrowSPXPacketsList();                              \ 
               (*_Status)     =  NDIS_STATUS_SUCCESS;                          \
           if (NULL == _RecvPacket) {                                       \
              DBGPRINT(NDIS, ("Couldn't grow packets allocated...\r\n"));   \
              (*_Status)     =  NDIS_STATUS_RESOURCES;                          \
           }                                                                \
        }                                                                   \
    }                                                                      

#define SpxFreeSendPacket(_Device,_Packet)										\
		{ 																		\
           DBGPRINT(NDIS                                                        \ 
            ("SpxFreeSendPacket\n"));                                           \
           SpxFreePacket(_Device, _Packet);                                     \
        }                                                                       \

#define SpxFreeRecvPacket(_Device,_Packet)										\
		{ 																		\
           DBGPRINT(NDIS                                                        \ 
            ("SpxFreeRecvPacket\n"));                                           \
           SpxFreePacket(_Device, _Packet);                                     \
        }                                                                       \

#define	SpxReInitSendPacket(_Packet)                                            \
		{                                                                       \
           DBGPRINT(NDIS                                                        \ 
            ("SpxReInitSendPacket\n"));                                         \
		}                                                                       \

#define	SpxReInitRecvPacket(_Packet)                                            \
		{                                                                       \
           DBGPRINT(NDIS,                                                       \ 
            ("SpxReInitRecvPacket\n"));                                         \ 
		}            
                                                                   \    
#endif

#if !defined SPX_OWN_PACKETS

#define SEND_RESD(_Packet) ((PSPX_SEND_RESD)((_Packet)->ProtocolReserved))
#define RECV_RESD(_Packet) ((PSPX_RECV_RESD)((_Packet)->ProtocolReserved))

#else

#define SpxAllocSendPacket(_Device, _SendPacket, _Status)						\
		{ 																		\
			if (*(_SendPacket) = SpxBPAllocBlock(BLKID_NDISSEND))				\
				*(_Status) = NDIS_STATUS_SUCCESS;	 							\
			else																\
				*(_Status) = NDIS_STATUS_RESOURCES;								\
		}																		

#define SpxAllocRecvPacket(_Device,_RecvPacket,_Status)							\
		{																		\
			if (*(_RecvPacket) = SpxBPAllocBlock(BLKID_NDISRECV))				\
				*(_Status) = NDIS_STATUS_SUCCESS;	 							\
			else																\
				*(_Status) = NDIS_STATUS_RESOURCES;								\
		}

#define SpxFreeSendPacket(_Device,_Packet)										\
		{ 																		\
			SpxBPFreeBlock(_Packet, BLKID_NDISSEND);							\
		}

#define SpxFreeRecvPacket(_Device,_Packet)										\
		{ 																		\
			SpxBPFreeBlock(_Packet, BLKID_NDISRECV);							\
		}

#define	SpxReInitSendPacket(_Packet)											\
		{																		\
		}

#define	SpxReInitRecvPacket(_Packet)											\
		{																		\
		}

#define SEND_RESD(_Packet) ((PSPX_SEND_RESD)((_Packet)->ProtocolReserved))
#define RECV_RESD(_Packet) ((PSPX_RECV_RESD)((_Packet)->ProtocolReserved))

#endif




#if !defined SPX_OWN_PACKETS
//
// If we DO NOT use SPX_OWN_PACKETS, we would rather make it a function call
//

PNDIS_PACKET
SpxAllocSendPacket(
                   IN  PDEVICE      _Device,
                   OUT PNDIS_PACKET *_SendPacket,
                   OUT PNDIS_STATUS _Status
                   );

PNDIS_PACKET
SpxAllocRecvPacket(
                   IN  PDEVICE      _Device,
                   OUT PNDIS_PACKET *_SendPacket,
                   OUT PNDIS_STATUS _Status
                   );   

void 
SpxFreeSendPacket(
                  PDEVICE        _Device,
                  PNDIS_PACKET   _Packet
                  );

void
SpxFreeRecvPacket(
                  PDEVICE        _Device,
                  PNDIS_PACKET   _Packet
                  );   

void 
SpxReInitSendPacket(
                    PNDIS_PACKET _Packet
                    );

void 
SpxReInitRecvPacket(
                    PNDIS_PACKET _Packet
                    );


#endif // SPX_OWN_PACKETS

//
//	Routine Prototypes
//

VOID
SpxPktBuildCr(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	IN		struct _SPX_ADDR		*	pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildCrAck(
	IN		struct _SPX_CONN_FILE 	*	pSpxConnFile,
	IN		struct _SPX_ADDR		*	pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fNeg,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildSn(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSs(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSsAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSnAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildRr(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				SeqNum,
	IN		USHORT				State);

VOID
SpxPktBuildRrAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				MaxPktSize);

VOID
SpxPktBuildProbe(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildData(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				Length);

VOID
SpxCopyBufferChain(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_BUFFER * TargetChain,
    IN NDIS_HANDLE PoolHandle,
    IN PNDIS_BUFFER SourceChain,
    IN UINT Offset,
    IN UINT Length
    );

VOID
SpxPktBuildAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fBuildNack,
	IN		USHORT				NumToResend);

VOID
SpxPktBuildDisc(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	IN		PREQUEST			pRequest,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		UCHAR				DataType);

VOID
SpxPktRecvRelease(
	IN	PNDIS_PACKET	pPkt);

VOID
SpxPktSendRelease(
	IN	PNDIS_PACKET	pPkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxreg.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxreg.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of the ISN SPX module.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXREG

// Local functions used to access the registry.
NTSTATUS
SpxInitReadIpxDeviceName(
    VOID);

NTSTATUS
SpxInitSetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext);

NTSTATUS
SpxInitGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxInitGetConfiguration)
#pragma alloc_text(INIT, SpxInitFreeConfiguration)
#pragma alloc_text(INIT, SpxInitGetConfigValue)
#pragma alloc_text(INIT, SpxInitReadIpxDeviceName)
#pragma alloc_text(INIT, SpxInitSetIpxDeviceName)
#endif


NTSTATUS
SpxInitGetConfiguration (
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    )

/*++

Routine Description:

    This routine is called by SPX to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in ipxcnfg.h file. A list of adapters to bind to is chained
    on to the config information.

Arguments:

    RegistryPath - The name of ST's node in the registry.

    ConfigPtr - Returns the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NTSTATUS    Status;
    UINT        i;
    PWSTR       RegistryPathBuffer;
    PCONFIG     Config;
    RTL_QUERY_REGISTRY_TABLE QueryTable[CONFIG_PARAMETERS+2];

	ULONG Zero = 0;
    ULONG Two = 2;
    ULONG Four = 4;
    ULONG Five = 5;
    ULONG Eight = 8;
    ULONG Twelve = 12;
    ULONG Fifteen = 15;
    ULONG Thirty = 30;
    ULONG FiveHundred = 500;
	ULONG Hex4000 = 0x4000;
	ULONG Hex7FFF = 0x7FFF;
	ULONG FourK   = 4096;

    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[CONFIG_PARAMETERS] = {
        { L"ConnectionCount",       &Five },
        { L"ConnectionTimeout",     &Two  },
        { L"InitPackets",           &Five },
        { L"MaxPackets",            &Thirty},
        { L"InitialRetransmissionTime", &FiveHundred},
        { L"KeepAliveCount",        &Eight},
        { L"KeepAliveTimeout",      &Twelve},
        { L"WindowSize",            &Four},
		{ L"SpxSocketRangeStart",	&Hex4000},
		{ L"SpxSocketRangeEnd",		&Hex7FFF},
		{ L"SpxSocketUniqueness",	&Eight},
		{ L"MaxPacketSize",         &FourK},
		{ L"RetransmissionCount",   &Eight},
		{ L"DisableSpx2",			&Zero},
		{ L"RouterMtu", 			&Zero},
		{ L"BackCompSpx", 			&Zero},
        { L"DisableRTT",            &Zero}
	};

    if (!NT_SUCCESS(SpxInitReadIpxDeviceName()))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate memory for the main config structure.
    Config = CTEAllocMem (sizeof(CONFIG));
    if (Config == NULL) {
		TMPLOGERR();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Config->cf_DeviceName.Buffer = NULL;

    // SpxReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    RegistryPathBuffer = (PWSTR)CTEAllocMem(RegistryPath->Length + sizeof(WCHAR));

    if (RegistryPathBuffer == NULL) {

        SpxInitFreeConfiguration(Config);

		TMPLOGERR();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (
		RegistryPathBuffer,
		RegistryPath->Buffer,
		RegistryPath->Length);

    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    Config->cf_RegistryPathBuffer = RegistryPathBuffer;

    // Read the per-transport (as opposed to per-binding)
    // parameters.
    //
    // Set up QueryTable to do the following:
    // 1) Switch to the Parameters key below SPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    // 2-14) Call SpxSetBindingValue for each of the keys we
    // care about.
    for (i = 0; i < CONFIG_PARAMETERS; i++) {

        QueryTable[i+1].QueryRoutine = SpxInitGetConfigValue;
        QueryTable[i+1].Flags = 0;
        QueryTable[i+1].Name = ParameterValues[i].KeyName;
        QueryTable[i+1].EntryContext = UlongToPtr(i);
        QueryTable[i+1].DefaultType = REG_DWORD;
        QueryTable[i+1].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+1].DefaultLength = sizeof(ULONG);
    }

    // 15) Stop
    QueryTable[CONFIG_PARAMETERS+1].QueryRoutine = NULL;
    QueryTable[CONFIG_PARAMETERS+1].Flags = 0;
    QueryTable[CONFIG_PARAMETERS+1].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->cf_RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {
        SpxInitFreeConfiguration(Config);

		TMPLOGERR();
        return Status;
    }

    CTEFreeMem (RegistryPathBuffer);
    *ConfigPtr = Config;

    return STATUS_SUCCESS;

}   // SpxInitGetConfiguration




VOID
SpxInitFreeConfiguration (
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by SPX to get free any storage that was allocated
    by SpxGetConfiguration in producing the specified CONFIG structure.

Arguments:

    Config - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    CTEFreeMem (Config);

}   // SpxInitFreeConfig




NTSTATUS
SpxInitGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the CONFIG structure.

    EntryContext - The index in Config->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {
        return STATUS_INVALID_PARAMETER;
    }

    DBGPRINT(CONFIG, INFO,
			("Config parameter %d, value %lx\n",
                (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));

    Config->cf_Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;
    return STATUS_SUCCESS;

}   // SpxInitGetConfigValue




NTSTATUS
SpxInitReadIpxDeviceName(
    VOID
    )

{
    NTSTATUS                    Status;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    PWSTR                       Export = L"Export";
    PWSTR                       IpxRegistryPath = IPX_REG_PATH;

    // Set up QueryTable to do the following:
    //
    // 1) Call SetIpxDeviceName for the string in "Export"
    QueryTable[0].QueryRoutine = SpxInitSetIpxDeviceName;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = Export;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;

    // 2) Stop
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                IpxRegistryPath,
                QueryTable,
                NULL,
                NULL);

    return Status;
}




NTSTATUS
SpxInitSetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string and
    saves the information in a ConfigurationInfo structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - NULL.

    EntryContext - NULL.

Return Value:

    status

--*/

{
    PWSTR       fileName;
    NTSTATUS    status  = STATUS_SUCCESS;

    fileName = (PWSTR)CTEAllocMem(ValueLength);
    if (fileName != NULL) {
        RtlCopyMemory(fileName, ValueData, ValueLength);
        RtlInitUnicodeString (&IpxDeviceName, fileName);
    }
    else
    {
        status  = STATUS_UNSUCCESSFUL;
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxrecv.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxrecv.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

BOOLEAN
SpxReceive(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  ULONG_PTR           FwdAdapterCtx,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize,
        IN  PMDL                pMdl);

VOID
SpxTransferDataComplete(
    IN  PNDIS_PACKET    pNdisPkt,
    IN  NDIS_STATUS     NdisStatus,
    IN  UINT            BytesTransferred);

VOID
SpxReceiveComplete(
    IN  USHORT  NicId);

VOID
SpxRecvDataPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize);

VOID
SpxRecvDiscPacket(
    IN  PUCHAR              LookaheadBuffer,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
    IN  UINT                LookaheadSize);

VOID
SpxRecvSysPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize);

VOID
SpxRecvFlushBytes(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				BytesToFlush,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxRecvProcessPkts(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
SpxRecvIndicatePendingData(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxsend.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxsend.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/


VOID
SpxSendComplete(
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS  NdisStatus);

VOID
SpxSendPktRelease(
	IN	PNDIS_PACKET	pPkt,
	IN	UINT			BufCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxsend.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxsend.c

Abstract:

    This module contains code that implements the send engine for the
    SPX transport provider.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//	Define module number for event logging entries
#define	FILENUM		SPXSEND

VOID
SpxSendComplete(
    IN PNDIS_PACKET pNdisPkt,
    IN NDIS_STATUS  NdisStatus
    )

/*++

Routine Description:

    This routine is called by the I/O system to indicate that a connection-
    oriented packet has been shipped and is no longer needed by the Physical
    Provider.

Arguments:

    ProtocolBindingContext - The ADAPTER structure for this binding.

    NdisPacket/RequestHandle - A pointer to the NDIS_PACKET that we sent.

    NdisStatus - the completion status of the send.

Return Value:

    none.

--*/

{
	PSPX_CONN_FILE	pSpxConnFile;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pNdisBuffer;
	CTELockHandle	lockHandle;
	UINT			bufCount;
	PREQUEST		pRequest	= NULL;
	BOOLEAN			completeReq = FALSE, freePkt = FALSE,
					orphaned 	= FALSE, lockHeld = FALSE;

	pSendResd		= (PSPX_SEND_RESD)(pNdisPkt->ProtocolReserved);

#if DBG
	if (NdisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(SEND, DBG,
				("SpxSendComplete: For %lx with status **%lx**\n",
					pNdisPkt, NdisStatus));
	}
#endif
	//	IPX changes the length set for the first ndis buffer descriptor.
	//	Change it back to its original value here.
	NdisQueryPacket(pNdisPkt, NULL, &bufCount, &pNdisBuffer, NULL);
	NdisAdjustBufferLength(pNdisBuffer, IpxMacHdrNeeded	+ MIN_IPXSPX2_HDRSIZE);


	do
	{
		pSpxConnFile 	= pSendResd->sr_ConnFile;
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
		lockHeld = TRUE;
#if defined(__PNP)
        //
        // if IPX gave us a new LocalTarget, use for our next send.
        //
        // But if we are sending connect requests by iterating over NicIds,
        // dont update the local target bcoz that will mess up our iteration
        // logic.
        //
        if ( DEVICE_NETWORK_PATH_NOT_FOUND == NdisStatus
                    &&
             !(
                SPX_CONN_CONNECTING(pSpxConnFile) &&
                (SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) &&
                (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0)
               ) ) {

            pSpxConnFile->scf_LocalTarget = pSendResd->LocalTarget;

            //
            // Renegotiate the max packet size if we have an active SPX2
            // session going on and we negotiated the max size originally.
            //
            if ( SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE &&
                 SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2) &&
                 SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG)    ) {

                //
                // this call will get the local max size on this new local target
                // from IPX.
                //
                SPX_MAX_PKT_SIZE(pSpxConnFile, TRUE, TRUE, *((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr );
                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RENEG);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessAck: %lx CONNECTION ENTERING RENEG\n",
                                        pSpxConnFile));
            }

        }
#endif  __PNP

		CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0);
	
		//	IPX dont own this packet nomore.
		pSendResd->sr_State		&= ~SPX_SENDPKT_IPXOWNS;
	
		//	If a send packet has been aborted, then we need to call
		//	abort send to go ahead and free up this packet, and deref associated
		//	request, if there is one, potentially completing it.
		if ((pSendResd->sr_State & SPX_SENDPKT_ABORT) != 0)
		{
			spxConnAbortSendPkt(
				pSpxConnFile,
				pSendResd,
				SPX_CALL_TDILEVEL,
				lockHandle);

			lockHeld = FALSE;
			break;
		}

		//	If there is an associated request, remove reference on it. BUT for a
		//	sequenced packet only if it has been acked and is waiting for the request
		//	to be dereferenced. It is already dequeued from queue, just free it up.
		if ((((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0) &&
			 ((pSendResd->sr_State & SPX_SENDPKT_SEQ) == 0)) ||
			((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) != 0))
		{
			freePkt = (BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) != 0);

			pRequest		= pSendResd->sr_Request;
			CTEAssert(pRequest != NULL);

			DBGPRINT(SEND, DBG,
					("IpxSendComplete: ReqRef before dec %lx.%lx\n",
						pRequest, REQUEST_INFORMATION(pRequest)));

			//	Deref the request and see if we complete it now. We always have our
			//	own reference on the request.
			//	!!! Status should already have been set in request...!!!
			if (--(REQUEST_INFORMATION(pRequest)) == 0)
			{
				CTEAssert(REQUEST_STATUS(pRequest) != STATUS_PENDING);

				completeReq	= TRUE;

				//	If this is acked already, request is not on list.
				//	BUG #11626
				if ((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) == 0)
				{
					RemoveEntryList(REQUEST_LINKAGE(pRequest));
				}
			}
		}
	
		//	Do we destroy this packet?
		if ((pSendResd->sr_State & SPX_SENDPKT_DESTROY) != 0)
		{
			//	Remove this packet from the send list in the connection.
			DBGPRINT(SEND, INFO,
					("IpxSendComplete: destroy packet...\n"));

			SpxConnDequeueSendPktLock(pSpxConnFile, pNdisPkt);
			freePkt = TRUE;	
		}

	} while (FALSE);

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	if (freePkt)
	{
		DBGPRINT(SEND, INFO,
				("IpxSendComplete: free packet...\n"));

		SpxPktSendRelease(pNdisPkt);
	}

	if (completeReq)
	{
		//	If this is a send request, set info to data sent, else it will be
		//	zero.
		if (REQUEST_MINOR_FUNCTION(pRequest) == TDI_SEND)
		{
			PTDI_REQUEST_KERNEL_SEND	pParam;

			pParam 	= (PTDI_REQUEST_KERNEL_SEND)
						REQUEST_PARAMETERS(pRequest);

			REQUEST_INFORMATION(pRequest) = pParam->SendLength;
			DBGPRINT(SEND, DBG,
					("IpxSendComplete: complete req %lx.%lx...\n",
						REQUEST_STATUS(pRequest),
						REQUEST_INFORMATION(pRequest)));
	
			CTEAssert(pRequest != NULL);
			CTEAssert(REQUEST_STATUS(pRequest) != STATUS_PENDING);
			SpxCompleteRequest(pRequest);
		}
		else
		{
			DBGPRINT(SEND, DBG,
					("SpxSendComplete: %lx DISC Request %lx with %lx.%lx\n",
						pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
						REQUEST_INFORMATION(pRequest)));

			DBGPRINT(SEND, DBG,
					("SpxSendComplete: %lx.%lx.%lx\n",
						pSpxConnFile->scf_RefCount,
						pSpxConnFile->scf_Flags,
						pSpxConnFile->scf_Flags2));

			//	Set the request in the connection, and deref for it.
			InsertTailList(
				&pSpxConnFile->scf_DiscLinkage,
				REQUEST_LINKAGE(pRequest));
		}

		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

    return;

}   //  SpxSendComplete




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxtimer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxtimer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	TIMER_DONT_REQUEUE		0
#define	TIMER_REQUEUE_CUR_VALUE	1

typedef	ULONG (*TIMER_ROUTINE)(IN PVOID Context, IN BOOLEAN TimerShuttingDown);

extern
NTSTATUS
SpxTimerInit(
	VOID);

extern
ULONG
SpxTimerScheduleEvent(
	IN	TIMER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	ULONG			DeltaTime,	// Schedule after this much time
	IN	PVOID			pContext);	// Context to pass to the routine

extern
VOID
SpxTimerFlushAndStop(
	VOID);

extern
BOOLEAN
SpxTimerCancelEvent(
	IN	ULONG	TimerId,
	IN	BOOLEAN	ReEnqueue);

#define	TMR_SIGNATURE		*(PULONG)"ATMR"
#if	DBG
#define	VALID_TMR(pTmr)		(((pTmr) != NULL) && \
							 ((pTmr)->tmr_Signature == TMR_SIGNATURE))
#else                   	
#define	VALID_TMR(pTmr)		((pTmr) != NULL)
#endif
typedef	struct _TimerList
{
#if	DBG
	ULONG					tmr_Signature;
#endif
	struct _TimerList *		tmr_Next;		// Link to next
	struct _TimerList **	tmr_Prev;		// Link to prev
	struct _TimerList *		tmr_Overflow;	// Link to overflow entry in hash table
	ULONG					tmr_AbsTime;	// Absolute time, for re-enqueue
	ULONG					tmr_RelDelta;	// Relative to the previous entry
	ULONG					tmr_Id;			// Unique Id for this event
	BOOLEAN					tmr_Cancelled;	// Was the timer cancelled?
	TIMER_ROUTINE			tmr_Worker;		// Real Worker
	PVOID					tmr_Context;	// Real context
} TIMERLIST, *PTIMERLIST;


#define	SpxGetCurrentTime()	(SpxTimerCurrentTime/SPX_TIMER_FACTOR)
#define	SpxGetCurrentTick()	SpxTimerCurrentTime

// Keep this at a ONE second level.
#define	SPX_TIMER_FACTOR	10				// i.e. 10 ticks per second
#define	SPX_MS_TO_TICKS		100				// Divide ms by this to get ticks
#define	SPX_TIMER_TICK		-1000000L		// 100ms in 100ns units
#define	SPX_TIMER_WAIT		50				// Time to wait in FlushAndStop in ms
#define	TIMER_HASH_TABLE	32

VOID
spxTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2);

VOID
spxTimerWorker(
	IN	PTIMERLIST	pList);

VOID
spxTimerEnqueue(
	PTIMERLIST	pListNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxreg.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxreg.h

Abstract:

    Private include file for the ISN SPX module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/

#define	HALFSEC_TO_MS_FACTOR				500
#define	IPX_REG_PATH						L"NwlnkIpx\\Linkage"

// These are used to index into the Parameters array in CONFIG.
#define CONFIG_CONNECTION_COUNT             0
#define CONFIG_CONNECTION_TIMEOUT           1
#define CONFIG_INIT_PACKETS                 2
#define CONFIG_MAX_PACKETS                  3
#define CONFIG_INITIAL_RETRANSMIT_TIMEOUT   4
#define CONFIG_KEEPALIVE_COUNT              5
#define CONFIG_KEEPALIVE_TIMEOUT            6
#define CONFIG_WINDOW_SIZE                  7
#define CONFIG_SOCKET_RANGE_START           8
#define CONFIG_SOCKET_RANGE_END	           	9
#define CONFIG_SOCKET_UNIQUENESS           	10
#define CONFIG_MAX_PACKET_SIZE           	11
#define CONFIG_REXMIT_COUNT		           	12

//	Hidden parameters
#define	CONFIG_DISABLE_SPX2					13
#define	CONFIG_ROUTER_MTU					14
#define	CONFIG_BACKCOMP_SPX					15
#define CONFIG_DISABLE_RTT                  16
 
#define CONFIG_PARAMETERS                   17

// Main configuration structure.
typedef struct _CONFIG {

    ULONG       cf_Parameters[CONFIG_PARAMETERS];   // index defined above
    NDIS_STRING cf_DeviceName;                      // device name exported
    PWSTR       cf_RegistryPathBuffer;              // path to config info

} CONFIG, * PCONFIG;


#define	PARAM(x)	(SpxDevice->dev_ConfigInfo->cf_Parameters[(x)])


NTSTATUS
SpxInitGetConfiguration (
    IN  PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr);

VOID
SpxInitFreeConfiguration (
    IN PCONFIG Config);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxtimer.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxtimer.c

Abstract:

	This file implements the timer routines used by the stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)


Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXTIMER

//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxTimerInit)
#endif

//	Globals for this module
PTIMERLIST			spxTimerList 					= NULL;
PTIMERLIST			spxTimerTable[TIMER_HASH_TABLE]	= {0};
PTIMERLIST			spxTimerActive					= NULL;
CTELock     		spxTimerLock      				= {0};
LARGE_INTEGER		spxTimerTick					= {0};
KTIMER				spxTimer						= {0};
KDPC				spxTimerDpc						= {0};
ULONG				spxTimerId 						= 1;
LONG				spxTimerCount 					= 0;
USHORT				spxTimerDispatchCount 			= 0;
BOOLEAN				spxTimerStopped 				= FALSE;


NTSTATUS
SpxTimerInit(
	VOID
	)
/*++

Routine Description:

 	Initialize the timer component for the appletalk stack.

Arguments:


Return Value:


--*/
{
#if      !defined(_PNP_POWER)
	BOOLEAN	TimerStarted;
#endif  !_PNP_POWER

	// Initialize the timer and its associated Dpc. timer will be kicked
    // off when we get the first card arrival notification from ipx
	KeInitializeTimer(&spxTimer);
	CTEInitLock(&spxTimerLock);
	KeInitializeDpc(&spxTimerDpc, spxTimerDpcRoutine, NULL);
	spxTimerTick = RtlConvertLongToLargeInteger(SPX_TIMER_TICK);
#if      !defined(_PNP_POWER)
	TimerStarted = KeSetTimer(&spxTimer,
							  spxTimerTick,
							  &spxTimerDpc);
	CTEAssert(!TimerStarted);
#endif  !_PNP_POWER
	return STATUS_SUCCESS;
}




ULONG
SpxTimerScheduleEvent(
	IN	TIMER_ROUTINE		Worker,		// Routine to invoke when time expires
	IN	ULONG				MsTime,		// Schedule after this much time
	IN	PVOID				pContext	// Context(s) to pass to the routine
	)
/*++

Routine Description:

 	Insert an event in the timer event list. If the list is empty, then
 	fire off a timer. The time is specified in ms. We convert to ticks.
	Each tick is currently 100ms. It may not be zero or negative. The internal
	timer fires at 100ms granularity.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList;
	CTELockHandle	lockHandle;
	ULONG			DeltaTime;
	ULONG			Id = 0;

	//	Convert to ticks.
	DeltaTime	= MsTime/SPX_MS_TO_TICKS;
	if (DeltaTime == 0)
	{
		DBGPRINT(SYSTEM, INFO,
				("SpxTimerScheduleEvent: Converting %ld to ticks %ld\n",
					MsTime, DeltaTime));

		DeltaTime = 1;
	}

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerScheduleEvent: Converting %ld to ticks %ld\n",
				MsTime, DeltaTime));

	// Negative or Zero DeltaTime is invalid.
	CTEAssert (DeltaTime > 0);
			
	DBGPRINT(SYSTEM, INFO,
			("SpxTimerScheduleEvent: Routine %lx, Time %d, Context %lx\n",
			Worker, DeltaTime, pContext));

	CTEGetLock(&spxTimerLock, &lockHandle);

	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, FATAL,
				("SpxTimerScheduleEvent: Called after Flush !!\n"));
	}

	else do
	{
		pList = SpxBPAllocBlock(BLKID_TIMERLIST);

		if (pList == NULL)
		{
			break;
		}

#if	DBG
		pList->tmr_Signature = TMR_SIGNATURE;
#endif
		pList->tmr_Cancelled = FALSE;
		pList->tmr_Worker = Worker;
		pList->tmr_AbsTime = DeltaTime;
		pList->tmr_Context = pContext;
		
		Id = pList->tmr_Id = spxTimerId++;

		// Take care of wrap around
		if (spxTimerId == 0)
			spxTimerId = 1;

		// Enqueue this handler
		spxTimerEnqueue(pList);
	} while (FALSE);

	CTEFreeLock(&spxTimerLock, lockHandle);

	return Id;
}



VOID
spxTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
	)
/*++

Routine Description:

 	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 	the head of the list is decremented and if ZERO unlinked and dispatched.
 	If the list is non-empty, the timer is fired again.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList, *ppList;
	BOOLEAN			TimerStarted;
	ULONG			ReEnqueueTime;
	CTELockHandle	lockHandle;

	pKDpc; pContext; SystemArgument1; SystemArgument2;

#if     defined(_PNP_POWER)
	CTEGetLock(&spxTimerLock, &lockHandle);
	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, ERR,
				("spxTimerDpc: Enetered after Flush !!!\n"));

        CTEFreeLock(&spxTimerLock, lockHandle);
		return;
	}
#else
	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, ERR,
				("spxTimerDpc: Enetered after Flush !!!\n"));
		return;
	}

	CTEGetLock(&spxTimerLock, &lockHandle);
#endif  _PNP_POWER

	SpxTimerCurrentTime ++;	// Update our relative time

#ifdef	PROFILING
	//	This is the only place where this is changed. And it always increases.
	SpxStatistics.stat_ElapsedTime = SpxTimerCurrentTime;
#endif

	// We should never be here if we have no work to do
	if ((spxTimerList != NULL))
	{
		// Careful here. If two guys wanna go off together - let them !!
		if (spxTimerList->tmr_RelDelta != 0)
			(spxTimerList->tmr_RelDelta)--;
	
		// Dispatch the entry if it is ready to go
		if (spxTimerList->tmr_RelDelta == 0)
		{
			pList = spxTimerList;
			CTEAssert(VALID_TMR(pList));

			// Unlink from the list
			spxTimerList = pList->tmr_Next;
			if (spxTimerList != NULL)
				spxTimerList->tmr_Prev = &spxTimerList;

			// Unlink from the hash table now
			for (ppList = &spxTimerTable[pList->tmr_Id % TIMER_HASH_TABLE];
				 *ppList != NULL;
				 ppList = &((*ppList)->tmr_Overflow))
			{
				CTEAssert(VALID_TMR(*ppList));
				if (*ppList == pList)
				{
					*ppList = pList->tmr_Overflow;
					break;
				}
			}

			CTEAssert (*ppList == pList->tmr_Overflow);

			DBGPRINT(SYSTEM, INFO,
					("spxTimerDpcRoutine: Dispatching %lx\n",
					pList->tmr_Worker));

			spxTimerDispatchCount ++;
			spxTimerCount --;
			spxTimerActive = pList;
			CTEFreeLock(&spxTimerLock, lockHandle);

			//	If reenqueue time is 0, do not requeue. If 1, then requeue with
			//	current value, else use value specified.
			ReEnqueueTime = (*pList->tmr_Worker)(pList->tmr_Context, FALSE);
			DBGPRINT(SYSTEM, INFO,
					("spxTimerDpcRoutine: Reenequeu time %lx.%lx\n",
						ReEnqueueTime, pList->tmr_AbsTime));

			CTEGetLock(&spxTimerLock, &lockHandle);

			spxTimerActive = NULL;
			spxTimerDispatchCount --;

			if (ReEnqueueTime != TIMER_DONT_REQUEUE)
			{
				// If this chappie was cancelled while it was running
				// and it wants to be re-queued, do it right away.
				if (pList->tmr_Cancelled)
				{
					(*pList->tmr_Worker)(pList->tmr_Context, FALSE);
					SpxBPFreeBlock(pList, BLKID_TIMERLIST);
				}
				else
				{
					if (ReEnqueueTime != TIMER_REQUEUE_CUR_VALUE)
					{
						pList->tmr_AbsTime = ReEnqueueTime/SPX_MS_TO_TICKS;
						if (pList->tmr_AbsTime == 0)
						{
							DBGPRINT(SYSTEM, INFO,
									("SpxTimerDispatch: Requeue at %ld\n",
										pList->tmr_AbsTime));
						}
						DBGPRINT(SYSTEM, INFO,
								("SpxTimerDispatch: Requeue at %ld.%ld\n",
									ReEnqueueTime, pList->tmr_AbsTime));
					}

					spxTimerEnqueue(pList);
				}
			}
			else
			{
				SpxBPFreeBlock(pList, BLKID_TIMERLIST);
			}
		}
	}

#if     defined(_PNP_POWER)
	if (!spxTimerStopped)
	{
		TimerStarted = KeSetTimer(&spxTimer,
								  spxTimerTick,
								  &spxTimerDpc);

        // it is possible that while we were here in Dpc, PNP_ADD_DEVICE
        // restarted the timer, so this assert is commented out for PnP
//		CTEAssert(!TimerStarted);
	}

	CTEFreeLock(&spxTimerLock, lockHandle);
#else
	CTEFreeLock(&spxTimerLock, lockHandle);

	if (!spxTimerStopped)
	{
		TimerStarted = KeSetTimer(&spxTimer,
								  spxTimerTick,
								  &spxTimerDpc);
		CTEAssert(!TimerStarted);
	}
#endif  _PNP_POWER
}


VOID
spxTimerEnqueue(
	IN	PTIMERLIST	pListNew
	)
/*++

Routine Description:

 	Here is a thesis on the code that follows.

 	The timer events are maintained as a list which the timer dpc routine
 	looks at every timer tick. The list is maintained in such a way that only
 	the head of the list needs to be updated every tick i.e. the entire list
 	is never scanned. The way this is achieved is by keeping delta times
 	relative to the previous entry.

 	Every timer tick, the relative time at the head of the list is decremented.
 	When that goes to ZERO, the head of the list is unlinked and dispatched.

 	To give an example, we have the following events queued at time slots
 	X			Schedule A after 10 ticks.
 	X+3			Schedule B after 5  ticks.
 	X+5			Schedule C after 4  ticks.
 	X+8			Schedule D after 6  ticks.

 	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 	D at X+14 (X+8+6).

 	The above example covers all the situations.

 	- NULL List.
 	- Inserting at head of list.
 	- Inserting in the middle of the list.
 	- Appending to the list tail.

 	The list will look as follows.

 		    BEFORE                          AFTER
 		    ------                          -----

     X   Head -->|                  Head -> A(10) ->|
     A(10)

     X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
     B(5)

     X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
     C(4)

     X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
     D(6)

 	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.

Arguments:


Return Value:


--*/
{
	PTIMERLIST	pList, *ppList;
	ULONG		DeltaTime = pListNew->tmr_AbsTime;
	
	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &spxTimerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Next)
	{
		CTEAssert(VALID_TMR(pList));
		if (DeltaTime <= pList->tmr_RelDelta)
		{
			pList->tmr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->tmr_RelDelta;
	}
	

	// Link this in the chain
	pListNew->tmr_RelDelta = DeltaTime;
	pListNew->tmr_Next = pList;
	pListNew->tmr_Prev = ppList;
	*ppList = pListNew;
	if (pList != NULL)
	{
		pList->tmr_Prev = &pListNew->tmr_Next;
	}

	// Now link it in the hash table
	pListNew->tmr_Overflow = spxTimerTable[pListNew->tmr_Id % TIMER_HASH_TABLE];
	spxTimerTable[pListNew->tmr_Id % TIMER_HASH_TABLE] = pListNew;
	spxTimerCount ++;
}




VOID
SpxTimerFlushAndStop(
	VOID
	)
/*++

Routine Description:

 	Force all entries in the timer queue to be dispatched immediately. No
 	more queue'ing of timer routines is permitted after this. The timer
 	essentially shuts down.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList;
	CTELockHandle	lockHandle;

	CTEAssert (KeGetCurrentIrql() == LOW_LEVEL);

	DBGPRINT(SYSTEM, ERR,
			("SpxTimerFlushAndStop: Entered\n"));

	CTEGetLock(&spxTimerLock, &lockHandle);

	spxTimerStopped = TRUE;

	KeCancelTimer(&spxTimer);

	if (spxTimerList != NULL)
	{
		// Dispatch all entries right away
		while (spxTimerList != NULL)
		{
			pList = spxTimerList;
			CTEAssert(VALID_TMR(pList));
			spxTimerList = pList->tmr_Next;

			DBGPRINT(SYSTEM, INFO,
					("spxTimerFlushAndStop: Dispatching %lx\n",
					pList->tmr_Worker));

			// The timer routines assume they are being called at DISPATCH
			// level. This is OK since we are calling with SpinLock held.

			(*pList->tmr_Worker)(pList->tmr_Context, TRUE);

			spxTimerCount --;
			SpxBPFreeBlock(pList, BLKID_TIMERLIST);
		}
		RtlZeroMemory(spxTimerTable, sizeof(spxTimerTable));
	}

	CTEFreeLock(&spxTimerLock, lockHandle);

	// Wait for all timer routines to complete
	while (spxTimerDispatchCount != 0)
	{
		SpxSleep(SPX_TIMER_WAIT);
	}
}




BOOLEAN
SpxTimerCancelEvent(
	IN	ULONG	TimerId,
	IN	BOOLEAN	ReEnqueue
	)
/*++

Routine Description:

 	Cancel a previously scheduled timer event, if it hasn't fired already.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList, *ppList;
	CTELockHandle	lockHandle;

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerCancelEvent: Entered for TimerId %ld\n", TimerId));

	CTEAssert(TimerId != 0);

	CTEGetLock(&spxTimerLock, &lockHandle);

	for (ppList = &spxTimerTable[TimerId % TIMER_HASH_TABLE];
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Overflow)
	{
		CTEAssert(VALID_TMR(pList));
		// If we find it, cancel it
		if (pList->tmr_Id == TimerId)
		{
			// Unlink this from the hash table
			*ppList = pList->tmr_Overflow;

			// ... and from the list
			if (pList->tmr_Next != NULL)
			{
				pList->tmr_Next->tmr_RelDelta += pList->tmr_RelDelta;
				pList->tmr_Next->tmr_Prev = pList->tmr_Prev;
			}
			*(pList->tmr_Prev) = pList->tmr_Next;

			spxTimerCount --;
			if (ReEnqueue)
				 spxTimerEnqueue(pList);
			else SpxBPFreeBlock(pList, BLKID_TIMERLIST);
			break;
		}
	}

	// If we could not find it in the list, see if it currently running.
	// If so mark him to not reschedule itself, only if reenqueue was false.
	if (pList == NULL)
	{
		if ((spxTimerActive != NULL) &&
			(spxTimerActive->tmr_Id == TimerId) &&
			!ReEnqueue)
		{
	        spxTimerActive->tmr_Cancelled = TRUE;
		}
	}

	CTEFreeLock(&spxTimerLock, lockHandle);

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerCancelEvent: %s for Id %ld\n",
				(pList != NULL) ? "Success" : "Failure", TimerId));

	return (pList != NULL);
}




#if	DBG

VOID
SpxTimerDumpList(
	VOID
	)
{
	PTIMERLIST		pList;
	ULONG			CumTime = 0;
	CTELockHandle	lockHandle;

	DBGPRINT(DUMP, FATAL,
			("TIMER LIST: (Times are in %dms units\n", 1000));
	DBGPRINT(DUMP, FATAL,
			("\tTimerId  Time(Abs)  Time(Rel)  Routine Address\n"));

	CTEGetLock(&spxTimerLock, &lockHandle);

	for (pList = spxTimerList;
		 pList != NULL;
		 pList = pList->tmr_Next)
	{
		CumTime += pList->tmr_RelDelta;
		DBGPRINT(DUMP, FATAL,
				("\t% 6lx      %5d      %5ld         %lx\n",
				pList->tmr_Id, pList->tmr_AbsTime, CumTime, pList->tmr_Worker));
	}

	CTEFreeLock(&spxTimerLock, lockHandle);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxutils.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxutils.c

Abstract:

    This contains all utility routines for the ISN SPX module.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXUTILS

UINT
SpxUtilWstrLength(
	IN PWSTR Wstr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	UINT length = 0;

	while (*Wstr++)
	{
		length += sizeof(WCHAR);
	}

	return length;
}




LONG
SpxRandomNumber(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LARGE_INTEGER	Li;
	static LONG		seed = 0;

	// Return a positive pseudo-random number; simple linear congruential
	// algorithm. ANSI C "rand()" function.

	if (seed == 0)
	{
		KeQuerySystemTime(&Li);
		seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);

	return (seed & 0x7FFFFFFF);
}




NTSTATUS
SpxUtilGetSocketType(
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				SocketType
	)
/*++

Routine Description:

	For PROTO_SPX, i'd return a device name from the dll of the form
	\Device\IsnSpx\SpxStream (for SOCK_STREAM) or
	\Device\IsnSpx\Spx               (for SOCK_SEQPKT)
	
	and for PROTO_SPXII (the more common case we hope, even if
	internally we degrade to SPX1 cause of the remote client's
	limitations)
	\Device\IsnSpx\Stream        (for SOCK_STREAM) or
	\Device\IsnSpx               (for SOCK_SEQPKT)

Arguments:


Return Value:


--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	UNICODE_STRING		typeString;

	*SocketType		= SOCKET2_TYPE_SEQPKT;

	// Check for the socket type
	do
	{
		if (RemainingFileName->Length == 0)
		{
			break;
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET1STREAM_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET1STREAM_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET1_TYPE_STREAM;
				break;
			}
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET1_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET1_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET1_TYPE_SEQPKT;
				break;
			}
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET2STREAM_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET2STREAM_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET2_TYPE_STREAM;
				break;
			}
		}

		status = STATUS_NO_SUCH_DEVICE;
	
	} while (FALSE);

	return(status);
}




#define	ONE_MS_IN_100ns		-10000L		// 1ms in 100ns units

VOID
SpxSleep(
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KTIMER	SleepTimer;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	KeInitializeTimer(&SleepTimer);

	KeSetTimer(&SleepTimer,
				RtlConvertLongToLargeInteger(TimeInMs * ONE_MS_IN_100ns),
				NULL);

	KeWaitForSingleObject(&SleepTimer, UserRequest, KernelMode, FALSE, NULL);
	return;
}




TDI_ADDRESS_IPX UNALIGNED *
SpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress
	)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_IPX.

Arguments:

    Transport - The generic TDI address.

Return Value:

    A pointer to the IPX address, or NULL if none is found.

--*/

{
    TA_ADDRESS * addressName;
    INT i;

    addressName = &TransportAddress->Address[0];

    // The name can be passed with multiple entries; we'll take and use only
    // the IPX one.
    for (i=0;i<TransportAddress->TAAddressCount;i++)
	{
        if (addressName->AddressType == TDI_ADDRESS_TYPE_IPX)
		{
            if (addressName->AddressLength >= sizeof(TDI_ADDRESS_IPX))
			{
                return ((TDI_ADDRESS_IPX UNALIGNED *)(addressName->Address));
            }
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }
    return NULL;

}   // SpxParseTdiAddress



BOOLEAN
SpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
	)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount))
	{
        DBGPRINT(TDI, ERR,
				("SpxValidateTdiAddress: runt address\n"));

        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++)
	{
        if (addressName->Address > AddressEnd)
		{
            DBGPRINT(TDI, ERR,
					("SpxValidateTdiAddress: address too short\n"));

            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd)
	{
        DBGPRINT(TDI, ERR,
				("SpxValidateTdiAddress: address too short\n"));

        return FALSE;
    }
    return TRUE;

}   // SpxValidateTdiAddress




ULONG
SpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG AddressBufferLength,
    IN UCHAR Network[4],
    IN UCHAR Node[6],
    IN USHORT Socket
	)

/*++

Routine Description:

    This routine fills in a TRANSPORT_ADDRESS in the specified
    buffer, given the socket, network and node. It will write
    less than the full address if the buffer is too short.

Arguments:

    AddressBuffer - The buffer that will hold the address.

    AddressBufferLength - The length of the buffer.

    Network - The network number.

    Node - The node address.

    Socket - The socket.

Return Value:

    The number of bytes written into AddressBuffer.

--*/

{
    TA_IPX_ADDRESS UNALIGNED * SpxAddress;
    TA_IPX_ADDRESS TempAddress;

    if (AddressBufferLength >= sizeof(TA_IPX_ADDRESS))
	{
        SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;
    }
	else
	{
        SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)&TempAddress;
    }

    SpxAddress->TAAddressCount = 1;
    SpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    SpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    SpxAddress->Address[0].Address[0].NetworkAddress = *(UNALIGNED LONG *)Network;
    SpxAddress->Address[0].Address[0].Socket = Socket;
    RtlCopyMemory(SpxAddress->Address[0].Address[0].NodeAddress, Node, 6);

    if (AddressBufferLength >= sizeof(TA_IPX_ADDRESS))
	{
        return sizeof(TA_IPX_ADDRESS);
    }
	else
	{
        RtlCopyMemory(AddressBuffer, &TempAddress, AddressBufferLength);
        return AddressBufferLength;
    }

}   // SpxBuildTdiAddress



VOID
SpxBuildTdiAddressFromIpxAddr(
    IN PVOID 		AddressBuffer,
    IN PBYTE	 	pIpxAddr
	)
{
    TA_IPX_ADDRESS UNALIGNED * SpxAddress;

    SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;
    SpxAddress->TAAddressCount = 1;
    SpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    SpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    SpxAddress->Address[0].Address[0].NetworkAddress = *(UNALIGNED LONG *)pIpxAddr;
    RtlCopyMemory(
		SpxAddress->Address[0].Address[0].NodeAddress,
		pIpxAddr+4,
		6);

	GETSHORT2SHORT(
		&SpxAddress->Address[0].Address[0].Socket,
		pIpxAddr + 10);

	return;
}



VOID
SpxCalculateNewT1(
	IN	struct _SPX_CONN_FILE	* 	pSpxConnFile,
	IN	int							NewT1
	)
/*++

Routine Description:


Arguments:

	NewT1 - New value for the RTT in ms.

Return Value:


--*/
{
	int	baseT1, error;

	//
	//	VAN JACOBSEN Algorithm.  From Internetworking with Tcp/ip
	//	(Comer) book.
	//

	error 					 = NewT1 - (pSpxConnFile->scf_AveT1 >> 3);
	pSpxConnFile->scf_AveT1	+= error;
	if (pSpxConnFile->scf_AveT1 <= 0)     // Make sure not too small
	{
        pSpxConnFile->scf_AveT1 = SPX_T1_MIN;
	}

	if (error < 0)
		error = -error;

	error 					-= (pSpxConnFile->scf_DevT1 >> 2);
	pSpxConnFile->scf_DevT1	+= error;
	if (pSpxConnFile->scf_DevT1 <= 0)
        pSpxConnFile->scf_DevT1 = 1;

	baseT1 = (((pSpxConnFile->scf_AveT1 >> 2) + pSpxConnFile->scf_DevT1) >> 1);

	//	If less then min - set it
	if (baseT1 < SPX_T1_MIN)
		baseT1 = SPX_T1_MIN;

	//	Set the new value
	DBGPRINT(TDI, DBG,
			("SpxCalculateNewT1: Old value %lx New %lx\n",
				pSpxConnFile->scf_BaseT1, baseT1));

	pSpxConnFile->scf_BaseT1	= baseT1;

	//	At the time of restarting the timer,we convert this to a tick value.
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxutils.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxutils.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

//	For PROTO_SPX, i'd return a device name from the dll of the form
//	\Device\NwlnkSpx\SpxStream (for SOCK_STREAM) or
//	\Device\NwlnkSpx\Spx       (for SOCK_SEQPKT)
//	
//	and for PROTO_SPXII (the more common case we hope, even if
//	internally we degrade to SPX1 cause of the remote client's
//	limitations)
//	\Device\NwlnkSpx\Stream        (for SOCK_STREAM) or
//	\Device\NwlnkSpx               (for SOCK_SEQPKT)

#define	SOCKET1STREAM_SUFFIX		L"\\SpxStream"
#define	SOCKET1_SUFFIX				L"\\Spx"
#define	SOCKET2STREAM_SUFFIX		L"\\Stream"
#define	SOCKET1_TYPE_SEQPKT			0	
#define	SOCKET2_TYPE_SEQPKT			1
#define	SOCKET1_TYPE_STREAM			2
#define	SOCKET2_TYPE_STREAM			3

#define	IN_RANGE(_S, _RangeStart, _RangeEnd)		\
		((_S >= _RangeStart) && (_S <= _RangeEnd))


//
// The following macros deal with on-the-wire integer and long values
//
// On the wire format is big-endian i.e. a long value of 0x01020304 is
// represented as 01 02 03 04. Similarly an int value of 0x0102 is
// represented as 01 02.
//
// The host format is not assumed since it will vary from processor to
// processor.
//

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = (ULONG) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a dword from on-the-wire format to a dword in the host format
#define GETULONG2ULONG(DstPtr, SrcPtr)   \
		*(PULONG)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) + \
							  (*((PBYTE)(SrcPtr)+1) << 16) + \
							  (*((PBYTE)(SrcPtr)+2) << 8)  + \
							  (*((PBYTE)(SrcPtr)+3)	))

// Get a dword from on-the-wire format to a dword in the same format but
// also watch out for alignment
#define GETULONG2ULONG_NOCONV(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0); \
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1); \
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2); \
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3);

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTULONG2BYTE(DstPtr, Src)   \
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTULONG2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((ULONG)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTULONG2ULONG(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((ULONG)(Src) >> 24), \
		*((PBYTE)(DstPtr)+1) = (BYTE) ((ULONG)(Src) >> 16), \
		*((PBYTE)(DstPtr)+2) = (BYTE) ((ULONG)(Src) >>  8), \
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

// Put a BYTE[4] array into another BYTE4 array.
#define PUTBYTE42BYTE4(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0),	\
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1),	\
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2),	\
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3)

//	MIN/MAX macros
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))




//	Exported prototypes

UINT
SpxUtilWstrLength(
	IN PWSTR Wstr);

LONG
SpxRandomNumber(
	VOID);

NTSTATUS
SpxUtilGetSocketType(
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				SocketType);

VOID
SpxSleep(
	IN	ULONG	TimeInMs);

ULONG
SpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG AddressBufferLength,
    IN UCHAR Network[4],
    IN UCHAR Node[6],
    IN USHORT Socket);

VOID
SpxBuildTdiAddressFromIpxAddr(
    IN PVOID 		AddressBuffer,
    IN PBYTE	 	pIpxAddr);

TDI_ADDRESS_IPX UNALIGNED *
SpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress);

BOOLEAN
SpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength);

VOID
SpxCalculateNewT1(
	IN	struct _SPX_CONN_FILE	* 	pSpxConnFile,
	IN	int							NewT1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\winsock\wshelper.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshelper.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsipx.h>
#include <wsnwlink.h>

#include <isnkrnl.h>

#include <stdio.h>

#if defined(UNICODE)
#define NWLNKSPX_SERVICE_NAME L"nwlnkspx"
#else
#define NWLNKSPX_SERVICE_NAME "nwlnkspx"
#endif


typedef struct _IPX_OLD_ADDRESS_DATA {
    UINT adapternum;
    UCHAR netnum[4];
    UCHAR nodenum[6];
} IPX_OLD_ADDRESS_DATA, *PIPX_OLD_ADDRESS_DATA;


/** Device names for IPX sockets **/

#define ISNDGRAM_DEVNAME        L"\\Device\\NwlnkIpx"

/** Device names for SPX/SPXII sockets **/

#define ISNSTREAM_DEVNAME       L"\\Device\\NwlnkSpx\\SpxStream"
#define ISNSEQPKT_DEVNAME       L"\\Device\\NwlnkSpx\\Spx"

#define ISNSTREAMII_DEVNAME     L"\\Device\\NwlnkSpx\\Stream"
#define ISNSEQPKTII_DEVNAME     L"\\Device\\NwlnkSpx"

/** Friendly names for IPX and SPX. **/

#define SPX_NAME                L"SPX"
#define SPX2_NAME               L"SPX II"
#define IPX_NAME                L"IPX"

/** Start for IPX protocol families **/

#define MCSBASE_DGRAM           NSPROTO_IPX

#define BUFFER_SIZE 40

/** **/

UCHAR wsh_bcast[6] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

//  SPX Loaded flag, set for each process
BOOLEAN SpxLoaded = FALSE;

//
// IPX/SPX provider GUIDs.
//

GUID IpxProviderGuid =
         { /* 11058240-be47-11cf-95c8-00805f48a192 */
             0x11058240,
             0xbe47,
             0x11cf,
             { 0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
         };

GUID SpxProviderGuid =
         { /* 11058241-be47-11cf-95c8-00805f48a192 */
             0x11058241,
             0xbe47,
             0x11cf,
             { 0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
         };

/** Forward Decls/External Prototypes **/
DWORD
WshLoadSpx(
    VOID);

extern
INT
do_tdi_action(
    HANDLE,
    ULONG,
    PUCHAR,
    INT,
    BOOLEAN,
    PHANDLE OPTIONAL);

/*page****************************************************************
       These are the triples we support.
*********************************************************************/
typedef struct _MAPPING_TRIPLE {
    INT triple_addrfam;
    INT triple_socktype;
    INT triple_protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;
#define MAPPING_NUM_COLUMNS     3

extern MAPPING_TRIPLE stream_triples[];
extern int stream_num_triples;
extern int stream_table_size;

extern MAPPING_TRIPLE dgram_triples[];
extern int dgram_num_triples;
extern int dgram_table_size;

/** Forward declarations on internal routines **/

BOOLEAN is_triple_in_list(PMAPPING_TRIPLE, ULONG, INT, INT, INT);

/**
    There is one of these structures allocated for every
    socket that is created for us.
**/

typedef struct _WSHIPX_SOCKET_CONTEXT {
    INT con_addrfam;
    INT con_socktype;
    INT con_pcol;
    INT con_flags;
    UCHAR con_sendptype;        /* Current send packet type     */
    UCHAR con_recvptype;        /* Recv ptype we are filtering on */
    UCHAR con_dstype;           /* Datastream type              */
} WSHIPX_SOCKET_CONTEXT, *PWSHIPX_SOCKET_CONTEXT;

/** Values for con_flags **/

#define WSHCON_FILTER       0x0001  /* We are filtering on recv pkt type */
#define WSHCON_EXTADDR      0x0002  /* Extended addressing is on         */
#define WSHCON_SENDHDR      0x0004  /* Send header flag                  */
#define WSHCON_RCVBCAST     0x0008  /* It does receive broadcasts        */
#define WSHCON_IMM_SPXACK   0x0020  /* Immediate spx acks no piggyback   */

/*page***************************************************************
       W S H O p e n S o c k e t

       This is called for the socket call.  We make sure that
       we support the address family/socket type/protocol triple
       given and then we will allocate some memory to keep track
       of the socket.

       Arguments - addrfam  = Entry: Address family from socket call
                       Exit:  Filled in address family
            socktype = Entry: Socket type from socket call
                       Exit:  Filled in socket type
            pcol     = Entry: Protocol from socket call
                       Exit:  Filled in protocol
            devname  = Ptr to where to store device name
            pcontext = Where to store context value
            events   = Bitmask for events we want to know about

       Returns - NO_ERROR = OK
          Else = WinSock Error Code
*********************************************************************/
INT WSHOpenSocket(PINT addrfam, PINT socktype, PINT pcol,
          PUNICODE_STRING devname, PVOID *pcontext, PDWORD events)
{
    PWSHIPX_SOCKET_CONTEXT context;

    /** Determine whether this is DGRAM or STREAM or SEQPACKET **/

    if (is_triple_in_list(stream_triples, stream_num_triples,
                  *addrfam, *socktype, *pcol)) {

       if (*socktype == SOCK_SEQPACKET) {
           if (*pcol == NSPROTO_SPX)
               RtlInitUnicodeString(devname, ISNSEQPKT_DEVNAME);
           else
               RtlInitUnicodeString(devname, ISNSEQPKTII_DEVNAME);
       }
       else {
           if (*pcol == NSPROTO_SPX)
               RtlInitUnicodeString(devname, ISNSTREAM_DEVNAME);
           else
               RtlInitUnicodeString(devname, ISNSTREAMII_DEVNAME);
       }

       if (!SpxLoaded) {

           WshLoadSpx();

       }
    }

    /** Check for DGRAM **/

    else if (is_triple_in_list(dgram_triples, dgram_num_triples,
                       *addrfam, *socktype, *pcol)) {

       RtlInitUnicodeString(devname, ISNDGRAM_DEVNAME);
    }

    /**
       All others are errors.   This should never happen unless
       the registry information is wrong.
    **/

    else
       return WSAEINVAL;

    /** Allocate context for the socket **/

    context = RtlAllocateHeap(RtlProcessHeap(), 0L, sizeof(*context));
    if (context == NULL)
       return WSAENOBUFS;

    /** Init the context **/

    context->con_addrfam   = *addrfam;
    context->con_socktype  = *socktype;
    context->con_pcol      = *pcol;
    context->con_flags     = WSHCON_RCVBCAST;
    context->con_sendptype = (UCHAR)(*pcol - MCSBASE_DGRAM);
    context->con_recvptype = 0;
    context->con_dstype    = 0;

    /**
       Tell the Windows Sockets DLL which state transitions we
       are interested in.
    **/

    *events = WSH_NOTIFY_CLOSE | WSH_NOTIFY_BIND | WSH_NOTIFY_CONNECT;

    /** Give WinSock DLL our context pointer **/

    *pcontext = context;

    /** Everything OK - return OK **/

    return NO_ERROR;
}

/*page**************************************************************
       W S H G e t S o c k A d d r T y p e

       This routine parses a sockaddr to determine the type
       of machine address and endpoint address portions of the
       sockaddr.  This is called by the WinSock DLL whenever it
       needs to interpret a sockaddr.

       Arguments - sockaddr      = Ptr to sockaddr struct to evaluate
            sockaddrlen  = Length of data in the sockaddr
            sockaddrinfo = Ptr to structure to recv info
                           about the sockaddr

       Returns - NO_ERROR = Evaluation OK
          Else = WinSock error code
********************************************************************/
INT WSHGetSockaddrType(PSOCKADDR sockaddr, DWORD sockaddrlen,
               PSOCKADDR_INFO sockaddrinfo)
{
    PSOCKADDR_IPX sa = (PSOCKADDR_IPX)sockaddr;


    /** Make sure the address family is correct **/

    if (sa->sa_family != AF_NS)
       return WSAEAFNOSUPPORT;

    /** Make sure the length is OK **/

    if (sockaddrlen < sizeof(SOCKADDR_IPX))
       return WSAEFAULT;

    /** Looks like a good addr - determine the type **/

    if (!memcmp(sa->sa_nodenum, wsh_bcast, 6))
       sockaddrinfo->AddressInfo = SockaddrAddressInfoBroadcast;
    else
       sockaddrinfo->AddressInfo = SockaddrAddressInfoNormal;

    /** Determine the endpoint **/

    if (sa->sa_socket == 0)
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    else if (ntohs(sa->sa_socket) < 2000)
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoReserved;
    else
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoNormal;

    /** **/

    return NO_ERROR;
}

/*page**************************************************************
       W S H G e t W i n s o c k M a p p i n g

       Returns the list of address family/socket type/protocol
       triples supported by this helper DLL.

       Arguments - mapping = Contect ptr from WSAOpenSocket
            maplen  =

       Returns - The length in bytes of a eeded OK
          Else = WinSock error code
********************************************************************/
DWORD WSHGetWinsockMapping(PWINSOCK_MAPPING mapping, DWORD maplen)
{
    DWORD len;

    /**
       Figure how much data we are going to copy into
       the user buffer.
    **/

    len = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
         dgram_table_size + stream_table_size;

    /**
       If the buffer passed is too small, then return the size
       that is needed.  The caller should then call us again
       with a buffer of the correct size.
    **/

    if (len > maplen)
       return len;

    /** Fill in the output buffer **/

    mapping->Rows    = stream_num_triples + dgram_num_triples;
    mapping->Columns = MAPPING_NUM_COLUMNS;
    RtlMoveMemory(mapping->Mapping,
          stream_triples,
          stream_table_size);

    RtlMoveMemory((PCHAR)mapping->Mapping + stream_table_size,
          dgram_triples,
          dgram_table_size);

    /** Return the number of bytes we filled in **/

    return len;
}

/*page***************************************************************
       W S H N o t i f y

       This routine is called for events that we registered at
       open socket time.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            event      = What event happened

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHNotify(PVOID context, SOCKET handle,
             HANDLE addrhandle, HANDLE connhandle,
             DWORD event)
{
    INT rc;
    INT t1;
    PWSHIPX_SOCKET_CONTEXT ct;

    /** Get context pointer **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    /** On close - just free the context structure **/

    if (event == WSH_NOTIFY_CLOSE) {
       RtlFreeHeap(RtlProcessHeap(), 0L, context);
       return NO_ERROR;
    }

    /** On bind set the send packet type **/

    if (event == WSH_NOTIFY_BIND)
    {
        if (ct->con_socktype == SOCK_DGRAM)
        {
            /** Set the send packet ptype **/
            t1 = (UINT)ct->con_sendptype;
            rc = WSHSetSocketInformation(
                    context, handle, addrhandle,
                    connhandle, NSPROTO_IPX,
                    IPX_PTYPE, (PCHAR)&t1, sizeof(INT));

            if (rc)
                return rc;

            if (ct->con_flags & WSHCON_EXTADDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_EXTENDED_ADDRESS, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Set the recv filter packet type **/

            if (ct->con_flags & WSHCON_FILTER)
            {
                t1 = (UINT)ct->con_recvptype;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_FILTERPTYPE, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Set up broadcast reception **/

            if (ct->con_flags & WSHCON_RCVBCAST)
            {

                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECEIVE_BROADCAST, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Enable send header if we need to **/
            if (ct->con_flags & WSHCON_SENDHDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECVHDR, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }
        }
        else if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
        {
            if (ct->con_flags & WSHCON_SENDHDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECVHDR, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            if (ct->con_flags & WSHCON_IMM_SPXACK)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_IMMEDIATESPXACK, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }
        }

        /** It is OK - return OK **/
        return NO_ERROR;
    }

    /** On connect set things not set already **/
    if (event == WSH_NOTIFY_CONNECT)
    {

        /** If on DGRAM - just return OK **/
        if (ct->con_socktype == SOCK_DGRAM)
            return NO_ERROR;

        /**
           If the datastream type has been set - set it
       **/

        if (ct->con_dstype)
        {
            rc = do_tdi_action(connhandle, MSPX_SETDATASTREAM, &ct->con_dstype, 1, FALSE, NULL);
            if (rc)
                return rc;
        }

        /** It is OK - return OK **/
        return NO_ERROR;
    }

    /** All others are bad **/
    return WSAEINVAL;
}


/*page**************************************************************
       W S H G e t S o c k I n f o r m a t i o n

       This routine retrieves information about a socket for those
       socket options supported in this DLL.  The options
       supported here are SO_KEEPALIVE and SO_DONTROUTE.  This
       routine is called by the WinSock DLL when a level/option name
       combination is passed to getsockopt that the WinSock DLL
       does not understand.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            level      = Level from getsockopt call
            optname    = Option name from getsockopt call
            optvalue   = Option value ptr from getsockopt call
            optlength  = Option length field from getsockopt call

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
********************************************************************/
INT WSHGetSocketInformation(PVOID context, SOCKET handle,
                    HANDLE addrhandle, HANDLE connhandle,
                    INT level, INT optname, PCHAR optvalue,
                    PINT optlength)
{
    PWSHIPX_SOCKET_CONTEXT ct;
    INT rc;
    INT ibuf[2];
    PIPX_ADDRESS_DATA p;

    /** Get ptr to context **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    //
    // Check if this is an internal request for context information.
    //

    if ( level == SOL_INTERNAL && optname == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( optvalue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *optlength < sizeof(*ct) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( optvalue, ct, sizeof(*ct) );
        }

        *optlength = sizeof(*ct);

        return NO_ERROR;
    }

    /** The only level we support is NSPROTO_IPX **/

    if (level != NSPROTO_IPX)
       return WSAEINVAL;

    /** Fill in the result based on the options name **/

    switch (optname) {

    /** Get the current send packet type **/

    case IPX_PTYPE:

       /** Make sure the length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Set the type **/

       *(UINT *)optvalue = (UINT)ct->con_sendptype;
       *optlength = sizeof(UINT);
       break;

    /** Get the current recv packet type filter **/

    case IPX_FILTERPTYPE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** If option not on - return error **/

       if (!(ct->con_flags & WSHCON_FILTER))
           return WSAEINVAL;

       /** Save the new value **/

       *(UINT *)optvalue = (UINT)ct->con_recvptype;
       *optlength = sizeof(UINT);
       break;

    /** Get the max DGRAM size that can be sent **/

    case IPX_MAXSIZE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value from the driver **/

       rc = do_tdi_action(addrhandle, MIPX_GETPKTSIZE, (PUCHAR)ibuf, sizeof(INT)*2, TRUE, NULL);

       *(INT *)optvalue = ibuf[1];
       *optlength = sizeof(int);

       /** Return the result **/

       return rc;

    /** Get the max adapternum that is valid **/

    case IPX_MAX_ADAPTER_NUM:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value from the driver **/

       rc = do_tdi_action(addrhandle, MIPX_ADAPTERNUM, optvalue, sizeof(INT), TRUE, NULL);

       *optlength = sizeof(int);

       /** Return the result **/

       return rc;

    /** Get SPX statistics **/

    case IPX_SPXGETCONNECTIONSTATUS:

        /** Make sure data length OK **/

        if (*optlength < sizeof(IPX_SPXCONNSTATUS_DATA))
            return WSAEFAULT;

        /** Make sure this is for a STREAM socket **/

        if ((ct->con_socktype != SOCK_STREAM) &&
            (ct->con_socktype != SOCK_SEQPACKET)) {

            return WSAEINVAL;
        }

        /** Send it to the driver **/

        rc = do_tdi_action(
                connhandle,
                MSPX_GETSTATS,
                optvalue,
                *optlength,
                FALSE,
                NULL);

        if (rc)
            return rc;

        *optlength = sizeof(IPX_SPXCONNSTATUS_DATA);

        /** Return OK **/

        return NO_ERROR;

    /** Get the current datastream type to send pkts with **/

    case IPX_DSTYPE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a STREAM socket **/

       if ((ct->con_socktype != SOCK_STREAM) &&
           (ct->con_socktype != SOCK_SEQPACKET)) {

           return WSAEINVAL;
       }

       /** Save the new value **/

       *(UINT *)optvalue = (UINT)ct->con_dstype;
       *optlength = sizeof(UINT);
       break;

    /** Get net information **/

    case IPX_GETNETINFO:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_GETNETINFO,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Get net information without RIPping **/

    case IPX_GETNETINFO_NORIP:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_GETNETINFO_NR,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Like GETNETINFO, but force a re-rip **/

    case IPX_RERIPNETNUMBER:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_RERIPNETNUM,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Get card information **/

    case IPX_ADDRESS_NOTIFY:

       /** We need the action header, the data, and the event handle **/

       if (*optlength < (INT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]) + sizeof(IPX_ADDRESS_DATA) + sizeof(HANDLE)))
           return WSAEFAULT;

       /** Otherwise just fall through **/

    case IPX_ADDRESS:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_OLD_ADDRESS_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       if (optname == IPX_ADDRESS) {

           rc = do_tdi_action(
                    addrhandle,
                    MIPX_GETCARDINFO,
                    optvalue,
                    *optlength,
                    TRUE,
                    NULL);

       } else {

           rc = do_tdi_action(
                    addrhandle,
                    MIPX_NOTIFYCARDINFO,
                    optvalue,
                    *optlength - sizeof(HANDLE),
                    TRUE,
                    (PHANDLE)(optvalue + FIELD_OFFSET(NWLINK_ACTION, Data[0]) + sizeof(IPX_ADDRESS_DATA)));
       }

       if (rc) {
           p = (PIPX_ADDRESS_DATA)optvalue;
           memset(p->netnum, 0xFF, 4);
           memset(p->nodenum, 0xFF, 6);
           return rc;
       }

       /** Return OK **/

       if (*optlength < sizeof(IPX_ADDRESS_DATA)) {
           *optlength = sizeof(IPX_OLD_ADDRESS_DATA);
       } else if (*optlength < sizeof(IPX_ADDRESS_DATA)) {
           *optlength = sizeof(IPX_ADDRESS_DATA);
       }

       return NO_ERROR;

    /** All others are error **/

    default:
       return WSAENOPROTOOPT;
    }

    /** All is OK **/

    return NO_ERROR;
}

/*page***************************************************************
       W S H S e t S o c k e t I n f o r m a t i o n

       This routine sets information about a socket for those
       options supported in this helper DLL.  This routine
       is called when a setsockopt call is made and the option/level
       passed is unknown to the WinSock DLL.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            level      = Level from getsockopt call
            optname    = Option name from getsockopt call
            optvalue   = Option value ptr from getsockopt call
            optlength  = Option length field from getsockopt call

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHSetSocketInformation(PVOID context, SOCKET handle,
                    HANDLE addrhandle, HANDLE connhandle,
                    INT level, INT optname, PCHAR optvalue,
                    INT optlength)
{
    PWSHIPX_SOCKET_CONTEXT ct;
    INT rc;

    /** Get ptr to context **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    //
    // Check if this is an internal request for context information.
    //

    if ( level == SOL_INTERNAL && optname == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( optlength < sizeof(*ct) ) {
            return WSAEINVAL;
        }

        if ( ct == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            ct = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*ct) );
            if ( ct == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( ct, optvalue, sizeof(*ct) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHIPX_SOCKET_CONTEXT *)optvalue = ct;

            return NO_ERROR;

        } else {

            PWSHIPX_SOCKET_CONTEXT parentContext;
            INT one = 1;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHIPX_SOCKET_CONTEXT)optvalue;

            ASSERT( ct->con_addrfam == parentContext->con_addrfam );
            ASSERT( ct->con_socktype == parentContext->con_socktype );
            ASSERT( ct->con_pcol == parentContext->con_pcol );

            return NO_ERROR;
        }
    }

    /** We only support level NSPROTO_IPX **/

    if (level != NSPROTO_IPX)
       return WSAEINVAL;

    /** Handle the options **/

    switch (optname) {

    /** Set the send packet type **/

    case IPX_PTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_sendptype = (UCHAR)rc;

       /** Send the new value down to the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_SETSENDPTYPE, &ct->con_sendptype, 1, TRUE, NULL);
       else
           rc = NO_ERROR;

       return rc;

    /** Set the recv filter for packet type **/

    case IPX_FILTERPTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_recvptype = (UCHAR)rc;
       ct->con_flags |= WSHCON_FILTER;

       /** Send the new value down to the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_FILTERPTYPE, &ct->con_recvptype, 1, TRUE, NULL);
       else
           rc = NO_ERROR;

       /** **/

       return rc;

    /** Stop filtering recv on pkt type **/

    case IPX_STOPFILTERPTYPE:

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Turn off the flag **/

       ct->con_flags &= ~WSHCON_FILTER;

       /** Tell the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_NOFILTERPTYPE, NULL, 0, TRUE, NULL);
       else
           rc = NO_ERROR;
       break;

    /** Set piggyback wait for backtraffic flag **/
    case IPX_IMMEDIATESPXACK:

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc)
        {
            /** Turn it ON **/
            rc = WSAEINVAL;
            if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;

                ct->con_flags |= WSHCON_IMM_SPXACK;

                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_NOACKWAIT, NULL, 0, TRUE, NULL);
            }
        }
        else
        {
            /** Turn it OFF **/
            rc = WSAEINVAL;
            if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;

                ct->con_flags &= ~WSHCON_IMM_SPXACK;

                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_ACKWAIT, NULL, 0, TRUE, NULL);
            }
       }

       /** Return the result **/
       return rc;

    /** Set to recv pcol hdrs with data **/

    case IPX_RECVHDR:

        /** Get the optvalue as an INT **/
        rc = *(INT *)optvalue;

        if (rc)
        {
            /** Turn it ON **/
            ct->con_flags |= WSHCON_SENDHDR;

            /** Send it to the driver **/
            rc = WSAEINVAL;
            if (ct->con_socktype == SOCK_DGRAM)
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MIPX_SENDHEADER, NULL, 0, TRUE, NULL);
            }
            else if ((ct->con_socktype == SOCK_STREAM) ||
                    (ct->con_socktype == SOCK_SEQPACKET))
            {
                /** Do this on address handle **/
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_SENDHEADER, NULL, 0, TRUE, NULL);
            }
        }
        else
        {

            /** Turn it OFF **/
            ct->con_flags &= ~WSHCON_SENDHDR;

            /** Send it to the driver **/
            rc = WSAEINVAL;
            if (ct->con_socktype == SOCK_DGRAM)
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MIPX_NOSENDHEADER, NULL, 0, TRUE, NULL);
            }
            else if ((ct->con_socktype == SOCK_STREAM) ||
                     (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_NOSENDHEADER, NULL, 0, TRUE, NULL);
            }
        }

        /** Return the result **/
        return rc;

    /** Set the Datastream type to send pkts with **/

    case IPX_DSTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a STREAM socket **/

       if ((ct->con_socktype != SOCK_STREAM) &&
           (ct->con_socktype != SOCK_SEQPACKET)) {

           return WSAEINVAL;
       }

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_dstype = (UCHAR)rc;

       /** Send the new value down to the driver **/

       if (connhandle)
           rc = do_tdi_action(connhandle, MSPX_SETDATASTREAM, &ct->con_dstype, 1, FALSE, NULL);
       else
           rc = 0;

       /** **/

       return rc;

    /** Set the extended address option **/

    case IPX_EXTENDED_ADDRESS:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc) {

           /** Send the option down to the driver **/

           ct->con_flags |= WSHCON_EXTADDR;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_SENDADDROPT, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       else {

           /** Send the option down to the driver **/

           ct->con_flags &= ~WSHCON_EXTADDR;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_NOSENDADDROPT, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       return rc;


    /** Set the broadcast reception **/

    case IPX_RECEIVE_BROADCAST:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc) {

           /** Send the option down to the driver **/

           ct->con_flags |= WSHCON_RCVBCAST;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_RCVBCAST, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       else {

           /** Send the option down to the driver **/

           ct->con_flags &= ~WSHCON_RCVBCAST;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_NORCVBCAST, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       return rc;

    /** All others return error **/

    default:
       return WSAENOPROTOOPT;
    }

    /** All Done OK **/

    return NO_ERROR;
}

/*page***************************************************************
       W S H G e t W i l d c a r d S o c k a d d r

       This routing returns a wilcard socket address for the
       sockets DLL to use.

       Arguments - context    = Context ptr from WSAOpenSocket
            addrp      = Ptr to where to store the address
            addrlen    = Ptr to where to store length of address

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHGetWildcardSockaddr(PVOID context, PSOCKADDR addrp, PINT addrlen)
{

    /**
       Setup the address as the address family +
       all 0's for the rest.
    **/

    memset(addrp, 0, sizeof(SOCKADDR));
    addrp->sa_family = AF_NS;

    /** Set the address length **/

    *addrlen = sizeof(SOCKADDR);

    /** Return OK **/

    return NO_ERROR;
}

/*page***************************************************************
       i s _ t r i p l e _ i n _ l i s t

       Check to see if the given triple is in the given
       triple list.

       Arguments - tlist    = Ptr to the triple list
            tlen     = Num entries in the triple list
            addrfam  = Address family to look for
            socktype = Socket Type to look for
            pcol     = Protocol to look for

       Returns - TRUE   = Yes
          FALSE = No
*********************************************************************/
BOOLEAN is_triple_in_list(PMAPPING_TRIPLE tlist, ULONG tlen,
                  INT addrfam, INT socktype, INT pcol)
{
    ULONG i;

    /**
       Go thru the list and search to see if we can
       find the given triple in the list.
    **/

    for (i = 0 ; i < tlen ; i++,tlist++) {

       /** If it matches - return OK **/

       if ((addrfam  == tlist->triple_addrfam) &&
           (socktype == tlist->triple_socktype) &&
           (pcol     == tlist->triple_protocol))

           return TRUE;
    }

    /** Not Found **/

    return FALSE;
}

/*page***************************************************************
       W S H E n u m P r o t o c o l s

       Enumerates IPX/SPX protocols.

       Returns - NO_ERROR or an error code.
*********************************************************************/
INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DWORD bytesRequired;
    PPROTOCOL_INFOW protocolInfo;
    BOOL useSpx = FALSE;
    BOOL useSpx2 = FALSE;
    BOOL useIpx = FALSE;
    BOOL spxString;
    DWORD i;
    PWCHAR namePtr;
    INT entriesReturned = 0;

    //
    // Determine whether we should return information for IPX or SPX.
    //

    if ( _wcsicmp( L"NwlnkIpx", (LPWSTR)lpTransportKeyName ) == 0 ) {
        spxString = FALSE;
    } else {
        spxString = TRUE;
    }

    //
    // Make sure that the caller cares about SPX, SPX2, and/or IPX.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == NSPROTO_SPX && spxString ) {
                useSpx = TRUE;
            }
            if ( lpiProtocols[i] == NSPROTO_SPXII && spxString ) {
                useSpx2 = TRUE;
            }
            if ( lpiProtocols[i] == NSPROTO_IPX && !spxString ) {
                useIpx = TRUE;
            }
        }

    } else {

        useSpx = FALSE;
        useSpx2 = spxString;
        useIpx = !spxString;
    }

    if ( !useSpx && !useSpx2 && !useIpx ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 3) +
                        ( (wcslen( SPX_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( SPX2_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( IPX_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Initialize local variables.
    //

    protocolInfo = lpProtocolBuffer;
    namePtr = (PWCHAR)( (PCHAR)lpProtocolBuffer + *lpdwBufferLength );

    //
    // Fill in SPX info, if requested.
    //

    if ( useSpx ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                       XP_MESSAGE_ORIENTED |
                                       XP_PSEUDO_STREAM |
                                       XP_GUARANTEED_ORDER |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_SEQPACKET;
        protocolInfo->iProtocol = NSPROTO_SPX;
        protocolInfo->dwMessageSize = 0xFFFFFFFF;

        namePtr = namePtr - (wcslen( SPX_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, SPX_NAME );

        protocolInfo += 1;
    }

    //
    // Fill in SPX II info, if requested.
    //

    if ( useSpx2 ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                       XP_MESSAGE_ORIENTED |
                                       XP_PSEUDO_STREAM |
                                       XP_GRACEFUL_CLOSE |
                                       XP_GUARANTEED_ORDER |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_SEQPACKET;
        protocolInfo->iProtocol = NSPROTO_SPXII;
        protocolInfo->dwMessageSize = 0xFFFFFFFF;

        namePtr = namePtr - (wcslen( SPX2_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, SPX2_NAME );

        protocolInfo += 1;
    }

    //
    // Fill in IPX info, if requested.
    //

    if ( useIpx ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                       XP_MESSAGE_ORIENTED |
                                       XP_SUPPORTS_BROADCAST |
                                       XP_SUPPORTS_MULTICAST |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_DGRAM;
        protocolInfo->iProtocol = NSPROTO_IPX;
        protocolInfo->dwMessageSize = 576;

        namePtr = namePtr - (wcslen( IPX_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, IPX_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return entriesReturned;

} // WSHEnumProtocols


#define _IPX_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)
#define IOCTL_IPX_LOAD_SPX      _IPX_CONTROL_CODE( 0x5678, METHOD_BUFFERED )

DWORD
WshLoadSpx(
    VOID
    )
/*++

Routine Description:

    Starts the nwlnkspx.sys driver by submitting a special ioctl
    to ipx, which calls ZwLoadDriver() for us.

Arguments:

    none

Returns:

    Error return from the load operation.

++*/
{
    DWORD err = NO_ERROR;
    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileString;
    WCHAR FileName[] = L"\\Device\\NwlnkIpx";
    NTSTATUS Status;

    RtlInitUnicodeString (&FileString, FileName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
                 &FileHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status)) {

        err = ERROR_FILE_NOT_FOUND;

    } else {

        Status = NtDeviceIoControlFile(
                     FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_IPX_LOAD_SPX,
                     NULL,
                     0,
                     NULL,
                     0);

        if (Status == STATUS_IMAGE_ALREADY_LOADED) {

            err = ERROR_SERVICE_ALREADY_RUNNING;

            //
            // #36451
            // If the service controller loads SPX ("net start nwlnkspx", or due to dependency of RPC on SPX)
            // then we get this error the first time too. Keep a note of that.
            //
            // NOTE: we still leak a handle per process since the handle to the driver is actually created
            // in the system process' context. The ideal way to fix this should be to have IPX associate the
            // handle with the current process (so handle is destroyed when the process dies) or to have the
            // dll tell IPX to close the handle it opened earlier.
            //
            SpxLoaded = TRUE;

        } else if (!NT_SUCCESS(Status)) {

            err = ERROR_IO_DEVICE;

        } else {
            SpxLoaded = TRUE;
        }

        NtClose (FileHandle);

    }

    return(err);
}

/*page***************************************************************
       W S H G e t P r o v i d e r G u i d

       Queries the GUID identifier for this protocol.

       Returns - NO_ERROR or an error code.
*********************************************************************/
INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )
{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"NwlnkIpx" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &IpxProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    if( _wcsicmp( ProviderName, L"NwlnkSpx" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &SpxProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
        
    WCHAR string[BUFFER_SIZE];
    INT length;
    LPSOCKADDR_IPX addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_IPX) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_IPX)Address;

    if( addr->sa_family != AF_NS ) {

        return WSAEINVAL;

    }

 
    length = swprintf(
                 string,
                 L"%2.2x%2.2x%2.2x%2.2x.%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                 (UCHAR) addr->sa_netnum[0],
                                 (UCHAR) addr->sa_netnum[1],
                                 (UCHAR) addr->sa_netnum[2],
                                 (UCHAR) addr->sa_netnum[3],
                                 (UCHAR) addr->sa_nodenum[0],
                                 (UCHAR) addr->sa_nodenum[1],
                                 (UCHAR) addr->sa_nodenum[2],
                                 (UCHAR) addr->sa_nodenum[3],
                                 (UCHAR) addr->sa_nodenum[4],
                                 (UCHAR) addr->sa_nodenum[5]                                     
                 );

    if( addr->sa_socket != 0 ) {

        length += swprintf(
                      string + length,
                      L":%hu",
                      ntohs( addr->sa_socket )
                      );

    }

    length++;   // account for terminator

        if ( length > BUFFER_SIZE ) {
                DbgPrint("length exceeded internal buffer in wshisn.dll.\n"); 
                return WSAEFAULT; 
        }

    if( *AddressStringLength < (DWORD)length ) {
                DbgPrint("AddressStringLength %lu < length %lu\n",*AddressStringLength, length);  
        return WSAEFAULT;
    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\winsock\wshisn.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshnwlnk.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>
#include <wsipx.h>
#include <wsnwlink.h>

/*page****************************************************************
       These are the triples we support.
*********************************************************************/
typedef struct _MAPPING_TRIPLE {
    INT triple_addrfam;
    INT triple_socktype;
    INT triple_protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE stream_triples[] = {
    { AF_NS,   SOCK_STREAM,    NSPROTO_SPX },
    { AF_NS,   SOCK_SEQPACKET, NSPROTO_SPX },
    { AF_NS,   SOCK_STREAM,    NSPROTO_SPXII },
    { AF_NS,   SOCK_SEQPACKET, NSPROTO_SPXII },
};
int stream_num_triples = 4;                     /* When SPXII - set to 4 */
int stream_table_size = sizeof(stream_triples);

/**
    For IPX we assign the default packet type according to the
    protocol type used.  The user can also we setsockopt
    to set the packet type.
**/

MAPPING_TRIPLE dgram_triples[] = {
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX     },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+1   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+2   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+3   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+4   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+5   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+6   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+7   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+8   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+9   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+10  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+11  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+12  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+13  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+14  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+15  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+16  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+17  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+18  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+19  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+20  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+21  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+22  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+23  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+24  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+25  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+26  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+27  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+28  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+29  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+30  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+31  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+32  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+33  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+34  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+35  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+36  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+37  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+38  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+39  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+40  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+41  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+42  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+43  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+44  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+45  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+46  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+47  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+48  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+49  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+50  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+51  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+52  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+53  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+54  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+55  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+56  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+57  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+58  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+59  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+60  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+61  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+62  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+63  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+64  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+65  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+66  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+67  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+68  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+69  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+70  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+71  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+72  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+73  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+74  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+75  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+76  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+77  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+78  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+79  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+80  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+81  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+82  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+83  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+84  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+85  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+86  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+87  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+88  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+89  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+90  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+91  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+92  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+93  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+94  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+95  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+96  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+97  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+98  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+99  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+100 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+101 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+102 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+103 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+104 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+105 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+106 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+107 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+108 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+109 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+110 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+111 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+112 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+113 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+114 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+115 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+116 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+117 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+118 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+119 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+120 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+121 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+122 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+123 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+124 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+125 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+126 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+127 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+128 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+129 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+130 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+131 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+132 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+133 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+134 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+135 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+136 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+137 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+138 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+139 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+140 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+141 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+142 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+143 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+144 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+145 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+146 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+147 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+148 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+149 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+150 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+151 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+152 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+153 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+154 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+155 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+156 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+157 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+158 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+159 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+160 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+161 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+162 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+163 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+164 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+165 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+166 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+167 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+168 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+169 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+170 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+171 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+172 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+173 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+174 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+175 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+176 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+177 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+178 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+179 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+180 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+181 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+182 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+183 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+184 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+185 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+186 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+187 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+188 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+189 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+190 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+191 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+192 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+193 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+194 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+195 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+196 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+197 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+198 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+199 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+200 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+201 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+202 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+203 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+204 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+205 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+206 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+207 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+208 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+209 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+210 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+211 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+212 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+213 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+214 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+215 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+216 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+217 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+218 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+219 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+220 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+221 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+222 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+223 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+224 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+225 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+226 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+227 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+228 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+229 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+230 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+231 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+232 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+233 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+234 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+235 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+236 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+237 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+238 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+239 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+240 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+241 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+242 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+243 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+244 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+245 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+246 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+247 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+248 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+249 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+250 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+251 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+252 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+253 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+254 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+255 }
};
int dgram_num_triples = 256;
int dgram_table_size = sizeof(dgram_triples);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\idlole\makefile.inc ===
$(O)\alg.idl: alg.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ipmsp.idl: ipmsp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\confpriv.idl: confpriv.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\h323priv.idl: h323priv.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnetbcon.idl: hnetbcon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnetcfg.idl: hnetcfg.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnautoc.idl: hnautoc.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ih26xcd.idl: ih26xcd.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msp.idl: msp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\natupnp.idl: natupnp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcfgn.idl: netcfgn.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcfgx.idl: netcfgx.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcon.idl: netcon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netmon.idl: netmon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\prsht.idl: prsht.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rend.idl: rend.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\sdoias.idl: sdoias.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3cc.idl: tapi3cc.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3ds.idl: tapi3ds.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3if.idl: tapi3if.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\termmgr.idl: termmgr.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rtccore.idl: rtccore.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\upnp.idl: upnp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\upnphost.idl: upnphost.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_ROOT)\inc\$(O)\cxq_cust.h: $(O)\cxq_cust.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\iaspolcy.h: $(O)\iaspolcy.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\iaspolcy.idl: iaspolcy.idl
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\ippmcb.h: $(O)\ippmcb.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\netmon.idl: netmon.idl
    -copy /v $? $@
    
$(PROJECT_ROOT)\inc\$(O)\upnpp.h: $(O)\upnpp.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\upnpp.idl: upnpp.idl
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\dhcpcsvc.c ===
#include "netpch.h"
#pragma hdrstop

#include <dhcpcapi.h>


static
DWORD
APIENTRY
DhcpAcquireParameters(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
DhcpAcquireParametersByBroadcast(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DhcpNotifyConfigChange(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD 
APIENTRY
DhcpStaticRefreshParams(
    IN LPWSTR Adapter
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DhcpReleaseParameters(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(dhcpcsvc)
{
    DLPENTRY(DhcpAcquireParameters)
    DLPENTRY(DhcpAcquireParametersByBroadcast)
    DLPENTRY(DhcpNotifyConfigChange)
    DLPENTRY(DhcpReleaseParameters)
    DLPENTRY(DhcpStaticRefreshParams)
};

DEFINE_PROCNAME_MAP(dhcpcsvc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\winsock\wshutil.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshutil.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>

#include <isnkrnl.h>

/*page*******************************************************
       d o _ t d i _ a c t i o n

       Generate a TDI_ACTION down to the streams
       driver.

       Arguments - fd     = Handle to send on
            cmd    = Command to send down
            optbuf = Ptr to options buffer
            optlen = Ptr to options length
            addrflag = TRUE  = This is for DG/STREAM socket on addr handle
                       FALSE = This is for conn handle

       Returns - A WinSock error code (NO_ERROR = OK)
************************************************************/
INT do_tdi_action(HANDLE fd, ULONG cmd, PUCHAR optbuf, INT optlen, BOOLEAN addrflag, PHANDLE eventhandle OPTIONAL)
{
    NTSTATUS status;
    PSTREAMS_TDI_ACTION tdibuf;
    ULONG           tdilen;
    IO_STATUS_BLOCK iostat;
    HANDLE          event;


    /** If the eventhandle is passed, it also means that the **/
    /** NWLINK_ACTION header is pre-allocated in the buffer, **/
    /** although we still have to fill the header in here.   **/

    if (eventhandle == NULL) {

        /** Get the length of the buffer we need to allocate **/

        tdilen = FIELD_OFFSET(STREAMS_TDI_ACTION,Buffer) + sizeof(ULONG) + optlen;

        /** Allocate a buffer to use for the action **/

        tdibuf = RtlAllocateHeap(RtlProcessHeap(), 0, tdilen);
        if (tdibuf == NULL) {
           return WSAENOBUFS;
        }

    } else {

        tdilen = optlen;
        tdibuf = (PSTREAMS_TDI_ACTION)optbuf;

    }

    /** Set the datagram option **/

    RtlMoveMemory(&tdibuf->Header.TransportId, "MISN", 4);
    tdibuf->DatagramOption = addrflag;

    /**
       Fill out the buffer, the buffer looks like this:

       ULONG cmd
       data passed.
    **/

    memcpy(tdibuf->Buffer, &cmd, sizeof(ULONG));

    if (eventhandle == NULL) {

        tdibuf->BufferLength = sizeof(ULONG) + optlen;

        RtlMoveMemory(tdibuf->Buffer + sizeof(ULONG), optbuf, optlen);

        /** Create an event to wait on **/

        status = NtCreateEvent(
           &event,
           EVENT_ALL_ACCESS,
           NULL,
           SynchronizationEvent,
           FALSE);

        /** If no event - then return error **/

        if (!NT_SUCCESS(status)) {
           RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);
           return WSAENOBUFS;
        }

    } else {

        tdibuf->BufferLength = sizeof(ULONG) + optlen - FIELD_OFFSET (NWLINK_ACTION, Data[0]);

        /** Use the event handle passed in **/

        event = *eventhandle;

    }

    /** **/

    status = NtDeviceIoControlFile(
       fd,
       event,
       NULL,
       NULL,
       &iostat,
       IOCTL_TDI_ACTION,
       NULL,
       0,
       tdibuf,
       tdilen);


    if (eventhandle == NULL) {

        /** If pending - wait for it to finish **/

        if (status == STATUS_PENDING) {
           status = NtWaitForSingleObject(event, FALSE, NULL);
           ASSERT(status == 0);
           status = iostat.Status;
        }

        /** Close the event **/

        NtClose(event);

    }

    /** If we get an error - return it **/

    if (!NT_SUCCESS(status)) {
       if (eventhandle == NULL) {
           RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);
       }
       return WSAEINVAL;
    }

    if (eventhandle == NULL) {

        /** Copy the returned back to optbuf if needed */

        if (optlen) {
            RtlMoveMemory (optbuf, tdibuf->Buffer + sizeof(ULONG), optlen);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);

    }

    /** Return OK **/

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\iashlpr.c ===
#include "netpch.h"
#pragma hdrstop

static
HRESULT 
WINAPI 
ConfigureIas (
    VOID
    )
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(iashlpr)
{
    DLPENTRY(ConfigureIas)
};

DEFINE_PROCNAME_MAP(iashlpr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\netpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\iphlpapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <winsock2.h>
#include <iphlpapi.h>


static
DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpNetTable(
    OUT    PMIB_IPNETTABLE pIpNetTable,
    IN OUT PULONG          pdwSize,
    IN     BOOL            bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpForwardTable(
    OUT    PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT PULONG              pdwSize,
    IN     BOOL                bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpStatistics(
    OUT  PMIB_IPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpStatisticsEx(
    OUT  PMIB_IPSTATS   pStats,
    IN   DWORD          dwFamily
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD  pdwNumIf
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetTcpStatisticsEx(
    OUT PMIB_TCPSTATS   pStats,
    IN  DWORD           dwFamily
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetUdpStatisticsEx(
    OUT PMIB_UDPSTATS   pStats,
    IN  DWORD           dwFamily
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetBestInterfaceEx(
    IN  struct sockaddr *pDestAddr,
    OUT PDWORD           pdwBestIfIndex
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
NotifyAddrChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
NotifyRouteChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    
    return FALSE;
}

static
DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetAdaptersAddresses(
    IN     ULONG                 Family,
    IN     DWORD                 Flags,
    IN     PVOID                 Reserved,
    OUT    PIP_ADAPTER_ADDRESSES pAdapterAddresses,
    IN OUT PULONG                pOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetAdaptersInfo(
    PIP_ADAPTER_INFO    pAdapterInfo,
    PULONG              pOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIfEntry(
    IN OUT PMIB_IFROW   pIfRow
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetPerAdapterInfo(
    ULONG                   IfIndex,
    PIP_PER_ADAPTER_INFO    pPerAdapterInfo,
    PULONG                  pOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
NhGetInterfaceNameFromDeviceGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(iphlpapi)
{
    DLPENTRY(GetAdaptersAddresses)
    DLPENTRY(GetAdaptersInfo)
    DLPENTRY(GetBestInterface)
    DLPENTRY(GetBestInterfaceEx)
    DLPENTRY(GetBestRoute)
    DLPENTRY(GetFriendlyIfIndex)
    DLPENTRY(GetIcmpStatistics)
    DLPENTRY(GetIfEntry)
    DLPENTRY(GetIfTable)
    DLPENTRY(GetInterfaceInfo)    
    DLPENTRY(GetIpAddrTable)
    DLPENTRY(GetIpForwardTable)
    DLPENTRY(GetIpNetTable)
    DLPENTRY(GetIpStatistics)
    DLPENTRY(GetIpStatisticsEx)
    DLPENTRY(GetNumberOfInterfaces)    
    DLPENTRY(GetPerAdapterInfo)
    DLPENTRY(GetRTTAndHopCount)
    DLPENTRY(GetTcpStatistics)
    DLPENTRY(GetTcpStatisticsEx)
    DLPENTRY(GetUdpStatistics)
    DLPENTRY(GetUdpStatisticsEx)
    DLPENTRY(NhGetInterfaceNameFromDeviceGuid)
    DLPENTRY(NotifyAddrChange)
    DLPENTRY(NotifyRouteChange)    
};

DEFINE_PROCNAME_MAP(iphlpapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\mswsock.c ===
#include "netpch.h"
#pragma hdrstop

#include <wsasetup.h>

static
DWORD
MigrateWinsockConfiguration(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mswsock)
{
    DLPENTRY(MigrateWinsockConfiguration)
};

DEFINE_PROCNAME_MAP(mswsock)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\netcfgx.c ===
#include "netpch.h"
#pragma hdrstop

#include "netcfgx.h"
#include "netcfgp.h"


static
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    INetCfg* pINetCfg,
    INetCfgInternalSetup* pInternalSetup,
    const NIQ_INFO* pInfo)    
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection)
{
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netcfgx)
{
    DLPENTRY(HrDiAddComponentToINetCfg)
    DLPENTRY(UpdateLanaConfigUsingAnswerfile)
};

DEFINE_PROCNAME_MAP(netcfgx)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\mprapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <mprapi.h>
#include <mprapip.h>

static
DWORD
MprAdminBufferFree(
    IN PVOID        pBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD APIENTRY
MprAdminConnectionEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MprAdminConnectionGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminDeregisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceDelete(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceTransportRemove(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL APIENTRY
MprAdminIsServiceRunning(
    IN  LPWSTR  lpwsServerName
)
{
    return FALSE;
}

static
DWORD APIENTRY
MprAdminMIBBufferFree(
    IN      LPVOID                  pBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryCreate(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryDelete(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryGet(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInEntry,
    IN      DWORD                   dwInEntrySize,
    OUT     LPVOID*                 lplpOutEntry,
    OUT     LPDWORD                 lpOutEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntrySet(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBServerConnect(
    IN      LPWSTR                  lpwsServerName      OPTIONAL,
    OUT     MIB_SERVER_HANDLE *     phMibServer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprAdminMIBServerDisconnect(
    IN      MIB_SERVER_HANDLE       hMibServer
)
{
}

static
DWORD APIENTRY
MprAdminPortEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_PORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminPortGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hPort,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MprAdminRegisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminServerConnect(
    IN      LPWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprAdminServerDisconnect(
    IN      MPR_SERVER_HANDLE       hMprServer
    )
{
}

static
DWORD APIENTRY
MprAdminTransportCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminTransportGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE *                ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    OUT     LPBYTE *                ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminTransportSetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pGlobalInfo                 OPTIONAL,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminUpgradeUsers(
    IN  PWCHAR pszServer,
    IN  BOOL bLocal
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigBufferFree(
    IN      LPVOID                  pBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigServerConnect(
    IN      LPWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprConfigServerDisconnect(
    IN      HANDLE                  hMprConfig
    )
{
}

static
DWORD APIENTRY
MprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT LPWSTR*                 lplpwsDLLPath               OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportSetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN      LPBYTE                  pGlobalInfo                 OPTIONAL,
    IN      DWORD                   dwGlobalInfoSize            OPTIONAL,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath                 OPTIONAL
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
USHORT APIENTRY
MprGetUsrParams(
    USHORT    InfoType,
    LPWSTR    InBuf,
    LPWSTR    OutBuf
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprInfoBlockFind(
    IN      LPVOID                  lpHeader,
    IN      DWORD                   dwInfoType,
    OUT     LPDWORD                 lpdwItemSize,       // OPTIONAL
    OUT     LPDWORD                 lpdwItemCount,      // OPTIONAL
    OUT     LPBYTE*                 lplpItemData        // OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprInfoBlockSet(
    IN      LPVOID                  lpHeader,
    IN      DWORD                   dwInfoType,
    IN      DWORD                   dwItemSize,
    IN      DWORD                   dwItemCount,
    IN      LPBYTE                  lpItemData,
    OUT     LPVOID*                 lplpNewHeader
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprSetupIpInIpInterfaceFriendlyNameEnum(
    IN  PWCHAR  pwszMachineName,
    OUT LPBYTE* lplpBuffer,
    OUT LPDWORD lpdwEntriesRead
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprSetupIpInIpInterfaceFriendlyNameFree(
    IN  LPVOID  lpBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
RasPrivilegeAndCallBackNumber(
    IN BOOL         Compress,
    IN PRAS_USER_0  pRasUser0
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportGetInfo(
    IN      HANDLE  hMprConfig,
    IN      HANDLE  hRouterInterface,
    IN      HANDLE  hRouterIfTransport,
    IN  OUT LPBYTE* ppInterfaceInfo       OPTIONAL,
    OUT     LPDWORD lpdwInterfaceInfoSize OPTIONAL
)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mprapi)
{
    DLPENTRY(MprAdminBufferFree)
    DLPENTRY(MprAdminConnectionEnum)
    DLPENTRY(MprAdminConnectionGetInfo)
    DLPENTRY(MprAdminDeregisterConnectionNotification)
    DLPENTRY(MprAdminInterfaceCreate)
    DLPENTRY(MprAdminInterfaceDelete)
    DLPENTRY(MprAdminInterfaceEnum)
    DLPENTRY(MprAdminInterfaceGetHandle)
    DLPENTRY(MprAdminInterfaceTransportAdd)
    DLPENTRY(MprAdminInterfaceTransportRemove)
    DLPENTRY(MprAdminIsServiceRunning)
    DLPENTRY(MprAdminMIBBufferFree)
    DLPENTRY(MprAdminMIBEntryCreate)
    DLPENTRY(MprAdminMIBEntryDelete)
    DLPENTRY(MprAdminMIBEntryGet)
    DLPENTRY(MprAdminMIBEntrySet)
    DLPENTRY(MprAdminMIBServerConnect)
    DLPENTRY(MprAdminMIBServerDisconnect)
    DLPENTRY(MprAdminPortEnum)
    DLPENTRY(MprAdminPortGetInfo)
    DLPENTRY(MprAdminRegisterConnectionNotification)
    DLPENTRY(MprAdminServerConnect)
    DLPENTRY(MprAdminServerDisconnect)
    DLPENTRY(MprAdminTransportCreate)
    DLPENTRY(MprAdminTransportGetInfo)
    DLPENTRY(MprAdminTransportSetInfo)
    DLPENTRY(MprAdminUpgradeUsers)
    DLPENTRY(MprConfigBufferFree)
    DLPENTRY(MprConfigInterfaceCreate)
    DLPENTRY(MprConfigInterfaceDelete)
    DLPENTRY(MprConfigInterfaceEnum)
    DLPENTRY(MprConfigInterfaceGetHandle)
    DLPENTRY(MprConfigInterfaceTransportAdd)
    DLPENTRY(MprConfigInterfaceTransportEnum)
    DLPENTRY(MprConfigInterfaceTransportGetHandle)
    DLPENTRY(MprConfigInterfaceTransportGetInfo)
    DLPENTRY(MprConfigInterfaceTransportRemove)
    DLPENTRY(MprConfigServerConnect)
    DLPENTRY(MprConfigServerDisconnect)
    DLPENTRY(MprConfigTransportCreate)
    DLPENTRY(MprConfigTransportDelete)
    DLPENTRY(MprConfigTransportGetHandle)
    DLPENTRY(MprConfigTransportGetInfo)
    DLPENTRY(MprConfigTransportSetInfo)
    DLPENTRY(MprGetUsrParams)
    DLPENTRY(MprInfoBlockFind)
    DLPENTRY(MprInfoBlockSet)
    DLPENTRY(MprSetupIpInIpInterfaceFriendlyNameEnum)
    DLPENTRY(MprSetupIpInIpInterfaceFriendlyNameFree)
    DLPENTRY(RasPrivilegeAndCallBackNumber)
};

DEFINE_PROCNAME_MAP(mprapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\mpr.c ===
#include "netpch.h"
#pragma hdrstop

#include <winnetwk.h>

static
DWORD
APIENTRY
WNetAddConnection2W(
     IN LPNETRESOURCEW lpNetResource,
     IN LPCWSTR       lpPassword,
     IN LPCWSTR       lpUserName,
     IN DWORD          dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
WNetAddConnection3W(
    IN HWND             hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR          lpPassword,
    IN LPCWSTR          lpUserName,
    IN DWORD            dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCancelConnection2W(
    IN LPCWSTR  lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCloseEnum(
    IN HANDLE   hEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetEnumResourceW(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUniversalNameW(
     IN LPCWSTR lpLocalPath,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpBufferSize
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationW(
    IN LPNETRESOURCEW   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPWSTR         *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationA(
    IN LPNETRESOURCEA   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPSTR          *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumW(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetConnectionDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetConnectionDialog1W(
    IN OUT LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetDisconnectDialog1W(
    IN LPDISCDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetUseConnectionW(
    IN HWND            hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR        lpUserID,
    IN LPCWSTR        lpPassword,
    IN DWORD           dwFlags,
    OUT LPWSTR         lpAccessName,
    IN OUT LPDWORD     lpBufferSize,
    OUT LPDWORD        lpResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUserW(
    IN LPCWSTR  lpName,
    OUT LPWSTR   lpUserName,
    IN OUT LPDWORD   lpnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetConnectionW(
    IN LPCWSTR lpLocalName,
    OUT LPWSTR  lpRemoteName,
    IN OUT LPDWORD  lpnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceParentW(
    IN LPNETRESOURCEW lpNetResource,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpcbBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static    
DWORD
APIENTRY
WNetGetProviderNameW(
    IN DWORD   dwNetType,
    OUT LPWSTR lpProviderName,
    IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
MultinetGetConnectionPerformanceW(
    IN LPNETRESOURCEW lpNetResource,
    OUT LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetDisconnectDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetLastErrorW(
    OUT LPDWORD    lpError,
    OUT LPWSTR    lpErrorBuf,
    IN DWORD      nErrorBufSize,
    OUT LPWSTR    lpNameBuf,
    IN DWORD      nNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetLastErrorA(
     OUT LPDWORD    lpError,
     OUT LPSTR    lpErrorBuf,
     IN DWORD      nErrorBufSize,
     OUT LPSTR    lpNameBuf,
     IN DWORD      nNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetNetworkInformationA(
    LPCSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnectionW(
    IN HWND     hwndParent,
    IN LPCWSTR lpDevice
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnectionA(
    IN HWND     hwndParent,
    IN LPCSTR  lpDevice
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MultinetGetErrorTextW(
    OUT LPWSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPWSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetConnection3W(
     IN LPCWSTR lpLocalName,
     IN LPCWSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetFormatNetworkNameW(
    IN LPCWSTR  lpProvider,
    IN LPCWSTR  lpRemoteName,
    OUT LPWSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetProviderTypeW(
    IN  LPCWSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnection2W(
    IN  HWND     hwndParent,
    IN  LPCWSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetClearConnections(
    HWND hWnd
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetConnectionA (
    IN      LPCSTR   lpLocalName,
    OUT     LPSTR    lpRemoteName,
    IN OUT  LPDWORD  lpnLength
    )    
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumA(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE      lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mpr)
{
    DLPENTRY(MultinetGetConnectionPerformanceW)
    DLPENTRY(MultinetGetErrorTextW)
    DLPENTRY(WNetAddConnection2W)
    DLPENTRY(WNetAddConnection3W)
    DLPENTRY(WNetCancelConnection2W)
    DLPENTRY(WNetClearConnections)
    DLPENTRY(WNetCloseEnum)
    DLPENTRY(WNetConnectionDialog)
    DLPENTRY(WNetConnectionDialog1W)
    DLPENTRY(WNetDisconnectDialog)
    DLPENTRY(WNetDisconnectDialog1W)
    DLPENTRY(WNetEnumResourceW)
    DLPENTRY(WNetFormatNetworkNameW)
    DLPENTRY(WNetGetConnection3W)
    DLPENTRY(WNetGetConnectionA)
    DLPENTRY(WNetGetConnectionW)
    DLPENTRY(WNetGetLastErrorA)
    DLPENTRY(WNetGetLastErrorW)
    DLPENTRY(WNetGetNetworkInformationA)
    DLPENTRY(WNetGetNetworkInformationW)
    DLPENTRY(WNetGetProviderNameW)
    DLPENTRY(WNetGetProviderTypeW)
    DLPENTRY(WNetGetResourceInformationA)
    DLPENTRY(WNetGetResourceInformationW)
    DLPENTRY(WNetGetResourceParentW)
    DLPENTRY(WNetGetUniversalNameW)
    DLPENTRY(WNetGetUserW)
    DLPENTRY(WNetOpenEnumA)
    DLPENTRY(WNetOpenEnumW)
    DLPENTRY(WNetRestoreConnection2W)
    DLPENTRY(WNetRestoreConnectionA)
    DLPENTRY(WNetRestoreConnectionW)
    DLPENTRY(WNetUseConnectionW)
};

DEFINE_PROCNAME_MAP(mpr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\inc\makefile.inc ===
$(O)\atm.h: atm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\blberr.h: blberr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\g711uids.h: g711uids.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspaddr.h: mspaddr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspbase.h: mspbase.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspcall.h: mspcall.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspcoll.h: mspcoll.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspenum.h: mspenum.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msplog.h: msplog.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspstrm.h: mspstrm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspterm.h: mspterm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspthrd.h: mspthrd.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmac.h: msptrmac.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmar.h: msptrmar.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmvc.h: msptrmvc.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msputils.h: msputils.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndistapi.h: ndistapi.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndiswan.h: ndiswan.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\nettypes.h: nettypes.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qos.h: qos.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qosname.h: qosname.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qospol.h: qospol.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qossp.h: qossp.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rnderr.h: rnderr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\sdperr.h: sdperr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi.xc: tapi.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi.h: $(O)\tapi.xc
    hsplit -s -o $@ nul: $?

$(O)\tdi.h: tdi.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdiinfo.h: tdiinfo.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdikrnl.h: tdikrnl.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdistat.h: tdistat.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\traffic.h: traffic.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tspi.xc: tspi.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tspi.h: $(O)\tspi.xc
    hsplit -s -o $@ nul: $?

$(O)\tapiclnt.xc: tapiclnt.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapiclnt.h: $(O)\tapiclnt.xc
    hsplit -s -o $@ nul: $?

$(O)\viduids.h: viduids.w
   $(CLEANSE_PUBLISHED_HDR) $? $@


#
# http
#
$(O)\http.h $(O)\httpkrnl.h: http.w 
    hsplit -s -o $(O)\http.h $(O)\httpkrnl.h nul: $?

$(O)\httpp.h $(O)\httppkrnl.h: httpp.w 
    hsplit -s -o $(O)\httpp.h $(O)\httppkrnl.h nul: $?


#
# winnet
#
$(O)\winnet.wc : winnet.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\winnetwk.x $(O)\winnetp.x: $(O)\winnet.wc
    hsplit -e -o $(O)\winnetwk.x $(O)\winnetp.x $(O)\winnet.wc

$(O)\winnetp.h: $(O)\winnetp.x
    wcshdr < $? > $@

$(O)\winnetwk.h: $(O)\winnetwk.x
    wcshdr < $? > $@

all: $(DDK_INC_PATH)\ndis.h

$(DDK_INC_PATH)\ndis.h: $(O)\ndis.h
    $(PUBLISH_CMD) {$?=$@}

NDIS_DEPENDS = \
    $(DDK_INC_PATH)\netpnp.h          \
    ndismain.w       \
    ndisprot.w       \
    ndismac.w        \
    ndismini.w       \
    ndisco.w

$(O)\ndis.h: $(BASE_INC_PATH)\ndisbase.w $(NDIS_DEPENDS) makefile.inc
    copy $(BASE_INC_PATH)\ndisbase.w $@
    type << >> $@
//
// END INTERNAL DEFINITIONS
//
// The following definitions may be used by NDIS drivers, except as noted.
//

<<
    type $(DDK_INC_PATH)\netpnp.h >> $@
    type << >> $@

<<
    type ndismain.w >> $@
    type << >> $@

<<
    type ndisprot.w >> $@
    type << >> $@

//
// The following definitions are available only to full MAC drivers.  They
// must not be used by miniport drivers.
//

<<
    type ndismac.w >> $@
    type << >> $@

//
// The following definitions are available only to miniport drivers.  They
// must not be used by full MAC drivers.
//

#if defined(NDIS_MINIPORT_DRIVER) || defined(NDIS_WRAPPER)

<<
    type ndismini.w >> $@
    type << >> $@

#endif // defined(NDIS_MINIPORT_DRIVER) || defined(NDIS_WRAPPER)

#if defined(NDIS50) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT)
<<
    type ndisco.w >> $@
    type << >> $@

#endif // defined(NDIS50) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT)

#endif // _NDIS_
<<

$(O)\ndismain.h : ndismain.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndisprot.h : ndisprot.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndismac.h : ndismac.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndismini.h : ndismini.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndisco.h : ndisco.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

{$(O)}.h{$(PROJECT_ROOT)\inc\$(O)}.h:
   copy $< $@

$(PROJECT_ROOT)\inc\$(O)\tapip.h : tapi.x
    copy $? $@

$(PROJECT_ROOT)\inc\$(O)\tapclntp.h : tapiclnt.x
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\netshell.c ===
#include "netpch.h"
#pragma hdrstop

#include <setupapi.h>

static
HRESULT
WINAPI
HrGetAnswerFileParametersForNetCard(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszDeviceName,
    IN const GUID*  pguidNetCardInstance,
    OUT PWSTR* ppszwAnswerFile,
    OUT PWSTR* ppszwAnswerSections)
{
    return E_FAIL;
}

static
HRESULT
WINAPI
HrOemUpgrade(
    IN HKEY hkeyDriver,
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netshell)
{
    DLPENTRY(HrGetAnswerFileParametersForNetCard)
    DLPENTRY(HrOemUpgrade)
};

DEFINE_PROCNAME_MAP(netshell)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\netman.c ===
#include "netpch.h"
#pragma hdrstop

#include "netcon.h"

static
HRESULT
WINAPI
HrGetPnpDeviceStatus(
    const GUID* pguid,
    NETCON_STATUS *pStatus
    )
{
    return E_FAIL;
}

static
HRESULT
WINAPI
HrLanConnectionNameFromGuidOrPath(
    const GUID *pguid,
    LPCWSTR     pszwPath,
    LPWSTR      pszwName,
    LPDWORD     pcchMax
    )
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netman)
{
    DLPENTRY(HrGetPnpDeviceStatus)
    DLPENTRY(HrLanConnectionNameFromGuidOrPath)
};

DEFINE_PROCNAME_MAP(netman)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\sfmapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <macfile.h>

static
DWORD
AfpAdminConnect(
    IN  LPWSTR 		lpwsServerName,
    OUT PAFP_SERVER_HANDLE  phAfpServer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

VOID
AfpAdminDisconnect(
    IN AFP_SERVER_HANDLE hAfpServer
    )
{
}

static
DWORD
AfpAdminServerSetInfo(
    IN AFP_SERVER_HANDLE hAfpServer,
    IN LPBYTE            pAfpServerInfo,
    IN DWORD             dwParmNum
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(sfmapi)
{
    DLPENTRY(AfpAdminConnect)
    DLPENTRY(AfpAdminDisconnect)
    DLPENTRY(AfpAdminServerSetInfo)
};

DEFINE_PROCNAME_MAP(sfmapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\rasman.c ===
#include "netpch.h"
#pragma hdrstop

#include <rasapip.h>

static
DWORD
APIENTRY
RasReferenceRasman (
    BOOL fAttach
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasInitialize()
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasman)
{
    DLPENTRY(RasInitialize)
    DLPENTRY(RasReferenceRasman)
};

DEFINE_PROCNAME_MAP(rasman)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\tapi32.c ===
#include "netpch.h"
#pragma hdrstop

#include <tapi.h>

static
LONG
WINAPI
lineInitialize(
    LPHLINEAPP lphLineApp,  
    HINSTANCE hInstance,    
    LINECALLBACK lpfnCallback,  
    LPCSTR lpszAppName,     
    LPDWORD lpdwNumDevs
    )
{
    return LINEERR_NOMEM;
}

#undef lineTranslateAddress

static
LONG
WINAPI
lineTranslateAddress(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    LPCSTR lpszAddressIn,
    DWORD dwCard,
    DWORD dwTranslateOptions,
    LPLINETRANSLATEOUTPUT lpTranslateOutput
    )
{
    return LINEERR_NOMEM;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(tapi32)
{
    DLPENTRY(lineInitialize)
    DLPENTRY(lineTranslateAddress)
};

DEFINE_PROCNAME_MAP(tapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\rasdlg.c ===
#include "netpch.h"
#pragma hdrstop

#include <ras.h>
#include <rasdlg.h>
#include <rasuip.h>
#include <hnetcfg.h>

static
BOOL
APIENTRY
RasDialDlgW (
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPWSTR lpszPhoneNumber,
    LPRASDIALDLG lpInfo
    )
{
    lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    return FALSE;
}

static
BOOL
APIENTRY
RasEntryDlgW (
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPRASENTRYDLGW lpInfo
    )
{
    lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    return FALSE;
}

static
DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvCleanupService (
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvEnumConnections (
    IN OUT  LPRASSRVCONN    pRasSrvConn,    // Buffer of array of connections.
    IN      LPDWORD         pcb,            // size in bytes of buffer
    OUT     LPDWORD         pcConnections
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvHangupConnection (
    IN  HRASSRVCONN hRasSrvConn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvInitializeService (
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,            // The connection in question
    OUT BOOL*       pfConnected
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN BOOL  bEnable
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags)
{
    return ERROR_PROC_NOT_FOUND;
}



static
DWORD
APIENTRY
RasWizGetSuggestedEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizIsEntryRenamable(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizQueryMaxPageCount(
    IN  DWORD    dwRasWizType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizSetEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
APIENTRY
RasPhonebookDlgW(
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPRASPBDLGW lpInfo
    )
{
    if (lpInfo)
    {
        lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    }

    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasdlg)
{
    DLPENTRY(RasDialDlgW)
    DLPENTRY(RasEntryDlgW)
    DLPENTRY(RasPhonebookDlgW)
    DLPENTRY(RasSrvAddPropPages)
    DLPENTRY(RasSrvAddWizPages)
    DLPENTRY(RasSrvAllowConnectionsConfig)
    DLPENTRY(RasSrvCleanupService)
    DLPENTRY(RasSrvEnumConnections)
    DLPENTRY(RasSrvHangupConnection)
    DLPENTRY(RasSrvInitializeService)
    DLPENTRY(RasSrvIsConnectionConnected)
    DLPENTRY(RasSrvQueryShowIcon)
    DLPENTRY(RasUserEnableManualDial)
    DLPENTRY(RasUserGetManualDial)
    DLPENTRY(RasUserPrefsDlg)
    DLPENTRY(RasWizCreateNewEntry)
    DLPENTRY(RasWizGetNCCFlags)
    DLPENTRY(RasWizGetSuggestedEntryName)
    DLPENTRY(RasWizGetUserInputConnectionName)
    DLPENTRY(RasWizIsEntryRenamable)
    DLPENTRY(RasWizQueryMaxPageCount)
    DLPENTRY(RasWizSetEntryName)
};

DEFINE_PROCNAME_MAP(rasdlg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\rasapi32.c ===
#include "netpch.h"
#pragma hdrstop

#include <ras.h>
#include <rasapip.h>
#include <rasuip.h>


static
DWORD
APIENTRY
DwCloneEntry(
    IN      LPCWSTR lpwszPhonebookPath,
    IN      LPCWSTR lpwszSrcEntryName,
    IN      LPCWSTR lpwszDstEntryName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DwEnumEntryDetails(
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DwRasUninitialize()
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
RasConnectionNotificationW (
    HRASCONN hrasconn,
    HANDLE hEvent,
    DWORD dwfEvents
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasDeleteEntryW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasEnumConnectionsW (
    LPRASCONNW lprasconn,
    LPDWORD lpcb,
    LPDWORD lpcbConnections
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetConnectStatusW (
    HRASCONN hrasconn,
    LPRASCONNSTATUSW lprasconnstatus
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetConnectionStatistics (
    HRASCONN hRasConn,
    RAS_STATS *lpStatistics
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    LPRASENTRYW lpRasEntry,
    LPDWORD lpcbRasEntry,
    LPBYTE lpbDeviceConfig,
    LPDWORD lpcbDeviceConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetErrorStringW (
    IN  UINT  ResourceId,
    OUT LPWSTR lpszString,
    IN  DWORD InBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
RasGetProjectionInfoW(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetSubEntryHandleW (
    HRASCONN hrasconn,
    DWORD dwSubEntry,
    LPHRASCONN lphrasconn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetSubEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    DWORD dwSubEntry,
    LPRASSUBENTRYW lpRasSubEntry,
    LPDWORD lpcbRasSubEntry,
    LPBYTE lpbDeviceConfig,
    LPDWORD lpcbDeviceCnfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasHangUpW (
    HRASCONN hrasconn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasIsSharedConnection(
    IN LPRASSHARECONN   pConn,
    OUT PBOOL           pfShared
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasQueryLanConnTable(
    IN LPRASSHARECONN   pExcludedConn,
    OUT LPVOID*         ppvLanConnTable OPTIONAL, // NETCON_PROPERTIES
    OUT LPDWORD         pdwLanConnCount
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasRenameEntryW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSetEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    LPRASENTRYW lpRasEntry,
    DWORD dwcbRasEntry,
    LPBYTE lpbDeviceConfig,
    DWORD dwcbDeviceConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasShareConnection(
    IN LPRASSHARECONN   pConn,
    IN GUID*            pPrivateLanGuid OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUnshareConnection(
    OUT PBOOL           pfWasShared OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasValidateEntryNameW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasQuerySharedConnection(
    OUT LPRASSHARECONN  pConn
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasapi32)
{
    DLPENTRY(DwCloneEntry)
    DLPENTRY(DwEnumEntryDetails)
    DLPENTRY(DwRasUninitialize)
    DLPENTRY(RasConnectionNotificationW)
    DLPENTRY(RasDeleteEntryW)
    DLPENTRY(RasEnumConnectionsW)
    DLPENTRY(RasGetConnectStatusW)
    DLPENTRY(RasGetConnectionStatistics)
    DLPENTRY(RasGetEntryPropertiesW)
    DLPENTRY(RasGetErrorStringW)
    DLPENTRY(RasGetProjectionInfoW)
    DLPENTRY(RasGetSubEntryHandleW)
    DLPENTRY(RasGetSubEntryPropertiesW)
    DLPENTRY(RasHangUpW)
    DLPENTRY(RasIsSharedConnection)
    DLPENTRY(RasQueryLanConnTable)
    DLPENTRY(RasQuerySharedConnection)
    DLPENTRY(RasRenameEntryW)
    DLPENTRY(RasSetEntryPropertiesW)
    DLPENTRY(RasShareConnection)
    DLPENTRY(RasUnshareConnection)
    DLPENTRY(RasValidateEntryNameW)
};

DEFINE_PROCNAME_MAP(rasapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\rtutils.c ===
#include "netpch.h"
#pragma hdrstop

#include <rtutils.h>

static
VOID
APIENTRY
RouterLogDeregisterW(
    HANDLE hLogHandle
    )
{
}

static
VOID
APIENTRY
RouterLogEventW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    )
{
}

static
HANDLE
APIENTRY
RouterLogRegisterW(
    LPCWSTR lpszSource
    )
{
    return NULL;
}

static
DWORD
APIENTRY
TraceDeregisterW(
    IN  DWORD       dwTraceID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceRegisterExW(
    IN  LPCWSTR     lpszCallerName,
    IN  DWORD       dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceVprintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  va_list     arglist
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceVprintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  va_list     arglist
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rtutils)
{
    DLPENTRY(RouterLogDeregisterW)
    DLPENTRY(RouterLogEventW)
    DLPENTRY(RouterLogRegisterW)
    DLPENTRY(TraceDeregisterW)
    DLPENTRY(TraceRegisterExW)
    DLPENTRY(TraceVprintfExA)
    DLPENTRY(TraceVprintfExW)
};

DEFINE_PROCNAME_MAP(rtutils)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\wzcdlg.c ===
#include "netpch.h"
#pragma hdrstop

#include <netcon.h>
#include <wzcdlg.h>

static
HRESULT
WZCCanShowBalloon (
        IN const GUID * pGUIDConn,
        IN const PCWSTR pszConnectionName,
        IN OUT   BSTR * pszBalloonText,
        IN OUT   BSTR * pszCookie
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WZCOnBalloonClick (
        IN const GUID * pGUIDConn,
        IN const BSTR pszConnectionName,
        IN const BSTR szCookie
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WZCQueryConnectionStatusText (
        IN const GUID *  pGUIDConn,
        IN const NETCON_STATUS ncs,
        IN OUT BSTR *  pszStatusText
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wzcdlg)
{
    DLPENTRY(WZCCanShowBalloon)
    DLPENTRY(WZCOnBalloonClick)
    DLPENTRY(WZCQueryConnectionStatusText)
};

DEFINE_PROCNAME_MAP(wzcdlg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\ws2_32.c ===
#include "netpch.h"
#pragma hdrstop

#define WINSOCK_API_LINKAGE
#include <ws2spi.h>

#define SWAP_LONG(l)                                \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

#define WS_SWAP_SHORT(s)                            \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )


static
WINSOCK_API_LINKAGE
int
WSAAPI
getpeername(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    )
{
    return SOCKET_ERROR;
}


static
WINSOCK_API_LINKAGE
int
WSAAPI
WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR             lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSACleanup(
    void
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
int
WSAAPI
WSAEnumProtocolsW(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSAEventSelect(
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSAGetLastError(
    void
    )
{
    return ERROR_MOD_NOT_FOUND;
}

static
WINSOCK_API_LINKAGE
int
WSAAPI
WSAIoctl(
    IN SOCKET s,
    IN DWORD dwIoControlCode,
    IN LPVOID lpvInBuffer,
    IN DWORD cbInBuffer,
    OUT LPVOID lpvOutBuffer,
    IN DWORD cbOutBuffer,
    OUT LPDWORD lpcbBytesReturned,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSALookupServiceEnd(
    IN HANDLE  hLookup
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
int
WSAAPI
WSASend(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
SOCKET
WSAAPI
WSASocketW(
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags
    )
{
    return INVALID_SOCKET;
}

static
int
WSAAPI
WSAStartup(
    IN WORD wVersionRequested,
    OUT LPWSADATA lpWSAData
    )
{
    return WSAEFAULT;
}

static
int
WSAAPI
WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCDeinstallProvider(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCDeinstallProvider32(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCEnumProtocols(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCInstallNameSpace (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCInstallNameSpace32 (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCInstallProvider(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCInstallProvider64_32(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCUnInstallNameSpace (
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCUnInstallNameSpace32 (
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
bind(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
connect(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
closesocket(
    IN SOCKET s
    )
{
    return SOCKET_ERROR;
}

static
struct hostent FAR *
WSAAPI
gethostbyname(
    IN const char FAR * name
    )
{
    return NULL;
}

static
int
WSAAPI
getsockname(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    OUT int FAR * namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
getsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR * optlen
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
u_long
WSAAPI
htonl(
    IN u_long hostlong
    )
{
    return SWAP_LONG( hostlong );
}

static
WINSOCK_API_LINKAGE
u_short
WSAAPI
htons(
    IN u_short hostshort
    )
{
    return WS_SWAP_SHORT( hostshort );
}

static
unsigned long
WSAAPI
inet_addr(
    IN const char FAR * cp
    )
{
    return INADDR_NONE;
}

static
char FAR *
WSAAPI
inet_ntoa(
    IN struct in_addr in
    )
{
    return NULL;
}

static
u_long
WSAAPI
ntohl(
    IN u_long netlong
    )
{
    return SWAP_LONG( netlong );
}

static
WINSOCK_API_LINKAGE
u_short
WSAAPI
ntohs(
    IN u_short netshort
    )
{
    return WS_SWAP_SHORT( netshort );
}

static
WINSOCK_API_LINKAGE
int
WSAAPI
recv(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
int
WSAAPI
select(
    IN int nfds,
    IN OUT fd_set FAR * readfds,
    IN OUT fd_set FAR * writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR * timeout
    )
{
    return SOCKET_ERROR;
}

static
SOCKET
WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol
    )
{
    return INVALID_SOCKET;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(ws2_32)
{
    DLOENTRY(  2, bind)
    DLOENTRY(  3, closesocket)
    DLOENTRY(  4, connect)
    DLOENTRY(  5, getpeername)
    DLOENTRY(  6, getsockname)
    DLOENTRY(  7, getsockopt)
    DLOENTRY(  8, htonl)
    DLOENTRY(  9, htons)
    DLOENTRY( 11, inet_addr)
    DLOENTRY( 12, inet_ntoa)
    DLOENTRY( 14, ntohl)
    DLOENTRY( 15, ntohs)
    DLOENTRY( 16, recv)
    DLOENTRY( 18, select)
    DLOENTRY( 23, socket)
    DLOENTRY( 52, gethostbyname)
    DLOENTRY(111, WSAGetLastError)
    DLOENTRY(115, WSAStartup)
    DLOENTRY(116, WSACleanup)
};

DEFINE_ORDINAL_MAP(ws2_32);

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ws2_32)
{
    DLPENTRY(WSAAddressToStringA)
    DLPENTRY(WSAAddressToStringW)
    DLPENTRY(WSAEnumProtocolsW)
    DLPENTRY(WSAEventSelect)
    DLPENTRY(WSAIoctl)
    DLPENTRY(WSALookupServiceBeginW)
    DLPENTRY(WSALookupServiceEnd)
    DLPENTRY(WSALookupServiceNextW)
    DLPENTRY(WSASend)
    DLPENTRY(WSASocketW)
    DLPENTRY(WSAStartup)
    DLPENTRY(WSAStringToAddressW)
    DLPENTRY(WSCDeinstallProvider)
    DLPENTRY(WSCDeinstallProvider32)
    DLPENTRY(WSCEnumProtocols)
    DLPENTRY(WSCInstallNameSpace)
    DLPENTRY(WSCInstallNameSpace32)
    DLPENTRY(WSCInstallProvider)
    DLPENTRY(WSCInstallProvider64_32)
    DLPENTRY(WSCUnInstallNameSpace)
    DLPENTRY(WSCUnInstallNameSpace32)
};

DEFINE_PROCNAME_MAP(ws2_32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\dload\wzcsapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <wzcsapi.h>

static
DTLLIST*
ReadEapcfgList(DWORD dwFlags)
{
    return NULL;
}

static
VOID
DtlDestroyList (
    IN OUT DTLLIST* pdtllist,
    IN     PDESTROYNODE pfuncDestroyNode)
{
}

static
VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode)
{
}

static
DWORD
WZCEapolGetCustomAuthData (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  DWORD dwEapTypeId,
    IN  DWORD dwSizeOfSSID,
    IN  BYTE *pbSSID,
    IN OUT PBYTE pbConnInfo,
    IN OUT PDWORD pdwInfoSize)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolSetCustomAuthData (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  DWORD dwEapTypeId,
    IN  DWORD dwSizeOfSSID,
    IN  BYTE *pbSSID,
    IN  PBYTE pbConnInfo,
    IN  DWORD dwInfoSize)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolGetInterfaceParams (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN OUT EAPOL_INTF_PARAMS *pIntfParams
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCRefreshInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCSetInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
WZCDeleteIntfObj(
    PINTF_ENTRY pIntf)
{
}

static
DWORD
WZCQueryInterface(
    LPWSTR pSrvAddr,
    DWORD dwInFlags,
    PINTF_ENTRY pIntf,
    LPDWORD pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolSetInterfaceParams (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  EAPOL_INTF_PARAMS *pIntfParams)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey)
{
    return NULL;
}

static
PVOID
MIDL_user_allocate(size_t NumBytes)
{
    return NULL;
}

static
VOID
MIDL_user_free(void * MemPointer)
{
}

static
DWORD
WZCEapolReAuthenticate (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolQueryState (
    IN  LPWSTR              pSrvAddr,
    IN  PWCHAR              pwszGuid,
    IN OUT EAPOL_INTF_STATE *pIntfState
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(wzcsapi)
{
    DLOENTRY(60, MIDL_user_allocate)
    DLOENTRY(61, MIDL_user_free)
};

DEFINE_ORDINAL_MAP(wzcsapi)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wzcsapi)
{
    DLPENTRY(DestroyEapcfgNode)
    DLPENTRY(DtlDestroyList)
    DLPENTRY(EapcfgNodeFromKey)
    DLPENTRY(ReadEapcfgList)
    DLPENTRY(WZCDeleteIntfObj)
    DLPENTRY(WZCEapolGetCustomAuthData)
    DLPENTRY(WZCEapolGetInterfaceParams)
    DLPENTRY(WZCEapolQueryState)
    DLPENTRY(WZCEapolReAuthenticate)
    DLPENTRY(WZCEapolSetCustomAuthData)
    DLPENTRY(WZCEapolSetInterfaceParams)
    DLPENTRY(WZCQueryInterface)
    DLPENTRY(WZCRefreshInterface)
    DLPENTRY(WZCSetInterface)
};

DEFINE_PROCNAME_MAP(wzcsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\unixapis\getlogin.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getlogin.c

Abstract:

    Emulates the Unix getlogin routine. Used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       10-31-91     modified getpass to not echo input

Notes:

    Exports:

    getlogin

--*/
#include <stdio.h>
#include <windef.h>
#include <winbase.h>


int
getlogin(
    OUT char *UserName,
    IN  int   len
    )
{

    DWORD llen = len;

    if (!GetUserNameA(UserName, &llen)) {
        return(-1);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\nls\nls.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nls.c

Abstract:

    This module contains functions needed for the internationalisation
    of the TCP/IP utilities.

Author:

    Ronald Meijer (ronaldm)	  Nov 8, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    ronaldm	11-8-92	    created

Notes:

--*/

#include <io.h>
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <winuser.h>

#include <nls.h>

// see comment in nls.h
//
HMODULE NlsMsgSourcemModuleHandle = NULL;

/***	NlsPutMsg - Print a message to a handle
 *
 *  Purpose:
 *	PutMsg takes the given message number from the
 *	message table resource, and displays it on the requested
 *	handle with the given parameters (optional)
 *
 *   UINT PutMsg(UINT Handle, UINT MsgNum, ... )
 *
 *  Args:
 *	Handle		- the handle to print to
 *	MsgNum		- the number of the message to print
 *	Arg1 [Arg2...]	- additonal arguments for the message as necessary
 *
 *  Returns:
 *	The number of characters printed.
 *
 */

UINT 
NlsPutMsg (
    IN UINT Handle, 
    IN UINT MsgNumber, 
    IN ...)
{
    UINT msglen;
    VOID * vp;
    va_list arglist;
    DWORD StrLen;

    va_start(arglist, MsgNumber);
    if (!(msglen = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NlsMsgSourcemModuleHandle,
            MsgNumber,
            0L,		// Default country ID.
            (LPTSTR)&vp,
            0,
            &arglist)))
    {
	    return 0;
    }

    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return msglen;
}

/***	NlsPerror - NLS compliant version of perror()
 *
 *  Purpose:
 *	NlsPerror takes a messagetable resource ID code, and an error
 *	value (This function replaces perror()), loads the string
 *	from the resource, and passes it with the error code to s_perror()
 *
 *   void NlsPerror(UINT usMsgNum, int nError)
 *
 *  Args:
 *
 *	usMsgNum	    The message ID
 *	nError		    Typically returned from GetLastError()
 *
 *  Returns:
 *	Nothing.
 *
 */
    extern void s_perror(
            char *yourmsg,  // your message to be displayed
            int  lerrno     // errno to be converted
            );
VOID 
NlsPerror (
    IN UINT usMsgNum, 
    IN INT nError)
{
    VOID * vp;
    UINT msglen;

    if (!(msglen = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
		    NlsMsgSourcemModuleHandle,
		    usMsgNum,
		    0L,		// Default country ID.
		    (LPTSTR)&vp,
		    0,
		    NULL)))
    {
	    return;
    }

    s_perror(vp, nError);
    LocalFree(vp);
}

UINT 
NlsSPrintf ( 
    IN UINT usMsgNum,
    OUT char* pszBuffer,
    IN DWORD cbSize,
    IN ...)
/*++
    Prints the given message into the buffer supplied.

    Arguments:
        usMsgNum        message number for resource string.
        pszBuffer       buffer into which we need to print the string
        cbSize          size of buffer
        ...             optional arguments

    Returns:
        Size of the message printed.

    History:
       MuraliK   10-19-94
--*/
{
    UINT msglen;

    va_list arglist;
    
    va_start(arglist, cbSize);
    
    msglen = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                NlsMsgSourcemModuleHandle,
                usMsgNum,
                0L,
                (LPTSTR) pszBuffer,
                cbSize,
                &arglist);

    va_end(arglist);
    return msglen; 
}

/***	ConvertArgvToOem
 *
 *  Purpose:
 *	Convert all the command line arguments from Ansi to Oem.
 *
 *  Args:
 *
 *	argc		    Argument count
 *	argv[]		    Array of command-line arguments
 *
 *  Returns:
 *	Nothing.
 *
 *  
 */

VOID
ConvertArgvToOem(
    int argc,
    char* argv[]
    )
{
#if 0
    Bug 84807.  Removed workaround of needing to convert args to Oem by placing
                conversion immediately before dumping.
    
    int i;

    for (i=1; i<argc; ++i)
	CharToOemA(argv[i], argv[i]);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\unixapis\getopt.c ===
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <nls.h>
#include "nlstxt.h"

char *  optarg;
int     optind = 1;
int     optinx = 1;
int     opterr;

int
getopt(
    int     ac,
    char *  av[],
    char *  opts_allowed)
{
    char        option;
    static char NoOpt[] = "";

    optarg = NoOpt;

    if (optind >= ac)
        return(-1);

    if (*av[optind] != '-')
        return(-1);

    option = av[optind][optinx];
    while ((*opts_allowed ) && (*opts_allowed != option))
        opts_allowed ++;

    if (!*opts_allowed)
        {
        NlsPutMsg(STDOUT, LIBUEMUL_OPTION_INVALID, option);
        return((int) '?');
        }

    if ( *(opts_allowed + 1) == ':')   // there's an argument
        {
        if (av[optind][optinx+1] == '\0') // the argument is in the next av[]
            {
            optind++;
            optinx = 1;
            optarg = av[optind];
            }
        else
            {
            optarg = &av[optind][optinx+1];
            }
    	if (optarg == NULL)
    	    {
            NlsPutMsg(STDOUT, LIBUEMUL_OPTION_MORE_ARGS, option);
    	    optarg = NoOpt;
    	    return((int) '?');
    	    }
        optind++;
        optinx = 1;
        }
    else
        {
        if (av[optind][optinx+1] == '\0') // no more args for this -
            {
            optind++;
            optinx = 1;
            }
        else                              // more args for this -
            {
            optinx++;
            }
        }

    return((int) option);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\unixapis\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc
    copy $? $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\uuid\hnclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       H N C L S I D . C
//
//  Contents:   HNetCfg & HNetBcon class IDs
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//  History:    rgatta 16 August 2000
//              (added CLSID_InternetConnectionBeaconService)
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

//
// GUIDs reserved for our use
//
// 46C166AA-3108-11D4-9348-00C04F8EEB71     CLSID_HNetCfgMgr
// 46C166AB-3108-11D4-9348-00C04F8EEB71     CLSID_NetSharingManager
// 46C166AC-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPublicConnection
// 46C166AD-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPrivateConnection
// 46C166AE-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumApplicationDefinition
// 46C166AF-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPortMapping
// 46C166B0-3108-11D4-9348-00C04F8EEB71     CLSID_NetSharingApplicationDefinition
// 46C166B1-3108-11D4-9348-00C04F8EEB71		CLSID_NetSharingConfiguration
// 46C166B2-3108-11D4-9348-00C04F8EEB71
// 46C166B3-3108-11D4-9348-00C04F8EEB71
// 46C166B4-3108-11D4-9348-00C04F8EEB71
// 46C166B5-3108-11D4-9348-00C04F8EEB71
// 46C166B6-3108-11D4-9348-00C04F8EEB71
// 46C166B7-3108-11D4-9348-00C04F8EEB71
// 46C166B8-3108-11D4-9348-00C04F8EEB71
// 46C166B9-3108-11D4-9348-00C04F8EEB71
// 46C166BA-3108-11D4-9348-00C04F8EEB71
// 46C166BB-3108-11D4-9348-00C04F8EEB71
// 46C166BC-3108-11D4-9348-00C04F8EEB71
// 46C166BD-3108-11D4-9348-00C04F8EEB71

DEFINE_GUID(CLSID_HNetCfgMgr, 0x46C166AA,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);



// 04df613a-5610-11d4-9ec8-00b0d022dd1f     CLSID_InternetConnectionBeaconService

DEFINE_GUID(CLSID_InternetConnectionBeaconService, 0x04df613a,0x5610,0x11d4,0x9e,0xc8,0x00,0xb0,0xd0,0x22,0xdd,0x1f);

// {9A8EA3B5-572E-4cb3-9EB9-EC689AC575AE}   CLSID_HomeNetAutoConfigService 
DEFINE_GUID(CLSID_HomeNetAutoConfigService, 0x9a8ea3b5, 0x572e, 0x4cb3, 0x9e, 0xb9, 0xec, 0x68, 0x9a, 0xc5, 0x75, 0xae);

// {46C166AB-3108-11D4-9348-00C04F8EEB71}   CLSID_NetSharingManager
//DEFINE_GUID(CLSID_NetSharingManager, 0x46C166AB,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);
// bhanlon: 1/19/01:  I'm commenting this out because (we think) that
// the netcon.idl, which now uses the "coclass" keyword, and the netshell
// component was getting "one or more multiply defined symbols found" errors.
// Commenting out this line seems to help.

// 46C166AC-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPublicConnection
DEFINE_GUID(CLSID_SharingManagerEnumPublicConnection, 0x46C166AC,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AD-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPrivateConnection
DEFINE_GUID(CLSID_SharingManagerEnumPrivateConnection, 0x46C166AD,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AE-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumApplicationDefinition
DEFINE_GUID(CLSID_SharingManagerEnumApplicationDefinition, 0x46C166AE,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AF-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPortMapping
DEFINE_GUID(CLSID_SharingManagerEnumPortMapping, 0x46C166AF,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166B0-3108-11D4-9348-00C04F8EEB71		CLSID_SharingApplicationDefinition
DEFINE_GUID(CLSID_SharingApplicationDefinition, 0x46C166B0,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166B1-3108-11D4-9348-00C04F8EEB71		CLSID_SharingConfiguration
DEFINE_GUID(CLSID_SharingConfiguration, 0x46C166B1,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\unixapis\getpass.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getpass.c

Abstract:

    Emulates the Unix getpass routine. Used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       10-31-91     modified getpass to not echo input

Notes:

    Exports:

    getpass

--*/

#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <nls.h>
#include <winuser.h>
#include "nlstxt.h"

#define MAXPASSLEN 32

static char     pbuf[MAXPASSLEN+1];

/******************************************************************/
char *
getpass(
    char *prompt
    )
/******************************************************************/
{
    HANDLE          InHandle = (HANDLE)-1, OutHandle = (HANDLE)-1;
    unsigned long   SaveMode, NewMode;
    BOOL            Result;
    DWORD           NumBytes;
    int             i;

    pbuf[0] = 0;

    InHandle = CreateFile("CONIN$",
                          GENERIC_READ | GENERIC_WRITE,
			              FILE_SHARE_READ | FILE_SHARE_WRITE,
			              NULL,
			              OPEN_EXISTING,
			              FILE_ATTRIBUTE_NORMAL,
			              NULL
			             );

    if (InHandle == (HANDLE)-1) {
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_GETTING_CI_HANDLE, GetLastError());
        goto exit_getpass;
    }

    OutHandle = CreateFile("CONOUT$",
                          GENERIC_WRITE,
			              FILE_SHARE_READ | FILE_SHARE_WRITE,
			              NULL,
			              OPEN_EXISTING,
			              FILE_ATTRIBUTE_NORMAL,
			              NULL
			             );

    if (OutHandle == (HANDLE)-1) {
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_GETTING_CO_HANDLE,GetLastError());
        goto exit_getpass;
    }

    Result = GetConsoleMode(InHandle, &SaveMode);

    if (!Result) {
        NlsPutMsg(STDOUT,LIBUEMUL_ERROR_GETTING_CON_MODE, GetLastError());
        goto exit_getpass;
    }

    NewMode = SaveMode & ~ENABLE_ECHO_INPUT;

    Result = SetConsoleMode(InHandle, NewMode);

    if (!Result) {
        NlsPutMsg(STDOUT,LIBUEMUL_ERROR_SETTING_CON_MODE, GetLastError());
        goto exit_getpass;
    }

    NumBytes = strlen (prompt);

    CharToOemBuff (prompt, prompt, NumBytes);

    Result = WriteFile(OutHandle,
                       prompt,
                       NumBytes,
                       &NumBytes,
                       NULL);
    if (!Result) {
        NlsPutMsg(STDOUT,LIBUEMUL_WRITE_TO_CONSOLEOUT_ERROR, GetLastError());
        SetConsoleMode(InHandle, SaveMode);
        goto exit_getpass;
    }

    Result = ReadFile(InHandle,
                      pbuf,
                      MAXPASSLEN,
                      &NumBytes,
                      NULL);
    if (!Result)
        NlsPutMsg(STDOUT,LIBUEMUL_READ_FROM_CONSOLEIN_ERROR, GetLastError());
    else
        pbuf[MAXPASSLEN] = '\0';

    OemToCharBuff (pbuf, pbuf, NumBytes);

    // peel off linefeed
    i =  (int) NumBytes;
    while(--i >= 0)
        if ((pbuf[i] == '\n') || (pbuf[i] == '\r'))
            pbuf[i] = '\0';

    Result = SetConsoleMode(InHandle, SaveMode);
    if (!Result)
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_RESTORING_CONSOLE_MODE, GetLastError());

    WriteFile(OutHandle,
              "\n",
              1,
              &NumBytes,
              NULL);

exit_getpass :

    if (InHandle != (HANDLE)-1)
        CloseHandle(InHandle);
    if (OutHandle != (HANDLE) -1)
        CloseHandle(OutHandle);
	
    return(pbuf);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\lib\unixapis\getuname.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getuname.c

Abstract:

    Provides a function to prompt the user for a username similar to getpass
    for passwords.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     03-25-92     created by cloning getpass.c

Notes:

    Exports:

    getuname

--*/

#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <winuser.h>
#include <nls.h>
#include "nlstxt.h"

#define MAXUSERNAMELEN 32

static char     ubuf[MAXUSERNAMELEN+1];

/******************************************************************/
char *
getusername(
    char *prompt
    )
/******************************************************************/
{
    HANDLE          InHandle = (HANDLE)-1, OutHandle = (HANDLE)-1;
    BOOL            Result;
    DWORD           NumBytes;
    int             i;

    ubuf[0] = '\0';

    InHandle = CreateFile("CONIN$",
                          GENERIC_READ | GENERIC_WRITE,
			              FILE_SHARE_READ | FILE_SHARE_WRITE,
			              NULL,
			              OPEN_EXISTING,
			              FILE_ATTRIBUTE_NORMAL,
			              NULL
			             );
    if (InHandle == (HANDLE)-1) {
        NlsPutMsg(STDERR,LIBUEMUL_ERROR_GETTING_CI_HANDLE,GetLastError());
        goto exit_getusername;
    }

    OutHandle = CreateFile("CONOUT$",
                          GENERIC_WRITE,
			              FILE_SHARE_READ | FILE_SHARE_WRITE,
			              NULL,
			              OPEN_EXISTING,
			              FILE_ATTRIBUTE_NORMAL,
			              NULL
			             );
    if (OutHandle == (HANDLE)-1) {
        NlsPutMsg(STDERR,LIBUEMUL_ERROR_GETTING_CO_HANDLE,GetLastError());
        goto exit_getusername;
    }

    NumBytes = strlen(prompt);

    CharToOemBuff(prompt, prompt, NumBytes);

    Result = WriteFile(OutHandle,
                       prompt,
                       NumBytes,
                       &NumBytes,
                       NULL);
    if (!Result) {
        NlsPutMsg(STDERR,LIBUEMUL_WRITE_TO_CONSOLEOUT_ERROR, GetLastError());
        goto exit_getusername;
    }

    Result = ReadFile(InHandle,
                      ubuf,
                      MAXUSERNAMELEN,
                      &NumBytes,
                      NULL);
    if (!Result)
        NlsPutMsg(STDERR,LIBUEMUL_READ_FROM_CONSOLEIN_ERROR, GetLastError());
    ubuf[MAXUSERNAMELEN] = '\0';

    OemToCharBuff (ubuf, ubuf, NumBytes);

    // peel off linefeed
    i =  (int) NumBytes;
    while(--i >= 0)
        if ((ubuf[i] == '\n') || (ubuf[i] == '\r'))
            ubuf[i] = '\0';
	
exit_getusername :
    
    if (InHandle != (HANDLE)-1)
        CloseHandle(InHandle);
    if (OutHandle != (HANDLE)-1)
        CloseHandle(OutHandle);

    return(ubuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\uuid\ndisguid.c ===
#define INITGUID
#include <guiddef.h>

#include <ndisguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\uuid\ncclsid.c ===
#define INITGUID
#include <guiddef.h>

DEFINE_GUID(CLSID_CNetCfg,                  0x5B035261,0x40F9,0x11D1,0xAA,0xEC,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionCommonUi,       0x7007ACD1,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_ConnectionManager,        0xBA126AD1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionManager2,       0xBA126AE5,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_LanConnectionManager,     0xBA126AD3,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetConnectionUiUtilities, 0x7007ACD3,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_EAPOLManager,             0xBA126AE4,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetConnectionHNetUtil,    0xBA126AE3,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(GUID_NETSHELL_PROPS,            0x2d15a9a1,0xa556,0x4189,0x91,0xad,0x02,0x74,0x58,0xf1,0x1a,0x07);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\published\uuid\tapi3iid.c ===
//
// TAPI3IID.c
//
//  Description: CPP file instanciating the TAPI3 IIDs
//
//

#define INITGUID
#include <guiddef.h>

//
// TERMINAL CLASSES
//
    
//
// Video Window Terminal Class descriptor
// {F7438990-D6EB-11d0-82A6-00AA00B5CA1B}
//
const CLSID __declspec(selectany) CLSID_VideoWindowTerm = 
{ 0xf7438990, 0xd6eb, 0x11d0, { 0x82, 0xa6, 0x0, 0xaa, 0x0, 0xb5, 0xca, 0x1b } };

// {AAF578EC-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_VideoInputTerminal = 
{ 0xaaf578ec, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EB-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_HandsetTerminal = 
{ 0xaaf578eb, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578ED-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_HeadsetTerminal = 
{ 0xaaf578ed, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EE-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_SpeakerphoneTerminal = 
{ 0xaaf578ee, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EF-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_MicrophoneTerminal = 
{ 0xaaf578ef, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {E2F7AEF7-4971-11D1-A671-006097C9A2E8}
const CLSID __declspec(selectany) CLSID_MediaStreamTerminal = 
{ 0xE2F7AEF7, 0x4971, 0x11D1, { 0xA6, 0x71, 0x0, 0x60, 0x97, 0xC9, 0xA2, 0xE8 } };

// {8EBAE7A3-8943-11d1-96B8-00C04FB6E866}
const GUID __declspec(selectany) CLSID_BridgeTerminal = 
{ 0x8ebae7a3, 0x8943, 0x11d1, { 0x96, 0xb8, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66 } };


// {AAF578F0-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_SpeakersTerminal = 
{ 0xaaf578f0, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578F1-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_FileTerminal = 
{ 0xaaf578f1, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {521F3D06-C3D0-4511-8617-86B9A783DA77}
const CLSID __declspec(selectany) CLSID_FileRecordingTerminal = 
{ 0x521F3D06, 0xC3D0, 0x4511, {0x86, 0x17, 0x86, 0xB9, 0xA7, 0x83, 0xDA, 0x77 } };

// {BF14A2E4-E88B-4ef5-9740-5AC5D022F8C9}
const CLSID __declspec(selectany) CLSID_FileRecordingTrack =  
{ 0xbf14a2e4, 0xe88b, 0x4ef5, { 0x97, 0x40, 0x5a, 0xc5, 0xd0, 0x22, 0xf8, 0xc9 } };

// {0CB9914C-79CD-47dc-ADB0-327F47CEFB20}
const CLSID __declspec(selectany) CLSID_FilePlaybackTerminal =  
{ 0x0CB9914C, 0x79CD, 0x47dc, { 0xAD, 0xB0, 0x32, 0x7F, 0x47, 0xCE, 0xFB, 0x20 } };

//
// MEDIATYPES
//

// {028ED8C2-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_Audio =
{ 0x28ed8c2, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C4-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_Video =
{ 0x28ed8c4, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C6-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_DataModem =
{ 0x28ed8c6, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C7-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_G3Fax =
{ 0x28ed8c7, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };


// {831CE2D6-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_PSTN = 
{ 0x831ce2d6, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {831CE2D7-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_H323 = 
{ 0x831ce2d7, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {831CE2D8-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_Multicast = 
{ 0x831ce2d8, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\inc\ntddgpc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntddgpc.h

Abstract:

    defines that are exported to user mode

Author:

    Ofer Bar (oferbar) 23-May-1997

Revision History:

--*/

#ifndef _NTDDGPC_
#define _NTDDGPC_


typedef struct _PROTOCOL_STAT {

    ULONG          CreatedSp;
    ULONG          DeletedSp;
    ULONG          RejectedSp;
    ULONG          CurrentSp;

    ULONG          CreatedGp;
    ULONG          DeletedGp;
    ULONG          RejectedGp;
    ULONG          CurrentGp;

    ULONG          CreatedAp;
    ULONG          DeletedAp;
    ULONG          RejectedAp;
    ULONG          CurrentAp;

    ULONG          ClassificationRequests;
    ULONG          PatternsClassified;
    ULONG          PacketsClassified;

    ULONG		   DerefPattern2Zero;
    ULONG		   FirstFragsCount;
    ULONG          LastFragsCount;
    
    ULONG		   InsertedPH;
    ULONG		   RemovedPH;

    ULONG		   InsertedRz;
    ULONG		   RemovedRz;

    ULONG		   InsertedCH;
    ULONG		   RemovedCH;

} PROTOCOL_STAT, *PPROTOCOL_STAT;

typedef struct _CF_STAT {

    ULONG          CreatedBlobs;
    ULONG          ModifiedBlobs;
    ULONG          DeletedBlobs;
    ULONG          RejectedBlobs;
    ULONG          CurrentBlobs;
    ULONG		   DerefBlobs2Zero;

} CF_STAT, *PCF_STAT;


//
// GPC stats
//
typedef struct _GPC_STATS {

    ULONG          CreatedCf;
    ULONG          DeletedCf;
    ULONG          RejectedCf;
    ULONG          CurrentCf;

    ULONG		   InsertedHF;
    ULONG		   RemovedHF;

    CF_STAT		   CfStat[GPC_CF_MAX];
    PROTOCOL_STAT  ProtocolStat[GPC_PROTOCOL_TEMPLATE_MAX];

} GPC_STAT, *PGPC_STAT;



//
// CF data struct
//
typedef struct _CF_DATA {

    ULONG          CfId;
    ULONG          NumberOfClients;
    ULONG          Flags;
    ULONG          NumberOfPriorities;
    
} CF_DATA, *PCF_DATA;


//
// blob data struct
//
typedef struct _BLOB_DATA {

    ULONG          CfId;
    ULONG          BlobId;
    ULONG          ByteCount;
    CHAR           Data[1];
    
} BLOB_DATA, *PBLOB_DATA;


//
// specific pattern data struct
//
typedef struct _SP_DATA {

    ULONG          BlobId;
    CHAR           Pattern[1];

} SP_DATA, *PSP_DATA;


//
// generic pattern data struct
//
typedef struct _GP_DATA {

    ULONG          CfId;
    ULONG          Priority;
    ULONG          BlobId;
    CHAR           Pattern[1];
    //   Mask is following here
    
} GP_DATA, *PGP_DATA;

//
// the big output buffer
//

typedef struct _GPC_OUTPUT_BUFFER {

    ULONG          Version;

    //
    // statistics until now
    //

    GPC_STAT       Stats;

    //
    // number of elements in this report
    //

    ULONG          NumberOfCf;
    ULONG          NumberOfBlobs;
    ULONG          NumberOfSp;
    ULONG          NumberOfGp;
    CHAR           Data[1];

    //
    // order of data:
    //  CF_DATA
    //  BLOB_DATA
    //  SP_DATA
    //  GP_DATA
    //

} GPC_OUTPUT_BUFFER, *PGPC_OUTPUT_BUFFER;


typedef struct _GPC_INPUT_BUFFER {

    ULONG          Version;
    ULONG          ProtocolTemplateId;
    ULONG          Cf;                 // which CF or (-1) for all
    ULONG          BlobCount;          // (-1) for all
    ULONG          PatternCount;       // (-1) for all

} GPC_INPUT_BUFFER, *PGPC_INPUT_BUFFER;


/* Prototypes */
/* End Prototypes */

#endif /* _NTDDGPC_ */

/* end ntddgpc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcdbg.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmain.c

Abstract:

    This file contains initialization stuff for the GPC

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"




#if DBG

ULONG	DebugFlags = PATTERN | RHIZOME 
                     | LOCKS | CLASSIFY
					 | BLOB | MEMORY | IOCTL 
                     | CLIENT | MAPHAND | CLASSHAND | PAT_TIMER;
ULONG   DbgPrintFlags = 0;
ULONG   BytesAllocated = 0;

NDIS_SPIN_LOCK   LogLock;

//extern LOG Log;

LOG     Log  = {0, NULL, NULL, 0};


//
// Forward definition
//
#if 0
ULONG
StrLen(
    IN  UCHAR   *Ptr
    );
#endif


NTSTATUS
InitializeLog(
    VOID
    )
{
    NTSTATUS  Status = STATUS_SUCCESS;

    //
    // allocate memory for it
    //
    Log.Buffer = (PROW)ExAllocatePoolWithTag(NonPagedPool, 
                                             (LOGSIZE+4) * sizeof(ROW), 
                                             DebugTag);
    
    if (Log.Buffer) {

        Log.Index = 0;
        Log.Wraps = 0;
        Log.Current = Log.Buffer;

        NdisAllocateSpinLock(&LogLock);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


VOID
FreeDebugLog(VOID) 
{
    ExFreePool(Log.Buffer);
    Log.Buffer = NULL;
}


#if 0
ULONG
StrLen(
    IN  UCHAR   *Ptr
    )

/*++

Routine Description:

    This function does a strlen - so that we don't have to enable intrinsics.

Arguments:
    Ptr - a ptr to the string

Return Value:

    - the number of characters.

--*/

{
    ULONG   Count = 0;

    while (*Ptr++) {
        Count++;
    }

    return( Count );

}
#endif

VOID
TraceRtn(
    IN  UCHAR       *File,
    IN  ULONG       Line,
    IN  UCHAR       *FuncName,
    IN  ULONG_PTR   Param1,
    IN  ULONG_PTR   Param2,
    IN  ULONG	    Param3,
    IN  ULONG	    Param4,
    IN  ULONG       Mask
    )

/*++

Routine Description:

    This function logs the file and line number along with 3 other parameters
    into a circular buffer and possibly to the debug terminal.

Arguments:


Return Value:


--*/

{
    NTSTATUS    status;
    PROW        pEntry;
    PUCHAR      pFile, p;
    LONG		l, m;

    if (!Log.Buffer)
    {
        return;
    }

    NdisAcquireSpinLock(&LogLock);

    pEntry = &Log.Buffer[Log.Index];

    p = File;
    pFile = p + strlen(File) - 1;
    while (*pFile != '\\' && p != pFile) {
      pFile--;
    }
    //pFile = (PUCHAR)strrchr((CONST CHAR * )File,'\\');
    pFile++;

    RtlZeroMemory(&pEntry->Row[0], LOGWIDTH);

    l = strlen(pFile);
    RtlCopyMemory(&pEntry->Row[0], pFile, min(l,LOGWIDTH));

    if (l+3 < LOGWIDTH) {

        pEntry->Row[l+0] = ' ';
        pEntry->Row[l+1] = '%';
        pEntry->Row[l+2] = 'd';
        pEntry->Row[l+3] = ' ';
    }

    if (l+4 < LOGWIDTH) {

        m = strlen(FuncName);
        RtlCopyMemory(&pEntry->Row[l+4], FuncName, min(m,LOGWIDTH-(l+4)));
    }

    pEntry->Line = Line;
    pEntry->Time = GetTime();
    pEntry->P1 = Param1;
    pEntry->P2 = Param2;
    pEntry->P3 = Param3;
    pEntry->P4 = Param4;

    //++Log.Current;
    if (++(Log.Index) >= LOGSIZE)
    {
        Log.Index = 0;
        Log.Wraps++;
        Log.Current = Log.Buffer;
    }
    if (DebugFlags & KD_PRINT) {
        KdPrint(( pEntry->Row, Line ));
        KdPrint(( " %p %p %d %d\n", Param1, Param2, Param3, Param4 ));
    }

    NdisReleaseSpinLock(&LogLock);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\inc\pktsched.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    pktsched.h

Abstract:

    defines for packet scheduler component interface

Author:


Revision History:

--*/

#ifndef _PKTSCHED_H_
#define _PKTSCHED_H_

//
// forwards
//

/*
typedef struct _PSI_INFO;
typedef struct _PS_PROFILE;
typedef struct _PS_PIPE_CONTEXT;
typedef struct _PS_FLOW_CONTEXT;
typedef struct _PS_DEBUG_INFO;
*/

//
// Component registration function exported by PSched
//


//
// Context info passed to each component during pipe initialization.  The PS
// allocates one PS_PIPE_CONTEXT struct for each component.  The size of an
// individual component's struct is indicated by the component during registration,
// and must be at least as large as sizeof(PS_PIPE_CONTEXT).
// Each component's context area begins with the struct defined below, and the
// component-specific data follows.
//
// Note : This structure has to be word aligned.
//

typedef struct _PS_PIPE_CONTEXT {
    // NextComponentContext -   Pointer to next component's pipe-specific data
    // PrevComponentContext -   Pointer to previous component's pipe-specific data
    // NextComponent -          Function info about next component in pipeline
    // PacketReservedOffset -   Offset to packet reserved bytes for this component

    struct _PS_PIPE_CONTEXT    *NextComponentContext;
    struct _PS_PIPE_CONTEXT    *PrevComponentContext;
    struct _PSI_INFO           *NextComponent;
    ULONG                      PacketReservedOffset;
} PS_PIPE_CONTEXT, *PPS_PIPE_CONTEXT;

//
// Context info passed to each component during flow initialization.  The PS
// allocates one PS_FLOW_CONTEXT struct for each component.  The size of an
// individual component's struct is indicated by the component during registration,
// and must be at least as large as sizeof(PS_FLOW_CONTEXT).
// Each component's context area begins with the struct defined below, and the
// component-specific data follows.
//

typedef struct _PS_FLOW_CONTEXT {
    // NextComponentContext -   Pointer to next component's flow-specific data
    // PrevComponentContext -   Pointer to previous component's flow-specific data

    struct _PS_FLOW_CONTEXT    *NextComponentContext;
    struct _PS_FLOW_CONTEXT    *PrevComponentContext;
} PS_FLOW_CONTEXT, *PPS_FLOW_CONTEXT, PS_CLASS_MAP_CONTEXT, *PPS_CLASS_MAP_CONTEXT;

//
// Packet Information Block.  This structure can be found
// at offset zero from the packet's ProtocolReserved area.
//

typedef struct _PACKET_INFO_BLOCK {

    // SchedulerLinks -     Linkage in scheduling component list
    // PacketLength -       Length of packet, non including MAC header
    // ConformanceTime -    Token Bucket Conformance Time
    // DelayTime -          Time at which packet is eligible for sending
    // FlowContext -        Flow context area for the convenience of the scheduling
    //                      components.  May be used by the scheduling component
    //                      while the packet is being processed by that component.
    // ClassMapContext -    Class Map context area for convenience of scheduling
    //                      components. May be used by the scheduling component
    //                      when the packet is being processed by that component.
    // IpHdr -              points to the IP transport header. This is used by the 
    //                      sequencer to stamp the IP packet with the non conforming
    //                      TOS byte. We store a pointer here because we have already
    //                      done the dirty work of getting to the buffer in MpSend.
    //                      This will be 0 for non IP packets, in which case the 
    //                      sequencer  need not do anything.
    // IPPrecedenceByteNonConforming - The TOS setting for non conforming packets.
    // UserPriorityNonConforming - 802.1p setting for non conforming packets.

    LIST_ENTRY SchedulerLinks;
    ULONG   PacketLength;
    LARGE_INTEGER ConformanceTime;
    LARGE_INTEGER DelayTime;
    HANDLE FlowContext;
    HANDLE ClassMapContext;
    ULONG IPHeaderOffset;
    IPHeader *IPHdr;
    PNDIS_PACKET NdisPacket;
    UCHAR TOSNonConforming;
    UCHAR UserPriorityNonConforming;
} PACKET_INFO_BLOCK, *PPACKET_INFO_BLOCK;


//
// Prototypes for PS routines made available to scheduling components.
//

typedef VOID
(*PS_DROP_PACKET)(
    IN HANDLE PsPipeContext,
    IN HANDLE PsFlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

typedef HANDLE
(*PS_NDIS_PIPE_HANDLE)(
    IN HANDLE PsPipeContext
    );

typedef HANDLE
(*PS_NDIS_FLOW_HANDLE)(
    IN HANDLE PsFlowContext
    );

typedef VOID
(*PS_GET_TIMER_INFO)(
    OUT PULONG TimerResolution  // Timer resolution in system time units
    );

typedef struct _PS_PROCS {
    PS_DROP_PACKET DropPacket;
    PS_NDIS_PIPE_HANDLE NdisPipeHandle;
    PS_GET_TIMER_INFO GetTimerInfo;
} PS_PROCS, *PPS_PROCS;


//
// Upcall information passed to next component
//

typedef VOID
(*PSU_SEND_COMPLETE)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

typedef struct _PS_UPCALLS {
    PSU_SEND_COMPLETE SendComplete;
    PPS_PIPE_CONTEXT  PipeContext;
} PS_UPCALLS, *PPS_UPCALLS;

//
// Pipe parameters
//

typedef struct _PS_PIPE_PARAMETERS {

    // Bandwidth            - In bytes/sec
    // MTUSize              - Maximum frame size
    // HeaderSize           - Number of bytes in header
    // Flags                - See below
    // MaxOutstandingSends  - Maximum sends that can be pending concurrently
    // SDModeControlledLoad - Default handling of non-conforming controlled load traffic
    // SDModeGuaranteed     - Default handling of non-conforming guaranteed service  traffic
    // SDModeNetworkControl - Default handling of non-conforming NetworkControl service  traffic
    // SDModeQualitative    - Default handling of non-conforming Qualitative service  traffic
    // RegistryPath         - Pointer to the registry path of that interface. Can be used to read reg params.

    ULONG Bandwidth;
    ULONG MTUSize;
    ULONG HeaderSize;
    ULONG Flags;
    ULONG MaxOutstandingSends;
    ULONG SDModeControlledLoad;
    ULONG SDModeGuaranteed;
    ULONG SDModeNetworkControl;
    ULONG SDModeQualitative;
    PNDIS_STRING RegistryPath;

    // Need this to let the scheduling components to know what kind of medium it is //
    NDIS_MEDIUM MediaType;      //  Wan Or anything else

} PS_PIPE_PARAMETERS, *PPS_PIPE_PARAMETERS;

// Pipe flags

#define PS_DISABLE_DRR                  2
#define PS_INTERMEDIATE_SYS             4

//
// function typedefs for the scheduler entry points
//

typedef NDIS_STATUS
(*PS_INITIALIZE_PIPE)(
    IN HANDLE              PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT    ComponentPipeContext,
    IN PPS_PROCS           PsProcs,
    IN PPS_UPCALLS         Upcalls
    );

typedef NDIS_STATUS
(*PS_MODIFY_PIPE)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

typedef VOID
(*PS_DELETE_PIPE)(
    IN PPS_PIPE_CONTEXT PipeContext
    );

typedef NDIS_STATUS
(*PS_CREATE_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

typedef NDIS_STATUS
(*PS_MODIFY_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

typedef VOID
(*PS_DELETE_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

typedef VOID
(*PS_EMPTY_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

typedef BOOLEAN
(*PS_SUBMIT_PACKET)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PktInfo);

typedef BOOLEAN
(*PS_RECEIVE_PACKET)(
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    );

typedef BOOLEAN
(*PS_RECEIVE_INDICATION)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PVOID    HeaderBuffer,
    IN UINT     HeaderBufferSize,
    IN PVOID    LookAheadBuffer,
    IN UINT     LookAheadBufferSize,
    IN UINT     PacketSize,
    IN UINT     TransportHeaderOffset
    );

typedef VOID
(*PS_SET_INFORMATION) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG BufferSize,
    IN PVOID Buffer
    );

typedef VOID
(*PS_QUERY_INFORMATION) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG BufferSize,
    IN PVOID Buffer,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

typedef NDIS_STATUS
(*PS_CREATE_CLASS_MAP) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

typedef NDIS_STATUS
(*PS_DELETE_CLASS_MAP) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT
    );

/* End Prototypes */


//
// Scheduling component registration structure.
//

#define PS_COMPONENT_CURRENT_VERSION 1

typedef struct _PSI_INFO {
    LIST_ENTRY Links;
    BOOLEAN Registered;
    BOOLEAN AddIn;
    USHORT  Version;
    NDIS_STRING ComponentName;
    ULONG PacketReservedLength;
    ULONG PipeContextLength;
    ULONG FlowContextLength;
    ULONG ClassMapContextLength;
    ULONG SupportedOidsLength;
    NDIS_OID *SupportedOidList;
    ULONG SupportedGuidsLength;
    NDIS_GUID *SupportedGuidList;
    PS_INITIALIZE_PIPE InitializePipe;
    PS_MODIFY_PIPE ModifyPipe;
    PS_DELETE_PIPE DeletePipe;
    PS_CREATE_FLOW CreateFlow;
    PS_MODIFY_FLOW ModifyFlow;
    PS_DELETE_FLOW DeleteFlow;
    PS_EMPTY_FLOW  EmptyFlow;
    PS_SUBMIT_PACKET SubmitPacket;
    PS_RECEIVE_PACKET ReceivePacket;
    PS_RECEIVE_INDICATION ReceiveIndication;
    PS_SET_INFORMATION SetInformation;
    PS_QUERY_INFORMATION QueryInformation;
    PS_CREATE_CLASS_MAP CreateClassMap;
    PS_DELETE_CLASS_MAP DeleteClassMap;
} PSI_INFO, *PPSI_INFO;

//
// Profile registration structure
//
#define MAX_COMPONENT_PER_PROFILE 10
typedef struct _PS_PROFILE {
    LIST_ENTRY  Links;
    USHORT      UnregisteredAddInCnt;
    NDIS_STRING ProfileName;
    UINT        ComponentCnt;
    // Allocate an extra slot for the StubComponent
    PPSI_INFO   ComponentList[MAX_COMPONENT_PER_PROFILE + 1];
} PS_PROFILE, *PPS_PROFILE;



//
// Debugging support for add-in components
//
typedef VOID
(*PS_GET_CURRENT_TIME) (PLARGE_INTEGER SysTime);

typedef VOID
(*PS_LOGSTRING_PROC) (
    IN char *format,
    ...
    );

typedef VOID 
(*PS_LOGSCHED_PROC) (
    IN ULONG SchedulerComponent,
    IN ULONG Action,
    IN PVOID VC,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG Priority,
    IN LONGLONG ArrivalTime,
    IN LONGLONG ConformanceTime,
    IN ULONG PacketsInComponent,
    IN ULONG BytesInComponent
    );

typedef VOID
(*PS_LOGREC_PROC) (
    IN ULONG ComponentId,
    IN PVOID RecordData,
    IN ULONG RecordLength
    );

typedef ULONG
(*PS_GETID_PROC) (
    VOID);

typedef struct _PS_DEBUG_INFO {
    PULONG DebugLevel;
    PULONG DebugMask;
    PULONG LogTraceLevel;
    PULONG LogTraceMask;
    ULONG LogId;
    PS_GET_CURRENT_TIME GetCurrentTime;
    PS_LOGSTRING_PROC LogString;
    PS_LOGSCHED_PROC LogSched;
    PS_LOGREC_PROC LogRec;
} PS_DEBUG_INFO, *PPS_DEBUG_INFO;


//
//  VOID
//  InsertEntryList(
//      PLIST_ENTRY Entry,
//      PLIST_ENTRY EntryToInsert
//      );
//
//  insert EntryToInsert just after Entry
//

#define InsertEntryList( Entry, EntryToInsert ) {           \
    (EntryToInsert)->Flink = (Entry)->Flink;                \
    (Entry)->Flink = (EntryToInsert);                       \
    (EntryToInsert)->Blink = (EntryToInsert)->Flink->Blink; \
    (EntryToInsert)->Flink->Blink = (EntryToInsert);        \
    }


#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.
#define ARP_ETYPE_IP        0x800

typedef struct _ETH_HEADER {
    UCHAR DestAddr[ARP_802_ADDR_LENGTH];
    UCHAR SrcAddr[ARP_802_ADDR_LENGTH];
    USHORT Type;
} ETH_HEADER, *PETH_HEADER;

_inline
IPHeader *
GetIpHeader(ULONG TransportHeaderOffset, PNDIS_PACKET pNdisPacket)
{
    PVOID         pAddr;
    PNDIS_BUFFER  pNdisBuf1, pNdisBuf2;
    UINT          Len;

    pNdisBuf1 = pNdisPacket->Private.Head;
    NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    while(Len <= TransportHeaderOffset) {

        //
        // Transport header is not in this buffer,
        // try the next buffer
        //

        TransportHeaderOffset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        ASSERT(pNdisBuf2);
        NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    return (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);

}

//
// Set TOS byte and recalculate checksum 
// Use incremental checksum update
// RFCs 1071, 1141, 1624
// 
//
// RFC : 1624
// HC' = ~(~HC + ~m + m');
// HC - old checksum, m - old value, m' - new value
//

#define SET_TOS_XSUM(Packet, pIpHdr, tos) {                                              \
    PNDIS_PACKET_EXTENSION _PktExt;                                                               \
    NDIS_TCP_IP_CHECKSUM_PACKET_INFO _ChkPI;                                                      \
    _PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET((Packet));                                        \
    _ChkPI.Value = PtrToUlong(_PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo]);                  \
    if(_ChkPI.Transmit.NdisPacketIpChecksum) {                                                    \
        (pIpHdr)->iph_tos = ((pIpHdr)->iph_tos & PS_IP_DS_CODEPOINT_MASK) | (tos);                \
    }                                                                                             \
    else {                                                                                        \
        USHORT _old, _new;                                                                        \
        ULONG _sum;                                                                               \
        _old = *(USHORT *)(pIpHdr);                                                               \
        (pIpHdr)->iph_tos = ((pIpHdr)->iph_tos & PS_IP_DS_CODEPOINT_MASK) | (tos);                \
        _new = *(USHORT *)(pIpHdr);                                                               \
        _sum = ((~(pIpHdr)->iph_xsum) & 0xffff) + ((~_old) & 0xffff) + _new;                      \
        _sum = (_sum & 0xffff) + (_sum >> 16);                                                    \
        _sum += (_sum >> 16);                                                                     \
        (pIpHdr)->iph_xsum = (ushort) ((~_sum) & 0xffff);                                         \
    }                                                                                             \
}

   
//
// Number of OS time units per second
//

#define OS_TIME_SCALE               10000000

//
// convert from OS's 100 ns to millisecs
//

#define OS_TIME_TO_MILLISECS(_time) ((_time)/10000)

_inline VOID
PsGetCurrentTime(
    PLARGE_INTEGER SysTime
    )

/*++

Routine Description:

    Get the current system time

Arguments:

Comments:
    1. We need something that always increases - Hence we cannot use NdisGetCurrentSystemTime or
       KeQueryCurrentSystem time. Those APIs can return decreasing times (daylight savings, date/time, etc).

Return Value:

    System time (in base OS time units)

--*/

{

#if defined(PERF_COUNTER)
    LARGE_INTEGER Now;
    LARGE_INTEGER Frequency;

    Now = KeQueryPerformanceCounter(&Frequency);
    SysTime->QuadPart = (Now.QuadPart * OS_TIME_SCALE) / Frequency.QuadPart;

#else
    //
    // We used to use KeQueryTickCount() with KeQueryTimeIncrement(). But, if we are driving the clock at a lower
    // resolution, then we cannot use KeQueryTickCount, because this will always return the time based on the 
    // maximum resolution. Therefore, we use KeQueryInterruptTime().
    //
    SysTime->QuadPart = KeQueryInterruptTime();

#endif

}

#endif /* _PKTSCHED_H_ */

/* end pktsched.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcdb.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcdb.c

Abstract:

    This file contains database routines, that includes specific patterns,
    and classification index table.

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"



VOID
GpcSpecificCallback(
             IN VOID 				  *Ctx, 
             IN SpecificPatternHandle  SpHandle);




/*
************************************************************************

InitSpecificPatternDb - 

Initialize the specific patterns database. It will allocate a table
length Size.

Arguments
    pDb         - a pointer to the db to initialize
    Size        - number of entries in the table

Returns
	NDIS_STATUS

************************************************************************
*/
GPC_STATUS
InitSpecificPatternDb(
                      IN	PSPECIFIC_PATTERN_DB	pDb,
                      IN	ULONG					PatternSize
                      )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
	ULONG			Len, i;
    
	TRACE(INIT, pDb, PatternSize, "InitSpecificPatternDb");
    
    ASSERT(pDb);

    ASSERT(PatternSize);

    //
    // init the specific db struct
    // call the PH init routine
    //

    INIT_LOCK(&pDb->Lock);

    AllocatePatHashTable(pDb->pDb);

    if (pDb->pDb != NULL) {

        constructPatHashTable(pDb->pDb,
                              PatternSize * 8,
                              2,	// usage_ratio,
                              1,    // usage_histeresis,
                              1,    // allocation_histeresis,
                              16    // max_free_list_size
                              );
    } else {
        
        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, Status, 0, "InitSpecificPatternDb==>");

    return Status;
}




/*
************************************************************************

UninitSpecificPatternDb - 

Un-Initialize the specific patterns database. It will release all
allocated memory.

Arguments
    pDb         - a pointer to the db to free

Returns
	NDIS_STATUS

************************************************************************
*/
GPC_STATUS
UninitSpecificPatternDb(
                        IN	PSPECIFIC_PATTERN_DB	pDb
                        )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
    
	TRACE(INIT, pDb, 0, "UninitSpecificPatternDb");
    
    ASSERT(pDb);

    destructPatHashTable(pDb->pDb);
    FreePatHashTable(pDb->pDb);
    
	TRACE(INIT, Status, 0, "UninitSpecificPatternDb==>");

    return Status;
}





/*
************************************************************************

InitClassificationHandleTbl - 

Init the classification index table

Arguments
    ppCHTable       - a pointer a class handle table pointer
	
Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitClassificationHandleTbl(
                            IN	HandleFactory **ppCHTable
                            )
{
    GPC_STATUS					Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, ppCHTable, 0, "InitClassificationHandleTbl");
    
    ASSERT(ppCHTable);

    NEW_HandleFactory(*ppCHTable);

    if (*ppCHTable == NULL) {
        return GPC_STATUS_RESOURCES;
    }

    if (0 != constructHandleFactory(*ppCHTable)) {
        return GPC_STATUS_RESOURCES;
    }

    TRACE(INIT, Status, 0, "InitClassificationIndexTbl==>");

    return Status;
}




/*
************************************************************************

UninitClassificationHandleTbl - 

Uninit the classification index table

Arguments
    pCHTable       - a pointer a class handle table
	
Returns
	void

************************************************************************
*/
VOID
UninitClassificationHandleTbl(
                            IN	HandleFactory *pCHTable
                            )
{
    destructHandleFactory(pCHTable);
    FreeHandleFactory(pCHTable);
}




/*
************************************************************************

InitializeGenericDb - 

Init the generic db. This is called by per CF.

Arguments
    pGenericDb   - a pointer to the generic db
    NumEntries   - number of entries, one per rhizome
    PatternSize  - pattern size in bytes
	
Returns
	GPC_STATUS: no memory resources

************************************************************************
*/
GPC_STATUS
InitializeGenericDb(
                    IN  PGENERIC_PATTERN_DB	*ppGenericDb,
                    IN  ULONG				 NumEntries,
                    IN  ULONG				 PatternSize
                    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    ULONG				i;
    PGENERIC_PATTERN_DB	pDb;
    
    *ppGenericDb = NULL;

    ASSERT(PatternSize);

    GpcAllocMem(&pDb, 
                sizeof(GENERIC_PATTERN_DB) * NumEntries, 
                GenPatternDbTag);

    if (pDb == NULL)
        return GPC_STATUS_RESOURCES;

    *ppGenericDb = pDb;

    for (i = 0; i < NumEntries; i++, pDb++) {
        
        INIT_LOCK(&pDb->Lock);

        AllocateRhizome(pDb->pRhizome);

        if (pDb->pRhizome == NULL) {

            //
            // failed, release all allocated resources
            //

            while (i > 0) {
                NdisFreeSpinLock(&pDb->Lock);
                i--;
                pDb--;
                destructRhizome(pDb->pRhizome);
                FreeRhizome(pDb->pRhizome);
            }

            GpcFreeMem((*ppGenericDb), GenPatternDbTag);

            Status = GPC_STATUS_RESOURCES;
            *ppGenericDb = NULL;
            break;
        }

        //
        // init the rhizome
        //

        constructRhizome(pDb->pRhizome, PatternSize*8);
    }

    return Status;
}



/*
************************************************************************

UninitializeGenericDb - 

Uninit the generic db. 

Arguments
    pGenericDb   - a pointer to the generic db
    NumEntries   - number of entries, one per rhizome
    PatternSize  - pattern size in bytes
	
Returns
	void

************************************************************************
*/
VOID
UninitializeGenericDb(
                    IN  PGENERIC_PATTERN_DB	*ppGenericDb,
                    IN  ULONG				 NumEntries
                    )
{
    ULONG				i;
    PGENERIC_PATTERN_DB	pDb;
    
    pDb = *ppGenericDb;

    ASSERT(pDb);

    for (i = 0; i < NumEntries; i++, pDb++) {
        
        NdisFreeSpinLock(&pDb->Lock);

        destructRhizome(pDb->pRhizome);
        
        FreeRhizome(pDb->pRhizome);
    }

    GpcFreeMem(*ppGenericDb, GenPatternDbTag);

    *ppGenericDb = NULL;
}



/*
************************************************************************

GpcSpecificCallback -

Call back routine given when calling scanPatHashTable and getting called
by the pathash scanning routine.

Arguments
	Ctx      - a pointer to a SCAN_STRUCT to hold context info
    SpHandle - the specific pattern handle that matches

Returns
	void

************************************************************************
*/
VOID
GpcSpecificCallback(
             IN VOID 				  *Ctx, 
             IN SpecificPatternHandle  SpHandle)
{
    PSCAN_STRUCT			pScan = (PSCAN_STRUCT)Ctx;
    PPATTERN_BLOCK			pSpPattern;
    PPATTERN_BLOCK			pGpPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PatternHandle	    	GpHandle;
    PBLOB_BLOCK				pSpBlob, *ppSpCbBlob, OldBlob;
    ULONG					CfIndex;
    PCF_BLOCK				pCf;
    KIRQL					ReadIrql;
    KIRQL					CBirql;
    PCLASSIFICATION_BLOCK	pCB;
    PGPC_IP_PATTERN         pIp;
    BOOLEAN                 bBetterFound = FALSE;
    UINT                     i;
    TRACE(PATTERN, Ctx, SpHandle, "GpcSpecificCallback");

    pSpPattern = (PPATTERN_BLOCK)GetReferenceFromSpecificPatternHandle(SpHandle);
    pCB = pSpPattern->pClassificationBlock;
   
    pIp = (PGPC_IP_PATTERN) GetKeyPtrFromSpecificPatternHandle(SpHandle);
    ASSERT(pCB);
    ASSERT(pScan);
    
    //
    // get the CF index 
    //

    CfIndex = pScan->pClientBlock->pCfBlock->AssignedIndex;
    pCf = pScan->pClientBlock->pCfBlock;

    //
    // the blob that actually belongs to the SP
    //

    pSpBlob = GetBlobFromPattern(pSpPattern,CfIndex);

    //
    // the blob that currently exist in the CfIndex entry of the the CB
    //

    ppSpCbBlob = &pCB->arpBlobBlock[CfIndex];

    TRACE(PATTERN, pSpBlob, *ppSpCbBlob, "GpcSpecificCallback (2)");
    TRACE(PATTERN, pCB, CfIndex, "GpcSpecificCallback (2.5)");

    if (pSpBlob != *ppSpCbBlob || pSpBlob == NULL) {

        if (!pScan->bRemove) {

            //
            // we just added the generic pattern, so we should set the
            // CB pointer for that CF point to the new blob
            //
            for (i = 0; i <= pScan->pPatternBlock->Priority; i++) {

                pGenericDb = &pScan->pClientBlock->pCfBlock->arpGenericDb[pSpPattern->ProtocolTemplate][i];

                READ_LOCK(&pGenericDb->Lock, &ReadIrql);

                GpHandle = searchRhizome(pGenericDb->pRhizome,
                                         GetKeyPtrFromSpecificPatternHandle(SpHandle)
                                         );

                TRACE(PATTERN, pGenericDb, GpHandle, "GpcSpecificCallback (3.5)");

                if (GpHandle != NULL) {

                    WRITE_LOCK(&glData.ChLock, &CBirql);
                    bBetterFound = TRUE;

                    pGpPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    *ppSpCbBlob = GetBlobFromPattern(pGpPattern, CfIndex);

                    WRITE_UNLOCK(&glData.ChLock, CBirql);
                    READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                    break;

                }

                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);

            } 

            if (!bBetterFound) {

                WRITE_LOCK(&glData.ChLock, &CBirql);
                *ppSpCbBlob = pScan->pBlobBlock;

                WRITE_UNLOCK(&glData.ChLock, CBirql);
            }


        } else {
            
            //
            // The CfIndex slot in the CB points to a blob that doesn't belong
            // to the specific pattern we have just found. There is a chance
            // that there is another generic pattern somewhere, that may
            // or may not be more specific, thus resulting in updating the blob
            // pointer in the CB. So we need to search the generic db for a
            // match (to the specific pattern).
            //
            
            for (i = 0; i <= pScan->pPatternBlock->Priority; i++) {
            
                pGenericDb = &pScan->pClientBlock->pCfBlock->arpGenericDb[pSpPattern->ProtocolTemplate][i];
            
                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
            
                GpHandle = searchRhizome(pGenericDb->pRhizome, 
                                         GetKeyPtrFromSpecificPatternHandle(SpHandle)
                                         );

                TRACE(PATTERN, pGenericDb, GpHandle, "GpcSpecificCallback (3.5)");


                if (GpHandle != NULL) {
        
                    //
                    // we found a generic pattern in the rhizoe that can also be
                    // the same one that is currently being installed, but
                    // that's fine, since we want the most specific one, and
                    // the search guarantees that.
                    // all we need to do is to update the CB of the SP with 
                    // the blob of the GP we've just found.
                    //
                    bBetterFound = TRUE; 
                    WRITE_LOCK(&glData.ChLock, &CBirql);
                    OldBlob = *ppSpCbBlob;
                    pGpPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    *ppSpCbBlob = GetBlobFromPattern(pGpPattern, CfIndex);

                    TRACE(PATTERN, pGpPattern, pCB->arpBlobBlock[CfIndex], "GpcSpecificCallback (4)");
                    
                    WRITE_UNLOCK(&glData.ChLock, CBirql);
                    READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                    break;

                }

                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
            
            }

            if (!bBetterFound) {

                //
                // non was found
                //

                WRITE_LOCK(&glData.ChLock, &CBirql);
                *ppSpCbBlob = NULL;
                WRITE_UNLOCK(&glData.ChLock, CBirql);
                TRACE(PATTERN, *ppSpCbBlob, pCB->arpBlobBlock[CfIndex], "GpcSpecificCallback (5)");

            }


        }
                            
    }

    TRACE(PATTERN, pCB, CfIndex, "GpcSpecificCallback==>");
}





/*
************************************************************************

AddGenericPattern -

Add a generic pattern to the db. 

Arguments
	pClient		- 
    Pattern		- 
    Mask		- 
    Priority	- 
    pBlob		- 
    ppPatter	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
AddGenericPattern(
                  IN  PCLIENT_BLOCK		pClient,
                  IN  PUCHAR			pPatternBits,
                  IN  PUCHAR			pMaskBits,
                  IN  ULONG				Priority,
                  IN  PBLOB_BLOCK		pBlob,
                  IN  PPROTOCOL_BLOCK	pProtocol,
                  IN OUT PPATTERN_BLOCK	*ppPattern
)
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PatternHandle			GpHandle;
    PPATTERN_BLOCK			pPattern = *ppPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    SCAN_STRUCT				ScanStruct;
    ULONG                   i;
    ULONG                   CfIndex = pClient->pCfBlock->AssignedIndex;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    PGPC_IP_PATTERN         pIp, pMask;

	TRACE(PATTERN, pClient, pPatternBits, "AddGenericPattern");

    // This is impossible with a good client (320705)
    if (!pBlob) {

        return GPC_STATUS_INVALID_PARAMETER;

    }
    
    pIp = (PGPC_IP_PATTERN)pPatternBits;
    pMask = (PGPC_IP_PATTERN)pMaskBits;


    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    //
    // Add to the Rhizome tree, according to priority value
    //

    pGenericDb = &pClient->pCfBlock->arpGenericDb[pProtocol->ProtocolTemplate][Priority];

    //
    // Lock the generic db for insertion
    //

    WRITE_LOCK(&pGenericDb->Lock, &WriteIrql);

    GpHandle = insertRhizome(pGenericDb->pRhizome,
                             pPatternBits,
                             pMaskBits,
                             (PVOID)*ppPattern,
                             (PULONG)&Status
                             );

    WRITE_UNLOCK(&pGenericDb->Lock, WriteIrql);

    if (NT_SUCCESS(Status)) {

        //
        // add one ref count
        //
        
        REFADD(&(*ppPattern)->RefCount, 'ADGP');

        //
        // we managed to insert the pattern, no conflicts.
        // now we need to scan the specific db for a match, 
        // since the insertion might affect CB entries for
        // patterns which are subsets of the installed pattern
        //
        
        ProtocolStatInc(pProtocol->ProtocolTemplate, 
                        InsertedRz);
        
        //
        // lock the specific db, some other client may access it
        //
        
        ScanStruct.Priority = Priority;
        ScanStruct.pClientBlock = pClient;
        ScanStruct.pPatternBlock = *ppPattern;
        ScanStruct.pBlobBlock = pBlob;
        ScanStruct.bRemove = FALSE;

        //
        // update the pattern
        //

        GetBlobFromPattern(pPattern,CfIndex) = pBlob;
        pPattern->pClientBlock = pClient;
        ASSERT(GpHandle);
        pPattern->DbCtx = (PVOID)GpHandle;

        TRACE(PATTERN, pPattern, GpHandle, "AddGenericPattern: DbCtx");

        pPattern->State = GPC_STATE_READY;

        GpcInterlockedInsertTailList
            (&pBlob->PatternList,
             &pPattern->BlobLinkage[CfIndex],
             &pBlob->Lock
             );

        //
        // this will do the rest of the work...
        //
        
        READ_LOCK(&pSpecificDb->Lock, &ReadIrql);

        scanPatHashTable(
                         pSpecificDb->pDb,
                         pPatternBits,
                         pMaskBits,
                         (PVOID)&ScanStruct,
                         GpcSpecificCallback   // see callback routine...
                         );

        READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    }

	TRACE(PATTERN, Status, 0, "AddGenericPattern==>");

    return Status;
}

 

void DeleteAutoPattern(PPATTERN_BLOCK pPattern,IN  PPROTOCOL_BLOCK			pProtocol)
{

	NDIS_LOCK(&pPattern->Lock);

        pPattern->State = GPC_STATE_FORCE_REMOVE;
                    
        pPattern->Flags |= ~PATTERN_AUTO;
        
	NDIS_LOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);

        if (!IsListEmpty(&pPattern->TimerLinkage))
        	{
       	 	GpcRemoveEntryList(&pPattern->TimerLinkage);

       	 	InitializeListHead(&pPattern->TimerLinkage);

        	}
	
        NDIS_UNLOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);


        ProtocolStatInc(pPattern->ProtocolTemplate,
                    DeletedAp);

        ProtocolStatDec(pPattern->ProtocolTemplate,
                    CurrentAp);

        

         NDIS_UNLOCK(&pPattern->Lock);

         //
         // actually remove the pattern
         //

        // This will try to reacquire lock on pattern. So we released the lock above.
        privateGpcRemovePattern((GPC_HANDLE)pPattern->pAutoClient, (GPC_HANDLE)pPattern, TRUE, TRUE);    
   
            
        InterlockedDecrement(&pProtocol->AutoSpecificPatternCount);
        
}




    
/*
************************************************************************

AddSpecificPattern -

Add a specific pattern to the db. 

Arguments
	pClient		- 
    pPatternBits-
    pMaskBits	- 
    pBlob		- 
    pProtocol   - 
    ppPattern	- 
    ppCB		-

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
AddSpecificPattern(
                  IN  PCLIENT_BLOCK				pClient,
                  IN  PUCHAR					pPatternBits,
                  IN  PUCHAR					pMaskBits,
                  IN  PBLOB_BLOCK				pBlob,     // optional
                  IN  PPROTOCOL_BLOCK			pProtocol,
                  IN OUT PPATTERN_BLOCK			*ppPattern,
                  OUT PCLASSIFICATION_HANDLE 	pCH
                  )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    ULONG					Chyme;
    ULONG					CfIndex, i;
    PPATTERN_BLOCK			pPatternSave;
    PBLOB_BLOCK             pBlobSave;
    SpecificPatternHandle	SpHandle;
    PatternHandle			GpHandle;
    PCLASSIFICATION_BLOCK	pCB = NULL;
    PCF_BLOCK				pCf = NULL;
    PLIST_ENTRY				pHead, pEntry;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    KIRQL					irql;
    //BOOLEAN					bIsAuto;

    ASSERT(ppPattern);
    ASSERT(*ppPattern);

	TRACE(PATTERN, pClient, *ppPattern, "AddSpecificPattern");

    *pCH = 0;
    //bIsAuto = TEST_BIT_ON((*ppPattern)->Flags, PATTERN_AUTO);

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    //
    // get the CF index
    //

    CfIndex = pClient->pCfBlock->AssignedIndex;
    pCf = pClient->pCfBlock;

    //
    // Since we want to take the blob lock and specific DB lock
    // in the same order everywhere. Take the blob lock before the specific DB
    // lock. GPCEnumCfInfo does the same.
    //
    if (pBlob) {
        
        NDIS_LOCK(&pBlob->Lock);

    }
    //
    // lock the specific db, some other client may access it
    //

    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);

    //
    // calculate a chyme hash value for the pat -hash
    //

    Chyme = GpcCalcHash(pProtocol->ProtocolTemplate, pPatternBits);
    ASSERT(Chyme != (-1));

    //
    // actually call insert directly. If the pattern already exist in the 
    // db, the returned reference will be the one for a previously
    // installed pattern, so ppPattern will be different
    //

    SpHandle = insertPatHashTable(
                                  pSpecificDb->pDb,
                                  pPatternBits,
                                  Chyme,
                                  (PVOID)*ppPattern
                                  );

    if (SpHandle != NULL) {

        //
        // the pattern block associated with the pattern we've just
        // installed, we may have gotten one that has already been
        // installed.
        //

        pPatternSave = GetReferenceFromSpecificPatternHandle(SpHandle);

	 
	 
        if (*ppPattern != pPatternSave) {


	 	if ((TEST_BIT_ON( pPatternSave->Flags, PATTERN_AUTO))
	 		&& 
	 		(!TEST_BIT_ON(pPatternSave->Flags,PATTERN_AUTO_NOT_READY)))
	 		{
	 			PCLIENT_BLOCK pClient;
	 			
				NDIS_LOCK(&pPatternSave->Lock);
	 			
	 			REFADD(&pPatternSave->RefCount, 'DLAP');
	 
				NDIS_UNLOCK(&pPatternSave->Lock);

				//WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);

				pClient = pPatternSave->pAutoClient;
    	
    				DeleteAutoPattern(pPatternSave,pProtocol);

    				//WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
    				
				REFDEL(&pPatternSave->RefCount, 'DLAP');
    				REFDEL(&(pClient->RefCount),'CLNT');
	 		}
		
    		
    		SpHandle = insertPatHashTable(
                              pSpecificDb->pDb,
                              pPatternBits,
                              Chyme,
                              (PVOID)*ppPattern
                              );
        	}

        if (SpHandle!=NULL)
	      {
                   pPatternSave = GetReferenceFromSpecificPatternHandle(SpHandle);	

                   if (*ppPattern != pPatternSave){
           
      	            if (GetBlobFromPattern(pPatternSave,CfIndex) && pBlob) {

                        //
      	                // there is a blob assigned to this entry
      	                // this is a NO NO, and will be REJECTED!
      	                //
      	                
      	                //
      	                // just a duplicate - the caller will release
      	                // one ref count in case of an error, so this 
     	                // will keep the pattern around!
      	                //
      
     	                //NdisInterlockedIncrement(&(*ppPatternSave)->RefCount); 
      
                       //NDIS_UNLOCK(&pPatternSave->Lock);
      	                
                       WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
      
      	                //
                       // Since we want to take the blob lock and specific DB lock
                       // in the same order everywhere, release the blob lock after
                       // the specific DB lock. GPCEnumCfInfo does the same.
                       //
                       if (pBlob) {
         	        
                           NDIS_UNLOCK(&pBlob->Lock);

                       }

                       //TRACE(PATTERN, (*ppPattern)->RefCount, GPC_STATUS_CONFLICT, "AddSpecificPattern-->");

                      return GPC_STATUS_CONFLICT;
                  }

                  //
                  // get the CB pointer, since
                  // the pattern has been already created. 
                  //

                   pCB = pPatternSave->pClassificationBlock;

                   TRACE(PATTERN, pCB, CfIndex, "AddSpecificPattern (1.5)");

                   ASSERT(pCB);
                   ASSERT(CfIndex < pCB->NumberOfElements);
                   ASSERT(pPatternSave->DbCtx);
                   //
                   // increase ref count, since the caller assume there is 
                   // an extra one
                   //

                   REFADD(&pPatternSave->RefCount, 'ADSP');

                   *ppPattern = pPatternSave;

                   //
                   // increase client ref count
                   //
                   
                   NdisInterlockedIncrement(&pPatternSave->ClientRefCount);

                   if (pBlob) {

                     //
                     // now assign the slot entry in the CB to the new blob
                     //
	                
	                WRITE_LOCK(&glData.ChLock, &irql);

	                pCB->arpBlobBlock[CfIndex] = pBlob;

	                WRITE_UNLOCK(&glData.ChLock, irql);

	                GetBlobFromPattern(pPatternSave,CfIndex) = pBlob;

	                TRACE(PATTERN, pPatternSave, pBlob, "AddSpecificPattern(2)");
	    
	                        
	                //
	                // Reasons for removing the blob->lock - 
	                // The lock is taken at teh start of this function.
	                // (only to maintain the order in which locks are taken/released.
	                //
	                GpcInsertTailList
	                    (&pBlob->PatternList, 
	                     &pPatternSave->BlobLinkage[CfIndex]
	                     );
	            }

	            *pCH = pCB->ClassificationHandle;

	            //NDIS_UNLOCK(&pPatternSave->Lock);

	       } 
              else
             { // if (*ppPattern != pPatternSave)

	            ProtocolStatInc(pProtocol->ProtocolTemplate, 
	                            InsertedPH);
	        
	            //
	            // it's a new pattern -
	            // first we need to create a CB and update the pattern and
	            // the blob entries
	            //

	            REFADD(&pPatternSave->RefCount, 'ADSP');

	            pCB = CreateNewClassificationBlock(GPC_CF_MAX);

	            //
	            // This is a specific pattern, so we'll add the classification
	            // handle for future use
	            //

	            WRITE_LOCK(&glData.ChLock, &irql);
	            *pCH = (HFHandle)assign_HF_handle(
	                                              glData.pCHTable,
	                                              (void *)pCB
	                                              );
	            ProtocolStatInc(pProtocol->ProtocolTemplate, 
	                            InsertedCH);
	            WRITE_UNLOCK(&glData.ChLock, irql);

	            if (pCB && *pCH) {

	                TRACE(CLASSHAND, pCB, pCB->ClassificationHandle, "AddSpecificPattern (CH+)");
	                //
	                // got the CB, update the pattern
	                //

	                pCB->arpBlobBlock[CfIndex] = pBlob;
	                GetBlobFromPattern(pPatternSave, CfIndex) = pBlob;
	                pPatternSave->pClientBlock = pClient;
	                pPatternSave->pClassificationBlock = pCB;
	                pPatternSave->DbCtx = (PVOID)SpHandle;
	                pCB->ClassificationHandle = *pCH;
	                TRACE(PATTERN, pPatternSave, pBlob, "AddSpecificPattern(3)");

	                TRACE(PATTERN, pPatternSave, SpHandle, "AddSpecificPattern: DbCtx");

	                pPatternSave->State = GPC_STATE_READY;

	                if (pBlob != NULL) {
	                    
	                    //
	                    // Reason for not using the Blob->Lock anymore -
	                    // The lock is taken at teh start of this function.
	                    // (only to maintain the order in which locks are taken/released.
	                    GpcInsertTailList
	                        (&pBlob->PatternList, 
	                         &pPatternSave->BlobLinkage[CfIndex]
	                         );
	                    

	                }

	                ASSERT(pCf);

	                if (pProtocol->GenericPatternCount) {

	                    //
	                    // a new pattern has been created in the specific db.
	                    // the CB associated with it needs to be updated for each
	                    // CF entry (except the one we've already updated now)
	                    // we'll loop through the CF enlisted and find a match
	                    // for the specific pattern in each generic db.
	                    //
	                    
	                    pHead = &glData.CfList;
	                    pEntry = pHead->Flink;
	                    
	                    while (pEntry != pHead) {
	                        
	                        //
	                        // loop through the registered CF's
	                        //
	                        
	                        pCf = CONTAINING_RECORD(pEntry, CF_BLOCK, Linkage);
	                        
	                        pEntry = pEntry->Flink;
	                        
	                        if (pCf->AssignedIndex != CfIndex || pBlob == NULL) {
	                            
	                            //
	                            // skip the current CF only if this client installed
	                            // a CfInfo
	                            //
	                            
	                            pGenericDb = pCf->arpGenericDb[pProtocol->ProtocolTemplate];
	                            ASSERT(pGenericDb);
	                            
	                            for (i = 0, pPatternSave = NULL; 
	                                 i < pCf->MaxPriorities && pPatternSave == NULL; 
	                                 i++, pGenericDb++) {
	                                
	                                //
	                                // scan each priority Rhizome
	                                //
	                                
	                                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
	                                
	                                GpHandle = searchRhizome(pGenericDb->pRhizome,
	                                                         pPatternBits);
	                                
	                                if (GpHandle != NULL) {
	                                    
	                                    pPatternSave = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);

	                                    REFADD(&pPatternSave->RefCount, 'ADSP');

	                                }
	                                
	                                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
	                            }
	                            
	                            if (pPatternSave != NULL) {
	                                
	                                //
	                                // found a generic match, get the reference
	                                // which is a pointer to a pattern and get the
	                                // blob pointer from it.
	                                //
	                                
	                                pCB->arpBlobBlock[pCf->AssignedIndex] = 
	                                    GetBlobFromPattern(pPatternSave,pCf->AssignedIndex);
	                                
	                                REFDEL(&pPatternSave->RefCount, 'ADSP');

	                            } else {
	                                
	                                //
	                                // no generic pattern matches this specific one
	                                //
	                                
	                                pCB->arpBlobBlock[pCf->AssignedIndex] = NULL;

	                            }

	                            TRACE(PATTERN, pPatternSave, pCB->arpBlobBlock[pCf->AssignedIndex], "AddSpecificPattern(4)");

	                        }

	                    }	// while (pEntry != pHead)

	                } 	// if (pProtocol->GenericPatternCount)

	            } else {   // if (pCB)

	                //
	                // remove from pathash table!! (#321509)
	                //

	                removePatHashTable(
	                                   pSpecificDb->pDb,
	                                   SpHandle
	                                   );

	                REFDEL(&pPatternSave->RefCount, 'ADSP');

	                if (pCB) {
	                    ReleaseClassificationBlock(pCB);
	                }

	                if (*pCH) {
	                    FreeClassificationHandle(pClient, 
	                                             *pCH
	                                             );
	                }
	                 
	                Status = GPC_STATUS_RESOURCES;

	            }
	            
	 	   } 
              
        	}
        	else  

        	Status = GPC_STATUS_RESOURCES;
        
    	}
    
    	else
    		
    		Status=GPC_STATUS_RESOURCES;		
    //
    // release the specific db lock
    //
    
    WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);

    //
    // Since we want to take the blob lock and specific DB lock
    // in the same order everywhere, release the blob lock after
    // the specific DB lock. GPCEnumCfInfo does the same.
    //
    if (pBlob) {
        
        NDIS_UNLOCK(&pBlob->Lock);

    }

    //
    // set output parameters:
    //   ppPattern should have been set by now
    //
    
    TRACE(PATTERN, *ppPattern, Status, "AddSpecificPattern==>");

    	return Status;
    }
   
    	    






/*
************************************************************************

HandleFragment -

Handle an IP fragment.

Arguments
	pClient    -
    bFirstFrag -
    bLastFrag  - 
    
Retu
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
HandleFragment(
               IN  PCLIENT_BLOCK		pClient,
               IN  PPROTOCOL_BLOCK		pProtocol,
               IN  BOOLEAN             	bFirstFrag,
               IN  BOOLEAN             	bLastFrag,
               IN  ULONG				PacketId,
               IN OUT PPATTERN_BLOCK   *ppPatternBlock,
               OUT PBLOB_BLOCK			*ppBlob
)
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PFRAGMENT_DB	        pFragDb;
    SpecificPatternHandle	SpHandle;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    KIRQL					CHirql;

    ASSERT(ppPatternBlock);
    ASSERT(ppBlob);

	TRACE(CLASSIFY, PacketId, bFirstFrag, "HandleFragment: PacketId, bFirstFrag");
	TRACE(CLASSIFY, PacketId, bLastFrag, "HandleFragment: PacketId, bLastFrag");

    pFragDb = (PFRAGMENT_DB)pProtocol->pProtocolDb;

    if (bFirstFrag) {

        //
        // add an entry to the hash table
        //

        WRITE_LOCK(&pFragDb->Lock, &WriteIrql);

        SpHandle = insertPatHashTable(
                                      pFragDb->pDb,
                                      (char *)&PacketId,
                                      PacketId,
                                      (void *)*ppPatternBlock
                                      );

        WRITE_UNLOCK(&pFragDb->Lock, WriteIrql);

        ProtocolStatInc(pProtocol->ProtocolTemplate, 
                        FirstFragsCount);
        
    } else {

        //
        // search for it
        //

        READ_LOCK(&pFragDb->Lock, &ReadIrql);

        SpHandle = searchPatHashTable(
                                      pFragDb->pDb,
                                      (char *)&PacketId,
                                      PacketId);
        if (SpHandle) {

            *ppPatternBlock = GetReferenceFromSpecificPatternHandle(SpHandle);

            READ_UNLOCK(&pFragDb->Lock, ReadIrql);

            //NdisInterlockedIncrement(&(*ppPatternBlock)->RefCount);

            if (bLastFrag) {
                
                //
                // remove the entry from the hash table
                //
             
                WRITE_LOCK(&pFragDb->Lock, &WriteIrql);

                removePatHashTable(pFragDb->pDb, SpHandle);

                WRITE_UNLOCK(&pFragDb->Lock, WriteIrql);
                
                ProtocolStatInc(pProtocol->ProtocolTemplate, 
                                LastFragsCount);
            }

        } else {

            //
            // not found
            //

            READ_UNLOCK(&pFragDb->Lock, ReadIrql);

            *ppPatternBlock = NULL;
            *ppBlob = NULL;
            Status = GPC_STATUS_NOT_FOUND;
        }

    }

    if (Status == GPC_STATUS_SUCCESS) {

        ASSERT(*ppPatternBlock);

        if (TEST_BIT_ON((*ppPatternBlock)->Flags, PATTERN_SPECIFIC)) {

            //
            // specific pattern, lookup throught the CH
            //

            READ_LOCK(&glData.ChLock, &CHirql);

            *ppBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            (*ppPatternBlock)->pClassificationBlock->ClassificationHandle,
                            pClient->pCfBlock->AssignedIndex);

            READ_UNLOCK(&glData.ChLock, CHirql);

        } else {

            //
            // generic pattern, get the blob ptr directly
            //

            *ppBlob = GetBlobFromPattern((*ppPatternBlock), 
                                         pClient->pCfBlock->AssignedIndex);
                            
        }
         
        DBGPRINT(CLASSIFY, ("HandleFragment: Pattern=%X Blob=%X\n", 
                            *ppPatternBlock, *ppBlob));

    }

	TRACE(CLASSIFY, *ppPatternBlock, *ppBlob, "HandleFragment==>");

    return Status;
}





/*
************************************************************************

InternalSearchPattern -


Arguments

Returns
	matched pattern or NULL for none

************************************************************************
*/
NTSTATUS
InternalSearchPattern(
	IN  PCLIENT_BLOCK			pClientBlock,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  PVOID					pPatternKey,
    OUT PPATTERN_BLOCK          *pPatternBlock,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle,
    IN	BOOLEAN                 bNoCache
    )
{
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    PatternHandle			GpHandle;
    SpecificPatternHandle	SpHandle;
    PPATTERN_BLOCK			pPattern;
    PCF_BLOCK				pCf;
    int                     i;
    KIRQL					ReadIrql;
    NTSTATUS                Status;

	TRACE(CLASSIFY, pClientBlock, pPatternKey, "InternalSearchPattern:");

    DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X \n", pClientBlock));

    Status = GPC_STATUS_SUCCESS;

    //
    // start with the specific db
    //

    pSpecificDb = &pProtocol->SpecificDb;

    READ_LOCK(&pSpecificDb->Lock, &ReadIrql);

    pCf = pClientBlock->pCfBlock;

    SpHandle = searchPatHashTable(
                                  pSpecificDb->pDb,
                                  (char *)pPatternKey,
                                  GpcCalcHash(pProtocol->ProtocolTemplate,
                                              pPatternKey)
                                  );
    
    if (SpHandle) {
        
        pPattern = (PPATTERN_BLOCK)GetReferenceFromSpecificPatternHandle(SpHandle);
        //NdisInterlockedIncrement(&pPattern->RefCount);

        *pClassificationHandle = 
            (CLASSIFICATION_HANDLE)pPattern->pClassificationBlock->ClassificationHandle;

        TRACE(CLASSIFY, pClientBlock, *pClassificationHandle, "InternalSearchPattern (2)" );

    } else {

        pPattern = NULL;
        *pClassificationHandle = 0;
    }

    READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    if (pPattern == NULL) {

        if (bNoCache) {

            Status = GPC_STATUS_FAILURE;

        } else {

            //
            // no specific pattern, add an automagic one 
            //

            Status = AddSpecificPatternWithTimer(
                                            pClientBlock,
                                            pProtocol->ProtocolTemplate,
                                            pPatternKey,
                                            &pPattern,
                                            pClassificationHandle
                                            );

            DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X installed Pattern=%X\n", 
                                pClientBlock, pPattern));

        }

        if (!NT_SUCCESS(Status)) {

            //
            // not found, search each generic db
            //
        
            for (i = 0; i < (int)pCf->MaxPriorities && pPattern == NULL; i++) {
            
                //
                // scan each priority Rhizome
                //
            
                pGenericDb = &pCf->arpGenericDb[pProtocol->ProtocolTemplate][i];
                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
            
                GpHandle = searchRhizome(pGenericDb->pRhizome, pPatternKey);
            
                if (GpHandle != NULL) {
                
                    pPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    //NdisInterlockedIncrement(&pPattern->RefCount);

                }
                            
                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
            
            }

            // we had to search manually, make sure we know this in the main code.
            *pClassificationHandle = 0;

        }


        DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X Generic Pattern=%X\n", 
                            pClientBlock, pPattern));
    }


	TRACE(CLASSIFY, pPattern, *pClassificationHandle, "InternalSearchPattern==>");

    DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X returned Pattern=%X\n", 
                        pClientBlock, pPattern));

    *pPatternBlock = pPattern;
    return Status;
}




GPC_STATUS
InitFragmentDb(
               IN  PFRAGMENT_DB   *ppFragDb
)
{
    GPC_STATUS   Status = GPC_STATUS_SUCCESS;
    PFRAGMENT_DB pDb;
	ULONG		 Len, i;
    
	TRACE(INIT, ppFragDb, 0, "InitFragmentDb");
    
    ASSERT(ppFragDb);

    //
    // init the pattern db struct
    // call the PH init routine
    //
    
    GpcAllocMem(ppFragDb, sizeof(FRAGMENT_DB), FragmentDbTag);

    if (pDb = *ppFragDb) {
        
        INIT_LOCK(&pDb->Lock);

        AllocatePatHashTable(pDb->pDb);
        
        if (pDb->pDb != NULL) {
            
            constructPatHashTable(pDb->pDb,
                                  sizeof(ULONG),
                                  2,	// usage_ratio,
                                  1,    // usage_histeresis,
                                  1,    // allocation_histeresis,
                                  16    // max_free_list_size
                                  );
        } else {
            GpcFreeMem (*ppFragDb, FragmentDbTag);
            
            Status = GPC_STATUS_RESOURCES;
        }
        
    } else {

        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, Status, 0, "InitFragmentDb==>");
    
    return Status;
}


GPC_STATUS
UninitFragmentDb(
               IN  PFRAGMENT_DB   pFragDb
)
{
    destructPatHashTable (pFragDb->pDb);
    FreePatHashTable(pFragDb->pDb);
    GpcFreeMem (pFragDb, FragmentDbTag);
    return STATUS_SUCCESS;
}

/*
************************************************************************

RemoveSpecificPattern -

Remove a specific pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
RemoveSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern,
                      IN  BOOLEAN               ForceRemoval,
                      IN BOOLEAN DbLocked
                      )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    int                     i;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "RemoveSpecificPattern");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);
    
    ProtocolTemplate = pProtocol->ProtocolTemplate;

    // The plan: Remove the DbCtx (from the Specific pattern structure)
    // from teh Pathash table with the Specific Db Lock held. This 
    // will ensure that if the same pattern is being added, the pathash
    // table will accept the new one instead of bumping up the ref on what
    // we are trying to delete now.
    //
    NDIS_LOCK(&pPattern->Lock);     

    // If Database is not already locked
    if (!DbLocked)
    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
    
    cClientRef = NdisInterlockedDecrement(&pPattern->ClientRefCount);

    if (pPattern->State != GPC_STATE_DELETE) {
        
        ASSERT(cClientRef >= 0); 
        ASSERT(pPattern->DbCtx);
        
        if (0 == cClientRef) {

            pPattern->State = GPC_STATE_DELETE;
        
            removePatHashTable(
                               pSpecificDb->pDb,
                               (SpecificPatternHandle)pPattern->DbCtx
                               );
    
            pPattern->DbCtx = NULL;

            // If Database was not locked before this function was called
	     if (!DbLocked)	
            WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
	     
            NDIS_UNLOCK(&pPattern->Lock);
        
            ReadySpecificPatternForDeletion(
                                            pClient,
                                            pProtocol,
                                            pPattern,
                                            DbLocked
                                            );

        } else if (cClientRef > 0) {

        if (!DbLocked)
            {
        	    // If Database was not locked before this function was called	
                  WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
            }
            NDIS_UNLOCK(&pPattern->Lock);

            ClientRefsExistForSpecificPattern(
                                              pClient,
                                              pProtocol,
                                              pPattern,
                                              DbLocked
                                              );

        } else {

            // we shouldn't be getting here - really.

            // If Database was not locked before this function was called
            if (!DbLocked)
            WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
            NDIS_UNLOCK(&pPattern->Lock);

        }
            
    
    } else {

    	// If Database was not locked before this function was called
	if (!DbLocked)
        WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
        NDIS_UNLOCK(&pPattern->Lock);

    }

	TRACE(PATTERN, pPattern, Status, "RemoveSpecificPattern==>");

    return Status;
}


/*
************************************************************************

ReadySpecificPatternForDeletion -

Remove a specific pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
VOID
ReadySpecificPatternForDeletion(
                                IN  PCLIENT_BLOCK	    pClient,
                                IN  PPROTOCOL_BLOCK		pProtocol,
                                IN  PPATTERN_BLOCK		pPattern,
                                IN BOOLEAN DbLocked
                                )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    PCF_BLOCK               pCf;
    PCLASSIFICATION_BLOCK	pCB;
    int                     i;
    ULONG                   CfIndex;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    PVOID					Key;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "ReadySpecificPatternForDeletion");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

   
    pCf = pClient->pCfBlock;
    CfIndex = pCf->AssignedIndex;
    
    pCB = pPattern->pClassificationBlock;
    ProtocolTemplate = pProtocol->ProtocolTemplate;
    Key = GetKeyPtrFromSpecificPatternHandle(((SpecificPatternHandle)pPattern->DbCtx));

    ASSERT(pCB);

    //
    // Remove the ClHandle, so that if we are coming back in via a
    // user mode ioctl, we wont try to remove it again.
    //
    ClHandle = (HANDLE) LongToPtr(InterlockedExchange((PLONG32)&pPattern->ClHandle, 0));

    if (ClHandle) {
        FreeHandle(ClHandle);
    }
        
    //
    // Remove the pattern from the blobs linked list.
   
   ClearPatternLinks(pPattern, pProtocol, CfIndex);
   
    
    //
    // We are going to access the Specific DB now, lock it NOW.
    // This should fix deadlock 248352 [ShreeM]
    //
    // If the database is not already locked
    if (!DbLocked)
    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
        
    //
    // this is the last client that holds the pattern, 
    // we need to take the pattern off the specific db
    // 
    
    TRACE(PATTERN, pPattern, pPattern->DbCtx, "ReadySpecificPatternForDeletion: DbCtx");
    
    ASSERT(!pPattern->DbCtx);

    ProtocolStatInc(ProtocolTemplate, 
                    RemovedPH);
            
    //
    // free the classification handle - 
    // this must come *before* we free the classification block
    // since it may be referenced by other clients
    //
    
    TRACE(PATTERN, pCB, CfIndex, "ReadySpecificPatternForDeletion: (2)");
    
    FreeClassificationHandle(
                             pClient,
                             (CLASSIFICATION_HANDLE)pCB->ClassificationHandle
                             );
    
    ProtocolStatInc(ProtocolTemplate, 
                    RemovedCH);
    
    // If the database is not already locked
    if (!DbLocked)
    WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
        
    
    //
    // bye bye pattern, at least for this client
    //
    
    REFDEL(&pPattern->RefCount, 'ADSP');
    
    TRACE(PATTERN, pClient, pPattern, "ReadySpecificPatternForDeletion--------->");

}


/*
************************************************************************

ClientRefsExistForSpecificPattern -

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
VOID
ClientRefsExistForSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern,
                      IN BOOLEAN dbLocked
                      )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    PCF_BLOCK               pCf;
    PCLASSIFICATION_BLOCK	pCB;
    int                     i;
    ULONG                   CfIndex;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    PVOID					Key;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "ClientRefsExistForSpecificPattern");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    
    pCf = pClient->pCfBlock;
    CfIndex = pCf->AssignedIndex;
    
    
    pCB = pPattern->pClassificationBlock;
    ProtocolTemplate = pProtocol->ProtocolTemplate;
    Key = GetKeyPtrFromSpecificPatternHandle(((SpecificPatternHandle)pPattern->DbCtx));

    ASSERT(pCB);

    //
    // reference count > 0
    //

    
    pBlob = pCB->arpBlobBlock[CfIndex];
    

    TRACE(PATTERN, pPattern, pBlob, "ClientRefsExistForSpecificPattern (2)");

    //
    // We are going to access the Specific DB now, lock it NOW.
    // This should fix deadlock 248352 [ShreeM]
        //
    if (!dbLocked)
        {
             WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
        }
    
    if (pBlob 
        && 
        ((pBlob->pOwnerClient == pClient) ||
         TEST_BIT_ON(pBlob->Flags, PATTERN_REMOVE_CB_BLOB))) {

        bRemoveLinks = TRUE;
        pNewBlob = NULL;

        TRACE(PATTERN, pCB, CfIndex, "ClientRefsExistForSpecificPattern (3)");

        //
        // search the generic db for the same CF, since there is an open slot,
        // some other generic pattern might fill it with its own blob pointer
        //
            
        pGenericDb = pCf->arpGenericDb[ProtocolTemplate];
            
        ASSERT(pGenericDb);
            
        for (i = 0, pGp = NULL; 
             i < (int)pCf->MaxPriorities && pGp == NULL; 
             i++) {
                
            //
            // scan each priority Rhizome
            //
                
            READ_LOCK(&pGenericDb->Lock, &ReadIrql);
                
            GpHandle = searchRhizome(pGenericDb->pRhizome, Key);
                
            if (GpHandle != NULL) {
                    
                //
                // found a generic pattern that match this specific one.
                //
                    
                pGp = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                pNewBlob = GetBlobFromPattern(pGp, CfIndex);
            }
                
            READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                
            pGenericDb++;
        }

        //
        // update the classification block entry
        //

        WRITE_LOCK(&glData.ChLock, &irql);

        pCB->arpBlobBlock[CfIndex] = pNewBlob;

        WRITE_UNLOCK(&glData.ChLock, irql);

        TRACE(PATTERN, pGp, 
              pCB->arpBlobBlock[CfIndex], 
              "ClientRefsExistForSpecificPattern (4)");

    }

    //
    // must first release this lock to avoid dead lock
    // when aquiring the Blob lock
    //
    if (!dbLocked)
        {
             WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
        }

    // For Autopatterns pBlob = NULL 
    // Hence bRemoveLinks = FALSE
    // So we would not  be acessing the client block
    if (bRemoveLinks) {

        //
        // remove the pattern from any linked list
        //
            
        ClearPatternLinks(pPattern, pProtocol, CfIndex);

        ASSERT(CfIndex == pBlob->pOwnerClient->pCfBlock->AssignedIndex);

        GetBlobFromPattern(pPattern, CfIndex) = NULL;

    }


    REFDEL(&pPattern->RefCount, 'ADSP');

	TRACE(PATTERN, pClient, pPattern, "ClientRefsExistForSpecificPattern---->");

} 




/*
************************************************************************

RemoveGenericPattern -

Remove a generic pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
RemoveGenericPattern(
                     IN  PCLIENT_BLOCK			pClient,
                     IN  PPROTOCOL_BLOCK		pProtocol,
                     IN  PPATTERN_BLOCK		    pPattern
                     )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    PCF_BLOCK               pCf;
    SCAN_STRUCT				ScanStruct;
    UCHAR                   PatternBits[MAX_PATTERN_SIZE];
    UCHAR                   MaskBits[MAX_PATTERN_SIZE];
    ULONG                   i;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pPattern, pPattern->DbCtx, "RemoveGenericPattern");

    ASSERT(MAX_PATTERN_SIZE >= sizeof(GPC_IP_PATTERN));
    ASSERT(MAX_PATTERN_SIZE >= sizeof(GPC_IPX_PATTERN));

    //
    // Remove the ClHandle, so that if we are coming back in via a
    // user mode ioctl, we wont try to remove it again.
    //
    ClHandle = (HANDLE) LongToPtr(InterlockedExchange((PLONG32)&pPattern->ClHandle, 0));
    
    if (ClHandle) {
        FreeHandle(ClHandle);
    }



    pCf = pClient->pCfBlock;
    
    ScanStruct.Priority = pPattern->Priority;
    ScanStruct.pClientBlock = pClient;
    ScanStruct.pPatternBlock = pPattern;
    ScanStruct.pBlobBlock = GetBlobFromPattern(pPattern, pCf->AssignedIndex);
    ScanStruct.bRemove = TRUE;

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    pGenericDb = &pCf->arpGenericDb[pProtocol->ProtocolTemplate][pPattern->Priority];
    ASSERT(pGenericDb);

    // Lock the Pattern
    // Check it's State 
    // Set the State if not set to REMOVE
    // return if state already set to REMOVE
    NDIS_LOCK(&pPattern->Lock);
    if (pPattern->State==GPC_STATE_REMOVE)
    	{
    	       NDIS_UNLOCK(&pPattern->Lock);
		return Status;
    	}
    else{
        pPattern->State = GPC_STATE_REMOVE;
        NDIS_UNLOCK(&pPattern->Lock);
        }
    //
    // remove the pattern from any linked list
    //
    ClearPatternLinks(pPattern, pProtocol, pCf->AssignedIndex);
    
    //
    // copy the pattern key and mask for searching later
    //
    NDIS_LOCK(&pPattern->Lock);
    WRITE_LOCK(&pGenericDb->Lock, &WriteIrql);
    ASSERT(pPattern->DbCtx);

    NdisMoveMemory(PatternBits, 
                   GetKeyPtrFromPatternHandle(pGenericDb->pRhizome,
                                              pPattern->DbCtx),
                   GetKeySizeBytes(pGenericDb->pRhizome)
                   );
    NdisMoveMemory(MaskBits,
                   GetMaskPtrFromPatternHandle(pGenericDb->pRhizome,
                                               pPattern->DbCtx),
                   GetKeySizeBytes(pGenericDb->pRhizome)
                   );

    //
    // remove the pattern from generic db
    //

    removeRhizome(pGenericDb->pRhizome,
                  (PatternHandle)pPattern->DbCtx
                  );

    ProtocolStatInc(pProtocol->ProtocolTemplate, 
                    RemovedRz);
        
    //
    // This is no longer valid
    //

    pPattern->DbCtx = NULL;
    
    WRITE_UNLOCK(&pGenericDb->Lock, WriteIrql);
    NDIS_UNLOCK(&pPattern->Lock);

    //
    // the generic pattern has been removed, 
    //

    READ_LOCK(&pSpecificDb->Lock, &ReadIrql);
    
    //
    // this will do the rest of the work...
    //
    
    scanPatHashTable(
                     pSpecificDb->pDb,
                     (char *)PatternBits,
                     (char *)MaskBits,
                     (PVOID)&ScanStruct,
                     GpcSpecificCallback   // see callback routine...
                     );
    
    READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    //
    // time to go to the big hunting fields....
    //
    REFDEL(&pPattern->RefCount, 'ADGP');

	TRACE(PATTERN, pPattern, Status, "RemoveGenericPattern==>");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcdbg.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCDBG
#define __GPCDBG

//***   gpcdbg.h - GPC definitions & prototypes for debug/memory handling
//


#define GPC_MEM_MARK     'KRAM'


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/





#if DBG


#undef ASSERT
#define ASSERT( Value ) \
{                       \
    if ((ULONG_PTR)(Value) == 0) {   \
        KdPrint(("** ASSERT Failed ** %s\n",#Value));\
        KdPrint(("Assert Failed at line %d in file %s\n",__LINE__,__FILE__));\
        DbgBreakPoint();                                                     \
    }                                                                        \
}

//
// DBG=1
//

#define GpcAllocMem( _pAddress,_Length,_Tag )                          \
{                                                                      \
    PCHAR   _Addr;                                                     \
    ULONG   _Size = (((_Length)+3)&0xfffffffc) + 3*sizeof(ULONG);      \
    _Addr=ExAllocatePoolWithTag(NonPagedPool,_Size,_Tag );             \
    TRACE(MEMORY,_Addr+8,_Length,"GpcAllocMem");                       \
    if (_Addr) {                                                       \
        NdisFillMemory(_Addr, _Size, 0x7f);                            \
        *(PULONG)_Addr = _Size;                                        \
        *(PULONG)(_Addr+sizeof(ULONG)) = GPC_MEM_MARK;                 \
        *(PULONG)(_Addr+_Size-sizeof(ULONG)) = GPC_MEM_MARK;           \
        (PVOID)(*_pAddress) = (PVOID)(_Addr + 2*sizeof(ULONG));        \
        BytesAllocated += _Size;                                       \
    } else {                                                           \
        *_pAddress = NULL;                                             \
    }                                                                  \
}

#define GpcAllocMemWithQuota( _pAddress,_Length,_Tag )                          \
{                                                                      \
    PCHAR   _Addr;                                                     \
    ULONG   _Size = (((_Length)+3)&0xfffffffc) + 3*sizeof(ULONG);      \
    try{                                                                                                   \
    _Addr=ExAllocatePoolWithQuotaTag(NonPagedPool,_Size,_Tag );             \
    }                                                                                                       \
    except( EXCEPTION_EXECUTE_HANDLER)  {                                         \
    _Addr=NULL;                                                                                     \
    }                                                                                                      \
    TRACE(MEMORY,_Addr+8,_Length,"GpcAllocMem");                       \
    if (_Addr) {                                                       \
        NdisFillMemory(_Addr, _Size, 0x7f);                            \
        *(PULONG)_Addr = _Size;                                        \
        *(PULONG)(_Addr+sizeof(ULONG)) = GPC_MEM_MARK;                 \
        *(PULONG)(_Addr+_Size-sizeof(ULONG)) = GPC_MEM_MARK;           \
        (PVOID)(*_pAddress) = (PVOID)(_Addr + 2*sizeof(ULONG));        \
        BytesAllocated += _Size;                                       \
    } else {                                                           \
        *_pAddress = NULL;                                             \
    }                                                                  \
}




#define GpcFreeMem( _Address,_Tag )                                    \
{                                                                      \
    PCHAR _Addr = ((PUCHAR)_Address) - 2*sizeof(ULONG);                \
    ULONG _Size = *(PULONG)_Addr;                                      \
    TRACE(MEMORY,_Address,_Size-12,"GpcFreeMem");                      \
    ASSERT(*(PULONG)(_Addr+sizeof(ULONG)) == GPC_MEM_MARK);            \
    ASSERT(*(PULONG)(_Addr+_Size-sizeof(ULONG)) == GPC_MEM_MARK);      \
    NdisFillMemory(_Addr, _Size, 0xCC);                                \
    ExFreePool( _Addr );                                               \
    BytesAllocated -= _Size;                                           \
}


#define GpcAllocFromLL(_ptr, _list, _tag)                              \
{                                                                      \
    PCHAR _Addr;                                                       \
    if (_Addr = (PCHAR)NdisAllocateFromNPagedLookasideList(_list)) {   \
    	*(PULONG)(_Addr) = GPC_MEM_MARK;                               \
    	(PVOID)(*_ptr) = (PVOID)(_Addr + sizeof(ULONG_PTR));           \
    	TRACE(MEMORY,_tag,*_ptr,"GpcAllocFromLL");                     \
    } else {														   \
        *_ptr = NULL;                                                  \
    }        														   \
}


#define GpcFreeToLL(_ptr, _list, _tag)                                 \
{                                                                      \
    PCHAR _Addr = ((PUCHAR)_ptr) - sizeof(ULONG_PTR);                  \
    ASSERT(*(PULONG)_Addr == GPC_MEM_MARK);                            \
    *(PULONG)_Addr = 0x77777777;                                       \
    NdisFreeToNPagedLookasideList(_list, _Addr);                       \
    TRACE(MEMORY,_tag,_ptr,"GpcFreeToLL");                             \
}


#define GET_IRQL(_i)      _i = KeGetCurrentIrql()
#define VERIFY_IRQL(_i)   ASSERT((_i)==KeGetCurrentIrql())
#define DEFINE_KIRQL(_i)  KIRQL _i

#else     // DBG != 1



#define GpcAllocMem( Addr,Len,_Tag ) \
    *Addr = ExAllocatePoolWithTag(NonPagedPool, Len, _Tag )


#define GpcAllocMemWithQuota( Addr,Len,_Tag ) \
    try{                                                                                                   \
    *Addr=ExAllocatePoolWithQuotaTag(NonPagedPool,Len,_Tag );             \
    }                                                                                                       \
    except( EXCEPTION_EXECUTE_HANDLER)  {                                         \
    *Addr=NULL;                                                                                     \
    }                                                                                                      

#define GpcFreeMem( Address,_Tag )   \
    ExFreePool( (Address) )

#define GpcAllocFromLL(_ptr, _list, _tag) \
    *_ptr = NdisAllocateFromNPagedLookasideList(_list)

#define GpcFreeToLL(_ptr, _list, _tag)    \
    NdisFreeToNPagedLookasideList(_list, _ptr)

#define GET_IRQL(_i)
#define VERIFY_IRQL(_i)
#define DEFINE_KIRQL(_i)

#endif // if DBG



#if DBG
#define LockedIncrement( Count,_p )   LockedInc(Count,__FILE__,__LINE__,_p)
#else
#define LockedIncrement( Count,_p )   NdisInterlockedIncrement((PLONG)Count)
#endif

#if DBG
#define LockedDecrement( Count,_p )   LockedDec(Count,__FILE__,__LINE__,_p)
#else
#define LockedDecrement( Count,_p )   NdisInterlockedDecrement((PLONG)Count)
#endif

#define KD_PRINT     0x00000001
#define INIT         0x00000002
#define BLOB         0x00000004
#define PATTERN      0x00000008
#define NOTIFY       0x00000010
#define REGISTER     0x00000020
#define MEMORY       0x00000040
#define LOOKUP       0x00000080
#define LOCKS        0x00000100
#define CLASSIFY     0x00000200
#define RHIZOME      0x00000400
#define PATHASH      0x00000800
#define IOCTL        0x00001000
#define CLIENT       0x00002000
#define MAPHAND      0x00004000
#define CLASSHAND    0x00008000
#define PAT_TIMER    0x00010000
#define REFCOUNT     0x00020000
#define PARAM_EX     0x80000000   // this is reserved for the trace routine

#if DBG
#define DBGPRINT(Mask, String) \
{ \
 if(Mask & DbgPrintFlags)\
  DbgPrint String;\
}

#define TRACE( Mask,P1,P2,_fname )  \
{ \
 if (Mask & DebugFlags)\
  TraceRtn((PUCHAR)__FILE__,(ULONG)__LINE__,_fname,(ULONG_PTR)(P1),(ULONG_PTR)(P2),KeGetCurrentProcessorNumber(),KeGetCurrentIrql(),Mask|PARAM_EX);\
}

#else

#define DBGPRINT(Mask, String)
#define TRACE( Mask,P1,P2,_fname )

#endif



/*
/////////////////////////////////////////////////////////////////
//
//   externs & prototypes
//
/////////////////////////////////////////////////////////////////
*/

extern ULONG       DebugFlags;
extern ULONG       DbgPrintFlags;
extern ULONG       BytesAllocated;

VOID
TraceRtn(
        IN  UCHAR       *File,
        IN  ULONG       Line,
        IN  UCHAR       *FuncName,
        IN  ULONG_PTR   Param1,
        IN  ULONG_PTR   Param2,
        IN  ULONG   	Param3,
        IN  ULONG   	Param4,
        IN  ULONG       Mask
        );


_inline LONGLONG
GetTime(
    VOID
    )

/*++

Routine Description:

    Get the current system time

Arguments:


Return Value:

    System time (in base OS time units)

--*/

{
    LARGE_INTEGER Now;
    LARGE_INTEGER Frequency;

#if defined(PERF_COUNTER) || defined (TRACE_PERF_COUNTER)
    Now = KeQueryPerformanceCounter(&Frequency);
    Now.QuadPart = (Now.QuadPart * OS_TIME_SCALE) / Frequency.QuadPart;
#else
    NdisGetCurrentSystemTime( &Now );
#endif

    return Now.QuadPart;
}


#define LOGSIZE     4000  // number of entries
#define LOGWIDTH    64  // number of characters (one or two bytes) per entry


//
//
typedef struct {

    UCHAR   	Row[ LOGWIDTH ];
    LONGLONG	Time;
    ULONG		Line;
    ULONG_PTR	P1;
    ULONG_PTR	P2;
    ULONG		P3;
    ULONG		P4;

} ROW, *PROW;

typedef struct {

    ULONG   Index;
    PROW    Current;
    PROW    Buffer;
    ULONG	Wraps;

} LOG, *PLOG;

_inline VOID
DbgVerifyList(
           PLIST_ENTRY h
           )
{
    PLIST_ENTRY p = h->Flink;
    PLIST_ENTRY q = h;
    int			m = 1000;

    if (h->Flink == h) {
        ASSERT(h->Blink == h);
    }

    while (p != h && m > 0) {

        ASSERT(p->Blink == q);
        q = p;
        p = p->Flink;
        m--;
    }

    ASSERT(m > 0);
}


#endif //__GPCDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcdef.h ===
/*********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCDEF
#define __GPCDEF

//***   gpcdef.h - GPC internal definitions & prototypes
//
//  This file containes all the GPC data structures & defines


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

//
// Max number of clients per blob (same CF)
//
// AbhisheV - This can not be more than sizeof(ULONG)*8.
//

#define MAX_CLIENTS_CTX_PER_BLOB 32


//
// Max pattern size,
// GPC_IP_PATTERN = 24 bytes
// GPC_IPX_PATTERN = 24 bytes
//
#define MAX_PATTERN_SIZE	    sizeof(GPC_IP_PATTERN)

extern BOOLEAN IsItChanging;

//
// Pattern flags
//
#define PATTERN_SPECIFIC		0x00000001
#define PATTERN_AUTO			0x00000002
#define PATTERN_REMOVE_CB_BLOB	0x00000004
// Following flag to be set and unset only in addspecificpatternwithtimer.
// It indicates pattern has been created but not on timer list yet.
// It is set  before inserting it into the hash table i.e calling 
// AddSpecificPattern.
// It is supposed to be reset after putting pattern on timer list
// which in turn should occur after the pattern has been added into
// the hash table i.e. a successful call to addspecificpattern
#define PATTERN_AUTO_NOT_READY  0x00000008 

//
// Auto Pattern defines
//

// Every PATTERN_TIMEOUT seconds, the PatternTimerExpiry Routine gets called.
#define PATTERN_TIMEOUT	                60000		// 60 seconds

// This is the amount of time that a Pattern created for optimization 
// lives on the Pattern List.
#define AUTO_PATTERN_ENTRY_TIMEOUT      300000      // 5 minutes

// This is the number of timer granularity.
#define NUMBER_OF_WHEELS	 	        (AUTO_PATTERN_ENTRY_TIMEOUT/PATTERN_TIMEOUT)

//
// The size of structure to be allocated for TCP query with 1 address
#define ROUTING_INFO_ADDR_1_SIZE \
	     FIELD_OFFSET(GPC_TCP_QUERY_CONTEXT ,RouteInfo) + \
            FIELD_OFFSET(TDI_ROUTING_INFO, Address) + \
            FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + \
            FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)

// 
// For 2 addresses
#define ROUTING_INFO_ADDR_2_SIZE ROUTING_INFO_ADDR_1_SIZE + \
            FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)



// New debug locks [ShreeM]
// This will enable us to figure out who took the lock last
// and who released it last. New structure defined below and
// lock_acquire and lock_release macros are redefined later.

typedef struct _GPC_LOCK {

    NDIS_SPIN_LOCK			Lock;

#if DBG
    PETHREAD    CurrentThread;
    KIRQL       CurrentIRQL;
    LONG        LockAcquired;             // is it current held?
    UCHAR       LastAcquireFile[8];       
    ULONG       LastAcquireLine;
    UCHAR       LastReleaseFile[8];
    ULONG       LastReleaseLine;
#endif

} GPC_LOCK, PGPC_LOCK;

//
//
// states for blobs, patterns and more
//
typedef enum {

    GPC_STATE_READY = 0,
    GPC_STATE_INIT,
    GPC_STATE_ADD,
    GPC_STATE_MODIFY,
    GPC_STATE_REMOVE,   
    GPC_STATE_FORCE_REMOVE,
    GPC_STATE_DELETE,
    GPC_STATE_INVALID,
    GPC_STATE_NOTREADY,
    GPC_STATE_ERROR,
    GPC_STATE_PENDING

} GPC_STATE;


//
// ObjectVerification macro
//
#define VERIFY_OBJECT(_obj, _val) if(_obj) \
        {if(*(GPC_ENUM_OBJECT_TYPE *)_obj!=_val) return STATUS_INVALID_HANDLE;}
//Use this macro when you want to catch the error and not directly 
//return from the function
#define VERIFY_OBJECT_WITH_STATUS(_obj, _val,__status) if(_obj) \
        {if(*(GPC_ENUM_OBJECT_TYPE *)_obj!=_val) __status = STATUS_INVALID_HANDLE;}


//
// define event log error codes
//
#define GPC_ERROR_INIT_MAIN         0x00010000
#define GPC_ERROR_INIT_IOCTL        0x00020000


#define GPC_FLAGS_USERMODE_CLIENT   0x80000000

#define IS_USERMODE_CLIENT(_pc)	\
	TEST_BIT_ON((_pc)->Flags,GPC_FLAGS_USERMODE_CLIENT)

#define IS_USERMODE_CLIENT_EX(_pc)  \
        TEST_BIT_ON((_pc)->Flags,GPC_FLAGS_USERMODE_CLIENT_EX)


//
// for ioctl
//
#define SHUTDOWN_DELETE_DEVICE          0x00000100
#define SHUTDOWN_DELETE_SYMLINK         0x00000200

//
// helper macros
//
#define TEST_BIT_ON(_v,_b)          (((_v)&(_b))==(_b))
#define TEST_BIT_OFF(_v,_b)         (((_v)&(_b))==0)



//
// Define Default AutoPatternLimits
//

#define DEFAULT_SMALL_SYSTEM_AUTO_PATTERN_LIMIT         2000
#define DEFAULT_MEDIUM_SYSTEM_AUTO_PATTERN_LIMIT       8000
#define DEFAULT_LARGE_SYSTEM_AUTO_PATTERN_LIMIT          12000

//
// Define Registry settings to read into 
//
#define GPC_REG_KEY                       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\GPC"

// 
// Work Buffer size for reading from the registry
//
#define WORK_BUFFER_SIZE  256

//
// Reg Key under which the limit on the number of autopatterns is stored
//
#define GPC_REG_AUTO_PATTERN_LIMIT          L"AutoPatternLimit"
#define GPC_AUTO_PATTERN_MIN 2000
#define GPC_AUTO_PATTERN_MAX 20000

#if DBG

#define NDIS_INIT_LOCK(_sl) {\
        NdisAllocateSpinLock(&(_sl)->Lock); \
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"LOCK");\
        (_sl)->LockAcquired = -1; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_LOCK(_sl)  {\
      	NdisAcquireSpinLock(&(_sl)->Lock);\
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"LOCK");\
        (_sl)->LockAcquired = TRUE; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_UNLOCK(_sl) {\
        (_sl)->LockAcquired = FALSE; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
       	TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"UNLOCK");\
        NdisReleaseSpinLock(&(_sl)->Lock);\
}

#define NDIS_DPR_LOCK(_sl) {\
        NdisDprAcquireSpinLock(&(_sl)->Lock);\
		TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"DPR_LOCK");\
		(_sl)->LockAcquired = TRUE; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_DPR_UNLOCK(_sl) {\
        (_sl)->LockAcquired = FALSE; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"DPR_UNLOCK");\
        NdisDprReleaseSpinLock(&(_sl)->Lock);\
}

#else

#define NDIS_INIT_LOCK(_sl)      NdisAllocateSpinLock(&(_sl)->Lock)
#define NDIS_LOCK(_sl)           NdisAcquireSpinLock(&(_sl)->Lock)
#define NDIS_UNLOCK(_sl)         NdisReleaseSpinLock(&(_sl)->Lock)
#define NDIS_DPR_LOCK(_sl)       NdisDprAcquireSpinLock(&(_sl)->Lock)
#define NDIS_DPR_UNLOCK(_sl)     NdisDprReleaseSpinLock(&(_sl)->Lock)

#endif

#if DBG && EXTRA_DBG
#define VERIFY_LIST(_l) DbgVerifyList(_l)
#else
#define VERIFY_LIST(_l)
#endif

#define GpcRemoveEntryList(_pl) {PLIST_ENTRY _q = (_pl)->Flink;VERIFY_LIST(_pl);RemoveEntryList(_pl);InitializeListHead(_pl);VERIFY_LIST(_q);}
#define GpcInsertTailList(_l,_e) VERIFY_LIST(_l);InsertTailList(_l,_e);VERIFY_LIST(_e)
#define GpcInsertHeadList(_l,_e) VERIFY_LIST(_l);InsertHeadList(_l,_e);VERIFY_LIST(_e)

#if 0
#define GpcInterlockedInsertTailList(_l,_e,_s) \
	NdisInterlockedInsertTailList(_l,_e,_s)

#else

#define GpcInterlockedInsertTailList(_l,_e,_s) \
	{NDIS_LOCK(_s);VERIFY_LIST(_l);InsertTailList(_l,_e);VERIFY_LIST(_l);NDIS_UNLOCK(_s);}
#endif


#if NEW_MRSW

#define INIT_LOCK				 InitializeMRSWLock
#define READ_LOCK                EnterReader
#define READ_UNLOCK              ExitReader
#define WRITE_LOCK               EnterWriter
#define WRITE_UNLOCK             ExitWriter

#else

#define INIT_LOCK				 InitializeMRSWLock
#define READ_LOCK                AcquireReadLock
#define READ_UNLOCK              ReleaseReadLock
#define WRITE_LOCK               AcquireWriteLock
#define WRITE_UNLOCK             ReleaseWriteLock

#endif

//
// Get the CF index from the client block
//
#define GetCFIndexFromClient(_cl) (((PCLIENT_BLOCK)(_cl))->pCfBlock->AssignedIndex)

//
// Get the client index from the client block
//
#define GetClientIndexFromClient(_cl) (((PCLIENT_BLOCK)(_cl))->AssignedIndex)

//
// return the blob block pointer for the pattern:
// for specific patterns - its the blob entry in the CB
// for generic patterns  - its the pBlobBlock
//
#define GetBlobFromPattern(_p,_i)  (_p)->arpBlobBlock[_i]


//
// return the index bit to the ULONG
//
#define ReleaseClientIndex(_v,_i)  _v&=~(1<<_i) // clear the bit

//
// statistics macros
//
#define StatInc(_m)   (glStat._m)++
#define StatDec(_m)   (glStat._m)--
#define CfStatInc(_cf,_m)   (glStat.CfStat[_cf]._m)++
#define CfStatDec(_cf,_m)   (glStat.CfStat[_cf]._m)--
#define ProtocolStatInc(_p,_m)   (glStat.ProtocolStat[_p]._m)++
#define ProtocolStatDec(_p,_m)   (glStat.ProtocolStat[_p]._m)--

/*
/////////////////////////////////////////////////////////////////
//
//   typedef
//
/////////////////////////////////////////////////////////////////
*/


//
// completion opcodes
//
typedef enum {

    OP_ANY_CFINFO,
    OP_ADD_CFINFO,
    OP_MODIFY_CFINFO,
    OP_REMOVE_CFINFO

} GPC_COMPLETION_OP;


//
// define object type enum for handle verification
//
typedef enum {

    GPC_ENUM_INVALID,
    GPC_ENUM_CLIENT_TYPE,
    GPC_ENUM_CFINFO_TYPE,
    GPC_ENUM_PATTERN_TYPE

} GPC_ENUM_OBJECT_TYPE;


typedef struct _CF_BLOCK CF_BLOCK;
typedef struct _PATTERN_BLOCK PATTERN_BLOCK;


//
// A queued notification structure
//
typedef struct _QUEUED_NOTIFY {

    LIST_ENTRY   			Linkage;
    GPC_NOTIFY_REQUEST_RES	NotifyRes;
	PFILE_OBJECT 			FileObject;

} QUEUED_NOTIFY, *PQUEUED_NOTIFY;


//
// A queued completion structure
//
typedef struct _QUEUED_COMPLETION {

    GPC_COMPLETION_OP	OpCode;			// what completed
    GPC_HANDLE			ClientHandle;
    GPC_HANDLE			CfInfoHandle;
    GPC_STATUS			Status;

} QUEUED_COMPLETION, *PQUEUED_COMPLETION;


//
// A pending IRP structure
//
typedef struct _PENDING_IRP {

    LIST_ENTRY   		Linkage;

    PIRP         		Irp;
	PFILE_OBJECT 		FileObject;
    QUEUED_COMPLETION	QComp;

} PENDING_IRP, *PPENDING_IRP;


#if NEW_MRSW

//
// Multiple Readers Single Write definitions
// code has been taken from (tdi\tcpipmerge\ip\ipmlock.h)
//

typedef struct _MRSW_LOCK 
{
    KSPIN_LOCK rlReadLock;
    KSPIN_LOCK rlWriteLock;
    LONG       lReaderCount;
} MRSW_LOCK, *PMRSW_LOCK;

#else

//
// Multiple Readers Single Write definitions
// code has been taken from the filter driver project (routing\ip\fltrdrvr)
//

typedef struct _MRSW_LOCK 
{
    KSPIN_LOCK      SpinLock;
    LONG            ReaderCount;
} MRSW_LOCK, *PMRSW_LOCK;

#endif


//
// The generic pattern database struct
//
typedef struct _GENERIC_PATTERN_DB {

    MRSW_LOCK	Lock;
    Rhizome	   *pRhizome;     // pointer to a Rhizome

} GENERIC_PATTERN_DB, *PGENERIC_PATTERN_DB;



//
// A client block is used to store specific client context
//
typedef struct _CLIENT_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;

    LIST_ENTRY				ClientLinkage; // client blocks list link
	LIST_ENTRY				BlobList;     // list of blobs of the client

    CF_BLOCK		   	   *pCfBlock;
    GPC_CLIENT_HANDLE		ClientCtx;
    ULONG					AssignedIndex;
    ULONG					Flags;
    ULONG					State;
    GPC_LOCK			    Lock;
    REF_CNT                 RefCount;
    PFILE_OBJECT			pFileObject;	// used for async completion
    GPC_HANDLE				ClHandle;		// handle returned to the client
    GPC_CLIENT_FUNC_LIST	FuncList;

} CLIENT_BLOCK, *PCLIENT_BLOCK;


//
// A blob (A.K.A CF_INFO) block holds a GPC header + client specific data
//
typedef struct _BLOB_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;

	LIST_ENTRY				ClientLinkage;   // linked on the client
	LIST_ENTRY				PatternList;     // head of pattern linked list
    LIST_ENTRY				CfLinkage;		 // blobs on the CF

    //PCLIENT_BLOCK			pClientBlock;	 // pointer to installer
    REF_CNT					RefCount;
    GPC_STATE				State;
    ULONG					Flags;
    GPC_CLIENT_HANDLE		arClientCtx[MAX_CLIENTS_CTX_PER_BLOB];
    ULONG                   ClientStatusCountDown;
    GPC_STATUS              LastStatus;
    GPC_LOCK                Lock;
    CTEBlockStruc			WaitBlockAddFailed;
    PCLIENT_BLOCK			arpClientStatus[MAX_CLIENTS_CTX_PER_BLOB];
    ULONG					ClientDataSize;
    PVOID					pClientData;
    ULONG					NewClientDataSize;
    PVOID					pNewClientData;
    PCLIENT_BLOCK			pOwnerClient;
    PCLIENT_BLOCK			pCallingClient;
    PCLIENT_BLOCK			pCallingClient2;
    HANDLE					OwnerClientHandle;
    GPC_CLIENT_HANDLE		OwnerClientCtx;
    GPC_HANDLE				ClHandle;	// handle returned to the client
     // New fields to keep track of the additional information
    //
    // Rules:
    // (1) FileObject is referenced if NOT NULL
    // (2) Pattern needs to be freed if NOT NULL; should be used for AddPattern
    //
    PFILE_OBJECT    FileObject;
    PGPC_IP_PATTERN     Pattern;

    //

    //
    // assume only one client can accept the flow
    //
    PCLIENT_BLOCK			pNotifiedClient;
    GPC_CLIENT_HANDLE		NotifiedClientCtx;

#if NO_USER_PENDING
    CTEBlockStruc			WaitBlock;
#endif

} BLOB_BLOCK, *PBLOB_BLOCK;

//
// The classification block is an array of blob pointers
//
typedef struct _CLASSIFICATION_BLOCK {

    REF_CNT         RefCount;
    ULONG			NumberOfElements;
    HFHandle		ClassificationHandle;  // how to get back to index tbl

    // must be last
    PBLOB_BLOCK		arpBlobBlock[1];

} CLASSIFICATION_BLOCK, *PCLASSIFICATION_BLOCK;

//
// A pattern block holds specific data for the pattern
//
typedef struct _PATTERN_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;
    GPC_STATE               State;

    LIST_ENTRY				BlobLinkage[GPC_CF_MAX]; // linked on the blob
    LIST_ENTRY				TimerLinkage;

    PBLOB_BLOCK				arpBlobBlock[GPC_CF_MAX];
    PCLIENT_BLOCK		    pClientBlock;
    PCLIENT_BLOCK		    pAutoClient;
    PCLASSIFICATION_BLOCK	pClassificationBlock;
    ULONG                   WheelIndex;
    REF_CNT					RefCount;
    ULONG					ClientRefCount;
    ULONG					TimeToLive;				// for internal patterns
    ULONG					Flags;
    ULONG                   Priority;	// for generic pattern
    PVOID					DbCtx;
    GPC_LOCK                Lock;
    GPC_HANDLE				ClHandle;	// handle returned to the client
    ULONG					ProtocolTemplate;

} PATTERN_BLOCK, *PPATTERN_BLOCK;


//
// A CF block struct. This would construct a linked list of Cf blocks.
//
typedef struct _CF_BLOCK {

    REF_CNT                 RefCount;
    LIST_ENTRY				Linkage;		// on the global list
    LIST_ENTRY				ClientList;		// for the client blocks
    LIST_ENTRY				BlobList;		// list of blobs

    ULONG					NumberOfClients;
    ULONG					AssignedIndex;
    ULONG					ClientIndexes;
    GPC_LOCK			    Lock;
  	//MRSW_LOCK		   		ClientSync;
  	GPC_LOCK	   	        ClientSync;
    ULONG					MaxPriorities;
    PGENERIC_PATTERN_DB		arpGenericDb[GPC_PROTOCOL_TEMPLATE_MAX];

} CF_BLOCK, *PCF_BLOCK;


typedef struct _SPECIFIC_PATTERN_DB {

    MRSW_LOCK	   Lock;
    PatHashTable   *pDb;

} SPECIFIC_PATTERN_DB, *PSPECIFIC_PATTERN_DB;


typedef struct _FRAGMENT_DB {

    MRSW_LOCK   	Lock;
    PatHashTable   *pDb;

} FRAGMENT_DB, *PFRAGMENT_DB;


//
// A context structure to pass to the pathash scan routine
//
typedef struct _SCAN_STRUCT {

    PCLIENT_BLOCK	pClientBlock;
    PPATTERN_BLOCK	pPatternBlock;
    PBLOB_BLOCK		pBlobBlock;
    ULONG			Priority;
    BOOLEAN         bRemove;

} SCAN_STRUCT, *PSCAN_STRUCT;


//
// A protocol block holds pointers to databases for a specific 
// protocol template
//
typedef struct _PROTOCOL_BLOCK {

    LIST_ENTRY                      TimerPatternList[NUMBER_OF_WHEELS];
    ULONG                           CurrentWheelIndex;
    ULONG							SpecificPatternCount;
    ULONG                           GenericPatternCount;
    ULONG							AutoSpecificPatternCount;
    ULONG							ProtocolTemplate;
    ULONG							PatternSize;
    SPECIFIC_PATTERN_DB				SpecificDb;
    PVOID                           pProtocolDb;	// fragments
    GPC_LOCK					    PatternTimerLock[NUMBER_OF_WHEELS];
    NDIS_TIMER						PatternTimer;

} PROTOCOL_BLOCK, *PPROTOCOL_BLOCK;


//
// Global data block
//
typedef struct _GLOBAL_BLOCK {

    LIST_ENTRY			CfList;		// CF list head
    LIST_ENTRY          gRequestList; // Maintain a request list to deal with contention...
    GPC_LOCK		    Lock;
    GPC_LOCK		    RequestListLock;
    HandleFactory		*pCHTable;  // Hash table maps user mode handle to kmode pointer
    MRSW_LOCK	   		ChLock;		// lock for pCHTable
    PPROTOCOL_BLOCK		pProtocols;	// pointer to array of supported protocols
    MM_SYSTEMSIZE             SystemSizeHint;
    ULONG                            AutoPatternLimit;

} GLOBAL_BLOCK, *PGLOBAL_BLOCK;



//
// TCP Query Context . Allocated before calling TcpQueryInfo.
// When calling TcpQueryInfo only pass Offset into this structure 
// pointing at RouteInfo.
// into TCP.
// Initialize the TcpPattern with remote address and remote  port
// before the call and check on call completion if the values are
// of relevance : this will happen when protocol = UDP and stack 
// gives us only one IP address on TcpQueryInfo call completion
//
typedef struct _GPC_TCP_QUERY_CONTEXT
{
	PGPC_IP_PATTERN pTcpPattern;
	PMDL pMdl;
	//This should be the last field
	//ROUTING_INFO_ADDR_1_SIZE
	//depends on that
	TDI_ROUTING_INFO RouteInfo;
} GPC_TCP_QUERY_CONTEXT, *PGPC_TCP_QUERY_CONTEXT;
	

//
// New request block. This will be used to store the event and linkage.
// Therefore, when a thread needs to block, allocate a request_block, allocate
// an event, grab the requestlist lock , put this on the list and wait.
//
typedef struct _REQUEST_BLOCK {

    LIST_ENTRY              Linkage;
    NDIS_EVENT              RequestEvent;

}   REQUEST_BLOCK, *PREQUEST_BLOCK;

#if NEW_MRSW

//
// VOID
// InitRwLock(
//  PMRSW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//

#define InitializeMRSWLock(l) {                                 \
    KeInitializeSpinLock(&((l)->rlReadLock));                   \
    KeInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0;                                      \
}


//
// VOID
// EnterReader(
//  PMRSW_LOCK    pLock,
//  PKIRQL        pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//
#define EnterReader(l, q) {\
    KeAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    TRACE(LOCKS,l,*q,"EnterReader");                            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1) {       \
        TRACE(LOCKS,l,(l)->lReaderCount,"EnterReader1");        \
        KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
        TRACE(LOCKS,l,(l)->rlWriteLock,"EnterReader2");         \
    }                                                           \
    TRACE(LOCKS,l,(l)->lReaderCount,"EnterReader3");            \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

#define EnterReaderAtDpcLevel(l) {\
    KeAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

//
// VOID
// ExitReader(
//  PMRSW_LOCK    pLock,
//  KIRQL         kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q) {\
    TRACE(LOCKS,l,q,"ExitReader");\
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0) {       \
        TRACE(LOCKS,(l)->rlWriteLock,q,"ExitReader1");          \
        KeReleaseSpinLock(&((l)->rlWriteLock), q);              \
    }                                                           \
    else {                                                      \
        TRACE(LOCKS,l,(l)->lReaderCount,"ExitReader2");         \
        KeLowerIrql(q);                                         \
    }                                                           \
}

#define ExitReaderFromDpcLevel(l) {\
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));     \
}

//
// EnterWriter(
//  PMRSW_LOCK    pLock,
//  PKIRQL        pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q) {\
    KeAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    TRACE(LOCKS,l,*q,"EnterWriter");                            \
    TRACE(LOCKS,l,(l)->rlWriteLock,"EnterWrite1");              \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));           \
}

#define EnterWriterAtDpcLevel(l) {                              \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));           \
}


//
// ExitWriter(
//  PMRSW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q) {\
    TRACE(LOCKS,l,(l)->rlWriteLock,"ExitWrite1");               \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    TRACE(LOCKS,l,q,"ExitWrite1");                              \
    KeReleaseSpinLock(&((l)->rlReadLock), q);                   \
}


#define ExitWriterFromDpcLevel(l) {\
    KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

#else

#define InitializeMRSWLock(_pLock) {                       \
    (_pLock)->ReaderCount =    0;                          \
    KeInitializeSpinLock(&((_pLock)->SpinLock));           \
}

#define AcquireReadLock(_pLock,_pOldIrql) {                \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RL.1");   \
    KeAcquireSpinLock(&((_pLock)->SpinLock),_pOldIrql);    \
    InterlockedIncrement(&((_pLock)->ReaderCount));        \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RL.2");   \
    KeReleaseSpinLockFromDpcLevel(&((_pLock)->SpinLock));  \
	TRACE(LOCKS, _pLock, *(_pOldIrql), "RL.3");            \
}

#define ReleaseReadLock(_pLock,_OldIrql) {                 \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RU.1");   \
    InterlockedDecrement(&((_pLock)->ReaderCount));        \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RU.2");   \
    KeLowerIrql(_OldIrql);                                 \
	TRACE(LOCKS, _pLock, _OldIrql, "RU.3");                \
}

#define AcquireWriteLock(_pLock,_pOldIrql) {               \
	TRACE(LOCKS, _pLock, _pOldIrql, "WL.1");               \
    KeAcquireSpinLock(&((_pLock)->SpinLock),_pOldIrql);    \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WL.2");   \
    while(InterlockedDecrement(&((_pLock)->ReaderCount))>=0)\
    {                                                      \
        InterlockedIncrement (&((_pLock)->ReaderCount));   \
    }                                                      \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WL.3");   \
}

#define ReleaseWriteLock(_pLock,_OldIrql) {                \
 	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WU.1");   \
    InterlockedExchange(&(_pLock)->ReaderCount,0);         \
 	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WU.2");   \
    KeReleaseSpinLock(&((_pLock)->SpinLock),_OldIrql);     \
 	TRACE(LOCKS, _pLock, _OldIrql, "WU.3");                \
}

#endif

#if 1

#define RSC_READ_LOCK(_l,_i)		NDIS_LOCK(_l)
#define RSC_READ_UNLOCK(_l,_i)		NDIS_UNLOCK(_l)
#define RSC_WRITE_LOCK(_l,_i)		NDIS_LOCK(_l)
#define RSC_WRITE_UNLOCK(_l,_i)		NDIS_UNLOCK(_l)

#else

#define RSC_READ_LOCK		WRITE_LOCK
#define RSC_READ_UNLOCK		WRITE_UNLOCK
#define RSC_WRITE_LOCK		WRITE_LOCK
#define RSC_WRITE_UNLOCK	WRITE_UNLOCK

#endif

/*
/////////////////////////////////////////////////////////////////
//
//   IP definitions
//
/////////////////////////////////////////////////////////////////
*/

#define	DEFAULT_VERLEN		0x45		// Default version and length.
#define	IP_VERSION			0x40
#define	IP_VER_FLAG			0xF0
#define	IP_RSVD_FLAG		0x0080		// Reserved.
#define	IP_DF_FLAG			0x0040		// 'Don't fragment' flag
#define	IP_MF_FLAG			0x0020		// 'More fragments flag'
#define	IP_OFFSET_MASK		~0x00E0		// Mask for extracting offset field.

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))
#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))
#endif
/*
 * Protocols (from winsock.h)
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */
#define IPPROTO_IPSEC			51              /* ???????? */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// 
// UDP header definition
//
typedef struct _UDP_HEADER {
    ushort          uh_src;
    ushort          uh_dest;
    ushort          uh_length;
    ushort          uh_xsum;
} UDP_HEADER, *PUDP_HEADER;


//
//*	IP Header format.
//
typedef struct _IP_HEADER {

	uchar		iph_verlen;				// Version and length.
	uchar		iph_tos;				// Type of service.
	ushort		iph_length;				// Total length of datagram.
	ushort		iph_id;					// Identification.
	ushort		iph_offset;				// Flags and fragment offset.
	uchar		iph_ttl;				// Time to live.
	uchar		iph_protocol;			// Protocol.
	ushort		iph_xsum;				// Header checksum.
	ULONG		iph_src;				// Source address.
	ULONG		iph_dest;				// Destination address.

} IP_HEADER, *PIP_HEADER;


//
// Definition of the IPX header.
//
typedef struct _IPX_HEADER {

    USHORT 	CheckSum;
    UCHAR 	PacketLength[2];
    UCHAR 	TransportControl;
    UCHAR 	PacketType;
    UCHAR 	DestinationNetwork[4];
    UCHAR 	DestinationNode[6];
    USHORT 	DestinationSocket;
    UCHAR 	SourceNetwork[4];
    UCHAR 	SourceNode[6];
    USHORT 	SourceSocket;

} IPX_HEADER, *PIPX_HEADER;


/*
/////////////////////////////////////////////////////////////////
//
//   extern
//
/////////////////////////////////////////////////////////////////
*/

extern GLOBAL_BLOCK 		glData;
extern GPC_STAT       		glStat;

#ifdef STANDALONE_DRIVER
extern GPC_EXPORTED_CALLS  	glGpcExportedCalls;
#endif

// tags

extern ULONG					ClassificationFamilyTag;
extern ULONG					ClientTag;
extern ULONG					PatternTag;
extern ULONG					CfInfoTag;
extern ULONG					QueuedNotificationTag;
extern ULONG					PendingIrpTag;

extern ULONG					HandleFactoryTag;
extern ULONG					PathHashTag;
extern ULONG					RhizomeTag;
extern ULONG					GenPatternDbTag;
extern ULONG					FragmentDbTag;
extern ULONG					CfInfoDataTag;
extern ULONG					ClassificationBlockTag;
extern ULONG					ProtocolTag;
extern ULONG					DebugTag;
extern ULONG                             TcpPatternTag;
extern ULONG                             TcpQueryContextTag;


// Lookaside lists

extern NPAGED_LOOKASIDE_LIST	ClassificationFamilyLL;
extern NPAGED_LOOKASIDE_LIST	ClientLL;
extern NPAGED_LOOKASIDE_LIST	PatternLL;
//extern NPAGED_LOOKASIDE_LIST	CfInfoLL;
extern ULONG 					CfInfoLLSize;
extern NPAGED_LOOKASIDE_LIST	QueuedNotificationLL;
extern NPAGED_LOOKASIDE_LIST	PendingIrpLL;



/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/


NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


GPC_STATUS
InitSpecificPatternDb(
    IN	PSPECIFIC_PATTERN_DB	pDb,
    IN  ULONG					PatternSize
    );

GPC_STATUS
UninitSpecificPatternDb(
    IN	PSPECIFIC_PATTERN_DB	pDb
    );

GPC_STATUS
InitClassificationHandleTbl(
	IN	HandleFactory **ppCHTable
);

VOID
UninitClassificationHandleTbl(
	IN	HandleFactory *pCHTable
);
GPC_STATUS
InitializeGenericDb(
	IN  PGENERIC_PATTERN_DB	*ppGenericDb,
    IN  ULONG				 NumEntries,
    IN  ULONG				 PatternSize
);

VOID
UninitializeGenericDb(
	IN  PGENERIC_PATTERN_DB	*ppGenericDb,
    IN  ULONG				 NumEntries
    );

PCLIENT_BLOCK
CreateNewClientBlock(VOID);

VOID
ReleaseCfBlock(
	IN  PCF_BLOCK	pCf
    );

PCF_BLOCK
CreateNewCfBlock(
	IN	ULONG			CfId,
    IN	ULONG			MaxPriorities
    );

VOID
ReleaseClientBlock(
	IN  PCLIENT_BLOCK	pClientBlock
    );

PPATTERN_BLOCK
CreateNewPatternBlock(
	IN  ULONG	Flags
    );

VOID
ReleasePatternBlock(
	IN  PPATTERN_BLOCK	pPatternBlock
    );

PCLASSIFICATION_BLOCK
CreateNewClassificationBlock(
	IN  ULONG	NumEntries
    );

ULONG
AssignNewClientIndex(
	IN PCF_BLOCK	pCfBlock
    );

GPC_STATUS
AddGenericPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PUCHAR				pPatternBits,
    IN  PUCHAR				pMaskBits,
    IN  ULONG				Priority,
    IN  PBLOB_BLOCK			pBlob,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN OUT PPATTERN_BLOCK	*ppPattern
    );


GPC_STATUS
AddSpecificPattern(
	IN  PCLIENT_BLOCK			pClient,
    IN  PUCHAR					pPatternBits,
    IN  PUCHAR					pMaskBits,
    IN  PBLOB_BLOCK				pBlob,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN OUT PPATTERN_BLOCK		*ppPattern,
    OUT PCLASSIFICATION_HANDLE	pCH
    );

ULONG
GpcCalcHash(
	IN	ULONG				ProtocolTempId,
    IN	PUCHAR				pPattern
    );


VOID
DereferencePattern(
	IN  PPATTERN_BLOCK		pPattern
    );

VOID
DereferenceBlob(
	IN  PBLOB_BLOCK			pBlob
    );

PBLOB_BLOCK
CreateNewBlobBlock(
    IN  ULONG				ClientDataSize,
    IN  PVOID				pClientData,
    BOOLEAN                        fChargeQuota
    );

VOID
ReleaseBlobBlock(
    IN  PBLOB_BLOCK			pBlobBlock
    );

GPC_STATUS
HandleFragment(
	IN  PCLIENT_BLOCK		pClientBlock,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  BOOLEAN             bFirstFrag,
    IN  BOOLEAN             bLastFrag,
    IN  ULONG				PacketId,
    IN OUT PPATTERN_BLOCK   *ppPatternBlock,
    OUT PBLOB_BLOCK			*ppBlob
    );

NTSTATUS
InternalSearchPattern(
	IN  PCLIENT_BLOCK			pClientBlock,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  PVOID					pPatternKey,
    OUT PPATTERN_BLOCK          *ppPatternBlock,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle,
    IN  BOOLEAN					bNoCache
    );

GPC_STATUS
InitFragmentDb(
	IN  PFRAGMENT_DB   *ppFragDb
    );

GPC_STATUS
UninitFragmentDb(
               IN  PFRAGMENT_DB   pFragDb
);

VOID
DereferenceClient(
	IN  PCLIENT_BLOCK	pClient
    );


GPC_STATUS
ClientAddCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );
  
VOID
ClientAddCfInfoComplete(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    );

GPC_STATUS
ClientModifyCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   pClientData
    );

VOID
ClientModifyCfInfoComplete(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS	        	Status
    );

GPC_STATUS
ClientRemoveCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

VOID
ClientRemoveCfInfoComplete(
	IN	PCLIENT_BLOCK		pClient,
    IN	PBLOB_BLOCK         pBlob,
    IN	GPC_STATUS			Status
    );

GPC_STATUS
RemoveSpecificPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  PPATTERN_BLOCK		pPattern,
    IN  BOOLEAN             ForceRemoval,
    IN BOOLEAN DbLocked
    );

VOID
ClientRefsExistForSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern,
                      IN BOOLEAN dbLocked
                      );

VOID
ReadySpecificPatternForDeletion(
                                IN  PCLIENT_BLOCK	    pClient,
                                IN  PPROTOCOL_BLOCK		pProtocol,
                                IN  PPATTERN_BLOCK		pPattern,
                                IN BOOLEAN 	DbLocked
                                );

GPC_STATUS
RemoveGenericPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  PPATTERN_BLOCK		pPattern
    );

VOID
ReleaseClassificationBlock(
	IN  PCLASSIFICATION_BLOCK	pClassificationBlock
    );

VOID
ClearPatternLinks(
	IN  PPATTERN_BLOCK        	pPattern,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  ULONG                 	CfIndex
    );

VOID
ModifyCompleteClients(
	IN  PCLIENT_BLOCK   		pClient,
    IN  PBLOB_BLOCK     		pBlob
    );

//CLASSIFICATION_HANDLE
//GetClassificationHandle(
//	IN  PCLIENT_BLOCK   		pClient, 
//    IN  PPATTERN_BLOCK  		pPattern
//    );

VOID
FreeClassificationHandle(
	IN  PCLIENT_BLOCK          pClient,
    IN  CLASSIFICATION_HANDLE  CH
    );

GPC_STATUS
CleanupBlobs(
	IN  PCLIENT_BLOCK     		pClient
    );


VOID
GpcReadRegistry();

NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

VOID
GPC_REG_READ_DWORD(
	HANDLE hRegKey, 
	PWCHAR pwcName, 
	PULONG  pulData, 
	ULONG ulDefault,
	ULONG  ulMax, 
	ULONG ulMin);


#ifdef STANDALONE_DRIVER
/*
/////////////////////////////////////////////////////////////////
//
// GPC inetrface APIs
//
/////////////////////////////////////////////////////////////////
*/


GPC_STATUS
GpcGetCfInfoClientContext(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

GPC_CLIENT_HANDLE
GpcGetCfInfoClientContextWithRef(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    );

GPC_STATUS
GpcGetUlongFromCfInfo(
    IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG					Offset,
    IN	PULONG					pValue
    );

GPC_STATUS
GpcRegisterClient(
    IN	ULONG					CfId,
	IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
	IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
	IN	GPC_CLIENT_HANDLE		ClientContext,
	OUT	PGPC_HANDLE				pClientHandle
    );

GPC_STATUS
GpcDeregisterClient(
	IN	GPC_HANDLE				ClientHandle
    );

GPC_STATUS
GpcAddCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN  ULONG					CfInfoSize,
	IN	PVOID					pClientCfInfo,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	OUT	PGPC_HANDLE	    		pGpcCfInfoHandle
    );



GPC_STATUS
GpcAddPattern(
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					Pattern,
	IN	PVOID					Mask,
	IN	ULONG					Priority,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	OUT	PGPC_HANDLE				pGpcPatternHandle,
	OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

VOID
GpcAddCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

GPC_STATUS
GpcModifyCfInfo (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
	IN  PVOID	    			pClientCfInfo
    );

VOID
GpcModifyCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

GPC_STATUS
GpcRemoveCfInfo (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle
    );

VOID
GpcRemoveCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

GPC_STATUS
GpcRemovePattern (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcPatternHandle
    );

GPC_STATUS
GpcClassifyPattern (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID			        pPattern,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN		ULONG				Offset,
    IN		PULONG				pValue,
    IN		BOOLEAN				bNoCache
    );

GPC_STATUS
GpcClassifyPacket (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					pNdisPacket,
	IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		InterfaceId,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    );

GPC_STATUS
GpcEnumCfInfo (
	IN		GPC_HANDLE				ClientHandle,
    IN OUT 	PHANDLE					pCfInfoHandle,
    OUT    PHANDLE					pCfInfoMapHandle,
    IN OUT 	PULONG					pCfInfoCount,
    IN OUT 	PULONG					pBufferSize,
    OUT 	PGPC_ENUM_CFINFO_BUFFER	Buffer
    );

#endif // STANDALONE_DRIVER

GPC_STATUS
GetClientCtxAndUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	OUT PCLASSIFICATION_HANDLE	pClassificationHandle,
    OUT PGPC_CLIENT_HANDLE		pClientCfInfoContext,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    );


GPC_STATUS
privateGpcAddCfInfo(
    IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					CfInfoSize,
    IN	PVOID					pClientCfInfoPtr,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    IN       PFILE_OBJECT                     FileObject,
    IN       PGPC_IP_PATTERN              Pattern,
    OUT PGPC_HANDLE	    		pGpcCfInfoHandle
    );

GPC_STATUS
privateGpcRemoveCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	GPC_HANDLE				GpcCfInfoHandle,
    IN   ULONG					Flags
    );

GPC_STATUS
privateGpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle,
    IN  BOOLEAN         ForceRemoval,
    IN BOOLEAN DbLocked
    );

VOID
UMClientRemoveCfInfoNotify(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK				pBlob
    );


VOID
UMCfInfoComplete(
	IN	GPC_COMPLETION_OP		OpCode,
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    );

VOID
CloseAllObjects(
	IN	PFILE_OBJECT			FileObject,
    IN  PIRP					Irp
    );

NTSTATUS
IoctlInitialize(
    IN	PDRIVER_OBJECT DriverObject,
    IN	PULONG         InitShutdownMask
    );

NTSTATUS
CheckQueuedNotification(
	IN		PIRP	Irp,
    IN OUT  ULONG 	*outputBufferLength
    );

NTSTATUS
CheckQueuedCompletion(
	IN PQUEUED_COMPLETION		pQItem,
    IN PIRP              		Irp
    );

VOID
PatternTimerExpired(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					FunctionContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
    );

GPC_STATUS
AddSpecificPatternWithTimer(
	IN	PCLIENT_BLOCK			pClient,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					PatternKey,
    OUT	PPATTERN_BLOCK			*ppPattern,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

NTSTATUS
InitPatternTimer(
	IN	ULONG	ProtocolTemplate
    );


#endif // __GPCDEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcmain.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmain.c

Abstract:

    This file contains initialization stuff for the GPC
    and all the exposed APIs

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"


/*
/////////////////////////////////////////////////////////////////
//
//   globals
//
/////////////////////////////////////////////////////////////////
*/

NDIS_STRING 	DriverName = NDIS_STRING_CONST( "\\Device\\Gpc" );
GLOBAL_BLOCK    glData;

GPC_STAT        glStat;
static          _init_driver = FALSE;
ULONG			GpcMinorVersion = 0;

#ifdef STANDALONE_DRIVER
GPC_EXPORTED_CALLS			glGpcExportedCalls;
#endif

#if DBG
CHAR VersionTimestamp[] = __DATE__ " " __TIME__;
#endif

// tags

ULONG					QueuedNotificationTag = 'nqpQ';
ULONG					PendingIrpTag = 'ippQ';
ULONG					CfInfoTag = 'icpQ';
ULONG					ClientTag = 'tcpQ';
ULONG					PatternTag = 'appQ';

ULONG					HandleFactoryTag = 'fhpQ';	// Gphf
ULONG					PathHashTag = 'hppQ';
ULONG					RhizomeTag = 'zrpQ';
ULONG					GenPatternDbTag = 'dppQ';
ULONG					FragmentDbTag = 'dfpQ';
ULONG					ClassificationFamilyTag = 'fcpQ';
ULONG					CfInfoDataTag = 'dcpQ';
ULONG					ClassificationBlockTag = 'bcpQ';
ULONG					ProtocolTag = 'tppQ';
ULONG					DebugTag = 'gdpQ';
ULONG                                RequestBlockTag = 'brpQ';
ULONG                                TcpPatternTag = 'ptpQ';
ULONG                                TcpQueryContextTag= 'qtpQ';

// Lookaside lists

NPAGED_LOOKASIDE_LIST	ClassificationFamilyLL;
NPAGED_LOOKASIDE_LIST	ClientLL;
NPAGED_LOOKASIDE_LIST	PatternLL;
//NPAGED_LOOKASIDE_LIST	CfInfoLL;
NPAGED_LOOKASIDE_LIST	QueuedNotificationLL;
NPAGED_LOOKASIDE_LIST	PendingIrpLL;

ULONG 					ClassificationFamilyLLSize = sizeof( CF_BLOCK );
ULONG 					ClientLLSize = sizeof( CLIENT_BLOCK );
ULONG 					PatternLLSize = sizeof( PATTERN_BLOCK );
ULONG 					CfInfoLLSize = sizeof( BLOB_BLOCK );
ULONG 					QueuedNotificationLLSize = sizeof( QUEUED_NOTIFY );
ULONG 					PendingIrpLLSize = sizeof( PENDING_IRP );

/*
/////////////////////////////////////////////////////////////////
//
//   pragma
//
/////////////////////////////////////////////////////////////////
*/


//#pragma NDIS_INIT_FUNCTION(DriverEntry)

#if 0
#pragma NDIS_PAGEABLE_FUNCTION(DriverEntry)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRegisterClient)
#pragma NDIS_PAGEABLE_FUNCTION(GpcDeregisterClient)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddPattern)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcModifyCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcModifyCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemoveCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemoveCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemovePattern)
#endif

/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/

#if DBG
NTSTATUS
InitializeLog();

VOID
FreeDebugLog(
    VOID);

#endif

VOID
GpcUnload (
    IN PDRIVER_OBJECT DriverObject
    );

/*
************************************************************************

InitGpc - 

The initialization routine. It is getting called during load time
and is responsible to call other initialization code.

Arguments
	none

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitGpc(void)
{
    GPC_STATUS	Status = STATUS_SUCCESS;
    ULONG		i, k;

	TRACE(INIT, 0, 0, "InitGpc");

    //
    // init the global data
    //

    RtlZeroMemory(&glData, sizeof(glData));

    InitializeListHead(&glData.CfList);
	NDIS_INIT_LOCK(&glData.Lock);
    
    //
    // Create a new Request list for blocked requests... [276945]
    //
    InitializeListHead(&glData.gRequestList);
    NDIS_INIT_LOCK(&glData.RequestListLock);

    k = sizeof(PROTOCOL_BLOCK) * GPC_PROTOCOL_TEMPLATE_MAX;

    GpcAllocMem(&glData.pProtocols, k, ProtocolTag);

    if (glData.pProtocols == NULL) {

        Status = GPC_STATUS_NO_MEMORY;

        TRACE(INIT, Status, 0, "InitGpc==>");

        return Status;
    }

    RtlZeroMemory(glData.pProtocols, k);
    RtlZeroMemory(&glStat, sizeof(glStat));

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {

        if ((Status = InitPatternTimer(i)) != STATUS_SUCCESS) {
            
            TRACE(INIT, Status, i, "InitGpc, timer==>");
            
            break;
        }

        //
        // init rest of strcture
        //
        
        glData.pProtocols[i].ProtocolTemplate = i;
        glData.pProtocols[i].SpecificPatternCount = 0;
        glData.pProtocols[i].AutoSpecificPatternCount = 0;
        glData.pProtocols[i].GenericPatternCount = 0;

        switch (i) {

        case GPC_PROTOCOL_TEMPLATE_IP:

            k = sizeof(GPC_IP_PATTERN);
            break;

        case GPC_PROTOCOL_TEMPLATE_IPX:

            k = sizeof(GPC_IPX_PATTERN);
            break;

        default:
            ASSERT(0);
        }

        glData.pProtocols[i].PatternSize = k;

        //
        // init specific pattern db
        //
        
        Status = InitSpecificPatternDb(&glData.pProtocols[i].SpecificDb, k);
        
        if (!NT_SUCCESS(Status)) {
            
            TRACE(INIT, Status, 0, "InitGpc==>");
            
            break;
        }

        //
        // init fragments db
        //
        
        Status = InitFragmentDb((PFRAGMENT_DB *)&glData.pProtocols[i].pProtocolDb);
        
        if (!NT_SUCCESS(Status)) {

            // SS202
            // 
            UninitSpecificPatternDb(&glData.pProtocols[i].SpecificDb);
            
            TRACE(INIT, Status, 0, "InitGpc==>");
            
            break;
        }
        
    } 	// for (i...)

    if (!NT_SUCCESS (Status)) {
        TRACE(INIT, Status, 0, "InitGpc b");
        goto Cleanup;
    }
    
    //
    // init handle mapping table
    //

    Status = InitMapHandles();

    if (!NT_SUCCESS(Status)) {
	  
        TRACE(INIT, Status, 0, "InitGpc b");
        goto Cleanup;
    }

    //
    // init classification index table
    //

    Status = InitClassificationHandleTbl(&glData.pCHTable);

    if (!NT_SUCCESS(Status)) {
        TRACE(INIT, Status, 0, "InitGpc c");
        goto Cleanup;
    }


#ifdef STANDALONE_DRIVER

    //
    // initialize the exported calls table
    //

    glGpcExportedCalls.GpcVersion = GpcMajorVersion;
    glGpcExportedCalls.GpcGetCfInfoClientContextHandler = GpcGetCfInfoClientContext;
    glGpcExportedCalls.GpcGetCfInfoClientContextWithRefHandler = GpcGetCfInfoClientContextWithRef;
    glGpcExportedCalls.GpcGetUlongFromCfInfoHandler = GpcGetUlongFromCfInfo;
    glGpcExportedCalls.GpcRegisterClientHandler = GpcRegisterClient;
    glGpcExportedCalls.GpcDeregisterClientHandler = GpcDeregisterClient;
    glGpcExportedCalls.GpcAddCfInfoHandler = GpcAddCfInfo;
    glGpcExportedCalls.GpcAddPatternHandler = GpcAddPattern;
    glGpcExportedCalls.GpcAddCfInfoNotifyCompleteHandler = GpcAddCfInfoNotifyComplete;
    glGpcExportedCalls.GpcModifyCfInfoHandler = GpcModifyCfInfo;
    glGpcExportedCalls.GpcModifyCfInfoNotifyCompleteHandler = GpcModifyCfInfoNotifyComplete;
    glGpcExportedCalls.GpcRemoveCfInfoHandler = GpcRemoveCfInfo;
    glGpcExportedCalls.GpcRemoveCfInfoNotifyCompleteHandler = GpcRemoveCfInfoNotifyComplete;
    glGpcExportedCalls.GpcRemovePatternHandler = GpcRemovePattern;
    glGpcExportedCalls.GpcClassifyPatternHandler = GpcClassifyPattern;
    glGpcExportedCalls.GpcClassifyPacketHandler = GpcClassifyPacket;
    //glGpcExportedCalls.GpcEnumCfInfoHandler = GpcEnumCfInfo;

#endif

#if DBG

    //
    // for the debug version, add a ULONG_PTR for the GPC mark ULONG.
    // ULONG_PTR is used to ensure 8-byte alignment of the returned block on
    // 64-bit platforms.
    //

    ClassificationFamilyLLSize += sizeof( ULONG_PTR );
    ClientLLSize += sizeof( ULONG_PTR );
    PatternLLSize += sizeof( ULONG_PTR );
    CfInfoLLSize += sizeof( ULONG_PTR );
    QueuedNotificationLLSize += sizeof( ULONG_PTR );
    PendingIrpLLSize += sizeof( ULONG_PTR );
#endif

    NdisInitializeNPagedLookasideList(&ClassificationFamilyLL,
                                      NULL,
                                      NULL,
                                      0,
                                      ClassificationFamilyLLSize,
                                      ClassificationFamilyTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&ClientLL,
                                      NULL,
                                      NULL,
                                      0,
                                      ClientLLSize,
                                      ClientTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&PatternLL,
                                      NULL,
                                      NULL,
                                      0,
                                      PatternLLSize,
                                      PatternTag,
                                      (USHORT)0);

    /*NdisInitializeNPagedLookasideList(&CfInfoLL,
                                      NULL,
                                      NULL,
                                      0,
                                      CfInfoLLSize,
                                      CfInfoTag,
                                      (USHORT)0);*/

    NdisInitializeNPagedLookasideList(&QueuedNotificationLL,
                                      NULL,
                                      NULL,
                                      0,
                                      QueuedNotificationLLSize,
                                      QueuedNotificationTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&PendingIrpLL,
                                      NULL,
                                      NULL,
                                      0,
                                      PendingIrpLLSize,
                                      PendingIrpTag,
                                      (USHORT)0);
    //
    // Load cofiguration from registry
    // loads default values if reg keys not available
    //
    GpcReadRegistry();
    TRACE(INIT, Status, 0, "InitGpc==>");

Cleanup:
    // SS202
    // Much leaking above, needed common cleanup block
    //
    if (!NT_SUCCESS(Status))	
    {
        UninitMapHandles();
        if (glData.pProtocols != NULL)
        {
            for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) 
            {
                UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
                UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
            }
            GpcFreeMem(glData.pProtocols, ProtocolTag);
            glData.pProtocols = NULL;
        }            
    }
    
    return Status;
    }




/*
************************************************************************

DriverEntry -

The driver's entry point.

Arguments
	DriverObject - Pointer to the driver object created by the system.
        RegistryPath - string path to the registry.

Returns
	NT_STATUS

************************************************************************
*/
NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    GPC_STATUS		Status;
    ULONG			dummy = 0;
    PWCHAR          EventLogString = DriverName.Buffer;

    _init_driver = TRUE;


#if DBG

    //
    // first thing, init the trace log
    //

    Status = InitializeLog();

    if (Status != STATUS_SUCCESS) {
     
        KdPrint(("!!! GPC Failed to initialize trace log !!!\n", Status));
    }
#endif

    DriverObject->DriverUnload = GpcUnload;
    //
    // Call the init routine
    //
    
    Status = InitGpc();
    
    if (NT_SUCCESS(Status)) {
        
        //
        // initialize the file system device
        //
        
        Status = (GPC_STATUS)IoctlInitialize(DriverObject, &dummy);
        
        if (!NT_SUCCESS(Status)) {
            
            NdisWriteEventLogEntry(DriverObject,
                                   EVENT_TRANSPORT_REGISTER_FAILED,
                                   GPC_ERROR_INIT_IOCTL,
                                   1,
                                   &EventLogString,
                                   0,
                                   NULL);
        }

    } else {

        NdisWriteEventLogEntry(DriverObject,
                               EVENT_TRANSPORT_REGISTER_FAILED,
                               GPC_ERROR_INIT_MAIN,
                               1,
                               &EventLogString,
                               0,
                               NULL);
#if DBG
        FreeDebugLog ();
#endif
    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        KdPrint(("!!! GPC loading Failed (%08X) !!!\n", Status));        
    }
#endif

    return (NTSTATUS)Status;

} // end DriverEntry
VOID
GpcUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG i;

    NdisDeleteNPagedLookasideList(&ClassificationFamilyLL);
    NdisDeleteNPagedLookasideList(&ClientLL);
    NdisDeleteNPagedLookasideList(&PatternLL);
   // NdisDeleteNPagedLookasideList(&CfInfoLL);
    NdisDeleteNPagedLookasideList(&QueuedNotificationLL);
    NdisDeleteNPagedLookasideList(&PendingIrpLL);

    UninitClassificationHandleTbl(glData.pCHTable);
    UninitMapHandles();

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
        UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
        UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
    }
    GpcFreeMem(glData.pProtocols, ProtocolTag);
#if DBG
    FreeDebugLog ();
#endif

}




/*
************************************************************************

GpcGetCfInfoClientContext -

Returns the client context for blob

Arguments
    ClientHandle - the calling client's handle
	ClassificationHandle - needless to say

Returns
	A CfInfo client context or NULL if the classification 
	handle is invalid

************************************************************************
*/
GPC_STATUS
GpcGetCfInfoClientContext(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    )
{
    PBLOB_BLOCK				pBlob;
    GPC_CLIENT_HANDLE		h;
    KIRQL					CHirql;
    NTSTATUS                Status;
    PCLASSIFICATION_BLOCK   pCB;

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetCfInfoClientContext");

    pCB = NULL;

	if (ClientHandle == NULL) {
        
        *pClientCfInfoContext = NULL;
	    return GPC_STATUS_INVALID_PARAMETER;

    }

    READ_LOCK(&glData.ChLock, &CHirql);

	pBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            ClassificationHandle,
                            GetCFIndexFromClient(ClientHandle));

	if (pBlob == NULL) {
    
        pCB = dereference_HF_handle(
                                    glData.pCHTable,
                                    ClassificationHandle);

        READ_UNLOCK(&glData.ChLock, CHirql);

        if (!pCB) {

            Status = GPC_STATUS_INVALID_HANDLE;

        } else {
        
            Status = GPC_STATUS_NOT_FOUND;

        }

        *pClientCfInfoContext = 0;

        return Status;
    }

#if DBG
    {
        //
        // Get the client index to reference into the ClientCtx table
        //
        
        ULONG t = GetClientIndexFromClient(ClientHandle);

        ASSERT(t < MAX_CLIENTS_CTX_PER_BLOB);
        
        TRACE(CLASSIFY, ClassificationHandle, pBlob->arClientCtx[t],
              "GpcGetCfInfoClientContext (ctx)");
    }
#endif

    h = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

    READ_UNLOCK(&glData.ChLock, CHirql);

	TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContext==>");
    
    *pClientCfInfoContext = h;

    return GPC_STATUS_SUCCESS;
}


/*
************************************************************************

GpcGetCfInfoClientContextWithRef -

Returns the client context for blob and increments a Dword provided by
the client. This function can be used by clients to synchronize access
to their structures on the remove and send path.

Arguments
    ClientHandle - the calling client's handle
	ClassificationHandle - needless to say
    Offset - Offset to location that needs to be incremented.

Returns
	A CfInfo client context or NULL if the classification 
	handle is invalid

************************************************************************
*/
GPC_CLIENT_HANDLE
GpcGetCfInfoClientContextWithRef(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    )
{
    PBLOB_BLOCK				pBlob;
    GPC_CLIENT_HANDLE		h;
    KIRQL					CHirql;
    PULONG                  RefPtr = NULL;

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetCfInfoClientContextWithRef");

	if (ClientHandle == NULL)
	  return NULL;

    READ_LOCK(&glData.ChLock, &CHirql);

	pBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            ClassificationHandle,
                            GetCFIndexFromClient(ClientHandle));

    
	if (pBlob == NULL) {

        READ_UNLOCK(&glData.ChLock, CHirql);

        return NULL;

    } 
    
#if DBG
    {
        //
        // Get the client index to reference into the ClientCtx table
        //
        
        ULONG t = GetClientIndexFromClient(ClientHandle);

        ASSERT(t < MAX_CLIENTS_CTX_PER_BLOB);
        
        TRACE(CLASSIFY, ClassificationHandle, pBlob->arClientCtx[t],
              "GpcGetCfInfoClientContextWithRef (ctx)");
    }
#endif

    h = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

    //
    // As part of 390882, it has been noted that sometimes the handle can
    // NULL, this could be either due to an Auto pattern or a generic 
    // pattern.
    //
    if (!h) {
        
        READ_UNLOCK(&glData.ChLock, CHirql);
        TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContextWithRef==>");
        return NULL;

    }

    // The GPC Clients wants GPC to increment the memory at this offset.
    ASSERT(h);
    RefPtr = (PULONG) (((PUCHAR)h) + Offset);
    InterlockedIncrement(RefPtr);

    //(*((PUCHAR)h + Offset))++;

    READ_UNLOCK(&glData.ChLock, CHirql);

	TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContextWithRef==>");

    return h;
}




/*
************************************************************************

GpcGetUlongFromCfInfo -

Returns a ulong in the blob data pointer from the classification handle for
the particular client.

Arguments
    ClientHandle    - the client handle
    ClassificationHandle - the classification handle
    Offset          - oofset in bytes into the CfInfo structure
    pValue          - store for the returned value

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcGetUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    )
{
    KIRQL					irql;
    PCLASSIFICATION_BLOCK	pCB;
    PBLOB_BLOCK				pBlob;

    ASSERT( pValue );

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetUlongFromCfInfo");

	if (ClientHandle == NULL)
	  return GPC_STATUS_INVALID_PARAMETER;

    READ_LOCK(&glData.ChLock, &irql);

	pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(
							glData.pCHTable,
                            ClassificationHandle);

	if (pCB == NULL) {

        READ_UNLOCK(&glData.ChLock, irql);
    
        return GPC_STATUS_INVALID_HANDLE;
    }

    pBlob = pCB->arpBlobBlock[GetCFIndexFromClient(ClientHandle)];

    if (pBlob == NULL) {

        TRACE(CLASSIFY, pBlob, 0, "GpcGetUlongFromCfInfo-->");

        READ_UNLOCK(&glData.ChLock, irql);
    
        return GPC_STATUS_NOT_FOUND;
    }

	TRACE(CLASSIFY, ClassificationHandle, pBlob->pClientData, "GpcGetUlongFromCfInfo (2)");

    ASSERT( Offset+sizeof(ULONG) <= pBlob->ClientDataSize );
    ASSERT( pBlob->pClientData );

    if (pBlob->pClientData == NULL) {
        READ_UNLOCK(&glData.ChLock, irql);
        return (GPC_STATUS_FAILURE);
    }

    *pValue = *(PULONG)((PUCHAR)pBlob->pClientData + Offset);

    READ_UNLOCK(&glData.ChLock, irql);

	TRACE(CLASSIFY, pBlob, *pValue, "GpcGetUlongFromCfInfo==>");

    return GPC_STATUS_SUCCESS;
}




/*
************************************************************************

GetClientCtxAndUlongFromCfInfo -

Returns a ulong in the blob data pointer AND the client context
from the classification handle for the particular client.

Arguments
    ClientHandle    - the client handle
    ClassificationHandle - the classification handle
    Offset          - oofset in bytes into the CfInfo structure
    pValue          - store for the returned value

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GetClientCtxAndUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	OUT PCLASSIFICATION_HANDLE	pClassificationHandle,
    OUT PGPC_CLIENT_HANDLE		pClientCfInfoContext,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    )
{
    PCLASSIFICATION_BLOCK	pCB;
    KIRQL					irql;
    PBLOB_BLOCK				pBlob;

    ASSERT( ClientHandle );
    ASSERT( pClientCfInfoContext || pValue );

	TRACE(CLASSIFY, ClientHandle, pClassificationHandle, "GetClientCtxAndUlongFromCfInfo");

    READ_LOCK(&glData.ChLock, &irql);

	pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(
							glData.pCHTable,
                            *pClassificationHandle
                            );

	TRACE(CLASSIFY, pCB, GetCFIndexFromClient(ClientHandle), "GetClientCtxAndUlongFromCfInfo (2)");

	if (pCB == NULL) {

        //
        // didn't find the reference, which means the CH is probably invalid
        // reset it to 0 to indicate the caller that it should add a new one
        //

        *pClassificationHandle = 0;
        READ_UNLOCK(&glData.ChLock, irql);

        return GPC_STATUS_NOT_FOUND;
    }

    ASSERT(GetClientIndexFromClient(ClientHandle) < MAX_CLIENTS_CTX_PER_BLOB);

    pBlob = pCB->arpBlobBlock[GetCFIndexFromClient(ClientHandle)];

    if (pBlob == NULL) {

        TRACE(CLASSIFY, pBlob, 0, "GetClientCtxAndUlongFromCfInfo-->");

        READ_UNLOCK(&glData.ChLock, irql);

        return GPC_STATUS_NOT_FOUND;
    
    } 
    
    TRACE(CLASSIFY, *pClassificationHandle, pBlob->pClientData, "GetClientCtxAndUlongFromCfInfo (3)");

    ASSERT( Offset+sizeof(ULONG) <= pBlob->ClientDataSize );
    ASSERT( pBlob->pClientData );
    
    if (pClientCfInfoContext) {
        *pClientCfInfoContext = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

        TRACE(CLASSIFY, pBlob, *pClientCfInfoContext, "GetClientCtxAndUlongFromCfInfo==>");

    }

    if (pValue) {
        *pValue = *(PULONG)((PUCHAR)pBlob->pClientData + Offset);

        TRACE(CLASSIFY, pBlob, *pValue, "GetClientCtxAndUlongFromCfInfo==>");

    }

    READ_UNLOCK(&glData.ChLock, irql);

    return GPC_STATUS_SUCCESS;
}



/*
************************************************************************

GpcRegisterClient -

	This will register the client in the GPC and return a client handle.
    If another client already registered for the same CF, we link this one
    on a list for the CF. The first client for the CF will cause a CF block
    to be created. CFs are identified by CfName. The other parameters will also
    be set in the client's block.

Arguments
	CfId 				- Id of the classification family
    Flags				- operation modes for the client:
							CF_FRAGMENT
    MaxPriorities		- max number of priorities the client will ever use
    pClientFuncList		- list of callback functions
    ClientContext		- client context, GPC will use it in callbacks
    pClientHandle		- OUT, the returned client handle
    
Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRegisterClient(
	IN	ULONG					CfId,
    IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
    IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
    IN	GPC_CLIENT_HANDLE		ClientContext,
    OUT	PGPC_HANDLE				pClientHandle
    )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
    PCF_BLOCK		pCf;
    PCLIENT_BLOCK	pClient= NULL;
    ULONG			i;
    PLIST_ENTRY		pHead, pEntry;
    KIRQL			irql;

	TRACE(REGISTER, CfId, ClientContext, "GpcRegisterClient");

    *pClientHandle = NULL;

    if (!_init_driver) {

        return GPC_STATUS_NOTREADY;
    }

    //
    // verify the CF Id
    //

    if (CfId >= GPC_CF_MAX) {
        
        TRACE(REGISTER, GPC_STATUS_INVALID_PARAMETER, CfId, "GpcRegisterClient-->");
        StatInc(RejectedCf);

        return GPC_STATUS_INVALID_PARAMETER;
    }

    //
    // verify the maximum number of priorities
    //

    if (MaxPriorities > GPC_PRIORITY_MAX) {
        
        TRACE(REGISTER, GPC_STATUS_INVALID_PARAMETER, MaxPriorities, "GpcRegisterClient~~>");
        StatInc(RejectedCf);

        return GPC_STATUS_INVALID_PARAMETER;
    }

    if (MaxPriorities == 0) {
        MaxPriorities = 1;
    }

    //
    // find the CF or create a new one
    //

    NDIS_LOCK(&glData.Lock);

    pHead = &glData.CfList;
    pEntry = pHead->Flink;
    pCf = NULL;

    while (pCf == NULL && pEntry != pHead) {

        pCf = CONTAINING_RECORD(pEntry, CF_BLOCK, Linkage);

        if (pCf->AssignedIndex != CfId) {

            pCf = NULL;
        }

        pEntry = pEntry->Flink;
    }

    if (pCf == NULL) {

        //
        // create a new CF
        //

        pCf = CreateNewCfBlock(CfId, MaxPriorities);

        if (pCf == NULL) {

            NDIS_UNLOCK(&glData.Lock);

            return GPC_STATUS_NO_MEMORY;
        }
     
        //
        // add the new CF to the list
        //

        GpcInsertTailList(&glData.CfList, &pCf->Linkage);
    }

    //
    // grab the CF lock before releasing the global lock
    //

    NDIS_UNLOCK(&glData.Lock);

    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    NDIS_LOCK(&pCf->Lock);
    
    //
    // create a new client block and chain it on the CF block
    //

    pClient = CreateNewClientBlock();

    if (pClient == NULL) {

        //
        // oops
        //

        NDIS_UNLOCK(&pCf->Lock);

        RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

        TRACE(REGISTER, GPC_STATUS_RESOURCES, 0, "GpcRegisterClient==>");

        StatInc(RejectedCf);

        return GPC_STATUS_NO_MEMORY;
    }

    //
    // assign a new index to the client. This will also mark the index
    // as busy for this CF.
    //

    pClient->AssignedIndex = AssignNewClientIndex(pCf);

    if (pClient->AssignedIndex == (-1)) {

        //
        // too many clients
        //

        StatInc(RejectedCf);

        NDIS_UNLOCK(&pCf->Lock);

        RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

        ReleaseClientBlock(pClient);

        TRACE(REGISTER, GPC_STATUS_TOO_MANY_HANDLES, 0, "GpcRegisterClient==>");
        return GPC_STATUS_TOO_MANY_HANDLES;
    }

    //
    // init the client block
    //

    pClient->pCfBlock = pCf;
    pClient->ClientCtx = ClientContext;
    pClient->Flags = Flags;
    pClient->State = GPC_STATE_READY;

    if (pClientFuncList) {

        RtlMoveMemory(&pClient->FuncList, 
                      pClientFuncList, 
                      sizeof(GPC_CLIENT_FUNC_LIST));
    }

    //
    // add the client block to the CF and update CF
    //

    GpcInsertTailList(&pCf->ClientList, &pClient->ClientLinkage);

    pCf->NumberOfClients++;

    //
    // fill the output client handle
    //

    *pClientHandle = (GPC_CLIENT_HANDLE)pClient;

    //
    // release the lock
    //

    NDIS_UNLOCK(&pCf->Lock);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

#if 0
    //
    // if this is not the first client for the CF, start a working
    // thread to notify the client about each installed blob for the CF.
    // In the call include:
    //

    if (!IsListEmpty(&pCf->BlobList)) {

        //
        // this is not the first client, start a notification thread
        //

    }
#endif

    TRACE(REGISTER, pClient, Status, "GpcRegisterClient==>");




    if (NT_SUCCESS(Status)) {

        StatInc(CreatedCf);
        StatInc(CurrentCf);

    } else {

        StatInc(RejectedCf);

    }

    return Status;
}




/*
************************************************************************

GpcDeregisterClient -

Deregisters the client and remove associated data from the GPC.

Arguments
	ClientHandle - client handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcDeregisterClient(
	IN	GPC_HANDLE		ClientHandle
    )
{
    GPC_STATUS	    Status = STATUS_SUCCESS;
    PCLIENT_BLOCK   pClient;
    PCF_BLOCK       pCf;

	TRACE(REGISTER, ClientHandle, 0, "GpcDeregisterClient");

    pClient = (PCLIENT_BLOCK)ClientHandle;

    NDIS_LOCK(&pClient->Lock);

    pCf = pClient->pCfBlock;
    
    if (!IsListEmpty(&pClient->BlobList)) {

        Status = GPC_STATUS_NOT_EMPTY;

        NDIS_UNLOCK(&pClient->Lock);

        return Status;
    }

    if (pClient->State != GPC_STATE_READY) {

        //
        // HUH?!?
        // Client called to remove twice! probably caller bug
        // but we need to protect our selves.
        //

        NDIS_UNLOCK(&pClient->Lock);

        TRACE(REGISTER, GPC_STATUS_NOTREADY, 0, "GpcDeregisterClient==>");

        return GPC_STATUS_NOTREADY;
    }

    //
    // remove the client from the Cf's client list
    //
    
    pClient->State = GPC_STATE_REMOVE;
    pClient->ObjectType = GPC_ENUM_INVALID;

    //
    // release the client's mapping handle
    //
    
    FreeHandle(pClient->ClHandle);    

    //
    // remove the client from the CF list and return the index back
    //

#if 0
    NDIS_DPR_LOCK(&pCf->Lock);

    GpcRemoveEntryList(&pClient->ClientLinkage);
    ReleaseClientIndex(pCf->ClientIndexes, pClient->AssignedIndex);
#endif

    //
    // decrease number of clients
    //
        
    if (NdisInterlockedDecrement(&pCf->NumberOfClients) == 0) {
        
        TRACE(CLIENT, pClient, pCf->NumberOfClients, "NumberOfClients");
        
        //
        // last client on the CF, we may release all db
        //
        
        //UninitializeGenericDb(&pCf->pGenericDb, pCf->MaxPriorities);
    }    
        
    StatInc(DeletedCf);
    StatDec(CurrentCf);

#if 0
    NDIS_DPR_UNLOCK(&pCf->Lock);
#endif

    NDIS_UNLOCK(&pClient->Lock);

    //
    // release the client block
    //

    REFDEL(&pClient->RefCount, 'CLNT');
    
    TRACE(REGISTER, Status, 0, "GpcDeregisterClient==>");

    return Status;
}


/*
************************************************************************

GpcAddCfInfo -

Add A new blob. The blob is copied into the GPC and the GPC notifies
other client for the same CF about the installation.

Arguments
	ClientHandle		- client handle
    CfInfoSize			- size of the blob
    pClientCfInfoPtr	- pointer to the blob
    ClientCfInfoContext	- client's context to associate with the blob
    pGpcCfInfoHandle	- OUT, returned blob handle

Returns
	GPC_STATUS: SUCCESS, PENDING or FAILURE

************************************************************************
*/
GPC_STATUS
GpcAddCfInfo(
IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					CfInfoSize,
    IN	PVOID					pClientCfInfoPtr,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    OUT PGPC_HANDLE	    		pGpcCfInfoHandle
    )
{
	return privateGpcAddCfInfo(ClientHandle,
	                                CfInfoSize,pClientCfInfoPtr,
	                                ClientCfInfoContext,NULL,NULL,
	                                pGpcCfInfoHandle);
}



/*
************************************************************************

PrivateGpcAddCfInfo -

Add A new blob. The blob is copied into the GPC and the GPC notifies
other client for the same CF about the installation.

Arguments
	ClientHandle		- client handle
    CfInfoSize			- size of the blob
    pClientCfInfoPtr	- pointer to the blob
    ClientCfInfoContext	- client's context to associate with the blob
    pGpcCfInfoHandle	- OUT, returned blob handle

Returns
	GPC_STATUS: SUCCESS, PENDING or FAILURE

************************************************************************
*/
GPC_STATUS
privateGpcAddCfInfo(
    IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					CfInfoSize,
    IN	PVOID					pClientCfInfoPtr,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    IN       PFILE_OBJECT                     FileObject,
    IN       PGPC_IP_PATTERN              Pattern,
    OUT PGPC_HANDLE	    		pGpcCfInfoHandle
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS          Status1;
    PCLIENT_BLOCK		pClient;
    PCLIENT_BLOCK		pNotifyClient;
    PCLIENT_BLOCK		pNotifyClient2;
    PBLOB_BLOCK			pBlob;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    int                 i;
    GPC_CLIENT_HANDLE	ReturnedCtx;
    KIRQL				irql;

    //If this function fails for any reason we should guarantee that
    // Pattern is freed

    TRACE(BLOB, ClientHandle, ClientCfInfoContext, "GpcAddCfInfo");

    VERIFY_OBJECT_WITH_STATUS(ClientHandle, GPC_ENUM_CLIENT_TYPE,Status);
    
    if(GPC_STATUS_SUCCESS != Status){
        if (Pattern){
                GpcFreeMem(Pattern,TcpPatternTag);
            }
            return Status;
        }
        

    *pGpcCfInfoHandle = NULL;

    //
    // cast the client handle to the block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    
    ASSERT(pClient);

    pCf = pClient->pCfBlock;

    ASSERT(pCf);

    //
    // create a new blob block and copy the user data into
    //

    pBlob = CreateNewBlobBlock(CfInfoSize, pClientCfInfoPtr,IS_USERMODE_CLIENT_EX(pClient));

    if (pBlob) {

#if NO_USER_PENDING

        //
        // this will be only required until we implement the user level
        // pending report
        //

        CTEInitBlockStruc(&pBlob->WaitBlock);

#endif

        //
        // Put the FileObject and the Pattern information in the Blob.
        //
        if (FileObject || Pattern)
        {
            ASSERT(FileObject);
            ASSERT(Pattern);

            pBlob->FileObject = FileObject;
            pBlob->Pattern = Pattern;
        }

        //
        // Add one reference count to the blob since if during
        // completion, it might be deleted (if the client fails)
        //

        REFADD(&pBlob->RefCount, 'ADCF');

        //
        // set the calling client context inside the blob
        //
        
        pBlob->arClientCtx[pClient->AssignedIndex] = ClientCfInfoContext;

        //
        // set the owner client's context
        //

        pBlob->OwnerClientCtx = ClientCfInfoContext;

        //
        // set pointer to installer and the state
        //

        pBlob->pOwnerClient = pClient;
        pBlob->State = GPC_STATE_ADD;

        //
        // init the client status array to keep track
        // of how many client have succeeded so far
        //
        
        RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
        pBlob->ClientStatusCountDown = 0;

        //
        // notify each client
        //

        //NDIS_LOCK(&pCf->Lock);

        RSC_READ_LOCK(&pCf->ClientSync, &irql);

        pHead = &pCf->ClientList;
        pEntry = pHead->Flink;

        while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                                   Status == GPC_STATUS_PENDING)) {

            //
            // get the notified client block
            //

            pNotifyClient = CONTAINING_RECORD(pEntry, 
                                              CLIENT_BLOCK, 
                                              ClientLinkage);

            if (pNotifyClient != pClient 
                && 
                !IS_USERMODE_CLIENT(pNotifyClient) ) {

                //
                // don't notify the caller
                //

                REFADD(&pNotifyClient->RefCount, 'ADCF');

                //
                // okay, we have bumped the ref count for this
                // client. No need to keep the lock 
                //

                RSC_READ_UNLOCK(&pCf->ClientSync, irql);
                //NDIS_UNLOCK(&pCf->Lock);
        
                //
                // increase number of count down clients,
                // so we keep track how many clients are still
                // pending. We do it *before* the call, since
                // the completion might be called before the notification
                // returns.
                //
                
                Status1 = ClientAddCfInfo
                    (pNotifyClient,
                     pBlob,
                     &ReturnedCtx
                     );
               

                if (Status1 == GPC_STATUS_PENDING) {
                    
                    pBlob->arClientCtx[pNotifyClient->AssignedIndex] = 
                        ReturnedCtx;
                    Status = GPC_STATUS_PENDING;
                    
                    if (pBlob->pNotifiedClient == NULL &&
                        pNotifyClient->FuncList.ClGetCfInfoName) {

                        TRACE(BLOB, pBlob, ReturnedCtx, "GpcAddCfInfo: (client)");

                        //ASSERT(ReturnedCtx);

                        //
                        // assume that is the client returned PENDING
                        // it has some interest in the blob...
                        //
                        
                        pBlob->pNotifiedClient = pNotifyClient;
                        pBlob->NotifiedClientCtx = ReturnedCtx;
                    }

                } else if (!NT_SUCCESS(Status1)) {
                    
                    //
                    // some failure, notify each client that reported
                    // success on the add blob, to remove it
                    //

                    //
                    // change the state to 'remove'
                    //
                    
                    pBlob->State = GPC_STATE_REMOVE;

                    //
                    // set the last status to the failure status
                    //

                    pBlob->LastStatus = Status = Status1;

                    REFDEL(&pNotifyClient->RefCount, 'ADCF');

                    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {

                        //
                        // only clients with none zero entries
                        // have succefully installed the blob
                        //

                        if (pNotifyClient = pBlob->arpClientStatus[i]) {
                            
                            //
                            // notify each client to remove the blob
                            //
                            
                            Status1 = ClientRemoveCfInfo
                                (
                                 pNotifyClient,
                                 pBlob,
                                 pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                                 );
                            
                            if (Status1 != GPC_STATUS_PENDING) {
                                
                                //
                                // error or success
                                //

                                pBlob->arpClientStatus[i] = NULL;

                                //DereferenceClient(pNotifyClient);
                            }
                            
                        }

                    } // for

                    //
                    // don't notify other clients
                    //

                    //NDIS_LOCK(&pCf->Lock);
                    RSC_READ_LOCK(&pCf->ClientSync, &irql);
                    
                    break;

                } else {

                    //
                    // status success or ignored reported
                    //

                    if (Status1 == GPC_STATUS_SUCCESS) {
                        
                        pBlob->arClientCtx[pNotifyClient->AssignedIndex] = 
                            ReturnedCtx;
                        pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                            pNotifyClient;

                        if (pBlob->pNotifiedClient == NULL &&
                            pNotifyClient->FuncList.ClGetCfInfoName) {

                            TRACE(BLOB, pBlob, ReturnedCtx, "GpcAddCfInfo: (client 2)");
                            
                            //ASSERT(ReturnedCtx);

                            //
                            // update the notified client
                            //
                            
                            pBlob->pNotifiedClient = pNotifyClient;
                            pBlob->NotifiedClientCtx = ReturnedCtx;
                        }

                    }

                }

                //
                // This is a tricky part,
                // we need to let go of the ref count of the current client object
                // but get the next one...
                //
                
                //NDIS_LOCK(&pCf->Lock);
                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                pEntry = pEntry->Flink;

                if (pEntry != pHead) {
                    
                    pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                       CLIENT_BLOCK, 
                                                       ClientLinkage);

                    REFADD(&pNotifyClient2->RefCount, 'ADCF');

                }

                //
                // release the list lock since the next call will try to get it
                //

                RSC_READ_UNLOCK(&pCf->ClientSync, irql);
                 
                REFDEL(&pNotifyClient->RefCount, 'ADCF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                if (pEntry != pHead) {
                    
                    //
                    // safe to do since the list is locked
                    //

                    REFDEL(&pNotifyClient2->RefCount, 'ADCF');
                }

            } else {   // if (pNotifyClient != pClient)

                //
                // advance to the next client block
                //
                
                pEntry = pEntry->Flink;
            }
                
        } // while


        //
        // release the CF lock still got
        //

        //NDIS_UNLOCK(&pCf->Lock);

        RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    } else { // if (pBlob)...
        
        //
        // error - no more memory?!?
        //
        // Failed to allocate the blob 
        // release the pattern memory.
        // Must release pattern memory if this function
        // fails
        if (Pattern){
                GpcFreeMem(Pattern,TcpPatternTag);
                // Do not access Pattern after
                // this
                Pattern = NULL;
            }
        Status = GPC_STATUS_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {
        
        ASSERT(pBlob);

        *pGpcCfInfoHandle = (GPC_CLIENT_HANDLE)pBlob;

        if (Status == GPC_STATUS_SUCCESS) {

            //
            // add the blob to the CF and client lists
            //
            
            GpcInterlockedInsertTailList(&pClient->BlobList, 
                                         &pBlob->ClientLinkage,
                                         &pClient->Lock
                                         );
            GpcInterlockedInsertTailList(&pCf->BlobList, 
                                         &pBlob->CfLinkage,
                                         &pCf->Lock
                                         );
            
            pBlob->State = GPC_STATE_READY;
        }

    } else {
        
        //
        // failed - remove the blob
        //

        if (pBlob)
            REFDEL(&pBlob->RefCount, 'BLOB');
    }

    if (pBlob) {

        //
        // release the first refcount we got up there...
        //
        REFDEL(&pBlob->RefCount, 'ADCF');

    }

	TRACE(BLOB, pBlob, Status, "GpcAddCfInfo==>");

    if (Status == GPC_STATUS_SUCCESS) {

        CfStatInc(pCf->AssignedIndex,CreatedBlobs);
        CfStatInc(pCf->AssignedIndex,CurrentBlobs);

    } else if (Status != GPC_STATUS_PENDING) {

        CfStatInc(pCf->AssignedIndex,RejectedBlobs);
        
    }

    return Status;
}




/*
************************************************************************

GpcAddPattern -

This will install a pattern into the GPC database. The pattern is hooked
to a blob. The pattern can be specific or general.
Adding a specific pattern:
It goes into the specific hash table (per protocol block)
....
return a classification handle

Adding general pattern:
It goes into a separate Rhizome per CF and into its priority slot.
....

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template ID to use
    Pattern					- pattern
    Mask					- patern mask
    Priority				- pattern priority in case of conflict
    GpcCfInfoHandle			- associated blob handle
    pGpcPatternHandle		- OUT, returned pattern handle
    pClassificationHandle	- OUT, for specific pattern only

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcAddPattern(
	IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					Pattern,
    IN	PVOID					Mask,
    IN	ULONG					Priority,
    IN	GPC_HANDLE				GpcCfInfoHandle,
    OUT	PGPC_HANDLE				pGpcPatternHandle,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    )
{
    GPC_STATUS				Status;
    PCLIENT_BLOCK			pClient;
    PBLOB_BLOCK				pBlob;
    PPATTERN_BLOCK			pPattern, pCreatedPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PCLASSIFICATION_BLOCK	pCB;
    ULONG					i;
    PUCHAR					p;
    ULONG					Flags;
    PPROTOCOL_BLOCK			pProtocolBlock;
    ULONG					CfIndex;
    PGPC_IP_PATTERN			pIpPattern;
    REQUEST_BLOCK           Request, *pRequest;
    PLIST_ENTRY             pLinkage;

	TRACE(PATTERN, ClientHandle, Pattern, "GpcAddPattern");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    ASSERT(pGpcPatternHandle);
    ASSERT(pClassificationHandle);

    *pGpcPatternHandle = NULL;
    *pClassificationHandle = (CLASSIFICATION_HANDLE)0;

    //
    // NdisInitializeEvent must run at PASSIVE (isnt that sad)
    //
    RtlZeroMemory(&Request, sizeof(REQUEST_BLOCK));
    NdisInitializeEvent(
                        &Request.RequestEvent
                        );
    
    //
    // cast the client handle to the block
    // and the CfInfo handle to a blob block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pClient);

    CfIndex = pClient->pCfBlock->AssignedIndex;

    if (Priority >= pClient->pCfBlock->MaxPriorities ||
        ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX ) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    if (pBlob != NULL) {
        NDIS_LOCK(&pBlob->Lock);

        if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

            NDIS_UNLOCK(&pBlob->Lock);
            return GPC_STATUS_INVALID_PARAMETER;
        }

    }

    NDIS_LOCK(&glData.RequestListLock);

    if (pBlob != NULL && pBlob->State != GPC_STATE_READY) {
     
        //
        // Block until it is safe to restart the work.
        //
        InsertTailList(&glData.gRequestList, &Request.Linkage);
            
        NDIS_UNLOCK(&glData.RequestListLock);
        
        //
        // doing something else
        //
        NDIS_UNLOCK(&pBlob->Lock);

        if (TRUE == NdisWaitEvent(
                                  &Request.RequestEvent,
                                  0
                                  )) {
            
            //
            // The wait was successful, continue with regularly scheduled programming.
            // This lock needs to be taken when we get out.
            NDIS_LOCK(&pBlob->Lock);
            
        } else {

            //
            // How could this happen? I dont know. 
            // Definitely need to investigate.
            //

            TRACE(PATTERN, GPC_STATUS_FAILURE, 0, "GpcAddPattern: The conflict <-> wait <-> resume plan has FAILED!\n");
            ASSERT(FALSE);
            return GPC_STATUS_NOTREADY;
        }

    } else {

        NDIS_UNLOCK(&glData.RequestListLock);

    }

    //
    // determine if the pattern is specific or generic
    //

    pProtocolBlock = &glData.pProtocols[ProtocolTemplate];

    if (ProtocolTemplate == GPC_PROTOCOL_TEMPLATE_IP) {

        //
        // 
        //

        pIpPattern = (PGPC_IP_PATTERN)Pattern;
        pIpPattern->Reserved[0] = pIpPattern->Reserved[1] = pIpPattern->Reserved[2] = 0;

        pIpPattern = (PGPC_IP_PATTERN)Mask;
        pIpPattern->Reserved[0] = pIpPattern->Reserved[1] = pIpPattern->Reserved[2] = 0xff;
    }

    for (i = 0, p=(PUCHAR)Mask; i < pProtocolBlock->PatternSize; i++, p++) {
        
        if (*p != 0xff)
            break;
        
    }

    //
    // set the Flags
    //

    Flags = (i < pProtocolBlock->PatternSize) ? 0 : PATTERN_SPECIFIC;

    if (pBlob != NULL) {

        //
        // change the blob state to ADD, so no one can delete it
        // while the pattern is being added to its list
        //
        
        pBlob->State = GPC_STATE_ADD;
        
        NDIS_UNLOCK(&pBlob->Lock);
    }

    //
    // increment ref counting
    //

    //NdisInterlockedIncrement(&pClient->RefCount);

    //
    // cerate a new pattern block
    //

    pPattern = CreateNewPatternBlock(Flags);

    pCreatedPattern = pPattern;

#if DBG

    {
        PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)Pattern;
        PGPC_IP_PATTERN	pMask = (PGPC_IP_PATTERN)Mask;

        DBGPRINT(PATTERN, ("GpcAddPattern: Client=%X %s - ", 
                           pClient,
                           TEST_BIT_ON(Flags, PATTERN_SPECIFIC)?"Specific":"Generic"));
        DBGPRINT(PATTERN, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n", 
                           pIp->InterfaceId.InterfaceId,
                           pIp->InterfaceId.LinkId,
                           pIp->SrcAddr,
                           pIp->gpcSrcPort,
                           pIp->DstAddr,
                           pIp->gpcDstPort,
                           pIp->ProtocolId,
                           pIp->Reserved[0],
                           pIp->Reserved[1],
                           pIp->Reserved[2]
                           ));
        DBGPRINT(PATTERN, ("Mask: ifc={%x,%x} src=%08X:%04x, dst=%08X:%04x, prot=%x rsv=%x,%x,%x\n", 
                           pMask->InterfaceId.InterfaceId,
                           pMask->InterfaceId.LinkId,
                           pMask->SrcAddr,
                           pMask->gpcSrcPort,
                           pMask->DstAddr,
                           pMask->gpcDstPort,
                           pMask->ProtocolId,
                           pMask->Reserved[0],
                           pMask->Reserved[1],
                           pMask->Reserved[2]
                           ));
    }
#endif

    if (pPattern) {
        
        //
        // add one reference count to the pattern, so when we add it
        // to the db, we're sure it stays there
        //
        
        //pPattern->RefCount++;
        pPattern->Priority = Priority;
        pPattern->ProtocolTemplate = ProtocolTemplate;

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            //
            // add a specific pattern
            //
            
            Status = AddSpecificPattern(
                                        pClient,
                                        Pattern,
                                        Mask,
                                        pBlob,
                                        pProtocolBlock,
                                        &pPattern,  // output pattern pointer
                                        pClassificationHandle
                                        );

        } else {
            
            //
            // add a generic pattern
            //
            
            Status = AddGenericPattern(
                                       pClient,
                                       Pattern,
                                       Mask,
                                       Priority,
                                       pBlob,
                                       pProtocolBlock,
                                       &pPattern   // output pattern pointer
                                       );
            
        }

        // [OferBar]
        // release the extra ref count that was added
        // in the case of a specific pattern, this might be a totally different
        // one, but it should still have the extra ref-count
        // if there was an error, this will release the pattern
        // REFDEL(&pPattern->RefCount, 'FILT');


        // [ShreeM]
        // A reference FILT is added to a filter on creation. This will be substituted by 'ADSP' or
        // 'ADGP' whether it was a Generic Pattern or a Specific Pattern. However, it is likely that
        // in the AddSpecificPattern function, the pPattern got changed to something else because a
        // filter already existed. We want to ensure that the tag subsitution happens only in the 
        // case where pPattern was not replaced with the existing pattern in AddSpecificPattern.
        // 
        REFDEL(&pCreatedPattern->RefCount, 'FILT');

        //
        // check if failure, and if so - release the pattern block
        //
        
        if (NT_SUCCESS(Status)) {

            //
            // fill the output handle
            //
            
            *pGpcPatternHandle = (GPC_HANDLE)pPattern;
        }

    } else {

        Status = GPC_STATUS_RESOURCES;
    }

    if (pBlob != NULL) {

        //
        // change the state back to ready, so others can work on this blob
        //

        pBlob->State = GPC_STATE_READY;
    }

    //
    // release the extra ref count
    //

    //NdisInterlockedDecrement(&pClient->RefCount);

    TRACE(PATTERN, pPattern, Status, "GpcAddPattern==>");
        
    if (NT_SUCCESS(Status)) {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            ProtocolStatInc(ProtocolTemplate,
                            CreatedSp);
            ProtocolStatInc(ProtocolTemplate,
                            CurrentSp);

            NdisInterlockedIncrement(&pProtocolBlock->SpecificPatternCount);            
            
            ASSERT(pProtocolBlock->SpecificPatternCount > 0);

        } else {

            ProtocolStatInc(ProtocolTemplate,
                            CreatedGp);
            ProtocolStatInc(ProtocolTemplate,
                            CurrentGp);

            NdisInterlockedIncrement(&pProtocolBlock->GenericPatternCount);            
            
            ASSERT(pProtocolBlock->GenericPatternCount > 0);

        }

    } else {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {
            
            ProtocolStatInc(ProtocolTemplate,
                            RejectedSp);

        } else {

            ProtocolStatInc(ProtocolTemplate,
                            RejectedGp);
        }        
    }

    //
    // Check if some requests got queued while we were in there.
    //
    
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NDIS_LOCK(&glData.RequestListLock);
    
    if (!IsListEmpty(&glData.gRequestList)) {

        pLinkage = RemoveHeadList(&glData.gRequestList);

        NDIS_UNLOCK(&glData.RequestListLock);

        pRequest = CONTAINING_RECORD(pLinkage, REQUEST_BLOCK, Linkage);
        
        NdisSetEvent(&pRequest->RequestEvent);
        
    } else {

        NDIS_UNLOCK(&glData.RequestListLock);

    }

    return Status;
}



/*
************************************************************************

GpcAddCfInfoNotifyComplete -

A completion routine that the client will call after the GPC called into
the client's ClAddCfInfoNotify handler, but returned PENDING.
After all the clients have completed, a callback to the calling client's
ClAddCfInfoComplete is done to complete the GpcAddCfInfo call.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	void

************************************************************************
*/
VOID
GpcAddCfInfoNotifyComplete(
	IN	GPC_HANDLE			ClientHandle,
    IN	GPC_HANDLE			GpcCfInfoHandle,
    IN	GPC_STATUS			Status,
	IN	GPC_CLIENT_HANDLE	ClientCfInfoContext
    )
{
    PCLIENT_BLOCK		pClient, pNotifyClient, pFirstClient;
    PBLOB_BLOCK			pBlob;
    //GPC_CLIENT_HANDLE	ClientCtx;
    //ULONG				cd;
    int                 i;
    GPC_STATUS          LastStatus, Status1;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcAddCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (NT_SUCCESS(Status)) {

        //
        // success reported, save the reporting client handle
        // so we can notify him to remove the blob in case of an error
        // down the road by another client for the same blob
        //

        ASSERT(pBlob->arpClientStatus[pClient->AssignedIndex] == NULL);

        pBlob->arpClientStatus[pClient->AssignedIndex] = pClient;

    } else {

        //
        // error reported, update the last status code.
        //

        pBlob->LastStatus = Status;

    }

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {
        
        //
        // all clients have reported
        //
        
        //
        // save the client's blob data, cuz it might get deleted
        // 

        //ClientCtx = pBlob->arClientCtx[pClient->AssignedIndex];
        LastStatus = pBlob->LastStatus;
        pFirstClient = pBlob->pOwnerClient;

        if (NT_ERROR(LastStatus)) {

            //
            // error has been previously reported by a client
            // tell each client that reported success to remove
            // the blob (sorry...)
            //

#if 0
            NDIS_LOCK(&pBlob->pOwnerClient->pCfBlock->Lock);
            
            GpcRemoveEntryList(&pBlob->CfLinkage);
            
            NDIS_DPR_LOCK(&pBlob->pOwnerClient->Lock);    
            GpcRemoveEntryList(&pBlob->ClientLinkage);
            NDIS_DPR_UNLOCK(&pBlob->pOwnerClient->Lock);

            NDIS_UNLOCK(&pBlob->pOwnerClient->pCfBlock->Lock);
#endif

            CTEInitBlockStruc(&pBlob->WaitBlockAddFailed);

            Status1 = GPC_STATUS_SUCCESS;

            for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {
                
                //
                // only clients with none zero entries
                // have succefully installed the blob
                //
                
                if (pNotifyClient = pBlob->arpClientStatus[i]) {
                    
                    //
                    // notify each client to remove the blob
                    //
                    
                    if (ClientRemoveCfInfo
                        (
                         pNotifyClient,
                         pBlob,
                         pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                         ) == GPC_STATUS_PENDING)

                        {
                            Status1 = GPC_STATUS_PENDING;

                        } else {

                            //DereferenceClient(pNotifyClient);
                        }
                }
                
            } // for
            
            if (Status1 == GPC_STATUS_PENDING) {

                //
                // Block on completion of all removals...
                //
                
                Status1 = CTEBlock(&pBlob->WaitBlockAddFailed);
                
            }

        } else {	// if (NT_ERROR(LastStats))...

            //
            // store the returned client context, since the call can be completed
            // before the notification handler returns.
            //

            pBlob->arClientCtx[pClient->AssignedIndex] = ClientCfInfoContext;

            //
            // add the blob to the CF and client lists
            //
            
            GpcInterlockedInsertTailList(&pBlob->pOwnerClient->BlobList, 
                                         &pBlob->ClientLinkage,
                                         &pBlob->pOwnerClient->Lock
                                         );
            GpcInterlockedInsertTailList(&pBlob->pOwnerClient->pCfBlock->BlobList, 
                                         &pBlob->CfLinkage,
                                         &pBlob->pOwnerClient->pCfBlock->Lock
                                         );
            
        }

        //
        // complete the request to the client
        //

        ClientAddCfInfoComplete(
                                pFirstClient, // first guy who made the call
                                pBlob,        // completing blob
                                LastStatus    // status
                                );
        
    }

    //
    // this will be done after the last client completes
    //

    //DereferenceClient(pClient);
}



/*
************************************************************************

GpcModifyCfInfo -

The client calls this to modify a blob. Each other client on the CF will
get notified. This routine returns PENDING and starts a working thread
to do the main job.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the handle of the blob to modify
    CfInfoSize		- new blob size
    pClientCfInfo	- new blob data pointer

Returns
	GPC_STATUS, PENDING is valid

************************************************************************
*/
GPC_STATUS
GpcModifyCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
    IN  PVOID	    			pClientCfInfoPtr
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS          Status1;
    PCLIENT_BLOCK		pClient;
    PCLIENT_BLOCK		pNotifyClient;
    PCLIENT_BLOCK		pNotifyClient2;
    PBLOB_BLOCK			pBlob;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    int                 i;
    KIRQL				irql;

	TRACE(BLOB, ClientHandle, GpcCfInfoHandle, "GpcModifyCfInfo");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    ASSERT(pClientCfInfoPtr);

    //
    // cast the client handle to the block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;
    pCf = pClient->pCfBlock;

    ASSERT(pClient);
    ASSERT(pBlob);

    NDIS_LOCK(&pBlob->Lock);

    if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_INVALID_PARAMETER;
    }

    //
    // check the blob is in READY state and change it to MODIFY state
    //

    if (pBlob->State != GPC_STATE_READY) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_NOTREADY;
    }

    //
    // allocate private memory in the GPC to copy the client's data
    // into
    //

    GpcAllocMem(&pBlob->pNewClientData, CfInfoSize, CfInfoDataTag);

    if (pBlob->pNewClientData == NULL) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_RESOURCES;
    }

    pBlob->NewClientDataSize = CfInfoSize;
    pBlob->State = GPC_STATE_MODIFY;

    //
    // we set the calling client here so we can notify it when the 
    // the modification is completed
    //

    pBlob->pCallingClient = pClient;

    NDIS_UNLOCK(&pBlob->Lock);

#if NO_USER_PENDING

    //
    // this will be only required until we implement the user level
    // pending report
    //
    
    CTEInitBlockStruc(&pBlob->WaitBlock);
    
#endif

    //
    // copy the memory
    //
    
    RtlMoveMemory(pBlob->pNewClientData, pClientCfInfoPtr, CfInfoSize);

    //
    // init the client status array to keep track
    // of how many client have succeeded so far
    //
    
    //RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
    pBlob->ClientStatusCountDown = 0;
    pBlob->LastStatus = GPC_STATUS_SUCCESS;

    //
    // notify each client
    //
    
    //NDIS_LOCK(&pCf->Lock);

    RSC_READ_LOCK(&pCf->ClientSync, &irql);
    
    pHead = &pCf->ClientList;
    pEntry = pHead->Flink;
    
    while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                               Status == GPC_STATUS_PENDING)) {

        //
        // get the notified client block
        //
        
        pNotifyClient = CONTAINING_RECORD(pEntry, CLIENT_BLOCK, ClientLinkage);
        
        if (pNotifyClient != pClient 
            &&
            pBlob->arpClientStatus[pNotifyClient->AssignedIndex]
            && 
            !IS_USERMODE_CLIENT(pNotifyClient) ) {

            //
            // don't notify the caller
            //

            REFADD(&pNotifyClient->RefCount, 'CFMF');
       
            //
            // okay, we have bumped the ref count for this
            // client. No need to keep the lock 
            //

            //NDIS_UNLOCK(&pCf->Lock);
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            //
            // increase number of count down clients,
            // so we keep track how many clients are still
            // pending. We do it *before* the call, since
            // the completion might be called before the notification
            // returns.
            //
                
            Status1 = ClientModifyCfInfo
                (pNotifyClient,
                 pBlob,
                 CfInfoSize,
                 pBlob->pNewClientData
                 );

            TRACE(BLOB, pBlob, Status1, "GpcModifyCfInfo: (client)");

            //
            // grab the lock again since we're walking the list
            //
            
            //NDIS_LOCK(&pCf->Lock);
                
            //
            // now we check the Status1 code
            // the rules are:
            //  we stop on failure
            //  ignore GPC_STATUS_IGNORE
            //  and save PENDING status
            // 

            if (Status1 == GPC_STATUS_PENDING
                       && 
                       !NT_SUCCESS(pBlob->LastStatus)) {

                //
                // we've got back pending, but the client
                // actually completed the request
                // behind our back
                //

                Status = GPC_STATUS_PENDING;

                REFDEL(&pNotifyClient->RefCount, 'CFMF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                break;
                
            } else if (!NT_SUCCESS(Status1)) {
                    
                //
                // don't notify other clients
                //

                pBlob->LastStatus = Status = Status1;

                REFDEL(&pNotifyClient->RefCount, 'CFMF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);
                
                break;
                
            } else if (Status1 == GPC_STATUS_SUCCESS
                       ||
                       Status1 == GPC_STATUS_PENDING) {

                pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                    pNotifyClient;

                if (Status1 == GPC_STATUS_PENDING) {
                    Status = GPC_STATUS_PENDING;
                }

            }

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            pEntry = pEntry->Flink;

            if (pEntry != pHead) {
                
                pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                   CLIENT_BLOCK, 
                                                   ClientLinkage);
                
                REFADD(&pNotifyClient2->RefCount, 'CFMF');

            }

            //
            // release the list lock since the next call will try to get it
            //
            
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            REFDEL(&pNotifyClient->RefCount, 'CFMF');

            RSC_READ_LOCK(&pCf->ClientSync, &irql);
            
            if (pEntry != pHead) {
                
                //
                // safe to do since the list is locked
                //
                REFDEL(&pNotifyClient2->RefCount, 'CFMF');
                
            }
            
        } else {   // if (pNotifyClient != pClient)
        
            //
            // grab the next client block, 
            //
            
            pEntry = pEntry->Flink;

        }

    } // while
    
    
    //
    // release the CF lock still got
    //

    //NDIS_UNLOCK(&pCf->Lock);
    RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    //
    // Status code should be either:
    //
    // GPC_STATUS_SUCCESS - all clients have been notified and returned SUCCESS
    // GPC_STATUS_PENDING - all clients have been notified, at least one
    //						return PENDING
    // Error code - at least one client failed
    //

    if (Status != GPC_STATUS_PENDING) {

        //
        // Note: the status here can be either FAILED or SUCCESS
        //
        // no client has been pending, so we complete the modification
        // back to the clients (except the caling client)
        //

        ModifyCompleteClients(pClient, pBlob);

        //
        // restore READY state
        //

        pBlob->State = GPC_STATE_READY;

    }

	TRACE(BLOB, pBlob, Status, "GpcModifyCfInfo==>");

    if (NT_SUCCESS(Status)) {

        CfStatInc(pCf->AssignedIndex,ModifiedBlobs);
        
    }

    return Status;
}





/*
************************************************************************

GpcModifyCfInfoNotifyComplete -

Called by clients to complete a previous call to ClModifyCfInfoNotify
made by the GPC.


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	GPC_STATUS

************************************************************************
*/
VOID
GpcModifyCfInfoNotifyComplete(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN	GPC_STATUS		Status
    )
{
    PCLIENT_BLOCK		pClient, pNotifyClient;
    PBLOB_BLOCK			pBlob;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcModifyCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (NT_SUCCESS(Status)) {

        //
        // success reported, save the reporting client handle
        // so we can notify him to remove the blob in case of an error
        // down the road by another client for the same blob
        //

        ASSERT(pBlob->arpClientStatus[pClient->AssignedIndex] == pClient);

        //pBlob->arpClientStatus[pClient->AssignedIndex] = pClient;
        
    } else {

        //
        // error reported, update the last status code.
        //

        pBlob->LastStatus = Status;

    }

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {
        
        //
        // all clients have reported
        //
        
        ModifyCompleteClients(pClient, pBlob);

#if NO_USER_PENDING

        //
        // the user is blocking on this call
        //

        CTESignal(&pBlob->WaitBlock, Status);

#else
            
        //
        // now, complete the call back to the calling client
        //

        ClientModifyCfInfoComplete(
                                   pBlob->pCallingClient,
                                   pBlob,
                                   pBlob->LastStatus
                                   );

        pBlob->State = GPC_STATE_READY;

#endif
        
    }

	TRACE(BLOB, pClient, Status, "GpcModifyCfInfoNotifyComplete==>");
}




/*
************************************************************************

privateGpcRemoveCfInfo - 

Remove a blob from GPC. 


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- blob handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
privateGpcRemoveCfInfo(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN   ULONG			Flags
    )
{
    GPC_STATUS	    Status = GPC_STATUS_SUCCESS;
    GPC_STATUS      Status1;
    PCLIENT_BLOCK   pClient;
    PCLIENT_BLOCK   pNotifyClient;
    PCLIENT_BLOCK   pNotifyClient2;
    PBLOB_BLOCK     pBlob;
    PCF_BLOCK       pCf;
    PPATTERN_BLOCK	pPattern;
    PLIST_ENTRY     pHead, pEntry;
    KIRQL			irql;
    PPROTOCOL_BLOCK pProtocol;
    ULONG           cClientRef;

	TRACE(BLOB, ClientHandle, GpcCfInfoHandle, "privateGpcRemoveCfInfo");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    
    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob   = (PBLOB_BLOCK)GpcCfInfoHandle;
    pCf     = pClient->pCfBlock;

    NDIS_LOCK(&pBlob->Lock);

    if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_INVALID_PARAMETER;
    }


    if (pBlob->State != GPC_STATE_READY) {

        if ((pBlob->pCallingClient2) || (IS_USERMODE_CLIENT_EX(pClient))){

            //
            // Can't handle more than 2 removals for the 
            // same flow.
            // another client has already requested the removal of 
            // this flow, we should fail here
            //
            // Also dont pend requests from user mode clients using the new IOCTL 
            // interface

            NDIS_UNLOCK(&pBlob->Lock);

            TRACE(BLOB, GPC_STATUS_NOTREADY, 0, "privateGpcRemoveCfInfo==>");
            
            return GPC_STATUS_NOTREADY;

        }
         
        //
        // the flow is being removed when another client
        // requested its removal. we save this client handle
        // and we'll coplete it later
        //


        
        pBlob->pCallingClient2 = pClient;
    
        NDIS_UNLOCK(&pBlob->Lock);
        
        TRACE(BLOB, GPC_STATUS_PENDING, 0, "privateGpcRemoveCfInfo==>");
        
        return GPC_STATUS_PENDING;
    }
    
    //
    // remove the supported patterns on the cfinfo
    // there are two cases:
    //
    // 1. from a user - traffic.dll requires that ALL the filters
    //	  would have been deleted, therefore this case is a nop.
    //
    // 2. from a kernel client - in this case we MUST remove the 
    //    patterns before proceesing to delete the cfinfo,
    //    since we can't rely on traffic.dll to do it
    //

    //
    // grab a refcount on this blob so it doesn't go away due
    // to some funky client that decides to complete before
    // it return any status code (and most of them do!)
    // this should be released before we exit the routine,
    // so that the blob may actually go away on the last deref
    //

    REFADD(&pBlob->RefCount, 'RMCF');

    //
    // set the removing client
    //
    
    pBlob->pCallingClient = pClient;
    

    //
    // don't allow the user mode owner client to remove this flow
        // if there are any patterns on it....
    // ...unless the REMOVE_CB_BLOB bit ahs been set,
    // for example: when the calling process dies
    //

    if (!IsListEmpty(&pBlob->PatternList) &&
        TEST_BIT_ON(pClient->Flags, GPC_FLAGS_USERMODE_CLIENT) &&
        (pClient == pBlob->pOwnerClient) &&
         TEST_BIT_OFF(pBlob->Flags, PATTERN_REMOVE_CB_BLOB)
       )
    {

        NDIS_UNLOCK(&pBlob->Lock);

        return GPC_STATUS_NOT_EMPTY;
    
    } else {

        //
        // Since we have decided to remove the patterns, we should
        // mark this as invalid
        //

        pBlob->ObjectType = GPC_ENUM_INVALID;
    }

    while (!IsListEmpty(&pBlob->PatternList)) {

        pPattern = CONTAINING_RECORD(pBlob->PatternList.Flink,
                                     PATTERN_BLOCK,
                                     BlobLinkage[pCf->AssignedIndex]);

        NDIS_DPR_LOCK(&pPattern->Lock);

        REFADD(&pPattern->RefCount, 'RMCF');

        pPattern->State = GPC_STATE_FORCE_REMOVE;
        
        //
        // If it is an AUTO PATTERN, remove it from the list and 
        // unset the flag.
        //
        if (TEST_BIT_ON( pPattern->Flags, PATTERN_AUTO)) {
    
            pProtocol = &glData.pProtocols[pPattern->ProtocolTemplate];
            
            pPattern->Flags |= ~PATTERN_AUTO;

            NDIS_DPR_LOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);
    
            GpcRemoveEntryList(&pPattern->TimerLinkage);
    
            NDIS_DPR_UNLOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);
                
            InitializeListHead(&pPattern->TimerLinkage);
            
            NDIS_DPR_UNLOCK(&pPattern->Lock);

            NDIS_UNLOCK(&pBlob->Lock);

            privateGpcRemovePattern(ClientHandle, (GPC_HANDLE)pPattern, TRUE, FALSE);        

            InterlockedDecrement(&pProtocol->AutoSpecificPatternCount);

        } else {

            NDIS_DPR_UNLOCK(&pPattern->Lock);
            NDIS_UNLOCK(&pBlob->Lock);

        }
        
        privateGpcRemovePattern(ClientHandle, (GPC_HANDLE)pPattern, TRUE , FALSE);        
        
        REFDEL(&pPattern->RefCount, 'RMCF');

        NDIS_LOCK(&pBlob->Lock);
    }


    //
    // set the state
    //
    
    pBlob->State = GPC_STATE_REMOVE;

    NDIS_UNLOCK(&pBlob->Lock);

#if NO_USER_PENDING

    //
    // this will be only required until we implement the user level
    // pending report
    //
    
    CTEInitBlockStruc(&pBlob->WaitBlock);
    
#endif


    SuspendHandle(pBlob->ClHandle);

    //
    // init the client status array to keep track
    // of how many client have succeeded so far
    //
        
    //RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
    pBlob->ClientStatusCountDown = 0;
    pBlob->LastStatus = GPC_STATUS_SUCCESS;

    //
    // notify each client
    //

    NDIS_LOCK(&pCf->Lock);
    GpcRemoveEntryList(&pBlob->CfLinkage);
    NDIS_UNLOCK(&pCf->Lock);

    //NDIS_LOCK(&pClient->Lock);    

    RSC_READ_LOCK(&pCf->ClientSync, &irql);
    
    NDIS_LOCK(&pClient->Lock);
    GpcRemoveEntryList(&pBlob->ClientLinkage);
    NDIS_UNLOCK(&pClient->Lock);

    //NDIS_UNLOCK(&pClient->Lock);

    //
    // the blob is not on the CF or on the client list
    // okay to change the object type so further handle lookup will fail
    //

    pHead = &pCf->ClientList;
    pEntry = pHead->Flink;
    
    while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                               Status == GPC_STATUS_PENDING)) {

        //
        // get the notified client block
        //
        
        pNotifyClient = CONTAINING_RECORD(pEntry, CLIENT_BLOCK, ClientLinkage);
        
        if (pNotifyClient != pClient
            &&
            pBlob->arpClientStatus[pNotifyClient->AssignedIndex] ) {

            //
            // don't notify the caller
            //
            
            REFADD(&pNotifyClient->RefCount, 'PRCF');

            //NDIS_UNLOCK(&pCf->Lock);
            RSC_READ_UNLOCK(&pCf->ClientSync, &irql);

            Status1 = ClientRemoveCfInfo
                (pNotifyClient,
                 pBlob,
                 pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                 );
            
            TRACE(BLOB, pBlob, Status, "privateGpcRemoveCfInfo: (client)");

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            if (Status1 == GPC_STATUS_PENDING) {
                                
                Status = GPC_STATUS_PENDING;
              
            } else {

                if (NT_ERROR(Status1)) {
                
                    Status = pBlob->LastStatus = Status1;
                
                } else {
                    
                    //
                    // status success
                    //
                
                    pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                        pNotifyClient;

                    NDIS_DPR_LOCK(&pBlob->Lock);

                    if (pNotifyClient == pBlob->pNotifiedClient) {

                        pBlob->pNotifiedClient = NULL;
                        pBlob->NotifiedClientCtx = NULL;
                    }

                    NDIS_DPR_UNLOCK(&pBlob->Lock);

                }
                
                //
                // not pending - no need to hold the ref count to this client
                //

                //DereferenceClient(pNotifyClient);
            }
            
            //
            // advance to the next client block, and release the ref count
            // for this client
            //
            
            //NDIS_LOCK(&pCf->Lock);

            pEntry = pEntry->Flink;

            if (pEntry != pHead) {
                
                pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                   CLIENT_BLOCK, 
                                                   ClientLinkage);
                
                REFADD(&pNotifyClient2->RefCount, 'PRCF');

            }

            //
            // release the list lock since the next call will try to get it
            //
            
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            REFDEL(&pNotifyClient->RefCount, 'PRCF');

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            if (pEntry != pHead) {
                
                //
                // safe to do since the list is locked
                //
                
                REFDEL(&pNotifyClient2->RefCount, 'PRCF');
            }

        } else {      // if (pNotifyClient != pClient)
            
            pEntry = pEntry->Flink;
        }
        
    } // while
        
    //NDIS_UNLOCK(&pCf->Lock);

    RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    if (Status != GPC_STATUS_PENDING) {

        NDIS_LOCK(&pBlob->Lock);

        //
        // notify any pending client about the status
        //
        
        if (pClient = pBlob->pCallingClient2) {

            pClient = pBlob->pCallingClient2;
            pBlob->pCallingClient2 = NULL;

            NDIS_UNLOCK(&pBlob->Lock);

            //
            // complete the request to this client
            //
            
            ClientRemoveCfInfoComplete
                (
                 pClient,  			// the guy who made the call
                 pBlob,             // completing blob
                 Status        		// status
                 );
            
            //pBlob->pCallingClient2 = NULL;

        } else {

            NDIS_UNLOCK(&pBlob->Lock);
        }

        if (Status != GPC_STATUS_SUCCESS) {

            //
            // failed to remove the blob
            //

            pBlob->State = GPC_STATE_READY;
            pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;

            //
            // resume the suspended handle
            //

            ResumeHandle(pBlob->ClHandle);
        }
    }

    if (Status == GPC_STATUS_SUCCESS) {
        
        //
        // release the mapping handle 
        //
        
        FreeHandle(pBlob->ClHandle);
        
        //
        // all done, we can remove the blob from memory
        //
        
        REFDEL(&pBlob->RefCount, 'BLOB');
        
        CfStatInc(pCf->AssignedIndex,DeletedBlobs);
        CfStatDec(pCf->AssignedIndex,CurrentBlobs);
    }           

    //
    // release the extra refcount we got in the begining
    // this is to avoid the problem of the blob going away,
    // since some clients may complete the remove before we get
    // here, and this will cause the blob structure to be released
    // it's not a pretty sight....
    //

    REFDEL(&pBlob->RefCount, 'RMCF');
    
    TRACE(BLOB, Status, 0, "privateGpcRemoveCfInfo==>");

    return Status;
}




/*
************************************************************************

GpcRemoveCfInfo - 

	This must have been called from kernel. We simply pass the call
    to the private routine with Flags=0.


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- blob handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRemoveCfInfo(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle
    )
{

    return privateGpcRemoveCfInfo(
                                  ClientHandle,
                                  GpcCfInfoHandle,
                                  0
                                  );
}




/*
************************************************************************

GpcRemoveCfInfoNotifyComplete -

Called by clients who are completing a ClRemoveCfInfoNotify that was PENDING.
This may have been called for two reasons:
1. A client issued a GpcRemoveCfInfo request.
2. A client issued a GpcAddCfInfo request, but one of the other clients
   failed, so we are removing the successfully installed blobs.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	void

************************************************************************
*/
VOID
GpcRemoveCfInfoNotifyComplete(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN	GPC_STATUS		Status
    )
{
    PCLIENT_BLOCK		pClient;
    PBLOB_BLOCK			pBlob;
    PCLIENT_BLOCK		pClient2;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcRemoveCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (!NT_ERROR(pBlob->LastStatus) || NT_ERROR(Status)) {

        //
        // save the last error code
        //

        pBlob->LastStatus = Status;
    }

    NDIS_LOCK(&pBlob->Lock);
    
    if (Status == GPC_STATUS_SUCCESS && pClient == pBlob->pNotifiedClient) {
        
        pBlob->pNotifiedClient = NULL;
        pBlob->NotifiedClientCtx = NULL;
    }
    
    NDIS_UNLOCK(&pBlob->Lock);

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {

        if (pBlob->State == GPC_STATE_REMOVE) {
            
            if (pBlob->pCallingClient->State == GPC_STATE_READY) {

                //
                // complete the request to the client
                //
                
                ClientRemoveCfInfoComplete
                    (
                     pBlob->pCallingClient,   // first guy who made the call
                     pBlob,                   // completing blob
                     pBlob->LastStatus        // status
                     );

                NDIS_LOCK(&pBlob->Lock);

                //
                // notify any pending client about the status
                //
                
                if (pClient2 = pBlob->pCallingClient2) {

                    pBlob->pCallingClient2 = NULL;

                    NDIS_UNLOCK(&pBlob->Lock);

                    //
                    // complete the request to this client
                    //
                    
                    ClientRemoveCfInfoComplete
                        (
                         pClient2,  			// the guy who made the call
                         pBlob,                 // completing blob
                         pBlob->LastStatus		// status
                         );
                } else {

                    NDIS_UNLOCK(&pBlob->Lock);
                }
                
                //pBlob->State = GPC_STATE_READY;

                if (pBlob->LastStatus == GPC_STATUS_SUCCESS) {

                    //
                    // release the mapping handle 
                    //
                    
                    FreeHandle(pBlob->ClHandle);
                    
                    //
                    // all clients have reported
                    // remove the blob
                    //
                
                    REFDEL(&pBlob->RefCount, 'BLOB');
                    //DereferenceBlob(&pBlob);

                } else {

                    //
                    // blob not removed - restore the object type
                    //

                    pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;

                    //
                    // resume the mapping handle
                    //
                    
                    ResumeHandle(pBlob->ClHandle);
                }
            }

        } else { // if (pBlob->State....)

            //
            // we are removing the blob since we failed to add it
            // to ALL clients.
            //

            ASSERT(pBlob->State == GPC_STATE_ADD);

            //
            // Release the AddFailed block so that the AddComplete
            // will resume
            //

            CTESignal(&pBlob->WaitBlockAddFailed, pBlob->LastStatus);
            
        }
    }

    //
    // release the one we got earlier
    //

    //DereferenceClient(pClient);

	TRACE(BLOB, 0, 0, "GpcRemoveCfInfoNotifyComplete==>");
}




/*
************************************************************************

GpcRemovePattern -

Called by the client to remove a pattern from the database.

Arguments
	ClientHandle		- client handle
    GpcPatternHandle	- pattern handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle
    )
{

    return(privateGpcRemovePattern(
                            ClientHandle,
                            GpcPatternHandle,
                            FALSE, FALSE
                            ));

}


/*
************************************************************************

privateGpcRemovePattern -

Internal call in the GPC to indicate whether this is forceful removal.

Arguments
	ClientHandle		- client handle
    GpcPatternHandle	- pattern handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
privateGpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle,
    IN  BOOLEAN         ForceRemoval ,
    IN BOOLEAN    DbLocked
    )
{

    GPC_STATUS	    Status = GPC_STATUS_SUCCESS;
    PPATTERN_BLOCK  pPattern;
    PCLIENT_BLOCK   pClient;
    PPROTOCOL_BLOCK pProtocol;
    ULONG           Flags;
    ULONG			CfIndex;
    ULONG			ProtocolId;

	TRACE(PATTERN, ClientHandle, GpcPatternHandle, "GpcRemovePattern");

    DBGPRINT(PATTERN, ("GpcRemovePattern: Client=%X Pattern=%X\n", 
                       ClientHandle, GpcPatternHandle));

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    VERIFY_OBJECT(GpcPatternHandle, GPC_ENUM_PATTERN_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pPattern = (PPATTERN_BLOCK)GpcPatternHandle;

    ASSERT(pClient);
    ASSERT(pPattern);

    CfIndex = pClient->pCfBlock->AssignedIndex;
    ProtocolId = pPattern->ProtocolTemplate;
    pProtocol = &glData.pProtocols[ProtocolId];

    //
    // If the pattern has already been removed by the ADAPTER (mostly WAN link)
    // going down, just return with an error. The memory is valid since the 
    // ProxyRemovePattern function added a REF.
    // 
    NDIS_LOCK(&pPattern->Lock);

    if (!ForceRemoval && (pPattern->State != GPC_STATE_READY)) {

        NDIS_UNLOCK(&pPattern->Lock);
        
        return GPC_STATUS_INVALID_HANDLE;

    } else {
        
        NDIS_UNLOCK(&pPattern->Lock);

    }

	//
	// determine weather its a specific or generic pattern
	//

    Flags = pPattern->Flags;

    if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

        //
        // this is a specific pattern, call the appropriate routine
        // to remove from db
        //

        Status = RemoveSpecificPattern(
                                       pClient,
                                       pProtocol,
                                       pPattern,
                                       ForceRemoval,
                                       DbLocked
                                       );
    } else {

        //
        // this is a generic pattern, call the appropriate routine
        // to remove from db
        //

        Status = RemoveGenericPattern(
                                      pClient,
                                      pProtocol,
                                      pPattern
                                      );
    }

	TRACE(PATTERN, Status, 0, "GpcRemovePattern==>");

    if (NT_SUCCESS(Status)) {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            ProtocolStatInc(ProtocolId,DeletedSp);
            ProtocolStatDec(ProtocolId,CurrentSp);

            NdisInterlockedDecrement(&pProtocol->SpecificPatternCount);            
            

        } else {

            ProtocolStatInc(ProtocolId,DeletedGp);
            ProtocolStatDec(ProtocolId,CurrentGp);

            NdisInterlockedDecrement(&pProtocol->GenericPatternCount);            
            

        }

    }

    DBGPRINT(PATTERN, ("GpcRemovePattern: Client=%X Pattern=%X, Status=%X\n", 
                       ClientHandle, GpcPatternHandle,Status));

    return Status;
}




/*
************************************************************************

GpcClassifyPattern -

Called by the client to classify a pattern and get back a client blob
context and a classification handle.

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template to use
    pPattern				- pointer to pattern
    pClientCfInfoContext	- OUT, the client's blob context
    pClassificationHandle	- OUT, classification handle

Returns
	GPC_STATUS: GPC_STATUS_NOT_FOUND

************************************************************************
*/
GPC_STATUS
GpcClassifyPattern(
	IN		GPC_HANDLE				ClientHandle,
    IN		ULONG					ProtocolTemplate,
    IN		PVOID			        pPattern,
    OUT		PGPC_CLIENT_HANDLE		pClientCfInfoContext,	// optional
    IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN		ULONG					Offset,
    IN		PULONG					pValue,
    IN		BOOLEAN					bNoCache
    )
{
    GPC_STATUS		Status;
    PPATTERN_BLOCK	pPatternBlock;
    PCLIENT_BLOCK	pClient;
    PPROTOCOL_BLOCK	pProtocol;
    PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)pPattern;
    KIRQL           CHirql;
    PBLOB_BLOCK     pBlob;

	TRACE(CLASSIFY, ClientHandle, *pClassificationHandle, "GpcClassifyPattern<==");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    ASSERT(ClientHandle);
    ASSERT(pPattern);
    //ASSERT(pClientCfInfoContext);
    ASSERT(pClassificationHandle);

    Status = GPC_STATUS_SUCCESS;

    if (ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    pProtocol = &glData.pProtocols[ProtocolTemplate];

    //
    // Optimization - check if there are any patterns installed
    //

    if (pProtocol->SpecificPatternCount == 0 
        &&
        pProtocol->GenericPatternCount == 0 ) {
        
        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }
        *pClassificationHandle = (CLASSIFICATION_HANDLE)0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X no patterns returned %X\n", 
                            ClientHandle, GPC_STATUS_NOT_FOUND));

        TRACE(CLASSIFY, ClientHandle, GPC_STATUS_NOT_FOUND, "GpcClassifyPattern (1)" );

        return GPC_STATUS_NOT_FOUND;
    }

    pClient = (PCLIENT_BLOCK)ClientHandle;

    if (ProtocolTemplate == GPC_PROTOCOL_TEMPLATE_IP) {

        pIp = (PGPC_IP_PATTERN)pPattern;
        pIp->Reserved[0] = pIp->Reserved[1] = pIp->Reserved[2] = 0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X, CH=%d\n", 
                            ClientHandle, *pClassificationHandle));
        DBGPRINT(CLASSIFY, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n", 
                            pIp->InterfaceId.InterfaceId,
                            pIp->InterfaceId.LinkId,
                            pIp->SrcAddr,
                            pIp->gpcSrcPort,
                            pIp->DstAddr,
                            pIp->gpcDstPort,
                            pIp->ProtocolId,
                            pIp->Reserved[0],
                            pIp->Reserved[1],
                            pIp->Reserved[2]
                            ));
    }

    ProtocolStatInc(ProtocolTemplate, ClassificationRequests);

    //
    // verify the classification handle, if it's valid, simply return
    //

    if (*pClassificationHandle && (pClientCfInfoContext || pValue)) {

        Status = GetClientCtxAndUlongFromCfInfo(ClientHandle,
                                                pClassificationHandle,
                                                pClientCfInfoContext,
                                                Offset,
                                                pValue
                                                );

        ProtocolStatInc(ProtocolTemplate, PatternsClassified);

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X returned immediate CH %d\n", 
                            pClient, *pClassificationHandle));

        TRACE(CLASSIFY, pClient, *pClassificationHandle, "GpcClassifyPattern (2)" );

        return Status;
    }

    //
    // there pattern needs to be classified
    // this should find the classification handle
    //

    Status = InternalSearchPattern(
                                    pClient, 
                                    pProtocol, 
                                    pPattern,
                                    &pPatternBlock,
                                    pClassificationHandle,
                                    bNoCache
                                    );
    
    if (*pClassificationHandle && (pClientCfInfoContext || pValue)) {

        Status = GetClientCtxAndUlongFromCfInfo(ClientHandle,
                                                pClassificationHandle,
                                                pClientCfInfoContext,
                                                Offset,
                                                pValue
                                                );

    } else if ((!NT_SUCCESS(Status)) && 
                pPatternBlock && 
                pClientCfInfoContext) {
        // it is likely that we could not allocate the Auto Specific pattern
        // just try to send the context anyway.

        READ_LOCK(&glData.ChLock, &CHirql);
        
        pBlob = GetBlobFromPattern(pPatternBlock, GetCFIndexFromClient(ClientHandle));

        if(pBlob) {

            *pClientCfInfoContext = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

        } else {

            Status = GPC_STATUS_NOT_FOUND;

        }

        READ_UNLOCK(&glData.ChLock, CHirql); 

    } else if (!*pClassificationHandle) {

        //
        // none found, 
        //

        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }

        Status = GPC_STATUS_NOT_FOUND;
    
    } else {

        Status = GPC_STATUS_SUCCESS;

    }

    if (pPatternBlock) {

        //DereferencePattern(pPatternBlock, pClient->pCfBlock);

        ProtocolStatInc(ProtocolTemplate, PatternsClassified);
    }

	TRACE(CLASSIFY, pPatternBlock, Status, "GpcClassifyPattern==>");

    DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X returned Pattern=%X, CH=%d, Status=%X\n", 
                        pClient, pPattern, *pClassificationHandle, Status));
    return Status;
}



/*
************************************************************************

GpcClassifyPacket -

Called by the client to classify a packet and get back a client blob
context and a classification handle.
Content is extracted from the packet and placed into a protocol specific
structure (IP).
For IP, if fragmentation is ON for the client:
   o First fragment will create a hash table entry
   o Other fragments will be looked in the hash by the packet ID
   o Last fragment will cause entry to be deleted.

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template
    pNdisPacket				- ndis packet
    TransportHeaderOffset	- byte offset of the start of the transport
							  header from the beginning of the packet
    pClientCfInfoContext	- OUT, client blob context
    pClassificationHandle	- OUT, classification handle

Returns
	GPC_STATUS

************************************************************************
*/

GPC_STATUS
GpcClassifyPacket(
	IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					pPacket,
    IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		pInterfaceId,
    OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,	//optional
    OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PNDIS_PACKET			pNdisPacket = NULL;
    PCLIENT_BLOCK			pClient;
    PCF_BLOCK				pCf;
    PPATTERN_BLOCK			pPattern = NULL;
    PPROTOCOL_BLOCK			pProtocol;
    PBLOB_BLOCK				pBlob = NULL;
    ULONG					CfIndex;
    int						i;
    GPC_IP_PATTERN			IpPattern;
    GPC_IPX_PATTERN			IpxPattern;
    PVOID					pKey = NULL;
    PVOID					pAddr;
    UINT					Len, Tot;
    PNDIS_BUFFER			pNdisBuf1, pNdisBuf2;
    PIP_HEADER              pIpHdr;
    PIPX_HEADER             pIpxHdr;
    USHORT         			PacketId;
    USHORT         			FragOffset;
    UINT           			IpHdrLen;
    PUDP_HEADER    			pUDPHdr;
    UCHAR          			PktProtocol;
    BOOLEAN					bFragment = FALSE;
    BOOLEAN					bLastFragment = FALSE;
    BOOLEAN					bFirstFragment = FALSE;

	TRACE(CLASSIFY, ClientHandle, pNdisPacket, "GpcClassifyPacket");
    
    DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X CH=%d\n", 
                        ClientHandle, *pClassificationHandle));

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    ASSERT(pPacket);
    ASSERT(ClientHandle);
    //ASSERT(pClientCfInfoContext);
    ASSERT(pClassificationHandle);

    if (ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    pProtocol = &glData.pProtocols[ProtocolTemplate];

    //
    // Optimization - check if there are any patterns installed
    //

    if (pProtocol->SpecificPatternCount == 0
        &&
        pProtocol->GenericPatternCount == 0 ) {
        
        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }
        *pClassificationHandle = 0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X no patterns returned %X\n", 
                            ClientHandle, GPC_STATUS_NOT_FOUND));

        return GPC_STATUS_NOT_FOUND;
    }

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pNdisPacket = (PNDIS_PACKET)pPacket;

    //
    // get the classification handle from the packet
    // if there - extract the blob pointer and the client blob context
    // directly and return
    //

    //
    // o/w, we need to look inside the packet
    // Parse the packet into a pattern and make a db search
    // first match a specific pattern, and then search the generic
    // database(s) for the given CF
    //

    pCf = pClient->pCfBlock;

    CfIndex = pCf->AssignedIndex;

    ProtocolStatInc(ProtocolTemplate,ClassificationRequests);

    *pClassificationHandle = 0;

    //
    // get the pattern from the packet
    //

    //
    // get the first NDIS buffer - assuming it is a MAC header
    //

    NdisGetFirstBufferFromPacket(pNdisPacket,
                                 &pNdisBuf1,   // Ndis buffer 1 desc.
                                 &pAddr,       // buffer VA
                                 &Len,         // buffer length
                                 &Tot          // total length (all buffs)
                                 );

    ASSERT(Tot > TransportHeaderOffset);

    while (Len <= TransportHeaderOffset) {
        
        //
        // Transport header is not in this buffer,
        // try the next buffer
        //

        TransportHeaderOffset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        ASSERT(pNdisBuf2); // should never happen!!
        NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    switch (ProtocolTemplate) {

    case GPC_PROTOCOL_TEMPLATE_IP:

        //
        // fill the pattern with '0'
        //
        
        RtlZeroMemory(&IpPattern, sizeof(IpPattern));

        //
        // parse IP packet here...
        //

        pIpHdr = (PIP_HEADER)(((PUCHAR)pAddr) + TransportHeaderOffset);
        IpHdrLen = (pIpHdr->iph_verlen & (uchar)~IP_VER_FLAG) << 2;
        
        FragOffset = pIpHdr->iph_offset & IP_OFFSET_MASK;
        FragOffset = net_short(FragOffset) * 8;

        PacketId = pIpHdr->iph_id;

        //
        // check for fragmentation
        //

        bFragment = (pIpHdr->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
        bFirstFragment = bFragment && (FragOffset == 0);
        bLastFragment = bFragment && 
            TEST_BIT_OFF(pIpHdr->iph_offset, IP_MF_FLAG);

        //
        // sanity check - doesn't make sense to have a single fragment
        //

        ASSERT(!bFirstFragment || !bLastFragment);

        if (TEST_BIT_ON(pClient->Flags, GPC_FLAGS_FRAGMENT) &&
            (bFragment && ! bFirstFragment)) {
            
            //
            // client is interested in fragmentation and this is a
            // a fragment, but not the first one.
            // It will be handled later when we find the pattern
            //

            Status = HandleFragment(
                                    pClient,
                                    pProtocol,
                                    bFirstFragment,    // first frag
                                    bLastFragment,     // last frag
                                    PacketId,
                                    &pPattern,
                                    &pBlob
                                    );

        } else {

            //
            // not a fragment, or is the first one - we have to search db
            //

            IpPattern.SrcAddr = pIpHdr->iph_src;
            IpPattern.DstAddr = pIpHdr->iph_dest;
            IpPattern.ProtocolId = pIpHdr->iph_protocol;
            
            //
            // case the ProtocolId and fill the appropriate union
            //
            
            switch (IpPattern.ProtocolId) {
                
            case IPPROTO_IP:
                //
                // we have everything so far
                //

                break;


            case IPPROTO_TCP:
            case IPPROTO_UDP:

                //
                // need to get those port numbers
                //

                if (IpHdrLen < Len) {

                    //
                    // the UDP/TCP header is in the same buffer
                    // 

                    pUDPHdr = (PUDP_HEADER)((PUCHAR)pIpHdr + IpHdrLen);
                    
                } else {

                    //
                    // get the next buffer
                    //
                    
                    NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
                    ASSERT(pNdisBuf2);
            
                    if (IpHdrLen > Len) {
                
                        //
                        // There is an optional header buffer, so get the next
                        // buffer to reach the udp/tcp header
                        //
                        
                        pNdisBuf1 = pNdisBuf2;
                        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
                        ASSERT(pNdisBuf2);
                    }
            
                    NdisQueryBuffer(pNdisBuf2, &pUDPHdr, &Len);
                }

                IpPattern.gpcSrcPort = pUDPHdr->uh_src;
                IpPattern.gpcDstPort = pUDPHdr->uh_dest;
#if INTERFACE_ID
                IpPattern.InterfaceId.InterfaceId = pInterfaceId->InterfaceId;
                IpPattern.InterfaceId.LinkId = pInterfaceId->LinkId;
#endif
                break;
                
            case IPPROTO_ICMP:
            case IPPROTO_IGMP:
            default:

                // 
                // The default will cover all IP_PROTO_RAW packets. Note that in this case, all we care about
                // is the InterfaceID
                //
#if INTERFACE_ID
                IpPattern.InterfaceId.InterfaceId = pInterfaceId->InterfaceId;
                IpPattern.InterfaceId.LinkId = pInterfaceId->LinkId;
#endif
                break;

            case IPPROTO_IPSEC:

                pKey = NULL;
                Status = GPC_STATUS_NOT_SUPPORTED;
            }
            
            pKey = &IpPattern;
            break;
        }
        
        DBGPRINT(CLASSIFY, ("IP: ifc={%d,%d} src=%X:%x, dst=%X:%x, prot=%x, rsv=%x,%x,%x \n", 
                            IpPattern.InterfaceId.InterfaceId,
                            IpPattern.InterfaceId.LinkId,
                            IpPattern.SrcAddr,
                            IpPattern.gpcSrcPort,
                            IpPattern.DstAddr,
                            IpPattern.gpcDstPort,
                            IpPattern.ProtocolId,
                            IpPattern.Reserved[0],
                            IpPattern.Reserved[1],
                            IpPattern.Reserved[2]
                            ));
        break;
        

    case GPC_PROTOCOL_TEMPLATE_IPX:

        //
        // fill the pattern with '0'
        //
        
        RtlZeroMemory(&IpxPattern, sizeof(IpxPattern));

        //
        // parse IPX packet here...
        //

        pIpxHdr = (PIPX_HEADER)(((PUCHAR)pAddr) + TransportHeaderOffset);

        //
        // source
        //
        IpxPattern.Src.NetworkAddress = *(ULONG *)pIpxHdr->SourceNetwork;
        RtlMoveMemory(IpxPattern.Src.NodeAddress, pIpxHdr->SourceNode,6);
        IpxPattern.Src.Socket = pIpxHdr->SourceSocket;

        //
        // destination
        //
        IpxPattern.Dest.NetworkAddress = *(ULONG *)pIpxHdr->DestinationNetwork;
        RtlMoveMemory(IpxPattern.Dest.NodeAddress, pIpxHdr->DestinationNode,6);
        IpxPattern.Dest.Socket = pIpxHdr->DestinationSocket;

        pKey = &IpxPattern;

        break;
        
    default:
        Status = GPC_STATUS_INVALID_PARAMETER;

    }

    if (NT_SUCCESS(Status) && pPattern == NULL) {

        //
        // no failure so far but no pattern found either
        // search for the pattern
        //

        ASSERT(pKey);

        //
        // if there is a match, the pattern ref count will be bumped
        // up and we need to release it when we're done.
        //

        Status = InternalSearchPattern(
                                         pClient, 
                                         pProtocol, 
                                         pKey,
                                         &pPattern,
                                         pClassificationHandle,
                                         FALSE
                                         );
    }

    if (*pClassificationHandle) {
        
        if (pClientCfInfoContext) {

            Status = GpcGetCfInfoClientContext(ClientHandle,
                                              *pClassificationHandle,
                                              pClientCfInfoContext);
        }

        ProtocolStatInc(ProtocolTemplate, PacketsClassified);

    } else {

        //ASSERT(pBlob == NULL);

        //
        // none found, or some other error occured.
        //

        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }

        *pClassificationHandle = 0;

        Status = GPC_STATUS_NOT_FOUND;
    }

	TRACE(CLASSIFY, pPattern, Status, "GpcClassifyPacket==>");

    DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X returned Pattern=%X, CH=%d, Status=%X\n", 
                        pClient, pPattern, *pClassificationHandle, Status));
    return Status;
}





/*
************************************************************************

GpcEnumCfInfo -

	Called to enumerate CfInfo's (and attached filters).
    For each CfInfo, GPC will return the CfInfo blob and the list of 
    pattern attached to it.

Arguments

	ClientHandle	- the calling client
    pBlob			- the next cfinfo to enumerate, NULL for the first
    pBlobCount		- in: requested; out: returned
    pBufferSize		- in: allocated; out: bytes returned
    Buffer			- output buffer

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcEnumCfInfo(
	IN     GPC_HANDLE				ClientHandle,
    IN OUT PHANDLE					pCfInfoHandle,
    OUT    PHANDLE					pCfInfoMapHandle,
    IN OUT PULONG					pCfInfoCount,
    IN OUT PULONG					pBufferSize,
    IN     PGPC_ENUM_CFINFO_BUFFER	Buffer
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS 			st;
    PBLOB_BLOCK			pBlob = NULL;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    PPATTERN_BLOCK		pPattern;
    ULONG				cCfInfo = 0;
    ULONG				cTotalBytes = 0;
    ULONG				cPatterns, cValidPatterns;
    ULONG				size, cValidSize;
    ULONG				PatternMaskLen;
    ULONG				PatternSize;
    ULONG				i;
    PCHAR				p, q;
    PGENERIC_PATTERN_DB	pGenDb;
    UNICODE_STRING		CfInfoName;
    PGPC_GEN_PATTERN	pGenPattern;
    BOOLEAN				bEnum;
    KIRQL				ReadIrql;
    KIRQL				irql;
    PCLIENT_BLOCK		pNotifiedClient;
    GPC_CLIENT_HANDLE	NotifiedClientCtx;
    BOOLEAN             found = FALSE;
    UNICODE_STRING      UniStr;

    //
    //  debug checks
    //

    ASSERT(ClientHandle);
    ASSERT(pCfInfoHandle);
    ASSERT(pCfInfoMapHandle);
    ASSERT(pCfInfoCount);
    ASSERT(pBufferSize);
    ASSERT(Buffer);

    cValidPatterns  = 0;

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    pCf = ((PCLIENT_BLOCK)ClientHandle)->pCfBlock;

    //NDIS_LOCK(&pCf->Lock);
    
    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    //
    // check if we start from a previous blob
    //

    if (*pCfInfoHandle) {

        pBlob = (PBLOB_BLOCK)*pCfInfoHandle;

        NDIS_LOCK(&pBlob->Lock);

        if (pBlob->State == GPC_STATE_REMOVE) {
            
            //
            // the blob has been marked for removal
            //

            NDIS_UNLOCK(&pBlob->Lock);
            //NDIS_UNLOCK(&pCf->Lock);

            RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
            
            *pCfInfoMapHandle = NULL;

            return STATUS_DATA_ERROR;
        }

        //NDIS_UNLOCK(&pBlob->Lock);

    } else {

        //
        // find the first (good) blob to enumerate.
        //
            
        //
        // Need to take pCf->Lock to manipulate or 
        // traverse the Blobs on it
        //
        NDIS_LOCK(&pCf->Lock);

        if (IsListEmpty(&pCf->BlobList)) {

            //
            // no blobs to enumerate
            //

            *pCfInfoCount = 0;
            *pBufferSize = 0;
            *pCfInfoMapHandle = NULL;

            //NDIS_UNLOCK(&pCf->Lock);

            NDIS_UNLOCK(&pCf->Lock);

            RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

            return GPC_STATUS_SUCCESS;

        } else {

            //
            // Find a good Blob (something that's not getting deleted)
            //
            pEntry = pCf->BlobList.Flink;

            while (&pCf->BlobList != pEntry) {
            
                pBlob = CONTAINING_RECORD(pEntry, BLOB_BLOCK, CfLinkage);
                NDIS_LOCK(&pBlob->Lock);

                if ((pBlob->State == GPC_STATE_READY) && 
                    (pBlob->ObjectType != GPC_ENUM_INVALID)) {
                    
                    found = TRUE;
                    break;


                } else {

                    //Aha! The first Blob is bad!!
                    pEntry = pEntry->Flink;
                    NDIS_UNLOCK(&pBlob->Lock);
                }

            }
            
            //
            // Couldn't find anything to enumerate.
            if (!found) {
                
                //No Blobs to enumerate

                *pCfInfoCount = 0;
                *pBufferSize = 0;
                *pCfInfoMapHandle = NULL;
    
                NDIS_UNLOCK(&pCf->Lock);

                //NDIS_UNLOCK(&pCf->Lock);
                RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
    
                return GPC_STATUS_SUCCESS;

            }
        }
        
        NDIS_UNLOCK(&pCf->Lock);

    }

    ASSERT(pBlob);

    *pCfInfoMapHandle = pBlob->ClHandle;

    //
    // at this point, we should have a blob pointer that we can 
    // start enumerating. The CF is still lock, so we can safely
    // walk the BlobList
    // The blob lock is also taken so we can scan the pattern list
    //

    for ( ; ; ) {	// we'll break out from this

        //NDIS_LOCK(&pBlob->Lock);

        //NdisInterlockedIncrement(&pBlob->RefCount);

        //ASSERT (pBlob->State != GPC_STATE_REMOVE);
 
        //NDIS_UNLOCK(&pBlob->Lock);

        pHead = &pBlob->PatternList;
        pEntry = pHead->Flink;
        
        //
        // Calculate how much space is needed for just one CfInfo
        // and all of its filters
        //
        
        size = sizeof(GPC_ENUM_CFINFO_BUFFER) + pBlob->ClientDataSize;

        // 
        // patterns might become invalid while we try to enum the CF, so we set cValidSize here
        // we have to align cValidSize so that the next CfInfo starts at a word boundary.
        //

        size = ((size + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
        cValidSize = size;

        //
        // Count the patterns
        //
       
        for (cPatterns = 0, PatternMaskLen = 0;
             pHead != pEntry; 
             cPatterns++, pEntry = pEntry->Flink) {

            pPattern = CONTAINING_RECORD(pEntry, 
                                         PATTERN_BLOCK, 
                                         BlobLinkage[pCf->AssignedIndex]);
            
            PatternMaskLen += (sizeof(GPC_GEN_PATTERN) +
                               2 * glData.pProtocols[pPattern->ProtocolTemplate].PatternSize);

        }

        //
        // check if we have enough buffer space
        //
        size += PatternMaskLen;
        cValidPatterns = 0;

        if ((cTotalBytes + size) <= *pBufferSize) {

            //
            // yes, we can squeeze one more...
            //
            pEntry = pHead->Flink;

            pGenPattern = &Buffer->GenericPattern[0];

            for (i = 0; 
                 ((i < cPatterns) && (pEntry != pHead)); 
                 i++, pEntry = pEntry->Flink) {

                //
                // fill all the patterns + masks in
                //

                pPattern = CONTAINING_RECORD(pEntry, 
                                             PATTERN_BLOCK,
                                             BlobLinkage[pCf->AssignedIndex] );

                NDIS_LOCK(&pPattern->Lock);
                
                // Check for pattern's state...
                //

                if (GPC_STATE_READY != pPattern->State) {
                    
                    // don't try to list it out if its being removed!
                    NDIS_UNLOCK(&pPattern->Lock);
                    continue;

                }

                cValidSize += (sizeof(GPC_GEN_PATTERN) +
                         2 * glData.pProtocols[pPattern->ProtocolTemplate].PatternSize);


                PatternSize = glData.pProtocols[pPattern->ProtocolTemplate].PatternSize;
                pGenPattern->ProtocolId = pPattern->ProtocolTemplate;
                pGenPattern->PatternSize = PatternSize;
                pGenPattern->PatternOffset = sizeof(GPC_GEN_PATTERN);
                pGenPattern->MaskOffset = pGenPattern->PatternOffset + PatternSize;

                p = ((PUCHAR)pGenPattern) + pGenPattern->PatternOffset;

                cValidPatterns++;

                //
                // get the pattern and mask bits
                //

                if (TEST_BIT_ON(pPattern->Flags, PATTERN_SPECIFIC)) {

                    //
                    // this is a specific pattern
                    //

                    READ_LOCK(&glData.pProtocols[pPattern->ProtocolTemplate].SpecificDb.Lock, &ReadIrql);

                    ASSERT(pPattern->DbCtx);

                    q = GetKeyPtrFromSpecificPatternHandle
                        (((SpecificPatternHandle)pPattern->DbCtx));

                    RtlMoveMemory(p, q, PatternSize);
                    
                    p += PatternSize;

                    //
                    // that's a specific pattern, remember?
                    //

                    NdisFillMemory(p, PatternSize, (CHAR)0xff);

                    READ_UNLOCK(&glData.pProtocols[pPattern->ProtocolTemplate].SpecificDb.Lock, ReadIrql);

                } else {

                    pGenDb = &pCf->arpGenericDb[pPattern->ProtocolTemplate][pPattern->Priority];

                    READ_LOCK(&pGenDb->Lock, &ReadIrql);

                    //
                    // generic pattern
                    //

                    ASSERT(pPattern->DbCtx);

                    q = GetKeyPtrFromPatternHandle(pGenDb->pRhizome, 
                                                   pPattern->DbCtx);

                    RtlMoveMemory(p, q, PatternSize);
                    
                    p += PatternSize;

                    //
                    // mask
                    //

                    q = GetMaskPtrFromPatternHandle(pGenDb->pRhizome, 
                                                    pPattern->DbCtx);

                    RtlMoveMemory(p, q, PatternSize);

                    READ_UNLOCK(&pGenDb->Lock, ReadIrql);

                }
                
                p += PatternSize;
                pGenPattern = (PGPC_GEN_PATTERN)p;
                
                NDIS_UNLOCK(&pPattern->Lock);
                    
            } // for (i = 0; ...)

            //
            // we can now fill the CfInfo data.
            // 'pGenPattern' now points to the place where we can safely
            // store the CfInfo structure, and update the pointer
            //

            Buffer->InstanceNameLength = 0;
            pNotifiedClient = pBlob->pNotifiedClient;
            NotifiedClientCtx = pBlob->NotifiedClientCtx;

            st = GPC_STATUS_FAILURE;

            if (pNotifiedClient) {

                if (pNotifiedClient->FuncList.ClGetCfInfoName &&
                    NotifiedClientCtx) {

                    st = pNotifiedClient->FuncList.ClGetCfInfoName(
                                           pNotifiedClient->ClientCtx,
                                           NotifiedClientCtx,
                                           &CfInfoName
                                           );
                
                    if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                    
                    //
                    // RajeshSu claims this can never happen.
                    //
                    ASSERT(NT_SUCCESS(st));

                }

            } 

            if (NT_SUCCESS(st)) {

                //
                // copy the instance name
                //
                
                Buffer->InstanceNameLength = CfInfoName.Length;
                RtlMoveMemory(Buffer->InstanceName, 
                              CfInfoName.Buffer,
                              CfInfoName.Length
                              );
            } else {

                //
                // generate a default name
                //
                if (NotifiedClientCtx) {

                    RtlInitUnicodeString(&UniStr, L"Flow <ClientNotified>");

                } else {

                    RtlInitUnicodeString(&UniStr, L"Flow <unknown name>");

                }


                RtlCopyMemory(Buffer->InstanceName, UniStr.Buffer, UniStr.Length);

                Buffer->InstanceNameLength = UniStr.Length;
                
            }

            Buffer->InstanceName[Buffer->InstanceNameLength/sizeof(WCHAR)] = L'\0';
                
            //
            // 'pGenPattern' should point to the location right after the last
            // mask, so we fill the CfInfo data there
            //

            //NDIS_LOCK(&pBlob->Lock);

            RtlMoveMemory(pGenPattern, 
                          pBlob->pClientData, 
                          pBlob->ClientDataSize);

            Buffer->Length          = cValidSize;
            Buffer->CfInfoSize      = pBlob->ClientDataSize;
            
            Buffer->CfInfoOffset    = (ULONG)((PCHAR)pGenPattern 
                                              - (PCHAR)Buffer);	// offset to structure
            Buffer->PatternCount    = cValidPatterns;
            Buffer->PatternMaskLen  = PatternMaskLen;
            Buffer->OwnerClientCtx  = pBlob->pOwnerClient->ClientCtx;

            //
            // release the blob lock we've got earlier
            //
            NDIS_UNLOCK(&pBlob->Lock);
            
            //
            // update total counts
            //
            cCfInfo++;
            cTotalBytes += cValidSize;
            Buffer = (PGPC_ENUM_CFINFO_BUFFER)((PCHAR)Buffer + cValidSize);

            pEntry = pBlob->CfLinkage.Flink;

            //
            // advance to the next blob in the list
            //

            if (pEntry == &pCf->BlobList) {

                //
                // end of blob list, reset the blob to NULL and return 
                //
                
                pBlob = NULL;
                *pCfInfoMapHandle = NULL;
                
                break;
            }

            pBlob = CONTAINING_RECORD(pEntry,
                                       BLOB_BLOCK, 
                                       CfLinkage);
            *pCfInfoMapHandle = pBlob->ClHandle;

            if (cCfInfo == *pCfInfoCount) {

                //
                // enough CfInfo's filled
                //

                break;
            }

            //
            // lock the blob for the next cycle
            //

            NDIS_LOCK(&pBlob->Lock);

        } else { // if (cTotalBytes + size <= *pBufferSize)...

            //
            // size is too small, set return values and break
            //

            //DereferenceBlob(&pBlob);

            if (cCfInfo == 0) {

                Status = GPC_STATUS_INSUFFICIENT_BUFFER;
            }

            //
            // release the blob lock we've got earlier
            //

            NDIS_UNLOCK(&pBlob->Lock);

            break;

        }

    } // for (;;")

    //NDIS_UNLOCK(&pCf->Lock);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
    
    *pCfInfoHandle = (GPC_HANDLE)pBlob;
    *pCfInfoCount = cCfInfo;
    *pBufferSize = cTotalBytes;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpchlp.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcdb.c

Abstract:

    This file contains specific patterns database routines

Author:

    Ofer Bar  -April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"

//
// locals
//

/*
************************************************************************

CreateNewCfBlock -

create and return a new CF block for internal use

Arguments

	CfId			- 
    MaxPriorities	-

Returns
	pointer to the new CF block or NULL for no memory resources

************************************************************************
*/
PCF_BLOCK
CreateNewCfBlock(
	IN	ULONG			CfId,
    IN	ULONG			MaxPriorities
    )
{
    PCF_BLOCK	pCf;
    int			i;
    GPC_STATUS	Status;

    GpcAllocFromLL(&pCf, &ClassificationFamilyLL, ClassificationFamilyTag);

    if (pCf) {

        //
        // reset all
        //

        NdisZeroMemory(pCf, sizeof(CF_BLOCK));

        InitializeListHead(&pCf->ClientList);
        InitializeListHead(&pCf->BlobList);
        NDIS_INIT_LOCK(&pCf->Lock);
        //pCf->ClientSync = 0;
        //INIT_LOCK(&pCf->ClientSync);
        NDIS_INIT_LOCK(&pCf->ClientSync);

        pCf->NumberOfClients = 0;
        pCf->AssignedIndex = CfId;
        pCf->MaxPriorities = MaxPriorities;
        ReferenceInit(&pCf->RefCount, pCf, ReleaseCfBlock);
        REFADD(&pCf->RefCount, 'CFBK');

        //
        // for each protocol, reset the generic pattern
        // this will be dynamically allocated later
        // when pattern are installed
        //
        
        for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {

            Status = InitializeGenericDb(&pCf->arpGenericDb[i], 
                                         MaxPriorities,
                                         glData.pProtocols[i].PatternSize);
            
            if (Status != GPC_STATUS_SUCCESS) {
                
                REFDEL(&pCf->RefCount, 'CFBK');
                pCf = NULL;
                break;
            }
        }
    }

    return pCf;
}


/*
************************************************************************

ReleaseCfBlock -

Release the CF block

Arguments

	pCf - the CF block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseCfBlock(
	IN  PCF_BLOCK	pCf
    )
{
    int		i;

    ASSERT(pCf);
    ASSERT(IsListEmpty(&pCf->ClientList));
    ASSERT(IsListEmpty(&pCf->BlobList));
    ASSERT(pCf->NumberOfClients == 0);

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
        
        if (pCf->arpGenericDb[i]) {
            
            UninitializeGenericDb(&pCf->arpGenericDb[i],
                                  pCf->MaxPriorities
                                  );
        }
    }
    
    NdisFreeSpinLock(&pCf->Lock);

    //
    // just free the memory
    //

    GpcFreeToLL(pCf, &ClassificationFamilyLL, ClassificationFamilyTag);
}




/*
************************************************************************

CreateNewClientBlock -

create and return a new client block for internal use

Arguments
	none

Returns
	pointer to the new client block or NULL for no memory resources

************************************************************************
*/
PCLIENT_BLOCK
CreateNewClientBlock(VOID)
{
    PCLIENT_BLOCK	pClient;

    GpcAllocFromLL(&pClient, &ClientLL, ClientTag);

    if (pClient) {

        //
        // reset all
        //

        NdisZeroMemory(pClient, sizeof(CLIENT_BLOCK));

        pClient->ObjectType = GPC_ENUM_CLIENT_TYPE;
        pClient->ClHandle = NULL;

        NDIS_INIT_LOCK(&pClient->Lock);
        InitializeListHead(&pClient->BlobList);
        ReferenceInit(&pClient->RefCount, pClient, DereferenceClient);
        REFADD(&pClient->RefCount, 'CLNT');
    }

    return pClient;
}




/*
************************************************************************

CreateNewPatternBlock -

create and return a new pattern block for internal use

Arguments
	none

Returns
	pointer to the new pattern block or NULL for no memory resources

************************************************************************
*/
PPATTERN_BLOCK
CreateNewPatternBlock(
                     IN  ULONG	Flags
                     )
{
    PPATTERN_BLOCK	pPattern;
    int				i;

    GpcAllocFromLL(&pPattern, &PatternLL, PatternTag);

    if (pPattern) {

        //
        // reset all
        //

        TRACE(PATTERN, pPattern, sizeof(PATTERN_BLOCK), "CreateNewPatternBlock");

        NdisZeroMemory(pPattern, sizeof(PATTERN_BLOCK));

        pPattern->ObjectType = GPC_ENUM_PATTERN_TYPE;
        
        for (i = 0; i < GPC_CF_MAX; i++) {
            InitializeListHead(&pPattern->BlobLinkage[i]);
        }

        InitializeListHead(&pPattern->TimerLinkage);
        NDIS_INIT_LOCK(&pPattern->Lock);
        pPattern->Flags = Flags;
        ReferenceInit(&pPattern->RefCount, pPattern, DereferencePattern);
        REFADD(&pPattern->RefCount, 'FILT');
        pPattern->ClientRefCount = 1;
        pPattern->State = GPC_STATE_INIT;

        //AllocateHandle(&pPattern->ClHandle, (PVOID)pPattern);
    }

    return pPattern;
}




/*
************************************************************************

CreateNewBlobBlock -

create and return a new blob block for internal use.
A copy of ClientData is being place pointed by the new blob

Arguments
	none

Returns
	pointer to the new blob block or NULL for no memory resources

************************************************************************
*/
PBLOB_BLOCK
CreateNewBlobBlock(
                     IN  ULONG		ClientDataSize,
                     IN  PVOID		pClientData,
                     BOOLEAN            fChargeQuota // Should I charge Quota?
                     )
{
    // Quota Charging should be done only if we have a proces context

    PBLOB_BLOCK	pBlob;

    
    if (fChargeQuota){
            GpcAllocMemWithQuota(&pBlob,CfInfoLLSize,CfInfoTag);
        }
    else{
           GpcAllocMem(&pBlob,CfInfoLLSize,CfInfoTag);
        }
        
    

    if (pBlob) {

        //
        // reset all
        //
            
        NdisZeroMemory(pBlob, sizeof(BLOB_BLOCK));


        if (fChargeQuota){
            GpcAllocMemWithQuota(&pBlob->pClientData, 
                    ClientDataSize, CfInfoDataTag);
        }
        else{
           GpcAllocMem(&pBlob->pClientData,
                    ClientDataSize, CfInfoDataTag);
        }
        

        if (pBlob->pClientData) {

            pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;
            pBlob->ClHandle = NULL;
            
            InitializeListHead(&pBlob->ClientLinkage);
            InitializeListHead(&pBlob->PatternList);
            InitializeListHead(&pBlob->CfLinkage);

            pBlob->State = GPC_STATE_INIT;
            pBlob->Flags = 0;
            ReferenceInit(&pBlob->RefCount, pBlob, DereferenceBlob);
            REFADD(&pBlob->RefCount, 'BLOB');
            pBlob->ClientDataSize = ClientDataSize;
            pBlob->LastStatus = GPC_STATUS_SUCCESS;
            NdisMoveMemory(pBlob->pClientData, pClientData, ClientDataSize);
            NDIS_INIT_LOCK(&pBlob->Lock);

            //
            // that's for the notified client about the CfInfo Add
            //

            pBlob->pNotifiedClient = NULL;
            pBlob->NotifiedClientCtx = NULL;

        } else {

            //GpcFreeToLL(pBlob, &CfInfoLL, CfInfoTag);
            GpcFreeMem(pBlob,CfInfoTag);

            pBlob = NULL;
        }
    }

    return pBlob;
}




/*
************************************************************************

AssignNewClientIndex -

Finds and returns a new index for a client on the CF. It also sets
the index as busy in the CF block.

Arguments
	pClient - poinetr to the client block

Returns
	a client index or (-1) for none

************************************************************************
*/
ULONG
AssignNewClientIndex(
                     IN PCF_BLOCK	pCfBlock
                     )
{
    ULONG	i;

    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {

        if (TEST_BIT_OFF(pCfBlock->ClientIndexes, (1 << i)))
            break;
    }

    if (i < MAX_CLIENTS_CTX_PER_BLOB) {

        //
        // found a zero bit, set it on
        //

        pCfBlock->ClientIndexes |= (1 << i);

    } else {
        i = (-1);
    }

    return i;
}



/*
************************************************************************

ReleaseClientBlock -

Release the client block

Arguments
	pClientBlock - the client block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseClientBlock(
                   IN  PCLIENT_BLOCK	pClientBlock
                   )
{
    NdisFreeSpinLock(&pClientBlock->Lock);

    //
    // just free the memory
    //

    GpcFreeToLL(pClientBlock, &ClientLL, ClientTag);
}




/*
************************************************************************

ReleasePatternBlock -

Release the pattern block

Arguments
	pPatternBlock - the pattern block to release

Returns
	void

************************************************************************
*/
VOID
ReleasePatternBlock(
                   IN  PPATTERN_BLOCK	pPatternBlock
                   )
{

#if DBG
    pPatternBlock->TimeToLive = 0xdeadbeef;
#endif 

    //
    // just free the memory
    //

    GpcFreeToLL(pPatternBlock, &PatternLL, PatternTag);
}





/*
************************************************************************

ReleaseBlobBlock -

Release the blob block

Arguments
	pBlobBlock - the blob block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseBlobBlock(
                   IN  PBLOB_BLOCK	pBlobBlock
                   )
{

    //
    // just free the memory
    //
    
    GpcFreeMem(pBlobBlock->pClientData, CfInfoDataTag);
    ASSERT(pBlobBlock->pNewClientData == NULL);
    //GpcFreeToLL(pBlobBlock, &CfInfoLL, CfInfoTag);
    GpcFreeMem(pBlobBlock,CfInfoTag);
}





/*
************************************************************************

CreateNewClassificationBlock -

create and return a new classification block for internal use

Arguments
	NumEntries - number of entries

Returns
	pointer to the new classification block or NULL for no memory resources

************************************************************************
*/
PCLASSIFICATION_BLOCK
CreateNewClassificationBlock(
                             IN  ULONG	NumEntries
                             )
{
    PCLASSIFICATION_BLOCK	pClassification;
    ULONG					l;

    l = sizeof(CLASSIFICATION_BLOCK) + sizeof(PBLOB_BLOCK) * (NumEntries-1);
    GpcAllocMem(&pClassification, l, ClassificationBlockTag);

    if (pClassification) {

        //
        // reset all
        //

        NdisZeroMemory(pClassification, l);

        pClassification->NumberOfElements = NumEntries;
    }

    return pClassification;
}




/*
************************************************************************

ReleaseClassificationBlock -

Release the Classification block

Arguments
	pClassificationBlock - the Classification block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseClassificationBlock(
                           IN  PCLASSIFICATION_BLOCK	pClassificationBlock
                           )
{
    if (pClassificationBlock) {

        //
        // release the memory block
        //
        
        GpcFreeMem(pClassificationBlock, ClassificationBlockTag);
    }
}





/*
************************************************************************

GpcCalcHash -

Calculate the hash table key for a specific pattern

Arguments
	ProtocolTempId - The protocol template
    pPattern	   - a pointer to the pattern

Returns
	ULONG - the hash key, (-1) if Protocol value is illegal

************************************************************************
*/
ULONG
GpcCalcHash(
            IN	ULONG		ProtocolTempId,
            IN	PUCHAR		pPattern
            )
{
    ULONG				Key = (-1);
    ULONG				temp;
    PULONG				Cheat;
    PGPC_IP_PATTERN		pIpPatt;
    PGPC_IPX_PATTERN	pIpxPatt;
    const ULONG			MagicNumber = 0x9e4155b9; // magic number - hocus pocus

    TRACE(LOOKUP, ProtocolTempId, pPattern, "GpcClacHash");

    ASSERT(pPattern);

    switch (ProtocolTempId) {

    case GPC_PROTOCOL_TEMPLATE_IP:

        //
        // the IP protocol template, this function was contributed by
        // JohnDo
        //

        pIpPatt = (PGPC_IP_PATTERN)pPattern;
        temp = (pIpPatt->SrcAddr << 16) ^ (pIpPatt->SrcAddr >> 16)
            ^ pIpPatt->DstAddr ^ pIpPatt->ProtocolId ^ pIpPatt->gpcSpi;
        Key = temp * MagicNumber;	
        break;

    case GPC_PROTOCOL_TEMPLATE_IPX:

        //
        // the IPX protocol template, this function was contributed by
        // JohnDo
        //

        Cheat = (PULONG)pPattern;
        temp = 
            (Cheat[0] << 16) ^ (Cheat[0] >> 16) ^
            (Cheat[1] << 16) ^ (Cheat[1] >> 16) ^
            (Cheat[2] << 16) ^ (Cheat[2] >> 16) ^
            Cheat[3] ^ Cheat[4] ^ Cheat[5];

        Key = temp * MagicNumber;
        break;

    default:

        //
        // illegal value
        //

        ASSERT(0);
    }

    //
    // -1 is a bad key
    //

    if (Key == (-1))
        Key = 0;

    TRACE(LOOKUP, Key, 0, "GpcClacHash==>");

    return Key;
}





/*
************************************************************************

DereferencePattern -

Decrement the RefCount and deletes the pattern block if the count reaches
zero.

Arguments
    pPattern	- a pointer to the pattern

Returns
	void

************************************************************************
*/
VOID
DereferencePattern(
                   IN  PPATTERN_BLOCK	pPattern
                   )
{
    ASSERT(pPattern);
    //ASSERT(pPattern->RefCount.Count > 0);

    TRACE(PATTERN, pPattern, pPattern->DbCtx, "DereferencePattern");

    ProtocolStatInc(pPattern->ProtocolTemplate,
                    DerefPattern2Zero);

    ASSERT(IsListEmpty(&pPattern->TimerLinkage));

    //
    // no longer do we need this CB
    //

    ReleaseClassificationBlock(pPattern->pClassificationBlock);

    //
    // time to remove the pattern
    //
        
    ReleasePatternBlock(pPattern);

}



/*
************************************************************************

DereferenceBlob -

Decrement the RefCount and deletes the blob block if the count reaches
zero.

Arguments
    pBlob	   - a pointer to the blob

Returns
	void

************************************************************************
*/
VOID
DereferenceBlob(
                IN  PBLOB_BLOCK	pBlob
                )
{
    ASSERT(pBlob);
     //
    // If there is a File Object, dereference it.
    //
    if (pBlob->FileObject) {
        ObDereferenceObject(pBlob->FileObject);
        pBlob->FileObject = NULL;
    }

    if (pBlob->Pattern) {
        GpcFreeMem(pBlob->Pattern,TcpPatternTag);
        pBlob->Pattern = NULL;
    }
    

    //ASSERT(*ppBlob);

    //TRACE(BLOB, *ppBlob, (*ppBlob)->RefCount, "DereferenceBlob");
    
    //ASSERT((*ppBlob)->RefCount.Count > 0);

    CfStatInc(pBlob->pOwnerClient->pCfBlock->AssignedIndex,DerefBlobs2Zero);

    //
    // time to remove the blob
    //

    ReleaseBlobBlock(pBlob);
        
}



/*
************************************************************************

DereferenceClient -

Decrement the RefCount and deletes the client block if the count reaches
zero.

Arguments
    pClient - pointer to the client block

Returns
	void

************************************************************************
*/
VOID
DereferenceClient(
                  IN  PCLIENT_BLOCK	pClient
                  )
{
    PCF_BLOCK   pCf;
    KIRQL		irql;

    ASSERT(pClient);

    //TRACE(CLIENT, pClient, pClient->RefCount, "DereferenceClient");

    //ASSERT(pClient->RefCount.Count > 0);

    pCf = pClient->pCfBlock;

    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    //
    // time to remove the client
    //

    GpcRemoveEntryList(&pClient->ClientLinkage);
    ReleaseClientIndex(pCf->ClientIndexes, pClient->AssignedIndex);

    ReleaseClientBlock(pClient);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
}





/*
************************************************************************

ClientAddCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientAddCfInfo(
                IN	PCLIENT_BLOCK			pClient,
                IN  PBLOB_BLOCK             pBlob,
                OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
                )
{
    GPC_STATUS  Status = GPC_STATUS_SUCCESS;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientAddCfInfo");

    *pClientCfInfoContext = NULL;

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClAddCfInfoNotifyHandler) {
            
            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfo (2)");

            // Pass in link id if a client of the new interface registers
             if (IS_USERMODE_CLIENT_EX(pBlob->pOwnerClient)){
                        Status = (pClient->FuncList.ClAddCfInfoNotifyHandler)
                        (
                            pClient->ClientCtx,
                            (GPC_HANDLE)pBlob,
                            &(pBlob->Pattern->InterfaceId),
                            pBlob->ClientDataSize,
                            pBlob->pClientData,
                            pClientCfInfoContext
                         );
                }
             else{
                
                Status = (pClient->FuncList.ClAddCfInfoNotifyHandler)
                        (
                            pClient->ClientCtx,
                            (GPC_HANDLE)pBlob,
                            NULL,
                            pBlob->ClientDataSize,
                            pBlob->pClientData,
                            pClientCfInfoContext
                         );
                }

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, *pClientCfInfoContext, Status, "ClientAddCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {

                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        }
    }

    return Status;
}

  

/*
************************************************************************

ClientAddCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientAddCfInfoComplete(
                        IN	PCLIENT_BLOCK			pClient,
                        IN	PBLOB_BLOCK             pBlob,
                        IN	GPC_STATUS				Status
                        )
{
    ULONG	CfIndex;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientAddCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pClient);
    ASSERT(pBlob);

    if (pClient->State == GPC_STATE_READY) {

#if NO_USER_PENDING

        //
        // the user is blocking on this call
        //

        CTESignal(&pBlob->WaitBlock, Status);

#else

        CfIndex = pClient->pCfBlock->AssignedIndex;

        if (NT_SUCCESS(Status)) {
            
            CfStatInc(CfIndex,CreatedBlobs);
            CfStatInc(CfIndex,CurrentBlobs);
            
        } else {
            
            CfStatInc(CfIndex,RejectedBlobs);
        }

        if (pClient->FuncList.ClAddCfInfoCompleteHandler) {
            
            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfoComplete (2)");
            TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientAddCfInfoComplete (3)");

            (pClient->FuncList.ClAddCfInfoCompleteHandler)
                (
                 pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 Status
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientAddCfInfoComplete (4)");

        } else if (IS_USERMODE_CLIENT(pClient) 
                   &&
                   pClient == pBlob->pOwnerClient ) {

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfoComplete (5)");

            //
            // this is a user mode client - call the specific routine
            // to complete a pending IRP, but only if the client is the 
            // blob owner
            //

            UMCfInfoComplete( OP_ADD_CFINFO, pClient, pBlob, Status );
                                
            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientAddCfInfoComplete (6)");

        }

        if (NT_SUCCESS(Status)) {
            
            pBlob->State = GPC_STATE_READY;
            
        } else {
            
            //
            // remove the blob
            //
            REFDEL(&pBlob->RefCount, 'BLOB');

        }
#endif
    }
}



/*
************************************************************************

ClientModifyCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientModifyCfInfoComplete(
                           IN	PCLIENT_BLOCK			pClient,
                           IN	PBLOB_BLOCK             pBlob,
                           IN	GPC_STATUS	        	Status
                           )
{
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientModifyCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClModifyCfInfoCompleteHandler) {
            
            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfoComplete (2)");

            (pClient->FuncList.ClModifyCfInfoCompleteHandler)
                (
                 pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 Status
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfoComplete (3)");

        } else if (IS_USERMODE_CLIENT(pClient)) {

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfoComplete (4)");

            UMCfInfoComplete( OP_MODIFY_CFINFO, pClient, pBlob, Status );
                                
            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfoComplete (5)");
        }

    }
}



/*
************************************************************************

ClientModifyCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientModifyCfInfo(
                   IN	PCLIENT_BLOCK			pClient,
                   IN   PBLOB_BLOCK             pBlob,
                   IN   ULONG                   CfInfoSize,
                   IN   PVOID                   pClientData
                   )
{
    GPC_STATUS  Status = GPC_STATUS_IGNORED;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientModifyCfInfo");

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClModifyCfInfoNotifyHandler) {

            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfo (2)");

            Status = (pClient->FuncList.ClModifyCfInfoNotifyHandler)
                (pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 CfInfoSize,
                 pClientData
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {
             
                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        }
    }

    return Status;
}




/*
************************************************************************

ClientRemoveCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientRemoveCfInfoComplete(
                           IN	PCLIENT_BLOCK			pClient,
                           IN	PBLOB_BLOCK             pBlob,
                           IN	GPC_STATUS				Status
                           )
{
    ULONG	CfIndex;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientRemoveCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pClient);
    ASSERT(pBlob);

#if NO_USER_PENDING

    //
    // the user is blocking on this call
    //
    
    CTESignal(&pBlob->WaitBlock, Status);

#else

    CfIndex = pClient->pCfBlock->AssignedIndex;

    if (NT_SUCCESS(Status)) {
        
        CfStatInc(CfIndex,DeletedBlobs);
        CfStatDec(CfIndex,CurrentBlobs);
    }
    
    if (pClient->FuncList.ClRemoveCfInfoCompleteHandler) {
        
        GET_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientRemoveCfInfoComplete (2)");

        (pClient->FuncList.ClRemoveCfInfoCompleteHandler)
            (
             pClient->ClientCtx,
             pBlob->arClientCtx[pClient->AssignedIndex],
             Status
             );
        
        VERIFY_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfoComplete (3)");

    } else if (IS_USERMODE_CLIENT(pClient)) {

        GET_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientRemoveCfInfoComplete (4)");

        UMCfInfoComplete( OP_REMOVE_CFINFO, pClient, pBlob, Status );
        
        VERIFY_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfoComplete (5)");
    }

#endif
}



/*
************************************************************************

ClientRemoveCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientRemoveCfInfo(
                   IN	PCLIENT_BLOCK			pClient,
                   IN   PBLOB_BLOCK             pBlob,
                   IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
                   )
{
    GPC_STATUS  Status = GPC_STATUS_SUCCESS;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientRemoveCfInfo");

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClRemoveCfInfoNotifyHandler) {

            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, ClientCfInfoContext, "ClientRemoveCfInfo (2)");

            Status = (pClient->FuncList.ClRemoveCfInfoNotifyHandler)
                (pClient->ClientCtx,
                 ClientCfInfoContext
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {
             
                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        } else if 
                    (IS_USERMODE_CLIENT(pClient) //For client using IOCTL interface
                   &&
                   !IS_USERMODE_CLIENT_EX(pClient)//But Not for new IOCTL interfaces
                   &&
                   pClient == pBlob->pOwnerClient) {// If the client owns the Blob

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, ClientCfInfoContext, "ClientRemoveCfInfo (4)");

            //
            // the notified client installed the blob
            // and it is a user mode client
            // we need to make a special call to dequeue a pending IRP
            // and complete it with the specified data
            //

            UMClientRemoveCfInfoNotify(pClient, pBlob);

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfo (5)");
        }
    }

    return Status;
}





/*
************************************************************************

ClearPatternLinks - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClearPatternLinks(
                  IN  PPATTERN_BLOCK        pPattern,
                  IN  PPROTOCOL_BLOCK		pProtocol,
                  IN  ULONG                 CfIndex
                  )
{
    PBLOB_BLOCK    *ppBlob;

    //
    // Remove the pattern from the blob list
    // and NULL the pointer to the blob in the pattern block
    //

    ppBlob = & GetBlobFromPattern(pPattern, CfIndex);

    if (*ppBlob) {

        NDIS_LOCK(&(*ppBlob)->Lock);

        GpcRemoveEntryList(&pPattern->BlobLinkage[CfIndex]);

        NDIS_UNLOCK(&(*ppBlob)->Lock);

        *ppBlob = NULL;

    }

}




/*
************************************************************************

ModifyCompleteClients - 


Arguments


Returns
	

************************************************************************
*/
VOID
ModifyCompleteClients(
                      IN  PCLIENT_BLOCK   pClient,
                      IN  PBLOB_BLOCK     pBlob
                      )
{
    uint            i;
    PCLIENT_BLOCK   pNotifyClient;
    KIRQL			irql;

    if (NT_SUCCESS(pBlob->LastStatus)) {
        
        //
        // in case of successful completion, assign the 
        // new client data
        //
        
        NDIS_LOCK(&pBlob->Lock);
        WRITE_LOCK(&glData.ChLock, &irql);

        GpcFreeMem(pBlob->pClientData, CfInfoDataTag);
        pBlob->ClientDataSize = pBlob->NewClientDataSize;
        pBlob->pClientData = pBlob->pNewClientData;

        WRITE_UNLOCK(&glData.ChLock, irql);
        NDIS_UNLOCK(&pBlob->Lock);

    } else {
        
        GpcFreeMem(pBlob->pNewClientData, CfInfoDataTag);
    }

    pBlob->NewClientDataSize = 0;
    pBlob->pNewClientData = NULL;
    
    //
    // notify each client (except the caller) that successfully
    // modified the blob about the status. 
    // it can be SUCCESS or some failure
    //
    
    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {
        
        //
        // only clients with none zero entries
        // have been succefully modified the blob
        //
        
        if (pNotifyClient = pBlob->arpClientStatus[i]) {
            
            //
            // complete here
            //
            
            ClientModifyCfInfoComplete(
                                       pNotifyClient,
                                       pBlob,
                                       pBlob->LastStatus
                                       );
            
            //
            // release the one we got earlier
            //
            
            //DereferenceClient(pNotifyClient);
        }
        
    } // for

#if 0
    //
    // now, complete the call back to the calling client
    //
    
    ClientModifyCfInfoComplete(
                               pBlob->pCallingClient,
                               pBlob,
                               pBlob->LastStatus
                               );
#endif

    pBlob->State = GPC_STATE_READY;
}




#if 0
/*
************************************************************************

GetClassificationHandle - 

Get the classification handle from the blob. If none is available
creates a new one. '0' is not a valid CH!

Arguments
    pClient  - The calling client
    pPattern - The pattern that refers to the CH

Returns
    A classification handle 

************************************************************************
*/
CLASSIFICATION_HANDLE
GetClassificationHandle(
                        IN  PCLIENT_BLOCK   pClient,
                        IN  PPATTERN_BLOCK  pPattern
                        )
{
    HFHandle				hfh;
	ULONG					t;
    PCLASSIFICATION_BLOCK	pCB;

	TRACE(CLASSIFY, pClient, pPattern, "GetClassificationHandle:");

    if (TEST_BIT_ON(pPattern->Flags,PATTERN_SPECIFIC)) {
        
        //
        // this is a specific pattern
        //

        //
        // get the CH from it
        //

        ASSERT(pPattern->pClassificationBlock);
        hfh = pPattern->pClassificationBlock->ClassificationHandle;

        //
        // check if CH is valid
        //

        t = pPattern->ProtocolTemplate;
        
        pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(glData.pCHTable, 
                                                           hfh);
        
        TRACE(CLASSHAND, pCB, hfh, "GetClassificationHandle (~)");

        if (pCB != pPattern->pClassificationBlock) {

            //
            // the CH is invalid, release it and get a new one
            //

            NDIS_LOCK(&glData.Lock);

            release_HF_handle(glData.pCHTable, hfh);

            ProtocolStatInc(pPattern->ProtocolTemplate, 
                            RemovedCH);
        
            TRACE(CLASSHAND, glData.pCHTable, hfh, "GetClassificationHandle (-)");

            hfh = assign_HF_handle(glData.pCHTable,
                                   (void *)pPattern->pClassificationBlock);

            ProtocolStatInc(pPattern->ProtocolTemplate, 
                            InsertedCH);
        

            NDIS_UNLOCK(&glData.Lock);

            TRACE(CLASSIFY, pPattern, hfh, "GetClassificationHandle (+)");

            pPattern->pClassificationBlock->ClassificationHandle = hfh;
        }

    } else {

        //
        // this is a generic pattern
        //

        hfh = 0;

    }

	TRACE(CLASSIFY, pPattern, hfh, "GetClassificationHandle==>");

    return (CLASSIFICATION_HANDLE)hfh;
}
#endif



/*
************************************************************************

FreeClassificationHandle - 

Free the classification handle. It will invalidate the entry in the 
index table and make it avaiable for future use.

Arguments
    pClient  - The calling client
    CH       - The classification handle

Returns
    void

************************************************************************
*/
VOID
FreeClassificationHandle(
                         IN  PCLIENT_BLOCK          pClient, 
                         IN  CLASSIFICATION_HANDLE  CH
                         )
{
    KIRQL	CHirql;

    WRITE_LOCK(&glData.ChLock, &CHirql);

    release_HF_handle(glData.pCHTable, CH);

    TRACE(CLASSHAND, glData.pCHTable, CH, "FreeClassificationHandle");

    WRITE_UNLOCK(&glData.ChLock, CHirql);
}




GPC_STATUS
CleanupBlobs(
             IN  PCLIENT_BLOCK     pClient
             )
{
    PBLOB_BLOCK          pBlob;
    //PPATTERN_BLOCK       pPattern;
    //ULONG                CfIndex = pClient->pCfBlock->AssignedIndex;
    GPC_STATUS           Status = GPC_STATUS_SUCCESS;

    NDIS_LOCK(&pClient->Lock);

    //
    // scan blobs
    //

    while (!IsListEmpty(&pClient->BlobList)) {

        //
        // get the blob
        //

        pBlob = CONTAINING_RECORD(pClient->BlobList.Flink, BLOB_BLOCK, ClientLinkage);

        pBlob->Flags |= PATTERN_REMOVE_CB_BLOB;

        NDIS_UNLOCK(&pClient->Lock);

        //
        // remove the blob
        //
        
        Status = GpcRemoveCfInfo((GPC_HANDLE)pClient,
                                 (GPC_HANDLE)pBlob
                                 );

        NDIS_LOCK(&pClient->Lock);
        
    }

    NDIS_UNLOCK(&pClient->Lock);

    return GPC_STATUS_SUCCESS;
}




VOID
CloseAllObjects(
	IN	PFILE_OBJECT	FileObject,
    IN  PIRP			Irp
    )
{
    PLIST_ENTRY     	pEntry0, pHead0;
    PLIST_ENTRY     	pEntry, pHead;
    PCLIENT_BLOCK		pClient = NULL;
    PCF_BLOCK			pCf;
    PPROTOCOL_BLOCK		pProtocol;
    //int					i,j;
    //NTSTATUS			NtStatus;
    //QUEUED_COMPLETION	QItem;
    KIRQL				irql;

    NDIS_LOCK(&glData.Lock);

    pHead0 = &glData.CfList;
    pEntry0 = pHead0->Flink;

    while (pEntry0 != pHead0 && pClient == NULL) {

        pCf = CONTAINING_RECORD(pEntry0, CF_BLOCK, Linkage);
        pEntry0 = pEntry0->Flink;
        
        RSC_READ_LOCK(&pCf->ClientSync, &irql);

        pHead = &pCf->ClientList;
        pEntry = pHead->Flink;
            
        while (pEntry != pHead && pClient == NULL) {

            pClient = CONTAINING_RECORD(pEntry,CLIENT_BLOCK,ClientLinkage);
            pEntry = pEntry->Flink;

            if (pClient->pFileObject == FileObject) {

                REFADD(&pClient->RefCount, 'CAOB');

            } else {

                pClient = NULL;
            }
        }

        RSC_READ_UNLOCK(&pCf->ClientSync, irql);
        
    } // while (...)
        
    NDIS_UNLOCK(&glData.Lock);

    if (pClient) {

        //
        // clear all the blobs on the client
        //
        
        CleanupBlobs(pClient);
        
        //
        // deregister the client
        //
        
        GpcDeregisterClient((GPC_HANDLE)pClient);

        //
        // release the previous ref count
        //
        
        REFDEL(&pClient->RefCount, 'CAOB');

    }                    

}



// Cool new feature - Timer Wheels [ShreeM]
// We maintain N lists of patterns, one for each "timertick". The Pattern 
// Expiry routine will clean up one of the lists every time it is invoked.
// It then makes a note to cleanup the next list on the wheel, the next time
// it is invoked.
// The Timer Wheels reduces spin lock contention between inserts and deletes.

VOID
PatternTimerExpired(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					FunctionContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
)
{
    PLIST_ENTRY		pEntry;
    PPATTERN_BLOCK	pPattern;
    ULONG           CleanupWheelIndex = 0, NewWheelIndex;
    PPROTOCOL_BLOCK	pProtocol = &glData.pProtocols[PtrToUlong(FunctionContext)];

    TRACE(PAT_TIMER, FunctionContext, 0, "PatternTimerExpired");

    DBGPRINT(PAT_TIMER, ("PatternTimerExpired: Timer expired, protocol=%d \n", 
                        PtrToUlong(FunctionContext)));

    //
    // Which of the timer wheels do we want to cleanup this time?
    // Remember that we Increment the current index pointer into the wheels
    // All the wheel index calculations are protected by gldata->lock.
    NDIS_LOCK(&glData.Lock);

    CleanupWheelIndex   = pProtocol->CurrentWheelIndex;
    pProtocol->CurrentWheelIndex += 1;
    //
    // Make sure we wrap around.
    //
    pProtocol->CurrentWheelIndex %= NUMBER_OF_WHEELS;
    NDIS_UNLOCK(&glData.Lock);
    NDIS_LOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);


    while (!IsListEmpty(&pProtocol->TimerPatternList[CleanupWheelIndex])) {

    	PCLIENT_BLOCK pClient;

        pEntry = RemoveHeadList(&pProtocol->TimerPatternList[CleanupWheelIndex]);

        pPattern = CONTAINING_RECORD(pEntry, PATTERN_BLOCK, TimerLinkage);

	 InitializeListHead(&pPattern->TimerLinkage);

        NDIS_UNLOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);
        
        ASSERT(pPattern->TimeToLive != 0xdeadbeef);
        
        ASSERT(TEST_BIT_ON( pPattern->Flags, PATTERN_AUTO ));

        NDIS_LOCK(&pPattern->Lock);
        pPattern->Flags |= ~PATTERN_AUTO;
        NDIS_UNLOCK(&pPattern->Lock);

        

        TRACE(PAT_TIMER, pPattern, pPattern->RefCount.Count, "PatternTimerExpired: del");

        ProtocolStatInc(pPattern->ProtocolTemplate,
                        DeletedAp);

        ProtocolStatDec(pPattern->ProtocolTemplate,
                        CurrentAp);

        //
        // actually remove the pattern
        //

        DBGPRINT(PAT_TIMER, ("PatternTimerExpired: removing pattern=%X, ref=%d, client=%X \n", 
                            pPattern, pPattern->RefCount, pPattern->pAutoClient));

	pClient = pPattern->pAutoClient;

        GpcRemovePattern((GPC_HANDLE)pPattern->pAutoClient,
                         (GPC_HANDLE)pPattern);

	 REFDEL(&(pClient->RefCount), 'CLNT');
        InterlockedDecrement(&pProtocol->AutoSpecificPatternCount);

        NDIS_LOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);

    }
    
    NDIS_UNLOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);

    //
    // If there are any Auto Specific patterns around restart the timer.
    //
    if(InterlockedExchangeAdd(&pProtocol->AutoSpecificPatternCount, 0) > 0) {
    
        NdisSetTimer(&pProtocol->PatternTimer, PATTERN_TIMEOUT);
        
        DBGPRINT(PAT_TIMER, ("PatternTimer restarted\n"));
    
    } else {

        DBGPRINT(PAT_TIMER, ("Zero Auto Patterns - Timer NOT restarted\n"));

    }

}



GPC_STATUS
AddSpecificPatternWithTimer(
	IN	PCLIENT_BLOCK			pClient,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					PatternKey,
    OUT	PPATTERN_BLOCK			*ppPattern,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
)
{
    GPC_STATUS		Status=GPC_STATUS_SUCCESS;
    PPATTERN_BLOCK	pPattern=NULL, pCreatedPattern=NULL;
    PPROTOCOL_BLOCK	pProtocol = &glData.pProtocols[ProtocolTemplate];
    UCHAR			Mask[MAX_PATTERN_SIZE];
    ULONG           WheelIndex = 0;
    ULONG           ulCurrentAutoPatternCount=0;


    ulCurrentAutoPatternCount=InterlockedExchangeAdd(&pProtocol->AutoSpecificPatternCount,0);
    DBGPRINT(PAT_TIMER,("MSGPC:Creating New AutoPattern: Number of AutoPatterns"
        "Before Creation = %ul \n", ulCurrentAutoPatternCount));

    if (ulCurrentAutoPatternCount > glData.AutoPatternLimit) {
            DBGPRINT(PAT_TIMER,("MSGPCHit AutoPatternLimit : Num AutoPatterns = %ul  :"
                "Limit =%ul \n",ulCurrentAutoPatternCount, glData.AutoPatternLimit));
            Status = GPC_STATUS_NO_MEMORY;
            goto exit;
        }
        
    TRACE(PAT_TIMER, pClient, PatternKey, "AddSpecificPatternWithTimer");

#if DBG
    {
        PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)PatternKey;
        
        DBGPRINT(PAT_TIMER, ("AddSpecificPatternWithTimer: Client=%X \n", pClient));
#if INTERFACE_ID
        DBGPRINT(PAT_TIMER, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n",
                             pIp->InterfaceId.InterfaceId,
                             pIp->InterfaceId.LinkId,
                             pIp->SrcAddr,
                             pIp->gpcSrcPort,
                             pIp->DstAddr,
                             pIp->gpcDstPort,
                             pIp->ProtocolId,
                             pIp->Reserved[0],
                             pIp->Reserved[1],
                             pIp->Reserved[2]
                             ));
#endif
    }
#endif

    RtlFillMemory(Mask, sizeof(Mask), 0xff);

    pPattern = CreateNewPatternBlock(PATTERN_SPECIFIC);
    pCreatedPattern = pPattern;
    
    if (pPattern) {
        
        //
        // setup the pattern fields and add it
        //
        
        //pPattern->RefCount++;
        pPattern->Priority = 0;
        pPattern->ProtocolTemplate = ProtocolTemplate;
        pPattern->Flags |= PATTERN_AUTO;
        // This flag indicates that the auto pattern is not on 
        // timer list yet .  This means
        // the pattern is not ready yet though it may or may
        // not have been inserted into the patternhashtable
        pPattern->Flags |= PATTERN_AUTO_NOT_READY;
        pPattern->pAutoClient = pClient;

        Status = AddSpecificPattern(
                                    pClient,
                                    PatternKey,
                                    Mask,
                                    NULL,
                                    pProtocol,
                                    &pPattern,  // output pattern pointer
                                    pClassificationHandle
                                    );
        

    } else {

        Status = GPC_STATUS_NO_MEMORY;

    }
    
    if (NT_SUCCESS(Status)) {
        
        //
        // we didn't get an already existing pattern
        //

        //ASSERT(*pClassificationHandle);
        
        *ppPattern = pPattern;
        
        // Figure out which wheel to stick this pattern on.
        NDIS_LOCK(&glData.Lock);
        WheelIndex = pProtocol->CurrentWheelIndex;
        NDIS_UNLOCK(&glData.Lock);
        
        WheelIndex += (NUMBER_OF_WHEELS -1);
        WheelIndex %= NUMBER_OF_WHEELS;

        //
        // we must lock this pattern since we look at the timer linkage
        // 

        NDIS_LOCK(&pPattern->Lock);

        //
        // set the AUTO flag again, since we might have got
        // a pattern that already exist
        //

        pPattern->Flags |= PATTERN_AUTO;
        pPattern->pAutoClient = pClient;
        pPattern->WheelIndex = WheelIndex;

        //
        // this pattern has not been on any the timer list yet
        //

        if (IsListEmpty(&pPattern->TimerLinkage)) {

            //
            // We need to insert this in the TimerWheel which is (NUMBER_OF_WHEELS - 1)
            // away from the current, so that it spends enough time on the list.
            //
            NDIS_DPR_LOCK(&pProtocol->PatternTimerLock[WheelIndex]);
        
            //
            // If the AutoSpecificPatternCount was zero earlier, then we need
            // to a) start the timer and b) increment this count.
            //
            if (1 == InterlockedIncrement(&pProtocol->AutoSpecificPatternCount)) {
            
                //
                // restart the timer for the first auto pattern
                //
                NdisSetTimer(&pProtocol->PatternTimer, PATTERN_TIMEOUT);
                
                TRACE(PAT_TIMER, pPattern, PATTERN_TIMEOUT, "Starting Pattern Timer\n AddSpecificPatternWithTimer: (1)");
            }
        
            GpcInsertHeadList(&pProtocol->TimerPatternList[WheelIndex], &pPattern->TimerLinkage);

            //
            // don't refer to pPattern after it has been placed on the timer list
            // since the timer may expire any time and remove it from there...
            //
            
            NDIS_DPR_UNLOCK(&pProtocol->PatternTimerLock[WheelIndex]);

        }

        //
        // This is a specific pattern, so lets increment the count [ShreeM].
        InterlockedIncrement(&pProtocol->SpecificPatternCount);
        // Pattern is now ready. It has been inserted
        // into the hash table and has been put into the
        // timer list.
        pPattern->Flags &= ~PATTERN_AUTO_NOT_READY;

        NDIS_UNLOCK(&pPattern->Lock);
        
        ProtocolStatInc(ProtocolTemplate,
                        CreatedAp);
        
        ProtocolStatInc(ProtocolTemplate,
                        CurrentAp);
    } else {
        
        
         goto exit;     
    }

    
    
exit:
    if (!NT_SUCCESS(Status)){
       *ppPattern = NULL;
       *pClassificationHandle = 0;     
         ProtocolStatInc(ProtocolTemplate,
                        RejectedAp);
            }
    else{
    		REFADD(&pClient->RefCount, 'CLNT');
    	}
            
    if (pPattern) {

        //
        // release the reference count to this pattern
        // in case of an error, this will also release
        // the data block
        //

        REFDEL(&pCreatedPattern->RefCount, 'FILT');
    }

    TRACE(PAT_TIMER, pPattern, Status, "AddSpecificPatternWithTimer==>");
    
    DBGPRINT(CLASSIFY, ("AddSpecificPatternWithTimer: pClient=%X Pattern=%X Status=%X\n", 
                        pClient, pPattern, Status));
    return Status;
}


// SS202 CR
// 
NTSTATUS
InitPatternTimer(
	IN	ULONG	ProtocolTemplate
)
{
    ULONG  i=0;

    
    //
    // We increase the granularity of when a "Automatic" Pattern gets cleaned 
    // out by using timer wheels, but they are more efficient for inserting and
    // removing (in terms of locks).
    //
    
    for (i = 0; i < NUMBER_OF_WHEELS; i++) {
        
        NDIS_INIT_LOCK(&glData.pProtocols[ProtocolTemplate].PatternTimerLock[i]);

        InitializeListHead(&glData.pProtocols[ProtocolTemplate].TimerPatternList[i]);

    }

    glData.pProtocols[ProtocolTemplate].CurrentWheelIndex = 0;

    
    NdisInitializeTimer(&glData.pProtocols[ProtocolTemplate].PatternTimer, 
                        PatternTimerExpired, 
                        (PVOID) ULongToPtr(ProtocolTemplate));

    return STATUS_SUCCESS;
}


//
// Some CRT and RTL functions that cant be used at DISPATHC_LEVEL IRQL are being 
// cut/paste here.
//



NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    )
/*++

Routine Description:

    Opens a Registry key and returns a handle to it.

Arguments:

    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(HandlePtr,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}



NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
/*++

Routine Description:

    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


/*++

Routine Description:

    Reads a REG_DWORD value from registry and init the variable passed in..

Arguments:

      - Open handle to the parent key of the value to read.
    param  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
VOID
GPC_REG_READ_DWORD(HANDLE hRegKey, PWCHAR pwcName, PULONG  pulData, ULONG ulDefault,ULONG  ulMax, ULONG ulMin) {   
    NTSTATUS   status;                                                   
    status = GetRegDWORDValue(hRegKey,                                   
                                pwcName,                                     
                                (pulData));                                    
                                                                            
    if (!NT_SUCCESS(status)) {                                            
        *(pulData) = ulDefault;                                                     
    } else if (*(pulData) > ulMax) {                                            
        *(pulData) = ulMax;                                                     
    } else if (*(pulData) < ulMin) {                                           
        *(pulData) = ulMin;                                                     
    }                                                                       
}

VOID
GpcReadRegistry()
/*++

Routine Description:

    Reads config info from registry into glData

Arguments:


Return Value:

    status of the read.

--*/
{
    NTSTATUS        status;
    HANDLE          hRegKey;
    WCHAR           GpcParametersRegistryKey[] = GPC_REG_KEY;
   
    glData.SystemSizeHint = MmQuerySystemSize();
    switch (glData.SystemSizeHint)
        {
            case MmSmallSystem:
                        glData.AutoPatternLimit = DEFAULT_SMALL_SYSTEM_AUTO_PATTERN_LIMIT;
                        break;
                                               
            case MmMediumSystem:
                        glData.AutoPatternLimit = DEFAULT_MEDIUM_SYSTEM_AUTO_PATTERN_LIMIT;
                        break;
                                                 
            case MmLargeSystem: 
                        glData.AutoPatternLimit = DEFAULT_LARGE_SYSTEM_AUTO_PATTERN_LIMIT;
                        break;
                  
            default: break;
        }

    status = OpenRegKey(&hRegKey,
                        GpcParametersRegistryKey);

    if (NT_SUCCESS(status)) {
        //
        // Expected configuration values. We use reasonable defaults if they
        // aren't available for some reason.
        //
       GPC_REG_READ_DWORD(   hRegKey,
                                GPC_REG_AUTO_PATTERN_LIMIT,
                                &glData.AutoPatternLimit,
                                glData.AutoPatternLimit,
                                GPC_AUTO_PATTERN_MAX,
                                GPC_AUTO_PATTERN_MIN);
        }
     ZwClose(hRegKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcmap.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCMAP
#define __GPCMAP

//***   gpcmap.h - GPC definitions & prototypes for mapping handles
//

HANDLE
AllocateHandle(
    OUT HANDLE *OutHandle,           
    IN  PVOID  Reference
    );

VOID
SuspendHandle(
    IN 	HANDLE    Handle
    );

VOID
ResumeHandle(
    IN 	HANDLE    Handle
    );

VOID
FreeHandle(
    IN 	HANDLE    Handle
    );

PVOID
GetHandleObject(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType
    );

PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType,
    IN  ULONG                   Ref

    );

GPC_STATUS
InitMapHandles(VOID);

VOID
UninitMapHandles(VOID);


#endif //__GPCMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcpre.h ===
//
// gpcpre.h
//

#include <ndis.h>
#include <ntddndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>


#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <ntddk.h>

#include "refcnt.h"
#include "gpcifc.h"
#include "rhizome.h"
#include "pathash.h"
#include "handfact.h"
#include "ntddgpc.h"
#include "gpcstruc.h"
#include "gpcdef.h"
#include "gpcdbg.h"
#include "gpcmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\handfact.c ===
/*
 *  handfact.c
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This source file provides functions that implement assignment, release, and
 *  dereferencing operations with a handle_factory.  The code is object-oriented
 *  C, transliterated from a C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  None of the code or comments in this file need to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, handfact.h.
 *
 */

#include "gpcpre.h"

/*
 *  There are a number of aspects to the handle factory that must be understood
 *  by anyone wishing to modify this code.  The description in this comment
 *  block is intended to provide a progressive overview of the handle factory.
 *
 *  The basic system comprises a table of entries.  Each assigned handle
 *  corresponds to a single, unique entry, as determined by the handle value
 *  modulo the table size.  A handle is validated by comparing the handle value
 *  to the stored handle value in the entry.  The unassigned entries are kept
 *  on a list; when an entry is released (or revoked), it is put on the tail of
 *  the list, and when an entry is needed for an assignment, it is taken from
 *  the head of the list.
 *
 *  If there are no unassigned entries in the table when a new handle is
 *  requested, a new table of twice the size is allocated, and all assigned
 *  handles are relocated to the new table.  All unassigned handles in the new
 *  table are placed on the unassigned list.
 *
 *  As handles are released, the space required for handle entries is reduced.
 *  The table can be contracted into a table of half the size if no two assigned
 *  handles will yield the same entry address.  Two handles which will yield
 *  the same entry address in a half-size table are called a pair, and the
 *  number of such pairs is tracked in the variable pair_count, which must be
 *  zero in order to contract the table.  In order to minimize the number of
 *  pairs in the table, there are actually two lists of unassigned entries.
 *  Assigning an entry from the primary list will not increase the pair count,
 *  whereas assigning an entry from the secondary list will increase the pair
 *  count.  Thus, assignments are always made from the primary list, if it is
 *  not empty.
 *
 *  Assigned handles are also kept on a list, in order of assignment.  If it
 *  becomes necessary to revoke a handle to make room for another, the oldest
 *  handle will be revoked, and it will be found at the head of this list.
 *
 */

// This macro allocates an array of HFEntry structures.  The size of the array
// is provided as an argument to the macro.
//
//#define NEW_HFEntry_array(array_size) \
//	((HFEntry *)malloc(array_size * sizeof(HFEntry)))
#define NEW_HFEntry_array(_a,array_size) \
	GpcAllocMem(&_a,array_size * sizeof(HFEntry), HandleFactoryTag)

// This macro allocates an array of integers.  The size of the array is
// provided as an argument to the macro.
//
//#define NEW_int_array(array_size) \
//	((int *)malloc(array_size * sizeof(int)))
#define NEW_int_array(_a,array_size) \
	GpcAllocMem(&_a,array_size * sizeof(int), HandleFactoryTag)

/*
 *  Following are prototypes for static functions that are used internally by
 *  the handle factory routines.
 *
 */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact);

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact);

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact);

// Every entry is on one of three lists, and the heads and tails of these lists
// are maintained in the entry_list[] array.  The index of this array is given
// by the following three manifest constants.
//
#define LD_PRIMARY 0       // first list from which to select an entry to assign
#define LD_SECONDARY 1    // second list from which to select an entry to assign
#define LD_ASSIGNED 2    // list of assigned entries, in order of assignment age

// When the handle space is recycled, there is a danger of handle collisions.
// In order to substantially reduce the likelihood of these collisions, very
// old handles are revoked well before their recycling begins, to give the
// holders of these handles ample opportunity to notice that their handles
// have become invalid and to request new handles.  Thus, handles are revoked
// when they become more than MAX_HANDLE_RANGE less than the currently generated
// handles.  To reduce overhead, revokations are performed in batches of size
// determined by HANDLE_RANGE_STEP.
//
// A handle may be suspended by incrementing the handle value by
// HANDLE_RANGE_STEP.  This causes the comparison in dereference_HF_handle() to
// fail, so the handle is judged to be invalid.  To reinstate the handle, the
// handle value is decremented by HANDLE_RANGE_STEP, returning the handle to its
// original value.  A handle that is suspended will be revoked one revokation
// pass later than it would have been if it hadn't been suspended.
//
#define HANDLE_RANGE_STEP ((HFHandle)0x20000000)
#define MAX_HANDLE_RANGE ((HFHandle)0x90000000)

// To keep the mean assignment and release times constant (and, indirectly, to
// minimize the allocation chatter of rapidly expanding and contracting the
// table), the table is not necessarily contracted as soon as possible.
// Hysteresis is employed to postpone the contraction until the computational
// cost of previous expansions and contractions is distributed over a sufficient
// number of assignment or release operations to maintain a constant cost per
// operation ratio.  The cost of each expansion is equal to the overhead of
// memory allocation and deallocation plus the cost to split each entry into
// two entries.  The cost of each contraction is equal to the overhead of
// memory allocation and deallocation plus the cost to merge each pair of
// entries into one entry.  The cost of memory allocation and deallocation is
// equal to ALLOCATION_COST times the mean cost of a single split or merge
// operation.  This value was determined by empirical measurement.
//
#define ALLOCATION_COST 12

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact)
{
	// The table size is initially set to 2, and it will never be smaller.
	hfact->table_size = 2;
	// Allocate space for the initial table.
	NEW_HFEntry_array(hfact->entries,hfact->table_size);
	if (hfact->entries == 0)
	{
		// Memory could not be allocated for the array of entries created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
		return 1;
	}
	hfact->verifier0 = 0;   // the verifiers are initialized with the same value
	hfact->verifier1 = 0;   // the verifiers are initialized with the same value
	hfact->handle_base = 0;                         // handles will start with 0
	hfact->population = 0;                      // no handles initially assigned
	hfact->pair_count = 0;                // since no assigned handles, no pairs
	hfact->hysteresis_debt = 0;
	// Initialize the two entries that are initially allocated.  Both are marked
	// as unassigned; the larger value (2) is put on the secondary list, and the
	// smaller value (1) on the secondary list.  Record 0 contains an initial
	// handle value of 2 instead of 0 because a handle value of 0 is reserved.
	hfact->entries[0].handle = hfact->handle_base + hfact->table_size;
	hfact->entries[0].next_handle = hfact->handle_base + hfact->table_size;
	hfact->entries[0].reference = 0;
	hfact->entries[0].next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entries[0].prev_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entries[1].handle = hfact->handle_base + 1;
	hfact->entries[1].next_handle = hfact->handle_base + 1;
	hfact->entries[1].reference = 0;
	hfact->entries[1].next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entries[1].prev_entry = &hfact->entry_list[LD_PRIMARY];
	// Initialize the primary list.  This list initially contains entry 1.
	hfact->entry_list[LD_PRIMARY].handle = 0;
	hfact->entry_list[LD_PRIMARY].next_handle = 0;
	hfact->entry_list[LD_PRIMARY].reference = 0;
	hfact->entry_list[LD_PRIMARY].next_entry = &hfact->entries[1];
	hfact->entry_list[LD_PRIMARY].prev_entry = &hfact->entries[1];
	// Initialize the secondary list.  This list initially contains entry 0.
	hfact->entry_list[LD_SECONDARY].handle = 0;
	hfact->entry_list[LD_SECONDARY].next_handle = 0;
	hfact->entry_list[LD_SECONDARY].reference = 0;
	hfact->entry_list[LD_SECONDARY].next_entry = &hfact->entries[0];
	hfact->entry_list[LD_SECONDARY].prev_entry = &hfact->entries[0];
	// Initialize the assigned list.  This list initially is empty.
	hfact->entry_list[LD_ASSIGNED].handle = 0;
	hfact->entry_list[LD_ASSIGNED].next_handle = 0;
	hfact->entry_list[LD_ASSIGNED].reference = 0;
	hfact->entry_list[LD_ASSIGNED].next_entry = &hfact->entry_list[LD_ASSIGNED];
	hfact->entry_list[LD_ASSIGNED].prev_entry = &hfact->entry_list[LD_ASSIGNED];
	// Reduce handle_base by HANDLE_RANGE_STEP so that suspended handles will
	// not slip through revokation.
	hfact->handle_base -= HANDLE_RANGE_STEP;
	// return an indication of success to the client.
	return 0;
}

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact)
{
	// Free the space consumed by the table of handles.
	GpcFreeMem(hfact->entries, HandleFactoryTag);
}

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference)
{
	int list;
	HFEntry *entry;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing
	HFHandle handle;
	HFHandle handle_range;

	if (hfact->population >= hfact->table_size)
	{
		// All entries in the table are assigned, so it is necessary to
		// increase the table size.
		int expansion_failure = expand_HF_table(hfact);
		if (expansion_failure)
		{
            //
            // just fail
            //

            return 0;
#if 0

            // Expanding the table failed, presumably due to inability to
			// allocate sufficient memory.  So, instead, we revoke the least-
			// recently assigned handle.  First, remove the entry from the
			// assigned list and place it on the secondary list.
			entry = hfact->entry_list[LD_ASSIGNED].next_entry;
			entry->next_entry->prev_entry = &hfact->entry_list[LD_ASSIGNED];
			hfact->entry_list[LD_ASSIGNED].next_entry = entry->next_entry;
			entry->next_entry = &hfact->entry_list[LD_SECONDARY];
			entry->prev_entry = hfact->entry_list[LD_SECONDARY].prev_entry;
			hfact->entry_list[LD_SECONDARY].prev_entry->next_entry = entry;
			hfact->entry_list[LD_SECONDARY].prev_entry = entry;
			// Then, invalidate the handle.  The order of the operations is
			// important to correct multi-threaded operation.
			seq_entry = entry;
			seq_entry->handle = entry->next_handle;   // first invalidate handle
			seq_entry->reference = 0;                    // then clear reference
			// Decrement the pair count and population, so that when they are
			// incremented in the code below, they will have correct values.
			hfact->pair_count--;
			hfact->population--;
#endif
		}
	}
	// At this point, there is at least one available entry.  If there is any
	// entry on the primary list, it should be selected.
	list = LD_PRIMARY;
	if (hfact->entry_list[LD_PRIMARY].next_entry ==
		&hfact->entry_list[LD_PRIMARY])
	{
		// The primary list is empty, so we take from the secondary list.  By
		// definition, this will increase the pair count.
		list = LD_SECONDARY;
		hfact->pair_count++;
	}
	// Remove the entry from the head of the appropriate list and place it on
	// the assigned list.
	entry = hfact->entry_list[list].next_entry;
	handle = entry->handle;
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[LD_ASSIGNED];
	entry->prev_entry = hfact->entry_list[LD_ASSIGNED].prev_entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry->next_entry = entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry = entry;
	// Set the reference pointer to that provided as an argument.
	entry->reference = reference;
	// The next handle for this entry will be greater by the table size.  It
	// is important to set this value in this routine because unequal values of
	// handle and next_handle indicate an assigned entry.
	entry->next_handle = handle + hfact->table_size;
	if (entry->next_handle == 0)
	{
		// The handle value has wrapped around back to zero; however, zero is
		// a reserved value, so we instead set the next handle to the subsequent
		// legal value, which is the table size.
		entry->next_handle = hfact->table_size;
	}
	// The population has increased by one.
	hfact->population++;
	// We're being tricky with unsigned integer math here.  We revoke ancient
	// handles if the value of the handle we are currently issuing is greater
	// than the handle base by more than MAX_HANDLE_RANGE, modulo the size of
	// the handle space.  The modulo is implicit.
	handle_range = handle - hfact->handle_base;
	if (handle_range > MAX_HANDLE_RANGE)
	{
		revoke_ancient_HF_handles(hfact);
	}
	// This assignment operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// Return the newly assigned handle.
	return handle;
}

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;
	HFEntry *other_entry;
	int list;
	HFHandle adjusted_next_handle;
	HFHandle adjusted_other_next_handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if ((entry->handle != handle && entry->handle != handle + HANDLE_RANGE_STEP)
		|| entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle nor to
		// the provided handle's suspension value, or the entry is unassigned.
		// In any of these cases, abort and return an error code to the client.
		return 1;
	}
	// The "other entry" is the entry that would have to be merged with the
	// indexed entry if the table size were to be contracted in half.
	other_entry = &hfact->entries[entry_index ^ hfact->table_size / 2];
	if (other_entry->handle == other_entry->next_handle)
	{
		// We're being tricky with unsigned integer math here.  Before comparing
		// the two next handles, we subtract from each the value of handle_base,
		// modulo the size of the handle space (the modulo is implicit).  This
		// allows the effective comparison of their logical acyclic values
		// rather than their actual cyclic values.
		adjusted_next_handle = entry->next_handle - hfact->handle_base;
		adjusted_other_next_handle =
			other_entry->next_handle - hfact->handle_base;
		if (adjusted_other_next_handle < adjusted_next_handle)
		{
			// The other entry is unassigned and has a smaller handle value
			// than the indexed entry.  Thus, the other entry should be moved
			// from the secondary list to the primary list, and the indexed
			// entry should be placed on the secondary list.
			other_entry->next_entry->prev_entry = other_entry->prev_entry;
			other_entry->prev_entry->next_entry = other_entry->next_entry;
			other_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
			other_entry->prev_entry = hfact->entry_list[LD_PRIMARY].prev_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry->next_entry = other_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry = other_entry;
			list = LD_SECONDARY;
		}
		else
		{
			// The other entry is unassigned and has a larger handle value
			// than the indexed entry.  Thus, the indexed entry should be
			// placed on the secondary list.
			list = LD_PRIMARY;
		}
	}
	else
	{
		// The other entry is assigned.  Thus, the indexed entry should be
		// placed on the secondary list.  Also, since the two entries were
		// both assigned, they formed a pair.  Since we are releasing one of
		// them, the pair count drops by one.
		list = LD_SECONDARY;
		hfact->pair_count--;
	}
	// Remove the entry from the assigned list and place it on the
	// appropriate list.
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[list];
	entry->prev_entry = hfact->entry_list[list].prev_entry;
	hfact->entry_list[list].prev_entry->next_entry = entry;
	hfact->entry_list[list].prev_entry = entry;
	// Invalidate the handle.  The order of the operations is important to
	// correct multi-threaded operation.
	seq_entry = entry;
	seq_entry->handle = entry->next_handle;           // first invalidate handle
	seq_entry->reference = 0;                            // then clear reference
	// The population has decreased by one.
	hfact->population--;
	// This release operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && hfact->table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
	// return an indication of success to the client.
	return 0;
}

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if (entry->handle != handle || entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle, or
		// the entry is unassigned.  In either case, abort and return an error
		// code to the client.
		return 1;
	}
	// Suspend the handle.
	entry->handle += HANDLE_RANGE_STEP;
	// This suspension operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if (entry->handle != handle + HANDLE_RANGE_STEP ||
		entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle's
		// suspension value, or the entry is unassigned.  In either case, abort
		// and return an error code to the client.
		return 1;
	}
	// Reinstate the handle.
	entry->handle -= HANDLE_RANGE_STEP;
	// This reinstatement operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released but a null value is returned, then the
// handle has been revoked by the handle factory.  This is expected to be a
// highly unusual occurrence; however, since it can happen, any program that
// employs the handle factory must have some auxiliary mechanism for retrieving
// the desired pointer information.  Once the pointer is retrieved through this
// (presumably expensive) auxiliary means, a new handle can be reassigned to
// the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	HFHandle entry_handle;
	void *reference;
	//int verifier;
	int entry_index;
	/*volatile*/ HFEntry *entry;                    // volatile to ensure sequencing

	// This loop spins until the verifier variables begin and end a pass of
	// the loop with the same value. There is an extremely short sequence
	// of instructions in the expand and contract routines that modifies the
	// values of the entries and table_size variables, and these modifications
	// are bracketed by increments of the verifier variables in the reverse
	// order as they are here read.  As long as the verifiers have the same
	// value, then entries and table_size are in a consistent state.  This loop
	// should very rarely be executed more than once, since the modification in
	// the other routines is so short.
	do
	{
		//verifier = hfact->verifier1;
		// Compute the index of the entry by taking the handle value modulo the
		// table size.  Since the table size is a power of two, we can simply
		// subtract one to produce a mask and then conjoin the mask with the
		// handle value.
		entry_index = handle & hfact->table_size - 1;
		entry = &hfact->entries[entry_index];
		// Get local copies of the reference pointer and handle value.  The
		// order of the operations is important to correct multi-threaded
		// operation.
		reference = entry->reference;                     // first get reference
		entry_handle = entry->handle;       // then get handle to check validity
	}	while (0 /*verifier != hfact->verifier0*/);
	if (entry_handle == handle)
	{
		// The stored handle matches the provided handle, so the latter is
		// valid.  We thus return the reference pointer.
		return reference;
	}
	else
	{
		// The stored handle does not match the provided handle, so the latter
		// is invalid.  We thus return a null pointer.
		return 0;
	}
}



void *
dereference_HF_handle_with_cb(
	HandleFactory *hfact,
	HFHandle handle,
    ULONG    offset)
{
	HFHandle entry_handle;
	void *reference;
	//int verifier;
	int entry_index;
	/*volatile*/ HFEntry *entry;                    // volatile to ensure sequencing

	// This loop spins until the verifier variables begin and end a pass of
	// the loop with the same value. There is an extremely short sequence
	// of instructions in the expand and contract routines that modifies the
	// values of the entries and table_size variables, and these modifications
	// are bracketed by increments of the verifier variables in the reverse
	// order as they are here read.  As long as the verifiers have the same
	// value, then entries and table_size are in a consistent state.  This loop
	// should very rarely be executed more than once, since the modification in
	// the other routines is so short.
	do
	{
		//verifier = hfact->verifier1;
		// Compute the index of the entry by taking the handle value modulo the
		// table size.  Since the table size is a power of two, we can simply
		// subtract one to produce a mask and then conjoin the mask with the
		// handle value.
		entry_index = handle & hfact->table_size - 1;
		entry = &hfact->entries[entry_index];
		// Get local copies of the reference pointer and handle value.  The
		// order of the operations is important to correct multi-threaded
		// operation.

        if ((entry->reference) && (entry->handle == handle)) {

            ASSERT(((PCLASSIFICATION_BLOCK)entry->reference)->NumberOfElements > offset);
            reference = (void *)((PCLASSIFICATION_BLOCK)entry->reference)->arpBlobBlock[offset];
            TRACE(CLASSIFY, entry->reference, reference, "dereference_HF_handle_with_cb");

            return reference;

        } else {

            reference = 0;
            return 0;

        }

	}	while (0 /*verifier != hfact->verifier0*/);

}




#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle()
// and release_HF_handle.  If the routine returns any value other than zero,
// then the internal lists of records are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact)
{
	int entry_count[3];
	int list;
	HFEntry *entry;
	for (list = 0; list < 3; list++)
	{
		entry_count[list] = 0;
		entry = &hfact->entry_list[list];
		do
		{
			entry_count[list]++;
			if (entry->next_entry->prev_entry != entry)
			{
				return 1;
			}
			entry = entry->next_entry;
		}	while (entry != &hfact->entry_list[list]);
		entry_count[list]--;
	}
	if (entry_count[2] != hfact->population)
	{
		return 2;
	}
	if (entry_count[0] + entry_count[2] - 2 * hfact->pair_count !=
		entry_count[1])
	{
		return 3;
	}
	if (entry_count[0] + entry_count[1] + entry_count[2] != hfact->table_size)
	{
		return 4;
	}
	return 0;
}

#endif /* _TEST_HANDFACT */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact)
{
	int double_size;
	HFEntry *new_entries;
	HFEntry *old_entries;
	HFEntry *old_entry;
	HFEntry *low_entry;
	HFEntry *high_entry;
	HFEntry *assigned_entry;
	HFEntry *secondary_entry;
	HFEntry *other_entry;
	HFHandle handle;
	HFHandle next_handle;
	HFHandle other_handle;
	void *reference;
	int other_entry_index;
	int index;

	// Expanded table is double the size of the old table.
	double_size = hfact->table_size * 2;
	// Allocate space for the expanded table.
	NEW_HFEntry_array(new_entries,double_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries.
		// Therefore, we return an indication of failure.
		return 1;
	}
	// Since we are doubling the table size, we will be treating one more bit
	// of each handle as a bit of the entry index.  The value of this bit
	// determines the index of the entry in the new table.  For each entry,
	// we have to determine the value of this bit and relocate the entry to
	// the indicated location.
	for (index = 0; index < hfact->table_size; index++)
	{
		old_entry = &hfact->entries[index];
		low_entry = &new_entries[index];
		high_entry = &new_entries[hfact->table_size + index];
		handle = old_entry->handle;
		next_handle = old_entry->next_handle;
		reference = old_entry->reference;
		// One of the two entries in the new table that correspond to the
		// indexed entry in the old table will have a next handle value equal
		// to the next handle value of the entry in the old table, and one will
		// have a handle value equal to the indexed entry's next handle plus
		// the old table size.
		other_handle = next_handle + hfact->table_size;
		if (other_handle == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			other_handle = double_size;
		}
		if ((handle & hfact->table_size) == 0)
		{
			// The handle of the old entry has a zero in its next bit, so the
			// old entry will be located in the lower half of the new table.
			if ((next_handle & hfact->table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = other_handle;
				high_entry->next_handle = other_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = next_handle;
				high_entry->next_handle = next_handle;
				low_entry->next_handle = other_handle;
			}
			// The high entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the low entry.
			// Remove the old entry from the assigned list, and replace it
			// with the low entry.
			high_entry->reference = 0;
			low_entry->handle = handle;
			low_entry->reference = reference;
			old_entry->next_entry->prev_entry = low_entry;
			old_entry->prev_entry->next_entry = low_entry;
			low_entry->next_entry = old_entry->next_entry;
			low_entry->prev_entry = old_entry->prev_entry;
		}
		else
		{
			// The handle of the old entry has a one in its next bit, so the
			// old entry will be located in the higher half of the new table.
			if ((next_handle & hfact->table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = other_handle;
				low_entry->handle = next_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = next_handle;
				low_entry->handle = other_handle;
				low_entry->next_handle = other_handle;
			}
			// The low entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the high entry.
			// Remove the old entry from the assigned list, and replace it
			// with the high entry.
			low_entry->reference = 0;
			high_entry->handle = handle;
			high_entry->reference = reference;
			old_entry->next_entry->prev_entry = high_entry;
			old_entry->prev_entry->next_entry = high_entry;
			high_entry->next_entry = old_entry->next_entry;
			high_entry->prev_entry = old_entry->prev_entry;
		}
	}
	// All of the unassigned entries in the new table will be placed on the
	// secondary list.  We loop through the assigned list and place the
	// unassigned entry corresponding each assigned entry onto the secondary
	// list.  Doing the list assignment in this manner tends to approximately
	// sort the secondary list according to handle value, since the assigned
	// list is sorted according to assignment order, and this approximately
	// correlates to the handle value.
	assigned_entry = hfact->entry_list[LD_ASSIGNED].next_entry;
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (assigned_entry != &hfact->entry_list[LD_ASSIGNED])
	{
		other_entry_index =
			assigned_entry->handle + hfact->table_size & double_size - 1;
		other_entry = &new_entries[other_entry_index];
		secondary_entry->next_entry = other_entry;
		other_entry->prev_entry = secondary_entry;
		secondary_entry = other_entry;
		assigned_entry = assigned_entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This expansion increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of splitting each
	// entry into two entries.
	hfact->hysteresis_debt += ALLOCATION_COST + hfact->table_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = hfact->entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  These operations must be performed
	// atomically in order for the dereference routine to perform correctly.
	// We thus bracket the operations with increments to the verifier variables.
	// When the verifiers have the same value, the table_size and entries
	// variables are in a consistent state.  This is checked by the dereference
	// routine.
	hfact->verifier0++;                                // begin critical section
	hfact->entries = new_entries;
	hfact->table_size = double_size;
	hfact->verifier1 = hfact->verifier0;                 // end critical section
	// Deallocate the old table.
	GpcFreeMem(old_entries, handleFactoryTag);
	// Since the new table was created by expanding a half-size table, the pair
	// count must be zero.
	hfact->pair_count = 0;
	// return an indication of success.
	return 0;
}

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact)
{
	HFEntry *new_entries;
	HFEntry *old_entries;
	int *list;
	int half_size;
	int quarter_size;
	int index;
	HFEntry *high_entry1;
	HFEntry *high_entry0;
	HFEntry *low_entry1;
	HFEntry *low_entry0;
	HFEntry *new_entry1;
	HFEntry *new_entry0;
	HFHandle adjusted_high_next_handle1;
	HFHandle adjusted_low_next_handle1;
	HFHandle next_handle1;
	HFHandle adjusted_high_next_handle0;
	HFHandle adjusted_low_next_handle0;
	HFHandle next_handle0;
	HFHandle adjusted_new_handle0;
	HFHandle adjusted_new_handle1;
	HFEntry *entry;
	HFEntry *primary_entry;
	HFEntry *secondary_entry;

	// Contracted table is half the size of the old table.
	half_size = hfact->table_size / 2;
	quarter_size = half_size / 2;
	// Allocate space for the contracted table.
	NEW_HFEntry_array(new_entries,half_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries, so we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.
		return 1;
	}
	// Allocate space for auxiliary array of list indicators
	NEW_int_array(list,half_size);
	if (list == 0)
	{
		// Memory could not be allocated for the auxiliary array, so again we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.  First, however, we must free the memory allocated for
		// the new array of entries above.
		GpcFreeMem(new_entries, handleFactoryTag);
		return 1;
	}
	// Since we are halving the size of the table, it might seem reasonable to
	// loop through each index of the new table and merge the two corresponding
	// entries from the old table.  This is in fact what the following routine
	// does; however, it does it by looping through only half of the new indices
	// and processing two merges for each index.  It does this so that it can
	// then examine the two new entries to determine on which list to place each
	// of them.
	for (index = 0; index < quarter_size; index++)
	{
		// We're looking at four entries at once.  First we merge high_entry1
		// and low_entry1, and then we independently merge high_entry0 and
		// low_entry0.  After the two merges, we examine the results jointly.
		high_entry1 = &hfact->entries[half_size + quarter_size + index];
		high_entry0 = &hfact->entries[half_size + index];
		low_entry1 = &hfact->entries[quarter_size + index];
		low_entry0 = &hfact->entries[index];
		new_entry1 = &new_entries[quarter_size + index];
		new_entry0 = &new_entries[index];
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle1 =
			high_entry1->next_handle - hfact->handle_base;
		adjusted_low_next_handle1 =
			low_entry1->next_handle - hfact->handle_base;
		next_handle1 = __max(adjusted_high_next_handle1,
			adjusted_low_next_handle1) + hfact->handle_base - half_size;
		// Since handle 1 is -- by definition -- in either the second or fourth
		// quarter of the table, there is no need to check for the reserved
		// value of zero.
		if (high_entry1->handle != high_entry1->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = high_entry1->handle;
			new_entry1->reference = high_entry1->reference;
			high_entry1->next_entry->prev_entry = new_entry1;
			high_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = high_entry1->next_entry;
			new_entry1->prev_entry = high_entry1->prev_entry;
		}
		else if (low_entry1->handle != low_entry1->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = low_entry1->handle;
			new_entry1->reference = low_entry1->reference;
			low_entry1->next_entry->prev_entry = new_entry1;
			low_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = low_entry1->next_entry;
			new_entry1->prev_entry = low_entry1->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry1->handle = next_handle1;
			new_entry1->reference = 0;
			if (adjusted_high_next_handle1 < adjusted_low_next_handle1)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry1->next_entry->prev_entry = new_entry1;
				high_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = high_entry1->next_entry;
				new_entry1->prev_entry = high_entry1->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry1->next_entry->prev_entry = new_entry1;
				low_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = low_entry1->next_entry;
				new_entry1->prev_entry = low_entry1->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry1->next_handle = next_handle1;
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle0 =
			high_entry0->next_handle - hfact->handle_base;
		adjusted_low_next_handle0 =
			low_entry0->next_handle - hfact->handle_base;
		next_handle0 = __max(adjusted_high_next_handle0,
			adjusted_low_next_handle0) + hfact->handle_base - half_size;
		if (next_handle0 == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			next_handle0 = half_size;
		}
		if (high_entry0->handle != high_entry0->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = high_entry0->handle;
			new_entry0->reference = high_entry0->reference;
			high_entry0->next_entry->prev_entry = new_entry0;
			high_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = high_entry0->next_entry;
			new_entry0->prev_entry = high_entry0->prev_entry;
		}
		else if (low_entry0->handle != low_entry0->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = low_entry0->handle;
			new_entry0->reference = low_entry0->reference;
			low_entry0->next_entry->prev_entry = new_entry0;
			low_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = low_entry0->next_entry;
			new_entry0->prev_entry = low_entry0->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry0->handle = next_handle0;
			new_entry0->reference = 0;
			if (adjusted_high_next_handle0 < adjusted_low_next_handle0)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry0->next_entry->prev_entry = new_entry0;
				high_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = high_entry0->next_entry;
				new_entry0->prev_entry = high_entry0->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry0->next_entry->prev_entry = new_entry0;
				low_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = low_entry0->next_entry;
				new_entry0->prev_entry = low_entry0->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry0->next_handle = next_handle0;
		// Now that we have merged high_entry1 and low_entry1 into new_entry1,
		// and independently merged high_entry0 and low_entry0 into new_entry0,
		// we examine the two new entries to determine on which list to place
		// each of them.  Note that we do not actually manipulate the lists in
		// this portion of the code; we merely make decisions and record these
		// decisions for the future.
		if (new_entry0->handle == new_entry0->next_handle &&
			new_entry1->handle == new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are unassigned, so one of them
			// belongs on the primary list and the other on the secondary list.
			// Which goes on which is determined by a comparison of their handle
			// values.  We're being tricky with unsigned integer math here.
			// Before comparing the two handles, we subtract from each the value
			// of handle_base, modulo the size of the handle space (the modulo
			// is implicit).  This allows the effective comparison of their
			// logical acyclic values rather than their actual cyclic values.
			adjusted_new_handle0 = new_entry0->handle - hfact->handle_base;
			adjusted_new_handle1 = new_entry1->handle - hfact->handle_base;
			if (adjusted_new_handle0 < adjusted_new_handle1)
			{
				// The handle value for new_entry0 is lower, so new_entry0
				// belongs on the primary list and new_entry1 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_PRIMARY;
				list[quarter_size + index] = LD_SECONDARY;
			}
			else
			{
				// The handle value for new_entry1 is lower, so new_entry1
				// belongs on the primary list and new_entry0 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_SECONDARY;
				list[quarter_size + index] = LD_PRIMARY;
			}
		}
		else
		{
			// Either new_entry0 or new_entry1 (or both) is assigned, and it is
			// therefore already on the assigned list.  If one of the entries
			// is not assigned, it belongs on the secondary list.  We indicate
			// this decision in both places of the list array, which is safe to
			// do since the assigned entry's list indicator will never be
			// examined.
			list[index] = LD_SECONDARY;
			list[quarter_size + index] = LD_SECONDARY;
		}
		if (new_entry0->handle != new_entry0->next_handle &&
			new_entry1->handle != new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are assigned, so they form a pair.
			// We thus increment the pair count.  Note that we never set the
			// pair count to zero above, but this was not necessary since the
			// table could not be contracted unless the pair count was zero.
			hfact->pair_count++;
		}
	}
	// At this point, the table has been completely contracted except for the
	// reassembly of the unassigned lists.  In the code above, any entries that
	// had previously been on the secondary list were merged with assigned
	// entries, so they are no longer relevant.  Only those entries that had
	// previously been (and are still) on the primary list will still be
	// unassigned.  We now loop through the primary list and place each list
	// element on the appropriate list, as indicated by the list array.  Doing
	// the list assignment in these two steps preserves the general order of
	// the entries, which has some value since they will tend to be partially
	// sorted.
	entry = hfact->entry_list[LD_PRIMARY].next_entry;
	primary_entry = &hfact->entry_list[LD_PRIMARY];
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (entry != &hfact->entry_list[LD_PRIMARY])
	{
		if (list[entry->handle & half_size - 1] == LD_PRIMARY)
		{
			// The list array indicates the primary list, so place the entry
			// onto the primary list.
			primary_entry->next_entry = entry;
			entry->prev_entry = primary_entry;
			primary_entry = entry;
		}
		else
		{
			// The list array indicates the secondary list, so place the entry
			// onto the secondary list.
			secondary_entry->next_entry = entry;
			entry->prev_entry = secondary_entry;
			secondary_entry = entry;
		}
		entry = entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	primary_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entry_list[LD_PRIMARY].prev_entry = primary_entry;
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This contraction increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of merging each
	// pair of entries into a single entry.
	hfact->hysteresis_debt += ALLOCATION_COST + half_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = hfact->entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to decrease the table size and update the entries
	// variable to point to the new table.  These operations must be performed
	// atomically in order for the dereference routine to perform correctly.
	// We thus bracket the operations with increments to the verifier variables.
	// When the verifiers have the same value, the table_size and entries
	// variables are in a consistent state.  This is checked by the dereference
	// routine.
	hfact->verifier0++;                                // begin critical section
	hfact->table_size = half_size;
	hfact->entries = new_entries;
	hfact->verifier1 = hfact->verifier0;                 // end critical section
	
    // Deallocate the old table and the auxiliary list indicator array.
	GpcFreeMem(old_entries, handleFactoryTag);
	GpcFreeMem(list, handleFactoryTag);
	// return an indication of success.
	return 0;
}

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact)
{
	HFHandle new_handle_base;
	int half_size;
	int index;
	HFEntry *high_entry;
	HFEntry *low_entry;
	HFHandle adjusted_high_handle;
	HFHandle adjusted_low_handle;
	HFHandle adjusted_high_next_handle;
	HFHandle adjusted_low_next_handle;
	HFHandle handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	// Compute new handle base.
	new_handle_base = hfact->handle_base + HANDLE_RANGE_STEP;
	// It might seem reasonable to loop through each index of the table and
	// determine whether to revoke the handle of each entry.  This is in fact
	// what the following routine does; however, it does it by looping through
	// only half of the indices and examining two entries for each index.  It
	// does this so that it can compare the two entries to determine on which
	// list to place each of them.
	half_size = hfact->table_size / 2;
	for (index = 0; index < half_size; index++)
	{
		// We're looking at two entries at once.
		high_entry = &hfact->entries[half_size + index];
		low_entry = &hfact->entries[index];
		// We're being tricky with unsigned integer math here.  Before making
		// comparisons on either handle, we subtract from it the value of
		// handle_base, modulo the size of the handle space (the modulo is
		// implicit).  This allows the effective comparison of its logical
		// acyclic value rather than its actual cyclic value.
		adjusted_high_handle = high_entry->handle - hfact->handle_base;
		adjusted_low_handle = low_entry->handle - hfact->handle_base;
		if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP ||
			adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
		{
			// At least one of the handles is less than twice HANDLE_RANGE_STEP
			// more than the current handle base, so it will need to be updated.
			// For the vast majority of cases, this test is expected to fail,
			// and so all of the following work can be skipped.
			if (high_entry->handle != high_entry->next_handle &&
				low_entry->handle != low_entry->next_handle)
			{
				// Both of the entries are assigned, so, since at least one of
				// them will be revoked, we will be losing one pair.
				hfact->pair_count--;
			}
			if (high_entry->handle == high_entry->next_handle ||
				adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the high entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				high_entry->next_entry->prev_entry = high_entry->prev_entry;
				high_entry->prev_entry->next_entry = high_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				high_entry->next_entry = 0;
				high_entry->prev_entry = 0;
			}
			if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The high handle needs to be updated.
				if (high_entry->handle != high_entry->next_handle)
				{
					// The high handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_high_next_handle,
					HANDLE_RANGE_STEP + half_size + index) + hfact->handle_base;
				// Since the high handle is -- by definition -- in the upper
				// half of the table, there is no need to check for the reserved
				// value of zero.
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = high_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (low_entry->handle == low_entry->next_handle ||
				adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the low entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				low_entry->next_entry->prev_entry = low_entry->prev_entry;
				low_entry->prev_entry->next_entry = low_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				low_entry->next_entry = 0;
				low_entry->prev_entry = 0;
			}
			if (adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The low handle needs to be updated.
				if (low_entry->handle != low_entry->next_handle)
				{
					// The low handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_low_next_handle =
					low_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_low_next_handle,
					HANDLE_RANGE_STEP + index) + hfact->handle_base;
				if (handle == 0)
				{
					// The handle value has wrapped around back to zero;
					// however, zero is a reserved value, so we instead set the
					// handle to the subsequent legal value, which is the table
					// size.
					handle = hfact->table_size;
				}
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = low_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (high_entry->handle != high_entry->next_handle)
			{
				// The high entry is still assigned, so the low entry belongs
				// on the secondary list.
				low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				low_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					low_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
			}
			else if (low_entry->handle != low_entry->next_handle)
			{
				// The low entry is still assigned, so the high entry belongs
				// on the secondary list.
				high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				high_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					high_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
			}
			else
			{
				// Neither entry is still assigned, so one entry belongs on the
				// primary list and one on the secondary list.  Which goes on
				// which is determined by a comparison of their handle values.
				// We're being tricky with unsigned integer math here.  Before
				// comparing the two handles, we subtract from each the value
				// of handle_base, modulo the size of the handle space (the
				// modulo is implicit).  This allows the effective comparison
				// of their logical acyclic values rather than their actual
				// cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - new_handle_base;
				adjusted_low_next_handle =
					low_entry->next_handle - new_handle_base;
				if (adjusted_low_next_handle < adjusted_high_next_handle)
				{
					// The handle value for the low entry is smaller, so it
					// belongs on the primary list and the high entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = low_entry;
				}
				else
				{
					// The handle value for the high entry is smaller, so it
					// belongs on the primary list and the low entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
				}
			}
		}
	}
	// Update the handle base with the new handle base.
	hfact->handle_base = new_handle_base;
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && hfact->table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\gpcmap.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmap.c

Abstract:

    This file contains mapping routines like user handles to
    kernel handles.

Author:

    Ofer Bar - July 14, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"


/*
/////////////////////////////////////////////////////////////////
//
//   globals
//
/////////////////////////////////////////////////////////////////
*/

static MRSW_LOCK		HandleLock;
static HandleFactory   *pMapHandles = NULL;

/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/



HANDLE
AllocateHandle(
    OUT HANDLE *OutHandle,           
    IN  PVOID  Reference
    )
/*++

Routine Description:

    This function creates a handle.

Arguments:

    OutHandle - a pointer to a location to fill in the result handle
    Reference - to associate with the handle

Return Value:

	The handle factory handle, or NULL in case of en error

--*/
{
    HFHandle	Handle;
    KIRQL		irql;
    
    ASSERT(OutHandle);

	TRACE(MAPHAND, Reference, OutHandle, "AllocateHandle <==");

    WRITE_LOCK( &HandleLock, &irql );

    *OutHandle = (HANDLE) UIntToPtr((Handle = assign_HF_handle(pMapHandles, Reference)));
    
    WRITE_UNLOCK( &HandleLock, irql );

    StatInc(InsertedHF);

	TRACE(MAPHAND, Reference, Handle, "AllocateHandle ==>");

    return (HANDLE) UIntToPtr(Handle);
}


VOID
FreeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function frees the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "FreeHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = release_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        StatInc(RemovedHF);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "FreeHandle ==>");
}




VOID
SuspendHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function suspends the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "SuspendHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = suspend_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "SuspendHandle ==>");
}




VOID
ResumeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function resumess the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "ResumeHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = reinstate_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "ResumeHandle ==>");
}




PVOID
GetHandleObject(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType
    )
{
    GPC_ENUM_OBJECT_TYPE   *p;
    KIRQL					irql;

	TRACE(MAPHAND, h, ObjType, "GetHandleObject <==");

    READ_LOCK(&HandleLock, &irql);

    p = (GPC_ENUM_OBJECT_TYPE *)dereference_HF_handle(pMapHandles, 
                                                      (HFHandle)(UINT_PTR)h);

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if (*p != ObjType) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
        
    }

    READ_UNLOCK(&HandleLock, irql);
    
	TRACE(MAPHAND, h, p, "GetHandleObject ==>");

    return (PVOID)p;
}


// (a) Determine the memory pointer that the handle points to
// (b) Verify that the memory is of the correct BLOCK (ObjType enum is checked)
// (c) Verify that the Handle associated with the memory pointer is indeed
//       what was passed in 

PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType,
    IN  ULONG                   Ref
    )
{
    GPC_ENUM_OBJECT_TYPE   *p;
    KIRQL		irql;
    
	TRACE(MAPHAND, h, ObjType, "GetHandleObjectWithRef ==>");

    READ_LOCK( &HandleLock, &irql );
    
    p = dereference_HF_handle(pMapHandles, (HFHandle)(ULONG_PTR)h);

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if (*p != ObjType) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
        
    }

    if (p != NULL) {

        switch (ObjType) {

        case GPC_ENUM_CFINFO_TYPE:
            REFADD(&((PBLOB_BLOCK)p)->RefCount, Ref);
            break;

        case GPC_ENUM_CLIENT_TYPE:
            
            REFADD(&((PCLIENT_BLOCK)p)->RefCount, Ref);
            break;

        case GPC_ENUM_PATTERN_TYPE:
            REFADD(&((PPATTERN_BLOCK)p)->RefCount, Ref);
            break;

        default:
            ASSERT(0);
        }
    }
    
    READ_UNLOCK( &HandleLock, irql );

	TRACE(MAPHAND, h, p, "GetHandleObjectWithRef <==");

    return (PVOID)p;
}



/*
************************************************************************

InitMapHandles - 

The initialization handle mapping table

Arguments
	none

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitMapHandles(VOID)
{
    GPC_STATUS Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, 0, 0, "InitMapping");

	INIT_LOCK(&HandleLock);

    NEW_HandleFactory(pMapHandles);

    if (pMapHandles != NULL ) {
        
        if (constructHandleFactory(pMapHandles)) {
            
            FreeHandleFactory(pMapHandles);

            Status = GPC_STATUS_RESOURCES;
        } 
            
    } else {
        
        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, pMapHandles, Status, "InitMapping");

    return Status;
}


/*
************************************************************************

UninitMapHandles - 

	release handle mapping table resources

Arguments
	none

Returns
	void

************************************************************************
*/
VOID
UninitMapHandles(VOID)
{
    GPC_STATUS Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, 0, 0, "UninitMapHandles");

	//NdisFreeSpinLock(&HandleLock);

    destructHandleFactory(pMapHandles);

    FreeHandleFactory(pMapHandles);

	TRACE(INIT, pMapHandles, Status, "UninitMapHandles");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\handfact.h ===
/*
 *  handfact.h
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the handle factory.  The code is object-oriented C, transliterated from a
 *  C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the handle factory.
 *
 */

#ifndef _INC_HANDFACT

#define _INC_HANDFACT

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the HFEntry and the HandleFactory.
 *  Ideally, these would be completely hidden from the client, but the size of
 *  the HandleFactory structure structure needs to be known by the client for
 *  allocation purposes, and this is most easily accomplished by declaring the
 *  structure itself here in the header file, which in turn requires declaring
 *  the HFEntry structure.  It is strongly urged that the client not directly
 *  refer to any of the fields of either of these structures.  To support the
 *  documentation of the accompanying rhizome.c file, these structures are
 *  annotated with internal comments, but these can be ignored by the reader
 *  who wishes only to understand how to write client code that makes use of
 *  the handle factory.
 *
 *  The handles generated by the handle factory are of type HFHandle.  This is
 *  typedefed to an unsigned int, but this fact can be ignored by the client,
 *  since it is an implementation detail.
 *
 */

//#include <stdlib.h>
//#include <malloc.h>

// HFHandle is the type of the handles generated by the handle factory.
//
typedef unsigned int HFHandle;

struct _HFEntry;

typedef struct _HFEntry HFEntry;

struct _HFEntry
{
	// This is the element in which each handle and its associated pointer are
	// stored.  If handle == next_handle, the entry is not assigned, and it is
	// available for assignment to a pointer via the assign_HF_handle()
	// function.  If handle != next_handle, then the entry is assigned to the
	// pointer in the reference field.
	//
	// Each entry is on one of three lists: the primary free list, the secondary
	// free list, or the assigned list.  Each of these lists is maintained via
	// the next_entry and prev_entry pointers.

	HFHandle handle;                                          // value of handle
	HFHandle next_handle;         // next value given to handle when invalidated
	void *reference;                           // pointer to which handle refers
	HFEntry *next_entry;                        // pointer to next entry in list
	HFEntry *prev_entry;                    // pointer to previous entry in list
};

struct _HandleFactory;

typedef struct _HandleFactory HandleFactory;

struct _HandleFactory
{
	// This structure contains private member variables for the handle factory.
	// The first four fields are marked volatile to insure that the operations
	// performed on them occur in the specified sequence.  The handle factory
	// can operate in a multi-threaded environment without requiring that a
	// lock be taken before calling dereference_HF_handle(), and this is
	// accomplished by careful sequencing of the read and write operations on
	// these four variables.
	//
	// The verifier variables are used to provide a simple synchronization
	// mechanism.  When the variables have the same value, then the table_size
	// and entries variables are in a consistent state.
	//
	// The table that holds the handles can only be contracted (shrunk in half)
	// when for each assigned handle in the lower half of the table, there is
	// no assigned handle in the corresponding upper half of the table.  The
	// number of correspondences between the two table halves is given by
	// pair_count.

	volatile int table_size;                // size of table for storing entries
	HFEntry *volatile entries;                   // pointer to tables of entries
	volatile int verifier0;                          // synchronization variable
	volatile int verifier1;                          // synchronization variable
	HFHandle handle_base;                // rolling point of lowest handle value
	int population;                      // number of handles currently assigned
	int pair_count;               // contractions can occur when pair_count == 0
	int hysteresis_debt;                      // must be zero before contraction
	HFEntry entry_list[3];                     // array of all three entry lists
};

/*
 *  The client interface to the handle factory is provided by seven functions
 *  and one macro.  It is expected that the provider will first instantiate a
 *  handle factory, either in the static data segment, on the stack, or on the
 *  heap.  Then, the provider will assign handles to various pointers by
 *  calling assign_HF_handle(), which it will distribute to its clients.  When
 *  the provider wishes to release these handles, it will do so by calling
 *  release_HF_handle().  Each time a client presents a handle to the provider,
 *  the provider can validate the handle and retrieve the associated pointer
 *  by calling dereference_HF_handle().  A client can temporarily suspend a
 *  handle by calling suspend_HF_handle(), after which it can either reinstate
 *  the handle by calling reinstate_HF_handle() or release the handle by calling
 *  release_HF_handle().
 *
 */

// A handle factory may be allocated in the static data segment or on the stack
// simply by declaring a variable of type HandleFactory.  To allocate it on the
// heap, the following macro returns a pointer to a new HandleFactory structure.
// If this macro is used, a corresponding call to free() must be made to
// deallocate the structure from the heap.
//
#define NEW_HandleFactory(_h)   GpcAllocMem(&(_h),\
                                            sizeof(HandleFactory),\
                                            HandleFactoryTag)

#define FreeHandleFactory(_h)   GpcFreeMem((_h),\
                                           HandleFactoryTag)

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact);

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact);

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference);

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released or suspended but a null value is
// returned, then the handle has been revoked by the handle factory.  This is
// expected to be a highly unusual occurrence; however, since it can happen, any
// program that employs the handle factory must have some auxiliary mechanism
// for retrieving the desired pointer information.  Once the pointer is
// retrieved through this (presumably expensive) auxiliary means, a new handle
// can be reassigned to the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);


void *
dereference_HF_handle_with_cb(
	HandleFactory *hfact,
	HFHandle handle,
    ULONG offset);

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle(),
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().  If the
// routine returns any value other than zero, then the internal lists of records
// are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact);

#if DBG
#define VERIFY_HF_HFACT(_hfact) ASSERT(verify_HF_lists(_hfact)==0)
#else
#define VERIFY_HF_HFACT(_hfact)
#endif

#endif /* _TEST_HANDFACT */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_HANDFACT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\ioctl.c ===
#include "gpcpre.h"

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Creates symbolic link to receive ioctls from user mode and contains the
    ioctl case statement.

Author:

    Yoram Bernet (yoramb) May, 7th. 1997

Environment:

    Kernel Mode

Revision History:

	Ofer Bar (oferbar) 	Oct 1, 1997		- revision II

--*/

#pragma hdrstop

VOID
IoctlCleanup(
    ULONG ShutdownMask
    );

NTSTATUS
GPCIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CancelPendingIrpCfInfo(
    IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    );

VOID
CancelPendingIrpNotify(
    IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    );

NTSTATUS
ProxyGpcRegisterClient(
    PVOID 			ioBuffer,
    ULONG 			inputBufferLength,
    ULONG 			*outputBufferLength,
    PFILE_OBJECT	FileObject,
    BOOLEAN         fNewInterface
    );

NTSTATUS
ProxyGpcDeregisterClient(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT	FileObject,
    BOOLEAN fNewInterface
    );


NTSTATUS
ProxyGpcAddCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT	FileObject
    );

NTSTATUS
ProxyGpcAddCfInfoEx(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT	FileObject
    );


NTSTATUS
ProxyGpcModifyCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT	FileObject
    );

NTSTATUS
ProxyGpcRemoveCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT	FileObject,
    BOOLEAN fNewInterface
    );



NTSTATUS
ProxyGpcAddPattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject,
    BOOLEAN        fNewInterface
    );

NTSTATUS
ProxyGpcRemovePattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject,
    BOOLEAN  fNewInterface
    );


NTSTATUS
ProxyGpcEnumCfInfo(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject
    );

NTSTATUS
GpcValidateClientOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN PFILE_OBJECT pFile
    );

NTSTATUS
GpcValidatePatternOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN GPC_HANDLE GpcPatternHandle
    );

NTSTATUS
GpcValidateCfinfoOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN GPC_HANDLE GpcCfInfoHandle
    );


GPC_CLIENT_FUNC_LIST 	CallBackProxyList;
PDEVICE_OBJECT 			GPCDeviceObject;
LIST_ENTRY 				PendingIrpCfInfoList;
LIST_ENTRY 				PendingIrpNotifyList;
LIST_ENTRY 				QueuedNotificationList;
LIST_ENTRY 				QueuedCompletionList;

/* End Forward */

#pragma NDIS_PAGEABLE_FUNCTION(GPCIoctl)

UNICODE_STRING GpcDriverName = {sizeof(DD_GPC_DEVICE_NAME)-2,
                                sizeof(DD_GPC_DEVICE_NAME),
                                DD_GPC_DEVICE_NAME};
NTSTATUS
IoctlInitialize(
    PDRIVER_OBJECT 	DriverObject,
    PULONG 			InitShutdownMask
    )

/*++

Routine Description:

    Perform initialization 

Arguments:

    DriverObject - pointer to DriverObject from DriverEntry
    InitShutdownMask - pointer to mask used to indicate which events have been
        successfully init'ed

Return Value:

    STATUS_SUCCESS if everything worked ok

--*/

{
    NTSTATUS Status;
    UINT FuncIndex;

    InitializeListHead(&PendingIrpCfInfoList);
    InitializeListHead(&PendingIrpNotifyList);
    InitializeListHead(&QueuedNotificationList);
    InitializeListHead(&QueuedCompletionList);

    //
    // Initialize the driver object's entry points
    //

    DriverObject->FastIoDispatch = NULL;

    for (FuncIndex = 0; FuncIndex <= IRP_MJ_MAXIMUM_FUNCTION; FuncIndex++) {
        DriverObject->MajorFunction[FuncIndex] = GPCIoctl;
    }

    Status = IoCreateDevice(DriverObject,
                            0,
                            &GpcDriverName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &GPCDeviceObject);

    if ( NT_SUCCESS( Status )) {

        *InitShutdownMask |= SHUTDOWN_DELETE_DEVICE;

        GPCDeviceObject->Flags |= DO_BUFFERED_IO;

/*      yoramb - don't need a symbolic link for now...

        Status = IoCreateSymbolicLink( &GPCSymbolicName, &GPCDriverName );

        if ( NT_SUCCESS( Status )) {

            *InitShutdownMask |= SHUTDOWN_DELETE_SYMLINK;
        } else {
            DBGPRINT(IOCTL, ("IoCreateSymbolicLink Failed (%08X): %ls -> %ls\n",
            Status, GPCSymbolicName.Buffer, PSDriverName.Buffer));
        }
*/
    } else {
        DbgPrint("IoCreateDevice failed. Status = %x\n", Status);
        GPCDeviceObject = NULL;
    }

    //
    // Initialize the callback functions. These are called by the
    // kernel Gpc and turned into async notifications to the user. 
    // For now, the user does not get callbacks, so they are NULL. 
    //

    CallBackProxyList.GpcVersion = GpcMajorVersion;
    CallBackProxyList.ClAddCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClAddCfInfoNotifyHandler = NULL;
    CallBackProxyList.ClModifyCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClModifyCfInfoNotifyHandler = NULL;
    CallBackProxyList.ClRemoveCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClRemoveCfInfoNotifyHandler = NULL;

    return Status;
}


NTSTATUS
GPCIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    UCHAR				saveControlFlags;
    NTSTATUS            Status = STATUS_SUCCESS;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    KIRQL				irql2;
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    PAGED_CODE();

    //
    // Init to default settings- we only expect 1 type of
    //     IOCTL to roll through here, all others an error.
    //

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    saveControlFlags = irpStack->Control;

    TRACE(LOCKS, thrd, irql, "GPCIoctl");

    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:
        DBGPRINT(IOCTL, ("IRP Create\n"));
        break;

    case IRP_MJ_READ:
        DBGPRINT(IOCTL, ("IRP Read\n"));
        break;

    case IRP_MJ_CLOSE:
        DBGPRINT(IOCTL, ("IRP Close\n"));
        TRACE(IOCTL, irpStack->FileObject, 0, "IRP Close");

        //
        // make sure we clean all the objects for this particular
        // file object, since it's closing right now.
        //

        CloseAllObjects(irpStack->FileObject, Irp);

        break;

    case IRP_MJ_CLEANUP:
        DBGPRINT(IOCTL, ("IRP Cleanup\n"));
        break;

    case IRP_MJ_SHUTDOWN:
        DBGPRINT(IOCTL, ("IRP Shutdown\n"));
        break;

    case IRP_MJ_DEVICE_CONTROL:

        DBGPRINT(IOCTL, ("GPCIoctl: ioctl=0x%X, IRP=0x%X\n", 
                         ioControlCode, (ULONG_PTR)Irp));

        TRACE(IOCTL, ioControlCode, Irp, "GPCIoctl.irp:");

        //
        // Mark the IRP as Pending BEFORE calling any dispatch routine.
        // If Status is actually set to STATUS_PENDING, we assume the IRP
        // is ready to be returned. 
        // It is possible the IoCompleteRequest has been called async for the
        // IRP, but this should be taken care of by the IO subsystem.
        //

        IoMarkIrpPending(Irp);

        switch (ioControlCode) {

        case IOCTL_GPC_REGISTER_CLIENT:


            Status = ProxyGpcRegisterClient(ioBuffer,
                                            inputBufferLength,
                                            &outputBufferLength,
                                            irpStack->FileObject,
                                            FALSE); //Admin Only

            
            break;

        case IOCTL_GPC_REGISTER_CLIENT_EX:
        	Status = ProxyGpcRegisterClient(ioBuffer,
                                            inputBufferLength,
                                            &outputBufferLength,
                                            irpStack->FileObject,
                                            TRUE); // All users
              break;
            
        case IOCTL_GPC_DEREGISTER_CLIENT:

            
            Status = ProxyGpcDeregisterClient(ioBuffer,
                                              inputBufferLength,
                                              &outputBufferLength,
                                              irpStack->FileObject,
                                              FALSE 
                                              );// Admin Only Call

            break;

        case IOCTL_GPC_DEREGISTER_CLIENT_EX:

            Status = ProxyGpcDeregisterClient(ioBuffer,
                                              inputBufferLength,
                                              &outputBufferLength,
                                              irpStack->FileObject,
                                              TRUE);// All users

            break;
            
        case IOCTL_GPC_ADD_CF_INFO:
            
            Status = ProxyGpcAddCfInfo(ioBuffer,
                                       inputBufferLength,
                                       &outputBufferLength,
                                       Irp,
                                       irpStack->FileObject
                                       );

            break;
	 // RSVP Removal Change
	 // New IOCTL added 
        case IOCTL_GPC_ADD_CF_INFO_EX:
           
	            Status = ProxyGpcAddCfInfoEx(ioBuffer,
                                       inputBufferLength,
                                       &outputBufferLength,
                                       Irp,
                                       irpStack->FileObject
                                       );
                   break;

            
        case IOCTL_GPC_MODIFY_CF_INFO:
            
            Status = ProxyGpcModifyCfInfo(ioBuffer,
                                          inputBufferLength,
                                          &outputBufferLength,
                                          Irp,
                                          irpStack->FileObject
                                          );
            
            break;
            
        case IOCTL_GPC_REMOVE_CF_INFO:
            
            Status = ProxyGpcRemoveCfInfo(ioBuffer,
                                          inputBufferLength,
                                          &outputBufferLength,
                                          Irp,
                                          irpStack->FileObject,
                                          FALSE);//Admin Only
            
             break;

        case IOCTL_GPC_REMOVE_CF_INFO_EX:

        	Status = ProxyGpcRemoveCfInfo(ioBuffer,
                                          inputBufferLength,
                                          &outputBufferLength,
                                          Irp,
                                          irpStack->FileObject,
                                          TRUE);//All User
              break;

            
        case IOCTL_GPC_ADD_PATTERN:
            
            Status = ProxyGpcAddPattern(ioBuffer,
                                        inputBufferLength,
                                        &outputBufferLength,
                                        irpStack->FileObject,
                                        FALSE); //Admin only IOCTL
            
            break;

        case IOCTL_GPC_ADD_PATTERN_EX:

       	Status = ProxyGpcAddPattern(ioBuffer,
                                        inputBufferLength,
                                        &outputBufferLength,
                                        irpStack->FileObject,
                                        TRUE); // All user IOCTL
            
            	break;

            
        case IOCTL_GPC_REMOVE_PATTERN:
            
            Status = ProxyGpcRemovePattern(ioBuffer,
                                           inputBufferLength,
                                           &outputBufferLength,
                                           irpStack->FileObject,
                                           FALSE);// Admin Only IOCTL
            
            break;

        case IOCTL_GPC_REMOVE_PATTERN_EX:
        	
	      Status = ProxyGpcRemovePattern(ioBuffer,
                                           inputBufferLength,
                                           &outputBufferLength,
                                           irpStack->FileObject,
                                           TRUE);// All user IOCTL
            
             break;
        	
            
        case IOCTL_GPC_ENUM_CFINFO:
            
            Status = ProxyGpcEnumCfInfo(ioBuffer,
                                        inputBufferLength,
                                        &outputBufferLength,
                                        irpStack->FileObject);
            
            break;
            
        case IOCTL_GPC_NOTIFY_REQUEST:
            
            //
            // request to pend an IRP
            //

            Status = CheckQueuedNotification(Irp, &outputBufferLength);

            break;

            
        case IOCTL_GPC_GET_ENTRIES:

            // Locking Down Kmode Only IOCTLs
            if (ExGetPreviousMode() != KernelMode)
                {
                    Status = STATUS_ACCESS_DENIED;
                    break;
                }
#ifdef STANDALONE_DRIVER

            //
            // Return the exported calls in the buffer
            //
            
            if (outputBufferLength >= sizeof(glGpcExportedCalls)) {
                
                NdisMoveMemory(ioBuffer, 
                               &glGpcExportedCalls, 
                               sizeof(glGpcExportedCalls));
                

                outputBufferLength = sizeof(glGpcExportedCalls);

            } else {
                
                outputBufferLength = sizeof(glGpcExportedCalls);
                Status = GPC_STATUS_INSUFFICIENT_BUFFER;
            }
#else
            Status = STATUS_INVALID_PARAMETER;
#endif
            break;

        default:
            DBGPRINT(IOCTL, ("GPCIoctl: Unknown IRP_MJ_DEVICE_CONTROL\n = %X\n",
                             ioControlCode));

            Status = STATUS_INVALID_PARAMETER;
            break;
            
        }	// switch (ioControlCode)
        
        break;


    default:
        DBGPRINT(IOCTL, ("GPCIoctl: Unknown IRP major function = %08X\n", 
                         irpStack->MajorFunction));

        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    DBGPRINT(IOCTL, ("GPCIoctl: Status=0x%X, IRP=0x%X, outSize=%d\n",
                     Status, (ULONG_PTR)Irp,  outputBufferLength));
    
    TRACE(IOCTL, Irp, Status, "GPCIoctl.Complete:");

    if (Status != STATUS_PENDING) {

        //
        // IRP completed and it's not Pending, we need to restore the Control flags,
        // since it might have been marked as Pending before...
        //

        irpStack->Control = saveControlFlags;
        
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = outputBufferLength;
        
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }

#if DBG
    irql2 = KeGetCurrentIrql();
    ASSERT(irql == irql2);
#endif

    TRACE(LOCKS, thrd, irql2, "GPCIoctl (end)");

    return Status;

} // GPCIoctl




VOID
IoctlCleanup(
    ULONG ShutdownMask
    )

/*++

Routine Description:

    Cleanup code for Initialize

Arguments:

    ShutdownMask - mask indicating which functions need to be cleaned up

Return Value:

    None

--*/

{
/*
    if ( ShutdownMask & SHUTDOWN_DELETE_SYMLINK ) {

        IoDeleteSymbolicLink( &PSSymbolicName );
    }
*/

    if ( ShutdownMask & SHUTDOWN_DELETE_DEVICE ) {

        IoDeleteDevice( GPCDeviceObject );
    }
}





NTSTATUS
TcpQueryInfoComplete(PDEVICE_OBJECT pDeviceObject,
            PIRP Irp,
            PVOID Context)
{
    PTDI_ROUTING_INFO RoutingInfo;
    PTRANSPORT_ADDRESS TransportAddress;
    PTA_ADDRESS TaAddress;
    PTDI_ADDRESS_IP IpAddress;
    int i;
    PGPC_IP_PATTERN   pTcpPattern;
    PGPC_TCP_QUERY_CONTEXT pGpcTcpContext;
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    
    RoutingInfo = (PTDI_ROUTING_INFO)Context;
    //
    // Get a pointer to the Original Context. This allows us to access the GPC_IP_PATTERN
    pGpcTcpContext = CONTAINING_RECORD(Context,GPC_TCP_QUERY_CONTEXT,RouteInfo);
    //
    // Retreive the pointer to the GPC_IP_PATTERN
    pTcpPattern =  pGpcTcpContext->pTcpPattern;

    // Check status .
    if (Irp->IoStatus.Status != STATUS_SUCCESS){
        goto exit;
        }
    DBGPRINT(IOCTL,("\n"));
    DBGPRINT(IOCTL,("Protocol: %d\n", RoutingInfo->Protocol));
    DBGPRINT(IOCTL,("InterfaceId: %d\n", RoutingInfo->InterfaceId));
    DBGPRINT(IOCTL,("LinkId: %d\n", RoutingInfo->LinkId));

    // Fill up the values of the Interface
    pTcpPattern->InterfaceId.InterfaceId = RoutingInfo->InterfaceId;
    pTcpPattern->InterfaceId.LinkId = RoutingInfo->LinkId;

    TransportAddress = (PTRANSPORT_ADDRESS)&RoutingInfo->Address;
    DBGPRINT(IOCTL,("Address Count: %d\n",TransportAddress->TAAddressCount));
 
    TaAddress = (PTA_ADDRESS)&TransportAddress->Address;


    if ((2 < TransportAddress->TAAddressCount) || (1 > TransportAddress->TAAddressCount)){
        // Release Memory
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        ASSERT(FALSE);
        goto exit;
        }

    IpAddress = (PTDI_ADDRESS_IP)&TaAddress->Address;
    pTcpPattern->SrcAddr = IpAddress->in_addr;
    pTcpPattern->gpcSrcPort = IpAddress->sin_port;
    DBGPRINT(IOCTL,("AddressLength = %d\n",TaAddress->AddressLength));
    DBGPRINT(IOCTL,("AddressType = %d\n",TaAddress->AddressType));
    DBGPRINT(IOCTL,("Port = %d\n",IpAddress->sin_port));
    DBGPRINT(IOCTL,("Address = %d.%d.%d.%d\n",
                        (IpAddress->in_addr & 0xff000000) >> 24, 
                        (IpAddress->in_addr & 0x00ff0000) >> 16,
                        (IpAddress->in_addr & 0x0000ff00) >> 8,
                        IpAddress->in_addr & 0x000000ff));

    if ( 2 == TransportAddress->TAAddressCount)
        {
            TaAddress = (PTA_ADDRESS)((PUCHAR)TaAddress + 
                                FIELD_OFFSET(TA_ADDRESS, Address) + 
                                TaAddress->AddressLength);
            IpAddress = (PTDI_ADDRESS_IP)&TaAddress->Address;
            pTcpPattern->DstAddr = IpAddress->in_addr;
            pTcpPattern->gpcDstPort = IpAddress->sin_port;
            pTcpPattern->ProtocolId = IPPROTO_TCP;
            DBGPRINT(IOCTL,("AddressLength = %d\n",TaAddress->AddressLength));
            DBGPRINT(IOCTL,("AddressType = %d\n",TaAddress->AddressType));
            DBGPRINT(IOCTL,("Port = %d\n",IpAddress->sin_port));
            DBGPRINT(IOCTL,("Address = %d.%d.%d.%d\n",
                        (IpAddress->in_addr & 0xff000000) >> 24, 
                        (IpAddress->in_addr & 0x00ff0000) >> 16,
                        (IpAddress->in_addr & 0x0000ff00) >> 8,
                        IpAddress->in_addr & 0x000000ff));
        }
    else{
            pTcpPattern->ProtocolId = IPPROTO_UDP;
        }
    //
    // Need to free the Memory allocated, MDL and the IRP here.
    
    exit:
    IoFreeMdl(pGpcTcpContext->pMdl);
    GpcFreeMem(pGpcTcpContext,TcpQueryContextTag);
    IoFreeIrp(Irp);
    
    return Status;
}


void
BuildTDIAddress(uchar * Buffer, IPAddr Addr, ushort Port)
{
    PTRANSPORT_ADDRESS XportAddr;
    PTA_ADDRESS TAAddr;

    XportAddr = (PTRANSPORT_ADDRESS) Buffer;
    XportAddr->TAAddressCount = 1;
    TAAddr = XportAddr->Address;
    TAAddr->AddressType = TDI_ADDRESS_TYPE_IP;
    TAAddr->AddressLength = sizeof(TDI_ADDRESS_IP);
    ((PTDI_ADDRESS_IP) TAAddr->Address)->sin_port = Port;
    ((PTDI_ADDRESS_IP) TAAddr->Address)->in_addr = Addr;
    memset(((PTDI_ADDRESS_IP) TAAddr->Address)->sin_zero,
        0,
        sizeof(((PTDI_ADDRESS_IP) TAAddr->Address)->sin_zero));
}



NTSTATUS
TcpQueryInfo(PFILE_OBJECT FileObject, PGPC_IP_PATTERN pTcpPattern, ULONG RemoteAddress, USHORT RemotePort)
{
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PVOID pBuffer = NULL;
    PVOID pInputBuf = NULL;
    PIO_STACK_LOCATION   pIrpSp;

    TDI_CONNECTION_INFORMATION ConnInfo;
    UCHAR InputBuf[FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + 
            FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)];
    PTRANSPORT_ADDRESS Address1;
    PTA_ADDRESS Address2;
    PGPC_IP_PATTERN * ppPattern;
    PGPC_TCP_QUERY_CONTEXT pContext= NULL;


    // IRP for querying TCPIP
    //Charge quota for outstanding IRPs
    try{
            pIrp = IoAllocateIrp((CCHAR)(FileObject->DeviceObject->StackSize), TRUE);
        }
    except(EXCEPTION_EXECUTE_HANDLER){
           pIrp = NULL;
        }
    //Check for allocation failure
    if (pIrp == NULL){
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
        } 

    //
    // Build output buf
    // Allocate Space for GPC_TCP_QUERY_CONTEXT
    //  
    
   GpcAllocMemWithQuota(&pBuffer, ROUTING_INFO_ADDR_2_SIZE, TcpQueryContextTag);
    // Check for allocation failure
    if (pBuffer==NULL) {
        Status = GPC_STATUS_RESOURCES ;   
        goto exit;
        }
   // Will use pContext to index into the Data Structure
   pContext = (PGPC_TCP_QUERY_CONTEXT)pBuffer;

   // Store our pointer to Pattern at the beginning of the Buffer
   (pContext->pTcpPattern) = pTcpPattern;


  // Initialize with Remote Ports 
  // Will disregard these values if we get back 2 addresses from TCP
   pTcpPattern->DstAddr = RemoteAddress;
   pTcpPattern->gpcDstPort = RemotePort; 

   // Jump over the pointer stored
   pBuffer = &(pContext->RouteInfo);
    
    // Charge Quota for the MDL allocation
    try{
        pMdl = IoAllocateMdl(pBuffer, ROUTING_INFO_ADDR_2_SIZE-
                    FIELD_OFFSET(GPC_TCP_QUERY_CONTEXT ,RouteInfo), FALSE, TRUE, NULL);
        }
    except(EXCEPTION_EXECUTE_HANDLER){
        pMdl = NULL;
        }
    
    //Check for allocation failure
    if (pMdl==NULL) {
        Status = GPC_STATUS_RESOURCES;
        goto exit;
        }


    // Should not Fail
    MmBuildMdlForNonPagedPool(pMdl);

    // Store our pointer to MDL in the context
    pContext->pMdl = pMdl;

    //
    // Build the input buf
    // Not Expected to Fail
    BuildTDIAddress(InputBuf, RemoteAddress, RemotePort);
    ConnInfo.RemoteAddress = InputBuf;
    ConnInfo.RemoteAddressLength = 100;

    // Should not  Fail
    TdiBuildQueryInformationEx(pIrp,
                                 FileObject->DeviceObject,
                                 FileObject,
                                 (PIO_COMPLETION_ROUTINE)TcpQueryInfoComplete,
                                 pBuffer, // Context in completion call
                                 TDI_QUERY_ROUTING_INFO,
                                 pMdl,
                                 &ConnInfo);

        // Completion handler always called, don't care on return value.
        Status=IoCallDriver(FileObject->DeviceObject, pIrp);

    // Per SanjayKa the call should always completely syncrhonously        
    // If we made the call memory would be released in our 
    // completion function
    return Status;
    exit:
            // release all memory 
            //allocated before returning
            // if we failed at some
            // stage
            if (pMdl){
                    IoFreeMdl(pMdl);
                }
            if (pContext){    
                    GpcFreeMem(pContext,TcpQueryContextTag);
                }
            if (pIrp){
                    IoFreeIrp(pIrp);
                }
   return Status;
}






// Function: ProxyGpcRegisterClient
//
// Parameters: 
//		PVOID ioBuffer: The buffer containing request and result
//          ULONG inputBufferLength: Size of Request
//          ULONG * outputBufferLength: Size of Result
// 		PFILE_OBJECT: The client's file object
//
// Result: The Status of the Call. an fail the IRP or return failure in the
//            GPC result structure
// Environment: 
// 		For use with the new REGISTER_CLIENT and  REGISTER_CLIENT_EX
//          Ioctls
NTSTATUS
ProxyGpcRegisterClient(
    PVOID 			ioBuffer,
    ULONG 			inputBufferLength,
    ULONG 			*outputBufferLength,
    PFILE_OBJECT	FileObject,
    BOOLEAN         fNewInterface
    )
{
    NTSTATUS 					Status;
    PCLIENT_BLOCK				pClient;
    PGPC_REGISTER_CLIENT_REQ 	GpcReq; 
    PGPC_REGISTER_CLIENT_RES 	GpcRes; 

    if (inputBufferLength < sizeof(GPC_REGISTER_CLIENT_REQ) 
        ||
        *outputBufferLength < sizeof(GPC_REGISTER_CLIENT_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }


    if (fNewInterface){
        // Do not allow HTTP to use this IOCTL interface
        //
            if ( KernelMode == ExGetPreviousMode() ){
                 return GPC_STATUS_NOT_SUPPORTED;
            }
        }

    GpcReq = (PGPC_REGISTER_CLIENT_REQ)ioBuffer;
    GpcRes = (PGPC_REGISTER_CLIENT_RES)ioBuffer;


     // Old IOCTL interface locked down to QOS only
    if (GpcReq->CfId != GPC_CF_QOS) return GPC_STATUS_INVALID_PARAMETER;
    

    // Check the flags the user is allowed to pass in 
    if (!((GpcReq->Flags == 0) ||(GpcReq->Flags == GPC_FLAGS_FRAGMENT))){
    	return GPC_STATUS_INVALID_PARAMETER;
    	}


    // Check the number of priorities requested
    if (GpcReq->MaxPriorities > GPC_PRIORITY_MAX) {
    	return GPC_STATUS_INVALID_PARAMETER;
    	}

    // ClientContext not validated since we dont do anything 
    // with it except return it to the client

    if (fNewInterface){
            Status = GpcRegisterClient(GpcReq->CfId,
                               GpcReq->Flags | GPC_FLAGS_USERMODE_CLIENT
                               |GPC_FLAGS_USERMODE_CLIENT_EX,
                               GpcReq->MaxPriorities,
                               &CallBackProxyList,
                               GpcReq->ClientContext,
                               (PGPC_HANDLE)&pClient);
        }
    else{
        Status = GpcRegisterClient(GpcReq->CfId,
                               GpcReq->Flags | GPC_FLAGS_USERMODE_CLIENT,
                               GpcReq->MaxPriorities,
                               &CallBackProxyList,
                               GpcReq->ClientContext,
                               (PGPC_HANDLE)&pClient);
        }
        

    ASSERT(Status != GPC_STATUS_PENDING);

    if (Status == STATUS_SUCCESS) {

        ASSERT(pClient);

        pClient->pFileObject = FileObject;

        GpcRes->ClientHandle = AllocateHandle(&pClient->ClHandle, (PVOID)pClient);

        if (GpcRes->ClientHandle == NULL)
        {   
            //Got a NULL Handle release the CLIENT_BLOCK 
            GpcDeregisterClient(pClient);
            Status = GPC_STATUS_RESOURCES;
        }
    }

    GpcRes->Status = Status;

    *outputBufferLength = sizeof(GPC_REGISTER_CLIENT_RES);

    return STATUS_SUCCESS;
}

// Function: ProxyGpcDeregisterClientEx
//
// Parameters: 
//          PVOID ioBuffer: The buffer containing request and result
//          ULONG inputBufferLength: Size of Request
//          ULONG * outputBufferLength: Size of Result
//          PFILE_OBJECT: The client's file object
//
// Result: The Status of the Call. can fail the IRP or return failure in the
//            GPC result structure
// Environment: 
// 		For use with the new DEREGISTER_CLIENT_EX and DEREGISTER_CLIENT 
//          ioctls

NTSTATUS
ProxyGpcDeregisterClient(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
     PFILE_OBJECT	FileObject,
     BOOLEAN fNewInterface
    )
{
    NTSTATUS 					Status;
    PGPC_DEREGISTER_CLIENT_REQ 	GpcReq;
    PGPC_DEREGISTER_CLIENT_RES 	GpcRes;
    GPC_HANDLE					GpcClientHandle;

    if (inputBufferLength < sizeof(GPC_DEREGISTER_CLIENT_REQ) 
        ||
        *outputBufferLength < sizeof(GPC_DEREGISTER_CLIENT_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (fNewInterface){
        // Do not allow HTTP to use this IOCTL interface
        //
            if ( KernelMode == ExGetPreviousMode() ){
                 return GPC_STATUS_NOT_SUPPORTED;
            }
        }

    GpcReq = (PGPC_DEREGISTER_CLIENT_REQ)ioBuffer;
    GpcRes = (PGPC_DEREGISTER_CLIENT_RES)ioBuffer;

    //Validate that the  client handle maps on to a CLIENT_BLOCK
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGDC');

    if (!GpcClientHandle) {
            Status = GPC_STATUS_INVALID_HANDLE;
            goto exit;
        }

   
    //
    // Validate that the client handle is owned by the 
    // calling user mode app.
    Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
    if (STATUS_SUCCESS != Status){
        goto exit;
     }
    
    Status = GpcDeregisterClient(GpcClientHandle);
    
    exit:
        
    if (GpcClientHandle) {
       REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGDC');
    }                
    
        
    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_DEREGISTER_CLIENT_RES);
                                   
    return STATUS_SUCCESS;
}

//
// Function for Handling New IOCTL 
// for adding cfinfo now open 
// to all users.
//
// Function: ProxyGpcAddCfInfoEx
//
// Parameters: 
//		PVOID ioBuffer: The buffer containing request and result
//          ULONG inputBufferLength: Size of Request
//          ULONG * outputBufferLength: Size of Result
// 		PIRP Irp: The Irp
//
// Result: The Status of the Call. One of GPC_STATUS_VALUES
//            documented in gpcifc.h
// Environment: 
//            To be used in response tos calls from winsock helper dll
//            for installing QOS flows for TCP sockets.
NTSTATUS
ProxyGpcAddCfInfoEx(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT FileObject
    )
{        
    NTSTATUS 				Status;
    GPC_HANDLE 				GpcClientHandle  = NULL;
    PGPC_ADD_CF_INFO_EX_REQ 	GpcReq = NULL; 
    PGPC_ADD_CF_INFO_RES 	GpcRes = NULL; 
    PBLOB_BLOCK				pBlob = NULL;
    QUEUED_COMPLETION		QItem;
    UNICODE_STRING 			CfInfoName;
    USHORT					NameLen = 0;
    PGPC_IP_PATTERN                 pTcpPattern = NULL;


    if (inputBufferLength < sizeof(GPC_ADD_CF_INFO_EX_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ADD_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }


    // Do not allow HTTP to use this IOCTL interface
    //
    if ( KernelMode == ExGetPreviousMode() )
        {
            return GPC_STATUS_NOT_SUPPORTED;
        }
        
    GpcReq = (PGPC_ADD_CF_INFO_EX_REQ)ioBuffer;
    GpcRes = (PGPC_ADD_CF_INFO_RES)ioBuffer;


    // Validating CfInfo and CfInfoSize
    if (GpcReq->CfInfoSize > 
        inputBufferLength - FIELD_OFFSET(GPC_ADD_CF_INFO_EX_REQ, CfInfo)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    // Should be atleast 1 byte : minimum size of variable length array
    if (GpcReq->CfInfoSize < sizeof(CHAR)) return GPC_STATUS_INVALID_PARAMETER;

    // NULL Handle
    if (NULL == GpcReq->FileHandle) return GPC_STATUS_INVALID_HANDLE;

    // Validate that the client handle maps on to a CLIENT_BLOCK
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGAC');
    //Failed to get the client handle 
    if (!GpcClientHandle){
        Status = GPC_STATUS_INVALID_HANDLE;
        goto exit;
    }

    //
    // Validate that the client handle is owned by the 
    // calling user mode app.
    //          
    Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
    if (Status != GPC_STATUS_SUCCESS) {
       // Need to release reference to CLIENT_BLOCK acquired earlier
       //
       goto exit;
    }

    // This is the new functionality 
    // Validate who owns the socket.
    // Get the fully specified pattern from TCP
    // Let's validate the request: file-object must be present
    //
       
	
    // 1. Get the file object for the file handle
    Status =  ObReferenceObjectByHandle(GpcReq->FileHandle,
                                                    0,
                                                    NULL,
                                                    KernelMode,
                                                    &FileObject,
                                                    NULL);

    if (Status != GPC_STATUS_SUCCESS) {
                goto exit;
    }

    GpcAllocMemWithQuota(&pTcpPattern , sizeof(GPC_IP_PATTERN), TcpPatternTag);


     if (pTcpPattern == NULL) {
	        goto exit;
     }
	     

    // The IOCTL sent by this function completes synchronously 
    // Expect the GPC_IP_PATTERN in pTcpPattern
    //
    Status = TcpQueryInfo(FileObject, pTcpPattern,GpcReq->RemoteAddress,GpcReq->RemotePort);
            
    if (STATUS_SUCCESS != Status) 
        goto exit;
            
    Status = privateGpcAddCfInfo(GpcClientHandle,
                              GpcReq->CfInfoSize,
                              &GpcReq->CfInfo,
                              GpcReq->ClientCfInfoContext,
                              FileObject,
                              pTcpPattern,
                              (PGPC_HANDLE)&pBlob);
       
    if (NT_SUCCESS(Status)) {

    //
    // including PENDING
    //
        if (Status == GPC_STATUS_PENDING) {

            QItem.OpCode = OP_ADD_CFINFO;
            QItem.ClientHandle = GpcClientHandle;
            QItem.CfInfoHandle = (GPC_HANDLE)pBlob;

            Status = CheckQueuedCompletion(&QItem, Irp);

        }

        if (Status == GPC_STATUS_SUCCESS) {
            GPC_STATUS			st = GPC_STATUS_FAILURE;
            GPC_CLIENT_HANDLE	NotifiedClientCtx = pBlob->NotifiedClientCtx;
            PCLIENT_BLOCK		pNotifiedClient = pBlob->pNotifiedClient;

            GpcRes->GpcCfInfoHandle = (GPC_HANDLE)AllocateHandle(&pBlob->ClHandle, (PVOID)pBlob);

            // what if we cant allocate a handle? fail the add!
            if (!GpcRes->GpcCfInfoHandle) {
                
                GpcRemoveCfInfo(GpcClientHandle,
                                pBlob);

                Status = GPC_STATUS_RESOURCES;
                // This memory is freed in 
                // GpcRemoveCfInfo 
                // due to dereferencing that blob
                pTcpPattern = NULL;
                
                goto exit;

            }
                 

            if (pNotifiedClient) {

                if (pNotifiedClient->FuncList.ClGetCfInfoName &&
                    NotifiedClientCtx) {
                
                    st = pNotifiedClient->FuncList.ClGetCfInfoName(
                                   pNotifiedClient->ClientCtx,
                                   NotifiedClientCtx,
                                   &CfInfoName
                                   );
                    if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                        CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                    //
                    // RajeshSu claims this can never happen.
                    //
                    ASSERT(NT_SUCCESS(st));

                }
            }
            
            if (NT_SUCCESS(st)) {
                
                //
                // copy the instance name
                //
                
                GpcRes->InstanceNameLength = NameLen = CfInfoName.Length;
                RtlMoveMemory(GpcRes->InstanceName, 
                              CfInfoName.Buffer,
                              CfInfoName.Length
                              );
            } else {
                
                //
                // generate a default name
                //
                
                if (NotifiedClientCtx)
                    swprintf(GpcRes->InstanceName, L"Flow %08X", NotifiedClientCtx);
                else
                    swprintf(GpcRes->InstanceName, L"Flow <unkonwn name>");
                GpcRes->InstanceNameLength = NameLen = wcslen(GpcRes->InstanceName)*sizeof(WCHAR);
            
            }
            
            GpcRes->InstanceName[GpcRes->InstanceNameLength/sizeof(WCHAR)] = L'\0';
            
        } else {

            pBlob = NULL;
            // The pattern is freed  along with the blob
            // We have a guarantee that it was at least
            // associated with the blob synchronously
            pTcpPattern = NULL;
        }

    }
    else
        {
            // This memory is freed in 
            // PrivateGpcAddCfInfoEx 
            // if that function fails
            pTcpPattern = NULL;
        }

        //
        // release the ref count we got earlier
        //
exit:

    if (GpcClientHandle) {
         //
         // release the ref count we got earlier
         //
        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGAC');
    }
    if (!NT_SUCCESS(Status) && (pTcpPattern)){
        GpcFreeMem(pTcpPattern, TcpPatternTag);
        }
        
    
    GpcRes->InstanceNameLength = NameLen;
    GpcRes->Status = Status;
    *outputBufferLength = sizeof(GPC_ADD_CF_INFO_RES);

    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}



// Function: ProxyGpcAddCfInfo
//
// Parameters: 
//		PVOID ioBuffer: The buffer containing request and result
//          ULONG inputBufferLength: Size of Request
//          ULONG * outputBufferLength: Size of Result
// 		PIRP Irp: The Irp
//
// Result: The Status of the Call. One of GPC_STATUS_VALUES
//            documented in gpcifc.h
// Environment: 
//            To be used in response to calls from HTTP.sys and traffic.dll
//            for installing QOS flows for TCP sockets.
NTSTATUS
ProxyGpcAddCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT FileObject 
    )
{        
    NTSTATUS 				Status;
    GPC_HANDLE 				GpcClientHandle;
    PGPC_ADD_CF_INFO_REQ 	GpcReq; 
    PGPC_ADD_CF_INFO_RES 	GpcRes; 
    PBLOB_BLOCK				pBlob = NULL;
    QUEUED_COMPLETION		QItem;
    UNICODE_STRING 			CfInfoName;
    USHORT					NameLen = 0;

    if (inputBufferLength < sizeof(GPC_ADD_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ADD_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_ADD_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_ADD_CF_INFO_RES)ioBuffer;


    //Validate CfInfo and CfInfoSize
    if (GpcReq->CfInfoSize > 
        inputBufferLength - FIELD_OFFSET(GPC_ADD_CF_INFO_REQ, CfInfo)) {

        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (GpcReq->CfInfoSize < 1) return GPC_STATUS_INVALID_PARAMETER;

    //Validate that the client handle maps on to a CLIENT_BLOCK
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGAC');
    if (GpcClientHandle) {

        //
        // Validate that the client handle is owned by the 
        // calling user mode app.
        //  
        Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
        if (Status == GPC_STATUS_SUCCESS)
        {
            Status = privateGpcAddCfInfo(GpcClientHandle,
                              GpcReq->CfInfoSize,
                              &GpcReq->CfInfo,
                              GpcReq->ClientCfInfoContext,
                              NULL,
                              NULL,
                              (PGPC_HANDLE)&pBlob);
        }
        

        if (NT_SUCCESS(Status)) {

            //
            // including PENDING
            //

            if (Status == GPC_STATUS_PENDING) {

                QItem.OpCode = OP_ADD_CFINFO;
                QItem.ClientHandle = GpcClientHandle;
                QItem.CfInfoHandle = (GPC_HANDLE)pBlob;

                Status = CheckQueuedCompletion(&QItem, Irp);

            }

            if (Status == GPC_STATUS_SUCCESS) {
                
                GPC_STATUS			st = GPC_STATUS_FAILURE;
                GPC_CLIENT_HANDLE	NotifiedClientCtx = pBlob->NotifiedClientCtx;
                PCLIENT_BLOCK		pNotifiedClient = pBlob->pNotifiedClient;

                GpcRes->GpcCfInfoHandle = (GPC_HANDLE)AllocateHandle(&pBlob->ClHandle, (PVOID)pBlob);

                // what if we cant allocate a handle? fail the add!
                if (!GpcRes->GpcCfInfoHandle) {
                    
                    GpcRemoveCfInfo(GpcClientHandle,
                                    pBlob);

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    
                    goto exit;
        
                }
                     

                if (pNotifiedClient) {

                    if (pNotifiedClient->FuncList.ClGetCfInfoName &&
                        NotifiedClientCtx) {
                    
                        st = pNotifiedClient->FuncList.ClGetCfInfoName(
                                       pNotifiedClient->ClientCtx,
                                       NotifiedClientCtx,
                                       &CfInfoName
                                       );
                        if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                        //
                        // RajeshSu claims this can never happen.
                        //
                        ASSERT(NT_SUCCESS(st));

                    }
                }
                
                if (NT_SUCCESS(st)) {
                    
                    //
                    // copy the instance name
                    //
                    
                    GpcRes->InstanceNameLength = NameLen = CfInfoName.Length;
                    RtlMoveMemory(GpcRes->InstanceName, 
                                  CfInfoName.Buffer,
                                  CfInfoName.Length
                                  );
                } else {
                    
                    //
                    // generate a default name
                    //
                    
                    if (NotifiedClientCtx)
                        swprintf(GpcRes->InstanceName, L"Flow %08X", NotifiedClientCtx);
                    else
                        swprintf(GpcRes->InstanceName, L"Flow <unkonwn name>");
                    GpcRes->InstanceNameLength = NameLen = wcslen(GpcRes->InstanceName)*sizeof(WCHAR);
                
                }
                
                GpcRes->InstanceName[GpcRes->InstanceNameLength/sizeof(WCHAR)] = L'\0';
                
            } else {

                pBlob = NULL;
            }

        }

        //
        // release the ref count we got earlier
        //
exit:

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGAC');

    } else {

      ASSERT(pBlob == NULL);
      Status = GPC_STATUS_INVALID_HANDLE;
    }

    GpcRes->InstanceNameLength = NameLen;
    GpcRes->Status = Status;
    *outputBufferLength = sizeof(GPC_ADD_CF_INFO_RES);

    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}



NTSTATUS
ProxyGpcAddPattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject,
    BOOLEAN        fNewInterface              
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE 				GpcClientHandle=NULL;
    GPC_HANDLE 				GpcCfInfoHandle=NULL;
    CLASSIFICATION_HANDLE 	ClassificationHandle = 0;
    PGPC_ADD_PATTERN_REQ 	GpcReq;
    PGPC_ADD_PATTERN_RES 	GpcRes;
    PVOID 					Pattern;
    PVOID 					Mask;
    PPATTERN_BLOCK			pPattern;
    PBLOB_BLOCK pBlob = NULL ;

    if (inputBufferLength < sizeof(GPC_ADD_PATTERN_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ADD_PATTERN_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (fNewInterface){
        // Do not allow HTTP to use this IOCTL interface
        //
            if ( KernelMode == ExGetPreviousMode() ){
                 return GPC_STATUS_NOT_SUPPORTED;
            }
        }

    GpcReq = (PGPC_ADD_PATTERN_REQ)ioBuffer;
    GpcRes = (PGPC_ADD_PATTERN_RES)ioBuffer;


    //Validate PatternSize and Size of PatternAndMask array
    if (GpcReq->PatternSize > MAX_PATTERN_SIZE) {
        
        return STATUS_INVALID_PARAMETER;
    }

    if (inputBufferLength - FIELD_OFFSET(GPC_ADD_PATTERN_REQ, PatternAndMask)
        < 2 * GpcReq->PatternSize) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //Validate that the client handle maps on to a CLIENT_BLOCK
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGAP');
    //
    // Validate that the cfInfo handle maps on to a BLOB_BLOCK
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGAP');

    if (!(GpcClientHandle && GpcCfInfoHandle)){
        Status = GPC_STATUS_INVALID_HANDLE;
        goto exit;
        }
        
    Pattern = (PVOID)&GpcReq->PatternAndMask;
    Mask = (PVOID)((PCHAR)(&GpcReq->PatternAndMask) + GpcReq->PatternSize);

     //
     // Validate that the client handle is owned by the 
     // calling user mode app.
     //  
     Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
     if ( GPC_STATUS_SUCCESS != Status ){
        goto exit;
        }
        
      //
      // Validate that the client owns the cfinfo 
      // to which he wants to link the pattern to 
      //
      Status = GpcValidateCfinfoOwner(GpcClientHandle,GpcCfInfoHandle);
      if (GPC_STATUS_SUCCESS != Status) {
        goto exit;
        }
     
      pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

       // Priority and Protocol Template Validation                     
      if (GpcReq->Priority >= 
        ((PCLIENT_BLOCK)(GpcClientHandle))->pCfBlock->MaxPriorities ||
          GpcReq->ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX ) {
                          Status = GPC_STATUS_INVALID_PARAMETER;
                          goto exit;
      }

     // EX IOCTL users should already have their
     // GPC_IP_PATTERN hanging off the 
     // BLOB_BLOCK
     if ((fNewInterface) && (!pBlob->Pattern)) {
        Status = GPC_STATUS_INVALID_PARAMETER;
        goto exit;
        }

    //EX IOCTL users only
    if (fNewInterface){       
             //Extra code for the new IOCTL.
             // The cfinfo should contain a valid pattern pointer
             // receiverd during the previous call to ProxyGpcAddCfinfoEx
             RtlCopyMemory(Pattern, pBlob->Pattern, sizeof(GPC_IP_PATTERN));
             RtlFillMemory(Mask, sizeof(GPC_IP_PATTERN), 0xff);
        }

                              
    Status = GpcAddPattern(GpcClientHandle,
                         GpcReq->ProtocolTemplate,
                         Pattern,
                         Mask,
                         GpcReq->Priority,
                         GpcCfInfoHandle,
                         (PGPC_HANDLE)&pPattern,
                         &ClassificationHandle);
                        

        
    if (Status == GPC_STATUS_SUCCESS) {    
        ASSERT(Pattern);

        GpcRes->GpcPatternHandle = AllocateHandle(&pPattern->ClHandle, (PVOID)pPattern);

        //
        // In certain circs, alloc_HF_handle could return 0. 
        // check for that and clean up the mess.
        //
        if (!GpcRes->GpcPatternHandle) {
            //
            // remove the pattern that was just added.
            //
            Status = GpcRemovePattern(GpcClientHandle,
                                          pPattern);

            //
            // This was really the problem why we got a NULL handle
            //
            Status = GPC_STATUS_RESOURCES;
        }
     }

   

exit:
    if (GpcCfInfoHandle) {

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGAP');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGAP');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
    GpcRes->ClassificationHandle = ClassificationHandle;
        
    *outputBufferLength = sizeof(GPC_ADD_PATTERN_RES);

    return STATUS_SUCCESS;
}


                                   
NTSTATUS
ProxyGpcModifyCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT FileObject
    )
{
    NTSTATUS                Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    PGPC_MODIFY_CF_INFO_REQ GpcReq;
    PGPC_MODIFY_CF_INFO_RES GpcRes;
    QUEUED_COMPLETION		QItem;

    if (inputBufferLength < sizeof(GPC_MODIFY_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_MODIFY_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_MODIFY_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_MODIFY_CF_INFO_RES)ioBuffer;

    if (GpcReq->CfInfoSize > 
        inputBufferLength - FIELD_OFFSET(GPC_MODIFY_CF_INFO_REQ, CfInfo)) {

        return STATUS_INVALID_BUFFER_SIZE;
    }
    // Validate that the client handle maps on to a valid CLIENT_BLOCK
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGMP');
    // Validate that the cfInfo handle maps on to a valid BLOB_BLOCK 
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGMP');
    
    if (GpcClientHandle && GpcCfInfoHandle) {

        //
        // Validate that the client handle is owned by the 
        // calling user mode app.
        //  
        Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
        if (Status == GPC_STATUS_SUCCESS)
        {
           //
           // Validate that the client only modifies a CfInfo that 
           // belongs to him.
           //
           Status = GpcValidateCfinfoOwner (GpcClientHandle , GpcCfInfoHandle);
           if ( Status == GPC_STATUS_SUCCESS )
            {
                Status = GpcModifyCfInfo(GpcClientHandle,
                                     GpcCfInfoHandle,
                                     GpcReq->CfInfoSize,
                                     &GpcReq->CfInfo
                                 );
            }
        }
        if (Status == GPC_STATUS_PENDING) {
            
            QItem.OpCode = OP_MODIFY_CFINFO;
            QItem.ClientHandle = GpcClientHandle;
            QItem.CfInfoHandle = GpcCfInfoHandle;
            
            Status = CheckQueuedCompletion(&QItem, Irp);
            
        }

    } else { 

        Status = STATUS_INVALID_HANDLE;
    }
                          
    if (GpcCfInfoHandle) {

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGMP');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGMP');
    }

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_MODIFY_CF_INFO_RES);

    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}



NTSTATUS
ProxyGpcRemoveCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp,
    PFILE_OBJECT    FileObject,
    BOOLEAN     fNewInterface
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    PGPC_REMOVE_CF_INFO_REQ GpcReq;
    PGPC_REMOVE_CF_INFO_RES GpcRes;
    QUEUED_COMPLETION		QItem;

    if (inputBufferLength < sizeof(GPC_REMOVE_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_REMOVE_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (fNewInterface){
        // Do not allow HTTP to use this IOCTL interface
        //
            if ( KernelMode == ExGetPreviousMode() ){
                 return GPC_STATUS_NOT_SUPPORTED;
            }
        }

    GpcReq = (PGPC_REMOVE_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_REMOVE_CF_INFO_RES)ioBuffer;

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGRC');
    
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGRC');
    
    if (GpcClientHandle && GpcCfInfoHandle) {
        
        //
        // Validate that the client handle is owned by the 
        // calling user mode app.
        //  
        Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
        if (Status == GPC_STATUS_SUCCESS)
        {
           //
           // Validate that the client only removes a cfinfo 
           // that belongs to him
           //
           Status = GpcValidateCfinfoOwner (GpcClientHandle , GpcCfInfoHandle);
           if ( Status == GPC_STATUS_SUCCESS )
            {
                if (fNewInterface){
                    Status = privateGpcRemoveCfInfo(GpcClientHandle, 
                                                GpcCfInfoHandle,
                                                GPC_FLAGS_USERMODE_CLIENT
                                                |GPC_FLAGS_USERMODE_CLIENT_EX);
                    }
                else{
                    Status = privateGpcRemoveCfInfo(GpcClientHandle, 
                                                GpcCfInfoHandle,
                                                GPC_FLAGS_USERMODE_CLIENT);
                    }
                    
                
            }
       }
        
        if (Status == GPC_STATUS_PENDING) {
            
            QItem.OpCode = OP_REMOVE_CFINFO;
            QItem.ClientHandle = GpcClientHandle;
            QItem.CfInfoHandle = GpcCfInfoHandle;
            
            Status = CheckQueuedCompletion(&QItem, Irp);
            
        }

    } else {

        Status = STATUS_INVALID_HANDLE;
    }
        
    if (GpcCfInfoHandle) {
        
        //
        // release the ref count we got earlier
        //

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGRC');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGRC');
    }

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_REMOVE_CF_INFO_RES);
                                   
    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}
                                   
                                   
NTSTATUS
ProxyGpcRemovePattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject,
    BOOLEAN   fNewInterface
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcPatternHandle;
    PGPC_REMOVE_PATTERN_REQ GpcReq;
    PGPC_REMOVE_PATTERN_RES GpcRes;

    if (inputBufferLength < sizeof(GPC_REMOVE_PATTERN_REQ)
        ||
        *outputBufferLength < sizeof(GPC_REMOVE_PATTERN_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (fNewInterface){
        // Do not allow HTTP to use this IOCTL interface
        //
            if ( KernelMode == ExGetPreviousMode() ){
                 return GPC_STATUS_NOT_SUPPORTED;
            }
        }

    GpcReq = (PGPC_REMOVE_PATTERN_REQ)ioBuffer;
    GpcRes = (PGPC_REMOVE_PATTERN_RES)ioBuffer;

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGRP');
    
    GpcPatternHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcPatternHandle,
                                                          GPC_ENUM_PATTERN_TYPE,
                                                          'PGRP');

    if (!(GpcClientHandle && GpcPatternHandle) ) {
        Status = GPC_STATUS_INVALID_HANDLE;
        goto exit;
        }
    //
    // Validate that the client handle is owned by the 
    // calling user mode app.
    //  
    Status = GpcValidateClientOwner(GpcClientHandle, FileObject);
    if (GPC_STATUS_SUCCESS  != Status) {
     goto exit;
    }

     // 
     // Validate that the client owns the Pattern that it is trying to delete
     //
     Status = GpcValidatePatternOwner(GpcClientHandle,GpcPatternHandle);
     if (GPC_STATUS_SUCCESS != Status){
      goto exit;
     }
      
    Status = GpcRemovePattern(GpcClientHandle, 
                                         GpcPatternHandle);

    exit:

    if (GpcPatternHandle) {    
        REFDEL(&((PPATTERN_BLOCK)GpcPatternHandle)->RefCount, 'PGRP');
    }

    if (GpcClientHandle) {
        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGRP');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_REMOVE_PATTERN_RES);
                                   
    return STATUS_SUCCESS;
}

NTSTATUS
ProxyGpcEnumCfInfo(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength,
    PFILE_OBJECT FileObject
    )
{
    NTSTATUS 				Status;
    PGPC_ENUM_CFINFO_REQ 	GpcReq;
    PGPC_ENUM_CFINFO_RES 	GpcRes;
    ULONG					Size;
    ULONG					TotalCount;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    GPC_HANDLE				EnumHandle;
    PBLOB_BLOCK				pBlob;

    if (inputBufferLength < sizeof(GPC_ENUM_CFINFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ENUM_CFINFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_ENUM_CFINFO_REQ)ioBuffer;
    GpcRes = (PGPC_ENUM_CFINFO_RES)ioBuffer;
    
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGEC');

    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->EnumHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGEC');
    
    if (GpcReq->EnumHandle != NULL && GpcCfInfoHandle == NULL) {

        //
        // the flow has been deleted during enumeration
        //
        
        Status = STATUS_DATA_ERROR;

    } else if (GpcClientHandle) {

        TotalCount = GpcReq->CfInfoCount;
        EnumHandle = GpcReq->EnumHandle;
        Size = *outputBufferLength - FIELD_OFFSET(GPC_ENUM_CFINFO_RES, 
                                                  EnumBuffer);

        //
        // save the blob pointer with the one extra ref count
        // since we called GetHandleObjectWithRef
        //

        pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

        Status = GpcEnumCfInfo(GpcClientHandle,
                               &GpcCfInfoHandle,
                               &EnumHandle,
                               &TotalCount,
                               &Size,
                               GpcRes->EnumBuffer
                               );

        if (pBlob) {

            REFDEL(&pBlob->RefCount, 'PGEC');

        }

        if (Status == GPC_STATUS_SUCCESS) {

            //
            // fill in the results
            //

            GpcRes->TotalCfInfo = TotalCount;
            GpcRes->EnumHandle = EnumHandle;
            *outputBufferLength = Size + FIELD_OFFSET(GPC_ENUM_CFINFO_RES, 
                                                      EnumBuffer);
        }

    } else {

        if (GpcCfInfoHandle) {
            
            REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGEC');
        }

        Status = STATUS_INVALID_HANDLE;
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGEC');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
    
    return STATUS_SUCCESS;
}
                                   


VOID
CancelPendingIrpCfInfo(
	IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    )

/*++

Routine Description:

	Cancels an outstanding IRP request for a CfInfo request.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The cfinfo block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PPENDING_IRP        pPendingIrp = NULL;
    PPENDING_IRP        pItem;
    PLIST_ENTRY        	pEntry;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: Irp=0x%X\n", 
                     (ULONG_PTR)Irp));

    TRACE(IOCTL, Irp, 0, "CancelPendingIrpCfInfo:");
    TRACE(LOCKS, thrd, irql, "CancelPendingIrpCfInfo:");

    for ( pEntry = PendingIrpCfInfoList.Flink;
          pEntry != &PendingIrpCfInfoList;
          pEntry = pEntry->Flink ) {

        pItem = CONTAINING_RECORD(pEntry, PENDING_IRP, Linkage);

        if (pItem->Irp == Irp) {

            pPendingIrp = pItem;
            GpcRemoveEntryList(pEntry);

            IoSetCancelRoutine(pPendingIrp->Irp, NULL);

            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pPendingIrp != NULL) {

        DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: found PendingIrp=0x%X\n", 
                         (ULONG_PTR)pPendingIrp));

        TRACE(IOCTL, Irp, pPendingIrp, "CancelPendingIrpCfInfo.PendingIrp:");

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

        //
        // Complete the IRP.
        //

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    } else {

        DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: PendingIrp not found\n"));
        TRACE(IOCTL, Irp, 0, "CancelPendingIrpCfInfo.NoPendingIrp:");

    }

#if DBG
    irql = KeGetCurrentIrql();
#endif

    TRACE(LOCKS, thrd, irql, "CancelPendingIrpCfInfo (end)");

	return;
}




VOID
CancelPendingIrpNotify(
	IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    )

/*++

Routine Description:

	Cancels an outstanding IRP request for a notification.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

--*/

{
    PPENDING_IRP        pPendingIrp = NULL;
    PPENDING_IRP        pItem;
    PLIST_ENTRY        	pEntry;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    DBGPRINT(IOCTL, ("CancelPendingIrpNotify: Irp=0x%X\n", 
                     (ULONG_PTR)Irp));
    TRACE(IOCTL, Irp, 0, "CancelPendingIrpNotify:");
    TRACE(LOCKS, thrd, irql, "CancelPendingIrpNotify:");

    for ( pEntry = PendingIrpNotifyList.Flink;
          pEntry != &PendingIrpNotifyList;
          pEntry = pEntry->Flink ) {

        pItem = CONTAINING_RECORD(pEntry, PENDING_IRP, Linkage);

        if (pItem->Irp == Irp) {

            pPendingIrp = pItem;
            GpcRemoveEntryList(pEntry);

            IoSetCancelRoutine(pPendingIrp->Irp, NULL);

            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pPendingIrp != NULL) {

        DBGPRINT(IOCTL, ("CancelPendingIrpNotify: Found a PendingIrp=0x%X\n", 
                         (ULONG_PTR)pPendingIrp));
        TRACE(IOCTL, Irp, pPendingIrp, "CancelPendingIrpNotify.PendingIrp:");

        //
        // Free the PENDING_IRP structure. 
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

        //
        // Complete the IRP.
        //

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    } else {

        DBGPRINT(IOCTL, ("CancelPendingIrpNotify: PendingIrp not found\n"));
        TRACE(IOCTL, Irp, 0, "CancelPendingIrpNotify.NoPendingIrp:");
    }

#if DBG
    irql = KeGetCurrentIrql();
#endif

    TRACE(LOCKS, thrd, irql, "CancelPendingIrpNotify (end)");

	return;
}




VOID
UMClientRemoveCfInfoNotify(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK				pBlob
    )

/*++

Routine Description:

	Notify user mode client that the CfInfo is deleted.
    This will dequeue a pending IRP and will complete it.
    If there is no pending IRP, a GPC_NOTIFY_REQUEST_RES buffer
    will be queued until we get an IRP down the stack.

Arguments:

	pClient	- the notified client
	pBlob	- the deleted cfinfo

Return Value:

    None

--*/

{
    KIRQL                 	oldIrql;
    PIRP                  	pIrp;
    PPENDING_IRP          	pPendingIrp = NULL;
    PLIST_ENTRY           	pEntry;
    PQUEUED_NOTIFY			pQItem;
    PGPC_NOTIFY_REQUEST_RES	GpcRes;

    ASSERT(pClient == pBlob->pOwnerClient);

    DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: pClient=0x%X, pBlob=0x%X\n", 
                     (ULONG_PTR)pClient, (ULONG_PTR)pBlob));
    TRACE(IOCTL, pClient, pBlob, "UMClientRemoveCfInfoNotify:");

    //
    // Find the request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = PendingIrpNotifyList.Flink;
          pEntry != &PendingIrpNotifyList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if (pPendingIrp->FileObject == pClient->pFileObject) {

            //
            // that's the pending request
            //

            pIrp = pPendingIrp->Irp;
            IoSetCancelRoutine(pIrp, NULL);
            GpcRemoveEntryList(pEntry);
            break;

        } else {
            
            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp == NULL) {

        //
        // No IRP, we need to queue the notification block
        //

        DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: No pending IRP found\n"
                         ));
        TRACE(IOCTL, 
              pClient->ClientCtx, 
              pBlob->arClientCtx[pClient->AssignedIndex],
              "UMClientRemoveCfInfoNotify.NoPendingIrp:");

        GpcAllocFromLL(&pQItem, &QueuedNotificationLL, QueuedNotificationTag);

        if (pQItem) {

            pQItem->FileObject = pClient->pFileObject;

            //
            // fill the item
            //

            pQItem->NotifyRes.ClientCtx = pClient->ClientCtx;
            pQItem->NotifyRes.NotificationCtx = 
                (ULONG_PTR)pBlob->arClientCtx[pClient->AssignedIndex];
            pQItem->NotifyRes.SubCode = GPC_NOTIFY_CFINFO_CLOSED;
            pQItem->NotifyRes.Reason = 0;	// for now...
            pQItem->NotifyRes.Param1 = 0;	// for now...

            GpcInsertTailList(&QueuedNotificationList, &pQItem->Linkage);

        }

    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pPendingIrp) {

        //
        // found an IRP, fill and complete
        //

        DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: Pending IRP found=0x%X\n",
                         (ULONG_PTR)pIrp));
        TRACE(IOCTL, 
              pClient->ClientCtx, 
              pBlob->arClientCtx[pClient->AssignedIndex],
              "UMClientRemoveCfInfoNotify.PendingIrp:");

        GpcRes = (PGPC_NOTIFY_REQUEST_RES)pIrp->AssociatedIrp.SystemBuffer;

        GpcRes->ClientCtx = pClient->ClientCtx;
        GpcRes->NotificationCtx = 
            (ULONG_PTR)pBlob->arClientCtx[pClient->AssignedIndex];
        GpcRes->SubCode = GPC_NOTIFY_CFINFO_CLOSED;
        GpcRes->Reason = 0;	// for now...
        GpcRes->Param1 = 0;	// for now...
        
        //
        // complete the IRP
        //

        pIrp->IoStatus.Information = sizeof(GPC_NOTIFY_REQUEST_REQ);
        pIrp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        //
        // We can free the pending irp item
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    }

    //
    // for now - complete the operation
    // we should probably let the User Mode client do it,
    // but this complicates things a little...
    //

    GpcRemoveCfInfoNotifyComplete((GPC_HANDLE)pClient,
                                  (GPC_HANDLE)pBlob,
                                  GPC_STATUS_SUCCESS
                                  );
    
    return;
}


VOID
UMCfInfoComplete(
	IN	GPC_COMPLETION_OP		OpCode,
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    )

/*++

Routine Description:

	This is the completion routine for any pending CfInfo request.
    It will search the pending IRP CfInfo list for a matching CfInfo
    structure that has been stored while the Add, Modify or Remove
    request returned PENDING. The client must be the CfInfo owner,
    otherwise we would have never got here. 
    If an IRP is not found, it means the operation completed *before*
    we got back the PENDING status, which is perfectly legal.
    In this case, we queue a completion item and return.

Arguments:

	OpCode  - the code of the completion (add, modify or remove)
	pClient	- the notified client
	pBlob	- the deleted cfinfo
	Status  - the reported status

Return Value:

    None

--*/

{
    typedef   union _GPC_CF_INFO_RES {
        GPC_ADD_CF_INFO_RES		AddRes;
        GPC_MODIFY_CF_INFO_RES	ModifyRes;
        GPC_REMOVE_CF_INFO_RES	RemoveRes;
    } GPC_CF_INFO_RES;
        
    KIRQL                 	oldIrql;
    PIRP                  	pIrp;
    PIO_STACK_LOCATION    	pIrpSp;
    PPENDING_IRP          	pPendingIrp = NULL;
    PLIST_ENTRY           	pEntry;
    GPC_CF_INFO_RES			*GpcRes;
    ULONG					outputBuferLength;
    //PQUEUED_COMPLETION		pQItem;

    //ASSERT(pClient == pBlob->pOwnerClient);

    DBGPRINT(IOCTL, ("UMCfInfoComplete: pClient=0x%X, pBlob=0x%X, Status=0x%X\n", 
                     (ULONG_PTR)pClient, (ULONG_PTR)pBlob, Status));
    TRACE(IOCTL, OpCode, pClient, "UMCfInfoComplete:");
    TRACE(IOCTL, pBlob, Status, "UMCfInfoComplete:");
    
    //
    // Find the request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = PendingIrpCfInfoList.Flink;
          pEntry != &PendingIrpCfInfoList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if (pPendingIrp->QComp.CfInfoHandle == (GPC_HANDLE)pBlob
            &&
            pPendingIrp->QComp.OpCode == OpCode ) {

            //
            // that's the pending request
            //

            pIrp = pPendingIrp->Irp;
            ASSERT(pIrp);
            IoSetCancelRoutine(pIrp, NULL);
            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp == NULL) {

        //
        // No IRP, we need to queue a completion block
        //

        DBGPRINT(IOCTL, ("UMCfInfoComplete: No pending IRP found\n"));
        TRACE(IOCTL, pBlob, Status, "UMCfInfoComplete.NoPendingIrp:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp) {

            pPendingIrp->Irp = NULL;
            pPendingIrp->FileObject = pClient->pFileObject;
            pPendingIrp->QComp.OpCode = OpCode;
            pPendingIrp->QComp.ClientHandle = (GPC_HANDLE)pClient;
            pPendingIrp->QComp.CfInfoHandle = (GPC_HANDLE)pBlob;
            pPendingIrp->QComp.Status = Status;

            GpcInsertTailList(&QueuedCompletionList, &pPendingIrp->Linkage);

        }

        IoReleaseCancelSpinLock(oldIrql);

        return;
    }

    IoReleaseCancelSpinLock(oldIrql);

    ASSERT(pPendingIrp && pIrp);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    GpcRes = (GPC_CF_INFO_RES *)pIrp->AssociatedIrp.SystemBuffer;

    DBGPRINT(IOCTL, ("UMCfInfoComplete: Pending IRP found=0x%X, Ioctl=0x%X\n",
                     (ULONG_PTR)pIrp,
                     pIrpSp->Parameters.DeviceIoControl.IoControlCode
                     ));

    TRACE(IOCTL, 
          pIrp, 
          pIrpSp->Parameters.DeviceIoControl.IoControlCode, 
          "UMCfInfoComplete.PendingIrp:");

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_GPC_ADD_CF_INFO:

        ASSERT(OpCode == OP_ADD_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_ADD);

        GpcRes->AddRes.Status = Status;

        GpcRes->AddRes.ClientCtx = pClient->ClientCtx;
        GpcRes->AddRes.CfInfoCtx = pBlob->OwnerClientCtx;
        GpcRes->AddRes.GpcCfInfoHandle = pBlob->ClHandle;
            
        if (Status == GPC_STATUS_SUCCESS) {
            
            UNICODE_STRING CfInfoName;
            
            if (pBlob->pNotifiedClient) {
                
                GPC_STATUS	st = GPC_STATUS_FAILURE;

                if (pBlob->pNotifiedClient->FuncList.ClGetCfInfoName) {

                    ASSERT(pBlob->NotifiedClientCtx);

                    pBlob->pNotifiedClient->FuncList.ClGetCfInfoName(
                                       pBlob->pNotifiedClient->ClientCtx,
                                       pBlob->NotifiedClientCtx,
                                       &CfInfoName
                                       );
                    
                    if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                }

                if (!NT_SUCCESS(st)) {

                    //
                    // generate a default name
                    //

                    swprintf(CfInfoName.Buffer, L"Flow %08X", pBlob->NotifiedClientCtx);
                    CfInfoName.Length = wcslen(CfInfoName.Buffer)*sizeof(WCHAR);

                }

                //
                // copy the instance name
                //
                    
                GpcRes->AddRes.InstanceNameLength = CfInfoName.Length;
                NdisMoveMemory(GpcRes->AddRes.InstanceName, 
                               CfInfoName.Buffer,
                               CfInfoName.Length
                               );
            }
        }

        outputBuferLength = sizeof(GPC_ADD_CF_INFO_RES);
        break;

    case IOCTL_GPC_MODIFY_CF_INFO:

        ASSERT(OpCode == OP_MODIFY_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_MODIFY);

        GpcRes->ModifyRes.Status = Status;
        GpcRes->ModifyRes.ClientCtx = pClient->ClientCtx;
        GpcRes->ModifyRes.CfInfoCtx = pBlob->OwnerClientCtx;

        outputBuferLength = sizeof(GPC_MODIFY_CF_INFO_RES);
        break;

    case IOCTL_GPC_REMOVE_CF_INFO:

        ASSERT(OpCode == OP_REMOVE_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_REMOVE);

        GpcRes->RemoveRes.Status = Status;
        GpcRes->RemoveRes.ClientCtx = pClient->ClientCtx;
        GpcRes->RemoveRes.CfInfoCtx = pBlob->OwnerClientCtx;

        outputBuferLength = sizeof(GPC_REMOVE_CF_INFO_RES);
        break;
        
    default:
        ASSERT(0);
    }
        
    GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Information = outputBuferLength;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    DBGPRINT(IOCTL, ("UMCfInfoComplete: Completing IRP =0x%X, Status=0x%X\n",
                     (ULONG_PTR)pIrp, Status ));

    TRACE(IOCTL, pIrp, Status, "UMCfInfoComplete.Completing:");

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return;
}


NTSTATUS
CheckQueuedNotification(
	IN		PIRP	Irp,
    IN OUT  ULONG 	*outputBufferLength
    )
/*++

Routine Description:

	This routine will check for a queued notification structrue,
    and it will fill the ioBuffer in the IRP if one has been found
    and return STATUS_SUCCESS. This should cover the case where
    the IRP was not available when the notification was generated.
    O/w the routine returns STATUS_PENDING.

Arguments:

	Irp - the incoming IRP

Return Value:

    STATUS_SUCCESS or STATUS_PENDING

--*/

{
    KIRQL                 	oldIrql;
    PIO_STACK_LOCATION    	pIrpSp;
    PQUEUED_NOTIFY          pQItem = NULL;
    PLIST_ENTRY           	pEntry;
    NTSTATUS				Status;
    PPENDING_IRP			pPendingIrp;

    DBGPRINT(IOCTL, ("CheckQueuedNotification: IRP =0x%X\n",
                     (ULONG_PTR)Irp));

    TRACE(IOCTL, Irp, 0, "CheckQueuedNotification:");

    if (*outputBufferLength < sizeof(GPC_NOTIFY_REQUEST_RES)) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(Irp);

    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = QueuedNotificationList.Flink;
          pEntry != &QueuedNotificationList;
          pEntry = pEntry->Flink ) {

        pQItem = CONTAINING_RECORD( pEntry, QUEUED_NOTIFY, Linkage);

        if (pQItem->FileObject == pIrpSp->FileObject) {

            //
            // the queued item if for this file object
            //

            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pQItem = NULL;
        }
    }

    if (pQItem) {

        //
        // We found something on the queue, copy it to the IRP
        // and delete the item
        //

        DBGPRINT(IOCTL, ("CheckQueuedNotification: found QItem =0x%X\n",
                         (ULONG_PTR)pQItem));

        TRACE(IOCTL, 
              pQItem, 
              pQItem->NotifyRes.ClientCtx, 
              "CheckQueuedNotification.QItem:");

        ASSERT(*outputBufferLength >= sizeof(GPC_NOTIFY_REQUEST_RES));

        NdisMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                       &pQItem->NotifyRes,
                       sizeof(GPC_NOTIFY_REQUEST_RES) );

        GpcFreeToLL(pQItem, &QueuedNotificationLL, QueuedNotificationTag);

        *outputBufferLength = sizeof(GPC_NOTIFY_REQUEST_RES);

        Status = STATUS_SUCCESS;

    } else {

        DBGPRINT(IOCTL, ("CheckQueuedNotification: QItem not found...PENDING\n"
                         ));

        TRACE(IOCTL, 0, 0, "CheckQueuedNotification.NoQItem:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp != NULL) {

            //
            // add the IRP on the pending notification list
            //

            DBGPRINT(IOCTL, ("CheckQueuedNotification: adding IRP=0x%X to list=0x%X\n",
                             (ULONG_PTR)Irp, (ULONG_PTR)pIrpSp ));
            TRACE(IOCTL, Irp, pIrpSp, "CheckQueuedNotification.Irp:");

            pPendingIrp->Irp = Irp;
            pPendingIrp->FileObject = pIrpSp->FileObject;

            if (!Irp->Cancel) {
            
                IoSetCancelRoutine(Irp, CancelPendingIrpNotify);
                GpcInsertTailList(&PendingIrpNotifyList, &(pPendingIrp->Linkage));

                Status = STATUS_PENDING;

            } else {

                DBGPRINT(IOCTL, ("CheckQueuedNotification: Status Cacelled: IRP=0x%X\n",
                                 (ULONG_PTR)Irp ));

                TRACE(IOCTL, Irp, pIrpSp, "CheckQueuedNotification.Cancelled:");
                GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

                Status = STATUS_CANCELLED;
            }

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        *outputBufferLength = 0;
        
    }

    IoReleaseCancelSpinLock(oldIrql);

    return Status;
}



NTSTATUS
CheckQueuedCompletion(
	IN PQUEUED_COMPLETION	pQItem,
    IN PIRP              	Irp
    )
/*++

Routine Description:

	This routine will check for a queued completion structrue
    with the same CfInfoHandle, and it will return it if found.
    The original queued memory block is release here.
    If not found, the returned status is PENDING, o/w the queued status
    is returned.

Arguments:

	pQItem - pass in the CfInfoHandle and ClientHandle

Return Value:

    Queued status or STATUS_PENDING

--*/

{
    KIRQL                 	oldIrql;
    PLIST_ENTRY           	pEntry;
    NTSTATUS				Status;
    PPENDING_IRP			pPendingIrp = NULL;
    PIO_STACK_LOCATION		irpStack;

    DBGPRINT(IOCTL, ("CheckQueuedCompletion: pQItem=0x%X\n",
                     (ULONG_PTR)pQItem));

    TRACE(IOCTL, 
          pQItem->OpCode, 
          pQItem->ClientHandle, 
          "CheckQueuedCompletion:");
    TRACE(IOCTL, 
          pQItem->CfInfoHandle, 
          pQItem->Status, 
          "CheckQueuedCompletion:");

    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = QueuedCompletionList.Flink;
          pEntry != &QueuedCompletionList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if ((pQItem->OpCode == OP_ANY_CFINFO || 
             pQItem->OpCode == pPendingIrp->QComp.OpCode)
            &&
            pPendingIrp->QComp.ClientHandle == (PVOID)pQItem->ClientHandle
            &&
            pPendingIrp->QComp.CfInfoHandle == (PVOID)pQItem->CfInfoHandle) {

            //
            // the queued item if for this file object
            // and the OpCode match
            // and it has the same CfInfo memory pointer
            //
            
            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp) {

        //
        // get the status and free the queued completion item
        //

        DBGPRINT(IOCTL, ("CheckQueuedCompletion: found pPendingIrp=0x%X, Status=0x%X\n",
                         (ULONG_PTR)pPendingIrp, pPendingIrp->QComp.Status));


        TRACE(IOCTL, 
              pPendingIrp->QComp.OpCode, 
              pPendingIrp->QComp.ClientHandle, 
              "CheckQueuedCompletion.Q:");
        TRACE(IOCTL, 
              pPendingIrp->QComp.CfInfoHandle, 
              pPendingIrp->QComp.Status, 
              "CheckQueuedCompletion.Q:");

#if DBG
        if (pQItem->OpCode != OP_ANY_CFINFO) {

            ASSERT(pPendingIrp->QComp.OpCode == pQItem->OpCode);
            ASSERT(pPendingIrp->QComp.ClientHandle == pQItem->ClientHandle);
        }
#endif

        Status = pPendingIrp->QComp.Status;

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    } else {

        DBGPRINT(IOCTL, ("CheckQueuedCompletion: pPendingIrp not found...PENDING\n"
                         ));

        TRACE(IOCTL, 0, 0, "CheckQueuedCompletion.NopQ:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp != NULL) {

            //
            // add the IRP on the pending CfInfo list
            //

            irpStack = IoGetCurrentIrpStackLocation(Irp);

            DBGPRINT(IOCTL, ("CheckQueuedCompletion: adding IRP=0x%X\n",
                             (ULONG_PTR)Irp ));
            TRACE(IOCTL, Irp, irpStack, "CheckQueuedCompletion.Irp:");

            pPendingIrp->Irp = Irp;
            pPendingIrp->FileObject = irpStack->FileObject;
            pPendingIrp->QComp.OpCode = pQItem->OpCode;
            pPendingIrp->QComp.ClientHandle = pQItem->ClientHandle;
            pPendingIrp->QComp.CfInfoHandle = pQItem->CfInfoHandle;
            pPendingIrp->QComp.Status = pQItem->Status;

            if (!Irp->Cancel) {
            
                IoSetCancelRoutine(Irp, CancelPendingIrpCfInfo);
                GpcInsertTailList(&PendingIrpCfInfoList, &(pPendingIrp->Linkage));

                Status = STATUS_PENDING;

            } else {

                DBGPRINT(IOCTL, ("CheckQueuedCompletion: Status Cacelled: IRP=0x%X\n",
                                 (ULONG_PTR)Irp ));

                TRACE(IOCTL, Irp, irpStack, "CheckQueuedCompletion.Cancelled:");
                GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

                Status = STATUS_CANCELLED;
            }

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        
    }

    IoReleaseCancelSpinLock(oldIrql);

    return Status;
}



// Function : GpcValidateClientOwner
//
// Description:
//  Validates that the user mode calling an irp owns the client in 
//  question.
//
//Arguments:
//  GpcClientHandle: Object obtained from client handle.
//                            In effect pointer to CLIENT_BLOCK 
//
//Returns:
// Returns GPC_STATUS_SUCCESS if the given client is owned by the  file object
// Returns GPC_STATUS_INVALID_HANDLE otherwise
//
//Environment:
//  Called to validate client ownership of CLIENT_BLOCK from the 
//  proxyGpc* functions . No locks held
//
NTSTATUS
GpcValidateClientOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN PFILE_OBJECT pFile
    )
{    
    PCLIENT_BLOCK pClient;
    NTSTATUS Status = GPC_STATUS_SUCCESS;
    
    pClient = (PCLIENT_BLOCK) GpcClientHandle;
    NDIS_LOCK(&pClient->Lock);
    if  (pClient->pFileObject != pFile)
    {
        Status = GPC_STATUS_INVALID_HANDLE;
    }
    NDIS_UNLOCK(&pClient->Lock);

    return Status;
}



// Function : GpcValidatePatternOwner
//
// Description:
//  Validates that the user mode client owns the Pattern in 
//  question.
//
//Arguments:
//  GpcClientHandle: Object obtained from client handle.
//                            In effect pointer to CLIENT_BLOCK 
//  GpcPatternHandle: Object Obtained from Pattern Handle
//                              In effect pointer to the PATTERN_BLOCK
//Returns:
// Returns GPC_STATUS_SUCCESS if the specified client owns the
//               specified Pattern.
// Returns GPC_STATUS_ACCESS_DENIED otherwise
//
//Environment:
//  Called to validate client ownership of PATTERN_BLOCK from the 
//  proxyGpc* functions . 
//
NTSTATUS
GpcValidatePatternOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN GPC_HANDLE GpcPatternHandle
    )
{    
    PCLIENT_BLOCK pClient;
    PPATTERN_BLOCK pPattern;
    NTSTATUS Status = GPC_STATUS_SUCCESS;
    
    pClient = (PCLIENT_BLOCK) GpcClientHandle;
    pPattern = (PPATTERN_BLOCK)GpcPatternHandle;
    if   (pClient != pPattern->pClientBlock )
    {
        Status = GPC_STATUS_INVALID_HANDLE;
    }

    return Status;
}







// Function : GpcValidateCfinfoOwner
//
// Description:
//  Validates that the user mode client owns the BLOB in 
//  question.
//
//Arguments:
//  GpcClientHandle: Object obtained from client handle.
//                            In effect pointer to CLIENT_BLOCK 
//  GpcCfinfoHandle: Object Obtained from Pattern Handle
//                            In effect pointer to the PATTERN_BLOCK
//Returns:
// Returns GPC_STATUS_SUCCESS if the specified client owns the
//               specified Cfinfo - BLOB_BLOCK.
// Returns GPC_STATUS_ACCESS_DENIED otherwise
//
//Environment:
//  Called to validate client ownership of BLOB_BLOCK from the 
//  proxyGpc* functions . 
//
NTSTATUS
GpcValidateCfinfoOwner (
    IN GPC_HANDLE GpcClientHandle,
    IN GPC_HANDLE GpcCfInfoHandle
    )
{    
    PCLIENT_BLOCK pClient;
    PBLOB_BLOCK pBlob;
    NTSTATUS Status = GPC_STATUS_SUCCESS;
    
    pClient = (PCLIENT_BLOCK) GpcClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;
    if (pClient != pBlob->pOwnerClient)
    {
        Status = GPC_STATUS_INVALID_HANDLE;
     }
    return Status;
}

/* end ioctl.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\refcnt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Edward Buchwalter (v-edbuc)    15-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM) 16-April-1999
    Adapted for GPC.
    
--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 17
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    INT         Count;
    PVOID       Instance;
    VOID        (*DeleteHandler)( PVOID );
#if DBG    
    int         Sig;
    REF_TAG     Tags[TAG_CNT];
    CTELock     Lock;
#endif     
}
REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID ) 
);

VOID
ReferenceAdd
(
    IN 	PREF_CNT  pRefCnt
);

VOID
ReferenceAddCount
(
    IN 	PREF_CNT    pRefCnt,
	IN	UINT	    Count
);

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
);

VOID
ReferenceApiTest
( 
	VOID 
);

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceCheckForZeroRef(PREF_CNT pRefCnt, ULONG Tag);

#define REFADD(Rc, Tag)         ReferenceAddDbg(Rc, Tag)
#define REFDEL(Rc, Tag)         ReferenceRemoveDbg(Rc, Tag)
#define REFZEROCHECK(Rc, Tag)   ReferenceCheckForZeroRef(Rc, Tag)

#else

#define REFADD(Rc, Tag)  ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)  ReferenceRemove(Rc);
#define REFZEROCHECK(Rc, Tag)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\pathash.c ===
/*
 *  pathash.c
 *
 *  author:	John R. Douceur
 *  date:	5 May 1997
 *
 *  This source file provides functions that implement insertion, removal,
 *  search, scan, and flush operations on the pat-hash table database.  The
 *  code is object-oriented C, transliterated from a C++ implementation.
 *
 *  The pat-hash database is a combination of a dynamically sized, separately
 *  chained hash table and a Patricia tree.  The hash table dynamically grows
 *  and shrinks as needed, and the workload of modifying the table size is
 *  distributed evenly among the insertion or removal operations that cause
 *  the growth or shrinkage.
 *
 *  The insertion and removal operations manage both a hash table and a Patricia
 *  tree, but the search routine uses only the hash table for performing the
 *  search.  The Patrica tree is present to support a scan operation, which
 *  searches the database for all entries that match a given pattern, where the
 *  pattern that is scanned may contain wildcards.
 *
 *  None of the code or comments in this file needs to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, rhizome.h.
 *
 */

#include "gpcpre.h"

#define MAGIC_NUMBER 0x9e4155b9     // Fibonacci hash multiplier (see Knuth 6.4)

// This macro allocates a new pat-hash table entry structure.  The size of
// the structure is a function of the value of keybytes, since the entry stores
// a copy of the pattern.  The value array, which is the last field in the
// structure, is declared as having a single element, but this array will
// actually extend beyond the defined end of the structure into additional
// space that is allocated for it by the following macro.
//
//#define NEW_PHTableEntry \
//	((PHTableEntry *)malloc(sizeof(PHTableEntry) + phtable->keybytes - 1))
#define NEW_PHTableEntry(_pe) \
	GpcAllocMem(&_pe,\
                sizeof(PHTableEntry) + phtable->keybytes - 1,\
                PathHashTag)

// This macro allocates a new pat-hash table group structure.  The size of
// the structure is a function of the size of the group.  The entry_list array,
// which is the last field in the structure, is declared as having a single
// element, but this array will actually extend beyond the defined end of the
// structure into additional space that is allocated for it by the following
// macro.
//
//#define NEW_PHTableGroup(group_size) \
//	((PHTableGroup *)malloc(sizeof(PHTableGroup) + \
//	((group_size) - 1) * sizeof(PHTableEntry *)))
#define NEW_PHTableGroup(group_size, _pg) \
	GpcAllocMem(&_pg,\
                sizeof(PHTableGroup) + \
                ((group_size) - 1) * sizeof(PHTableEntry *),\
                PathHashTag)

// This macro gets the indexed bit of the value, where the most-significant bit
// is defined as bit 0.
//
#define BIT_OF(value, index) \
	(((value)[(index) >> 3] >> (7 - ((index) & 0x7))) & 0x1)

// Following is a prototype for a static function that is used internally by
// the implementation of the pat-hash routines.

void
node_scan(
	PatHashTable *phtable,
	PHTableEntry *node,
	int prev_bit,
	char *value,
	char *mask,
	void *context,
	ScanCallback func);

// Since this is not C++, the PatHashTable structure is not self-constructing;
// therefore, the following constructor code must be called on the PatHashTable
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.  The usage
// ratio is the target ratio of database entries to discrete hash chains, which
// is also the mean length of a hash chain.  The usage histeresis is the
// histeresis between resizing operations due to insertions and removals.
// Allocation histeresis is the histeresis between allocation and deallocation
// of groups, specified as a binary exponent.  The maximum free list size
// determines the maximum number of elements that will be placed on a free
// list, rather than deallocated, when they are removed.
//
int
constructPatHashTable(
	PatHashTable *phtable,
	int keybits,
	int usage_ratio,
	int usage_histeresis,
	int allocation_histeresis,
	int max_free_list_size)
{
	PHTableGroup *group;
	phtable->keybits = keybits;
	phtable->keybytes = (keybits - 1) / 8 + 1;
	phtable->usage_ratio = usage_ratio;
	phtable->usage_histeresis = usage_histeresis;
	phtable->allocation_histeresis = allocation_histeresis;
	phtable->max_free_list_size = max_free_list_size;
	NEW_PHTableGroup(1, phtable->initial_group);
	phtable->top_group = phtable->initial_group;
	phtable->allocation_exponent = 0;
	phtable->size_exponent = 0;
	phtable->extension_size = 0;
	phtable->population = 0;
	phtable->root = 0;
	phtable->free_list = 0;
	phtable->free_list_size = 0;
	NEW_PHTableGroup(1, group);
	if (phtable->initial_group == 0 || group == 0)
	{
		// Memory could not be allocated for one of the two groups created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
        
        // 286334 : Not so fast! Please free memory before leaving...
        if (phtable->initial_group != 0) {
            GpcFreeMem(phtable->initial_group, PatHashTag);
        }

        if (group != 0) {
            GpcFreeMem(group, PatHashTag);
        }

		return 1;
	}
	group->previous = 0;
	group->entry_list[0] = 0;
	phtable->initial_group->previous = group;
	return 0;
}

// Since this is not C++, the PatHashTable structure is not self-destructing;
// therefore, the following destructor code must be called on the PatHashTable
// structure before it is deallocated.
//
void
destructPatHashTable(
	PatHashTable *phtable)
{
	PHTableGroup *group, *previous;
	PHTableEntry *entry, *next;
	int index, size;
	// First, free all groups that are allocated but not currently used.
	group = phtable->top_group;
	while (group != phtable->initial_group)
	{
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
	}
	// Then, free the entries in the initial group.  Since not all fields
	// in the initial group's table may be valid, only check those whose
	// indices are less than the extension size.
	for (index = phtable->extension_size - 1; index >= 0; index--)
	{
		entry = group->entry_list[index];
		while (entry != 0)
		{
			next = entry->next;
			GpcFreeMem(entry, PatHashTag);
			entry = next;
		}
	}
	// Then free the initial group.
	previous = group->previous;
	GpcFreeMem(group, PatHashTag);
	group = previous;
	// Scan through all remaining groups except the last one, freeing all
	// entries in each group, and thereafter freeing the group.
	size = 1 << (phtable->size_exponent - 1);
	while (group->previous != 0)
	{
		for (index = size - 1; index >= 0; index--)
		{
			entry = group->entry_list[index];
			while (entry != 0)
			{
				next = entry->next;
				GpcFreeMem(entry, PatHashTag);
				entry = next;
			}
		}
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
		size >>= 1;
	}
	// The last group is special, since it has a size of one, but the logic
	// used in the preceding loop would have calculated its size as zero.
	// Rather than complicating the previous loop with a check for a single
	// special case, we simply free the last group and its entries in the
	// following code.
	entry = group->entry_list[0];
	while (entry != 0)
	{
		next = entry->next;
		GpcFreeMem(entry, PatHashTag);
		entry = next;
	}
	GpcFreeMem(group, PatHashTag);
	// Finally, free all of the entries in the free list.
	while (phtable->free_list != 0)
	{
		next = phtable->free_list->next;
		GpcFreeMem(phtable->free_list, PatHashTag);
		phtable->free_list = next;
	}
}

// This function inserts a new specific pattern into the database, passed as
// an array of bytes.  The client supplies a digested form of the pattern as
// the chyme argument.
//
// The client specifies a void pointer reference value to associate with the
// specific pattern.  When the specific pattern is installed, the insert
// routine returns a pointer to a SpecificPatternHandle.
//
// If the submitted pattern has already been installed in the database, then
// the insertion does not occur, and the SpecificPatternHandle of the
// previously installed pattern is returned.
//
// The insertion routine inserts the new pattern into both the hash table and
// the Patricia tree, and the two insertions are almost completely independent
// except for the shared entry structure.
//
SpecificPatternHandle
insertPatHashTable(
	PatHashTable *phtable,
	char *pattern,
	unsigned int chyme,
	void *reference)
{
	unsigned int hash, address, small_address, split_point;
	PHTableGroup *group;
	PHTableEntry **entry, *new_entry;
	char *value;
	int index, group_size, pivot_bit, bit_value;
	// The first portion of this routine inserts the new pattern into the hash
	// table.  To begin, we determine whether the number of hash chains needs
	// to be increased in order to maintain the desired usage ratio.
	group_size = 1 << phtable->size_exponent;
	if (phtable->population >=
		(group_size + phtable->extension_size) * phtable->usage_ratio)
	{
		// The number of hash chains needs to be increased.  So, determine
		// whether the initial group is completely full.
		if (phtable->extension_size == group_size)
		{
			// The initial group is completely full.  So, determine whether
			// all allocated groups are currently in use.
			if (phtable->allocation_exponent == phtable->size_exponent)
			{
				// All allocated groups are currently in use.  So, allocate
				// a new group and set its previous pointer to point to the
				// initial group.  Update the allocation values of the structure
				// to reflect the new allocation.
				NEW_PHTableGroup(group_size << 1, group);
				if (group == 0)
				{
					// Memory could not be allocated for the new group.
					// Therefore, we return an indication of falure to the
					// client.
					return 0;
				}
				group->previous = phtable->initial_group;
				phtable->top_group = group;
				phtable->allocation_exponent++;
			}
			else
			{
				// Not all allocated groups are in use.  So, scanning backward
				// from the top group, find the group that immediately follows
				// the initial group.
				group = phtable->top_group;
				while (group->previous != phtable->initial_group)
				{
					group = group->previous;
				}
			}
			// We now have either a newly allocated group or a previously
			// allocated group that immediately follows the initial group.
			// Set this group to be the new initial group, and set the extension
			// size to zero.
			phtable->initial_group = group;
			phtable->size_exponent++;
			phtable->extension_size = 0;
		}
		else
		{
			// The initial group is not completely full.  So, select the initial
			// group.
			group = phtable->initial_group;
		}
		// We now have a group that is not completely full, either because it
		// wasn't completely full when the insert routine was entered, or
		// because it has just been allocated.  In either case, we now split
		// a hash chain from a smaller group into two hash chains, one of which
		// will be placed into an unused entry in the new group.  The address
		// of the hash chain to be split is determined by the extension size.
		// First we find the group that contains this address.
		group = group->previous;
		address = phtable->extension_size;
		while ((address & 0x1) == 0 && group->previous != 0)
		{
			address >>= 1;
			group = group->previous;
		}
		// Then, we scan through the entry list at the given address for the
		// appropriate split point.  The entries are stored in sorted order,
		// and we are essentially shifting one more bit into the address for
		// this value, so the split point can be found by searching for the
		// first entry with the bit set.
		address >>= 1;
		entry = &group->entry_list[address];
		split_point = ((phtable->extension_size << 1) | 0x1)
			<< (31 - phtable->size_exponent);
		while (*entry != 0 && (*entry)->hash < split_point)
		{
 			entry = &(*entry)->next;
		}
		// Now that we have found the split point, we move the split-off
		// piece of the list to the new address, and increment the extension
		// size.
		phtable->initial_group->entry_list[phtable->extension_size] = *entry;
		*entry = 0;
		phtable->extension_size++;
	}
	// Now that the memory management aspects of the hash table insertion have
	// been taken care of, we can perform the actual insertion.  First, we find
	// the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = MAGIC_NUMBER * chyme;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the first
	// entry whose hash value is equal to or greater than the hash of the search
	// key.  The entries are stored in sorted order to improve the search speed.
	address >>= 1;
	entry = &group->entry_list[address];
	while (*entry != 0 && (*entry)->hash < hash)
	{
		entry = &(*entry)->next;
	}
	// Now, we check all entries whose hash value matches that of the search
	// key.
	while (*entry != 0 && (*entry)->hash == hash)
	{
		// For each value whose hash matches, check the actual value to see
		// if it matches the search key.
		value = (*entry)->value;
		for (index = phtable->keybytes-1; index >= 0; index--)
		{
			if (value[index] != pattern[index])
			{
				break;
			}
		}
		if (index < 0)
		{
			// A match is found, so we return the SpecificPatternHandle of the
			// matching entry to the client.
			return *entry;
		}
		entry = &(*entry)->next;
	}
	// A match was not found, so we insert the new entry into the hash chain.
	// First we check to see if there is an entry avalable on the free list.
	if (phtable->free_list != 0)
	{
		// There is an entry available on the free list, so grab it and
		// decrement the size of the free list.
		new_entry = phtable->free_list;
		phtable->free_list = phtable->free_list->next;
		phtable->free_list_size--;
	}
	else
	{
		// There is no entry available on the free list, so allocate a new one.
		NEW_PHTableEntry(new_entry);
		if (new_entry == 0)
		{
			// Memory could not be allocated for the new entry.  Therefore,
			// we return an indication of falure to the client.
			return 0;
		}
	}
	// Set the fields of the new entry to the appropriate information and add
	// the entry to the hash chain.
	new_entry->hash = hash;
	new_entry->reference = reference;
	new_entry->next = *entry;
	for (index = phtable->keybytes - 1; index >= 0; index--)
	{
		new_entry->value[index] = pattern[index];
	}
	*entry = new_entry;
	// The hash table insertion is now complete.  Here we begin the insertion
	// of the new entry into the Patricia tree.  We have to treat an empty
	// tree as a special case.
	if (phtable->root == 0)
	{
		// The Patricia tree is empty, so we set the root to point to the new
		// entry.  This entry is special, since it serves only as a leaf of
		// the Patricia search and not also as a branch node.  A Patricia tree
		// always contains one fewer branch node than the number of leaves.
		// Since a leaf is determined by a pivot bit that is less than or equal
		// to the pivot bit of the parent branch node, a pivot bit of -1 flags
		// this node as always a leaf.
		new_entry->pivot_bit = -1;
		new_entry->children[0] = 0;
		new_entry->children[1] = 0;
		phtable->root = new_entry;
	}
	else
	{
		// The Patricia tree is not empty, so we proceed with the normal
		// insertion process.  Beginning at the root, scan through the tree
		// according to the bits of the new pattern, until we reach a leaf.
		entry = &phtable->root;
		index = -1;
		while ((*entry)->pivot_bit > index)
		{
			index = (*entry)->pivot_bit;
			entry = &(*entry)->children[BIT_OF(pattern, index)];
		}
		// Now, compare the new pattern, bit by bit, to the pattern stored at
		// the leaf, until a non-matching bit is found.  There is no need to
		// check for an exact match, since the hash insert above would have
		// aborted if an exact match had been found.
		value = (*entry)->value;
		pivot_bit = 0;
		while (BIT_OF(value, pivot_bit) == BIT_OF(pattern, pivot_bit))
		{
			pivot_bit++;
		}
		// Now, scan a second time through the tree, until finding either a leaf
		// or a branch with a pivot bit greater than the bit of the non-match.
		entry = &phtable->root;
		index = -1;
		while ((*entry)->pivot_bit > index && (*entry)->pivot_bit < pivot_bit)
		{
			index = (*entry)->pivot_bit;
			entry = &(*entry)->children[BIT_OF(pattern, index)];
		}
		// This is the point at which the new branch must be inserted.  Since
		// each node is both a branch and a leaf, the new entry serves as the
		// new branch, and one of its children points to itself as a leaf.  The
		// other child points to the remaining subtree below the insertion
		// point.
		bit_value = BIT_OF(value, pivot_bit);
		new_entry->pivot_bit = pivot_bit;
		new_entry->children[1 - bit_value] = new_entry;
		new_entry->children[bit_value] = *entry;
		*entry = new_entry;
	}
	// Having inserted the new entry in both the hash table and the Patricia
	// tree, we increment the population and return the SpecificPatternHandle
	// of the new entry.
	phtable->population++;
	return new_entry;
}

// This function removes a pattern from the pat-hash table.  The pattern is
// specified by the SpecificPatternHandle that was returned by the insert
// routine.  No checks are performed to insure that this is a valid handle.
//
// The removal routine removes the pattern from both the hash table and the
// Patricia tree, and the two removals are almost completely independent
// except for the shared entry structure.
//
void
removePatHashTable(
	PatHashTable *phtable,
	SpecificPatternHandle sphandle)
{
	unsigned int hash, address, small_address;
	PHTableGroup *group;
	PHTableEntry **entry, **branch, **parent, *epoint, *bpoint;
	char *value;
	int index, group_size;
	// The first portion of this routine removess the new pattern from the hash
	// table.  First, we find the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = sphandle->hash;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the entry
	// that matches the given SpecificPatternHandle.
	address >>= 1;
	entry = &group->entry_list[address];
	while (*entry != sphandle)
	{
		entry = &(*entry)->next;
	}
	// We then remove the entry from the hash chain and decrement the
	// population.
	*entry = sphandle->next;
	phtable->population--;
	// This completes the actual removal of the entry from the hash table, but
	// we now have to determine whether to reduce the number of hash chains in
	// order to maintain the desired usage ratio.  Note that the usage
	// histeresis is factored into the calculation.
	group_size = 1 << phtable->size_exponent;
	if (phtable->population + phtable->usage_histeresis <
		(group_size + phtable->extension_size - 1) * phtable->usage_ratio)
	{
		// The number of hash chains needs to be reduced.  So, we coalesce two
		// hash chains into a single hash chain.  The address of the hash chains
		// is determined by the extension size.  First we decrement the
		// extension size and find the group that contains the address of the
		// hash chain that is being retained.
		phtable->extension_size--;
		group = phtable->initial_group->previous;
		address = phtable->extension_size;
		while ((address & 0x1) == 0 && group->previous != 0)
		{
			address >>= 1;
			group = group->previous;
		}
		// Then, we find the end of the entry list at the given address.
		address >>= 1;
		entry = &group->entry_list[address];
		while (*entry != 0)
		{
 			entry = &(*entry)->next;
		}
		// We then make the last entry in the hash chain point to the first
		// entry in the other hash chain that is being coalesced.  We do not
		// need to update the group's pointer to the other hash chain, since
		// it is now beyond the extension size, and it will thus never be seen.
		*entry = phtable->initial_group->entry_list[phtable->extension_size];
		// Now, we check to see whether a group has been completely emptied.
		// We also check the size exponent, since even if we have just emptied
		// the first non-special group, we do not remove it.
		if (phtable->extension_size == 0  && phtable->size_exponent > 0)
		{
			// The initial group has just been completely emptied, so we set
			// the previous group as the new initial group.  Update all
			// housekeeping information accordingly.
			phtable->size_exponent--;
			phtable->extension_size = group_size >> 1;
			phtable->initial_group = phtable->initial_group->previous;
			// We now determine whether we should deallocate a group.  Note
			// that the allocation histeresis is factored into the calculation.
			if (phtable->size_exponent + phtable->allocation_histeresis <
				phtable->allocation_exponent)
			{
				// We should deallocate a group, so we deallocate the top group.
				phtable->allocation_exponent--;
				group = phtable->top_group->previous;
				GpcFreeMem(phtable->top_group, PatHashTag);
				phtable->top_group = group;
			}
		}
	}
	// Now, the hash table removal operation is complete, including the memory
	// management functions.  Here we begin the removal of the entry from the
	// Patricia tree.  First, we scan through the tree according to the bits of
	// the pattern being removed, until we reach a leaf.  We keep track of the
	// branch that immediately precedes the leaf, and we also note the parent
	// of the pattern, in the latter's capacity as a branch node.
	value = sphandle->value;
	entry = &phtable->root;
	branch = entry;
	parent = 0;
	index = -1;
	while ((*entry)->pivot_bit > index)
	{
		if ((*entry) == sphandle)
		{
			parent = entry;
		}
		branch = entry;
		index = (*entry)->pivot_bit;
		entry = &(*entry)->children[BIT_OF(value, index)];
	}
	// We set the branch that points to the leaf to instead point to the child
	// of the leaf that is not selected by the bit of the removed pattern, thus
	// removing the branch from the tree.
	epoint = *entry;
	bpoint = *branch;
	*branch = bpoint->children[1 - BIT_OF(value, index)];
	// If the branch that was removed is also the leaf that contains the
	// pattern, then the removal from the Patricia tree is complete.  Otherwise,
	// we replace the leaf that is being removed with the branch that is not
	// being removed.
	if (epoint != bpoint)
	{
		bpoint->pivot_bit = epoint->pivot_bit;
		bpoint->children[0] = epoint->children[0];
		bpoint->children[1] = epoint->children[1];
		// In the case of the special node that is not a branch node, we do
		// not update its parent to point to the replacing branch, since this
		// node has no parent.
		if (parent != 0)
		{
			*parent = bpoint;
		}
	}
	// The removal from the Patricia tree is now complete.  If appropriate, we
	// place the removed entry onto the free list.  If not, we simply free it.
	if (phtable->free_list_size < phtable->max_free_list_size)
	{
		sphandle->next = phtable->free_list;
		phtable->free_list = sphandle;
		phtable->free_list_size++;
	}
	else
	{
		GpcFreeMem(sphandle, PatHashTag);
	}
}

// This function searches the database for the specific pattern that matches
// the given key, which is passed as an array of bytes.  The client supplies
// a digested form of the pattern as the chyme argument.  If a match is found,
// the SpecificPatternHandle of that matching specific pattern is returned.
// If no match is found, then a value of 0 is returned.
//
// This search uses only the hash table; the Patricia tree is not used at all.
//
SpecificPatternHandle
searchPatHashTable(
	PatHashTable *phtable,
	char *key,
	unsigned int chyme)
{
	unsigned int hash, address, small_address;
	PHTableGroup *group;
	PHTableEntry *entry;
	char *value;
	int index;
	// First, we find the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = MAGIC_NUMBER * chyme;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the first
	// entry whose hash value is equal to or greater than the hash of the search
	// key.  The entries are stored in sorted order to improve the search speed.
	address >>= 1;
	entry = group->entry_list[address];
	while (entry != 0 && entry->hash < hash)
	{
		entry = entry->next;
	}
	// Now, we check all entries whose hash value matches that of the search
	// key.
	while (entry != 0 && entry->hash == hash)
	{
		// For each value whose hash matches, check the actual value to see
		// if it matches the search key.
		value = entry->value;
		for (index = phtable->keybytes-1; index >= 0; index--)
		{
			if (value[index] != key[index])
			{
				break;
			}
		}
		if (index < 0)
		{
			// A match is found, so we return the SpecificPatternHandle of the
			// matching entry to the client.
			return entry;
		}
		entry = entry->next;
	}
	// A match was not found, so we return a null pointer to the client.
	return 0;
}

// This function searches the database for all specific patterns that match a
// given general pattern.  The general pattern is specified by a value and a
// mask.  For each specific pattern in the database that matches the supplied
// general pattern, a client-supplied callback function is called with the
// SpecificPatternHandle of the matching specific pattern.  This callback
// function is also passed a context (as a void pointer) that is supplied by
// the client in the call to the scan routine.
//
// This scan uses only the Patricia tree; the hash table is not used at all.
//
void
scanPatHashTable(
	PatHashTable *phtable,
	char *value,
	char *mask,
	void *context,
	ScanCallback func)
{
	// Call the recursive node_scan routine, starting at the root of the
	// Patricia tree.
	if (phtable->root != 0)
	{
		node_scan(phtable, phtable->root, -1, value, mask, context, func);
	}
}

// This function recursively scans the Patricia tree for all specific patterns
// that match a given general pattern.
void
node_scan(
	PatHashTable *phtable,
	PHTableEntry *node,
	int prev_bit,
	char *value,
	char *mask,
	void *context,
	ScanCallback func)
{
	int mask_bit, index;
	// Partial recursion removal.  The while loop takes the place of one of the
	// recursive calls to node_scan().  We remain in the while loop while we
	// are still examining branch nodes.
	while (node->pivot_bit > prev_bit)
	{
		// For each branch node, determine which way(s) to branch based upon
		// the bit of the general pattern.  If the mask bit is a zero, then
		// branch both ways, requiring a recursive call.  If the mask bit is
		// a one, then branch in the direction indicated by the value bit.
		mask_bit = BIT_OF(mask, node->pivot_bit);
		if (mask_bit == 0)
		{
			// The general pattern has a wildcard for this node's pivot bit,
			// so we must branch both ways.  We branch on child one through
			// an actual recursive call.
			node_scan(phtable, node->children[1], node->pivot_bit,
				value, mask, context, func);
		}
		// We then branch either to the child selected by the value bit (if
		// the mask bit is one) or to child zero (if the mask bit is zero).
		prev_bit = node->pivot_bit;
		node = node->children[BIT_OF(value, node->pivot_bit) & mask_bit];
	}
	// We have reached a leaf node.  Examine its specific pattern to see if
	// it matches the given general pattern.  If it doesn't match, then just
	// return; otherwise, call the client's callback function.
	for (index = phtable->keybytes-1; index >= 0; index--)
	{
		if ((mask[index] & value[index]) !=
			(mask[index] & node->value[index]))
		{
			return;
		}
	}
	func(context, node);
}

// This function forces the pat-hash table to release all of the memory that
// it currently can, by deallocating all unneeded groups and entries.
//
void
flushPatHashTable(
	PatHashTable *phtable)
{
	PHTableGroup *group, *previous;
	PHTableEntry *entry, *next;
	// First, free all groups that are allocated but not currently used.
	group = phtable->top_group;
	while (group != phtable->initial_group)
	{
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
	}
	phtable->top_group = phtable->initial_group;
	phtable->allocation_exponent = phtable->size_exponent;
	// Then, free all of the entries in the free list.
	entry = phtable->free_list;
	while (entry != 0)
	{
		next = entry->next;
		GpcFreeMem(entry, PatHashTag);
		entry = next;
	}
	phtable->free_list = 0;
	phtable->free_list_size = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\pathash.h ===
/*
 *  pathash.h
 *
 *  author:	John R. Douceur
 *  date:	5 May 1997
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the pat-hash table database.  The code is object-oriented C, transliterated
 *  from a C++ implementation.
 *
 *  The pat-hash database is a combination of a dynamically sized, separately
 *  chained hash table and a Patricia tree.  The hash table dynamically grows
 *  and shrinks as needed, and the workload of modifying the table size is
 *  distributed evenly among the insertion or removal operations that cause
 *  the growth or shrinkage.
 *
 *  The insertion and removal operations manage both a hash table and a Patricia
 *  tree, but the search routine uses only the hash table for performing the
 *  search.  The Patrica tree is present to support a scan operation, which
 *  searches the database for all entries that match a given pattern, where the
 *  pattern that is scanned may contain wildcards.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the pat-hash table.
 *
 */

#ifndef _INC_PATHASH

#define _INC_PATHASH

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are three basic structures employed: the PHTableEntry, the
 *  PHTableGroup, and the PatHashTable.  Ideally, these would be completely
 *  hidden from the client, but the macro GetReferenceFromSpecificPatternHandle
 *  requires knowledge of the structure's definition.  It is strongly urged
 *  that the client not directly refer to any of the fields of either of these
 *  structures.  To support the documentation of the accompanying pathash.c
 *  file, these structures are annotated with internal comments, but these can
 *  be ignored by the reader who wishes only to understand how to write client
 *  code for the pat-hash table.
 *
 *  The values stored in the pat-hash table are known as specific patterns,
 *  where the term "specific" implies that the patterns do not contain
 *  wildcards.  The client refers to a pattern by its SpecificPatternHandle.
 *  This is typedefed to a pointer to PHTableEntry, but this fact should be
 *  ignored by the client, since it is an implementation detail.
 *
 */

    //#include <stdlib.h>
    //#include <malloc.h>

struct _PHTableEntry
{
	// This is the element in which a specific pattern is stored.  It is both
	// a component of a hash chain (linked list) that is indexed by a hash
	// table and also a component of a Patricia tree.

	// hash table fields:
	unsigned int hash;                                             // hash value
	struct _PHTableEntry *next;          // pointer to next entry in linked list

	// Patricia tree fields
	int pivot_bit;                              // bit of key on which to branch
	struct _PHTableEntry *children[2];                // pointers to child nodes

	// general:
	void *reference;                       // reference value supplied by client
	char value[1];                            // space for storing pattern value
};

typedef struct _PHTableEntry PHTableEntry;

struct _PHTableGroup
{
	// The hash table that indexes the hash chain of entries is itself a
	// linked list of structures called groups.  Each group is a table of
	// pointers to the hash chains of entries, and the group also contains
	// a pointer to the previous group, meaning that the groups are backwardly
	// linked.  The groups are sized in powers of two, so, in addition to one
	// special group of size one, there is a group of size one, a group of size
	// two, a group of size four, a group of size eight, and so on, up to the
	// number of groups necessary to hold the table.

	struct _PHTableGroup *previous;      // pointer to immediately smaller group
	PHTableEntry *entry_list[1];        // space to hold table of chain pointers
};

typedef struct _PHTableGroup PHTableGroup;

struct _PatHashTable
{
	int keybits;                                        // number of bits in key
	int keybytes;             // number of bytes in key, calculated from keybits
	int usage_ratio;                  // desired ratio of entries to hash chains
	int usage_histeresis;    // histeresis between insertion and removal resizes
	int allocation_histeresis;  // histeresis between insert and removal mallocs
	int max_free_list_size;                   // maximum size of free entry list
	PHTableGroup *initial_group;             // pointer to first group to search
	PHTableGroup *top_group;               // pointer to largest group allocated
	int allocation_exponent;       // binary exponent of current allocation size
	int size_exponent;                  // binary exponent of current group size
	int extension_size;               // number of slots in use in initial group
	int population;                             // number of entries in database
	PHTableEntry *root;                                 // root of Patricia tree
	PHTableEntry *free_list;                    // list of free (unused) entries
	int free_list_size;             // number of elements currently on free list
};

typedef struct _PatHashTable PatHashTable;

// The client uses SpecificPatternHandle to refer to values in the database.
typedef PHTableEntry *SpecificPatternHandle;

/*
 *  The client interface to the pat-hash table is provided by seven functions
 *  and two macros.  It is expected that the client will first instantiate a
 *  database, either on the stack or the heap, and then insert specific patterns
 *  with corresponding reference information into the database.  The client can
 *  then search the database for the specific patterns that were stored, and
 *  it can scan the database for all specific patterns that match a general
 *  pattern containing wildcards.
 *
 */

// A pat-hash table may be allocated on the stack simply by declaring a variable
// of type PatHashTable.  To allocate it on the heap, the following macro
// returns a pointer to a new PatHashTable structure.  If this macro is used, a
// corresponding call to free() must be made to deallocate the structure from
// the heap.
//
//#define NEW_PatHashTable ((PatHashTable *)malloc(sizeof(PatHashTable)))

#define AllocatePatHashTable(_ph)    GpcAllocMem(&_ph, \
                                                 sizeof(PatHashTable), \
                                                 PathHashTag)
#define FreePatHashTable(_ph)        GpcFreeMem(_ph,PathHashTag)

// Since this is not C++, the PatHashTable structure is not self-constructing;
// therefore, the following constructor code must be called on the PatHashTable
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.  The remaining
// arguments are parameters to the various control systems that govern the size
// of the database.
//
// The usage ratio is the target ratio of database entries to discrete hash
// chains, which is also the mean length of a hash chain:  The minimum value
// is one; a larger value slightly decreases memory utilization and
// insertion/removal time at the expense of increasing search time.  There is
// benefit to choosing a power of two for this value.  Recommended values are
// 2 and 4.
//
// The usage histeresis is the histeresis between resizing operations due to
// insertions and removals.  The minimum value is zero, providing no histeresis;
// in this case, if an insertion that causes a increase in table size is
// immediately followed by a removal, the table size will be decreased.  Thus,
// a zero histeresis maintains low memory usage, but it engenders resizing
// chatter if insertions and removals are frequent.
//
// Allocation histeresis is the histeresis between allocation and deallocation
// of groups.  A group is allocated immediately when it is required by a size
// increase in the table, but it is not necessarily deallocated immediately
// following a size decrease, if the allocation histeresis is set to a value
// greater than zero.  Because groups are allocated in powers of two, the
// histeresis value is specified as a binary exponent.  A value of 1 causes a
// group to be deallocated when the table is half of the size that will cause
// the group to be re-allocated.  A value of 2 causes the group to be
// deallocated when the table is one quarter of the size that will cause the
// group to be re-allocated, and so forth.
//
// The maximum free list size determines the maximum number of elements that
// will be placed on a free list, rather than deallocated, when they are
// removed.  Setting this value to zero keeps memory utilization low, but it
// can result in more frequent allocations and deallocation operations, which
// are expensive.
//
int
constructPatHashTable(
	PatHashTable *phtable,
	int keybits,
	int usage_ratio,
	int usage_histeresis,
	int allocation_histeresis,
	int max_free_list_size);

// Since this is not C++, the PatHashTable structure is not self-destructing;
// therefore, the following destructor code must be called on the PatHashTable
// structure before it is deallocated.
//
void
destructPatHashTable(
	PatHashTable *phtable);

// Once the PatHashTable structure has been allocated and constructed, patterns
// can be inserted into the database.  Each pattern is passed as an array of
// bytes.
//
// Since the PatHashTable structure specifies the size of each pattern, it is
// theoretically possible for the insert routine to digest the submitted
// pattern and produce a hash value therefrom; however, general mechanisms for
// accomplishing this digestion are not very efficient.  Therefore, the client
// is responsible for providing a digested form of its input as the chyme
// parameter.  If the pattern is no bigger than an unsigned int, then the chyme
// can simply be equal to the pattern.  If it is larger, then it should be set
// to something like the exclusive-or of the pattern's fields; however, care
// should be taken to ensure that two patterns are not likely to digest to the
// same chyme value, since this will substantially decrease the efficiency of
// the hash table.  One common way of accomplishing this is by rotating the
// fields by varying amounts prior to the exclusive-or.
//
// The client also specifies a reference value, as a void pointer, that it
// wishes to associate with this pattern.  When the pattern is installed, the
// insert routine returns a pointer to a SpecificPatternHandle.  From the
// SpecificPatternHandle can be gotten the reference value via the macro
// GetReferenceFromSpecificPatternHandle.
//
// If the submitted pattern has already been installed in the database, then
// the insertion does not occur, and the SpecificPatternHandle of the
// previously installed pattern is returned.
//
SpecificPatternHandle
insertPatHashTable(
	PatHashTable *phtable,
	char *pattern,
	unsigned int chyme,
	void *reference);

// This function removes a pattern from the pat-hash table.  The pattern is
// specified by the SpecificPatternHandle that was returned by the insert
// routine.  No checks are performed to insure that this is a valid handle.
//
void
removePatHashTable(
	PatHashTable *phtable,
	SpecificPatternHandle sphandle);

// This function searches the database for the specific pattern that matches
// the given key, which is passed as an array of bytes.  If a match is found,
// the SpecificPatternHandle of that matching specific pattern is returned.
// From the SpecificPatternHandle can be gotten the reference value via the
// macro GetReferenceFromSpecificPatternHandle.  If no match is found, then a
// value of 0 is returned as the SpecificPatternHandle.
//
// As with the insert routine, the client is expected to provide a digested
// form of the key as the chyme argument to the routine.  This chyme value
// must be calculated in the exact same way for the search routine as it is
// for the insert routine; otherwise, the search will not be able to find the
// matching pattern.
//
SpecificPatternHandle
searchPatHashTable(
	PatHashTable *phtable,
	char *key,
	unsigned int chyme);

// The scan routine (described below) requires the client to supply a callback
// function to be called for each specific pattern that matches the supplied
// general pattern.  The following typedef defines the ScanCallback function
// pointer, which specifies the prototype of the callback function that the
// client must provide.  The client's callback function must accept a void
// pointer (which is a client-supplied context) and a SpecificPatternHandle.
// The return type of the client's callback function is void.
//
typedef void (*ScanCallback)(void *, SpecificPatternHandle);

// This function searches the database for all specific patterns that match a
// given general pattern.  The general pattern is specified by a value and a
// mask.  Each bit of the mask determines whether the bit position is specified
// or is a wildcard:  A 1 in a mask bit indicates that the value of that bit is
// specified by the general pattern; a 0 indicates that the value of that bit
// is a wildcard.  If a mask bit is 1, then the corresponding bit in the value
// field indicates the specified value of that bit.  Value and mask fields are
// passed as arrays of bytes.
//
// For each specific pattern in the database that matches the supplied general
// pattern, a client-supplied callback function is called with the
// SpecificPatternHandle of the matching specific pattern.  This callback
// function is also passed a context (as a void pointer) that is supplied by
// the client in the call to the scan routine.
//
void
scanPatHashTable(
	PatHashTable *phtable,
	char *value,
	char *mask,
	void *context,
	ScanCallback func);

// To get the client-supplied reference value from a SpecificPatternHandle, the
// following macro should be used.  The client should not make assumptions
// about the details of the PHTableEntry structure, nor should it even assume
// that the SpecificPatternHandle is a pointer to a PHTableEntry.
// Also, get the key pointer (value)
//
#define GetReferenceFromSpecificPatternHandle(sphandle) (sphandle)->reference
#define GetKeyPtrFromSpecificPatternHandle(sphandle) (sphandle)->value

// As described above in the comments on the constructor, if the allocation
// histeresis is non-zero, then the groups will not be deallocated as soon as
// they can be.  Similarly, if max free list size is non-zero, then entries
// will not be deallocated as soon as they can be.  Thus, unused pieces of
// memory may accumulate, up to a limit.  If the client wishes to force the
// pat-hash table to release all of the memory that it currently can, then it
// should call the flush routine, which will deallocate all unneeded groups
// and entries.
//
void
flushPatHashTable(
	PatHashTable *phtable);

#ifdef __cplusplus
}
#endif

#endif	/* _INC_PATHASH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\refcnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Edward Buchwalter (v-edbuc)    14-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM) 16-April-1999
    
    Adapted for NT and GPC by ShreeM\MBert.
    
--*/

//
// Include Files
//

#include "gpcpre.h"

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID )
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    TRACE(REFCOUNT, pRefCnt, InstanceHandle, "ReferenceInit( 0x%x, 0x%x )\n");
    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    
    pRefCnt->Tags[0].Tag = 'LTOT';
    
    CTEInitLock(&pRefCnt->Lock);
    
#endif
        
}

VOID
ReferenceAdd
(
    IN  PREF_CNT pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ASSERT( pRefCnt );

    InterlockedIncrement(&pRefCnt->Count);
    TRACE(REFCOUNT, pRefCnt->Count, 0, "R+%d\n");

}

VOID
ReferenceAddCount
(
    IN  PREF_CNT    pRefCnt,
    IN  UINT        Count
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt->Count > 0 );

    CTEInterlockedExchangeAdd(&pRefCnt->Count, Count);
}

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt );

    // Trap remove reference on a zero count

    ASSERT( pRefCnt->Count > 0 );

    // If the decremented count is non zero return the instance handle

    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        TRACE(REFCOUNT, pRefCnt->Count, 0, "R-%d\n");        
        TRACE(REFCOUNT, pRefCnt->Count, 0, "ReferenceRemove:remaining: %d\n");
        return( pRefCnt->Instance );
    }

    // Delete this instance if a delete handler is available

    if( pRefCnt->DeleteHandler )
    {
        TRACE(REFCOUNT, 0, 0, "Executing DeleteHandler\n");

        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }

    // Indicate no active references to this instance

    return( NULL );
}

//
// API Test Support
//

#if DBG

VOID
ReferenceApiTest( VOID )
{
REF_CNT  RefCnt;

    TRACE(REFCOUNT, 0, 0, "\nReferenceApiTest\n");
    TRACE(REFCOUNT, 0, 0, "\nTest #1: NULL delete handler\n");

    ReferenceInit( &RefCnt, &RefCnt, NULL );

    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );

    while( ReferenceRemove( &RefCnt ) )
    {
        ;
    }

    TRACE( REFCOUNT, 0, 0, "\nTest #2: Delete Handler - TBD\n");
}

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    
    ASSERT(pRefCnt->Sig == REF_SIG);
    
    TRACE(REFCOUNT, EXPAND_TAG(Tag), pRefCnt->Count, ("GPC REF: add (%c%c%c%c) %d\n"));
    
    CTEGetLock(&pRefCnt->Lock, &hLock);
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    ASSERT(i < TAG_CNT);
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
    
    InterlockedIncrement(&pRefCnt->Count);
    
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    // sanity check
/*    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

*/    
    CTEFreeLock(&pRefCnt->Lock, hLock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    TRACE(REFCOUNT, EXPAND_TAG(Tag), pRefCnt->Count, "GPC REF: remove (%c%c%c%c) %d\n");
             
    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count > 0);
            
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
        
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);
    
    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);
    } 
    else if (pRefCnt->DeleteHandler)
    {
        TRACE(REFCOUNT, 0 , 0, "Executing DeleteHandler\n");
        
        CTEFreeLock(&pRefCnt->Lock, hLock);
        
        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }
    else
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);   
    }
        
/*
    // sanity check
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint(TEXT("Tag %X, RefCnt %X, perArray %d, total %d\n"), Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
    

*/    
}



VOID
ReferenceCheckForZeroRef(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count == 0);

            break;
        }
    }

    ASSERT(FoundIt);
  
    CTEFreeLock(&pRefCnt->Lock, hLock);   
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\rhizome.h ===
/*
 *  rhizome.h
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the rhizome database.  The code is object-oriented C, transliterated from
 *  a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the rhizome database.
 *
 */

#ifndef _INC_RHIZOME

#define _INC_RHIZOME

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the RhizomeNode and the Rhizome.
 *  Ideally, these would be completely hidden from the client, but the macro
 *  GetReferenceFromPatternHandle requires knowledge of the structure's
 *  definition.  It is strongly urged that the client not directly refer to any
 *  of the fields of either of these structures.  To support the documentation
 *  of the accompanying rhizome.c file, these structures are annotated with
 *  internal comments, but these can be ignored by the reader who wishes only
 *  to understand how to write client code for the rhizome.
 *
 *  The client refers to a pattern by its PatternHandle.  This is typedefed to
 *  a pointer to RhizomeNode, but this fact should be ignored by the client,
 *  since it is an implementation detail.
 *
 */

    //#include <stdlib.h>
    //#include <malloc.h>

struct _RhizomeNode
{
	// This structure is used for both branch nodes and leaf nodes.  The two
	// are distinguished by the value of the pivot_bit field.  For branch
	// nodes, pivot_bit < keybits, and for leaf nodes, pivot_bit == keybits.

	int pivot_bit;            // for branch nodes, bit of key on which to branch
	union
	{
		struct                                           // data for branch node
		{
			struct _RhizomeNode *children[2];  // pointers to children in search
		} branch;
		struct                                             // data for leaf node
		{
			void *reference;               // reference value supplied by client
			struct _RhizomeNode *godparent;   // pointer to more general pattern
		} leaf;
	} udata;
	char cdata[1];            // space for storing value, mask, and imask fields
};

typedef struct _RhizomeNode RhizomeNode;

struct _Rhizome
{
	int keybits;          // number of bits in key
	int keybytes;         // number of bytes in key, calculated from keybits
	RhizomeNode *root;    // root of search trie
};

typedef struct _Rhizome Rhizome;

// The client uses PatternHandle to refer to patterns stored in the database.
typedef RhizomeNode *PatternHandle;

/*
 *  The client interface to the rhizome is provided by five functions and two
 *  macros.  It is expected that the client will first instantiate a database,
 *  either on the stack or the heap, and then insert patterns with corresponding
 *  reference information into the database.  When the client then performs a
 *  search on a key, the client wishes to know which pattern most specifically
 *  matches the key, and it ultimately wants the reference information
 *  associated with the most specifically matching pattern.
 *
 */

// A rhizome may be allocated on the stack simply by declaring a variable of
// type Rhizome.  To allocate it on the heap, the following macro returns a
// pointer to a new Rhizome structure.  If this macro is used, a corresponding
// call to free() must be made to deallocate the structure from the heap.
//
//#define NEW_Rhizome ((Rhizome *)malloc(sizeof(Rhizome)))

#define AllocateRhizome(_r)   GpcAllocMem(&(_r), sizeof(Rhizome), RhizomeTag)
#define FreeRhizome(_r)       GpcFreeMem((_r), RhizomeTag)

// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits);

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.  However, if the client code can be
// sure, based upon its usage of the database, that all patterns have been
// removed before the structure is deallocated, then this function is
// unnecessary.
//
void
destructRhizome(
	Rhizome *rhizome);

// Once the Rhizome structure has been allocated and constructed, patterns can
// be inserted into the database.  Each pattern is specified by a value and a
// mask.  Each bit of the mask determines whether the bit position is specified
// or is a wildcard:  A 1 in a mask bit indicates that the value of that bit is
// specified by the pattern; a 0 indicates that the value of that bit is a
// wildcard.  If a mask bit is 1, then the corresponding bit in the value field
// indicates the specified value of that bit.  Value and mask fields are passed
// as arrays of bytes.
//
// The client also specifies a reference value, as a void pointer, that it
// wishes to associate with this pattern.  When the pattern is installed, the
// insertRhizome function returns a pointer to a PatternHandle.  From the
// PatternHandle can be gotten the reference value via the macro
// GetReferenceFromPatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status);

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle, so the client
// must discard the handle after it has called removeRhizome.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle);

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key);

// To get the client-supplied reference value from a PatternHandle, the
// following macro should be used.  The client should not make assumptions
// about the details of the RhizomeNode structure, nor should it even assume
// that the PatternHandle is a pointer to a RhizomeNode.
//
#define GetReferenceFromPatternHandle(phandle) ((PatternHandle)phandle)->udata.leaf.reference
#define GetKeyPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata)
#define GetMaskPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata + (_r)->keybytes)
#define GetKeySizeBytes(_r) ((_r)->keybytes)

#ifdef __cplusplus
}
#endif

#endif	/* _INC_RHIZOME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\gpc\rhizome.c ===
/*
 *  rhizome.c
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This source file provides functions that implement insertion, removal, and
 *  search operations on the rhizome database.  The code is object-oriented C,
 *  transliterated from a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  None of the code or comments in this file needs to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, rhizome.h.
 *
 */

#include "gpcpre.h"

// The fields of the RhizomeNode structure are accessed through the following
// macros.  The first three are obvious; the subsequent three rely on an agreed
// usage of the cdata array in the RhizomeNode.  The first keybytes locations
// of the cdata array are used to store the value field of the node; the second
// keybytes locations store the mask field; and the third keybytes locations
// store the imask field.
//
#define CHILDREN udata.branch.children
#define REFERENCE udata.leaf.reference
#define GODPARENT udata.leaf.godparent
#define VALUE(pointer) (pointer->cdata)
#define MASK(pointer) (pointer->cdata + rhizome->keybytes)
#define IMASK(pointer) (pointer->cdata + 2 * rhizome->keybytes)

// This macro allocates a new rhizome node structure.  The size of the structure
// is a function of the value of keybytes, since three bytes of information
// need to be stored in the structure for each byte of pattern length.  The
// cdata array, which is the last field in the structure, is declared as a
// having a single element, but this array will actually extend beyond the
// defined end of the structure into additional space that is allocated for it
// by the following macro.
//
#define NEW_RhizomeNode(_pa) \
	GpcAllocMem(_pa,\
                sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1,\
                RhizomeTag);\
    TRACE(RHIZOME, *_pa, sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1, "NEW_RhizomeNode")


// This macro gets the indexed bit of the value, where the most-significant bit
// is defined as bit 0.
//
#define BIT_OF(value, index) \
	(((value)[(index) >> 3] >> (7 - ((index) & 0x7))) & 0x1)

// Following are prototypes for static functions that are used internally by
// the implementation of the rhizome routines.

static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit);

static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint);

static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit);

static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point);

static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point);


// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits)
{
	rhizome->keybits = keybits;
	rhizome->keybytes = (keybits - 1) / 8 + 1;
	rhizome->root = 0;
}

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.
//
// If the structure is non-empty, call coalesce() to eliminate
// all branch nodes and to string leaf nodes into a list; then delete list.
//
void
destructRhizome(
	Rhizome *rhizome)
{
	RhizomeNode *leaf_list, *next;
	if (rhizome->root != 0)
	{
		leaf_list = 0;
		coalesce(rhizome, &leaf_list, rhizome->root);
		while (leaf_list != 0)
		{
			next = leaf_list->GODPARENT;
			GpcFreeMem(leaf_list, RhizomeTag);
			leaf_list = next;
		}
	}
}

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key)
{
	int index;
	RhizomeNode *point;
	// If tree is empty, search fails.
	if (rhizome->root == 0)
	{
		return 0;
	}
	// Otherwise, start at rhizome->root and navigate tree until reaching a leaf.
	point = rhizome->root;
	while (point->pivot_bit < rhizome->keybits)
	{
		point = point->CHILDREN[BIT_OF(key, point->pivot_bit)];
	}
	// Check value for match, one byte at a time.  If any byte fails to match,
	// continue checking godparent with same byte; since previous bytes matched
	// godchild, they are guaranteed to match godparent also.
	index = 0;
	while (index < rhizome->keybytes)
	{
		if ((((key)[index]) & MASK(point)[index]) != VALUE(point)[index])
		{
			if (point->GODPARENT != 0)
			{
				point = point->GODPARENT;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			index++;
		}
	}
	return point;
}

// This function inserts a new pattern into the database.  The pattern is
// specified by a value and a mask.  Each bit of the mask determines whether
// the bit position is specified or is a wildcard:  A 1 in a mask bit indicates
// that the value of that bit is specified by the pattern; a 0 indicates that
// the value of that bit is a wildcard.  If a mask bit is 1, then the
// corresponding bit in the value field indicates the specified value of that
// bit.  Value and mask fields are passed as arrays of bytes.
//
// The client specifies a void pointer reference value to associate with the
// pattern.  When the pattern is installed, the insertRhizome function returns
// a pointer to a PatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status)
{
	RhizomeNode *new_leaf;
	int index0, insert_status;
    
    *status = GPC_STATUS_SUCCESS;

	// Create new leaf and copy data into it; restrict set bits of value to
	// those set in mask, since later code assumes this is the case.  Add new
	// leaf to reference table.
	NEW_RhizomeNode(&new_leaf);
	if (new_leaf == 0)
	{
		// Memory could not be allocated for this new node.  Therefore, we
		// return an indication of failure to the client.
        *status = GPC_STATUS_RESOURCES;
		return 0;
	}
	for (index0 = 0; index0 < rhizome->keybytes; index0++)
	{
		VALUE(new_leaf)[index0] = value[index0] & mask[index0];
		MASK(new_leaf)[index0] = mask[index0];
		IMASK(new_leaf)[index0] = mask[index0];
	}
	new_leaf->REFERENCE = reference;
	new_leaf->pivot_bit = rhizome->keybits;
	new_leaf->GODPARENT = 0;
	// If tree is empty, leaf becomes first node; otherwise, attempt to insert
	// using recursive node_insert() routine.  If new leaf conflicts with
	// existing leaf, node_insert() throws exception; then remove new leaf and
	// return failure code.
	if (rhizome->root == 0)
	{
		rhizome->root = new_leaf;
	}
	else
	{
		insert_status = node_insert(rhizome, new_leaf, &rhizome->root, -1);
		if (insert_status != GPC_STATUS_SUCCESS)
		{
			removeRhizome(rhizome, new_leaf);
            *status = GPC_STATUS_CONFLICT;
			return 0;                                     // return null pointer
		};
	}
	return new_leaf;
}

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle)
{
	// Call recursive node_remove() routine to remove all references to leaf;
	// then delete leaf.
	node_remove(rhizome, phandle, &rhizome->root);
    TRACE(RHIZOME, rhizome, phandle, "removeRhizome")
	GpcFreeMem(phandle, RhizomeTag);
}

// Insert new_leaf into subtree pointed to by *ppoint.  Update *ppoint to point
// to newly created nodes if necessary.  Index of most recently examined bit
// is given by prev_bit.  The return value is a status code:  Normally, it
// returns GPC_STATUS_SUCCESS; if there is a conflict, then it returns NDIS_STATUS_CONFLICT;
// if there is insufficient memory available to perform the insertion, then it
// returns GPC_STATUS_RESOURCES.
//
static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit)
{
	int index, index0, bit_value, insert_status;
	char sub, super;
	RhizomeNode *point, *child, *new_branch;
	// This routine has a recursive structure, but unnecessary recursions have
	// been replaced by iteration, in order to improve performance.  This
	// recursion removal has introduced a forever loop which encloses the
	// entirety of the routine; looping back to the beginning of this loop is
	// thus the equivalent of recursing.
	while (1)
	{
		point = *ppoint;
		// Examine each bit index beginnig with that following last bit index
		// examined previously.  Continue examining bits until pivot bit of
		// current node is reached (unless loop is terminated prematurely).
		for (index = prev_bit + 1; index < point->pivot_bit; index++)
		{
			// If some leaf in the current subtree cares about the value of the
			// current bit, and if the new leaf cares about the value of the
			// current bit, and these two leaves disagree about the value of
			// this bit, then a new branch node should be inserted here.
			if (BIT_OF(MASK(new_leaf), index) == 1 &&
				BIT_OF(MASK(point), index) == 1 &&
				BIT_OF(VALUE(new_leaf), index) != BIT_OF(VALUE(point), index))
			{
				// Create new branch node; insert into tree; and set fields.
				bit_value = BIT_OF(VALUE(new_leaf), index);
				NEW_RhizomeNode(&new_branch);
				if (new_branch == 0)
				{
					// Memory could not be allocated for this new node.
					// Therefore, we pass an indication of failure up the stack.
					return GPC_STATUS_RESOURCES;
				}
				*ppoint = new_branch;
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(new_branch)[index0] =
						VALUE(point)[index0] | VALUE(new_leaf)[index0];
					MASK(new_branch)[index0] =
						MASK(point)[index0] | MASK(new_leaf)[index0];
					IMASK(new_branch)[index0] =
						IMASK(point)[index0] & IMASK(new_leaf)[index0];
				}
				// Pivot bit of new branch node is the bit that inspired the
				// creation of this branch.
				new_branch->pivot_bit = index;
				// The earlier subtree becomes the child whose bit disagreed
				// with that of the new leaf.
				new_branch->CHILDREN[1 - bit_value] = point;
				// If every leaf in the subtree cares about the value of this
				// bit, then we can insert the new leaf as the other child of
				// this branch.
				if (BIT_OF(IMASK(point), index) == 1)
				{
					// Insert new leaf here and return.
					new_branch->CHILDREN[bit_value] = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Otherwise, at least one leaf in the earlier subtree does not
				// care about the value of this bit.  Copy all such leaves
				// (and necessary branches) to the other child of the new
				// branch node.
				child = replicate(rhizome, point, index);
				if (child == 0)
				{
					// Memory could not be allocated for the replica.
					// Therefore, we remove the new node from the structure,
					// delete the new node, and pass an indication of failure
					// up the stack.
					*ppoint = point;
					GpcFreeMem(new_branch, RhizomeTag);
					return GPC_STATUS_RESOURCES;
				}
				new_branch->CHILDREN[bit_value] = child;
				// Continue search on newly copied subtree.
				ppoint = &new_branch->CHILDREN[bit_value];
				point = *ppoint;
			}
		}
		// All bits have been examined up to the pivot bit of the current node.
		// If this node is a leaf, then we have found a leaf with which the new
		// leaf has no disagreements over bit values.
		if (point->pivot_bit >= rhizome->keybits)
		{
			// Loop up the chain of godparents until one of the four cases
			// below causes an exit from the subroutine.
			while (1)
			{
				// Case 1:  We have reached the end of the godparent chain.
				if (point == 0)
				{
					// Insert new leaf at this point and return.
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 2:  We discover that we have already inserted this leaf
				// at the appropriate location.  This can happen because two
				// leaves in separate parts of the tree may have a common god-
				// ancestor, and a leaf which is a further god-ancestor of that
				// leaf will be reached more than once.  Since the first
				// occasion inserted the leaf, the second one can return without
				// performing any action.
				if (point == new_leaf)
				{
					return GPC_STATUS_SUCCESS;
				}
				// Compare mask bits of the new leaf to the current leaf.
				sub = 0;
				super = 0;
				for (index = 0; index < rhizome->keybytes; index++)
				{
					sub |= MASK(new_leaf)[index] & ~MASK(point)[index];
					super |= ~MASK(new_leaf)[index] & MASK(point)[index];
				}
				// Case 3:  The new leaf cares about at least one bit that the
				// current leaf does not; and the current leaf does not care
				// about any bits that the new leaf does not; thus, the new leaf
				// should be a godchild of the current leaf.
				if (sub != 0 && super == 0)
				{
					// Update imask field of new leaf; insert into chain;
					// and return.
					for (index0 = 0; index0 < rhizome->keybytes; index0++)
					{
						IMASK(new_leaf)[index0] &= IMASK(point)[index0];
					}
					new_leaf->GODPARENT = point;
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 4:  Either the new leaf has the same value and mask as
				// the current leaf, or there is a hierarchy conflict between
				// the two leaves.  In either case, terminate the insertion
				// process and clean up (in insert() routine) anything done
				// already.
				if (sub != 0 || super == 0)
				{
					return GPC_STATUS_CONFLICT;
				}
				// None of the above cases occurred; thus, the new leaf should
				// be a god-ancestor of the current leaf.  Update the imask
				// field of the current leaf, and continue with godparent of
				// current leaf.
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] &= IMASK(new_leaf)[index0];
				}
				ppoint = &point->GODPARENT;
				point = *ppoint;
			}
		}
		// The current node is not a leaf node.  Thus, we recurse on one or both
		// of the child nodes of the current node.  First, update the fields of
		// the current node to reflect the insertion of the new leaf into the
		// subtree.
		for (index0 = 0; index0 < rhizome->keybytes; index0++)
		{
			VALUE(point)[index0] |= VALUE(new_leaf)[index0];
			MASK(point)[index0] |= MASK(new_leaf)[index0];
			IMASK(point)[index0] &= IMASK(new_leaf)[index0];
		}
		// If the new leaf doesn't care about the value of the pivot bit of the
		// current leaf, then we must recurse on both children.  We can only
		// replace a single recursive call with iteration, so we perform a true
		// recursion in this case, and we recurse on child 1.
		if (BIT_OF(MASK(new_leaf), point->pivot_bit) == 0)
		{
			insert_status =
				node_insert(rhizome, new_leaf, &point->CHILDREN[1],
				point->pivot_bit);
			if (insert_status != GPC_STATUS_SUCCESS)
			{
				return insert_status;
			}
		}
		// Update the values of prev_bit and ppoint to reflect the same
		// conditions that would hold in a recursive call.  The pseudo-recursion
		// is performed on the bit indicated by the value of the pivot bit of
		// the new leaf.  If the new leaf does not care about this bit, then
		// this value will be a 0, and we recursed on child 1 above.  If the new
		// leaf does care about the value of this bit, then we continue down the
		// appropriate path.
		prev_bit = point->pivot_bit;
		ppoint = &point->CHILDREN[BIT_OF(VALUE(new_leaf), point->pivot_bit)];
	}
}

// Remove references to leaf from subtree pointed to by *ppoint.  Update *ppoint
// if necessary due to removal of branch nodes.
//
static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint)
{
	int pivot_bit, bit_value, index0;
	RhizomeNode *point, *child, *child0, *child1;
	point = *ppoint;
	pivot_bit = point->pivot_bit;
	if (pivot_bit < rhizome->keybits)
	{
		// The current node is a branch node.
		if (BIT_OF(MASK(leaf), pivot_bit) == 1)
		{
			// The leaf to be removed cares about this node's pivot bit;
			// therefore, we need only recurse on one of the current node's
			// children.
			bit_value = BIT_OF(VALUE(leaf), pivot_bit);
			node_remove(rhizome, leaf, &point->CHILDREN[bit_value]);
			child = point->CHILDREN[bit_value];
			if (child != 0 && BIT_OF(MASK(child), pivot_bit) == 1)
			{
				// Some leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, this node
				// still has reason to exist.  Update its fields to reflect the
				// change in one of its subtrees.
				child0 = point->CHILDREN[0];
				child1 = point->CHILDREN[1];
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(point)[index0] =
						VALUE(child0)[index0] | VALUE(child1)[index0];
					MASK(point)[index0] =
						MASK(child0)[index0] | MASK(child1)[index0];
					IMASK(point)[index0] =
						IMASK(child0)[index0] & IMASK(child1)[index0];
				}
			}
			else
			{
				// No leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, there is no
				// longer any reason for this node to exist.  Have the other
				// subtree take the current node's place in the tree; call
				// remove() to remove the unneeded subtree; and delete the
				// current node.
				*ppoint = point->CHILDREN[1 - bit_value];
				if (child != 0)
				{
					eliminate(rhizome, child);
				}
				GpcFreeMem(point, RhizomeTag);
			}
		}
		else
		{
			// The leaf to be removed does not care about this node's pivot bit;
			// therefore, we must recurse on both of the current node's
			// children.  This node must still be necessary, since we have not
			// removed any leaf which cares about this node's value.  So we
			// update its fields to reflect the change in its two subtrees.
			node_remove(rhizome, leaf, &point->CHILDREN[0]);
			node_remove(rhizome, leaf, &point->CHILDREN[1]);
			child0 = point->CHILDREN[0];
			child1 = point->CHILDREN[1];
			for (index0 = 0; index0 < rhizome->keybytes; index0++)
			{
				VALUE(point)[index0] =
					VALUE(child0)[index0] | VALUE(child1)[index0];
				MASK(point)[index0] =
					MASK(child0)[index0] | MASK(child1)[index0];
				IMASK(point)[index0] =
					IMASK(child0)[index0] & IMASK(child1)[index0];
			}
		}
	}
	else
	{
		// The current node is a leaf node.
		if (point == leaf)
		{
			// The current node is the leaf to be removed; therefore, remove it
			// from chain of godparents.
			*ppoint = leaf->GODPARENT;
		}
		else
		{
			// The current node is not leaf to be removed.  Therefore, if this
			// node has a godparent, then recurse on that godparent.  If this
			// node does not have a godparent, then the to-be-removed leaf
			// either already was removed by a different path, or it was never
			// inserted to begin with.  The latter might be the case if remove()
			// was called from the catch clause of insert().
			if (point->GODPARENT != 0)
			{
				node_remove(rhizome, leaf, &point->GODPARENT);
			}
			// We are now popping back up the recursion stack.  If this node
			// does not have a godparent, or if it did but it does not anymore,
			// then initialize imask to mask; otherwise, copy the godparent's
			// value of imask.  Since the godparent chain follows a strict
			// hierarchy, and since imask is formed by successive conjunction,
			// all leaves in any given godparent chain will have the same value
			// of imask, namely the mask value of the highest god-ancestor.
			if (point->GODPARENT == 0)
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = MASK(point)[index0];
				}
			}
			else
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = IMASK(point->GODPARENT)[index0];
				}
			}
		}
	}
}

// Replicate all nodes in a subtree which do not care about the value of
// pivot_bit.
//
static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit)
{
	int index0, current_bit;
	RhizomeNode *new_node, *child0, *child1;
	// If this routine were fully recursive, the following while statement
	// would be an if statement.  However, recursion has been replaced by
	// iteration where possible, so the following code loops until bottoming
	// out when a leaf node is reached.
	while (source->pivot_bit < rhizome->keybits)
	{
		if (BIT_OF(IMASK(source->CHILDREN[0]), pivot_bit) == 0)
		{
			if (BIT_OF(IMASK(source->CHILDREN[1]), pivot_bit) == 0)
			{
				// Both subtrees contain leaves which do not care about the
				// pivot bit; therefore, we may need to make a copy of the
				// current node.  It is not guaranteed that we need to make
				// a copy, since it may be a common leaf in both subtrees
				// that does not care about the pivot bit.  This may happen
				// for a leaf which is a godparent of two leaves, one in each
				// subtree.  Recurse on each child and examine results.
				child0 = replicate(rhizome, source->CHILDREN[0], pivot_bit);
				if (child0 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process and pass an
					// indication of failure op the stack.
					return 0;
				}
				child1 = replicate(rhizome, source->CHILDREN[1], pivot_bit);
				if (child1 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process, eliminate
					// the other child replica, and pass an indication of
					// failure op the stack.
					eliminate(rhizome, child0);
					return 0;                             // return null pointer
				}
				current_bit = source->pivot_bit;
				if (BIT_OF(MASK(child0), current_bit) == 1)
				{
					if (BIT_OF(MASK(child1), current_bit) == 1)
					{
						// Both replicated child subtrees contain leaves which
						// care about the current node's bit.  Since any node
						// which is a godparent of nodes in both subtrees could
						// not possibly care about the current node's bit, we
						// know that we need to make a copy of the current node.
						NEW_RhizomeNode(&new_node);
						if (new_node == 0)
						{
							// Memory could not be allocated for this new node.
							// Therefore, we have to eliminate both children
							// and pass an indication of failure up the stack.
							eliminate(rhizome, child0);
							eliminate(rhizome, child1);
							return 0;                     // return null pointer
						}
						for (index0 = 0; index0 < rhizome->keybytes; index0++)
						{
							VALUE(new_node)[index0] =
								VALUE(child0)[index0] | VALUE(child1)[index0];
							MASK(new_node)[index0] =
								MASK(child0)[index0] | MASK(child1)[index0];
							IMASK(new_node)[index0] =
								IMASK(child0)[index0] & IMASK(child1)[index0];
						}
						new_node->pivot_bit = current_bit;
						new_node->CHILDREN[0] = child0;
						new_node->CHILDREN[1] = child1;
						return new_node;
					}
					// Child 0's subtree contains a leaf that cares about the
					// current bit; however, child 1's subtree does not.  Thus,
					// all leaves which are in child 1's subtree are also in
					// child 0's subtree, so we only need to keep the latter.
					// We therefore eliminate child 1's subtree, and we return
					// child 0 as the new subtree at this location, since we
					// do not need to create a new branch node here.
					eliminate(rhizome, child1);
					return child0;
				}
				// Child 0's subtree does not contain a leaf that cares about
				// the current node's bit.  Thus, all leaves which are in child
				// 0's subtree are also in child 1's subtree, so we only need to
				// keep the latter.  We therefore eliminate child 0's subtree,
				// and we return child 1 as the new subtree at this location,
				// since we do not need to create a new branch node here.
				eliminate(rhizome, child0);
				return child1;
			}
			// Child 0's subtree contains a leaf which does not care about the
			// pivot bit; however, child 1's subtree does not.  Therefore, we
			// recurse on child 0.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[0];
		}
		else
		{
			// Child 0's subtree does not contain a leaf which does not care
			// about the pivot bit.  Child 1's subtree must contain such a leaf,
			// since the current node's subtree contains such a leaf.  Thus, we
			// recurse on child 1.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[1];
		}
	}
	// A leaf node has been reached.  We now iterate through the godparents of
	// the leaf until we find one which does not care about the pivot bit.
	// Once we find it, we know that all godparents of that leaf also do not
	// care about the pivot bit, since the godparents are arranged in a strict
	// hierarchy.  We thus return the first leaf found which does not care about
	// the value of the pivot bit.
	while (BIT_OF(MASK(source), pivot_bit) == 1)
	{
		source = source->GODPARENT;
	}
	return source;
}

// Eliminate an entire subtree.
//
static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point)
{
	RhizomeNode *child;
	// Partial recursion removal.  The while loop takes the place of one of the
	// recursive calls to eliminate().  We eliminate each node and recursively
	// eleminate each subtree under the node.  We do not eliminate leaves, since
	// there is only one copy of each leaf stored in the entire structure.
	while (point->pivot_bit < rhizome->keybits)
	{
		eliminate(rhizome, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, RhizomeTag);
		point = child;
	}
}

// Coalesce leaves of subtree into a linked list and eliminate subtree.  This
// routine is called by the destructor so that it can deallocate the leaf nodes
// after the branch nodes are eliminated.
//
static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point)
{
	RhizomeNode *child, *godparent;
	// Partial recursion removal.  This while loop takes the place of one of
	// the recursive calls to coalesce().  This performs an inorder traversal.
	// We delete each branch node after we have visited it, just as in the
	// eliminate() routine.
	while (point->pivot_bit < rhizome->keybits && point->pivot_bit >= 0)
	{
		coalesce(rhizome, leaf_list, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, RhizomeTag);
		point = child;
	}
	// Once we have found a leaf, we search through the chain of godparents,
	// adding to the list each leaf node that is not already in the list.
	// A pivot_bit of -1 indicates that the leaf is already in the list.
	// If a leaf is in the list, then so are all of its godparents.
	while (point != 0 && point->pivot_bit >= 0)
	{
		godparent = point->GODPARENT;
		point->pivot_bit = -1;
		point->GODPARENT = *leaf_list;
		*leaf_list = point;
		point = godparent;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\kdext\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windows.h>
#include <ntosp.h>

#include <ndis.h>
#include <cxport.h>

#include <wdbgexts.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <tdi.h>
#include <tdikrnl.h>

#include "gpcifc.h"
#include "rhizome.h"
#include "pathash.h"
#include "handfact.h"
#include "ntddgpc.h"
#include "gpcstruc.h"
#include "refcnt.h"
#include "gpcdef.h"
#include "gpcdbg.h"
#include "gpcmap.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\kdext\makefile.inc ===
$(O)\precomp.pph: ..\gpc\gpcdef.h makefile.inc
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dsogpc.c: dso.txt $(O)\precomp.pph makefile.inc
    @echo Creating $@
    @cd $(O)
    structo -i h -p -s $(MAKEDIR)\dso.txt -o dsogpc.c precomp.pph
    @cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\kdext\logger.c ===
/*
Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This function contains some example KD debugger extensions

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"


typedef BOOLEAN
(*PRINT_FUNC) (
    IN PROW Row
);

HANDLE     FileHandle;
PRINT_FUNC Print;

DWORD
MyOpenFile (
    IN PCHAR Name,
    IN PWINDBG_OUTPUT_ROUTINE out,
    OUT HANDLE *File
    )

{
    HANDLE hFile;
    hFile = CreateFile(Name,
                          GENERIC_WRITE | GENERIC_READ,
                          0,
                          NULL,
                          CREATE_ALWAYS ,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        out ("MyOpenFile: CreateFile Failed.\n");
    }

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
}

BOOLEAN MyWriteFile(PROW lRow)
{
    LONG  len;
    BOOL  bRv;
    DWORD dwWritten;
    CHAR  buffer[1024];

    dprintf(".");
    wsprintf(buffer, "[%4d] 0x%x:0x%x:0x%x:0x%x: %s\n", lRow->Line, lRow->P1, lRow->P2, lRow->P3, lRow->P4, lRow->Row);
    len = strlen(buffer);
    bRv = WriteFile( FileHandle, buffer, len, &dwWritten, NULL );

    if (!bRv) {
        dprintf("WriteFile: Puked\n");
    }

    return bRv ? TRUE :FALSE;
}

BOOLEAN MyWriteConsole(PROW lRow)
{
    dprintf("[%4d] 0x%x:0x%x:0x%x:0x%x: %s\n", lRow->Line, lRow->P1, lRow->P2, lRow->P3, lRow->P4, lRow->Row);
    return TRUE;
}

DECLARE_API( tt )
{
    UINT i, max, total = 0;
    DWORD hostAddress;
    LOG   LLog;
    ULONG status, success;
    ULONG bytesread;
    CHAR DeviceName[] = "c:\\tmp\\";
    CHAR buffer[255];

    char LogBase[]   = {"&msgpc!Log"};

    hostAddress =  GetExpression(LogBase);

    if ( *args != '\0' ) {

        strcpy( buffer, DeviceName );
        strcat( buffer, args );
        status = MyOpenFile( buffer, dprintf, &FileHandle );
        if ( status == ERROR_SUCCESS ) {
            Print = MyWriteFile;
            max = LOGSIZE;
        }
        else {
            goto cleanup;
        }

        dprintf( "handle =%x status=%x \n", FileHandle, status);
    }
    else {
        Print = MyWriteConsole;
        max = 100;
    }

    if (!hostAddress){
        dprintf("bad string conversion (%s) \n", LogBase);
        goto cleanup;
    }

    success = ReadMemory((ULONG)hostAddress, &LLog, sizeof(LOG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", hostAddress, sizeof(LOG));
        goto cleanup;
    }

    dprintf( "TT Log dumping %d entries\n", max);
    for(i = LLog.Index; (i < LOGSIZE) && (total < max); i++, total++)
    {
         PROW pRow;
         ROW  lRow;

         pRow = &LLog.Buffer[i];

         success = ReadMemory((ULONG)pRow, &lRow, sizeof(ROW), &bytesread);

         if(!success) {

              dprintf("problems reading memory at %x for %x bytes\n", pRow, sizeof(LOG));
              goto cleanup;
         }

         (*Print)(&lRow);

    }

    if (total < max) {
        dprintf( "TT Log dumping the rest (%d) from the top....\n", LLog.Index);
    }

    for(i = 0; (i < LLog.Index) && (total < max); i++, total++)
    {
         PROW pRow;
         ROW  lRow;

         pRow = &LLog.Buffer[i];

         success = ReadMemory((ULONG)pRow, &lRow, sizeof(ROW), &bytesread);

         if(!success) {

              dprintf("problems reading memory at %x for %x bytes\n", pRow, sizeof(LOG));
              goto cleanup;
         }

         (*Print)(&lRow);

    }

cleanup:
    if ( *args != '\0' ) {
         CloseHandle(FileHandle);
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
* 10/06/98 Rajeshsu edited to use wdbgexts.h
\***************************************************************************/

#define DsoPrint(x) dprintf("%.*s", nIndent, "                      "); dprintf x

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define EvalExp GetExpression

#define EXACT_MATCH 0xFFFF

int gnIndent = 0; // caller should set and restore this appropriately.

VOID moveBlock(
    PVOID pdst,
    PVOID src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;
    
    try {
        if (!ReadMemory((DWORD_PTR)src, pdst, size, &Result)) {
            fSuccess = FALSE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //dprintf(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        dprintf("moveBlock(%x, %x, %x) failed.\n", pdst, src, size);
    }
}


/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dsoGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * If dwSize is EXACT_MATCH, we try an exact
     * case sensitive match
     */
    if (dwSize == EXACT_MATCH) {
        while (pst->pszName != NULL) {
            if (!strcmp(pszStruct, pst->pszName)) {
                return pst;
            }
            pst++;
        }
        return NULL;
    }
    /*
     * Try an exact case insensitive match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
* 05/12/97 MCostea Added bit field support
\***************************************************************************/

#define NFIELDS 2  // per row.

BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst, pstNested;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    int   cBFStart, cBFLength;   /* for printing bit field values: keeps count of field location */
    char* pTmp;
    DWORD dwMask;
    BOOL  fBF;
    int   cBF;                   /* no of dwords this set of bit-fields spread till now */
    int   cchName;               /* length of field name */
    int   nIndent = gnIndent;    /* amount to indent */

    UNREFERENCED_PARAMETER(opts);

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dsoGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        DsoPrint(("Structure not found: %s\n", pszCmdLine));
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                DsoPrint(("Field not found: %s. Struct: %s\n", pszField, pst->pszName));
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }
    
        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = (PVOID) EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);

        DsoPrint(("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize));

        /*
         * Try to see if the fields are not nested structures
         */
        if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
            /*
             * Probably the field is a nested structure
             */
            if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                DWORD dwNestedOffset = dsoGetOffset(psot);
                char cmdLine[80];
                DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                if (pAddress) {
                    sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                    pTmp = cmdLine;
                }
                else {
                    pTmp = psot->pszField;
                }
                return Idso(opts, pTmp);
            }
        }

        DsoPrint(("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset));
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        DsoPrint(("Address   Value\n"));

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            DsoPrint(("%p  ", (DWORD_PTR)((PBYTE)pAddress + dwOffset + dwBytesRead)));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                DsoPrint(("%08lx ", *((DWORD *)pBufferOffset)));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                DsoPrint(("%0*lx", dwMoveSize * 2, dwValue));
            }
            dprintf("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    if (pAddress != NULL) {
        DsoPrint(("Structure %s %#lx - Size: %#lx", pst->pszName, pAddress, pst->dwSize));
    } else {
        DsoPrint(("Structure %s - Size: %#lx", pst->pszName, pst->dwSize));
    }

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = NFIELDS;
    cBFStart = 0;
    cBF = 0;

    /*
     * Loop through all fields in the table. Print one field per loop
     */

    while (psot->pszField != NULL) {

        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == NFIELDS) {
            dprintf("\n");
            dwFieldsPerRow = 1;
            cchName = 24 - gnIndent/NFIELDS;
            nIndent = gnIndent;
            // Print("cchName = %d\n", cchName);
        } else {
            dwFieldsPerRow++;
            cchName = 24 - (gnIndent + 1)/NFIELDS;
            nIndent = 0;
            // Print("cchName = %d\n", cchName);
        }

        /*
         * -v functionality
         * Try to see if the fields are not nested structures
         * The naming convention assigns Uppercase names for them
         */
        if (opts & OFLAG(v)) {
            if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
                /*
                 * Probably the field is a nested structure
                 */
                if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                    DWORD dwNestedOffset = dsoGetOffset(psot);
                    char cmdLine[80];
                    DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                    if (pAddress) {
                        sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                        pTmp = cmdLine;
                    }
                    else {
                        pTmp = psot->pszField;
                    }
                    Idso(opts, pTmp);
                    dwOffsetNext = dsoGetOffset(psot + 1);
                    dwFieldsPerRow = 0;
                    goto Continue;
                }
            }
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            DsoPrint(("%03lx %-*.*s", dsoGetOffset(psot),
                      cchName, cchName, psot->pszField));
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);

            /*
             * Deal with bit fields
             */
            fBF = FALSE;
            pTmp = psot->pszField;
            while (*pTmp) {
                if (*pTmp++ == ':') {

                    fBF = TRUE;
                    while ((*pTmp == ' ') || (*pTmp == '\t')) {     /* skip white spaces */
                        ++pTmp;
                    }
                    cBFLength = *(pTmp++) - '0';      /* now get the bit size, maybe 2 digits */
                    if ((*pTmp >= '0') && (*pTmp <= '9'))
                        cBFLength = cBFLength*10 + (*pTmp - '0');

                    if (cBFStart == 0) {
                        DsoPrint(("(%03lx) %08lx BIT FIELDS\n", dwOffset, dwValue));
                        dwFieldsPerRow = 1;
                    }
                    else if (cBFStart >= 8*sizeof(DWORD)) {   /* check for multi-dword fields */
                        cBF ++;
                        cBFStart %= 8*sizeof(DWORD);
                    }

                    dwMask = (1L << cBFLength) - 1;
                    dwMask <<= cBFStart;
                    /* print byte offset and the bit offset inside it */
                    DsoPrint(("(%03lx) (%d)   %-2x %-*.*s", dwOffset + cBF*sizeof(DWORD) + cBFStart/8, cBFStart & 7,
                           (dwMask & dwValue) >> cBFStart,
                            cchName, cchName, psot->pszField));
                    cBFStart += cBFLength;
                    cBFLength = 0;
                    break;
                }
            }
            if (!fBF) {
                int width = 8;
                if (dwSize == sizeof(BYTE)) {
                    dwValue &= 0xff;
                    width = 2;
                } else if (dwSize == sizeof(WORD)) {
                    dwValue &= 0xffff;
                    width = 4;
                }
                DsoPrint(("(%03lx) %*s%0*lx %-*.*s", dwOffset, 8 - width, "", width, dwValue,
                          cchName, cchName, psot->pszField));
                cBFStart = 0;
                cBF = 0;
            }

        } /* if (pAddress == NULL) */

Continue:
        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    dprintf("\n");

    return TRUE;
}

DECLARE_API( gpcdso )
{
    LPSTR pszCmdLine; 
    DWORD opts = 0;

    pszCmdLine = (LPSTR) args;
    Idso(opts, pszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\kdext\kdgpc.c ===
#include "precomp.h"

//
// The ExtensionApis is a mandatory global variable, which should
// have this exact name. All definitions of callbacks to the windbg
// are using this variable.
//

WINDBG_EXTENSION_APIS ExtensionApis;
USHORT  g_MajorVersion;
USHORT  g_MinorVersion;


//
// Prototypes
//
VOID
PrintCf(
        PCF_BLOCK       pCf
        );

VOID
PrintClient(
        PCLIENT_BLOCK   pClient
        );

VOID
PrintBlob(
        PBLOB_BLOCK     pBlob
        );

VOID
PrintPattern(
        PPATTERN_BLOCK  pPattern
        );

VOID
PrintStat(
                PGPC_STAT               pStat
        );

BOOL
GetDwordExpr(
             char* expr,
             DWORD* pdwAddress,
             DWORD* pValue
             );


//
// API's
//

LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )

/*++

Function Description:

    Windbg calls this function to match between the version of windbg and the
    extension. If the versions doesn't match, windbg will not load the extension.

--*/

{
    static EXT_API_VERSION ApiVersion =
        { 3, 5, EXT_API_VERSION_NUMBER, 0 };

    return &ApiVersion;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )

/*++

Function Description:

    When windbg loads the extension, it first call this function. You can
    perform various intialization here.

Arguments:

    lpExtensionApis - A structure that contains the callbacks to functions that
        I can use to do standard operation. I must store this in a global
        variable called 'ExtensionApis'.

    MajorVersion - Indicates if target machine is running checked build or free.
        0x0C - Checked build.
        0x0F - Free build.

    MinorVersion - The Windows NT build number (for example, 1381 for NT4).

--*/

{
    ExtensionApis = *lpExtensionApis;

    g_MajorVersion = MajorVersion;
    g_MinorVersion = MinorVersion;
}


DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("KDGPC: %s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            g_MajorVersion == 0x0c ? "Checked" : "Free",
            g_MinorVersion
            );
}




VOID
CheckVersion(
    VOID
    )

/*++

Function Description:

    This function is called before every command. It gives the extension
    a chance to compare between the versions of the target and the extension.
    In this demo, I don't do much with that.

--*/

{
#if DBG
    if ((g_MajorVersion != 0x0c) || (g_MinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                (VER_PRODUCTBUILD, g_MinorVersion, g_MajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
//    if ((g_MajorVersion != 0x0f) || (g_MinorVersion != VER_PRODUCTBUILD)) {
//        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
//                (VER_PRODUCTBUILD, g_MinorVersion, (g_MajorVersion==0x0f) ? "Free" : "Checked" );
//    }
#endif
}



DECLARE_API( help )

/*++

Function Description:

    This is the implementation of the '!help' extension command. It lists
    all available command in this debugger extension.

--*/

{
    dprintf(
        "help      - shows this list\n"
        "cf        - print the CF list\n"
        "client [addr]  - print the client block"
        "blob [addr]  - print the blob list for the QoS CF, or the specified blob\n"
        "pattern [addr] - print the pattern block\n"
        "stat      - print the statistics"
        );
}


DECLARE_API( cf )

/*++

Function Description:

    This function prints all the CF in the list. If args is specified, only that CF
    will be printed. Currently these are supported:

    0 - for CF_QOS

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       CfIndex = (-1);
    char                        *lerr;

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    if ( args )
        CfIndex = strtol( args, &lerr, 10 );

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }

}



DECLARE_API( blob )

/*++

Function Description:

    This function prints all the blob in the QoS CF list.
    If args is specified it is used as the blob addr.

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetBlob = 0;
    BLOB_BLOCK          LocalBlob;
    char                        *lerr;

    if ( args )
        TargetBlob = GetExpression( args );

    if (TargetBlob) {

        if ( !ReadMemory( TargetBlob,
                          &LocalBlob,
                          sizeof(LocalBlob),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetBlob );

        } else {

            PrintBlob( &LocalBlob );
        }
        return;
    }

#if 0
    //
    // scan the blob list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }
#endif

}



DECLARE_API( client )

/*++

Function Description:

    This function prints either the client addr or all the clients

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    PLIST_ENTRY         pHead1, pEntry1;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetClient = 0;
    CLIENT_BLOCK        LocalClient;
    int                         i = 0;

    if ( args )
        TargetClient = GetExpression( args );

    if (TargetClient) {

        if ( !ReadMemory( TargetClient,
                          &LocalClient,
                          sizeof(LocalClient),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetClient );

        } else {

            dprintf( "Client = 0x%X: ", TargetClient );
            PrintClient( &LocalClient );
        }
        return;
    }

    //
    // scan the client list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );
            return;

        } else {

            dprintf( "\nClients for CF=%d\n", LocalCf.AssignedIndex );

            pHead1 = (PLIST_ENTRY)((PUCHAR)TargetCf + FIELD_OFFSET(CF_BLOCK, ClientList));
            pEntry1 = LocalCf.ClientList.Flink;

            while ( pHead1 != pEntry1 ) {

                TargetClient = (DWORD)CONTAINING_RECORD( pEntry1, CLIENT_BLOCK, ClientLinkage );

                if ( !ReadMemory( TargetClient,
                                  &LocalClient,
                                  sizeof(LocalClient),
                                  &result ) ) {

                    dprintf( "Can't read memory from 0x%x", TargetClient );
                    return;

                } else {

                    dprintf( "Client [%d] = 0x%X: ", i++, TargetClient );
                    PrintClient( &LocalClient );
                }
                pEntry1 = LocalClient.ClientLinkage.Flink;
            }
        }

        pEntry = LocalCf.Linkage.Flink;

    }
}




BOOL
GetDwordExpr(
             char* expr,
             DWORD* pdwAddress,
             DWORD* pValue
             )

/*++

Function Description:

    This function gets as an argument a string which represent a DWORD
    variable. The funciton finds its address (if the symbols are loaded),
    and then grab the dword value from that address.

Arguments:

    expr [in] - A null terminated string, represent the variable.

    pdwAddress [out, optional] - Optinally return the address of the variable.

    pValue [out] - returns the value of the DWORD variable.

Return Value:

    true/false, if the function succeeded or failed.

--*/

{
    ULONG result;
    DWORD dwAddress;

    if( pdwAddress )
        *pdwAddress = 0;
    *pValue = 0;

    dwAddress = GetExpression( expr );
    if( !dwAddress )
        return FALSE;

    if( !ReadMemory( dwAddress, pValue, sizeof(DWORD), &result ) )
        return FALSE;

    if( pdwAddress )
        *pdwAddress = dwAddress;

    return TRUE;
}




VOID
PrintCf(
    PCF_BLOCK   pCf
    )

/*++

Function Description:

    This function gets as an argument a CF block pointer,
    and does a pretty print.

Arguments:

    pCf - pointer to CF block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  Linkage = { 0x%X, 0x%X }\n", pCf->Linkage.Flink, pCf->Linkage.Blink );
    dprintf( "  ClientList = { 0x%X, 0x%X }\n",
             pCf->ClientList.Flink,
             pCf->ClientList.Blink );
    dprintf( "  BlobList = { 0x%X, 0x%X }\n",
             pCf->BlobList.Flink,
             pCf->BlobList.Blink );
    dprintf( "  NumberOfClients = %d\n", pCf->NumberOfClients );
    dprintf( "  AssignedIndex = 0x%x\n", pCf->AssignedIndex );
    dprintf( "  ClientIndexes = %d\n", pCf->ClientIndexes );
    dprintf( "  MaxPriorities = %d\n", pCf->MaxPriorities );
    dprintf( "  arpGenericDb = 0x%X\n", &pCf->arpGenericDb );

    for ( i = GPC_PROTOCOL_TEMPLATE_IP; i < GPC_PROTOCOL_TEMPLATE_MAX; i++ ) {

        dprintf( "     [%d] = %d\n", i, (ULONG)pCf->arpGenericDb[i] );

    }
}




VOID
PrintBlob(
    PBLOB_BLOCK pBlob
    )

/*++

Function Description:

    This function gets as an argument a BLOB block pointer,
    and does a pretty print.

Arguments:

    pBlob - pointer to BLOB block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  ObjectType = %d\n", pBlob->ObjectType );
    dprintf( "  ClientLinkage = { 0x%X, 0x%X }\n",
             pBlob->ClientLinkage.Flink,
             pBlob->ClientLinkage.Blink );
    dprintf( "  PatternList = { 0x%X, 0x%X }\n",
             pBlob->PatternList.Flink,
             pBlob->PatternList.Blink );
    dprintf( "  CfLinkage = { 0x%X, 0x%X }\n",
             pBlob->CfLinkage.Flink,
             pBlob->CfLinkage.Blink );
    dprintf( "  RefCount = %d\n", pBlob->RefCount );
    dprintf( "  State = 0x%x\n", pBlob->State );

    dprintf( "  arClientCtx[]:\n" );
    for ( i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++ ) {

        dprintf( "     [%d] = 0x%x\n", i, (ULONG)pBlob->arClientCtx[i] );

    }


}




VOID
PrintClient(
    PCLIENT_BLOCK       pClient
    )

/*++

Function Description:

    This function gets as an argument a CLIENT block pointer,
    and does a pretty print.

Arguments:

    pClient - pointer to CLIENT block

Return Value:

    none

--*/

{
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;

    TargetCf = (DWORD)pClient->pCfBlock;

    if ( !ReadMemory( TargetCf,
                      &LocalCf,
                      sizeof(LocalCf),
                      &result ) ) {

        dprintf( "Can't read memory from 0x%x", TargetCf );
        return;
    }

    if (pClient->Flags & GPC_FLAGS_USERMODE_CLIENT) {
        dprintf( "  User Mode Client\n" );
    } else {
        if (GetExpression( "PSCHED!AddCfInfoNotify" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS || LocalCf.AssignedIndex == GPC_CF_CLASS_MAP)) {
            dprintf( "  Probably PSCHED client\n" );
        } else if (GetExpression( "TCPIP!GPCcfInfoAddNotify" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS || LocalCf.AssignedIndex == GPC_CF_IPSEC)) {
            dprintf( "  Probably TCPIP client\n" );
        } else if (GetExpression( "ATMARPC!AtmArpGpcAddCfInfoComplete" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS)) {
            dprintf( "  Probably ATMARPC client\n" );
        } else if (0 == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_IPSEC)) {
            dprintf( "  Probably IPSEC client\n" );
        } else {
            dprintf( "  Unknown client\n" );
        }
    }

    dprintf( "  ObjectType = %d\n", pClient->ObjectType );
    dprintf( "  ClientLinkage = { 0x%X, 0x%X }\n",
             pClient->ClientLinkage.Flink,
             pClient->ClientLinkage.Blink );
    dprintf( "  BlobList = { 0x%X, 0x%X }\n",
             pClient->BlobList.Flink,
             pClient->BlobList.Blink );
    dprintf( "  Parrent CF = 0x%X\n", pClient->pCfBlock );
    dprintf( "  Client Ctx = 0x%X\n", pClient->ClientCtx );
    dprintf( "  AssignedIndex = %d\n", pClient->AssignedIndex );
    dprintf( "  Flags = 0x%X %s %s \n",
             pClient->Flags,
             (pClient->Flags & GPC_FLAGS_USERMODE_CLIENT)?"UserMode":"" ,
             (pClient->Flags & GPC_FLAGS_FRAGMENT)?"Handle Fragments":""
             );
    dprintf( "  State = %d\n", pClient->State );
    dprintf( "  RefCount = %d\n", pClient->RefCount );
    dprintf( "  File Object = 0x%X\n", pClient->pFileObject );
    dprintf( "  Client Handle = %d\n", pClient->ClHandle );

    dprintf( "  Client Handlers:\n" );
    dprintf( "    Add Notify = 0x%X\n", pClient->FuncList.ClAddCfInfoCompleteHandler );
    dprintf( "    Add Complete = 0x%X\n", pClient->FuncList.ClAddCfInfoNotifyHandler );
    dprintf( "    Modify Notify = 0x%X\n", pClient->FuncList.ClModifyCfInfoCompleteHandler );
    dprintf( "    Modify Complete = 0x%X\n", pClient->FuncList.ClModifyCfInfoNotifyHandler );
    dprintf( "    Remove Notify = 0x%X\n", pClient->FuncList.ClRemoveCfInfoCompleteHandler );
    dprintf( "    Remove Complete = 0x%X\n", pClient->FuncList.ClRemoveCfInfoNotifyHandler );
    dprintf( "    Get CfInfo Name = 0x%X\n", pClient->FuncList.ClGetCfInfoName );

}




VOID
PrintPattern(
    PPATTERN_BLOCK      pPattern
    )

/*++

Function Description:

    This function gets as an argument a PATTERN block pointer,
    and does a pretty print.

Arguments:

    pPattern - pointer to PATTERN block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  ObjectType = %d\n", pPattern->ObjectType );
    dprintf( "  BlobLinkage[]:\n" );
    for ( i = 0; i < GPC_CF_MAX; i++ ) {

        dprintf( "     [%d] = {0x%X,0x%X}\n", i,
                 pPattern->BlobLinkage[i].Flink,
                 pPattern->BlobLinkage[i].Blink
                 );
    }
    dprintf( "  TimerLinkage = { 0x%X, 0x%X }\n",
             pPattern->TimerLinkage.Flink,
             pPattern->TimerLinkage.Blink );
    dprintf( "  Owner client = 0x%X\n", pPattern->pClientBlock );
    dprintf( "  Auto client = 0x%X\n", pPattern->pAutoClient );
    dprintf( "  Classification block = 0x%X\n", pPattern->pClassificationBlock );
    dprintf( "  Ref Count = %d\n", pPattern->RefCount );
    dprintf( "  Client Ref Count = %d\n", pPattern->ClientRefCount );
    dprintf( "  Flags = 0x%x %s %s \n", pPattern->Flags ,
             (pPattern->Flags & PATTERN_SPECIFIC)?"Specific":"",
             (pPattern->Flags & PATTERN_AUTO)?"Auto":""
             );
    dprintf( "  Priority = %d\n", pPattern->Priority );
    dprintf( "  Client handle = 0x%x\n", pPattern->ClHandle );
    dprintf( "  Protocol = 0x%x\n", pPattern->ProtocolTemplate );
}




VOID
PrintStat(
    PGPC_STAT   pStat
    )

/*++

Function Description:

    Prints the GPC stat structure

Arguments:

    pStat - pointer to GPC stat strucutre

Return Value:

    none

--*/

{
    PPROTOCOL_STAT  pProtocol;
    int                         i;

    dprintf( "Created CF = %d\n", pStat->CreatedCf );
    dprintf( "Deleted Cf = %d\n", pStat->DeletedCf );
    dprintf( "Rejected Cf = %d\n", pStat->RejectedCf );
    dprintf( "Current Cf = %d\n", pStat->CurrentCf );
    dprintf( "Inserted HF= %d\n", pStat->InsertedHF );
    dprintf( "Removed HF= %d\n", pStat->RemovedHF );

    for( i = 0; i < GPC_CF_MAX; i++) {

        dprintf( "CF[%d] info:\n", i);
        dprintf( "  Created Blobs = %d\n", pStat->CfStat[i].CreatedBlobs );
        dprintf( "  Modified Blobs = %d\n", pStat->CfStat[i].ModifiedBlobs );
        dprintf( "  Deleted Blobs = %d\n", pStat->CfStat[i].DeletedBlobs );
        dprintf( "  Rejected Blobs = %d\n", pStat->CfStat[i].RejectedBlobs );
        dprintf( "  Current Blobs = %d\n", pStat->CfStat[i].CurrentBlobs );
        dprintf( "  Deref Blobs to zero = %d\n", pStat->CfStat[i].DerefBlobs2Zero );
        dprintf( "\n" );
    }

    pProtocol = &pStat->ProtocolStat[GPC_PROTOCOL_TEMPLATE_IP];
    dprintf( "IP stats:   Specific Patterns   Generic Patterns   Auto Patterns\n" );
    dprintf( "  Created  =       %8d           %8d          %8d\n",
             pProtocol->CreatedSp, pProtocol->CreatedGp, pProtocol->CreatedAp );
    dprintf( "  Deleted  =       %8d           %8d          %8d\n",
             pProtocol->DeletedSp, pProtocol->DeletedGp, pProtocol->DeletedAp );
    dprintf( "  Rejected =       %8d           %8d          %8d\n",
             pProtocol->RejectedSp, pProtocol->RejectedGp, pProtocol->RejectedAp );
    dprintf( "  Current  =       %8d           %8d          %8d\n",
             pProtocol->CurrentSp, pProtocol->CurrentGp, pProtocol->CurrentAp );
    dprintf( "\n" );
    dprintf( "  Classification Requests = %d\n", pProtocol->ClassificationRequests );
    dprintf( "  Patterns Classified = %d\n", pProtocol->PatternsClassified );
    dprintf( "  Packets Classified = %d\n", pProtocol->PacketsClassified );
    dprintf( "\n" );
    dprintf( "  Deref Patterns to zero = %d\n", pProtocol->DerefPattern2Zero );
    dprintf( "  First Frags Count = %d\n", pProtocol->FirstFragsCount );
    dprintf( "  Last Frags Count = %d\n", pProtocol->LastFragsCount );
    dprintf( "\n" );
    dprintf( "  Inserted PH= %d\n", pProtocol->InsertedPH );
    dprintf( "  Removed PH= %d\n", pProtocol->RemovedPH );
    dprintf( "  Inserted Rz= %d\n", pProtocol->InsertedRz );
    dprintf( "  Removed Rz= %d\n", pProtocol->RemovedRz );
    dprintf( "  Inserted CH= %d\n", pProtocol->InsertedCH );
    dprintf( "  Removed CH= %d\n", pProtocol->RemovedCH );

}




DECLARE_API( pattern )

/*++

Function Description:

    This function prints all the pattern in the QoS CF list.
    If args is specified it is used as the blob addr.

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetPattern = 0;
    PATTERN_BLOCK       LocalPattern;
    char                        *lerr;

    if ( args )
        TargetPattern = GetExpression( args );

    if (TargetPattern) {

        if ( !ReadMemory( TargetPattern,
                          &LocalPattern,
                          sizeof(LocalPattern),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetPattern );

        } else {

            PrintPattern( &LocalPattern );
        }
        return;
    }

#if 0
    //
    // scan the blob list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }
#endif

}




DECLARE_API( stat )

/*++

Function Description:

    This function prints all the stat structure

--*/

{
    DWORD                       TargetStat;
    GPC_STAT            LocalStat;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;

    TargetStat = GetExpression( "MSGPC!glStat" );

    if( !TargetStat )
    {
        dprintf( "Can't find the address of 'glStat'" );
        return;
    }

    if ( !ReadMemory( TargetStat,
                      &LocalStat,
                      sizeof(LocalStat),
                      &result ) ) {

        dprintf( "Can't read memory from 0x%x", TargetStat );

    } else {

        PrintStat( &LocalStat );
    }

}

DECLARE_API( autopatterns )

/*++

Function Description:

    This function prints all the CF in the list. If args is specified, only that CF
    will be printed. Currently these are supported:

    0 - for CF_QOS

--*/

{
    DWORD               TargetGlobalData, TargetProtocolBlock;
    GLOBAL_BLOCK        LocalGlobalData;
    PROTOCOL_BLOCK      LocalProtocolBlock;
    PLIST_ENTRY         pHead, pEntry;
    LIST_ENTRY          listentry;
    DWORD               TargetPattern;
    PATTERN_BLOCK       LocalPattern;
    ULONG               result;
    INT                 i, j;
    ULONG               CfIndex = (-1);
    char                *lerr;

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //
    TargetProtocolBlock = (DWORD) LocalGlobalData.pProtocols;
    if ( !ReadMemory(
                     TargetProtocolBlock,
                     &LocalProtocolBlock,
                     sizeof(LocalProtocolBlock),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetProtocolBlock );
        return;
    }

    for (i = 0; i < NUMBER_OF_WHEELS; i++) {

        j = 0;

        pHead = (PLIST_ENTRY) ((DWORD)TargetProtocolBlock + (i * sizeof(listentry)));
        pEntry = LocalProtocolBlock.TimerPatternList[i].Flink;
        dprintf("Printing TimerWheel %d Head = %X and pEntry = %X ******************\n", i, pHead, pEntry);

        while ( (pHead != pEntry) && (j < 1000) ) {

            j++;
            TargetPattern = (DWORD)CONTAINING_RECORD( pEntry, PATTERN_BLOCK, TimerLinkage );

            if ( !ReadMemory( TargetPattern,
                              &LocalPattern,
                              sizeof(LocalPattern),
                              &result ) ) {

                dprintf( "Can't read memory from 0x%x", TargetPattern );

            } else {

                dprintf("Pattern = %X and ClassificationBlock = %X\n", TargetPattern, LocalPattern.pClassificationBlock);
                // PrintPattern( &LocalPattern );
            }

            pEntry = LocalPattern.TimerLinkage.Flink;

        }
    }
    dprintf("Done printing all Timer Wheels\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
* 10/06/98 Rajeshsu edited to use wdbgexts.h
\***************************************************************************/

#define DsoPrint(x) dprintf("%.*s", nIndent, "                      "); dprintf x

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define EvalExp (PVOID)GetExpression

#define EXACT_MATCH 0xFFFF

int gnIndent = 0; // caller should set and restore this appropriately.

VOID moveBlock(
    PVOID pdst,
    PVOID src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;
    
    try {
        if (!ReadMemory((DWORD_PTR)src, pdst, size, &Result)) {
            fSuccess = FALSE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //dprintf(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        dprintf("moveBlock(%x, %x, %x) failed.\n", pdst, src, size);
    }
}


/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dsoGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * If dwSize is EXACT_MATCH, we try an exact
     * case sensitive match
     */
    if (dwSize == EXACT_MATCH) {
        while (pst->pszName != NULL) {
            if (!strcmp(pszStruct, pst->pszName)) {
                return pst;
            }
            pst++;
        }
        return NULL;
    }
    /*
     * Try an exact case insensitive match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
* 05/12/97 MCostea Added bit field support
\***************************************************************************/

#define NFIELDS 2  // per row.

BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst, pstNested;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    int   cBFStart, cBFLength;   /* for printing bit field values: keeps count of field location */
    char* pTmp;
    DWORD dwMask;
    BOOL  fBF;
    int   cBF;                   /* no of dwords this set of bit-fields spread till now */
    int   cchName;               /* length of field name */
    int   nIndent = gnIndent;    /* amount to indent */

    UNREFERENCED_PARAMETER(opts);

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dsoGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        DsoPrint(("Structure not found: %s\n", pszCmdLine));
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                DsoPrint(("Field not found: %s. Struct: %s\n", pszField, pst->pszName));
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }
    
        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);

        DsoPrint(("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize));

        /*
         * Try to see if the fields are not nested structures
         */
        if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
            /*
             * Probably the field is a nested structure
             */
            if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                DWORD dwNestedOffset = dsoGetOffset(psot);
                char cmdLine[80];
                DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                if (pAddress) {
                    sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                    pTmp = cmdLine;
                }
                else {
                    pTmp = psot->pszField;
                }
                return Idso(opts, pTmp);
            }
        }

        DsoPrint(("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset));
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        DsoPrint(("Address   Value\n"));

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            DsoPrint(("%p  ", (DWORD_PTR)((PBYTE)pAddress + dwOffset + dwBytesRead)));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                DsoPrint(("%08lx ", *((DWORD *)pBufferOffset)));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                DsoPrint(("%0*lx", dwMoveSize * 2, dwValue));
            }
            dprintf("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    if (pAddress != NULL) {
        DsoPrint(("Structure %s %#lx - Size: %#lx", pst->pszName, pAddress, pst->dwSize));
    } else {
        DsoPrint(("Structure %s - Size: %#lx", pst->pszName, pst->dwSize));
    }

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = NFIELDS;
    cBFStart = 0;
    cBF = 0;

    /*
     * Loop through all fields in the table. Print one field per loop
     */

    while (psot->pszField != NULL) {

        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == NFIELDS) {
            dprintf("\n");
            dwFieldsPerRow = 1;
            cchName = 24 - gnIndent/NFIELDS;
            nIndent = gnIndent;
            // Print("cchName = %d\n", cchName);
        } else {
            dwFieldsPerRow++;
            cchName = 24 - (gnIndent + 1)/NFIELDS;
            nIndent = 0;
            // Print("cchName = %d\n", cchName);
        }

        /*
         * -v functionality
         * Try to see if the fields are not nested structures
         * The naming convention assigns Uppercase names for them
         */
        if (opts & OFLAG(v)) {
            if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
                /*
                 * Probably the field is a nested structure
                 */
                if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                    DWORD dwNestedOffset = dsoGetOffset(psot);
                    char cmdLine[80];
                    DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                    if (pAddress) {
                        sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                        pTmp = cmdLine;
                    }
                    else {
                        pTmp = psot->pszField;
                    }
                    Idso(opts, pTmp);
                    dwOffsetNext = dsoGetOffset(psot + 1);
                    dwFieldsPerRow = 0;
                    goto Continue;
                }
            }
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            DsoPrint(("%03lx %-*.*s", dsoGetOffset(psot),
                      cchName, cchName, psot->pszField));
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);

            /*
             * Deal with bit fields
             */
            fBF = FALSE;
            pTmp = psot->pszField;
            while (*pTmp) {
                if (*pTmp++ == ':') {

                    fBF = TRUE;
                    while ((*pTmp == ' ') || (*pTmp == '\t')) {     /* skip white spaces */
                        ++pTmp;
                    }
                    cBFLength = *(pTmp++) - '0';      /* now get the bit size, maybe 2 digits */
                    if ((*pTmp >= '0') && (*pTmp <= '9'))
                        cBFLength = cBFLength*10 + (*pTmp - '0');

                    if (cBFStart == 0) {
                        DsoPrint(("(%03lx) %08lx BIT FIELDS\n", dwOffset, dwValue));
                        dwFieldsPerRow = 1;
                    }
                    else if (cBFStart >= 8*sizeof(DWORD)) {   /* check for multi-dword fields */
                        cBF ++;
                        cBFStart %= 8*sizeof(DWORD);
                    }

                    dwMask = (1L << cBFLength) - 1;
                    dwMask <<= cBFStart;
                    /* print byte offset and the bit offset inside it */
                    DsoPrint(("(%03lx) (%d)   %-2x %-*.*s", dwOffset + cBF*sizeof(DWORD) + cBFStart/8, cBFStart & 7,
                           (dwMask & dwValue) >> cBFStart,
                            cchName, cchName, psot->pszField));
                    cBFStart += cBFLength;
                    cBFLength = 0;
                    break;
                }
            }
            if (!fBF) {
                int width = 8;
                if (dwSize == sizeof(BYTE)) {
                    dwValue &= 0xff;
                    width = 2;
                } else if (dwSize == sizeof(WORD)) {
                    dwValue &= 0xffff;
                    width = 4;
                }
                DsoPrint(("(%03lx) %*s%0*lx %-*.*s", dwOffset, 8 - width, "", width, dwValue,
                          cchName, cchName, psot->pszField));
                cBFStart = 0;
                cBF = 0;
            }

        } /* if (pAddress == NULL) */

Continue:
        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    dprintf("\n");

    return TRUE;
}

DECLARE_API( psdso )
{
    LPSTR pszCmdLine = (LPSTR)args;
    DWORD opts = 0;

    Idso(opts, pszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\pclass\proxy\gpcprx.c ===
#include <ndis.h>
#include <ntddndis.h>
#include <cxport.h>

#include "gpcifc.h"
#include "gpcstruc.h"

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gpcprx.c

Abstract:

    A GPC proxy to load msgpc.sys on demand

Author:

    Ofer Bar (Oferbar)  Nov 7, 1997

Environment:

    Kernel Mode

Revision History:


--*/


NTSTATUS
NTAPI
ZwLoadDriver(
	IN PUNICODE_STRING Name
    );

NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSTATUS
GpcInitialize(
	OUT	PGPC_EXPORTED_CALLS		pGpcEntries
    )
{
    NTSTATUS			Status;
    OBJECT_ATTRIBUTES	ObjAttr;
    HANDLE				FileHandle;
    IO_STATUS_BLOCK		IoStatusBlock;
    UNICODE_STRING		DriverName;
    UNICODE_STRING		DeviceName;

    ASSERT(pGpcEntries);

    RtlZeroMemory(pGpcEntries, sizeof(GPC_EXPORTED_CALLS));

    RtlInitUnicodeString(&DriverName, 
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Gpc");

    RtlInitUnicodeString(&DeviceName, DD_GPC_DEVICE_NAME);

    InitializeObjectAttributes(&ObjAttr,
                               &DeviceName,
                               0,
                               NULL,
                               NULL
                               );
    
    Status = ZwCreateFile(
                          &FileHandle,
                          GENERIC_READ | GENERIC_WRITE,
                          &ObjAttr,
                          &IoStatusBlock,
                          0,						// AllocationSize
                          FILE_ATTRIBUTE_NORMAL,	// FileAttributes
                          0,						// ShareAccess
                          FILE_OPEN_IF,				// CreateDisposition
                          0,						// CreateOptions
                          NULL,						// EaBuffer
                          0							// EaLength
                          );

    if (Status != STATUS_SUCCESS) {

        //
        // The GPC is not loaded yet, so we need to load it now
        // 

        Status = ZwLoadDriver(&DriverName);

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        // try again...
        //

        Status = ZwCreateFile(&FileHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &ObjAttr,
                              &IoStatusBlock,
                              0,						// AllocationSize
                              FILE_ATTRIBUTE_NORMAL,	// FileAttributes
                              0,						// ShareAccess
                              FILE_OPEN_IF,				// CreateDisposition
                              0,						// CreateOptions
                              NULL,						// EaBuffer
                              0							// EaLength
                              );
     
        if (Status != STATUS_SUCCESS) {

            return Status;
        }
    }

    Status = ZwDeviceIoControlFile(FileHandle,
                                   NULL,				// Event
                                   NULL,				// ApcRoutine
                                   NULL,				// ApcContext
                                   &IoStatusBlock,
                                   IOCTL_GPC_GET_ENTRIES,
                                   NULL,
                                   0,
                                   (PVOID)pGpcEntries,
                                   sizeof(GPC_EXPORTED_CALLS)
                                   );
    
    pGpcEntries->Reserved = FileHandle;
    
    return Status;
}



NTSTATUS
GpcDeinitialize(
	IN	PGPC_EXPORTED_CALLS		pGpcEntries
    )
{
    NTSTATUS	Status;

    Status = ZwClose(pGpcEntries->Reserved);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(pGpcEntries, sizeof(GPC_EXPORTED_CALLS));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\kdutil.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdutil.h

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

/* Prototypes of the utilities */

ushort IPHeaderXsum(void *Buffer, int Size);

//
// Useful macros
//
#define KD_READ_MEMORY(Target, Local, Size)                                               \
{                                                                                         \
    ULONG _BytesRead;                                                                     \
    BOOL  _Success;                                                                       \
                                                                                          \
    _Success = ReadMemory( (ULONG_PTR)(Target), (Local), (Size), &_BytesRead);                \
                                                                                          \
    if(_Success == FALSE) {                                                               \
        dprintf("Problem reading memory at 0x%x for %d bytes \n", Target, Size);          \
        return;                                                                     \
    }                                                                                     \
    if(_BytesRead < (Size)) {                                                            \
        dprintf("Memory 0x%x. Wrong byte count. Expected to read %d, read %d \n", Target,(Size),(_BytesRead)); \
        return;                                                                     \
    }                                                                                     \
}

VOID
DumpGpcClientVc(PCHAR indent, PGPC_CLIENT_VC TargetVc, PGPC_CLIENT_VC LocalVc);

VOID
DumpCallParameters(
    PGPC_CLIENT_VC Vc,
    PCHAR Indent
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\kdutil.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdutil.c

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#include "precomp.h"

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
ULONG                  GpcClientVcTag = '1CSP';

PCHAR ClientVCState[] = { 
    "", 
    "CL_VC_INITIALIZED", 
    "CL_CALL_PENDING",
    "CL_INTERNAL_CALL_COMPLETE",
    "CL_CALL_COMPLETE", 
    "CL_MODIFY_PENDING",
    "CL_GPC_CLOSE_PENDING", 
    "CL_INTERNAL_CLOSE_PENDING"
};

PCHAR ServiceTypeLabels[] = {
    "No Traffic",
    "Best Effort",
    "Controlled Load",
    "Guaranteed",
    "Network Unavailable",
    "General Information",
    "No Change",
    "",
    "",
    "Non Conforming",
    "Network Control",
    "Custom1",
    "Custom2",
    "Custom3"
};

PCHAR SDMode[]= {
    "Borrow",
    "Shape",
    "Discard",
    "Borrow Plus"};

ushort
IPHeaderXsum(void *Buffer, int Size)
{
    ushort  UNALIGNED *Buffer1 = (ushort UNALIGNED *)Buffer; // Buffer expres
    ulong   csum = 0;

    while (Size > 1) {
        csum += *Buffer1++;
        Size -= sizeof(ushort);
    }

    if (Size)
        csum += *(uchar *)Buffer1;              // For odd buffers, add in la

    csum = (csum >> 16) + (csum & 0xffff);
    csum += (csum >> 16);
    return (ushort)~csum;
}


VOID
CheckVersion(
    VOID
    )
{
#if 0
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target "
                "system(%d %s)\r\n\r\n", VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target "
                "system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
#endif
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
DumpGpcClientVc(PCHAR indent, PGPC_CLIENT_VC TargetClientVC, PGPC_CLIENT_VC LocalClientVC) 
{
    PWSTR  Name;
    ULONG bytes;

#if DBG
    if ( LocalClientVC->LLTag != GpcClientVcTag ) {
        dprintf( "%s ClientVC @ %08X has the wrong type \n", indent, TargetClientVC );
        return;
    }
#endif

    dprintf( "%s ClientVC @ %08X\n\n", indent, TargetClientVC );

    dprintf( "%s Refcount               = %d \n", indent, LocalClientVC->RefCount);
    dprintf( "%s VC State               = %s\n", indent, ClientVCState[ LocalClientVC->ClVcState ]);
    dprintf( "%s Adapter                = 0x%x \n", indent, LocalClientVC->Adapter);
    dprintf( "%s Flags                  = 0x%x \n", indent, LocalClientVC->Flags);
    dprintf( "%s Lock                   @ %08X \n", indent, &TargetClientVC->Lock);

    if(LocalClientVC->InstanceName.Length) {
        bytes = LocalClientVC->InstanceName.Length;
        Name = (PWSTR)malloc( bytes );
        if ( Name != NULL ) {
            KD_READ_MEMORY((LocalClientVC->InstanceName.Buffer), Name, bytes);
        }
    }
    else {
        Name = 0;
    }
    dprintf( "%s Instance Name          = %ws \n", indent, Name);
    dprintf( "%s CfInfo Handle          = %08X \n", indent, LocalClientVC->CfInfoHandle);
    dprintf( "%s CfType                 = %d \n", indent, LocalClientVC->CfType);
    dprintf( "%s TOS non conforming     = %X \n", indent, LocalClientVC->IPPrecedenceNonConforming);
    dprintf( "%s 802.1p conforming      = %X \n", indent, LocalClientVC->UserPriorityConforming);
    dprintf( "%s 802.1p non conforming  = %X \n", indent, LocalClientVC->UserPriorityNonConforming);

    dprintf( "%s Flow Context           = %x \n", indent, LocalClientVC->PsFlowContext);
    dprintf( "%s TokenRateChange        = %x \n", indent, LocalClientVC->TokenRateChange);

    //
    // Control by a flag later on.... to much junk otherwize
    //

    if(LocalClientVC->CallParameters) {

        dprintf("%s Call Parameters \n", indent);

        DumpCallParameters(LocalClientVC, "    ");
    }

    if(Name)
        free(Name);

    return;
}

VOID
DumpFlowSpec(
    PFLOWSPEC Flow,
    PCHAR Indent
    )
{
    dprintf( "%sTokenRate          = %u (%08X)\n", Indent, Flow->TokenRate, Flow->TokenRate );
    dprintf( "%sTokenBucketSize    = %u (%08X)\n", Indent, Flow->TokenBucketSize, Flow->TokenBucketSize );
    dprintf( "%sPeakBandwidth      = %u (%08X)\n", Indent, Flow->PeakBandwidth, Flow->PeakBandwidth );
    dprintf( "%sLatency            = %u (%08X)\n", Indent, Flow->Latency, Flow->Latency );
    dprintf( "%sDelayVariation     = %u (%08X)\n", Indent, Flow->DelayVariation, Flow->DelayVariation );

    if ( (LONG)(Flow->ServiceType) != -1 ) {

        dprintf( "%sServiceType    = %s\n", Indent, ServiceTypeLabels[ Flow->ServiceType ] );
    } else {

        dprintf( "%sServiceType    = Unspecified\n", Indent );
    }

    dprintf( "%sMaxSduSize         = %u (%08X)\n", Indent, Flow->MaxSduSize, Flow->MaxSduSize );
    dprintf( "%sMinimumPolicedSize = %u (%08X)\n", Indent, Flow->MinimumPolicedSize, Flow->MinimumPolicedSize );
}

VOID
DumpSpecific(
    ULONG Length,
    PCO_CALL_MANAGER_PARAMETERS TargetCMParams,
    PCHAR Indent
    )
{
    LONG ParamsLength;
    LPQOS_OBJECT_HDR lQoSObject = malloc(Length);
    CO_CALL_MANAGER_PARAMETERS CM;
    ULONG Address;

    if(!lQoSObject)
        return;

    Address = (ULONG)TargetCMParams +  FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    KD_READ_MEMORY(Address,
                   lQoSObject, 
                   Length);

    ParamsLength = Length;

    while(ParamsLength > 0) {

        switch(lQoSObject->ObjectType) {

          case QOS_OBJECT_SHAPING_RATE:
          {
              LPQOS_SHAPING_RATE pShapingRate = (LPQOS_SHAPING_RATE)(lQoSObject);
              dprintf("%s QOS_OBJECT_SHAPING_RATE (Shaping Rate = %d (0x%x) \n", Indent,
                      pShapingRate->ShapingRate, pShapingRate->ShapingRate);
              break;
          }

          case QOS_OBJECT_DS_CLASS:
          {
              LPQOS_DS_CLASS pDClass = (LPQOS_DS_CLASS)(lQoSObject);
              dprintf("%s QOS_OBJECT_DS_CLASS (DSCP = %d (0x%x) \n", Indent,
                      pDClass->DSField, pDClass->DSField);
              break;

          }

          case QOS_OBJECT_TRAFFIC_CLASS:
          {
              LPQOS_TRAFFIC_CLASS pDClass = (LPQOS_TRAFFIC_CLASS)(lQoSObject);
              dprintf("%s QOS_OBJECT_TRAFFIC_CLASS (DSCP = %d (0x%x) \n", Indent,
                      pDClass->TrafficClass, pDClass->TrafficClass);
              break;

          }

          case QOS_OBJECT_PRIORITY:
          {
              LPQOS_PRIORITY pPri = (LPQOS_PRIORITY)(lQoSObject);
              dprintf("%s QOS_OBJECT_PRIORITY \n", Indent);
              dprintf("%s%s SendPriority = %d \n", Indent, Indent, pPri->SendPriority);
              dprintf("%s%s RecvPriority = %d \n", Indent, Indent, pPri->ReceivePriority);
              dprintf("%s%s SendFlags    = %d \n", Indent, Indent, pPri->SendFlags);
              break;
          }

          case QOS_OBJECT_SD_MODE:
          {
              LPQOS_SD_MODE pSDMode = (LPQOS_SD_MODE)(lQoSObject);
              dprintf("%s QOS_OBJECT_SD_MODE (SD mode = %s) \n", 
                      Indent, 
                      SDMode[pSDMode->ShapeDiscardMode]);
              break;
          }

          case QOS_OBJECT_DIFFSERV:
          {
              LPQOS_DIFFSERV qD = (LPQOS_DIFFSERV)(lQoSObject);
              ULONG DSFieldCount = qD->DSFieldCount;
              LPQOS_DIFFSERV_RULE pDiffServRule = (LPQOS_DIFFSERV_RULE) qD->DiffservRule;
              ULONG i;

              dprintf("%s QOS_OBJECT_DIFFSERV \n\n", Indent);

              for(i=0; i<DSFieldCount; i++, pDiffServRule++) {

                  dprintf("%s%sInboundDSField        = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->InboundDSField,
                          pDiffServRule->InboundDSField);

                  dprintf("%s%sConforming     DS     = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->ConformingOutboundDSField,
                          pDiffServRule->ConformingOutboundDSField);

                  dprintf("%s%sNon Conforming DS     = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->NonConformingOutboundDSField,
                          pDiffServRule->NonConformingOutboundDSField);

                  dprintf("%s%sConforming     802.1p = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->ConformingUserPriority,
                          pDiffServRule->ConformingUserPriority);

                  dprintf("%s%sNon Conforming 802.1p = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->NonConformingUserPriority,
                          pDiffServRule->NonConformingUserPriority);

                  dprintf("\n");
              }

              break;
          }

              
        }

        if(
            ((LONG)lQoSObject->ObjectLength <= 0) ||
            ((LONG)lQoSObject->ObjectLength > ParamsLength)
            ){

            return;
        }

        ParamsLength -= lQoSObject->ObjectLength;
        lQoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)lQoSObject + 
                                       lQoSObject->ObjectLength);
    }

    if(lQoSObject) {

        free(lQoSObject);
    }

}

VOID
DumpCallParameters(
    PGPC_CLIENT_VC Vc,
    PCHAR Indent
    )
{
    PCO_CALL_PARAMETERS     tCp = Vc->CallParameters;
    CO_CALL_PARAMETERS     lCp;
    LONG bytes = sizeof( CO_CALL_MANAGER_PARAMETERS );
    LONG IndentLen;
    PCHAR NewIndent;

    IndentLen = strlen( Indent );

    NewIndent = malloc( IndentLen + 8 );

    if(!NewIndent)
        return;

    strcpy( NewIndent, Indent );
    strcat( NewIndent, "        " );

    //
    // Read CallParameters out of memory
    //
    KD_READ_MEMORY(tCp, &lCp, sizeof(CO_CALL_PARAMETERS));

    //
    // Dump it
    //

    dprintf("%sFlags                0x%x \n", Indent, lCp.Flags);
    dprintf("%sCallManager Parameters \n", Indent);
    
    {
        //
        // read CMParams struct out of target's memory
        //
        CO_CALL_MANAGER_PARAMETERS LocalCMParams;
        PCO_CALL_MANAGER_PARAMETERS TargetCMParams;
        
        TargetCMParams = lCp.CallMgrParameters;
        KD_READ_MEMORY((ULONG)TargetCMParams, &LocalCMParams,sizeof( CO_CALL_MANAGER_PARAMETERS));

        dprintf( "%s    Transmit\n", Indent );
        DumpFlowSpec( &LocalCMParams.Transmit, NewIndent );

        dprintf( "%s    Receive\n", Indent );
        DumpFlowSpec( &LocalCMParams.Receive, NewIndent );

        dprintf( "%s    Specific\n", Indent );
        DumpSpecific( LocalCMParams.CallMgrSpecific.Length, 
                      TargetCMParams, 
                      NewIndent );
    }
    dprintf("%sMediaParameters \n", Indent);
    {
        CO_MEDIA_PARAMETERS             lM;
        PCO_MEDIA_PARAMETERS    pM;
        
        pM = lCp.MediaParameters;
        KD_READ_MEMORY((ULONG)pM, &lM,sizeof(CO_MEDIA_PARAMETERS));
        dprintf( "%s    Flags            %x \n", Indent, lM.Flags);
        dprintf( "%s    ReceivePriority  %x \n", Indent, lM.ReceivePriority );
        dprintf( "%s    ReceiveSizeHint  %x \n", Indent, lM.ReceiveSizeHint );
        dprintf( "%s    Specific\n", Indent );
        //DumpSpecific( &lM.MediaSpecific, NewIndent );
    }

    free( NewIndent );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\logger.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This function contains some example KD debugger extensions

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// Forward function definitions 

PCHAR
FindPreamble(
    CHAR * BufferPointer,
    BOOLEAN FirstTime
    );

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR 
ParseOidRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseTimeRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseStringRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseSchedRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseRecvRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseSendRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

static PCHAR SchedModules[] = {
    "NOP",
    "TB CONFORMER",
    "SHAPER",
    "DRR SEQ",
    "CBQ"};

static PCHAR SchedActions[] = {
    "NOP",
    "ENQUEUE",
    "DEQUEUE",
    "CONFORMANCE",
    "DISCARD"};

static PCHAR SendRecvActions[] = {
    "",
    "ENTER",
    "NO_RESOURCES",
    "LOW_RESOURCES",
    "INDICATING",
    "RETURNED",
    "NOT_OURS",
    "OURS",
    "RETURNING",
    "TRANSFERRING",
    "NOT READY"};

static PCHAR RecvEvents[] = {
    "",
    "CL_RECV_PACKET",
    "MP_RETURN_PACKET",
    "CL_RECV_INDICATION",
    "CL_RECV_COMPLETE",
    "MP_TRANSFER_DATA",
    "CL_TRANSFER_COMPLETE"};

static PCHAR SendEvents[] = {
    "",
    "MP_SEND",
    "MP_CO_SEND",
    "DUP_PACKET",
    "DROP_PACKET",
    "CL_SEND_COMPLETE" };

        

//
// globals
//

CHAR Preamble[] = {(CHAR)0xef,(CHAR)0xbe,(CHAR)0xad,(CHAR)0xde};

ULONG  ByteCheck = 0;
ULONG  SafetyLimit;

BOOL
SafeRead(
    DWORD offset, 
    LPVOID lpBuffer, 
    DWORD cb, 
    LPDWORD lpcbBytesRead
    )
{
    if(ByteCheck <= SafetyLimit){
        ReadMemory(offset, lpBuffer, cb, lpcbBytesRead);
        ByteCheck += cb;
        return TRUE;
    }
    else{
        dprintf("SafetyLimit of %d, exceeded, quitting!\n", SafetyLimit);
        return FALSE;
    }
}

DWORD
MyOpenFile (
    IN PCHAR Name,
    IN PWINDBG_OUTPUT_ROUTINE out,
    OUT HANDLE *File
    )

{
    HANDLE hFile;
    hFile = CreateFile(Name,
                          GENERIC_WRITE | GENERIC_READ,
                          0,
                          NULL,
                          CREATE_ALWAYS ,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        out ("MyOpenFile: CreateFile Failed.\n");
    }

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
}

VOID
MyWriteFile (
    PCHAR buffer,
    HANDLE file,
    IN PWINDBG_OUTPUT_ROUTINE out
    )

{
    LONG  len;
    BOOL bRv;
        DWORD dwWritten;

        if (!buffer) {
        out("MyWriteFile: Buffer is null\n");
    }

    len = strlen(buffer);

    bRv = WriteFile( file, buffer, len, &dwWritten, NULL );

    if (!bRv) {
        out("WriteFile: Puked\n");
        }
}

CHAR * BufferBase;          // Start address of trace buffer, in host memory
CHAR * BufferEnd;           // End address of trace buffer, in host memory
CHAR * BufferPointer;       // Current location in host memory buffer
LONG   BufferSize;          // Total size of host memory buffer, in bytes.
LONG   BufferCount;         // Total count of traced bytes.
LONG   TotalValidBytesRead = 0;

#define OUTPUT_ERROR   0
#define OUTPUT_FILE    1
#define OUTPUT_CONSOLE 2

CHAR   FileIt;
HANDLE FileHandle;
ULONG   LineNumber = 0;

DECLARE_API( tt )
{
    DWORD hostAddress;
    CHAR  DeviceName[] = "c:\\tmp\\";
    CHAR  buffer[255];
    DWORD status;
    LONG  pBufferBase;
    LONG  pBufferCount;
    LONG  pBufferSize;
    BOOL  success;
    DWORD bytesread;
    CHAR *s, *dataStart;
    ULONG skip=0;

    char SchedBufBase[]   = {"&psched!SchedTraceBuffer"};
    char SchedCount[]     = {"&psched!SchedTraced"};
    char BuffSize[]       = {"&psched!SchedBufferSize"};

    TotalValidBytesRead = 0;
    LineNumber = 0;
    FileIt = OUTPUT_ERROR;
    
    if ( *args != '\0' ) {

        // First argument is the file name.
        s = strtok((LPSTR)args, " ");

        strcpy( buffer, DeviceName );
        strcat( buffer, s );

        // next arg is the optional args.
        while((s = strtok(NULL, " ")) != NULL)
        {
            if(s[0] == '-')
            {
                switch(s[1])
                {
                  case 's':
                  case 'S':
                      skip = atoi(&s[2]);
                      break;

                  default:
                      dprintf("Usage: !tt [filename] [-S<#>] \n");
                      dprintf("       S : No of records (from head) to skip \n");
                      goto cleanup;

                }
            }
        }
        
        status = MyOpenFile( buffer, dprintf, &FileHandle );
        if ( status == ERROR_SUCCESS ) {
            FileIt = OUTPUT_FILE;
        }
        else {
            goto cleanup;
        }
        dprintf( "handle =%x status=%x FileIt=%d\n", FileHandle, status, FileIt );
    }
    else {
        FileIt = OUTPUT_CONSOLE;
    }

    hostAddress =  GetExpression(SchedBufBase);
    pBufferBase =  (LONG)hostAddress;
    
    if (!pBufferBase){
        dprintf("bad string conversion (%s) \n", SchedBufBase);
        goto cleanup;
    }

    hostAddress  = GetExpression(SchedCount);
    pBufferCount = hostAddress;

    if (!pBufferCount) {
        dprintf( " bad string conversion (%s) \n", SchedCount );
        goto cleanup;
    }

    hostAddress =  GetExpression(BuffSize);
    pBufferSize = hostAddress;

    if (!pBufferSize) {
        dprintf( " bad string conversion (%s) \n", SchedCount );
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferCount, &BufferCount, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferCount, sizeof(LONG));
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferSize, &BufferSize, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferSize, sizeof(LONG));
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferBase, &BufferBase, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferBase, sizeof(LONG));
        goto cleanup;
    }

    SafetyLimit = (ULONG)-1;

    if(!BufferCount){
        dprintf("No data in buffer.\n");
        goto cleanup;
    }

    dprintf("struct@%x, total bytes traced: %d, buffer size: %d\n", BufferBase, BufferCount, BufferSize);

    // Find the starting point. If we haven't wrapped the buffer, it's at BufferBase.
    // If we have wrapped the buffer, we start right after our current pointer.
    // In either case, BufferPointer is the host address at which we should 
    // start looking for data.

    if(BufferCount <= BufferSize){
        BufferPointer = BufferBase;
    }
    else{
        BufferPointer = BufferBase + (BufferCount % BufferSize);
    } 

    BufferEnd = BufferBase + BufferSize;

    // dataStart will point to the first location after the
    // first preamble (in host memory), or - will be zero,
    // indicating that no preamble was found.

    dataStart = FindPreamble(BufferPointer, TRUE);

    if(dataStart){
        ParseBuffer(dataStart, skip);
    }
    else{
        dprintf("Error reading token trace buffer. Could not find preamble.\n");
    }

cleanup:
    if(FileIt == OUTPUT_FILE){
        CloseHandle( FileHandle );
    }
}

PCHAR
FindPreamble(
    CHAR * BufferPointer,
    BOOLEAN FirstTime
    )
{
    LONG count;
    LONG i;
    CHAR * readFrom;
    CHAR hold;
    BOOL success;
    DWORD bytesread;

    count = 0;
    i = 0;

    readFrom = BufferPointer;
    
    while(TRUE){
    
        success = SafeRead((ULONG)readFrom, &hold, 1, &bytesread );

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", readFrom, 1);
            break;
        }

        if(hold == Preamble[i]){
            i++;
        }
        else{
            i=0;
        }

        if(i == sizeof(TRACE_PREAMBLE)){
            if(FirstTime){
                dprintf("Found start of first record at %d.\n", readFrom+1 - BufferBase);
            }
            TotalValidBytesRead += sizeof(TRACE_PREAMBLE);
            readFrom++;
            break;
        }

        readFrom++;

        if(readFrom > BufferEnd){
            readFrom = BufferBase;
        }

        count++;

        if(count == TRACE_BUFFER_SIZE){
            readFrom = 0;
            break;
        }
    }

    return(readFrom);
}

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG  SkipCnt
    )
{
    CHAR * dataStart;
    CHAR * recordEnd;
    LONG records;
    BOOL success;
    CHAR hold;
    DWORD bytesread;

    records = 0;
    dataStart = DataStart;

    while(TRUE){

        success = SafeRead((ULONG)dataStart, &hold, 1, &bytesread );

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", dataStart, 1);
            break;
        }

        switch(hold){

        case RECORD_TSTRING:

            recordEnd = ParseStringRecord(dataStart, SkipCnt);
            break;

        case RECORD_OID:
            recordEnd = ParseOidRecord(dataStart,  SkipCnt);
            break;

        case RECORD_SCHED:

            recordEnd = ParseSchedRecord(dataStart,  SkipCnt);
            break;

        case RECORD_RECV:
            recordEnd = ParseRecvRecord(dataStart,  SkipCnt);
            break;

        case RECORD_SEND:
            recordEnd = ParseSendRecord(dataStart,  SkipCnt);
            break;
        default:

            dprintf("Unrecognized record type!\n");
        }

        records++;

        if(TotalValidBytesRead >= BufferCount){
            dprintf("\nCompleted parsing trace buffer. %d records found.\n", records);
            break;
        }

        dataStart = FindPreamble(recordEnd, FALSE);

        if(dataStart == DataStart){
            dprintf("\nCompleted parsing trace buffer. %d records found.\n", records);
            break;
        }
    }
}
    
VOID
GetBytesToRead(
    CHAR * DataStart,
    LONG RecordSize,
    LONG * BytesToReadFirst,
    LONG * BytesToReadNext
    )
{
    if((DataStart + RecordSize - sizeof(TRACE_PREAMBLE)) > BufferEnd){
        *BytesToReadFirst = BufferEnd - DataStart;
        *BytesToReadNext = RecordSize - sizeof(TRACE_PREAMBLE) - *BytesToReadFirst;
    }
    else{
        *BytesToReadFirst = RecordSize - sizeof(TRACE_PREAMBLE);
        *BytesToReadNext = 0;
    }
}

PCHAR
ParseAnyRecord(
    CHAR * DataStart,
    CHAR * Record,
    LONG   RecordSize
    )
{
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    GetBytesToRead(DataStart, RecordSize, &bytesToReadFirst, &bytesToReadNext);
    pRecordData = Record + sizeof(TRACE_PREAMBLE);
    
    success = SafeRead((ULONG)DataStart, pRecordData, bytesToReadFirst, &bytesread );
    TotalValidBytesRead += bytesToReadFirst;

    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", DataStart, 1);
    }

    nextDataStart = DataStart + bytesToReadFirst;

    if(bytesToReadNext){

        success = SafeRead((ULONG)BufferBase, 
                             pRecordData + bytesToReadFirst, 
                             bytesToReadNext, 
                             &bytesread);

        TotalValidBytesRead += bytesToReadNext;

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", BufferBase, 1);
        }

        nextDataStart = BufferBase + bytesToReadNext;
    }

    return(nextDataStart);
}

PCHAR 
ParseOidRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_OID record;
    CHAR buffer[255];
    CHAR * nextDataStart;
    static PCHAR OIDActions[] = 
    {
        "",
        "MpSetInformation",
        "MpQueryInformation",
        "SetRequestComplete",
        "QueryRequestComplete"
    };

    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_OID));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    if(record.Now.QuadPart){

        wsprintf(buffer, "[%4d]:[%u.%u]: OID: %5s:%9s:%08X:%08X:%08X \n",
                 LineNumber,
                 record.Now.HighPart,
                 record.Now.LowPart,
                 OIDActions[record.Action],
                 record.Local == TRUE?"Local":"Non Local",
                 record.Adapter,
                 record.Oid,
                 record.Status);
    }
    else {
        wsprintf(buffer, "[%4d]: OID: %5s:%9s:%08X:%08X:%08X \n",
                 LineNumber,
                 OIDActions[record.Action],
                 record.Local == TRUE?"Local":"Non Local",
                 record.Adapter,
                 record.Oid,
                 record.Status);
    }

    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}


PCHAR
ParseStringRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_STRING record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_STRING));

    if(++LineNumber < SkipCnt)
        return nextDataStart;

    if(record.Now.QuadPart){
        wsprintf(buffer, "[%4d]:[%u.%u]:%s",
                LineNumber,
                record.Now.HighPart,
                record.Now.LowPart,
                record.StringStart);
    }
    else{
        wsprintf(buffer, "[%4d]:%s",
                LineNumber,
                record.StringStart);
    }
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseSchedRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_SCHED record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    ULONG now;
    CHAR buffer[255];
    LARGE_INTEGER ConformanceTime;
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_SCHED));
    if(++LineNumber < SkipCnt)
        return nextDataStart;
    ConformanceTime.QuadPart = record.ConformanceTime;

    wsprintf(buffer,
            "[%4d]:[%u.%u]:%s:VC %x:%x:%u:%s:%d:%d:%u:%u\n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            SchedModules[record.SchedulerComponent],
            record.VC,
            record.Packet,
            record.PacketLength,
            SchedActions[record.Action],
            record.Priority,
            ConformanceTime.HighPart,
            ConformanceTime.LowPart,
            record.PacketsInComponent);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseRecvRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_RECV record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, 
                                   sizeof(TRACE_RECORD_RECV));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    wsprintf(buffer,
            "[%4d]:[%u.%u]:Adapter %08X:%s:%s:%x:%x \n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            record.Adapter,
            RecvEvents[record.Event],
            SendRecvActions[record.Action],
            record.Packet1,
            record.Packet2);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseSendRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_SEND record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, 
                                   sizeof(TRACE_RECORD_SEND));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    wsprintf(buffer,
            "[%4d]:[%u.%u]:Adapter %08X:%s:%s:%x:%x:%x\n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            record.Adapter,
            SendEvents[record.Event],
            SendRecvActions[record.Action],
            record.Vc,
            record.Packet1,
            record.Packet2);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\kdps.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdps.c

Abstract:

    Packet scheduler KD extension  

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#include "precomp.h"
#include <winsock.h>


//
// forwards
//

//
// globals
//

PCHAR AdapterMode[] = {
    "",
    "Diffserv",
    "RSVP"
};

PCHAR AdapterState[] = { 
    "", 
    "AdapterStateInitializing",
    "AdapterStateRunning",
    "AdapterStateWaiting",
    "AdapterStateDisabled",
    "AdapterStateClosing",
    "AdapterStateClosed"
};



/* forwards */

VOID
DumpAdapterStats(
    PPS_ADAPTER_STATS Stats,
    PCHAR Indent
    );

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

DECLARE_API( adapter )
/*
 *   dump a PS adapter structure
 */
{
    PADAPTER     TargetAdapter;
    ADAPTER      LocalAdapter;
    PADAPTER     LastAdapter;
    LIST_ENTRY   LocalListHead;
    PLIST_ENTRY  TargetListHead;
    PWSTR        PSName;
    PWSTR        MPName;
    PWSTR        WMIName;
    PWSTR        ProfileName;
    PWSTR        RegistryPath;
    BOOLEAN      DumpAllAdapters = FALSE;
    ULONG        bytes;

    if ( *args == '\0' ) {

        //
        // run down the adapter list, dumping the contents of each one
        //

        TargetListHead = (PLIST_ENTRY)GetExpression( "PSCHED!AdapterList" );

        if ( !TargetListHead ) {

            dprintf("Can't convert psched!AdapterList symbol\n");
            return;
        }

        PSName = 0;
        MPName = 0;
        WMIName = 0;
        ProfileName = 0;
        RegistryPath = 0;
        //
        // read adapter listhead out of target's memory
        //
        KD_READ_MEMORY(TargetListHead, &LocalListHead, sizeof(LIST_ENTRY));

        TargetAdapter = (PADAPTER)LocalListHead.Flink;

        LastAdapter = (PADAPTER)TargetListHead;

        DumpAllAdapters = TRUE;

    } else {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        LastAdapter = 0;
    }

    while ( TargetAdapter != LastAdapter ) {

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));

        PSName = 0;
        MPName = 0;
        WMIName = 0;
        ProfileName = 0;
        RegistryPath = 0;

        //
        // alloc some mem for the PS and MP device names and get them too
        //
        if(LocalAdapter.UpperBinding.Length) {
            bytes = ( LocalAdapter.UpperBinding.Length + 1);
            PSName = (PWSTR)malloc( bytes );
            if ( PSName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.UpperBinding.Buffer, PSName, bytes-1);
            }
        }

        if(LocalAdapter.MpDeviceName.Length) {
            bytes = ( LocalAdapter.MpDeviceName.Length + 1);
            MPName = (PWSTR)malloc( bytes );
            if ( MPName != NULL ) {
                KD_READ_MEMORY((ULONG)(LocalAdapter.MpDeviceName.Buffer),
                               MPName,
                               bytes-1);
            }
        }

        if(LocalAdapter.WMIInstanceName.Length) {

            bytes = ( LocalAdapter.WMIInstanceName.Length + 1);
            WMIName = (PWSTR)malloc( bytes );
            if ( WMIName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.WMIInstanceName.Buffer, WMIName, bytes-1);
    
            }
        }

        if(LocalAdapter.ProfileName.Length) {
            bytes = ( LocalAdapter.ProfileName.Length + 1 );
            ProfileName = (PWSTR)malloc( bytes );
            if ( ProfileName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.ProfileName.Buffer, ProfileName, bytes-1);
                
            }
        }

        if(LocalAdapter.RegistryPath.Length) {
            bytes = ( LocalAdapter.RegistryPath.Length + 1 );
            RegistryPath = (PWSTR)malloc( bytes );
            if ( RegistryPath != NULL ) {
                KD_READ_MEMORY(LocalAdapter.RegistryPath.Buffer, RegistryPath, bytes-1);
            }

        }

        dprintf( "\nAdapter @ %08X \n\n", TargetAdapter);

        dprintf( "    Next Adapter              @ %08X ", &TargetAdapter->Linkage);
       
        if(&TargetAdapter->Linkage == LocalAdapter.Linkage.Flink) {

            dprintf("  (empty) ");
        }
        dprintf( " \n");

        dprintf( "    Lock                           @ %08X\n", &TargetAdapter->Lock);
        dprintf( "    RefCount                       = %d\n", LocalAdapter.RefCount );
        dprintf( "    MpDeviceName                   = %ws \n", MPName);
        dprintf( "    UpperBinding                   = %ws \n", PSName);
        dprintf( "    WMIInstanceName                = %ws \n", WMIName);
        dprintf( "    ProfileName                    = %ws \n", ProfileName);
        dprintf( "    RegistryPath                   = %ws \n", RegistryPath);
        dprintf( "    MiniportHandle (PsNdisHandle)  = %x \n", LocalAdapter.PsNdisHandle);
        dprintf( "    BindingHandle  (LowerMpHandle) = %x \n", LocalAdapter.LowerMpHandle);

        dprintf( "    Outstanding NDIS request       = %d \n", LocalAdapter.OutstandingNdisRequests);
        
        dprintf( "    ShutdownMask                   = \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY)
            dprintf("           SHUTDOWN_CLOSE_WAN_ADDR_FAMILY \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_DELETE_PIPE      )  
            dprintf("           SHUTDOWN_DELETE_PIPE \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT  )  
            dprintf("           SHUTDOWN_FREE_PS_CONTEXT \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_UNBIND_CALLED    )  
            dprintf("           SHUTDOWN_UNBIND_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_MPHALT_CALLED    )  
            dprintf("           SHUTDOWN_MPHALT_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER   ) 
            dprintf("           SHUTDOWN_CLEANUP_ADAPTER \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_PROTOCOL_UNLOAD    )
            dprintf("           SHUTDOWN_PROTOCOL_UNLOAD \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_BIND_CALLED   )     
            dprintf("           SHUTDOWN_BIND_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_MPINIT_CALLED )
            dprintf("           SHUTDOWN_MPINIT_CALLED \n");
        

        if(!DumpAllAdapters) {
        dprintf( "    IpNetAddressList          @ %08X \n", LocalAdapter.IpNetAddressList);
        dprintf( "    IpxNetAddressList         @ %08X \n", LocalAdapter.IpxNetAddressList);
        dprintf( "    PsMpState                 = %s\n", AdapterState [ LocalAdapter.PsMpState]);
        dprintf( "    BlockingEvent             @ %08X\n", &TargetAdapter->BlockingEvent );
        dprintf( "    FinalStatus               = %08X\n", LocalAdapter.FinalStatus );
        dprintf( "    Media Type                = %d\n", LocalAdapter.MediaType );
        dprintf( "    Total Size                = %d\n", LocalAdapter.TotalSize );
        dprintf( "    HeaderSize                = %d\n", LocalAdapter.HeaderSize );
        dprintf( "    IPHeaderOffset            = %d\n", LocalAdapter.IPHeaderOffset );
        dprintf( "\n");
        
        dprintf( "    Admission Control details \n");
        dprintf( "    ------------------------- \n");
        dprintf( "        RawLinkSpeed              = %d \n", LocalAdapter.RawLinkSpeed);
        dprintf( "        BestEffortLimit           = %d \n", LocalAdapter.BestEffortLimit);
        dprintf( "        NonBestEffortLimit        = %d \n", LocalAdapter.NonBestEffortLimit);
        dprintf( "        ReservationLimitValue     = %d \n", LocalAdapter.ReservationLimitValue);
        dprintf( "        Link Speed                = %dbps\n", LocalAdapter.LinkSpeed);
        dprintf( "        RemainingBandWidth        = %dBps\n", LocalAdapter.RemainingBandWidth );
        dprintf( "        VCIndex                   = %d\n", LocalAdapter.VcIndex.QuadPart );
        dprintf( "        PipeHasResources          = %s \n", LocalAdapter.PipeHasResources ? "TRUE" : "FALSE");
        dprintf( "\n");

        dprintf( "    NDIS Handles, etc \n");
        dprintf( "    ----------------- \n");
        dprintf( "        BindContext               = %08X \n", LocalAdapter.BindContext);
        dprintf( "        Send PacketPoolHandle     = %08X \n", LocalAdapter.SendPacketPool);
        dprintf( "        Recv PacketPoolHandle     = %08X \n", LocalAdapter.RecvPacketPool);

        dprintf( "\n");
        

        dprintf( "    Best Effort VC \n");
        dprintf( "    -------------- \n");
        dprintf( "        BestEffortVc              = %08X \n", &TargetAdapter->BestEffortVc);
        dprintf( "        GPC Client VC List        @ %08X ",   &TargetAdapter->GpcClientVcList);

        if(&TargetAdapter->GpcClientVcList == LocalAdapter.GpcClientVcList.Flink) 
        {
            dprintf( " (empty) ");
        }
        dprintf("\n");
        dprintf( "        CfinfosInstalled          = %d \n", LocalAdapter.CfInfosInstalled);
        dprintf( "        FlowsInstalled            = %d \n", LocalAdapter.FlowsInstalled); 
        
        dprintf( " \n");

        dprintf( "    Scheduling Components \n");
        dprintf( "    --------------------- \n");
        dprintf( "        PsComponent               = %08X \n", LocalAdapter.PsComponent);
        dprintf( "        PsPipeContext             = %08X \n", LocalAdapter.PsPipeContext);
        dprintf( "        PipeContextLength         = %d \n", LocalAdapter.PipeContextLength);
        dprintf( "        FlowContextLength         = %d \n", LocalAdapter.FlowContextLength);
        dprintf( "        PacketContextLength       = %d \n", LocalAdapter.PacketContextLength);
        dprintf( "        ClassMapContextLength     = %d \n", LocalAdapter.ClassMapContextLength);
        dprintf( "        PipeFlags                 = %08X\n", LocalAdapter.PipeFlags );
        dprintf( "        MaxOutstandingSends       = 0x%08X \n", LocalAdapter.MaxOutstandingSends);
        dprintf( "\n");

        dprintf( "\n");
        dprintf( "    NDISWAN \n");
        dprintf( "    ------- \n");
        dprintf( "        WanCmHandle               = %08X \n", LocalAdapter.WanCmHandle);
        dprintf( "        WanBindingState           = %08X \n", LocalAdapter.WanBindingState);
        dprintf( "        WanLinkCount              = %08X \n", LocalAdapter.WanLinkCount);
        dprintf( "        WanLinkList               @ %08X ", &TargetAdapter->WanLinkList);

        if(&TargetAdapter->WanLinkList == LocalAdapter.WanLinkList.Flink) {
            dprintf( " (empty) \n");
        }
        else {
            dprintf( " Next = %08X \n", LocalAdapter.WanLinkList.Flink);
        }
        dprintf( "        ISSLOWPacketSize          = %08X \n", LocalAdapter.ISSLOWPacketSize);
        dprintf( "        ISSLOWFragmentSize        = %08X \n", LocalAdapter.ISSLOWFragmentSize);
        dprintf( "        ISSLOWTokenRate           = %08X \n", LocalAdapter.ISSLOWTokenRate);
        dprintf("\n");
        dprintf( "    Adaptermode               = %s   \n", AdapterMode[LocalAdapter.AdapterMode]);
        }
        dprintf( "\n" );


        if ( PSName != NULL )
            free( PSName );

        if ( MPName != NULL )
            free( MPName );

        if ( WMIName != NULL) 
            free ( WMIName);

        if ( RegistryPath != NULL)
            free(RegistryPath);

        if ( ProfileName != NULL)
            free(ProfileName);

        if ( !DumpAllAdapters ) {

            break;

        } else {

            TargetAdapter = (PADAPTER)LocalAdapter.Linkage.Flink;
        }

        if (CheckControlC()) {
            return;
        }
    }
} // adapter


DECLARE_API( cvc )
{
    GPC_CLIENT_VC LocalClientVC;
    PGPC_CLIENT_VC TargetClientVC;

    if ( *args == '\0' ) {

        dprintf("ClientVC <address of ClientVC structure>\n");
        return;
    }

    TargetClientVC =  (PGPC_CLIENT_VC)GetExpression( args );

    if ( !TargetClientVC) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(TargetClientVC, &LocalClientVC, sizeof(GPC_CLIENT_VC));

    DumpGpcClientVc("", TargetClientVC, &LocalClientVC);

} // cvc


DECLARE_API( astats )
/*
 *   dump an adapter's stats structure
 */
{
    PADAPTER TargetAdapter;
    ADAPTER LocalAdapter;
    PADAPTER LastAdapter;
    LIST_ENTRY LocalListHead;
    PLIST_ENTRY TargetListHead;
    PWSTR Name;
    BOOLEAN DumpAllAdapters = FALSE;
    ULONG bytes;

    if ( *args == '\0' ) {

        //
        // run down the adapter list, dumping the contents of each one
        //

        TargetListHead = (PLIST_ENTRY)GetExpression( "psched!AdapterList" );

        if ( !TargetListHead ) {

            dprintf("Can't convert psched!AdapterList symbol\n");
            return;
        }

        //
        // read adapter listhead out of target's memory
        //
        KD_READ_MEMORY(TargetListHead, &LocalListHead, sizeof(LIST_ENTRY));

        TargetAdapter = (PADAPTER)LocalListHead.Flink;
        LastAdapter = (PADAPTER)TargetListHead;
        DumpAllAdapters = TRUE;

    } else {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );
            return;

        }

        LastAdapter = 0;
    }

    while ( TargetAdapter != LastAdapter ) {

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        //
        // alloc some mem for the name and get that too
        //

        bytes = ( LocalAdapter.WMIInstanceName.Length + 1 ) * sizeof( WCHAR );
        Name = (PWSTR)malloc( bytes );
        if ( Name != NULL ) {

            KD_READ_MEMORY(((PADAPTER)TargetAdapter+1), Name, bytes);

        }

        dprintf( "\nAdapter Stats @ %08X (%ws)\n\n", TargetAdapter, Name );
        DumpAdapterStats( &LocalAdapter.Stats, "    " );

        if ( Name != NULL )
            free( Name );

        if ( !DumpAllAdapters ) {

            break;
        } else {

            TargetAdapter = (PADAPTER)LocalAdapter.Linkage.Flink;
        }

        if (CheckControlC()) {
            return;
        }
    }
} // astats


VOID
DumpAdapterStats(
    PPS_ADAPTER_STATS Stats,
    PCHAR Indent
    )
{
    dprintf( "%sOut of Packets = %d\n", Indent, Stats->OutOfPackets );

    dprintf( "%sFlows Opened = %d\n", Indent, Stats->FlowsOpened );
    dprintf( "%sFlows Closed = %d\n", Indent, Stats->FlowsClosed );
    dprintf( "%sFlows Rejected = %d\n", Indent, Stats->FlowsRejected );
    dprintf( "%sFlows Modified = %d\n", Indent, Stats->FlowsModified );
    dprintf( "%sFlows ModsRejected = %d\n", Indent, Stats->FlowModsRejected );
    dprintf( "%sFlows MaxSimultaneousFlows = %d\n", Indent, Stats->MaxSimultaneousFlows );

}

DECLARE_API( help )
{
    dprintf("PS kd extensions\n\n");
    dprintf("adapter    [address]           - dump adapter structure\n");
    dprintf("astats     [adapter address]   - dump adapter stats\n");
    dprintf("cvc        <address>           - dump client VC struct\n");
    dprintf("diff       <address>           - dump diffserv mapping \n");
    dprintf("fstats     [vc address]        - dump VC stats\n");
    dprintf("help                           - This help screen \n");
    dprintf("iph        <address>           - Dumps the IP header \n");
    dprintf("list       <address>           - Dumps the entries of a list \n");
    dprintf("lock       <address>           - Dumps the lock info \n");
    dprintf("ndisp      <address>           - Dumps the NDIS_PACKET \n");
    dprintf("netl       <address>           - Dumps the NETWORK_ADDRESS_LIST structure \n");
    dprintf("psdso      Struct [<address>]  - Structo on the structure \n");
    dprintf("tt         [<filename>]        - Dumps psched log on c:\\tmp\\<filename> or stdout \n");
    dprintf("upri       <address>           - Dumps the 802.1p value \n");
    dprintf("vc         <adapter address>   - Dumps the list of VCs on an adapter \n");
    dprintf("version                        - Displays version information \n");
    dprintf("wan        <adapter address>   - Dumps the list of WanLinks on an adapter \n");
    dprintf("wanlink    <address>           - Dumps the Wanlink Structure\n");

}

    
DECLARE_API( ndisp )
{
    PNDIS_PACKET TargetPacket;
    NDIS_PACKET  LocalPacket;
    MDL  *CurrentMdl;
    LONG MDLCnt = 0;

    if ( *args == '\0' ) {

        dprintf("ndisp <address of NDIS_PACKET> \n");
        return;
    }

    TargetPacket =  (PNDIS_PACKET)GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY((ULONG)TargetPacket, &LocalPacket, sizeof(NDIS_PACKET));

    dprintf("\nNDIS_PACKET @ %08X \n", TargetPacket);
    dprintf("    Private \n");
    dprintf("        Physical Count         : 0x%x (%d) \n", LocalPacket.Private.PhysicalCount,
            LocalPacket.Private.PhysicalCount);
    dprintf("        TotalLength            : 0x%x (%d) \n", LocalPacket.Private.TotalLength,
            LocalPacket.Private.TotalLength);
    dprintf("        Head                   : 0x%x      \n", LocalPacket.Private.Head);
    dprintf("        Tail                   : 0x%x      \n", LocalPacket.Private.Tail);
    dprintf("        Pool                   : 0x%x      \n", LocalPacket.Private.Pool);
    dprintf("        Count                  : 0x%x (%d) \n", LocalPacket.Private.Count,
            LocalPacket.Private.Count);
    dprintf("        Flags                  : 0x%x (%d) \n", LocalPacket.Private.Flags, 
            LocalPacket.Private.Flags);
    dprintf("        ValidCounts            : 0x%x (%d) \n", LocalPacket.Private.ValidCounts,
            LocalPacket.Private.ValidCounts);
    dprintf("        NdisPacketFlags        : 0x%x (%d) \n", LocalPacket.Private.NdisPacketFlags,
            LocalPacket.Private.NdisPacketFlags);
    dprintf("        NdisPacketOobOffset    : 0x%x (%d) \n", LocalPacket.Private.NdisPacketOobOffset,
            LocalPacket.Private.NdisPacketOobOffset);

    CurrentMdl = LocalPacket.Private.Head;


    while(CurrentMdl != 0) {

        MDL *TargetMdl;
        MDL LocalMdl;
        
        dprintf("\n    MDL # %d\n", ++MDLCnt);
        TargetMdl = CurrentMdl;

        if ( !TargetMdl ) {

            dprintf("bad string conversion (%s) \n", CurrentMdl );
            return;
        }

        //
        // read client struct out of target's memory
        //

        KD_READ_MEMORY( TargetMdl, &LocalMdl, sizeof(MDL));

        dprintf("        Next                   : 0x%x       \n", LocalMdl.Next);
        dprintf("        Size                   : 0x%x (%d)  \n", LocalMdl.Size, LocalMdl.Size);
        dprintf("        MdlFlags               : 0x%x (%d)  \n", LocalMdl.MdlFlags, 
                LocalMdl.MdlFlags);
        dprintf("        Process                : 0x%x       \n", LocalMdl.Process);
        dprintf("        MappedSystemVa         : 0x%x       \n", LocalMdl.MappedSystemVa);
        dprintf("        StartVa                : 0x%x       \n", LocalMdl.StartVa);
        dprintf("        ByteCount              : 0x%x (%d)  \n", LocalMdl.ByteCount, 
                LocalMdl.ByteCount);
        dprintf("        ByteOffset             : 0x%x (%d)  \n", LocalMdl.ByteOffset, 
                LocalMdl.ByteOffset);

        CurrentMdl = LocalMdl.Next;
    }
}

DECLARE_API(iph) 
{
    IPHeader *TargetPacket;
    IPHeader  LocalPacket;
    LONG MDLCnt = 0;

    if ( *args == '\0' ) {

        dprintf("iph <address of IP header> \n");
        return;
    }

    TargetPacket =  (IPHeader *) GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //

    KD_READ_MEMORY(TargetPacket, &LocalPacket, sizeof(IPHeader));

    dprintf("IPHeader @ %08X \n", TargetPacket);
    dprintf("    Version                  : %x \n", (LocalPacket.iph_verlen >> 4 ) & 0x0f);
    dprintf("    Header Length            : %x \n", LocalPacket.iph_verlen & 0x0f);
    dprintf("    TOS                      : %x \n", LocalPacket.iph_tos);
    dprintf("    Length                   : %x \n", ntohs(LocalPacket.iph_length));
    dprintf("    ID                       : %x \n", ntohs(LocalPacket.iph_id));
    dprintf("    Offset                   : %x \n", ntohs(LocalPacket.iph_offset));
    dprintf("    TTL                      : %x \n", LocalPacket.iph_ttl);
    dprintf("    Protocol                 : ");

    switch(LocalPacket.iph_protocol) {
        case 1:
            dprintf("ICMP (%d) \n", LocalPacket.iph_protocol);
            break;
        case 2:
            dprintf("IGMP (%d) \n", LocalPacket.iph_protocol);
            break;
        case 6:
            dprintf("TCP  (%d) \n", LocalPacket.iph_protocol);
            break;
        case 17:
            dprintf("UDP  (%d) \n", LocalPacket.iph_protocol);
            break;
        default:
            dprintf("Unknown (%d) \n", LocalPacket.iph_protocol);
            break;
    }

    //
    // Validate Header checksum
    //
    dprintf("    Checksum                 : %x ", LocalPacket.iph_xsum);
    if(IPHeaderXsum(&LocalPacket, sizeof(IPHeader)) == 0) {
        dprintf("(Good) \n");
    }
    else {
        dprintf("(Bad) \n");
    }

    {
        struct in_addr ip;
        ip.s_addr = LocalPacket.iph_src;
        dprintf("    Source                   : %s \n", inet_ntoa(ip));
        ip.s_addr = LocalPacket.iph_dest;
        dprintf("    Dest                     : %s \n", inet_ntoa(ip));
    }

}

DECLARE_API( upri )
{
    PNDIS_PACKET TargetPacket;
    NDIS_PACKET  LocalPacket;
    MDL  *CurrentMdl;
    LONG MDLCnt = 0;
    NDIS_PACKET_EXTENSION PerPacketInfo;

    if ( *args == '\0' ) {

        dprintf("ndisp <address of NDIS_PACKET> \n");
        return;
    }

    TargetPacket =  (PNDIS_PACKET)GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY(TargetPacket, &LocalPacket, sizeof(NDIS_PACKET));

    TargetPacket = (PNDIS_PACKET)((PUCHAR)TargetPacket +
                       LocalPacket.Private.NdisPacketOobOffset +
                        sizeof(NDIS_PACKET_OOB_DATA));

    KD_READ_MEMORY(TargetPacket, &PerPacketInfo, sizeof(NDIS_PACKET_EXTENSION));
    dprintf("802.1p Priority in packet is 0x%x \n", 
            PerPacketInfo.NdisPacketInfo[Ieee8021pPriority]);

    return;
}

DECLARE_API( wanlink )
{
    PPS_WAN_LINK Target;
    PS_WAN_LINK  Local;

    PCHAR DialUsage[] = {"DU_CALLIN", "DU_CALLOUT", "DU_ROUTER"}; 

    if ( *args == '\0' ) {

        dprintf("wanlink <address of wanlink> \n");
        return;
    }

    Target=  (PPS_WAN_LINK) GetExpression( args );

    if ( !Target) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY(Target, &Local, sizeof(PS_WAN_LINK));

    dprintf("WanLink @ %08X \n", Target);
    dprintf("    RefCount                     : %d \n", Local.RefCount);
    dprintf("    Dial Usage                   : %s \n", DialUsage[Local.DialUsage]);
    dprintf("    RawLinkSpeed                 : %d \n", Local.RawLinkSpeed);
    dprintf("    LinkSpeed                    : %d \n", Local.LinkSpeed);
    dprintf("    Lock                         : 0x%x \n", Local.Lock);
    dprintf("    Stats                        @ 0x%x \n", &Target->Stats);

    dprintf("    Addresses \n");
    dprintf("    --------- \n");
    dprintf("        Remote Address           : %02x:%02x:%02x:%02x:%02x:%02x \n",
            Local.OriginalRemoteMacAddress[0], Local.OriginalRemoteMacAddress[1],
            Local.OriginalRemoteMacAddress[2], Local.OriginalRemoteMacAddress[3], 
            Local.OriginalRemoteMacAddress[4], Local.OriginalRemoteMacAddress[5]);
    dprintf("        Local Address            : %02x:%02x:%02x:%02x:%02x:%02x \n",
            Local.OriginalLocalMacAddress[0], Local.OriginalLocalMacAddress[1],
            Local.OriginalLocalMacAddress[2], Local.OriginalLocalMacAddress[3], 
            Local.OriginalLocalMacAddress[4], Local.OriginalLocalMacAddress[5]);

    dprintf("    Protocol \n");
    dprintf("    -------- \n");
    dprintf("        ProtocolType             : ");

    switch(Local.ProtocolType) {
      case PROTOCOL_IP:
          {
              struct in_addr ip;
              dprintf("IP \n");
              ip.s_addr = Local.LocalIpAddress;
              dprintf("        Address (Local)          : %s \n", inet_ntoa(ip));
              ip.s_addr = Local.RemoteIpAddress;
              dprintf("        Address (Remote)         : %s \n", inet_ntoa(ip));
          }
          break;
          
      case PROTOCOL_IPX:
          dprintf("IPX \n");
          dprintf("        Address (Local)          : %d \n", Local.LocalIpxAddress);
          dprintf("        Address (Remote)         : %d \n", Local.RemoteIpxAddress);
          break;

      default:
          dprintf("Unknown \n");
          break;
    }

    return;
}

DECLARE_API( vc )
/*
 *   dump all the VCs on an adapter
 */
{
    PADAPTER TargetAdapter;
    ADAPTER  LocalAdapter;
    PGPC_CLIENT_VC Target;
    GPC_CLIENT_VC  Local;
    LIST_ENTRY  TargetList;
    PLIST_ENTRY pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        TargetList = LocalAdapter.GpcClientVcList;

        pL = (PLIST_ENTRY) TargetList.Flink;

        while ( pL != &TargetAdapter->GpcClientVcList) {

            //
            // read ClientVC struct out of target's memory
            //

            Target = CONTAINING_RECORD(pL, GPC_CLIENT_VC, Linkage);

            KD_READ_MEMORY(Target, &Local, sizeof(GPC_CLIENT_VC));

            dprintf(" ---------------------------------------------- \n");

            dprintf( "      GpcClientVc @ %08X: State %d, Flags 0x%x, Ref %d \n\n", Target, 
                     Local.ClVcState, Local.Flags, Local.RefCount);

            pL =  Local.Linkage.Flink;

        }
    }
}

DECLARE_API(fstats)
{

    GPC_CLIENT_VC LocalClientVC;
    PGPC_CLIENT_VC TargetClientVC;

    if ( *args == '\0' ) {

        dprintf("Flow Stats <address of ClientVC structure>\n");
        return;
    }

    TargetClientVC =  (PGPC_CLIENT_VC) GetExpression( args );

    if ( !TargetClientVC) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(TargetClientVC, &LocalClientVC, sizeof(GPC_CLIENT_VC));

    dprintf( " Stats for Vc %x \n", TargetClientVC);
    dprintf( " ----------------- \n");

    dprintf( " VC Stats \n");
    dprintf( "    Dropped Packets        = %d \n", LocalClientVC.Stats.DroppedPackets);
    dprintf( "    Packets Scheduled      = %d \n", LocalClientVC.Stats.PacketsScheduled);
    dprintf( "    Packets Transmitted    = %d \n", LocalClientVC.Stats.PacketsTransmitted);
    dprintf( "    Bytes   Transmitted    = %ld\n", LocalClientVC.Stats.BytesTransmitted.QuadPart);
    dprintf( "    Bytes   Scheduled      = %ld\n", LocalClientVC.Stats.BytesScheduled.QuadPart);

    dprintf( " Conformr Stats \n");

    dprintf( " Shaper stats \n");

    dprintf( " SequencerStats \n");

}

DECLARE_API(netl)
{
    PNETWORK_ADDRESS_LIST Target;
    NETWORK_ADDRESS_LIST Local;
    LONG i;

    if ( *args == '\0' ) {

        dprintf("netl <address>\n");
        return;
    }

    Target =  (PNETWORK_ADDRESS_LIST) GetExpression( args );

    if ( !Target) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(Target, &Local, FIELD_OFFSET(NETWORK_ADDRESS_LIST,Address));

    dprintf("Network Address List @ 0x%x \n", Target);

    dprintf("    AddressCount          = %d \n", Local.AddressCount);
    dprintf("    AddressType           = %d \n\n", Local.AddressType);

        Target = (PNETWORK_ADDRESS_LIST)((PUCHAR)Target + FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address));

    for(i=0; i<Local.AddressCount; i++)
    {
        NETWORK_ADDRESS_IP  ipAddr;
        NETWORK_ADDRESS_IPX ipxAddr;
        NETWORK_ADDRESS LocalN;

        //
        // Parse the NETWORK_ADDRESS
        //
        KD_READ_MEMORY(Target, &LocalN, FIELD_OFFSET(NETWORK_ADDRESS, Address));

        dprintf("        AddressLength     = %d \n", LocalN.AddressLength);
        dprintf("        AddressType       = %d \n", LocalN.AddressType);

        //
        // Read the Address
        //

        Target = (PNETWORK_ADDRESS_LIST)((PUCHAR)Target + FIELD_OFFSET(NETWORK_ADDRESS, Address));
    
        switch(LocalN.AddressType)
        {
            case NDIS_PROTOCOL_ID_TCP_IP:
            {
                struct in_addr ip;
                KD_READ_MEMORY(Target, &ipAddr, sizeof(NETWORK_ADDRESS_IP));
                ip.s_addr = ipAddr.in_addr;
                dprintf("        sin_port          = %d \n", ipAddr.sin_port);
                dprintf("        in_addr           = %s \n", inet_ntoa(ip));
                break;
            }

            default:
                dprintf("        *** ERROR : Unrecognized protocol \n");
                break;
        }

        dprintf("        ---------------------------- \n");
    }
    
}

DECLARE_API( wan )
/*
 *   dump all the VCs on an adapter
 */
{
    PADAPTER TargetAdapter;
    ADAPTER  LocalAdapter;
    PPS_WAN_LINK Target;
    PS_WAN_LINK  Local;
    LIST_ENTRY  TargetList;
    PLIST_ENTRY pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        TargetList = LocalAdapter.WanLinkList;

        pL = (PLIST_ENTRY) TargetList.Flink;

        while ( pL != &TargetAdapter->WanLinkList) {

            //
            // read ClientVC struct out of target's memory
            //

            Target = CONTAINING_RECORD(pL, PS_WAN_LINK, Linkage);

            KD_READ_MEMORY(Target, &Local, sizeof(PS_WAN_LINK));

            dprintf(" ---------------------------------------------- \n");

            dprintf( "     WanLink @ %08X\n\n", Target);

            pL =  Local.Linkage.Flink;

        }
    }
}

DECLARE_API( lock )
{
#if DBG
    PPS_SPIN_LOCK Target;
    PS_SPIN_LOCK  Local;
    ULONG        bytes;

    if ( *args != '\0' ) {

        Target =  (PPS_SPIN_LOCK)GetExpression( args );

        if ( !Target) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(Target, &Local, sizeof(PS_SPIN_LOCK));

        if(Local.LockAcquired == TRUE)
        {
                dprintf("    Acquired          : TRUE \n");
                dprintf("    LastAcquiredFile  : %s \n", Local.LastAcquiredFile);
                dprintf("    LastAcquiredLine  : %d \n", Local.LastAcquiredLine);
        }
        else
        {
                dprintf("    Acquired          : FALSE \n");
                dprintf("    LastReleasedFile  : %s \n", Local.LastReleasedFile);
                dprintf("    LastReleasedLine  : %d \n", Local.LastReleasedLine);
        }
    }

    return;
#endif

}

DECLARE_API(diff)
{
    PDIFFSERV_MAPPING TargetA;
    DIFFSERV_MAPPING LocalA;
    int i;

    if ( *args == '\0' )
    {
        dprintf("diff <address>\n");
        return;
    }

    TargetA =  (PDIFFSERV_MAPPING)GetExpression( args );

    if ( !TargetA) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }


    dprintf("TOS    : The Entire 8 bit DSField as it appears in the IP header \n");
    dprintf("DSCP   : The differentiated services code point (higher order 6 bits of above) \n");
    dprintf("Prec   : The precedence value (above field with bits swapped around \n");
    dprintf("OC-TOS : The Entire 8 bit DS field on outbound packets for conforming packets\n");
    dprintf("ONC-TOS: The Entire 8 bit DS field on outbound packets for non-conforming packets\n");
    dprintf("\n");

    dprintf("TOS    DSCP    Prec   OC-TOS  ONC-TOS     VC \n");
    dprintf("---------------------------------------------------------------------------------------\n");
    for(i=0; i<PREC_MAX_VALUE; i++)
    {
        //
        // read ClientVC struct out of target's memory
        //
        KD_READ_MEMORY(TargetA, &LocalA, sizeof(DIFFSERV_MAPPING));

        TargetA = (PDIFFSERV_MAPPING)((PUCHAR)TargetA + sizeof(DIFFSERV_MAPPING));

        //if(LocalA.Vc != 0)
        {
            dprintf("0x%2x   0x%2x    0x%2x    0x%2x    0x%2x    0x%8x\n",
                     i<<2,
                     i,
                     //BitShift(i),
                     0,
                     LocalA.ConformingOutboundDSField,
                     LocalA.NonConformingOutboundDSField,
                     LocalA.Vc);
        }
    }
    dprintf("---------------------------------------------------------------------------------------\n");
}

DECLARE_API( list )
{
    LIST_ENTRY  Target, Local, TargetList;
    PLIST_ENTRY head, pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        head = pL = (PLIST_ENTRY) GetExpression( args );

        if ( !pL) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(pL, &Local, sizeof(LIST_ENTRY));

        while ( Local.Flink != head) 
        {
            pL = Local.Flink;

            if(pL == 0)
            {   
                dprintf("Local = %x %x \n", Local.Flink, Local.Blink);
            }
            else 
            {
                dprintf("%x \n", pL);
            }

            KD_READ_MEMORY(pL, &Local, sizeof(LIST_ENTRY));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\makefile.inc ===
$(O)\precomp.pph: sched.h ..\sys\globals.h ..\..\inc\pktsched.h $(SDK_INC_PATH)\ntddpsch.h $(DDK_INC_PATH)\ndis.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dsotable.c: dso.txt $(O)\precomp.pph
    @echo Creating $@
    structo -p -s dso.txt -o $@ $(O)\precomp.pph
    del $(O)\precomp.pph

clean:
    del $(O)\dsotable.c $(O)\precomp.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <winuser.h>
#include <ntosp.h>
#include <ndis.h>

#include <wdbgexts.h>
#include <stdio.h>

#include "psched.h"
#include "kdutil.h"
#include "sched.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\kdext\sched.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.c

Abstract:

    Priority/DRR Sequencer.  This module is a scheduling component that
    determines the order in which submitted packets should be sent.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _DRRSEQ_H_FILE

#define _DRRSEQ_H_FILE

// The sequencer classifies each flow into an internal "priority group" based
// on the flow's service type and conformance status. Within each priority
// group, there may be one or more priority levels or offsets.  The total
// number of internal priority levels is the sum of the priority levels for
// each priority group.  The internal priority assigned to each flow is
// calculated from the priority group and the relative priority within the
// group, which is obtained from the QOS Priority object.  The 802.1 priority,
// is set by the wrapper. The non conforming values are obtained from the 
// packet.
//
// The flows of the following servicetypes have no internal priority.
//     SERVICETYPE_BESTEFFORT
//     SERVICETYPE_NONCONFORMING
//     SERVICETYPE_QUALITATIVE.
// 
// SERVICETYPE_BESTEFFORT is treated as SERVICETYPE_QUALITATIVE in the sequencer, so the no of priority
// groups is 1 less than the no. of servicetypes.

#define RELATIVE_PRIORITIES             8
#define PRIORITY_GROUPS                 (NUM_TC_SERVICETYPES - 1)
#define INTERNAL_PRIORITIES             (((PRIORITY_GROUPS - 2) * RELATIVE_PRIORITIES) + 2)
#define DEFAULT_PRIORITY_OFFSET         3
#define DEFAULT_MIN_QUANTUM             1500

#define PRIORITY_GROUP_NON_CONFORMING   0
#define PRIORITY_GROUP_BEST_EFFORT      1
#define PRIORITY_GROUP_CONTROLLED_LOAD  2
#define PRIORITY_GROUP_GUARANTEED       3
#define PRIORITY_GROUP_NETWORK_CONTROL  4

//
// For maintaining stats
//
#define SEQUENCER_AVERAGING_ARRAY_SIZE      256
#define NETCARD_AVERAGING_ARRAY_SIZE        256
#define SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE     256


// The DRR Sequencer's pipe information

typedef struct _DSEQ_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe and flow data
    // Flags -                  See below
    // Flows -                  List of all installed flows
    // ActiveFlows -            Lists of flows that are waiting to send packets
    // PriorityLevels -         Number of priority offsets for each priority group
    // StartPriority -          Lowest internal priority value for each priority group
    // ActiveFlowCount -        Number of active flows for each service type
    // MaxOutstandingSends -    Maximum number of outstanding sends
    // OutstandingSends -       Number of outstanding sends
    // PacketsInNetcardAveragingArray
    // PacketsInSequencer -     Current number packets in sequencer
    // PacketsInSequencerAveragingArray
    // Bandwidth -              Link speed
    // MinimumQuantum -         Minimum quantum size for DRR
    // MinimumRate -            Smallest rate currently assigned to a flow
    // TimerResolution -        Timer resolution in OS time units
    // PsFlags -                Flags from pipe parameters
    // PsPipeContext -          PS's pipe context value

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInNetcardAveragingArray;
    ULONG PacketsInSequencer;
    PRUNNING_AVERAGE PacketsInSequencerAveragingArray;
#endif
    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Flows;
    LIST_ENTRY ActiveFlows[INTERNAL_PRIORITIES];
    ULONG PriorityLevels[PRIORITY_GROUPS];
    ULONG StartPriority[PRIORITY_GROUPS];
    ULONG ActiveFlowCount[PRIORITY_GROUPS];
    ULONG TotalActiveFlows;
    ULONG MaxOutstandingSends;
    ULONG OutstandingSends;
    ULONG Bandwidth;
    ULONG MinimumQuantum;
    ULONG MinimumRate;
    ULONG TimerResolution;
    ULONG PsFlags;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    PSU_SEND_COMPLETE PreviousUpcallsSendComplete;
    PPS_PIPE_CONTEXT   PreviousUpcallsSendCompletePipeContext;
} DSEQ_PIPE, *PDSEQ_PIPE;

// Pipe flag values

#define DSEQ_DEQUEUE            1
#define DSEQ_PASSTHRU           2

typedef enum _FLOW_STATE {
    DRRSEQ_FLOW_CREATED = 1,
    DRRSEQ_FLOW_DELETED
} FLOW_STATE;

// The DRR Sequencer's flow information

typedef struct _DSEQ_FLOW {

    // ContextInfo -            Generic context info
    // ActiveLinks -            Links in active flow list
    // Links -                  Links in installed flow list
    // PacketQueue -            Self-explanatory
    // PacketSendTime -         Send time for current packet
    // LastConformanceTime -    Absolute conformance time of last packet
    // TokenRate -              TokenRate from GQOS
    // UserPriority -           Priority offset assigned by user
    // Priority -               Internal priority
    // PriorityGroup -          Priority group for flow
    // Quantum -                Quantum assigned to flow for DRR
    // DeficitCounter -         Current value of DRR deficit counter
    // Flags -                  See below
    // PsFlowContext -          PS's flow context value
    // BucketSize -             TokenBucketSize from GQOS
    // NumPacketsInSeq -                Number of packets from this flow in the sequencer
    // PacketsInSeqAveragingArray-Data for computing average packets in seq from this flow

    PS_FLOW_CONTEXT ContextInfo;
    LIST_ENTRY ActiveLinks;
    LIST_ENTRY Links;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER PacketSendTime;
    LARGE_INTEGER LastConformanceTime;
    ULONG TokenRate;
    ULONG UserPriority;
    ULONG Priority;
    ULONG PriorityGroup;
    ULONG Quantum;
    ULONG DeficitCounter;
    ULONG Flags;
    HANDLE PsFlowContext;
    ULONG BucketSize;
#ifdef INSTRUMENT
        ULONG PacketsInSequencer;
    PS_DRRSEQ_STATS Stats;
        PRUNNING_AVERAGE PacketsInSeqAveragingArray;
#endif
    FLOW_STATE State;
} DSEQ_FLOW, *PDSEQ_FLOW;

#define MAX_DEQUEUED_PACKETS            8

#define FLOW_USER_PRIORITY              0x00000002

// The following macro checks a packet for conformance based on the flow's
// LastPacketTime, the current time, and the timer resolution.

#define PacketIsConforming(_flow, _curtime, _r) \
    ( (_flow)->PacketSendTime.QuadPart <= ((_curtime).QuadPart + (_r)) )

#define AdjustLastPacketTime(_flow, _curtime, _r) \
    if ((_curtime).QuadPart > ((_flow)->PacketSendTime.QuadPart + (_r))) \
        if ((_curtime).QuadPart > ((_flow)->LastConformanceTime.QuadPart - (_r))) \
            (_flow)->PacketSendTime = (_flow)->LastConformanceTime; \
        else \
            (_flow)->PacketSendTime = (_curtime);



// The Shaper's pipe information

typedef struct _TS_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe data
    // ActiveFlows -            List of flows that are waiting to send packets
    // Timer -                  Timer struct
    // TimerStatus -            Status of timer
    // TimerResolution -        Timer resolution in OS time units
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.
    // PacketsInShaperAveragingArray

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_SHAPER_STATS Stats;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;
    ULONG PacketsInShaper;
#endif
    NDIS_SPIN_LOCK Lock;
    LIST_ENTRY ActiveFlows;
    NDIS_MINIPORT_TIMER Timer;
    ULONG TimerStatus;
    ULONG TimerResolution;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;
} TS_PIPE, *PTS_PIPE;

#define TIMER_UNINITIALIZED     0
#define TIMER_INACTIVE          1
#define TIMER_SET               2
#define TIMER_PROC_EXECUTING    3


// The Shaper's flow information

typedef struct _TS_FLOW {

    // ContextInfo -            Generic context info
    // Flags -                  See below
    // Links -                  Links in active flow list
    // Mode -                   Shape/Discard mode
    // Shape -                  Indicates whether to shape traffic
    // PacketQueue -            Self-explanatory
    // FlowEligibilityTime -    Absolute conformance time of 1st packet in queue
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.
    // PacketsInShaperAveragingArray - Per flow averaging data
    // State -                  State of the flow

    PS_FLOW_CONTEXT ContextInfo;
    ULONG Flags;
    LIST_ENTRY Links;
    ULONG Mode;
    ULONG Shape;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER FlowEligibilityTime;
    HANDLE PsFlowContext;
#ifdef QUEUE_LIMIT
    ULONG QueueSize;
    ULONG QueueSizeLimit;
    ULONG DropOverLimitPacketsFromHead;
    ULONG UseDefaultQueueLimit;
#endif // QUEUE_LIMIT
#ifdef INSTRUMENT
    ULONG PacketsInShaper;
    PS_SHAPER_STATS Stats;
        PRUNNING_AVERAGE PacketsInShaperAveragingArray;
#endif
    FLOW_STATE State;
} TS_FLOW, *PTS_FLOW;

typedef struct _TBC_PIPE {

    // ContextInfo -            Generic context info
    // MaxPacket -              Maximum packet size for pipe
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // HeaderLength -           Length of MAC header for this pipe
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_CONFORMER_STATS Stats;
#endif // INSTRUMENT
    ULONG MaxPacket;
    HANDLE PsPipeContext;
    ULONG TimerResolution;
    PPS_PROCS PsProcs;
    ULONG HeaderLength;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;
} TBC_PIPE, *PTBC_PIPE;

// The conformer's flow information

typedef struct _TBC_FLOW {

    // ContextInfo -            Generic context info
    // Lock -                   Protects flow data
    // TokenRate -              TokenRate from generic QoS
    // Capacity -               TokenBucketSize from generic QoS
    // PeakRate -               PeakBandwidth from generic QoS
    // MinPolicedUnit -         MinimumPolicedUnit from generic QoS
    // Mode -                   Flow S/D mode
    // NoConformance -          Indicates whether flow is exempt from conformance algorithm
    // LastConformanceTime -    Absolute tb conformance time of last non-discarded packet
    // LastPeakTime -           Absolute peak conformance time of last non-discarded packet 
    // PeakConformanceTime -    Earliest time next packet can be sent, based on peak rate
    // LastConformanceCredits - Number of credits at LastConformanceTime
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.

    PS_FLOW_CONTEXT ContextInfo;
    NDIS_SPIN_LOCK Lock;
    ULONG TokenRate;
    ULONG Capacity;
    ULONG PeakRate;
    ULONG MinPolicedUnit;
    ULONG Mode;
    ULONG NoConformance;
    LARGE_INTEGER LastConformanceTime;
    LARGE_INTEGER LastPeakTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG LastConformanceCredits;
    HANDLE PsFlowContext;
#ifdef INSTRUMENT
    PS_CONFORMER_STATS Stats;
#endif // INSTRUMENT
} TBC_FLOW, *PTBC_FLOW;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\ipqosrm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    ipqosrm.h

Abstract:

    The file contains the IP router manager
    interface for the QOS Mgr Protocol.

Revision History:

--*/

#ifndef __IPQOSRM_H_
#define __IPQOSRM_H_

//
// Constants
//

//
// Current QOS configuration version
//
#define QOS_CONFIG_VERSION_500       500


//
// Constants for the field 
// IPQOS_GLOBAL_CONFIG::LoggingLevel
//
#define IPQOS_LOGGING_NONE           0
#define IPQOS_LOGGING_ERROR          1
#define IPQOS_LOGGING_WARN           2
#define IPQOS_LOGGING_INFO           3


//
// Constants identifying QOS's MIB tables
//
#define IPQOS_GLOBAL_STATS_ID        0
#define IPQOS_GLOBAL_CONFIG_ID       1
#define IPQOS_IF_STATS_ID            2
#define IPQOS_IF_CONFIG_ID           3


//
// Structures
//

//
// In the following structures, all IP
// addresses are in network byte order
//

typedef struct _IPQOS_NAMED_FLOWSPEC
{
    WCHAR              FlowspecName[MAX_STRING_LENGTH];
    FLOWSPEC           FlowspecDesc;
}
IPQOS_NAMED_FLOWSPEC, *PIPQOS_NAMED_FLOWSPEC;

typedef struct _IPQOS_NAMED_QOSOBJECT
{
    WCHAR              QosObjectName[MAX_STRING_LENGTH];
    QOS_OBJECT_HDR     QosObjectHdr;
}
IPQOS_NAMED_QOSOBJECT, *PIPQOS_NAMED_QOSOBJECT;

//
// This MIB entry stores global config
// info for IP QOS MGR protocol.
//
typedef struct _IPQOS_GLOBAL_CONFIG 
{
    DWORD                  LoggingLevel;  // Detail of debug logging in qos

    ULONG                  NumFlowspecs;  // Number of flowspecs defined
    ULONG                  NumQosObjects; // Number of qos objects defined

//  IPQOS_NAMED_FLOWSPEC   FlowSpecs[0];  // Array of all flowspecs
//  
//  IPQOS_NAMED_QOSOBJECTS QosObjects[0]; // Array of all q objects
} 
IPQOS_GLOBAL_CONFIG, *PIPQOS_GLOBAL_CONFIG;

//
// Macros to operate on global config
//

#define IPQOS_GET_FIRST_FLOWSPEC_IN_CONFIG(Config)                     \
        (PIPQOS_NAMED_FLOWSPEC)((PUCHAR)(Config) +                     \
                                sizeof(IPQOS_GLOBAL_CONFIG))           \

#define IPQOS_GET_NEXT_FLOWSPEC_IN_CONFIG(Flowspec)                    \
        (Flowspec + 1)

#define IPQOS_GET_FIRST_QOSOBJECT_IN_CONFIG(Config)                    \
        (PIPQOS_NAMED_QOSOBJECT)((PUCHAR)(Config) +                    \
                                 sizeof(IPQOS_GLOBAL_CONFIG) +         \
                                 (Config->NumFlowspecs *               \
                                  sizeof(IPQOS_NAMED_FLOWSPEC)))

#define IPQOS_GET_NEXT_QOSOBJECT_IN_CONFIG(QosObject)                  \
        (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) QosObject +                  \
                                 FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT,   \
                                              QosObjectHdr) +          \
                                 QosObject->QosObjectHdr.ObjectLength)

typedef struct _IPQOS_NAMED_FLOW
{
    WCHAR                SendingFlowspecName[MAX_STRING_LENGTH];
    WCHAR                RecvingFlowspecName[MAX_STRING_LENGTH];
    ULONG                NumTcObjects;

//  WCHAR                TcObjectNames[0];
}
IPQOS_NAMED_FLOW, *PIPQOS_NAMED_FLOW;

//
// Macros to operate on a named flow
//

#define IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc) \
        (PWCHAR) ((PUCHAR)(FlowDesc) + sizeof(IPQOS_NAMED_FLOW))

#define IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(ObjectName) \
        (ObjectName + MAX_STRING_LENGTH)

//
// Describes a generic flow description
//
typedef struct _IPQOS_IF_FLOW
{
    WCHAR              FlowName[MAX_STRING_LENGTH];
                                       // Name used to identify the flow
    ULONG              FlowSize;       // Number of bytes in description
    IPQOS_NAMED_FLOW   FlowDesc;       // Traffic Control API def'nd flow
} 
IPQOS_IF_FLOW, *PIPQOS_IF_FLOW;

//
// This MIB entry describes per-interface 
// config for IP QOS MGR protocol
//
typedef struct _IPQOS_IF_CONFIG
{
    DWORD              QosState;       // QOS State on this interface
    ULONG              NumFlows;       // Number of flows on this "if"

//  IPQOS_IF_FLOW      Flows[0];       // Variable length list of flows
} 
IPQOS_IF_CONFIG, *PIPQOS_IF_CONFIG;

// State of IF
#define IPQOS_STATE_DISABLED    0x00
#define IPQOS_STATE_ENABLED     0x01

//
// Macros to operate on if config
//

#define IPQOS_GET_FIRST_FLOW_ON_IF(Config) \
        (PIPQOS_IF_FLOW) ((PUCHAR)(Config) + sizeof(IPQOS_IF_CONFIG))

#define IPQOS_GET_NEXT_FLOW_ON_IF(CurrFlow) \
        (PIPQOS_IF_FLOW) ((PUCHAR)(CurrFlow) + (CurrFlow)->FlowSize)

//
// This MIB entry stores per-interface 
// statistics for IP QOS MGR protocol.
//
typedef struct _IPQOS_GLOBAL_STATS
{
    DWORD              LoggingLevel;    // Detail of debug logging in qos
} 
IPQOS_GLOBAL_STATS, *PIPQOS_GLOBAL_STATS;


//
// This MIB entry stores per-interface 
// statistics for IP QOS MGR protocol.
//
typedef struct _IPQOS_IF_STATS
{
    DWORD              QosState;       // QOS State on this interface
    ULONG              NumFlows;       // Number of flows on this "if"
} 
IPQOS_IF_STATS, *PIPQOS_IF_STATS;


//
// This is passed as input data for MibSet
// Note that only the global config and 
// interface config are writable structs.
//
typedef struct _IPQOS_MIB_SET_INPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
    DWORD       BufferSize;
    DWORD       Buffer[1];
}
IPQOS_MIB_SET_INPUT_DATA, *PIPQOS_MIB_SET_INPUT_DATA;


//
// This is passed as input data for - 
// MibGet, MibGetFirst and MibGetNext
//
typedef struct _IPQOS_MIB_GET_INPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
}
IPQOS_MIB_GET_INPUT_DATA, *PIPQOS_MIB_GET_INPUT_DATA;


//
// This is passed as output data for -
// MibGet, MibGetFirst, and MibGetNext.
// [
//    Note that at the end of a table 
//    MibGetNext wraps to the next,
//    and therefore the value TypeID
//    should be examined to see the 
//    type of data returned in output
// ]
//
typedef struct _IPQOS_MIB_GET_OUTPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
    BYTE        Buffer[1];
}
IPQOS_MIB_GET_OUTPUT_DATA, *PIPQOS_MIB_GET_OUTPUT_DATA;

#endif // __IPQOSRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\qos.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qos.c

Abstract:

    IP QOS Command dispatcher.

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop

//
// Declare and Init Global Variables for QOS Extension
//

#ifdef ALLOW_CHILD_HELPERS
PIP_CONTEXT_TABLE_ENTRY g_QosContextTable  = NULL;
DWORD                   g_dwNumQosContexts = 0;
#endif

//
// The table of Add, Delete, Set, Show Commands for QOS
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FLOW' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY  g_QosAddCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_ADD_FILTER_TO_FLOW, HandleQosAttachFilterToFlow),*/
    CREATE_CMD_ENTRY(QOS_ADD_QOSOBJECT_ON_FLOW, HandleQosAddQosObjectOnIfFlow),
    CREATE_CMD_ENTRY(QOS_ADD_FLOWSPEC_ON_FLOW, HandleQosAddFlowspecOnIfFlow),
    CREATE_CMD_ENTRY(QOS_ADD_FLOW_ON_IF, HandleQosAddFlowOnIf),
    CREATE_CMD_ENTRY(QOS_ADD_IF, HandleQosAddIf),
    CREATE_CMD_ENTRY(QOS_ADD_DSRULE, HandleQosAddDsRule),
    CREATE_CMD_ENTRY(QOS_ADD_SDMODE, HandleQosAddSdMode),
    CREATE_CMD_ENTRY(QOS_ADD_FLOWSPEC, HandleQosAddFlowspec),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(ADD_HELPER, HandleQosAddHelper),
#endif
};

CMD_ENTRY  g_QosDelCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_DEL_FILTER_FROM_FLOW, HandleQosDetachFilterFromFlow),*/
    CREATE_CMD_ENTRY(QOS_DEL_QOSOBJECT_ON_FLOW, HandleQosDelQosObjectOnIfFlow),
    CREATE_CMD_ENTRY(QOS_DEL_FLOWSPEC_ON_FLOW, HandleQosDelFlowspecOnIfFlow),
    CREATE_CMD_ENTRY(QOS_DEL_FLOW_ON_IF, HandleQosDelFlowOnIf),
    CREATE_CMD_ENTRY(QOS_DEL_IF, HandleQosDelIf),
    CREATE_CMD_ENTRY(QOS_DEL_DSRULE, HandleQosDelDsRule),
    CREATE_CMD_ENTRY(QOS_DEL_SDMODE, HandleQosDelQosObject),
    CREATE_CMD_ENTRY(QOS_DEL_QOSOBJECT, HandleQosDelQosObject),
    CREATE_CMD_ENTRY(QOS_DEL_FLOWSPEC, HandleQosDelFlowspec),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(DEL_HELPER, HandleQosDelHelper),
#endif
};

CMD_ENTRY  g_QosSetCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_SET_FILTER_ON_FLOW, HandleQosModifyFilterOnFlow),*/
/* CREATE_CMD_ENTRY(QOS_SET_IF, HandleQosSetIf), */
   CREATE_CMD_ENTRY(QOS_SET_GLOBAL, HandleQosSetGlobal)
};

CMD_ENTRY  g_QosShowCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_SHOW_FILTER_ON_FLOW, HandleQosShowFilterOnFlow),*/
    CREATE_CMD_ENTRY(QOS_SHOW_FLOW_ON_IF, HandleQosShowFlowOnIf),
    CREATE_CMD_ENTRY(QOS_SHOW_IF, HandleQosShowIf),
    CREATE_CMD_ENTRY(QOS_SHOW_DSMAP, HandleQosShowDsMap),
    CREATE_CMD_ENTRY(QOS_SHOW_SDMODE, HandleQosShowSdMode),
    CREATE_CMD_ENTRY(QOS_SHOW_QOSOBJECT, HandleQosShowQosObject),
    CREATE_CMD_ENTRY(QOS_SHOW_FLOWSPEC, HandleQosShowFlowspec),
    CREATE_CMD_ENTRY(QOS_SHOW_GLOBAL, HandleQosShowGlobal),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(SHOW_HELPER, HandleQosShowHelper),
#endif
};

CMD_GROUP_ENTRY g_QosCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_QosAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_QosDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_QosSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_QosShowCmdTable),
};

ULONG   g_ulQosNumGroups = sizeof(g_QosCmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_QosCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleQosInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleQosUninstall),
};

ULONG g_ulQosNumTopCmds = sizeof(g_QosCmds)/sizeof(CMD_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>
#include <ntdef.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>



#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <igmprm.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <snmp.h>
#include <internal.h>

#define  INITGUID
#include <tcguid.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <qos.h>
#include <traffic.h>
#include <tcerror.h>
#include <ipqosrm.h>

#include <macros.h>
#include <netsh.h>
#include <ipmontr.h>
#include "ipprodefs.h"
#include "common.h"
#include "utils.h"
#include "strdefs.h"
#include "prstring.h"
#include "igmp.h"

#include "igmpcfg.h"
#include "igmpgetopt.h"
#include "igmpmib.h"
#include "rip.h"
#include "ripcfg.h"
#include "ripgetopt.h"
#include "ripmib.h"
#include "qosp.h"
#include "ospf.h"
#include "ospfcfg.h"
#include "ospfgetopt.h"
#include "ospfmib.h"
#include "bootp.h"
#include "bootpcfg.h"
#include "bootpopt.h"
#include "bootpmib.h"
#include "nathlp.h"
#include "nathlpcfg.h"
#include "nathlpopt.h"
#include "rdisc.h"
#include "rdiscopt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\prstring.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\prstring.h

Abstract:

    Definitions of command line option tag strings and their values. 

Revision History:

    Dave Thaler             11/11/98  Created

--*/

#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")


#define TOKEN_ROUTER                           _T("router")
#define TOKEN_MIB                              _T("mib")

    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_SHOW_HELPER              _T("show helper")
#define TOKEN_COMMAND_HELP                      _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                     _T("/?")
#define TOKEN_COMMAND_HELP2                     _T("-?")

    // Tokens for RIP MIB
#define TOKEN_RIP_MIB_OBJECT_STATS             _T("globalstats")
#define TOKEN_RIP_MIB_OBJECT_IFSTATS           _T("ifstats")
#define TOKEN_RIP_MIB_OBJECT_IFBINDING         _T("ifbinding")
#define TOKEN_RIP_MIB_OBJECT_PEERSTATS         _T("neighbor")
#define CMD_RIP_MIB_SHOW_STATS                 L"show globalstats"
#define CMD_RIP_MIB_SHOW_IFSTATS               L"show ifstats"
#define CMD_RIP_MIB_SHOW_IFBINDING             L"show ifbinding"
#define CMD_RIP_MIB_SHOW_PEERSTATS             L"show neighbor"

    // Tokens for BOOTP MIB
#define TOKEN_BOOTP_MIB_OBJECT_GLOBAL_CONFIG   _T("globalconfig")
#define TOKEN_BOOTP_MIB_OBJECT_IF_CONFIG       _T("ifconfig")
#define TOKEN_BOOTP_MIB_OBJECT_IF_BINDING      _T("ifbinding")
#define TOKEN_BOOTP_MIB_OBJECT_IF_STATS        _T("ifstats")
#define CMD_BOOTP_MIB_SHOW_GLOBAL_CONFIG       L"show globalconfig"
#define CMD_BOOTP_MIB_SHOW_IF_CONFIG           L"show ifconfig"
#define CMD_BOOTP_MIB_SHOW_IF_BINDING          L"show ifbinding"
#define CMD_BOOTP_MIB_SHOW_IF_STATS            L"show ifstats"

    // Tokens for OSPF MIB
#define TOKEN_OSPF_MIB_OBJECT_AREA              L"areastats"
#define TOKEN_OSPF_MIB_OBJECT_LSDB              L"lsdb"
#define TOKEN_OSPF_MIB_OBJECT_NEIGHBOR          L"neighbor"
#define TOKEN_OSPF_MIB_OBJECT_VIRTUALIF         L"virtifstats"
#define CMD_OSPF_MIB_SHOW_AREA                  L"show areastats"
#define CMD_OSPF_MIB_SHOW_LSDB                  L"show lsdb"
#define CMD_OSPF_MIB_SHOW_NEIGHBOR              L"show neighbor"
#define CMD_OSPF_MIB_SHOW_VIRTUALIF             L"show virtifstats"

    // Tokens for IGMP MIB
#define TOKEN_IGMP_MIB_OBJECT_IF_STATS          L"ifstats"
#define TOKEN_IGMP_MIB_OBJECT_IF_TABLE          L"iftable"
#define TOKEN_IGMP_MIB_OBJECT_GROUP_TABLE       L"grouptable"
#define TOKEN_IGMP_MIB_OBJECT_RAS_GROUP_TABLE   L"rasgrouptable"
#define TOKEN_IGMP_MIB_OBJECT_PROXY_GROUP_TABLE L"proxygrouptable"
#define CMD_IGMP_MIB_SHOW_IF_STATS              L"show ifstats"
#define CMD_IGMP_MIB_SHOW_IF_TABLE              L"show iftable"
#define CMD_IGMP_MIB_SHOW_GROUP_TABLE           L"show grouptable"
#define CMD_IGMP_MIB_SHOW_RAS_GROUP_TABLE       L"show rasgrouptable"
#define CMD_IGMP_MIB_SHOW_PROXY_GROUP_TABLE     L"show proxygrouptable"


    // tokens for router command options' tags
#define TOKEN_OPT_NAME                         _T("name")

        // filter options
#define TOKEN_OPT_ADDR                          _T("addr")
#define TOKEN_OPT_MASK                          _T("mask")
#define TOKEN_OPT_FILTER                        _T("filter")

        // NAT options
#define TOKEN_OPT_PUBLIC                       _T("public")
#define TOKEN_OPT_PRIVATE                      _T("private")
#define TOKEN_OPT_INBOUNDSESSIONS              _T("inboundsessions")
#define TOKEN_OPT_START                        _T("start")
#define TOKEN_OPT_END                          _T("end")
#define TOKEN_OPT_PROTO                        _T("proto")
#define TOKEN_OPT_PUBLICIP                     _T("publicip")
#define TOKEN_OPT_PUBLICPORT                   _T("publicport")
#define TOKEN_OPT_PRIVATEIP                    _T("privateip")
#define TOKEN_OPT_PRIVATEPORT                  _T("privateport")
#define TOKEN_OPT_TCPTIMEOUTMINS               _T("tcptimeoutmins")
#define TOKEN_OPT_UDPTIMEOUTMINS               _T("udptimeoutmins")
#define TOKEN_OPT_LOG_LEVEL                    _T("loglevel")

        // protocol options
#define TOKEN_OPT_SERVER                       _T("server")
#define TOKEN_OPT_AUTHENTICATION               _T("auth")
#define TOKEN_OPT_PASSWORD                     _T("password")
#define TOKEN_OPT_PEER_MODE                    _T("peermode")

            // BOOTP Interface options
#define TOKEN_OPT_RELAY_MODE                   _T("relaymode")
#define TOKEN_OPT_MAX_HOP                      _T("maxhop")
#define TOKEN_OPT_MIN_SECS                     _T("minsecs")

            // AUTODHCP/DNSPROXY Interface options
#define TOKEN_OPT_MODE                         _T("mode")
#define TOKEN_OPT_EXCLUSION                    _T("exclusion")
#define TOKEN_OPT_SCOPENETWORK                 _T("scopenetwork")
#define TOKEN_OPT_SCOPEMASK                    _T("scopemask")
#define TOKEN_OPT_QUERY_TIMEOUT                _T("querytimeout")
#define TOKEN_OPT_LEASETIME                    _T("leasetime")
#define TOKEN_OPT_DNSMODE                      _T("dnsmode")
#define TOKEN_OPT_WINSMODE                     _T("winsmode")

            // RIP global options
#define TOKEN_OPT_MIN_TRIG_INTR                _T("mintrig")

            // RIP Interface Options
#define TOKEN_OPT_UPDATE_MODE                  _T("updatemode")
#define TOKEN_OPT_ANNOUNCE_MODE                _T("announce")
#define TOKEN_OPT_ACCEPT_MODE                  _T("accept")
#define TOKEN_OPT_FLAG                         _T("flag")
#define TOKEN_OPT_FLAGS                        _T("flags")
#define TOKEN_OPT_EXPIRE_INTR                  _T("expire")
#define TOKEN_OPT_REMOVE_INTR                  _T("remove")
#define TOKEN_OPT_UPDATE_INTR                  _T("update")
#define TOKEN_OPT_AUTH_MODE                    _T("authmode")
#define TOKEN_OPT_ROUTE_TAG                    _T("tag")
#define TOKEN_OPT_UNICAST_MODE                 _T("unicast")
#define TOKEN_OPT_ACCEPT_FILTER_MODE           _T("accfiltmode")
#define TOKEN_OPT_ANNOUNCE_FILTER_MODE         _T("annfiltmode")
#define TOKEN_OPT_ACCEPT_FILTER                _T("accfilt")
#define TOKEN_OPT_ANNOUNCE_FILTER              _T("annfilt")

            // IGMP Interface options
#define TOKEN_OPT_PROTO_TYPE                   _T("igmpprototype")
#define TOKEN_OPT_ROBUSTNESS_VARIABLE          _T("robustvar")
#define TOKEN_OPT_GEN_QUERY_INTERVAL           _T("genqueryinterval")
#define TOKEN_OPT_GEN_QUERY_RESPONSE_TIME      _T("genqueryresptime")
#define TOKEN_OPT_INTERFACE_ENABLED            _T("ifenabled")
#define TOKEN_OPT_STARTUP_QUERY_COUNT          _T("startupquerycount")
#define TOKEN_OPT_STARTUP_QUERY_INTERVAL       _T("startupqueryinterval")
#define TOKEN_OPT_LASTMEM_QUERY_COUNT          _T("lastmemquerycount")
#define TOKEN_OPT_LASTMEM_QUERY_INTERVAL       _T("lastmemqueryinterval")
#define TOKEN_OPT_STATIC_GROUP                 _T("staticgroup")
#define TOKEN_OPT_STATIC_JOIN_MODE             _T("joinmode")
#define TOKEN_OPT_RTRALERT_PKTS                _T("accnonrtralertpkts")

            // OSPF Global Options
#define TOKEN_OPT_ROUTER_ID                    _T("routerid")
#define TOKEN_OPT_BORDER                       _T("asborder")



            // OSPF Area/Area Range Options
#define TOKEN_OPT_AREA_ID                      _T("areaid")
#define TOKEN_OPT_STUB_AREA                    _T("stubarea")
#define TOKEN_OPT_SUMMARY_ADVERTISEMENTS       _T("sumadv")
#define TOKEN_OPT_AREA_RANGE                   _T("range")

            // OSPF Virtual Interface Options
#define TOKEN_OPT_TRANSIT_AREA_ID              _T("transareaid")
#define TOKEN_OPT_VIRT_NBR_ROUTER_ID           _T("virtnbrid")

            // OSPF External routing
#define TOKEN_OPT_PROTOCOL_FILTER              _T("protofilter")
#define TOKEN_OPT_ACTION                       _T("action")

#define TOKEN_OPT_ROUTE_FILTER                 _T("routefilter")

            // OSPF Interface Options
#define TOKEN_OPT_IF_STATE                     _T("state")
#define TOKEN_OPT_PRIORITY                     _T("prio")
#define TOKEN_OPT_TRANS_DELAY                  _T("transdelay")
#define TOKEN_OPT_RETRANS_INTR                 _T("retrans")
#define TOKEN_OPT_HELLO_INTR                   _T("hello")
#define TOKEN_OPT_DEAD_INTR                    _T("dead")
#define TOKEN_OPT_POLL_INTR                    _T("poll")
#define TOKEN_OPT_MTU_SIZE                     _T("mtu")
            // QOS Interface options
#define TOKEN_OPT_IF_STATE                     _T("state")

            // QOS Flow options
#define TOKEN_OPT_FLOW_NAME                    _T("flowname")
#define TOKEN_OPT_FLOWSPEC                     _T("flowspec")
#define TOKEN_OPT_DIRECTION                    _T("direction")

            // QOS FlowSpec options
#define TOKEN_OPT_SERVICE_TYPE                 _T("servicetype")
#define TOKEN_OPT_TOKEN_RATE                   _T("tokenrate")
#define TOKEN_OPT_TOKEN_BUCKET_SIZE            _T("tokenbucketsize")
#define TOKEN_OPT_PEAK_BANDWIDTH               _T("peakbandwidth")
#define TOKEN_OPT_LATENCY                      _T("latency")
#define TOKEN_OPT_DELAY_VARIATION              _T("delayvariation")
#define TOKEN_OPT_MAX_SDU_SIZE                 _T("maxsdusize")
#define TOKEN_OPT_MIN_POLICED_SIZE             _T("minpolicedsize")

            // QOS Flowspec Direction Options
#define TOKEN_OPT_DIRECTION_INBOUND            _T("inbound")
#define TOKEN_OPT_DIRECTION_OUTBOUND           _T("outbound")
#define TOKEN_OPT_DIRECTION_BIDIRECTIONAL      _T("bidirectional")

            // QOS Object Options
#define TOKEN_OPT_QOSOBJECT                    _T("qosobject")

#define TOKEN_OPT_QOSOBJECT_TYPE               _T("type")

#define TOKEN_OPT_QOSOBJECT_DIFFSERV           _T("diffserv")
#define TOKEN_OPT_QOSOBJECT_SD_MODE            _T("sdmode")
            // QOS ServiceType options
#define TOKEN_OPT_SERVICE_BESTEFFORT           _T("besteffort")
#define TOKEN_OPT_SERVICE_CONTROLLEDLOAD       _T("controlledload")
#define TOKEN_OPT_SERVICE_GUARANTEED           _T("guaranteed")
#define TOKEN_OPT_SERVICE_QUALITATIVE          _T("qualitative")

            // QOS SD Mode options
#define TOKEN_OPT_SHAPING_MODE                 _T("shaping")

#define TOKEN_OPT_SDMODE_BORROW                _T("borrow")
#define TOKEN_OPT_SDMODE_SHAPE                 _T("shape")
#define TOKEN_OPT_SDMODE_DISCARD               _T("discard")
#define TOKEN_OPT_SDMODE_BORROW_PLUS           _T("borrowplus")

            // QOS Diffserv Rule options
#define TOKEN_OPT_INBOUND_DS_FIELD             _T("dsin")
#define TOKEN_OPT_CONF_OUTBOUND_DS_FIELD       _T("dsoutconf")
#define TOKEN_OPT_NONCONF_OUTBOUND_DS_FIELD    _T("dsoutnonconf")
#define TOKEN_OPT_CONF_USER_PRIORITY           _T("priconf")
#define TOKEN_OPT_NONCONF_USER_PRIORITY        _T("prinonconf")

            // OSPF Neighbor option
#define TOKEN_OPT_NBR_ADDR                     _T("nbraddr")
#define TOKEN_OPT_NBR_PRIO                     _T("nbrprio")

#define TOKEN_OPT_TYPE                         _T("type")
#define TOKEN_OPT_METRIC                       _T("metric")

            // Router discovery options
#define TOKEN_DISCOVERY                         L"disc"
#define TOKEN_MIN_DISC_INTERVAL                 L"minint"
#define TOKEN_MAX_DISC_INTERVAL                 L"maxint"
#define TOKEN_LIFETIME                          L"life"
#define TOKEN_LEVEL                             L"level"

        // Protocol types
#define TOKEN_OPT_VALUE_RTRMGR                 _T("ROUTERMANAGER")
#define TOKEN_OPT_VALUE_RIP                    _T("RIP")
#define TOKEN_OPT_VALUE_OSPF                   _T("OSPF")
#define TOKEN_OPT_VALUE_BOOTP                  _T("BOOTP")
#define TOKEN_OPT_VALUE_IGMP                   _T("IGMP")
#define TOKEN_OPT_VALUE_AUTO_DHCP              _T("AUTODHCP")
#define TOKEN_OPT_VALUE_DNS_PROXY              _T("DNSPROXY")

#define TOKEN_OPT_VALUE_TCP                    _T("TCP")
#define TOKEN_OPT_VALUE_UDP                    _T("UDP")
#define TOKEN_OPT_VALUE_ICMP                   _T("ICMP")
#define TOKEN_OPT_VALUE_NETMGMT                _T("SNMP")
#define TOKEN_OPT_VALUE_LOCAL                  _T("LOCAL")
#define TOKEN_OPT_VALUE_STATIC                 _T("STATIC")
#define TOKEN_OPT_VALUE_AUTOSTATIC             _T("AUTOSTATIC")
#define TOKEN_OPT_VALUE_NONDOD                 _T("NONDOD")
#define TOKEN_OPT_VALUE_ANY                    _T("ANY")


        // Igmp protocol types
#define TOKEN_OPT_VALUE_IGMPRTRV1              _T("IGMPRTRV1")
#define TOKEN_OPT_VALUE_IGMPRTRV2              _T("IGMPRTRV2")
#define TOKEN_OPT_VALUE_IGMPPROXY              _T("IGMPPROXY")

#define TOKEN_OPT_VALUE_TRUE                   _T("TRUE")
#define TOKEN_OPT_VALUE_FALSE                  _T("FALSE")
#define TOKEN_OPT_VALUE_HOST_JOIN              _T("HOSTJOIN")
#define TOKEN_OPT_VALUE_MGM_ONLY_JOIN          _T("MGMONLYJOIN")


        // Accept/Announce types
#define TOKEN_OPT_VALUE_RIP1                   _T("RIP1")
#define TOKEN_OPT_VALUE_RIP1_COMPAT            _T("RIP1COMPAT")
#define TOKEN_OPT_VALUE_RIP2                   _T("RIP2")

        // log level types
#define TOKEN_OPT_VALUE_ERROR                  _T("ERROR")
#define TOKEN_OPT_VALUE_WARN                   _T("WARN")
#define TOKEN_OPT_VALUE_INFO                   _T("INFO")

        // unicast peer modes
#define TOKEN_OPT_VALUE_ALSO                   _T("ALSO")
#define TOKEN_OPT_VALUE_ONLY                   _T("ONLY")

        // RIP Interface flag modes
#define TOKEN_OPT_VALUE_CLEAR                  _T("Clear")
#define TOKEN_OPT_VALUE_SPLIT_HORIZON          _T("SplitHorizon")
#define TOKEN_OPT_VALUE_POISON_REVERSE         _T("PoisonReverse")
#define TOKEN_OPT_VALUE_TRIGGERED_UPDATES      _T("TriggeredUpdates")
#define TOKEN_OPT_VALUE_CLEANUP_UPDATES        _T("CleanupUpdates")
#define TOKEN_OPT_VALUE_ACCEPT_HOST_ROUTES     _T("AcceptHostRoutes")
#define TOKEN_OPT_VALUE_SEND_HOST_ROUTES       _T("SendHostRoutes")
#define TOKEN_OPT_VALUE_ACCEPT_DEFAULT_ROUTES  _T("AcceptDefaultRoutes")
#define TOKEN_OPT_VALUE_SEND_DEFAULT_ROUTES    _T("SendDefaultRoutes")
#define TOKEN_OPT_VALUE_SUBNET_SUMMARY         _T("NoSubnetSummary")



        // filter modes
#define TOKEN_OPT_VALUE_INCLUDE                _T("INCLUDE")
#define TOKEN_OPT_VALUE_EXCLUDE                _T("EXCLUDE")

        // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")
#define TOKEN_OPT_VALUE_DIAL                   _T("DIAL")

#define TOKEN_OPT_VALUE_ENABLE                 _T("enable")
#define TOKEN_OPT_VALUE_DISABLE                _T("disable")
#define TOKEN_OPT_VALUE_DEFAULT                _T("default")

#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_OPT_VALUE_NONE                   _T("NONE")
#define TOKEN_OPT_VALUE_PASSWORD               _T("PASSWORD")

#define TOKEN_OPT_VALUE_DROP                   _T("DROP")
#define TOKEN_OPT_VALUE_FORWARD                _T("FORWARD")
#define TOKEN_OPT_VALUE_ACCEPT                 _T("ACCEPT")

#define TOKEN_OPT_VALUE_DEMAND                 _T("DEMAND")
#define TOKEN_OPT_VALUE_PERIODIC               _T("PERIODIC")

#define TOKEN_OPT_VALUE_NBMA                   _T("NBMA")
#define TOKEN_OPT_VALUE_POINT_TO_POINT         _T("P2P")
#define TOKEN_OPT_VALUE_BROADCAST              _T("BROADCAST")

#define TOKEN_OPT_VALUE_ADDRESSONLY            _T("ADDRESSONLY")
#define TOKEN_OPT_VALUE_PRIVATE                _T("PRIVATE")

#define TOKEN_OPT_VALUE_AUTH_NONE              _T("AUTHNONE")
#define TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD    _T("AUTHSIMPLEPASSWORD")

#define TOKEN_HLPER_RIP                        _T("rip")
#define TOKEN_HLPER_RIPMIB                     _T("ripmib")
#define TOKEN_HLPER_OSPF                       _T("ospf")
#define TOKEN_HLPER_OSPFMIB                    _T("ospfmib")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_MIB                                _T("mib")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // ip commands

#define CMD_IP_ADD_IF                          _T("add interface")
#define CMD_IP_DEL_IF                          _T("delete interface")
#define CMD_IP_ADD_IF_FILTER                   _T("add filter")
#define CMD_IP_DEL_IF_FILTER                   _T("delete filter")
#define CMD_IP_ADD_PROTO                       _T("add protocol")
#define CMD_IP_DEL_PROTO                       _T("delete protocol")
#define CMD_IP_ADD_ROUTEPREF                   _T("add routepref")
#define CMD_IP_DEL_ROUTEPREF                   _T("delete routepref")
#define CMD_IP_SET_IF                          _T("set interface")
#define CMD_IP_SET_IF_FILTER                   _T("set filter")
#define CMD_IP_SET_ROUTEPREF                   _T("set routepref")
#define CMD_IP_SET                             _T("set")

#define CMD_IP_SHOW_IF_FILTER                  _T("show filter")
#define CMD_IP_SHOW_IF                         _T("show interface")
#define CMD_IP_SHOW_ROUTEPREF                  _T("show routepref")
#define CMD_IP_SHOW_PROTOCOL                   _T("show protocol")
#define CMD_IP_SHOW                            _T("show")

    // rip add commands

#define CMD_RIP_ADD_PF                         _T("add peerfilter")
#define CMD_RIP_ADD_IF_ACCF                    _T("add acceptfilter")
#define CMD_RIP_ADD_IF_ANNF                    _T("add announcefilter")
#define CMD_RIP_ADD_IF_NBR                     _T("add neighbor")
#define CMD_RIP_ADD_IF                         _T("add interface")

    // rip delete commands

#define CMD_RIP_DEL_PF                         _T("delete peerfilter")
#define CMD_RIP_DEL_IF_ACCF                    _T("delete acceptfilter")
#define CMD_RIP_DEL_IF_ANNF                    _T("delete announcefilter")
#define CMD_RIP_DEL_IF_NBR                     _T("delete neighbor")
#define CMD_RIP_DEL_IF                         _T("delete interface")

    // rip set commands

#define CMD_RIP_SET_IF                         _T("set interface")
#define CMD_RIP_SET_FLAGS                      _T("set flags")
#define CMD_RIP_SET_GLOBAL                     _T("set global")

    // rip show commands

#define CMD_RIP_SHOW_IF                        _T("show interface")
#define CMD_RIP_SHOW_FLAGS                     _T("show flags")
#define CMD_RIP_SHOW_GLOBAL                    _T("show global")

    // DHCP relay agent add commands

#define CMD_BOOTP_ADD                          _T("add")
#define CMD_BOOTP_ADD_IF                       _T("add interface")
#define CMD_BOOTP_ADD_DHCP_SERVER              _T("add dhcpserver")

    // DHCP relay agent delete commands

#define CMD_BOOTP_DEL                          _T("delete")
#define CMD_BOOTP_DEL_IF                       _T("delete interface")
#define CMD_BOOTP_DEL_DHCP_SERVER              _T("delete dhcpserver")

    // DHCP relay agent set commands

#define CMD_BOOTP_SET_GLOBAL                   _T("set global")
#define CMD_BOOTP_SET_IF                       _T("set interface")

    // DHCP relay agent show commands

#define CMD_BOOTP_SHOW_GLOBAL                  _T("show global")
#define CMD_BOOTP_SHOW_IF                      _T("show interface")

    // IGMP commands

#define CMD_IGMP_ADD_IF_STATICGROUP            _T("add staticgroup")
#define CMD_IGMP_ADD_IF                        _T("add interface")

#define CMD_IGMP_DEL_IF_STATICGROUP            _T("delete staticgroup")
#define CMD_IGMP_DEL_IF                        _T("delete interface")

#define CMD_IGMP_SET_IF                        _T("set interface")
#define CMD_IGMP_SET_GLOBAL                    _T("set global")

#define CMD_IGMP_SHOW_IF                       _T("show interface")
#define CMD_IGMP_SHOW_GLOBAL                   _T("show global")

    // DHCP allocator commands
#define CMD_AUTODHCP_ADD_EXCLUSION             _T("add exclusion")
#define CMD_AUTODHCP_DELETE_EXCLUSION          _T("delete exclusion")
#define CMD_AUTODHCP_SET_GLOBAL                _T("set global")
#define CMD_AUTODHCP_SET_INTERFACE             _T("set interface")
#define CMD_AUTODHCP_SHOW_GLOBAL               _T("show global")
#define CMD_AUTODHCP_SHOW_INTERFACE            _T("show interface")

    // DNS proxy commands
#define CMD_DNSPROXY_SET_GLOBAL                _T("set global")
#define CMD_DNSPROXY_SET_INTERFACE             _T("set interface")
#define CMD_DNSPROXY_SHOW_GLOBAL               _T("show global")
#define CMD_DNSPROXY_SHOW_INTERFACE            _T("show interface")

    // NAT commands
#define CMD_NAT_ADD_ADDRESS_MAPPING            _T("add addressmapping")
#define CMD_NAT_ADD_ADDRESS_RANGE              _T("add addressrange")
#define CMD_NAT_ADD_DIRECTPLAY                 _T("add directplay")
#define CMD_NAT_ADD_H323                       _T("add h323")
#define CMD_NAT_ADD_INTERFACE                  _T("add interface")
#define CMD_NAT_ADD_PORT_MAPPING               _T("add portmapping")
#define CMD_NAT_DELETE_ADDRESS_MAPPING         _T("delete addressmapping")
#define CMD_NAT_DELETE_ADDRESS_RANGE           _T("delete addressrange")
#define CMD_NAT_DELETE_DIRECTPLAY              _T("delete directplay")
#define CMD_NAT_DELETE_H323                    _T("delete h323")
#define CMD_NAT_DELETE_INTERFACE               _T("delete interface")
#define CMD_NAT_DELETE_PORT_MAPPING            _T("delete portmapping")
#define CMD_NAT_SET_GLOBAL                     _T("set global")
#define CMD_NAT_SET_INTERFACE                  _T("set interface")
#define CMD_NAT_SHOW_GLOBAL                    _T("show global")
#define CMD_NAT_SHOW_INTERFACE                 _T("show interface")

    // RDISC commands
#define CMD_RDISC_ADD_INTERFACE                 L"add interface"
#define CMD_RDISC_DELETE_INTERFACE              L"delete interface"
#define CMD_RDISC_SET_INTERFACE                 L"set interface"
#define CMD_RDISC_SHOW_INTERFACE                L"show interface"

    // QOS commands

#define CMD_QOS_ADD_FILTER_TO_FLOW             _T("add filter")
#define CMD_QOS_ADD_QOSOBJECT_ON_FLOW          _T("add qoonflow")
#define CMD_QOS_ADD_FLOWSPEC_ON_FLOW           _T("add fsonflow")
#define CMD_QOS_ADD_FLOW_ON_IF                 _T("add flow")
#define CMD_QOS_ADD_IF                         _T("add interface")
#define CMD_QOS_ADD_DSRULE                     _T("add dsrule")
#define CMD_QOS_ADD_SDMODE                     _T("add sdmode")
#define CMD_QOS_ADD_FLOWSPEC                   _T("add flowspec")

#define CMD_QOS_DEL_FILTER_FROM_FLOW           _T("delete filter")
#define CMD_QOS_DEL_QOSOBJECT_ON_FLOW          _T("delete qoonflow")
#define CMD_QOS_DEL_FLOWSPEC_ON_FLOW           _T("delete fsonflow")
#define CMD_QOS_DEL_FLOW_ON_IF                 _T("delete flow")
#define CMD_QOS_DEL_IF                         _T("delete interface")
#define CMD_QOS_DEL_DSRULE                     _T("delete dsrule")
#define CMD_QOS_DEL_SDMODE                     _T("delete sdmode")
#define CMD_QOS_DEL_QOSOBJECT                  _T("delete qosobject")
#define CMD_QOS_DEL_FLOWSPEC                   _T("delete flowspec")

#define CMD_QOS_SET_FILTER_ON_FLOW             _T("set filter")
#define CMD_QOS_SET_FLOW_ON_IF                 _T("set flow")
#define CMD_QOS_SET_IF                         _T("set interface")
#define CMD_QOS_SET_GLOBAL                     _T("set global")

#define CMD_QOS_SHOW_FILTER_ON_FLOW            _T("show filter")
#define CMD_QOS_SHOW_FLOW_ON_IF                _T("show flow")
#define CMD_QOS_SHOW_IF                        _T("show interface")
#define CMD_QOS_SHOW_DSMAP                     _T("show dsmap")
#define CMD_QOS_SHOW_SDMODE                    _T("show sdmode")
#define CMD_QOS_SHOW_QOSOBJECT                 _T("show qosobject")
#define CMD_QOS_SHOW_FLOWSPEC                  _T("show flowspec")
#define CMD_QOS_SHOW_GLOBAL                    _T("show global")

    // Common dump commands

#define DMP_POPD L"\n\npopd\n"
#define DMP_UNINSTALL L"uninstall\n"

    // Igmp dump commands

#define DMP_IGMP_PUSHD L"\
pushd routing ip igmp\n"

#define DMP_IGMP_INSTALL _T("\
install\n")

#define DMP_IGMP_UNINSTALL _T("\
uninstall\n")

#define DMP_IGMP_SET_GLOBAL _T("\
set global loglevel = %1!s!\n")

#define DMP_IGMP_ADD_INTERFACE_RTRV1 _T("\
add interface name=%1!s! igmpprototype=%2!s!\
 ifenabled=%3!s!\
 robustvar=%4!d!\
 startupquerycount=%5!d!\
 startupqueryinterval=%6!d!\
 genqueryinterval=%7!d!\
 genqueryresptime=%8!d!\
 accnonrtralertpkts=%9!s!\n")

#define DMP_IGMP_ADD_INTERFACE_RTRV2 _T("\
add interface name=%1!s! igmpprototype=%2!s!\
 ifenabled=%3!s!\
 robustvar=%4!d!\
 startupquerycount=%5!d!\
 startupqueryinterval=%6!d!\
 genqueryinterval=%7!d!\
 genqueryresptime=%8!d!\
 lastmemquerycount=%9!d!\
 lastmemqueryinterval=%10!d!\
 accnonrtralertpkts=%11!s!\n")

#define DMP_IGMP_ADD_INTERFACE_PROXY _T("\
add interface name=%1!s! igmpprototype=%2!s! ifenabled=%3!s!\n")

#define DMP_IGMP_DELETE_INTERFACE _T("\
delete interface name=%1!s!\n")

#define DMP_IGMP_STATIC_GROUP _T("\
add staticgroup name=%1!s! staticgroup=%2!s! joinmode=%3!s!\n")

    // Rip dump commands

#define DMP_RIP_PUSHD L"\
pushd routing ip rip\n"

#define DMP_RIP_INSTALL _T("\
install\n")

#define DMP_RIP_UNINSTALL _T("\
uninstall\n")

#define DMP_RIP_SET_GLOBAL _T("\
set global loglevel=%1!s! mintrig=%2!d! peermode=%3!s!\n\n")

#define DMP_RIP_PEER_ADDR _T("\
add peerfilter server=%1!s!\n")

#define DMP_RIP_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")

#define DMP_RIP_ADD_INTERFACE _T("\
add interface name=%1!s! \n")

#define DMP_RIP_SET_INTERFACE _T("\
set interface name=%1!s!\
 metric=%2!d!\
 updatemode=%3!s!\
 announce=%4!s!\
 accept=%5!s!\
 expire=%6!d!\
 remove=%7!d!\
 update=%8!d!\
 authmode=%9!s!\
 tag=%10!d!\
 unicast=%11!s!\
 accfiltmode=%12!s!\
 annfiltmode=%13!s!\n")

#define DMP_RIP_SET_INTERFACE_PASSWORD _T("\
set interface name=%1!s!\
 password=%2!s!\n")

 
#define DMP_RIP_SET_FLAGS _T("\
set flags name=%1!s!\
 flag=%2!s!\n\n")

#define DMP_RIP_IF_UNICAST_PEER _T("\
add neighbor name=%1!s! server=%2!s!\n")

#define DMP_RIP_IF_ACC_FILTER _T("\
add acceptfilter name=%1!s! addr=%2!s! mask=%3!s!\n")

#define DMP_RIP_IF_ANN_FILTER _T("\
add announcefilter name=%1!s! addr=%2!s! mask=%3!s!\n")

    // QOS dump commands

#define DMP_QOS_PUSHD L"\
pushd routing ip qos\n"

#define DMP_QOS_INSTALL _T("\
install\n")

#define DMP_QOS_UNINSTALL _T("\
uninstall\n")


#define DMP_QOS_HEADER _T("\
\n")

#define DMP_QOS_FOOTER _T("\
\n")


#define DMP_QOS_GLOBAL_HEADER _T("\
\n")

#define DMP_QOS_GLOBAL_FOOTER _T("\
\n\n")

#define DMP_QOS_SET_GLOBAL _T("\
set global loglevel=%1!s!\n\n")


#define DMP_QOS_INTERFACE_HEADER _T("\
\n")

#define DMP_QOS_INTERFACE_FOOTER _T("\
\n\n")

#define DMP_QOS_ADD_INTERFACE _T("\
add interface name=%1!s!\
 state=%2!s!\n")

#define DMP_QOS_SET_INTERFACE _T("\
set interface name=%1!s!\
 state=%2!s!\n")

#define DMP_QOS_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")


#define DMP_QOS_ADD_FLOWSPEC _T("\
add flowspec name=%1!s!\
 servicetype=%2!s!\
 tokenrate=%3!d!\
 tokenbucketsize=%4!d!\
 peakbandwidth=%5!d!\
 latency=%6!d!\
 delayvariation=%7!d!\
 maxsdusize=%8!d!\
 minpolicedsize=%9!d!\n")

#define DMP_QOS_DELETE_FLOWSPEC _T("\
delete flowspec name=%1!s! \n")


#define DMP_QOS_ADD_SDMODE _T("\
add sdmode name=%1!s! shaping=%2!s!\n")

#define DMP_QOS_DEL_SDMODE _T("\
delete sdmode name=%1!s! \n")


#define DMP_QOS_DSMAP_HEADER _T("\
\n")

#define DMP_QOS_DSMAP_FOOTER _T("\
\n")

#define DMP_QOS_ADD_DSRULE _T("\
add dsrule name=%1!s! dsin=%2!d!\
 dsoutconf=%3!d! dsoutnonconf=%4!d!\
 priconf=%5!d! prinonconf=%6!d!\n")

#define DMP_QOS_DELETE_DSRULE _T("\
delete dsrule name=%1!s! dsin=%2!d!\n")


#define DMP_QOS_ADD_FLOW _T("\
add flow name=%1!s! flowname=%2!s!\n")

#define DMP_QOS_DELETE_FLOW _T("\
delete flow name=%1!s! flowname=%2!s!\n")


#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_IN  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! inbound\n")

#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_OUT  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! outbound\n")

#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_BI  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! bidirectional\n")


#define DMP_QOS_ADD_QOSOBJECT_ON_FLOW  _T("\
add qoonflow name=%1!s! flowname=%2!s! qosobject=%3!s!\n")

    // Router-discovery commands

#define DMP_RDISC_PUSHD L"\
pushd routing ip routerdiscovery\n"

#define DMP_RDISC_ADD_INTERFACE L"\
add interface name=%1!s! disc=%2!s! minint=%3!d!\
 maxint=%4!d! life=%5!d! level=%6!d!\n"

    //
    // DHCP relay commands
    //

#define DMP_BOOTP_PUSHD L"\
pushd routing ip relay\n"

#define DMP_BOOTP_INSTALL _T("\
install\n")

#define DMP_BOOTP_UNINSTALL _T("\
uninstall\n")

#define DMP_BOOTP_SET_GLOBAL _T("\
set global loglevel=%1!s!\n\n")

#define DMP_BOOTP_DHCP_SERVER_ADD _T("\
add dhcpserver server=%1!s!\n")

#define DMP_BOOTP_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")

#define DMP_BOOTP_ADD_INTERFACE _T("\
add interface name=%1!s! \n")

#define DMP_BOOTP_SET_INTERFACE _T("\
set interface name=%1!s! relaymode=%2!s! maxhop=%3!d! minsecs=%4!d!\n\n")

    //
    // DHCP allocator commands
    //
#define DMP_AUTODHCP_EXCLUSION _T("\
add exclusion %1!s!=%2!s!\n")

#define DMP_AUTODHCP_INSTALL _T("\
install\n")

#define DMP_AUTODHCP_PUSHD L"\
pushd routing ip autodhcp\n"

#define DMP_AUTODHCP_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_AUTODHCP_SET_INTERFACE _T("\
set interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_AUTODHCP_UNINSTALL _T("\
uninstall\n")

    //
    // DNS proxy commands
    //
#define DMP_DNSPROXY_INSTALL _T("\
install\n")

#define DMP_DNSPROXY_PUSHD L"\
pushd routing ip dnsproxy\n"

#define DMP_DNSPROXY_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_DNSPROXY_SET_INTERFACE _T("\
set interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_DNSPROXY_UNINSTALL _T("\
uninstall\n")

    //
    // NAT commands
    //
#define DMP_NAT_ADD_INTERFACE _T("\
add interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_NAT_ADDRESS_MAPPING _T("\
add addressmapping %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_NAT_ADDRESS_RANGE _T("\
add addressrange %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_NAT_PORT_MAPPING _T("\
add portmapping %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s! %9!s!=%10!s! %11!s!=%12!s!\n")

#define DMP_NAT_INSTALL _T("\
install\n")

#define DMP_NAT_PUSHD L"\
pushd routing ip nat\n"

#define DMP_NAT_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s!\n")

#define DMP_NAT_UNINSTALL _T("\
uninstall\n")

    // Ospf dump commands

#define DMP_OSPF_PUSHD _T("\
\npushd routing ip ospf")

#define DMP_OSPF_INSTALL _T("\
\ninstall")

#define DMP_OSPF_UNINSTALL _T("\
\nuninstall")

#define DMP_OSPF_SET_GLOBAL _T("\
\nset global routerid=%1!s! asborder=%2!s! loglevel=%3!s!")

#define DMP_OSPF_ROUTE_FILTER_HEADER _T("\
\n\n#Route filter configuration\n")

#define DMP_OSPF_ADD_ROUTE_FILTER _T("\
\nadd routefilter filter=%1!s! %2!s!")

#define DMP_OSPF_SET_ROUTE_FILTER_ACTION _T("\
\nset routefilter action = %1!s!")

#define DMP_OSPF_ADD_PROTO_FILTER _T("\
\nadd protofilter filter=%1!s!")

#define DMP_OSPF_PROTOCOL_FILTER_HEADER _T("\
\n\n#Protocol filter configuration\n")

#define DMP_OSPF_SET_PROTO_FILTER_ACTION _T("\
\nset protofilter action = %1!s!")

#define DMP_OSPF_DELETE_INTERFACE _T("\
\ndelete interface name=%1!s!")

#define DMP_OSPF_ADD_INTERFACE _T("\
\nadd interface name=%1!s! area=%2!s!")

#define DMP_OSPF_ADD_MULT_INTERFACE _T("\
\nadd interface name=%1!s!\
    area=%2!s!\
    addr=%3!s!\
    mask=%4!s!")

#define DMP_OSPF_SET_INTERFACE _T("\
\nset interface name=%1!s!\
    state=%2!s!\
    area=%3!s!\
    type=%4!s!\
    prio=%5!d!\
    transdelay=%6!d!\
    retrans=%7!d!\
    hello=%8!d!\
    dead=%9!d!\
    poll=%10!d!\
    metric=%11!d!\
    mtu=%12!d!")

#define DMP_OSPF_SET_MULT_INTERFACE _T("\
\nset interface name=%1!s!\
    addr=%2!s!\
    mask=%3!s!\
    state=%4!s!\
    area=%5!s!\
    type=%6!s!\
    prio=%7!d!\
    transdelay=%8!d!\
    retrans=%9!d!\
    hello=%10!d!\
    dead=%11!d!\
    poll=%12!d!\
    metric=%13!d!\
    mtu=%14!d!")

#define DMP_OSPF_SET_INTERFACE_PASSWORD _T("\
\nset interface name=%1!s!\
    password=%2!s!")
    
#define DMP_OSPF_SET_MULT_INTERFACE_PASSWORD _T("\
\nset interface name=%1!s!\
    addr=%2!s!\
    mask=%3!s!\
    password=%4!s!")


#define DMP_OSPF_AREA_HEADER _T("\
\n\n# Configuration for area %1!s!\n")

#define DMP_OSPF_DELETE_AREA _T("\
\ndelete area areaid=%1!s!")

#define DMP_OSPF_ADD_AREA _T("\
\nadd area areaid=%1!s!")

#define DMP_OSPF_SET_AREA _T("\
\nset area areaid=%1!s! auth=%2!s! stubarea=%3!s! metric=%4!d! sumadv=%5!s!")

#define DMP_OSPF_ADD_AREA_RANGE _T("\
\nadd range areaid=%1!s!\
    range=%2!s! %3!s!")

#define DMP_OSPF_NEIGHBOR_HEADER _T("\
\n\n#Neighbor configuration for %1!s!\n")

#define DMP_OSPF_ADD_NEIGHBOR _T("\
\nadd neighbor name=%1!s! addr=%2!s! nbraddr=%3!s! nbrprio=%4!d!")

#define DMP_OSPF_DELETE_NEIGHBOR _T("\
\ndelete neighbor name=%1!s! addr=%2!s! nbraddr=%3!s!")

#define DMP_OSPF_VIRTUAL_INTERFACE_HEADER _T("\
\n\n#Configuration for virtual interface AREA %1!s! NEIGHBOR %2!s!\n")

#define DMP_OSPF_ADD_VIRTUAL_INTERFACE _T("\
\nadd virtif transareaid=%1!s! virtnbrid=%2!s!")

#define DMP_OSPF_DELETE_VIRTUAL_INTERFACE _T("\
\ndelete virtif transareaid=%1!s! virtnbrid=%2!s!")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE _T("\
\nset virtif transareaid=%1!s! virtnbrid=%2!s!\
    transdelay=%3!d! retrans=%4!d! hello=%5!d!\
    dead=%6!d!")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE_PASSWORD _T("\
\nset virtif transareaid=%1!s! virtnbrid=%2!s!\
    password=%3!s!")

    // Ospf hlp commands

#define CMD_OSPF_ADD_AREA_RANGE                _T("add range")
#define CMD_OSPF_ADD_AREA                      _T("add area")
#define CMD_OSPF_ADD_VIRTIF                    _T("add virtif")
#define CMD_OSPF_ADD_IF_NBR                    _T("add neighbor")
#define CMD_OSPF_ADD_IF                        _T("add interface")
#define CMD_OSPF_ADD_ROUTE_FILTER              _T("add routefilter")
#define CMD_OSPF_ADD_PROTO_FILTER              _T("add protofilter")
#define CMD_OSPF_ADD                           _T("add")

#define CMD_OSPF_DEL_AREA_RANGE                _T("delete range")
#define CMD_OSPF_DEL_AREA                      _T("delete area")
#define CMD_OSPF_DEL_VIRTIF                    _T("delete virtif")
#define CMD_OSPF_DEL_IF_NBR                    _T("delete neighbor")
#define CMD_OSPF_DEL_IF                        _T("delete interface")
#define CMD_OSPF_DEL_ROUTE_FILTER              _T("delete routefilter")
#define CMD_OSPF_DEL_PROTO_FILTER              _T("delete protofilter")
#define CMD_OSPF_DEL                           _T("delete")

#define CMD_OSPF_SET_AREA                      _T("set area")
#define CMD_OSPF_SET_VIRTIF                    _T("set virtif")
#define CMD_OSPF_SET_IF                        _T("set interface")
#define CMD_OSPF_SET_GLOBAL                    _T("set global")
#define CMD_OSPF_SET_ROUTE_FILTER              _T("set routefilter")
#define CMD_OSPF_SET_PROTO_FILTER              _T("set protofilter")

#define CMD_OSPF_SHOW_GLOBAL                   _T("show global")
#define CMD_OSPF_SHOW_AREA                     _T("show area")
#define CMD_OSPF_SHOW_VIRTIF                   _T("show virtif")
#define CMD_OSPF_SHOW_IF                       _T("show interface")
#define CMD_OSPF_SHOW_ROUTE_FILTER             _T("show routefilter")
#define CMD_OSPF_SHOW_PROTO_FILTER             _T("show protofilter")
#define CMD_OSPF_SHOW                          _T("show")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\qoscfg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qoscfg.c

Abstract:

    Fns to change configuration for IP QOS

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop


static IPQOS_GLOBAL_CONFIG
g_ipqosGlobalDefault = {
    IPQOS_LOGGING_ERROR                 // Logging level
};

static BYTE* g_pIpqosGlobalDefault = (BYTE*)&g_ipqosGlobalDefault;

static IPQOS_IF_CONFIG
g_ipqosInterfaceDefault = {
    IPQOS_STATE_ENABLED,
    0                                   // NULL flow list
};

static BYTE* g_pIpqosInterfaceDefault = (BYTE*)&g_ipqosInterfaceDefault;


//
// If one of the arguments is specified with a name tag
// then all arguments must come with name tags.
// If no name tags, then arguments are assumed to be in a certain order
//

DWORD
MakeQosGlobalInfo(
    OUT      PBYTE                    *ppbStart,
    OUT      PDWORD                   pdwSize
    )
/*++

Routine Descqostion:

    Creates a QOS global info block.

Arguments:

    ppbStart  - Pointer to the info block
    pdwSize   - Pointer to size of the info block
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPQOS_GLOBAL_CONFIG);

    *ppbStart = HeapAlloc(GetProcessHeap(), 0, *pdwSize);

    if (*ppbStart is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    CopyMemory( *ppbStart, g_pIpqosGlobalDefault, *pdwSize);
    
    return NO_ERROR;
}

DWORD
ShowQosGlobalInfo (
    HANDLE hFile
    )
/*++

Routine Descqostion:

    Displays QOS global config info

Arguments:

Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    VALUE_TOKEN    vtLogLevelTable1[] 
                                = {IPQOS_LOGGING_NONE,TOKEN_OPT_VALUE_NONE,
                                   IPQOS_LOGGING_ERROR,TOKEN_OPT_VALUE_ERROR,
                                   IPQOS_LOGGING_WARN,TOKEN_OPT_VALUE_WARN,
                                   IPQOS_LOGGING_INFO,TOKEN_OPT_VALUE_INFO};

    VALUE_STRING   vtLogLevelTable2[] 
                                = {IPQOS_LOGGING_NONE,STRING_LOGGING_NONE,
                                   IPQOS_LOGGING_ERROR,STRING_LOGGING_ERROR,
                                   IPQOS_LOGGING_WARN,STRING_LOGGING_WARN,
                                   IPQOS_LOGGING_INFO,STRING_LOGGING_INFO};

    PIPQOS_GLOBAL_CONFIG pigc = NULL;
    PTCHAR   ptszLogLevel = NULL;
    DWORD    dwBlkSize, dwCount, dwRes;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                  (PBYTE *) &pigc,
                                                  &dwBlkSize,
                                                  &dwCount);
        if (dwBlkSize is 0)
        {
            dwRes = ERROR_NOT_FOUND;
        }
        
        if ( dwRes isnot NO_ERROR )
        {
            break;
        }

        //
        // getting logging mode string
        //

        if (hFile) 
        {
            dwRes = GetDisplayStringT(g_hModule,
                                      pigc->LoggingLevel,
                                      vtLogLevelTable1,
                                      NUM_VALUES_IN_TABLE(vtLogLevelTable1),
                                      &ptszLogLevel) ;
        } 
        else 
        {
            dwRes = GetDisplayString(g_hModule,
                                     pigc->LoggingLevel,
                                     vtLogLevelTable2,
                                     NUM_VALUES_IN_TABLE(vtLogLevelTable1),
                                     &ptszLogLevel) ;
        }

        if (dwRes != NO_ERROR)
            return dwRes ;
        

        if ( ptszLogLevel == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            //
            // dump qos global info
            //
            
            // DisplayMessageT(DMP_QOS_GLOBAL_HEADER) ;

            // DisplayMessageT(DMP_QOS_UNINSTALL) ;
            
            DisplayMessageT(DMP_QOS_INSTALL) ;
            
            DisplayMessageT(DMP_QOS_SET_GLOBAL,
                            ptszLogLevel);

            // DisplayMessageT(DMP_QOS_GLOBAL_FOOTER) ;
        }
        else
        {
            //
            // display qos global info
            //

            DisplayMessage(g_hModule, 
                           MSG_QOS_GLOBAL_INFO,
                           ptszLogLevel);
        }

        dwRes = NO_ERROR;

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(pigc);
    
    if ( ptszLogLevel ) { FreeString( ptszLogLevel ); }

    if (hFile is NULL)
    {
        switch(dwRes)
        {
            case NO_ERROR:
                break;
    
            case ERROR_NOT_FOUND:
                DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
                break;
                
            case ERROR_NOT_ENOUGH_MEMORY:
                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                break;
    
            default:
                DisplayError(g_hModule, dwRes);
                break;
        }
    }
    
    return NO_ERROR;
}


DWORD
UpdateQosGlobalConfig(
    PIPQOS_GLOBAL_CONFIG   pigcGlobalCfg,
    DWORD                  dwBitVector
    )
/*++

Routine Descqostion:

    Updates QOS global config info

Arguments:

    pigcGlobalCfg - The new values to be set
    dwBitVector   - Which fields need to be modified
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{

    DWORD                   dwRes = (DWORD) -1, dwIndex     = (DWORD) -1;
    DWORD                   dwSize      = 0, dwCount, i, j;
    DWORD                   dwBlkSize, dwNewBlkSize, dwQosCount;
    PDWORD                  pdwAddrTable= NULL, pdwNewAddrTable = NULL;
    PDWORD                  pdwSrcAddrTable = NULL;
    PIPQOS_GLOBAL_CONFIG    pigcSrc     = NULL, pigcDst     = NULL;
    PBOOL                   pbToDelete;


    DEBUG("In UpdateQosGlobalConfig");

    if (dwBitVector is 0)
    {
        return ERROR_OKAY;
    }

    //
    // Get Global Config info from Registry first
    //

    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                  (PBYTE *) &pigcSrc,
                                                  &dwBlkSize,
                                                  &dwQosCount);
    
        if (dwRes != NO_ERROR)
        {
            break;
        }
        
        if ( pigcSrc == NULL )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        //
        // We have a fixed len global info - so
        // no reallocation and recopy necessary
        //
        dwNewBlkSize = dwBlkSize;

        pigcDst = pigcSrc;

        if (dwBitVector & QOS_LOG_MASK)
        {
            pigcDst->LoggingLevel = pigcGlobalCfg->LoggingLevel;
        }

        //
        // Set the info
        //
        
        dwRes = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwRes != NO_ERROR)
        {
            break;
        }
        
            
    } while (FALSE);
    
    HEAP_FREE_NOT_NULL(pigcSrc);

    //
    // error processing
    //

    switch(dwRes)
    {
    case NO_ERROR:

        dwRes = ERROR_OKAY;

        break;

    case ERROR_NOT_FOUND:

        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO );

        dwRes = ERROR_SUPPRESS_OUTPUT;

        break;

    default:

        break;
    }

    return dwRes;
}


DWORD
MakeQosInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    )
/*++

Routine Descqostion:

    Creates a QOS interface info block.

Arguments:

    rifType   - Interface type
    ppbStart  - Pointer to the info block
    pdwSize   - Pointer to size of the info block
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPQOS_IF_CONFIG);

    *ppbStart = HeapAlloc(GetProcessHeap(), 0, *pdwSize);

    if (*ppbStart is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory( *ppbStart, g_pIpqosInterfaceDefault, *pdwSize);

    return NO_ERROR;
}


DWORD
ShowQosAllInterfaceInfo(
    IN    HANDLE    hFile
    )
/*++

Routine Descqostion:

    Displays config info for all
    qos enabled interfaces

Arguments:

    hFile - NULL, or file handle
    
--*/
{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i, dwNumBlocks=1, dwSize, dwIfType;
    PBYTE               pBuffer;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];


    //
    // dump qos config for all interfaces
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &dwCount,
                                 &dwTotal);
    if(dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that Qos is configured on that interface

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                                     MS_IP_QOSMGR,
                                                     &pBuffer,
                                                     &dwSize,
                                                     &dwNumBlocks,
                                                     &dwIfType);
        if (dwErr isnot NO_ERROR) {
            continue;
        }
        else {
            HEAP_FREE(pBuffer) ;
        }


        ShowQosInterfaceInfo(hFile, pmi0[i].wszInterfaceName) ;

        //
        // At this point we do not have any flags on interface
        // 
        // if (hFile)
        // {
        //    //
        //    // only for dump include the flag setting as part of
        //    // interface settings.  Otherwise Interface flag settings
        //    // are handled by the show flags command
        //    //
        // 
        //    ShowQosInterfaceFlags(hFile, pmi0[i].wszInterfaceName);
        // }
    }
    return NO_ERROR ;

}


DWORD
ShowQosInterfaceInfo(
    IN    HANDLE    hFile,
    IN    PWCHAR    pwszIfGuid
    )
/*++

Routine Descqostion:

    Displays QOS interface config info

Arguments:

    pwszIfGuid - Interface name
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    WCHAR   wszInterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ] = L"\0";
    PWCHAR  pwszFriendlyIfName = NULL;

    DWORD   dwBufferSize = sizeof(wszInterfaceName);

    DWORD                   dwRes           = (DWORD) -1,
                            dwCnt           = 0;

    PDWORD                  pdwAddr         = NULL;

    PIPQOS_IF_CONFIG        piic            = NULL;

    PTCHAR                  ptszState       = NULL;

    VALUE_TOKEN  vtStateTable1[] 
                             = {IPQOS_STATE_ENABLED,TOKEN_OPT_VALUE_ENABLE,
                                IPQOS_STATE_DISABLED,TOKEN_OPT_VALUE_DISABLE};

    VALUE_STRING vtStateTable2[] 
                             = {IPQOS_STATE_ENABLED,STRING_ENABLED,
                                IPQOS_STATE_DISABLED,STRING_DISABLED};

    DWORD                   dwBlkSize, dwIfType, dwCount;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfGuid,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piic,
                                                     &dwBlkSize,
                                                     &dwCount,
                                                     &dwIfType);
        
        if (dwBlkSize is 0)
            dwRes = ERROR_NOT_FOUND;

        if (dwRes isnot NO_ERROR)
        {
            break;
        }

        //
        // get friendly name for interface
        //
    
        dwRes = IpmontrGetFriendlyNameFromIfName( pwszIfGuid,
                                                  wszInterfaceName,
                                                  &dwBufferSize );
    
        if ( dwRes isnot NO_ERROR )
        {
            break;
        }
    
        pwszFriendlyIfName = MakeQuotedString( wszInterfaceName );
    
        if ( pwszFriendlyIfName == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
    
            break;
        }

        //
        // get state of the interface
        //

        GetAltDisplayString(g_hModule, hFile,
                      piic->QosState,
                      vtStateTable1,
                      vtStateTable2,
                      NUM_VALUES_IN_TABLE(vtStateTable1),
                      &ptszState);

        if ( ptszState == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_INTERFACE_HEADER,
                            pwszFriendlyIfName);

            DisplayMessageT(DMP_QOS_DELETE_INTERFACE,
                           pwszFriendlyIfName);

            DisplayMessageT(DMP_QOS_ADD_INTERFACE,
                           pwszFriendlyIfName,
                           ptszState);

            DisplayMessageT(DMP_QOS_SET_INTERFACE,
                           pwszFriendlyIfName,
                           ptszState);

            ShowQosFlowsOnIf(hFile, pwszIfGuid, NULL);

            DisplayMessageT(DMP_QOS_INTERFACE_FOOTER,
                            pwszFriendlyIfName);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_IF_INFO,
                           pwszFriendlyIfName,
                           ptszState);

            ShowQosFlowsOnIf(hFile, pwszIfGuid, NULL);
        }


        dwRes = NO_ERROR;

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(piic);

    FREE_STRING_NOT_NULL( ptszState ) ;

    if ( pwszFriendlyIfName )
    {
        FreeQuotedString( pwszFriendlyIfName );
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO,
                                L"RouterInterfaceConfig");
            break;
            
        default:
            DisplayError(g_hModule, dwRes);
            break;
    }

    return NO_ERROR;
}

DWORD
UpdateQosInterfaceConfig( 
    IN    PWCHAR              pwszIfGuid,                         
    IN    PIPQOS_IF_CONFIG    pChangeCfg,
    IN    DWORD               dwBitVector,
    IN    BOOL                bAddSet
    )
/*++

Routine Descqostion:

    Updates QOS interface config info

Arguments:

    pwszIfGuid    - Interface name
    pFinalCfg     - The old config(if bSet), or default config(if bAdd)
    pChangeCfg    - The changes to be applied to pFinalCfg (specified 
                    on cmd line)
    dwBitVector   - Which fields need to be modified
    bAddSet       - Is the interface being added or set.
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD                   dwErr       = NO_ERROR, dwSize = 0, dwQosCount=1;
    DWORD                   i, dwIfType;
    PIPQOS_IF_CONFIG        pFinalCfg, piicDst     = NULL;

    DEBUG("In UpdateQosInterfaceConfig");

    do
    {
        if (bAddSet) {

            //
            // Create default protocol info block
            //

            dwErr = IpmontrGetInterfaceType(pwszIfGuid, &dwIfType);
            
            if (dwErr isnot NO_ERROR)
            {
                break;
            }


            dwErr = MakeQosInterfaceInfo(dwIfType,(PBYTE *)&pFinalCfg,&dwSize);

            if (dwErr isnot NO_ERROR)
            {
                break;
            }


        }
        else {
            
            //
            // get current interface config
            //

            dwErr = GetInfoBlockFromInterfaceInfoEx(pwszIfGuid,
                                                    MS_IP_QOSMGR,
                                                    (PBYTE *)&pFinalCfg,
                                                    &dwSize,
                                                    &dwQosCount,
                                                    &dwIfType);

            if (dwErr isnot NO_ERROR)
            {
                return dwErr;
            }
        }

        piicDst = HeapAlloc(GetProcessHeap(), 0, dwSize);

        if ( piicDst == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Update the state on interface (and other vars)
        //

        *piicDst = *pFinalCfg;

        if (dwBitVector & QOS_IF_STATE_MASK)
        {
            piicDst->QosState = pChangeCfg->QosState;
        }

        //
        // Set the info
        //
        
        dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfGuid,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwSize,
                                                   dwQosCount);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(pFinalCfg);
    HEAP_FREE_NOT_NULL(piicDst);

    return dwErr;
}

DWORD
UpdateAllInterfaceConfigs(
    VOID
    )
{
    PMPR_INTERFACE_0    pmi0;
    PIPQOS_IF_CONFIG    piicBlk;
    DWORD               dwErr, dwCount, dwTotal, i;
    DWORD               dwBlkSize, dwBlkCount, dwIfType;

    //
    // Enumerate all interfaces applicable to QOS
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &dwCount,
                                 &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for (i = 0; i < dwCount; i++)
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicBlk,
                                                     &dwBlkSize,
                                                     &dwBlkCount,
                                                     &dwIfType);

        if (dwErr == NO_ERROR)
        {
            //
            // Get and set back the interface info
            //

            dwErr =IpmontrSetInfoBlockInInterfaceInfo(pmi0[i].wszInterfaceName,
                                                      MS_IP_QOSMGR,
                                                      (PBYTE) piicBlk,
                                                      dwBlkSize,
                                                      dwBlkCount);
            HEAP_FREE(piicBlk);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\common.c ===
#include "precomp.h"
#pragma hdrstop

// {0705ECA3-7AAC-11d2-89DC-006008B0E5B9}
const GUID g_MyGuid = 
{ 0x705eca3, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } };

static const GUID g_IpGuid = IPMONTR_GUID;

#define IPPROMON_HELPER_VERSION 1

// shell functions

PNS_REGISTER_HELPER     RegisterHelper;
PNS_MATCH_CMD_LINE      MatchCmdToken;
PNS_MATCH_TOKEN         MatchToken;
PNS_MATCH_ENUM_TAG      MatchEnumTag;
PNS_MATCH_TAGS_IN_CMD_LINE     MatchTagsInCmdLine;
PNS_MAKE_STRING         MakeString;
PNS_FREE_STRING         FreeString;
PNS_MAKE_QUOTED_STRING  MakeQuotedString;
PNS_FREE_QUOTED_STRING  FreeQuotedString;
PNS_DISPLAY_ERR         DisplayError;
PNS_DISPLAY_MSG         DisplayMessage;
PNS_DISPLAY_MSG_T       DisplayMessageT;
PNS_EXECUTE_HANDLER     ExecuteHandler;
PNS_INIT_CONSOLE        InitializeConsole;
PNS_DISPLAY_MSG_CONSOLE DisplayMessageMib;
PNS_REFRESH_CONSOLE     RefreshConsole;
PNS_UPDATE_NEW_CONTEXT  UpdateNewContext;
PNS_PREPROCESS_COMMAND  PreprocessCommand;

ULONG StartedCommonInitialization, CompletedCommonInitialization ;
HANDLE g_hModule;
MIB_SERVER_HANDLE g_hMibServer;

VOID
CommonNetshInit(
    IN  PNETSH_ATTRIBUTES           pUtilityTable
    )
{
    //
    // common utility functions exported by the shell
    //
        
    RegisterHelper              = pUtilityTable->pfnRegisterHelper;
    MatchCmdToken               = pUtilityTable->pfnMatchCmdLine;
    MatchToken                  = pUtilityTable->pfnMatchToken;
    MatchEnumTag                = pUtilityTable->pfnMatchEnumTag;
    MatchTagsInCmdLine          = pUtilityTable->pfnMatchTagsInCmdLine;
    MakeString                  = pUtilityTable->pfnMakeString;
    FreeString                  = pUtilityTable->pfnFreeString;
    MakeQuotedString            = pUtilityTable->pfnMakeQuotedString;
    FreeQuotedString            = pUtilityTable->pfnFreeQuotedString;
    DisplayError                = pUtilityTable->pfnDisplayError;
    DisplayMessage              = pUtilityTable->pfnDisplayMessage;
    DisplayMessageT             = pUtilityTable->pfnDisplayMessageT;
    ExecuteHandler              = pUtilityTable->pfnExecuteHandler;
    InitializeConsole           = pUtilityTable->pfnInitializeConsole;
    DisplayMessageMib           = pUtilityTable->pfnDisplayMessageToConsole;
    RefreshConsole              = pUtilityTable->pfnRefreshConsole;
    UpdateNewContext            = pUtilityTable->pfnUpdateNewContext;
    PreprocessCommand           = pUtilityTable->pfnPreprocessCommand;
}

BOOL WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IppromonStartHelper(
    IN CONST GUID *pguidParent,
    IN PVOID       pfnRegisterContext,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    PNS_REGISTER_CONTEXT RegisterContext 
        = (PNS_REGISTER_CONTEXT) pfnRegisterContext;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!

    // Register the IGMP context

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes)); 

    attMyAttributes.pwszContext = L"igmp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = IgmpDump;
    attMyAttributes.ulNumTopCmds= g_ulNumIgmpTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_IgmpCmds;
    attMyAttributes.ulNumGroups = g_ulIgmpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IgmpCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the RIP context

    attMyAttributes.pwszContext = L"rip";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = RipDump;
    attMyAttributes.ulNumTopCmds= g_ulRipNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_RipCmds;
    attMyAttributes.ulNumGroups = g_ulRipNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RipCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the OSPF context

    attMyAttributes.pwszContext = L"ospf";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = OspfDump;
    attMyAttributes.ulNumTopCmds= g_ulOspfNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_OspfCmds;
    attMyAttributes.ulNumGroups = g_ulOspfNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_OspfCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the RouterDiscovery relay context

    attMyAttributes.pwszContext = L"routerdiscovery";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = RdiscDump;
    attMyAttributes.ulNumTopCmds= g_RdiscTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_RdiscTopCmdTable;
    attMyAttributes.ulNumGroups = g_RdiscCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RdiscCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the DHCP relay context

    attMyAttributes.pwszContext = L"relay";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = BootpDump;
    attMyAttributes.ulNumTopCmds= g_ulBootpNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_BootpTopCmds;
    attMyAttributes.ulNumGroups = g_ulBootpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_BootpCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the Connection sharing contexts

    attMyAttributes.pwszContext = L"autodhcp";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = AutoDhcpDump;
    attMyAttributes.ulNumTopCmds= g_AutoDhcpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_AutoDhcpTopCmdTable;
    attMyAttributes.ulNumGroups = g_AutoDhcpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_AutoDhcpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    attMyAttributes.pwszContext = L"dnsproxy";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = DnsProxyDump;
    attMyAttributes.ulNumTopCmds= g_DnsProxyTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_DnsProxyTopCmdTable;
    attMyAttributes.ulNumGroups = g_DnsProxyCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_DnsProxyCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    attMyAttributes.pwszContext = L"nat";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = NatDump;
    attMyAttributes.ulNumTopCmds= g_NatTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_NatTopCmdTable;
    attMyAttributes.ulNumGroups = g_NatCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_NatCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    attMyAttributes.pwszContext = L"qos";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = QosDump;
    attMyAttributes.ulNumTopCmds= g_ulQosNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_QosCmds;
    attMyAttributes.ulNumGroups = g_ulQosNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_QosCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  PNETSH_ATTRIBUTES        pUtilityTable,
    OUT PNS_DLL_ATTRIBUTES       pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    CommonNetshInit( pUtilityTable );

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPPROMON_HELPER_VERSION;
    attMyAttributes.pfnStart           = IppromonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpGuid, &attMyAttributes );

    return dwErr;
}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    DWORD  dwNameId,
    DWORD dwErrorLog
    )
/*++

Routine Description:

    Finds if the protocol is already installed

Arguments:

    dwProtoId      - protocol id
    pswzName       - protocol name
    dwErrorLog     - TRUE(if not installed display error)
                     FALSE(if installed display error)
                     -1 (do not display error log)
Return Value:

    TRUE if protocol already installed, else FALSE

--*/

{
    PVOID       pvStart;
    DWORD       dwCount, dwBlkSize, dwRes;
    WCHAR      *pwszName;

    dwRes = IpmontrGetInfoBlockFromGlobalInfo(dwProtoId,
                                       (PBYTE *) NULL,
                                       &dwBlkSize,
                                       &dwCount);

    if ((dwRes isnot NO_ERROR) && (dwErrorLog == TRUE))
    {
        pwszName = MakeString( g_hModule, dwNameId);
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
        FreeString(pwszName);
    }
    else if ((dwRes == NO_ERROR) && (dwErrorLog == FALSE))
    {
        pwszName = MakeString( g_hModule, dwNameId);
        DisplayError(g_hModule, EMSG_PROTO_INSTALLED, pwszName);
        FreeString(pwszName);
    }

    return (dwRes == NO_ERROR) ? TRUE : FALSE;
}

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command

Return Value:

    NO_ERROR

--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IpmontrGetIfIndexFromFriendlyName( g_hMibServer,
                                       pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\qosopt.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qosopt.c

Abstract:

    Fns to parse QOS commands

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop


//
// Install, Uninstall Handlers
//

DWORD
HandleQosInstall(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for adding QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/

{
    PBYTE    pbInfoBlk;
    DWORD    dwSize, dwErr;
    
    //
    // No options expected for add command.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    pbInfoBlk = NULL;

    do
    {
        dwErr = MakeQosGlobalInfo( &pbInfoBlk, &dwSize);

        if (dwErr != NO_ERROR)
        {
            break;
        }

        //
        // Add Qos to global block
        //
    
        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                pbInfoBlk,
                                                dwSize,
                                                1);

        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    } 
    while (FALSE);

    HEAP_FREE_NOT_NULL(pbInfoBlk);
   
    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
HandleQosUninstall(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for deleting QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/

{
    DWORD dwErr;

    //
    // No options expected for add command.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = IpmontrDeleteProtocol(MS_IP_QOSMGR);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}



//
// Add, Del, Show Child Helpers
//


//
// Set and Show Global Handlers
//

DWORD
HandleQosSetGlobal(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for setting QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/
{
    DWORD                  dwBitVector;
    DWORD                  dwErr, dwRes;
    DWORD                  dwNumArg, i, j;
    IPQOS_GLOBAL_CONFIG    igcGlobalCfg;
    TAG_TYPE               pttTags[] = {{TOKEN_OPT_LOG_LEVEL,FALSE,FALSE}};
    DWORD                  pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    dwBitVector = 0;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // Tag LOGLEVEL
                //
                
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_VALUE_NONE, IPQOS_LOGGING_NONE},
                     {TOKEN_OPT_VALUE_ERROR, IPQOS_LOGGING_ERROR},
                     {TOKEN_OPT_VALUE_WARN, IPQOS_LOGGING_WARN},
                     {TOKEN_OPT_VALUE_INFO, IPQOS_LOGGING_INFO}};

                GET_ENUM_TAG_VALUE();
                
                igcGlobalCfg.LoggingLevel = dwRes;

                dwBitVector |= QOS_LOG_MASK;

                break;
            }
            
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    if (dwErr == NO_ERROR)
    {
        if (dwBitVector)
        {
            dwErr = UpdateQosGlobalConfig(&igcGlobalCfg,
                                          dwBitVector);
        }
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
HandleQosShowGlobal(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // Does not expect any arguments. If any are specified, report error.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        return ERROR_INVALID_SYNTAX;
    }

    return ShowQosGlobalInfo(NULL);
}



//
// Add, Del, Set, Show If Handlers
//

DWORD
HandleQosAddIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for add interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    dwErr
    
--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwErr, dwIfType, dwBlkSize, dwBitVector = 0, dwCount;
    IPQOS_IF_CONFIG ChangeCfg;

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get optional parameters that are also being set
    //

    ZeroMemory(&ChangeCfg, sizeof(IPQOS_IF_CONFIG));

    dwErr = GetQosSetIfOpt(pptcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            wszInterfaceName,
                            sizeof(wszInterfaceName),
                            &ChangeCfg,
                            &dwBitVector,
                            ADD_FLAG
                            );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        //
        // make sure that the interface does not already exist in the config
        //
        {
            PIPQOS_IF_CONFIG pTmpCfg;

            dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszInterfaceName,
                                                         MS_IP_QOSMGR,
                                                         (PBYTE *) &pTmpCfg,
                                                         &dwBlkSize,
                                                         &dwCount,
                                                         &dwIfType);

            if (dwErr is NO_ERROR && pTmpCfg != NULL) 
            {
                HEAP_FREE(pTmpCfg);
                
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS,
                               wszInterfaceName);

                return ERROR_SUPPRESS_OUTPUT;
            }
        }


        //
        // check if Qos global info is set. else add Qos global info
        //
        {
            PIPQOS_GLOBAL_CONFIG pGlobalConfig = NULL;
            DWORD                dwBlkSize, dwCount;

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pGlobalConfig,
                                                      &dwBlkSize,
                                                      &dwCount);

            HEAP_FREE_NOT_NULL(pGlobalConfig);
            
            if ((dwErr is ERROR_NOT_FOUND) || (dwBlkSize == 0))
            {
                // create qos global info
                
                dwErr = HandleQosInstall(pwszMachine,
                                         NULL, 
                                         0, 
                                         0, 
                                         dwFlags,
                                         hMibServer,
                                         pbDone);
            }
            
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        
        //
        // set the interface info
        //

        dwErr = UpdateQosInterfaceConfig(wszInterfaceName,
                                         &ChangeCfg,
                                         dwBitVector,
                                         ADD_FLAG);
    }
    while (FALSE);
    
    // no error message

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}

DWORD
HandleQosDelIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for del interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwErr, dwIfType, dwBlkSize, dwBitVector = 0, dwCount;
    IPQOS_IF_CONFIG ChangeCfg; //will not be used

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get interface name.
    //

    ZeroMemory( &ChangeCfg, sizeof(IPQOS_IF_CONFIG) );

    dwErr = GetQosSetIfOpt(pptcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            wszInterfaceName,
                            sizeof(wszInterfaceName),
                            &ChangeCfg,
                            &dwBitVector,
                            ADD_FLAG
                            );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    //
    // make sure that no other option is set.
    //
    if (dwBitVector) 
    {
        return ERROR_INVALID_SYNTAX;
    }
    
    //
    // delete interface info
    //

    dwErr = IpmontrDeleteInfoBlockFromInterfaceInfo(wszInterfaceName,
                                                    MS_IP_QOSMGR);

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}

DWORD
HandleQosSetIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for set interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/

{
    IPQOS_IF_CONFIG     ChangeCfg; //no variable parts can be set
    DWORD               dwBitVector = 0,
                        dwErr = NO_ERROR;
    WCHAR               wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get the optional interface parameters
    //
    
    ZeroMemory( &ChangeCfg, sizeof(IPQOS_IF_CONFIG) );

    dwErr = GetQosSetIfOpt(pptcArguments,
                           dwCurrentIndex,
                           dwArgCount,
                           wszIfName,
                           sizeof(wszIfName),
                           &ChangeCfg,
                           &dwBitVector,
                           SET_FLAG
                           );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    if (dwBitVector)
    {
        // 
        // Call UpdateInterfaceCfg
        //

        dwErr = UpdateQosInterfaceConfig(wszIfName,
                                         &ChangeCfg,
                                         dwBitVector,
                                         SET_FLAG);
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}


DWORD
HandleQosShowIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing QOS interface info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD         i, j, dwErr = NO_ERROR, dwNumOpt;
    WCHAR         wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD         dwNumArg,
                  dwBufferSize = sizeof(wszInterfaceName);
    DWORD         dwSize, dwRes;

    TAG_TYPE      pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    DWORD         pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    if (dwCurrentIndex == dwArgCount) {

        dwErr = ShowQosAllInterfaceInfo( NULL ) ;

        return dwErr;
    }

    //
    // Parse command line
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, NUM_TAGS_IN_TABLE(pttTags),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case 0 :
            IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                             wszInterfaceName,&dwBufferSize);

            break;

        default:
            i = dwNumArg;
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr == NO_ERROR)
    {
        dwErr = ShowQosInterfaceInfo(NULL, wszInterfaceName);
    }

    return dwErr;
}


//
// Dump Handlers
//


DWORD
DumpQosInformation (
    HANDLE hFile
    )

/*++

Routine Description:

    Dumps Qos information to a text file

Arguments:


Return Value:

    NO_ERROR

--*/

{

    //DisplayMessageT( DMP_QOS_HEADER );
    DisplayMessage(g_hModule, MSG_QOS_HEADER);
    DisplayMessageT( DMP_QOS_PUSHD );
    DisplayMessageT( DMP_QOS_UNINSTALL );

    //DisplayMessageT(DMP_QOS_GLOBAL_HEADER) ;

    //
    // dump qos global information
    //
    
    ShowQosGlobalInfo( hFile ) ;

    //
    // dump flowspecs at the end
    // of the global information
    //

    ShowQosFlowspecs(hFile, NULL);

    //
    // dump qos objects that occur
    // at the end of flowspec info
    //

    ShowQosObjects(hFile, 
                   NULL, 
                   QOS_OBJECT_END_OF_LIST);

    //DisplayMessageT(DMP_QOS_GLOBAL_FOOTER);

    //
    // dump qos config for all interfaces
    //

    ShowQosAllInterfaceInfo( hFile );

    DisplayMessageT( DMP_POPD );
    //DisplayMessageT( DMP_QOS_FOOTER );
    DisplayMessage( g_hModule, MSG_QOS_FOOTER );

    return NO_ERROR ;
}

DWORD
QosDump(
    PWCHAR    pwszMachine,
    WCHAR     **ppwcArguments,
    DWORD     dwArgCount,
    PVOID     pvData
    )
{
    return DumpQosInformation((HANDLE) -1);
}

//
// Help Handlers
//


//
// Flowspec Add, Del, Set Handlers
//


DWORD
HandleQosAddFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding flowspecs to the
    global info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelFlowspecOpt(pptcArguments,
                                   dwCurrentIndex,
                                   dwArgCount,
                                   TRUE);
}

DWORD
HandleQosDelFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting flowspecs from the
    global info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelFlowspecOpt(pptcArguments,
                                   dwCurrentIndex,
                                   dwArgCount,
                                   FALSE);
}

DWORD
HandleQosShowFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing flowspecs in the
    global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    PTCHAR             pszFlowspec;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);
    
    if (dwCurrentIndex == dwArgCount)
    {
        //
        // No arguments - show all flowspecs
        //

        pszFlowspec = NULL;
    }
    else {

        //
        // Get name of the flowspec to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        if (dwNumArg != 1)
        {
            return ERROR_INVALID_SYNTAX;
        }

        pszFlowspec = pptcArguments[dwCurrentIndex];
    }

    return ShowQosFlowspecs(NULL, pszFlowspec);
}


//
// DsRule Add, Del, Show Handlers
//

DWORD
HandleQosAddDsRule(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding diffserv rules to the
    diffserv maps in global info. If the diffserv
    map in not already present, a new one will be
    created when adding the first rule.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelDsRuleOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 TRUE);
}

DWORD
HandleQosDelDsRule(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting diffserv ruless from
    an existing diffserv map in the global info. If
    this is the last diffserv rule in the diffserv
    map, the diffserv map is removed from the global
    info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelDsRuleOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 FALSE);
}

DWORD
HandleQosShowDsMap(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing diffserv maps
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    return HandleQosShowGenericQosObject(QOS_OBJECT_DIFFSERV,
                                         pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         pbDone);
}

//
// Flow Add, Del, Set Handlers
//


DWORD
HandleQosAddFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding flows on an interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelIfFlowOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 TRUE);
}

DWORD
HandleQosDelFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting flows on an interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelIfFlowOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 FALSE);
}

DWORD
HandleQosShowFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR              wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD              dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE},
                                    {TOKEN_OPT_FLOW_NAME,FALSE,FALSE}};
    PTCHAR             pszIfName;
    PTCHAR             pszFlow;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    pszIfName = pszFlow = NULL;
    
    if (dwCurrentIndex == dwArgCount)
    {
        //
        // No arguments - show all flows on all interfaces
        //

        dwErr = NO_ERROR;
    }
    else {

        //
        // Get name of the flow to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        for ( i = 0; i < dwNumArg; i++ )
        {
            switch (pdwTagType[i])
            {
            case 0: // Interfacename

                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,
                                                 &dwBufferSize);
                pszIfName = wszInterfaceName;
                break;

            case 1: // Flowname

                pszFlow = pptcArguments[dwCurrentIndex + i];
                break;

            default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    if (dwErr == NO_ERROR)
    {
        dwErr = ShowQosFlows(NULL, pszIfName, pszFlow);
    }

    return dwErr;
}


//
// FlowspecOnFlow Add, Del Handlers
//

DWORD
HandleQosAddFlowspecOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelFlowspecOnFlowOpt(pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         TRUE);
}

DWORD
HandleQosDelFlowspecOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelFlowspecOnFlowOpt(pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         FALSE);
}

//
// QosObject Del, Show Handlers
//

DWORD
HandleQosDelQosObject(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for deleting qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE}};
    PWCHAR             pwszQosObject;
    DWORD              dwNumArg;
    DWORD              dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    if (dwNumArg != 1)
    {
        return ERROR_INVALID_SYNTAX;
    }

    //
    // Get name of the qosobject to delete
    //

    pwszQosObject = pptcArguments[dwCurrentIndex];

    return GetQosAddDelQosObject(pwszQosObject, NULL, FALSE);
}


DWORD
HandleQosShowQosObject(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE},
                                    {TOKEN_OPT_QOSOBJECT_TYPE,FALSE,FALSE}};
    PTCHAR             pszQosObject;
    ULONG              dwObjectType;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    // Init type to indicate a "generic" object
    dwObjectType = QOS_OBJECT_END_OF_LIST;

    pszQosObject = NULL;

    if (dwCurrentIndex < dwArgCount)
    {
        //
        // Get name of the qosobject to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        for (i = 0; i < dwNumArg; i++)
        {
            switch (pdwTagType[i])
            {
            case 0 :
                // QOS OBJECT NAME
                pszQosObject = pptcArguments[i + dwCurrentIndex];
                break;

            case 1 :
            {
                // QOS OBJECT TYPE
                
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_QOSOBJECT_DIFFSERV, QOS_OBJECT_DIFFSERV},
                     {TOKEN_OPT_QOSOBJECT_SD_MODE,  QOS_OBJECT_SD_MODE}};

                GET_ENUM_TAG_VALUE();

                dwObjectType = dwRes;

                break;
            }
            
            default:
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }

        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    return ShowQosObjects(NULL, pszQosObject, dwObjectType);
}

DWORD
HandleQosShowGenericQosObject(
    DWORD     dwQosObjectType,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    PTCHAR             pszQosObject;
    DWORD              dwNumArg;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    pszQosObject = NULL;
    
    if (dwCurrentIndex < dwArgCount)
    {
        //
        // Get name of the qosobject to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        if (dwNumArg != 1)
        {
            return ERROR_INVALID_SYNTAX;
        }

        pszQosObject = pptcArguments[dwCurrentIndex];
    }

    return ShowQosObjects(NULL, pszQosObject, dwQosObjectType);
}

//
// SDMode Add, Del, Show Handlers
//

DWORD
HandleQosAddSdMode(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for adding shape modes
    to the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                    {TOKEN_OPT_SHAPING_MODE,TRUE,FALSE}};
    QOS_SD_MODE        qsdMode;
    PTCHAR             pszSdMode;
    DWORD              dwSdMode, dwNumArg, i, j, dwErr, dwRes;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    // Init to -1 to indicate value not filled in
    dwSdMode = -1;

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // Process the arguments now
    //

    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
                // SDMODE_NAME
                pszSdMode = pptcArguments[i + dwCurrentIndex];
                break;

            case 1:
            {
                // SHAPING
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_SDMODE_BORROW, TC_NONCONF_BORROW},
                     {TOKEN_OPT_SDMODE_SHAPE, TC_NONCONF_SHAPE},
                     {TOKEN_OPT_SDMODE_DISCARD, TC_NONCONF_DISCARD},
                     {TOKEN_OPT_SDMODE_BORROW_PLUS, TC_NONCONF_BORROW_PLUS}};
                
                GET_ENUM_TAG_VALUE();

                dwSdMode = dwRes;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }        
    }

    if (dwErr == NO_ERROR)
    {
#if 0
        // interface name should be present
        // and also the shaping mode value
    
        if ((!pttTags[0].bPresent) ||
            (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif
        // Create a new QOS object with inp
        qsdMode.ObjectHdr.ObjectType   = QOS_OBJECT_SD_MODE ;
        qsdMode.ObjectHdr.ObjectLength = sizeof(QOS_SD_MODE);
        qsdMode.ShapeDiscardMode = dwSdMode;
        
        dwErr = GetQosAddDelQosObject(pszSdMode, 
                                      (QOS_OBJECT_HDR *)&qsdMode,
                                      TRUE);
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}


DWORD
HandleQosShowSdMode(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing shape modes
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    return HandleQosShowGenericQosObject(QOS_OBJECT_SD_MODE,
                                         pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         pbDone);
}

//
// QosObjectOnFlow Add, Del Handlers
//

DWORD
HandleQosAddQosObjectOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelQosObjectOnFlowOpt(pptcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          TRUE);
}

DWORD
HandleQosDelQosObjectOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelQosObjectOnFlowOpt(pptcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          FALSE);
}

//
// Filter Add, Del, Set Handlers
//

DWORD
HandleQosAttachFilterToFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosDetachFilterFromFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosModifyFilterOnFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosShowFilterOnFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

//
// If Helper functions
//

DWORD
GetQosSetIfOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      PWCHAR                  wszIfName,
    IN      DWORD                   dwSizeOfwszIfName,
    OUT     PIPQOS_IF_CONFIG        pChangeCfg,
    OUT     DWORD                  *pdwBitVector,
    IN      BOOL                    bAddSet
    )

/*++
Routine Description:

    Gets options for set interface, add interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    wszIfName       - Interface name.
    dwSizeOfwszIfName-Size of the wszIfName buffer
    pChangeCfg      - The config containing changes values
    pdwBitVector    - Bit vector specifying what values have changed
    bAddSet         - Called when If entry is being created or set
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD              dwErr = NO_ERROR,dwRes;
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                    {TOKEN_OPT_IF_STATE,FALSE,FALSE}};
    DWORD              dwNumOpt;
    DWORD              dwNumArg, i, j;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // INTERFACE_NAME
                //

                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszIfName,&dwSizeOfwszIfName);
    
                break;
            }

            case 1:
            {
                //
                // STATE
                //

                TOKEN_VALUE    rgEnums[] =
                       {{TOKEN_OPT_VALUE_DISABLE, IPQOS_STATE_DISABLED},
                        {TOKEN_OPT_VALUE_ENABLE,  IPQOS_STATE_ENABLED}};

                GET_ENUM_TAG_VALUE();

                pChangeCfg->QosState = dwRes;

                *pdwBitVector |= QOS_IF_STATE_MASK;

                break;
            }
     
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }
    }

#if 0

    // interface name should be present
    
    if (!pttTags[0].bPresent)
    {
        dwErr = ERROR_INVALID_SYNTAX;
    }

#endif

    return dwErr;    
}


//
// Flow Helper functions
//

DWORD
GetQosAddDelIfFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for add/del/set(modify) flows

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_IF_CONFIG      piicSrc = NULL, piicDst = NULL;
    DWORD                 dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                 i, j, dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD                 dwBufferSize = sizeof(wszIfName);
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName;
    DWORD                 dwNumArg;
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE}};
    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                /* Get interface name for the flow */
                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszIfName, &dwBufferSize);
                break;

        case 1: 
                /* Get the flow name for the flow */
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface and flow names should be present
    
        if ((!pttTags[0].bPresent) || (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (bAdd)
        {
            if (j < piicSrc->NumFlows)
            {
                //
                // We already have a flow by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_FLOW_ALREADY_EXISTS,
                               pwszFlowName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
        }
        else
        {
            if (j == piicSrc->NumFlows)
            {
                //
                // We do not have a flow by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_FLOW_NOT_FOUND,
                               pwszFlowName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            // Flow was found at 'pNextFlow' position
        }

        if (bAdd)
        {
            //
            // We have a new flow definition - update config
            //

            dwNewBlkSize = dwBlkSize + sizeof(IPQOS_IF_FLOW);

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy all the existing flows to the new config
            memcpy(piicDst, piicSrc, dwBlkSize);

            //
            // Stick the new flow as the last flow in array
            //

            pDestFlow = (PIPQOS_IF_FLOW)((PUCHAR) piicDst + dwBlkSize);

            wcscpy(pDestFlow->FlowName, pwszFlowName);

            pDestFlow->FlowSize = sizeof(IPQOS_IF_FLOW);

            pDestFlow->FlowDesc.SendingFlowspecName[0] = L'\0';
            pDestFlow->FlowDesc.RecvingFlowspecName[0] = L'\0';
            pDestFlow->FlowDesc.NumTcObjects = 0;

            piicDst->NumFlows++;
        }
        else
        {
            //
            // We have to del old flowspec defn - update config
            //

            dwNewBlkSize = dwBlkSize - pNextFlow->FlowSize;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pNextFlow - (PUCHAR)piicSrc;

            // Copy the all the flowspecs that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the rest of the flowspecs as they are
            dwSkip = dwOffset + pNextFlow->FlowSize;
            memcpy((PUCHAR) piicDst + dwOffset,
                   (PUCHAR) piicSrc + dwSkip,
                   dwBlkSize - dwSkip);

            piicDst->NumFlows--;
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwNewBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(piicSrc);
    HEAP_FREE_NOT_NULL(piicDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosFlows(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    )
{
    PMPR_INTERFACE_0    pmi0;
    DWORD               dwErr, dwCount, dwTotal, i;

    if (pwszIfGuid)
    {
        return ShowQosFlowsOnIf(hFile, pwszIfGuid, wszFlowName);
    }
    else
    {
        //
        // Enumerate all interfaces applicable to QOS
        //

        dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                     &dwCount,
                                     &dwTotal);

        if(dwErr != NO_ERROR)
        {
            return dwErr;
        }

        for(i = 0; i < dwCount; i++)
        {
            ShowQosFlowsOnIf(hFile, 
                             pmi0[i].wszInterfaceName, 
                             wszFlowName);
        }
    }

    return NO_ERROR;
}

DWORD
ShowQosFlowsOnIf(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    )
{
    WCHAR   wszInterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ] = L"\0";
    DWORD   dwBufferSize = sizeof(wszInterfaceName);
    PWCHAR  pwszFriendlyIfName = NULL;

    PIPQOS_IF_CONFIG piicSrc;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwIfType, dwErr, j, k;
    PIPQOS_IF_FLOW  pNextFlow;
    PWCHAR pwszFlowName = NULL;
    PWCHAR pwszNextObject, pwszObjectName = NULL;
    PWCHAR pwszSendingFlowspec, pwszRecvingFlowspec;

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfGuid,
                                                 MS_IP_QOSMGR,
                                                 (PBYTE *) &piicSrc,
                                                 &dwBlkSize,
                                                 &dwQosCount,
                                                 &dwIfType);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( piicSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get friendly name for interface
    //
    
    dwErr = IpmontrGetFriendlyNameFromIfName(pwszIfGuid,
                                             wszInterfaceName,
                                             &dwBufferSize);
    
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }
    
    pwszFriendlyIfName = MakeQuotedString( wszInterfaceName );
    
    if ( pwszFriendlyIfName == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

    for (j = 0; j < piicSrc->NumFlows; j++)
    {
        if ((!wszFlowName) ||
            (!_wcsicmp(pNextFlow->FlowName, wszFlowName)))
        {
            //
            // Print or dump the flow now
            //

            pwszFlowName = MakeQuotedString(pNextFlow->FlowName);
    
            if (pwszFlowName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Print or dump flowspecs
            
            pwszSendingFlowspec = 
                MakeQuotedString(pNextFlow->FlowDesc.SendingFlowspecName);

            pwszRecvingFlowspec =
                MakeQuotedString(pNextFlow->FlowDesc.RecvingFlowspecName);

            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_FLOW,
                                pwszFriendlyIfName,
                                pwszFlowName);
                                

                DisplayMessageT(DMP_QOS_ADD_FLOW,
                                pwszFriendlyIfName,
                                pwszFlowName);

                if (!_wcsicmp(pwszSendingFlowspec, pwszRecvingFlowspec))
                {
                    if (pNextFlow->FlowDesc.SendingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_BI,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszSendingFlowspec);
                    }
                }
                else
                {
                    if (pNextFlow->FlowDesc.RecvingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_IN,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszRecvingFlowspec);
                    }

                    if (pNextFlow->FlowDesc.SendingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_OUT,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszSendingFlowspec);
                    }
                }
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_FLOW_INFO,
                               pwszFlowName,
                               pwszFriendlyIfName,
                               pwszRecvingFlowspec,
                               pwszSendingFlowspec,
                               pNextFlow->FlowDesc.NumTcObjects);
            }

            // Print or dump qos objects

            pwszNextObject = 
                (PWCHAR) ((PUCHAR) pNextFlow + sizeof(IPQOS_IF_FLOW));

            for (k = 0; k < pNextFlow->FlowDesc.NumTcObjects; k++)
            {
                pwszObjectName = MakeQuotedString(pwszNextObject);

                if ( pwszObjectName == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (hFile)
                {
                    DisplayMessageT(DMP_QOS_ADD_QOSOBJECT_ON_FLOW,
                                    pwszFriendlyIfName,
                                    pwszFlowName,
                                    pwszObjectName);
                }
                else
                {
                    DisplayMessage(g_hModule, MSG_QOS_QOSOBJECT_INFO,
                                   k,
                                   pwszObjectName);
                }

                pwszNextObject += MAX_STRING_LENGTH;

                FreeQuotedString(pwszObjectName);
            }

            if ( pwszFlowName )
            {
                FreeQuotedString( pwszFlowName );
                pwszFlowName = NULL;
            }

            //
            // If we matched flow, then done
            //

            if ((wszFlowName) || (dwErr != NO_ERROR))
            {
                break;
            }
        }

        pNextFlow = (PIPQOS_IF_FLOW)
            ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
    }

    if ( pwszFriendlyIfName )
    {
        FreeQuotedString( pwszFriendlyIfName );
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszFlowName) && (j == piicSrc->NumFlows))
        {
            // We didnt find the flow we are looking for
            DisplayMessage(g_hModule, 
                           MSG_FLOW_NOT_FOUND,
                           wszFlowName);
            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    return dwErr;
}


//
// DsRule, DsMap Helpers
//

DWORD
GetQosAddDelDsRuleOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
{
    DWORD               dwErr = NO_ERROR;
    TAG_TYPE            pttTags[] = {
                             {TOKEN_OPT_NAME,TRUE,FALSE},
                             {TOKEN_OPT_INBOUND_DS_FIELD,TRUE,FALSE},
                             {TOKEN_OPT_CONF_OUTBOUND_DS_FIELD,FALSE,FALSE},
                             {TOKEN_OPT_NONCONF_OUTBOUND_DS_FIELD,FALSE,FALSE},
                             {TOKEN_OPT_CONF_USER_PRIORITY,FALSE,FALSE},
                             {TOKEN_OPT_NONCONF_USER_PRIORITY,FALSE,FALSE}};
    PIPQOS_NAMED_QOSOBJECT pThisQosObject, pNextQosObject;
    PVOID                  pBuffer;
    PTCHAR                 pszDsMap;
    QOS_DIFFSERV          *pDsMap;
    QOS_DIFFSERV_RULE      dsRule, *pDsRule, *pNextDsRule;
    PIPQOS_GLOBAL_CONFIG   pigcSrc = NULL, pigcDst = NULL;
    DWORD                  dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwSkip, dwOffset;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // We need all params for add and atleast
    // the dsmap name n dsrule num for delete
    //

    if (( bAdd && (dwNumArg != 6)) ||
        (!bAdd && (dwNumArg != 2)))
    {
        return ERROR_INVALID_SYNTAX;
    }

    pDsRule = &dsRule;

    //
    // Initialize the diffserv rule definition
    //

    memset(pDsRule, 0, sizeof(QOS_DIFFSERV_RULE));

    //
    // Process the arguments now
    //

    for ( i = 0; i < dwNumArg; i++)
    {
        // All params except the first are uchar vals

        if ( pdwTagType[i] > 0)
        {
            // What if this is not a valid ULONG ? '0' will not do...
            dwRes = _tcstoul(pptcArguments[i + dwCurrentIndex],NULL,10);
        }

        switch (pdwTagType[i])
        {
            case 0:

                //
                // DSMAP Name: See if we already have the name
                //

                pszDsMap = pptcArguments[i + dwCurrentIndex];

                dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                          (PBYTE *) &pigcSrc,
                                                          &dwBlkSize,
                                                          &dwQosCount);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                if ( pigcSrc == NULL )
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

                pThisQosObject = NULL;

                pNextQosObject = 
                    (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                             + sizeof(IPQOS_GLOBAL_CONFIG)
                                             + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

                for (j = 0; j < pigcSrc->NumQosObjects; j++)
                {
                    if (!_wcsicmp(pNextQosObject->QosObjectName, 
                                  pszDsMap))
                    {
                        break;
                    }

                    pNextQosObject =
                                (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
                }

                if (j < pigcSrc->NumQosObjects)
                {
                    //
                    // You cannot add/del dsrules from a non dsmap
                    //

                    if (pNextQosObject->QosObjectHdr.ObjectType !=
                            QOS_OBJECT_DIFFSERV)
                    {
                        i = dwNumArg;
                        dwErr = ERROR_INVALID_FUNCTION;
                        break;
                    }
                }

                if (bAdd)
                {
                    if (j < pigcSrc->NumQosObjects)
                    {
                        // Remember QOS object you are interested in
                        pThisQosObject = pNextQosObject;
                    }
                }
                else
                {
                    if (j == pigcSrc->NumQosObjects)
                    {
                        //
                        // We do not have a qos object by this name
                        //

                        DisplayMessage(g_hModule, 
                                       MSG_QOSOBJECT_NOT_FOUND,
                                       pszDsMap);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    // Remember QOS object you are interested in
                    pThisQosObject = pNextQosObject;
                }

                break;

            case 1:
                // INBOUND_DS
                pDsRule->InboundDSField = (UCHAR) dwRes;
                break;

            case 2:
                // CONF_OUTBOUND_DS
                pDsRule->ConformingOutboundDSField = (UCHAR) dwRes;
                break;

            case 3:
                // NONCONF_OUTBOUND_DS
                pDsRule->NonConformingOutboundDSField = (UCHAR) dwRes;
                break;

            case 4:
                // CONF_USER_PRIOTITY
                pDsRule->ConformingUserPriority = (UCHAR) dwRes;
                break;

            case 5:
                // NONCONF_USER_PRIOTITY
                pDsRule->NonConformingUserPriority = (UCHAR) dwRes;
                break;

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        //
        // interface name should be present
        // and the ds rule id (inbound ds)
        //

        if ((!pttTags[0].bPresent) ||
            (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // and the test of the info for add
        //

        if (bAdd)
        {
            if ((!pttTags[2].bPresent) ||
                (!pttTags[3].bPresent) ||
                (!pttTags[4].bPresent) ||
                (!pttTags[5].bPresent))
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }

#if 1
        //
        // BUGBUG: Adding and deleting DS rules will cause
        // the corresponding map to be updated, but will
        // this result in getting dependent flows changed?
        //
#endif
    
        if (bAdd)
        {
            if (pThisQosObject)
            {
                //
                // Check if this dsrule is already present
                //

                pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

                pNextDsRule = (QOS_DIFFSERV_RULE *)&pDsMap->DiffservRule[0];

                for (j = 0; j < pDsMap->DSFieldCount; j++)
                {
                    if (pNextDsRule->InboundDSField == 
                          pDsRule->InboundDSField)
                    {
                        break;
                    }

                    pNextDsRule++;
                }

                dwOffset = (PUCHAR)pNextDsRule - (PUCHAR)pigcSrc;

                if (j < pDsMap->DSFieldCount)
                {
                    //
                    // Update existing DS rule with info
                    //

                    *pNextDsRule = *pDsRule;

                    dwSkip  = 0;

                    pBuffer = NULL;
                }
                else
                {
                    //
                    // Initialize new DS rule for new rule info
                    //

                    dwSkip = sizeof(QOS_DIFFSERV_RULE);

                    pNextDsRule = HeapAlloc(GetProcessHeap(), 
                                            0, 
                                            dwSkip);

                    if (pNextDsRule == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    *pNextDsRule = *pDsRule;

                    //
                    // Update num of dfsrv rules in src buff
                    // so that dst copy results in new value
                    //

                    pDsMap->DSFieldCount++;

                    pDsMap->ObjectHdr.ObjectLength +=sizeof(QOS_DIFFSERV_RULE);

                    pBuffer = pNextDsRule;
                }
            }
            else
            {
                //
                // Initialize a new DS map to hold the rule
                //

                dwSkip = sizeof(IPQOS_NAMED_QOSOBJECT) +
                         sizeof(ULONG) + // this for DSFieldCount
                         sizeof(QOS_DIFFSERV_RULE);

                dwOffset = (PUCHAR) pNextQosObject - (PUCHAR) pigcSrc;

                pThisQosObject = HeapAlloc(GetProcessHeap(), 
                                           0, 
                                           dwSkip);

                if (pThisQosObject == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                wcscpy(pThisQosObject->QosObjectName, pszDsMap);

                pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

                pDsMap->ObjectHdr.ObjectType = QOS_OBJECT_DIFFSERV;
                pDsMap->ObjectHdr.ObjectLength = 
                    dwSkip - FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

                pDsMap->DSFieldCount = 1;

                pNextDsRule = 
                    (QOS_DIFFSERV_RULE *) &pDsMap->DiffservRule[0];

                *pNextDsRule = *pDsRule;

                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects++;

                pBuffer = pThisQosObject;
            }

            dwNewBlkSize = dwBlkSize + dwSkip;
                                       
            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the new information after dwOffset
            memcpy((PUCHAR) pigcDst + dwOffset,
                   pBuffer, 
                   dwSkip);

            // Copy the rest of the info as it is
            memcpy((PUCHAR) pigcDst + dwOffset + dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);

            HEAP_FREE_NOT_NULL(pBuffer);
        }
        else
        {
            //
            // Check if this dsrule is already present
            //

            pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

            pNextDsRule = (QOS_DIFFSERV_RULE *)&pDsMap->DiffservRule[0];

            for (j = 0; j < pDsMap->DSFieldCount; j++)
            {
                if (pNextDsRule->InboundDSField == 
                      pDsRule->InboundDSField)
                {
                    break;
                }

                pNextDsRule++;
            }

            if (j == pDsMap->DSFieldCount)
            {
                // Did not find DS rule in the DS map
                DisplayMessage(g_hModule,
                               MSG_DSRULE_NOT_FOUND,
                               pszDsMap,
                               pDsRule->InboundDSField);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            if (pDsMap->DSFieldCount == 1)
            {
                // Last DS rule in the DS map

                dwOffset = (PUCHAR)pThisQosObject - (PUCHAR)pigcSrc;

                dwSkip = sizeof(IPQOS_NAMED_QOSOBJECT) +
                         sizeof(ULONG) + // this for DSFieldCount
                         sizeof(QOS_DIFFSERV_RULE);

                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects--;
            }
            else
            {
                // More than 1 rule in DS map

                dwOffset = (PUCHAR)pNextDsRule - (PUCHAR)pigcSrc;

                dwSkip = sizeof(QOS_DIFFSERV_RULE);

                //
                // Update num of dfsrv rules in src buff
                // so that dst copy results in new value
                //

                pDsMap->DSFieldCount--;

                pDsMap->ObjectHdr.ObjectLength -= sizeof(QOS_DIFFSERV_RULE);
            }

            dwNewBlkSize = dwBlkSize - dwSkip;
                                       
            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the info as it is
            dwOffset += dwSkip;
            memcpy((PUCHAR) pigcDst + dwOffset - dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosDsMap(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszDsMapName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    QOS_DIFFSERV_RULE  *pDsRule;
    QOS_DIFFSERV *pDsMap;
    PWCHAR pwszDsMapName;
    DWORD dwErr, k;

    pDsMap = (QOS_DIFFSERV *) pQosObject;

    //
    // Print or dump the dsmap now
    //

    do
    {
        pwszDsMapName = MakeQuotedString(wszDsMapName);
    
        if (pwszDsMapName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DSMAP_HEADER);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_DSMAP_INFO,
                           pwszDsMapName,
                           pDsMap->DSFieldCount);
        }

        //
        // Print each DS rule in the map
        //

        pDsRule = (QOS_DIFFSERV_RULE *) &pDsMap->DiffservRule[0];
                
        for (k = 0; k < pDsMap->DSFieldCount; k++)
        {
            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_DSRULE,
                                pwszDsMapName,
                                pDsRule->InboundDSField);

                DisplayMessageT(DMP_QOS_ADD_DSRULE,
                                pwszDsMapName,
                                pDsRule->InboundDSField,
                                pDsRule->ConformingOutboundDSField,
                                pDsRule->NonConformingOutboundDSField,
                                pDsRule->ConformingUserPriority,
                                pDsRule->NonConformingUserPriority);
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_DSRULE_INFO,
                               pwszDsMapName,
                               k,
                               pDsRule->InboundDSField,
                               pDsRule->ConformingOutboundDSField,
                               pDsRule->NonConformingOutboundDSField,
                               pDsRule->ConformingUserPriority,
                               pDsRule->NonConformingUserPriority);
            }

            pDsRule++;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DSMAP_FOOTER);
        }

        if ( pwszDsMapName )
        {
            FreeQuotedString( pwszDsMapName );
        }

        return NO_ERROR;
    }
    while (FALSE);

    return dwErr;
}

//
// SD Mode Helpers
//

DWORD
ShowQosSdMode(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszSdModeName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    QOS_SD_MODE *pSdMode;
    PWCHAR pwszSdModeName;
    DWORD dwErr, k;
    PTCHAR  ptszSdMode = NULL;
    VALUE_TOKEN  vtSdMode1[] =
                  {TC_NONCONF_BORROW,TOKEN_OPT_SDMODE_BORROW,
                   TC_NONCONF_SHAPE,TOKEN_OPT_SDMODE_SHAPE,
                   TC_NONCONF_DISCARD,TOKEN_OPT_SDMODE_DISCARD,
                   TC_NONCONF_BORROW_PLUS,TOKEN_OPT_SDMODE_BORROW_PLUS};

    VALUE_STRING vtSdMode2[] =
                  {TC_NONCONF_BORROW,STRING_SDMODE_BORROW,
                   TC_NONCONF_SHAPE,STRING_SDMODE_SHAPE,
                   TC_NONCONF_DISCARD,STRING_SDMODE_DISCARD,
                   TC_NONCONF_BORROW_PLUS,STRING_SDMODE_BORROW_PLUS};

    pSdMode = (QOS_SD_MODE *)pQosObject;

    //
    // Print or dump the sdmode now
    //

    do
    {
        pwszSdModeName = MakeQuotedString(wszSdModeName);
    
        if (pwszSdModeName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Get service type of flowspec
        //

        GetAltDisplayString(g_hModule, hFile,
                            pSdMode->ShapeDiscardMode,
                            vtSdMode1,
                            vtSdMode2,
                            NUM_VALUES_IN_TABLE(vtSdMode1),
                            &ptszSdMode);
        
        if ( ptszSdMode == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
            
        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DEL_SDMODE,
                            pwszSdModeName);

            DisplayMessageT(DMP_QOS_ADD_SDMODE,
                            pwszSdModeName,
                            ptszSdMode);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_SDMODE_INFO,
                           pwszSdModeName,
                           ptszSdMode);
        }

        FREE_STRING_NOT_NULL ( ptszSdMode );

        if ( pwszSdModeName )
        {
            FreeQuotedString( pwszSdModeName );
        }

        return NO_ERROR;
    }
    while (FALSE);

    return dwErr;
}

//
// Qos Object Helpers
//

DWORD
GetQosAddDelQosObject(
    IN      PWCHAR                  pwszQosObjectName,
    IN      QOS_OBJECT_HDR         *pQosObject,
    IN      BOOL                    bAdd
    )
{
    PIPQOS_NAMED_QOSOBJECT pNextQosObject;
    PIPQOS_GLOBAL_CONFIG   pigcSrc = NULL, pigcDst = NULL;
    DWORD                  dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                  dwErr, dwSize, dwSkip, dwOffset, j;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if (pigcSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

    //
    // Search for a QOS Object with this name
    //

    pNextQosObject = (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                             + sizeof(IPQOS_GLOBAL_CONFIG)
                                             + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

    for (j = 0; j < pigcSrc->NumQosObjects; j++)
    {
        if (!_wcsicmp(pNextQosObject->QosObjectName, 
                      pwszQosObjectName))
        {
            break;
        }

        pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
    }

    do
    {
        if (bAdd)
        {
            dwSize = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                         pQosObject->ObjectLength;
            dwSkip = 0;

            if (j < pigcSrc->NumQosObjects)
            {
                //
                // Do (not) allow overwriting qos objects
                //
#if NO_UPDATE
                //
                // We already have a qos object by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_ALREADY_EXISTS,
                               pwszQosObjectName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
#endif
                // Get the existing size of the qos object
                dwSkip = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                             pNextQosObject->QosObjectHdr.ObjectLength;
            }
            else
            {
                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects++;
            }

            dwOffset = (PUCHAR) pNextQosObject - (PUCHAR) pigcSrc;

            dwNewBlkSize = dwBlkSize + dwSize - dwSkip;

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the new information after dwOffset

            // Copy the name of the qos object first
            wcscpy((PWCHAR)((PUCHAR) pigcDst + dwOffset),
                   pwszQosObjectName);

            // Copy the rest of the input information
            memcpy((PUCHAR) pigcDst + dwOffset + MAX_WSTR_LENGTH,
                   (PUCHAR) pQosObject,
                   pQosObject->ObjectLength);

            // Copy the rest of the info as it is
            memcpy((PUCHAR) pigcDst + (dwOffset + dwSize),
                   (PUCHAR) pigcSrc + (dwOffset + dwSkip),
                   dwBlkSize - (dwOffset + dwSkip));
        }
        else
        {
#if 1
            //
            // BUGBUG: What if there are dependent flows ?
            //
#endif
            if (j == pigcSrc->NumQosObjects)
            {
                //
                // We do not have a qos object by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObjectName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update num of qos objects in src buff
            // so that dst copy results in new value
            //

            pigcSrc->NumQosObjects--;

            dwOffset = (PUCHAR)pNextQosObject - (PUCHAR)pigcSrc;

            dwSkip = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                         pNextQosObject->QosObjectHdr.ObjectLength;

            dwNewBlkSize = dwBlkSize - dwSkip;

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the info as it is
            dwOffset += dwSkip;
            memcpy((PUCHAR) pigcDst + dwOffset - dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosObjects(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszQosObjectName,
    IN      ULONG                   dwQosObjectType
    )
{
    PIPQOS_NAMED_QOSOBJECT pNextQosObject;
    PIPQOS_GLOBAL_CONFIG pigcSrc;
    PSHOW_QOS_OBJECT     pfnShowQosObject;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwOffset;
    DWORD dwErr, j;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( pigcSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

    pNextQosObject = (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                              + sizeof(IPQOS_GLOBAL_CONFIG)
                                              + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

    for (j = 0; j < pigcSrc->NumQosObjects; j++)
    {
        if ((dwQosObjectType == QOS_OBJECT_END_OF_LIST) ||
            (dwQosObjectType == pNextQosObject->QosObjectHdr.ObjectType))
        {
            if ((!wszQosObjectName) ||
                (!_wcsicmp(pNextQosObject->QosObjectName, wszQosObjectName)))
            {
                switch (pNextQosObject->QosObjectHdr.ObjectType)
                {
                case QOS_OBJECT_DIFFSERV:
                    pfnShowQosObject = ShowQosDsMap;
                    break;

                case QOS_OBJECT_SD_MODE:
                    pfnShowQosObject = ShowQosSdMode;
                    break;
                
                default:
                    pfnShowQosObject = ShowQosGenObj;
                }

                pfnShowQosObject(hFile,
                                 pNextQosObject->QosObjectName,
                                 &pNextQosObject->QosObjectHdr);

                //
                // If we matched the qos object name, then done
                //

                if (wszQosObjectName)
                {
                    break;
                }
            }
        }

        pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                             ((PUCHAR) pNextQosObject + 
                              dwOffset + 
                              pNextQosObject->QosObjectHdr.ObjectLength);
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszQosObjectName) && (j == pigcSrc->NumQosObjects))
        {
            // We didnt find the qos object we are looking for
            DisplayMessage(g_hModule, 
                           MSG_QOSOBJECT_NOT_FOUND,
                           wszQosObjectName);

            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    HEAP_FREE(pigcSrc);

    return dwErr;
}

DWORD
ShowQosGenObj(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    // We can print a general description from name and size
    return NO_ERROR;
}

DWORD
GetQosAddDelQosObjectOnFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for attach and detach QOS objects
    from flows.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_GLOBAL_CONFIG  pigcSrc = NULL;
    PIPQOS_IF_CONFIG      piicSrc = NULL, piicDst = NULL;
    DWORD                 dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                 dwBlkSize1, dwQosCount1;
    DWORD                 i, j, k, l;
    DWORD                 dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwRes;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PIPQOS_NAMED_QOSOBJECT pNamedQosObject, pNextQosObject;
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName, pwszQosObject, pwszNextObject;
    DWORD                 dwNumArg,
                          dwBufferSize = sizeof(wszIfName);
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_QOSOBJECT,TRUE,FALSE}};

    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                // INTERFACE NAME
                IpmontrGetIfNameFromFriendlyName( pptcArguments[i + dwCurrentIndex],
                                                  wszIfName,&dwBufferSize);
                break;

        case 1: 
                // FLOW NAME
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        case 2: 
                // QOSOBJECT NAME
                pwszQosObject = pptcArguments[i + dwCurrentIndex];
                break;

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface, flow, qosobject names should be present
    
        if ((!pttTags[0].bPresent) || 
            (!pttTags[1].bPresent) ||
            (!pttTags[2].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (j == piicSrc->NumFlows)
        {
            //
            // We do not have a flow by this name
            //

            DisplayMessage(g_hModule, 
                           MSG_FLOW_NOT_FOUND,
                           pwszFlowName);
            i = dwNumArg;
            dwErr = ERROR_SUPPRESS_OUTPUT;
            break;
        }

        // Flow was found at 'pNextFlow' position

        //
        // Search for a QOS object by this name
        //

        pwszNextObject = 
            (PWCHAR) ((PUCHAR) pNextFlow + sizeof(IPQOS_IF_FLOW));

        for (k = 0; k < pNextFlow->FlowDesc.NumTcObjects; k++)
        {
            if (!_wcsicmp(pwszNextObject, pwszQosObject))
            {
                break;
            }

            pwszNextObject += MAX_STRING_LENGTH;
        }

        if (!bAdd)
        {
            //
            // Make sure that the flow has the named qosobject
            //

            if (k == pNextFlow->FlowDesc.NumTcObjects)
            {
                DisplayMessage(g_hModule,
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update number of qos objects in src buff
            // so that copy to dest results in new value
            //

            pNextFlow->FlowSize -= MAX_WSTR_LENGTH;

            pNextFlow->FlowDesc.NumTcObjects--;

            //
            // Delete the association of the qosobject & flow
            //

            dwNewBlkSize = dwBlkSize - MAX_WSTR_LENGTH;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pwszNextObject - (PUCHAR)piicSrc;

            // Copy the all the objects that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the rest of the obj names as they are
            dwSkip = dwOffset + MAX_WSTR_LENGTH;
            memcpy((PUCHAR) piicDst + dwOffset,
                   (PUCHAR) piicSrc + dwSkip,
                   dwBlkSize - dwSkip);
        }
        else
        {
            //
            // Does the flow already have this QOS object ?
            //

            if (k < pNextFlow->FlowDesc.NumTcObjects)
            {
                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_ALREADY_EXISTS,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Make sure that qosobject is actually defined
            //

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pigcSrc,
                                                      &dwBlkSize1,
                                                      &dwQosCount1);
            
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if ( pigcSrc == NULL )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

            pNextQosObject = 
                (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                         + sizeof(IPQOS_GLOBAL_CONFIG)
                                         + (pigcSrc->NumFlowspecs *
                                            sizeof(IPQOS_NAMED_FLOWSPEC)));

            for (l = 0; l < pigcSrc->NumQosObjects; l++)
            {
                if (!_wcsicmp(pNextQosObject->QosObjectName, 
                              pwszQosObject))
                {
                    break;
                }

                pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
            }

            if (l == pigcSrc->NumQosObjects)
            {
                //
                // We do not have a qos object by this name
                //

                DisplayMessage(g_hModule,
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update number of qos objects in src buff
            // so that copy to dest results in new value
            //

            pNextFlow->FlowSize += MAX_WSTR_LENGTH;

            pNextFlow->FlowDesc.NumTcObjects++;

            //
            // Create the association of the qosobject & flow
            //

            dwNewBlkSize = dwBlkSize + MAX_WSTR_LENGTH;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pwszNextObject - (PUCHAR)piicSrc;

            // Copy the all the objects that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the new association at the end of flow
            wcscpy((PWCHAR)((PUCHAR) piicDst + dwOffset),
                   pwszQosObject);

            // Copy the rest of the obj names as they are
            dwSkip = dwOffset + MAX_WSTR_LENGTH;
            memcpy((PUCHAR) piicDst + dwSkip,
                   (PUCHAR) piicSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwNewBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(piicSrc);
    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(piicDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}


//
// Flowspec Helpers
//

DWORD
GetQosAddDelFlowspecOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
{
    DWORD               dwErr = NO_ERROR;
    TAG_TYPE            pttTags[] = {
                              {TOKEN_OPT_NAME,TRUE,FALSE},
                              {TOKEN_OPT_SERVICE_TYPE,FALSE,FALSE},
                              {TOKEN_OPT_TOKEN_RATE,FALSE,FALSE},
                              {TOKEN_OPT_TOKEN_BUCKET_SIZE,FALSE,FALSE},
                              {TOKEN_OPT_PEAK_BANDWIDTH,FALSE,FALSE},
                              {TOKEN_OPT_LATENCY,FALSE,FALSE},
                              {TOKEN_OPT_DELAY_VARIATION,FALSE,FALSE},
                              {TOKEN_OPT_MAX_SDU_SIZE,FALSE,FALSE},
                              {TOKEN_OPT_MIN_POLICED_SIZE,FALSE,FALSE}};
    PIPQOS_NAMED_FLOWSPEC pNamedFlowspec, pNextFlowspec;
    FLOWSPEC           fsFlowspec, *pFlowspec;
    PIPQOS_GLOBAL_CONFIG pigcSrc = NULL, pigcDst = NULL;
    DWORD                   dwBlkSize, dwNewBlkSize, dwQosCount;
    PTCHAR             pszFlowspec;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwSkip, dwOffset;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // We need only the name for delete
    //

    if (!bAdd && (dwNumArg != 1))
    {
        return ERROR_INVALID_SYNTAX;
    }

    pFlowspec = &fsFlowspec;
    if (bAdd)
    {
        //
        // Initialize the flowspec definition
        //

        memset(pFlowspec, QOS_NOT_SPECIFIED, sizeof(FLOWSPEC));
    }

    //
    // Process the arguments now
    //

    for ( i = 0; i < dwNumArg; i++)
    {
        // Only an flowspec name is allowed at delete

        if ((!bAdd) && (pdwTagType[i] != 0))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // All params except the first 2 are ulong vals

        if ( pdwTagType[i] > 1)
        {
            // What if this is not a valid ULONG ? '0' will not do...
            dwRes = _tcstoul(pptcArguments[i + dwCurrentIndex],NULL,10);
        }

        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // FLOWSPEC_NAME : See if we already have the name
                //

                dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                          (PBYTE *) &pigcSrc,
                                                          &dwBlkSize,
                                                          &dwQosCount);
                
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                if ( pigcSrc == NULL )
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) 
                      ((PUCHAR) pigcSrc + sizeof(IPQOS_GLOBAL_CONFIG));

                for (j = 0; j < pigcSrc->NumFlowspecs; j++)
                {
                    if (!_wcsicmp(pNextFlowspec->FlowspecName,
                                  pptcArguments[i + dwCurrentIndex]))
                    {
                        break;
                    }

                    pNextFlowspec++;
                }

                if (bAdd)
                {
                    //
                    // Do (not) allow overwriting existing flowspecs
                    //
#if NO_UPDATE
                    if (j < pigcSrc->NumFlowspecs)
                    {
                        //
                        // We already have a flowspec by this name
                        //

                        DisplayMessage(g_hModule,
                                       MSG_FLOWSPEC_ALREADY_EXISTS,
                                       pptcArguments[i + dwCurrentIndex]);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
#endif
                    pszFlowspec = pptcArguments[i + dwCurrentIndex];
                }
                else
                {
                    if (j == pigcSrc->NumFlowspecs)
                    {
                        //
                        // We do not have a flowspec by this name
                        //

                        DisplayMessage(g_hModule,
                                       MSG_FLOWSPEC_NOT_FOUND,
                                       pptcArguments[i + dwCurrentIndex]);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
                }

                break;
            }

            case 1:
            {
                //
                // SERVICE_TYPE
                //

                TOKEN_VALUE    rgEnums[] =
                {{TOKEN_OPT_SERVICE_BESTEFFORT, SERVICETYPE_BESTEFFORT},
                 {TOKEN_OPT_SERVICE_CONTROLLEDLOAD,SERVICETYPE_CONTROLLEDLOAD},
                 {TOKEN_OPT_SERVICE_GUARANTEED, SERVICETYPE_GUARANTEED},
                 {TOKEN_OPT_SERVICE_QUALITATIVE, SERVICETYPE_QUALITATIVE}};

                GET_ENUM_TAG_VALUE();

                pFlowspec->ServiceType = dwRes;

                break;
            }
     
            case 2:
            {
                //
                // TOKEN_RATE
                //

                pFlowspec->TokenRate = dwRes;
                break;
            }

            case 3:
            {
                //
                // TOKEN_BUCKET_SIZE
                //

                pFlowspec->TokenBucketSize = dwRes;
                break;
            }

            case 4:
            {
                //
                // PEAK_BANDWIDTH
                //

                pFlowspec->PeakBandwidth = dwRes;
                break;
            }

            case 5:
            {
                //
                // LATENCY
                //

                pFlowspec->Latency = dwRes;
                break;
            }

            case 6:
            {
                //
                // DELAY_VARIATION
                //

                pFlowspec->DelayVariation = dwRes;
                break;
            }

            case 7:
            {
                //
                // MAX_SDU_SIZE
                //

                pFlowspec->MaxSduSize = dwRes;
                break;
            }

            case 8:
            {
                //
                // MIN_POLICED_SIZE
                //

                pFlowspec->MinimumPolicedSize = dwRes;
                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }                
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface name should be present
    
        if (!pttTags[0].bPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        // if add, service type should be present

        if (bAdd && (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (bAdd)
        {
            //
            // We have a new flowspec definition - update config
            //

            dwNewBlkSize = dwBlkSize;

            if (j == pigcSrc->NumFlowspecs)
            {
                // We do not already have a flowspec by this name
                dwNewBlkSize += sizeof(IPQOS_NAMED_FLOWSPEC);
            }

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwOffset = (PUCHAR)pNextFlowspec - (PUCHAR) pigcSrc;

            // Copy all existing flowspecs to the new config
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Stick new flowspec at the next flowspec in list
            pNamedFlowspec = 
                (PIPQOS_NAMED_FLOWSPEC)((PUCHAR)pigcDst + dwOffset);
            wcscpy(pNamedFlowspec->FlowspecName, pszFlowspec);
            pNamedFlowspec->FlowspecDesc = fsFlowspec;

            // Copy rest of the interface config information
            dwSkip = dwOffset;

            if (j == pigcSrc->NumFlowspecs)
            {
                pigcDst->NumFlowspecs++;
            }
            else
            {
                // We are overwriting an existing flowspec
                dwSkip += sizeof(IPQOS_NAMED_FLOWSPEC);
            }

            memcpy((PUCHAR)pigcDst + dwOffset + sizeof(IPQOS_NAMED_FLOWSPEC),
                   (PUCHAR)pigcSrc + dwSkip,
                   dwBlkSize - dwSkip);
        }
        else
        {
#if 1
            //
            // BUGBUG: What if there are dependent flows present ?
            //
#endif
            //
            // We have to del old flowspec defn - update config
            //

            dwNewBlkSize = dwBlkSize - sizeof(IPQOS_NAMED_FLOWSPEC);

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwOffset = (PUCHAR)pNextFlowspec - (PUCHAR)pigcSrc;

            // Copy the all the flowspecs that occur before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the flowspecs as they are
            dwSkip = dwOffset + sizeof(IPQOS_NAMED_FLOWSPEC);
            memcpy((PUCHAR) pigcDst + dwOffset,
                   (PUCHAR) pigcSrc + dwSkip,
                   dwBlkSize - dwSkip);

            pigcDst->NumFlowspecs--;
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);  
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosFlowspecs(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszFlowspecName
    )
{
    PIPQOS_GLOBAL_CONFIG pigcSrc;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwErr, j;
    PIPQOS_NAMED_FLOWSPEC pNextFlowspec;
    FLOWSPEC *pFlowspec;
    PWCHAR  pwszFlowspecName = NULL;
    PTCHAR  ptszServiceType = NULL;
    VALUE_TOKEN  vtServiceType1[] =
                  {SERVICETYPE_BESTEFFORT,TOKEN_OPT_SERVICE_BESTEFFORT,
                   SERVICETYPE_CONTROLLEDLOAD,TOKEN_OPT_SERVICE_CONTROLLEDLOAD,
                   SERVICETYPE_GUARANTEED,TOKEN_OPT_SERVICE_GUARANTEED,
                   SERVICETYPE_QUALITATIVE,TOKEN_OPT_SERVICE_QUALITATIVE};

    VALUE_STRING vtServiceType2[] =
                  {SERVICETYPE_BESTEFFORT,STRING_SERVICE_BESTEFFORT,
                   SERVICETYPE_CONTROLLEDLOAD,STRING_SERVICE_CONTROLLEDLOAD,
                   SERVICETYPE_GUARANTEED,STRING_SERVICE_GUARANTEED,
                   SERVICETYPE_QUALITATIVE,STRING_SERVICE_QUALITATIVE};

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( pigcSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) ((PUCHAR) pigcSrc + 
                                             sizeof(IPQOS_GLOBAL_CONFIG));

    for (j = 0; j < pigcSrc->NumFlowspecs; j++)
    {
        if ((!wszFlowspecName) ||
            (!_wcsicmp(pNextFlowspec->FlowspecName, wszFlowspecName)))
        {
            pFlowspec = &pNextFlowspec->FlowspecDesc;

            //
            // Print or dump the flowspec now
            //

            pwszFlowspecName = 
                MakeQuotedString(pNextFlowspec->FlowspecName);
    
            if (pwszFlowspecName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Get service type of flowspec
            //

            GetAltDisplayString(g_hModule, hFile,
                                pFlowspec->ServiceType,
                                vtServiceType1,
                                vtServiceType2,
                                NUM_VALUES_IN_TABLE(vtServiceType1),
                                &ptszServiceType);

            if ( ptszServiceType == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_FLOWSPEC,
                                pwszFlowspecName);

                DisplayMessageT(DMP_QOS_ADD_FLOWSPEC,
                                pwszFlowspecName,
                                ptszServiceType,
                                pFlowspec->TokenRate,
                                pFlowspec->TokenBucketSize,
                                pFlowspec->PeakBandwidth,
                                pFlowspec->Latency,
                                pFlowspec->DelayVariation,
                                pFlowspec->MaxSduSize,
                                pFlowspec->MinimumPolicedSize);
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_FLOWSPEC_INFO,
                               pwszFlowspecName,
                               ptszServiceType,
                               pFlowspec->TokenRate,
                               pFlowspec->TokenBucketSize,
                               pFlowspec->PeakBandwidth,
                               pFlowspec->Latency,
                               pFlowspec->DelayVariation,
                               pFlowspec->MaxSduSize,
                               pFlowspec->MinimumPolicedSize);
            }

            FREE_STRING_NOT_NULL( ptszServiceType ) ;

            if ( pwszFlowspecName )
            {
                FreeQuotedString( pwszFlowspecName );
                pwszFlowspecName = NULL;
            }

            //
            // If we matched flowspec, then done
            //

            if (wszFlowspecName)
            {
                break;
            }
        }

        // Advance to the next flowspec in the list
        pNextFlowspec++;
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszFlowspecName) && (j == pigcSrc->NumFlowspecs))
        {
            // We didnt find the flowspec we are looking for
            DisplayMessage(g_hModule,
                           MSG_FLOWSPEC_NOT_FOUND,
                           wszFlowspecName);

            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    HEAP_FREE(pigcSrc);

    return dwErr;
}

DWORD
GetQosAddDelFlowspecOnFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for attaching and detaching
    flowspecs on flows.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_GLOBAL_CONFIG  pigcSrc = NULL;
    PIPQOS_IF_CONFIG      piicSrc = NULL;
    DWORD                 dwBlkSize, dwQosCount;
    DWORD                 dwBlkSize1, dwQosCount1;
    DWORD                 i, j, dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwRes;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType, dwDirection;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PIPQOS_NAMED_FLOWSPEC pNamedFlowspec, pNextFlowspec;
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName, pwszFlowspec;
    DWORD                 dwNumArg,
                          dwBufferSize = sizeof(wszIfName);
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOWSPEC,TRUE,FALSE},
                                       {TOKEN_OPT_DIRECTION, FALSE, FALSE}};
    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    dwDirection = DIRECTION_BIDIRECTIONAL;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                // INTERFACE NAME
                IpmontrGetIfNameFromFriendlyName( pptcArguments[i + dwCurrentIndex],
                                                  wszIfName,&dwBufferSize);
                break;

        case 1: 
                // FLOW NAME
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        case 2: 
                // FLOWSPEC NAME
                pwszFlowspec = pptcArguments[i + dwCurrentIndex];
                break;

        case 3:
        {
                // DIRECTION
                TOKEN_VALUE    rgEnums[] =
                 {{TOKEN_OPT_DIRECTION_INBOUND, DIRECTION_INBOUND},
                 {TOKEN_OPT_DIRECTION_OUTBOUND, DIRECTION_OUTBOUND},
                 {TOKEN_OPT_DIRECTION_BIDIRECTIONAL, DIRECTION_BIDIRECTIONAL}};

                GET_ENUM_TAG_VALUE();

                dwDirection = dwRes;

                break;
        }

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface, flow, flowspec names should be present
    
        if ((!pttTags[0].bPresent) || 
            (!pttTags[1].bPresent) ||
            (!pttTags[2].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (j == piicSrc->NumFlows)
        {
            //
            // We do not have a flow by this name
            //

            DisplayMessage(g_hModule,
                           MSG_FLOW_NOT_FOUND,
                           pwszFlowName);
            i = dwNumArg;
            dwErr = ERROR_SUPPRESS_OUTPUT;
            break;
        }

        // Flow was found at 'pNextFlow' position

        if (!bAdd)
        {
            //
            // Make sure that the flow has the named flowspec
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                if (_wcsicmp(pNextFlow->FlowDesc.RecvingFlowspecName,
                             pwszFlowspec))
                {
                    DisplayMessage(g_hModule,
                                   MSG_FLOWSPEC_NOT_FOUND,
                                   pwszFlowspec);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                if (_wcsicmp(pNextFlow->FlowDesc.SendingFlowspecName,
                             pwszFlowspec))
                {
                    DisplayMessage(g_hModule,
                                   MSG_FLOWSPEC_NOT_FOUND,
                                   pwszFlowspec);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }
            }

            //
            // Delete the association of the flowspec & flow
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                pNextFlow->FlowDesc.RecvingFlowspecName[0] = L'\0';
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                pNextFlow->FlowDesc.SendingFlowspecName[0] = L'\0';
            }
        }
        else
        {
            //
            // Make sure that the flowspec is actually defined
            //

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pigcSrc,
                                                      &dwBlkSize1,
                                                      &dwQosCount1);
                
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if ( pigcSrc == NULL )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) 
                ((PUCHAR) pigcSrc + sizeof(IPQOS_GLOBAL_CONFIG));

            for (j = 0; j < pigcSrc->NumFlowspecs; j++)
            {
                if (!_wcsicmp(pNextFlowspec->FlowspecName,
                              pwszFlowspec))
                {
                    break;
                }

                pNextFlowspec++;
            }

            if (j == pigcSrc->NumFlowspecs)
            {
                //
                // We do not have a flowspec by this name
                //

                DisplayMessage(g_hModule,
                               MSG_FLOWSPEC_NOT_FOUND,
                               pwszFlowspec);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Create the association of the flowspec & flow
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                wcscpy(pNextFlow->FlowDesc.RecvingFlowspecName,
                       pwszFlowspec);
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                wcscpy(pNextFlow->FlowDesc.SendingFlowspecName,
                       pwszFlowspec);
            }
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicSrc,
                                                   dwBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(piicSrc);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\makefile.inc ===
qosmmsg.mc:   .\qosmlog.h
    mapmsg NET QOSMLOG_BASE .\qosmlog.h > qosmmsg.mc

qosmmsg.h msg00001.bin:       qosmmsg.mc
    mc -v qosmmsg.mc

qosmgr.rc:      msg00001.bin

clean::
    -del qosmmsg.mc qosmmsg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\qosp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qosp.h

Abstract:

    Includes for QOS netsh extension

Revision History:

--*/

#ifndef __QOSP_H
#define __QOSP_H

//
// Constants and Defines
//

#define QOS_LOG_MASK                0x00000001

#define QOS_IF_STATE_MASK           0x00000001

#define DIRECTION_INBOUND           0x00000001
#define DIRECTION_OUTBOUND          0x00000002
#define DIRECTION_BIDIRECTIONAL     (DIRECTION_INBOUND | DIRECTION_OUTBOUND)

#define MAX_WSTR_LENGTH             (MAX_STRING_LENGTH * sizeof(WCHAR))

//
// Extern Global Variables
//

extern ULONG                   g_ulQosNumTopCmds;
extern CMD_ENTRY               g_QosCmds[];

extern ULONG                   g_ulQosNumGroups;
extern CMD_GROUP_ENTRY         g_QosCmdGroups[];

extern ULONG                   g_dwNumQosTableEntries; // Num of sub-helpers

#ifdef ALLOW_CHILD_HELPERS
extern ULONG                   g_dwNumQosContexts;     // Num of sub-contexts
extern PIP_CONTEXT_TABLE_ENTRY g_QosContextTable;
#endif

//
// Function Prototypes
//

// Exported Entry Points

NS_CONTEXT_DUMP_FN   QosDump;

// Command Handlers

FN_HANDLE_CMD  HandleQosInstall;
FN_HANDLE_CMD  HandleQosUninstall;

FN_HANDLE_CMD  HandleQosAddHelper;
FN_HANDLE_CMD  HandleQosDelHelper;
FN_HANDLE_CMD  HandleQosShowHelper;

FN_HANDLE_CMD  HandleQosSetGlobal;
FN_HANDLE_CMD  HandleQosShowGlobal;

FN_HANDLE_CMD  HandleQosAddFlowspec;
FN_HANDLE_CMD  HandleQosDelFlowspec;
FN_HANDLE_CMD  HandleQosShowFlowspec;

FN_HANDLE_CMD  HandleQosDelQosObject;
FN_HANDLE_CMD  HandleQosShowQosObject;

FN_HANDLE_CMD  HandleQosAddSdMode;
FN_HANDLE_CMD  HandleQosShowSdMode;

FN_HANDLE_CMD  HandleQosAddDsRule;
FN_HANDLE_CMD  HandleQosDelDsRule;
FN_HANDLE_CMD  HandleQosShowDsMap;

FN_HANDLE_CMD  HandleQosAddIf;
FN_HANDLE_CMD  HandleQosSetIf;
FN_HANDLE_CMD  HandleQosDelIf;
FN_HANDLE_CMD  HandleQosShowIf;

FN_HANDLE_CMD  HandleQosDump;    
FN_HANDLE_CMD  HandleQosHelp;

FN_HANDLE_CMD  HandleQosAddFlowOnIf;
FN_HANDLE_CMD  HandleQosDelFlowOnIf;
FN_HANDLE_CMD  HandleQosShowFlowOnIf;

FN_HANDLE_CMD  HandleQosAddFlowspecOnIfFlow;
FN_HANDLE_CMD  HandleQosDelFlowspecOnIfFlow;

FN_HANDLE_CMD  HandleQosAddQosObjectOnIfFlow;
FN_HANDLE_CMD  HandleQosDelQosObjectOnIfFlow;

FN_HANDLE_CMD  HandleQosAttachFilterToFlow;
FN_HANDLE_CMD  HandleQosDetachFilterFromFlow;
FN_HANDLE_CMD  HandleQosModifyFilterOnFlow;
FN_HANDLE_CMD  HandleQosShowFilterOnFlow;

FN_HANDLE_CMD  HandleQosMibHelp;
FN_HANDLE_CMD  HandleQosMibShowObject;

// Helper Helper functions

BOOL
IsQosCommand(
    IN PWCHAR pwszCmd
    );

// Info Helper functions

DWORD
UpdateAllInterfaceConfigs(
    VOID
    );

DWORD
MakeQosGlobalInfo(
    OUT      PBYTE                 *ppbStart,
    OUT      PDWORD                 pdwSize
    );

DWORD
MakeQosInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                  *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD
ShowQosGlobalInfo (
    IN      HANDLE                  hFile
    );

DWORD
ShowQosInterfaceInfo(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfName
    );

DWORD
ShowQosAllInterfaceInfo(
    IN      HANDLE                  hFile
    );

DWORD
UpdateQosGlobalConfig(
    IN      PIPQOS_GLOBAL_CONFIG    pigcGlobalCfg,
    IN      DWORD                   dwBitVector
    );

DWORD
UpdateQosInterfaceConfig( 
    IN      PWCHAR                  pwszIfName,                         
    IN      PIPQOS_IF_CONFIG        pChangeCfg,
    IN      DWORD                   dwBitVector,
    IN      BOOL                    bAddSet
    );

DWORD
GetQosSetIfOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      PWCHAR                  wszIfName,
    IN      DWORD                   dwSizeOfwszIfName,
    OUT     PIPQOS_IF_CONFIG        pChangeCfg,
    OUT     DWORD                  *pdwBitVector,
    IN      BOOL                    bAddSet
    );

DWORD
GetQosAddDelIfFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosFlows(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    );

DWORD
ShowQosFlowsOnIf(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    );

DWORD
GetQosAddDelFlowspecOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosFlowspecs(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszFlowspecName
    );

DWORD
GetQosAddDelFlowspecOnFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
GetQosAddDelDsRuleOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
HandleQosShowGenericQosObject(
    IN      DWORD                   dwQosObjectType,
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                   *pbDone
    );

typedef
DWORD
(*PSHOW_QOS_OBJECT)(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pGenObj
    );

DWORD
ShowQosDsMap(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszDsMapName,
    IN      QOS_OBJECT_HDR         *pDsMap
    );

DWORD
ShowQosSdMode(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszSdModeName,
    IN      QOS_OBJECT_HDR         *pSdMode
    );

DWORD
GetQosAddDelQosObject(
    IN      PWCHAR                  pwszQosObjectName,
    IN      QOS_OBJECT_HDR         *pQosObject,
    IN      BOOL                    bAdd
    );

DWORD
GetQosAddDelQosObjectOnFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosObjects(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszQosObjectName,
    IN      ULONG                   dwQosObjectType
    );

DWORD
ShowQosGenObj(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pGenObj
    );

// Help Helper Functions

DWORD
ShowQosHelp(
    IN      DWORD                   dwDisplayFlags,
    IN      DWORD                   dwCmdFlags,
    IN      DWORD                   dwArgsRemaining,
    IN      PWCHAR                  pwszGroup
    );

DWORD
WINAPI
DisplayQosHelp(
    VOID
    );

// Dump Helper functions

DWORD
DumpQosInformation (
    IN      HANDLE                  hFile
    );

DWORD
DumpQosHelperInformation (
    IN      HANDLE                  hFile
    );

// MIB Helper defs

typedef
VOID
(*PQOS_PRINT_FN)(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

typedef struct _QOS_MAGIC_TABLE
{
    DWORD          dwId;
    PQOS_PRINT_FN  pfnPrintFunction;
}QOS_MAGIC_TABLE, *PQOS_MAGIC_TABLE;

// MIB Helper functions

VOID
PrintQosGlobalStats(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

VOID
PrintQosIfStats(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

DWORD
GetQosMIBIfIndex(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    OUT     PDWORD                  pdwIndices,
    OUT     PDWORD                  pdwNumParsed 
);

//
// Common Macros
//

#define GET_ENUM_TAG_VALUE()                                            \
        dwErr = MatchEnumTag(g_hModule,                                 \
                             pptcArguments[i + dwCurrentIndex],         \
                             NUM_TOKENS_IN_TABLE(rgEnums),              \
                             rgEnums,                                   \
                             &dwRes);                                   \
                                                                        \
        if (dwErr != NO_ERROR)                                          \
        {                                                               \
            DispTokenErrMsg(g_hModule,                                  \
                            EMSG_BAD_OPTION_VALUE,                      \
                            pttTags[pdwTagType[i]].pwszTag,             \
                            pptcArguments[i + dwCurrentIndex]);         \
                                                                        \
            DisplayMessage(g_hModule,                                   \
                           EMSG_BAD_OPTION_ENUMERATION,                 \
                           pttTags[pdwTagType[i]].pwszTag);             \
                                                                        \
            for ( j = 0; j < NUM_TOKENS_IN_TABLE(rgEnums); j++ )        \
            {                                                           \
                DisplayMessageT( L" %1!s!\n", rgEnums[j].pwszToken );   \
            }                                                           \
                                                                        \
            i = dwNumArg;                                               \
            dwErr = ERROR_SUPPRESS_OUTPUT;                              \
            break;                                                      \
        }                                                               \

#endif // __QOSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-netsh\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman            05/15/1996        Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged  
// in a hierachy as follows

    // Command line tokens
        // command class
        // commands
        // command objects
            // Router command objects
            // MIB comand objects
        // command option tags
            // interface options
            // filter options
            // Protocol Options
                // OSPF options
                // RIP options
                // Igmp options
            // Route options
        // Micellaneous options
        // Option values
            // Interface types
            // Router discovery types
            // Protocol types
            // Accept/Announce types
            // Misc. option values

    // command usage messages
        // show command usage 
        // add command usage 
        // delete command usage 
        // set command usage 

    // Output messages
        // Router messages
            // Interface messages
            // Filter messages
            // Route messages
            // Global info. messages
            // OSPF messages
        // MIB messages

    // Strings
        // Interface Types
        // TCP constants
        // TCP states
        // Protocol types
        // IP Route types
        // IP net types
        // Interface types
        // transmission types
        // Miscellaneous strings
        
    // Error Messages

#define MSG_NULL                                1000

#define MAX_ROUTER_OBJECTS                      \
    (TOKEN_RTR_OBJECT_IPIPTUNNEL - TOKEN_RTR_OBJECT_INTERFACE + 1)

#define MAX_MIB_OBJECTS                         \
    (TOKEN_MIB_OBJECT_MFESTATS - TOKEN_MIB_OBJECT_INTERFACE + 1)

#define DMP_IGMP_HEADER                         7017
#define DMP_IGMP_FOOTER                         7019
#define DMP_IGMP_INTERFACE_HEADER               7018

#define DMP_RDISC_HEADER                        7021

#define DMP_RIP_HEADER                          7033
#define DMP_RIP_INTERFACE_HEADER                7034
#define DMP_RIP_FOOTER                          7042

#define DMP_BOOTP_GLOBAL_HEADER                 7050
#define DMP_BOOTP_INTERFACE_HEADER              7055
#define DMP_BOOTP_FOOTER                        7059

#define DMP_OSPF_HEADER                         7063
#define DMP_OSPF_INTERFACE_HEADER               7064
#define DMP_OSPF_FOOTER                         7076

#define DMP_AUTODHCP_HEADER                     7080
#define DMP_AUTODHCP_FOOTER                     7081
#define DMP_AUTODHCP_INTERFACE_HEADER           7082

#define DMP_DNSPROXY_HEADER                     7085
#define DMP_DNSPROXY_FOOTER                     7086
#define DMP_DNSPROXY_INTERFACE_HEADER           7087

#define DMP_NAT_HEADER                          7090
#define DMP_NAT_FOOTER                          7091
#define DMP_NAT_INTERFACE_HEADER                7092

#define MSG_QOS_HEADER                          7101
#define MSG_QOS_FOOTER                          7102
#define MSG_QOS_GLOBAL_HEADER                   7103
#define MSG_QOS_GLOBAL_FOOTER                   7104
#define MSG_QOS_INTERFACE_HEADER                7105
#define MSG_QOS_INTERFACE_FOOTER                7106

#define MSG_FLOWSPEC_ALREADY_EXISTS             7201
#define MSG_FLOWSPEC_NOT_FOUND                  7202
#define MSG_FLOW_ALREADY_EXISTS                 7203
#define MSG_FLOW_NOT_FOUND                      7204
#define MSG_QOSOBJECT_ALREADY_EXISTS            7205
#define MSG_QOSOBJECT_NOT_FOUND                 7206
#define MSG_DSRULE_NOT_FOUND                    7207

// commmon hlp messages

#define HLP_HELP                                8400
#define HLP_HELP_EX                             8401
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_SHOW_HELPER                         8412
#define HLP_SHOW_HELPER_EX                      8413
#define HLP_INSTALL                             8414
#define HLP_INSTALL_EX                          8415
#define HLP_UNINSTALL                           8416
#define HLP_UNINSTALL_EX                        8417
#define HLP_DUMP                                8418
#define HLP_DUMP_EX                             8419
#define HLP_GROUP_ADD                           8420
#define HLP_GROUP_DELETE                        8421
#define HLP_GROUP_SET                           8422
#define HLP_GROUP_SHOW                          8423
#define HLP_ADD_HELPER                          8424
#define HLP_ADD_HELPER_EX                       8425
#define HLP_DEL_HELPER                          8426
#define HLP_DEL_HELPER_EX                       8427


// rip add hlp

#define HLP_RIP_ADD_PF                          9000
#define HLP_RIP_ADD_PF_EX                       9001
#define HLP_RIP_ADD_IF_ACCF                     9002
#define HLP_RIP_ADD_IF_ACCF_EX                  9003
#define HLP_RIP_ADD_IF_ANNF                     9004
#define HLP_RIP_ADD_IF_ANNF_EX                  9005
#define HLP_RIP_ADD_IF_NBR                      9006
#define HLP_RIP_ADD_IF_NBR_EX                   9007
#define HLP_RIP_ADD_IF                          9008
#define HLP_RIP_ADD_IF_EX                       9009

// rip delete hlp

#define HLP_RIP_DEL_PF                          9020
#define HLP_RIP_DEL_PF_EX                       9021
#define HLP_RIP_DEL_IF_ACCF                     9022
#define HLP_RIP_DEL_IF_ACCF_EX                  9023
#define HLP_RIP_DEL_IF_ANNF                     9024
#define HLP_RIP_DEL_IF_ANNF_EX                  9025
#define HLP_RIP_DEL_IF_NBR                      9026
#define HLP_RIP_DEL_IF_NBR_EX                   9027
#define HLP_RIP_DEL_IF                          9028
#define HLP_RIP_DEL_IF_EX                       9029

// rip set hlp

#define HLP_RIP_SET_IF                          9040
#define HLP_RIP_SET_IF_EX                       9041
#define HLP_RIP_SET_FLAGS                       9042
#define HLP_RIP_SET_FLAGS_EX                    9043
#define HLP_RIP_SET_GLOBAL                      9044
#define HLP_RIP_SET_GLOBAL_EX                   9045

// rip show hlp

#define HLP_RIP_SHOW_IF                         9050
#define HLP_RIP_SHOW_IF_EX                      9051
#define HLP_RIP_SHOW_FLAGS                      9052
#define HLP_RIP_SHOW_FLAGS_EX                   9053
#define HLP_RIP_SHOW_GLOBAL                     9054
#define HLP_RIP_SHOW_GLOBAL_EX                  9055

// ospf add hlp

#define HLP_OSPF_ADD_AREA_RANGE                 9100
#define HLP_OSPF_ADD_AREA_RANGE_EX              9101
#define HLP_OSPF_ADD_AREA                       9102
#define HLP_OSPF_ADD_AREA_EX                    9103
#define HLP_OSPF_ADD_VIRTIF                     9104
#define HLP_OSPF_ADD_VIRTIF_EX                  9105
#define HLP_OSPF_ADD_IF_NBR                     9106
#define HLP_OSPF_ADD_IF_NBR_EX                  9107
#define HLP_OSPF_ADD_IF                         9108
#define HLP_OSPF_ADD_IF_EX                      9109
#define HLP_OSPF_ADD_ROUTE_FILTER               9110
#define HLP_OSPF_ADD_ROUTE_FILTER_EX            9111
#define HLP_OSPF_ADD_PROTO_FILTER               9112
#define HLP_OSPF_ADD_PROTO_FILTER_EX            9113
#define HLP_OSPF_INSTALL                        9114
#define HLP_OSPF_INSTALL_EX                     9115

#define HLP_OSPF_DEL_AREA_RANGE                 9120
#define HLP_OSPF_DEL_AREA_RANGE_EX              9121
#define HLP_OSPF_DEL_AREA                       9122
#define HLP_OSPF_DEL_AREA_EX                    9123
#define HLP_OSPF_DEL_VIRTIF                     9124
#define HLP_OSPF_DEL_VIRTIF_EX                  9125
#define HLP_OSPF_DEL_IF_NBR                     9126
#define HLP_OSPF_DEL_IF_NBR_EX                  9127
#define HLP_OSPF_DEL_IF                         9128
#define HLP_OSPF_DEL_IF_EX                      9129
#define HLP_OSPF_DEL_ROUTE_FILTER               9130
#define HLP_OSPF_DEL_ROUTE_FILTER_EX            9131
#define HLP_OSPF_DEL_PROTO_FILTER               9132
#define HLP_OSPF_DEL_PROTO_FILTER_EX            9133
#define HLP_OSPF_UNINSTALL                      9134
#define HLP_OSPF_UNINSTALL_EX                   9135

#define HLP_OSPF_SET_AREA                       9140
#define HLP_OSPF_SET_AREA_EX                    9141
#define HLP_OSPF_SET_VIRTIF                     9142
#define HLP_OSPF_SET_VIRTIF_EX                  9143
#define HLP_OSPF_SET_IF                         9144
#define HLP_OSPF_SET_IF_EX                      9145
#define HLP_OSPF_SET_GLOBAL                     9146
#define HLP_OSPF_SET_GLOBAL_EX                  9147
#define HLP_OSPF_SET_ROUTE_FILTER               9148
#define HLP_OSPF_SET_ROUTE_FILTER_EX            9149
#define HLP_OSPF_SET_PROTO_FILTER               9150
#define HLP_OSPF_SET_PROTO_FILTER_EX            9151

#define HLP_OSPF_SHOW_GLOBAL                    9160
#define HLP_OSPF_SHOW_GLOBAL_EX                 9161
#define HLP_OSPF_SHOW_AREA                      9162
#define HLP_OSPF_SHOW_AREA_EX                   9163
#define HLP_OSPF_SHOW_VIRTIF                    9164
#define HLP_OSPF_SHOW_VIRTIF_EX                 9165
#define HLP_OSPF_SHOW_IF                        9166
#define HLP_OSPF_SHOW_IF_EX                     9167
#define HLP_OSPF_SHOW                           9168
#define HLP_OSPF_SHOW_EX                        9169
#define HLP_OSPF_SHOW_ROUTE_FILTER              9170
#define HLP_OSPF_SHOW_ROUTE_FILTER_EX           9171
#define HLP_OSPF_SHOW_PROTO_FILTER              9172
#define HLP_OSPF_SHOW_PROTO_FILTER_EX           9173

#define HLP_IGMP_ADD_IF_STATICGROUP             9300
#define HLP_IGMP_ADD_IF_STATICGROUP_EX          9301
#define HLP_IGMP_ADD_IF                         9302
#define HLP_IGMP_ADD_IF_EX                      9303
#define HLP_IGMP_INSTALL                        9304
#define HLP_IGMP_INSTALL_EX                     9305

#define HLP_IGMP_DEL_IF_STATICGROUP             9310
#define HLP_IGMP_DEL_IF_STATICGROUP_EX          9312
#define HLP_IGMP_DEL_IF                         9313
#define HLP_IGMP_DEL_IF_EX                      9314
#define HLP_IGMP_UNINSTALL                      9315
#define HLP_IGMP_UNINSTALL_EX                   9316
 
#define HLP_IGMP_SET_IF                         9320
#define HLP_IGMP_SET_IF_EX                      9321
#define HLP_IGMP_SET_GLOBAL                     9322 
#define HLP_IGMP_SET_GLOBAL_EX                  9323

#define HLP_IGMP_SHOW_IF                        9330
#define HLP_IGMP_SHOW_IF_EX                     9331
#define HLP_IGMP_SHOW_GLOBAL                    9332
#define HLP_IGMP_SHOW_GLOBAL_EX                 9333

// BOOTP help messages

#define HLP_BOOTP_ADD                           9401
#define HLP_BOOTP_ADD_EX                        9402
#define HLP_BOOTP_ADD_IF                        9403
#define HLP_BOOTP_ADD_IF_EX                     9404
#define HLP_BOOTP_ADD_DHCP_SERVER               9405
#define HLP_BOOTP_ADD_DHCP_SERVER_EX            9406

#define HLP_BOOTP_DEL                           9411
#define HLP_BOOTP_DEL_EX                        9412
#define HLP_BOOTP_DEL_IF                        9413
#define HLP_BOOTP_DEL_IF_EX                     9414
#define HLP_BOOTP_DEL_DHCP_SERVER               9415
#define HLP_BOOTP_DEL_DHCP_SERVER_EX            9416

#define HLP_BOOTP_SET_GLOBAL                    9421
#define HLP_BOOTP_SET_GLOBAL_EX                 9422
#define HLP_BOOTP_SET_IF                        9423
#define HLP_BOOTP_SET_IF_EX                     9424

#define HLP_BOOTP_SHOW_GLOBAL                   9431
#define HLP_BOOTP_SHOW_GLOBAL_EX                9432
#define HLP_BOOTP_SHOW_IF                       9433
#define HLP_BOOTP_SHOW_IF_EX                    9434

// DHCP allocator help messages
#define HLP_AUTODHCP_ADD_EXCLUSION              9441
#define HLP_AUTODHCP_ADD_EXCLUSION_EX           9442
#define HLP_AUTODHCP_DELETE_EXCLUSION           9443
#define HLP_AUTODHCP_DELETE_EXCLUSION_EX        9444
#define HLP_AUTODHCP_SET_GLOBAL                 9445
#define HLP_AUTODHCP_SET_GLOBAL_EX              9446
#define HLP_AUTODHCP_SET_INTERFACE              9447
#define HLP_AUTODHCP_SET_INTERFACE_EX           9448
#define HLP_AUTODHCP_SHOW_GLOBAL                9449
#define HLP_AUTODHCP_SHOW_GLOBAL_EX             9450
#define HLP_AUTODHCP_SHOW_INTERFACE             9451
#define HLP_AUTODHCP_SHOW_INTERFACE_EX          9452

// DNS proxy help messages
#define HLP_DNSPROXY_SET_GLOBAL                 9461
#define HLP_DNSPROXY_SET_GLOBAL_EX              9462
#define HLP_DNSPROXY_SET_INTERFACE              9463
#define HLP_DNSPROXY_SET_INTERFACE_EX           9464
#define HLP_DNSPROXY_SHOW_GLOBAL                9465
#define HLP_DNSPROXY_SHOW_GLOBAL_EX             9466
#define HLP_DNSPROXY_SHOW_INTERFACE             9467
#define HLP_DNSPROXY_SHOW_INTERFACE_EX          9468

// NAT help messages
#define HLP_NAT_ADD_ADDRESS_MAPPING             9471
#define HLP_NAT_ADD_ADDRESS_MAPPING_EX          9472
#define HLP_NAT_ADD_ADDRESS_RANGE               9473
#define HLP_NAT_ADD_ADDRESS_RANGE_EX            9474
#define HLP_NAT_ADD_PORT_MAPPING                9475
#define HLP_NAT_ADD_PORT_MAPPING_EX             9476
#define HLP_NAT_DELETE_ADDRESS_MAPPING          9477
#define HLP_NAT_DELETE_ADDRESS_MAPPING_EX       9478
#define HLP_NAT_DELETE_ADDRESS_RANGE            9479
#define HLP_NAT_DELETE_ADDRESS_RANGE_EX         9480
#define HLP_NAT_DELETE_PORT_MAPPING             9481
#define HLP_NAT_DELETE_PORT_MAPPING_EX          9482
#define HLP_NAT_SET_GLOBAL                      9483
#define HLP_NAT_SET_GLOBAL_EX                   9484
#define HLP_NAT_SET_INTERFACE                   9485
#define HLP_NAT_SET_INTERFACE_EX                9486
#define HLP_NAT_SHOW_GLOBAL                     9487
#define HLP_NAT_SHOW_GLOBAL_EX                  9488
#define HLP_NAT_ADD_INTERFACE                   9489
#define HLP_NAT_ADD_INTERFACE_EX                9490
#define HLP_NAT_DELETE_INTERFACE                9491
#define HLP_NAT_DELETE_INTERFACE_EX             9492
#define HLP_NAT_SHOW_INTERFACE                  9493
#define HLP_NAT_SHOW_INTERFACE_EX               9494
#define HLP_NAT_ADD_DIRECTPLAY                  9495
#define HLP_NAT_ADD_DIRECTPLAY_EX               9496
#define HLP_NAT_ADD_H323                        9497
#define HLP_NAT_ADD_H323_EX                     9498
#define HLP_NAT_DELETE_DIRECTPLAY               9499
#define HLP_NAT_DELETE_DIRECTPLAY_EX            9500
#define HLP_NAT_DELETE_H323                     9501
#define HLP_NAT_DELETE_H323_EX                  9502

// RDISC help messages
#define HLP_RDISC_ADD_INTERFACE                 9601
#define HLP_RDISC_ADD_INTERFACE_EX              9602
#define HLP_RDISC_DELETE_INTERFACE              9603
#define HLP_RDISC_DELETE_INTERFACE_EX           9604
#define HLP_RDISC_SET_INTERFACE                 9605
#define HLP_RDISC_SET_INTERFACE_EX              9606
#define HLP_RDISC_SHOW_INTERFACE                9607
#define HLP_RDISC_SHOW_INTERFACE_EX             9608
// QOS help messages

#define HLP_QOS_ADD_FILTER_TO_FLOW              9701
#define HLP_QOS_ADD_FILTER_TO_FLOW_EX           9702
#define HLP_QOS_ADD_QOSOBJECT_ON_FLOW           9703
#define HLP_QOS_ADD_QOSOBJECT_ON_FLOW_EX        9704
#define HLP_QOS_ADD_FLOWSPEC_ON_FLOW            9705
#define HLP_QOS_ADD_FLOWSPEC_ON_FLOW_EX         9706
#define HLP_QOS_ADD_FLOW_ON_IF                  9707
#define HLP_QOS_ADD_FLOW_ON_IF_EX               9708
#define HLP_QOS_ADD_IF                          9709
#define HLP_QOS_ADD_IF_EX                       9710
#define HLP_QOS_ADD_DSRULE                      9711
#define HLP_QOS_ADD_DSRULE_EX                   9712
#define HLP_QOS_ADD_SDMODE                      9713
#define HLP_QOS_ADD_SDMODE_EX                   9714
#define HLP_QOS_ADD_FLOWSPEC                    9715
#define HLP_QOS_ADD_FLOWSPEC_EX                 9716


#define HLP_QOS_DEL_FILTER_FROM_FLOW            9721
#define HLP_QOS_DEL_FILTER_FROM_FLOW_EX         9722
#define HLP_QOS_DEL_QOSOBJECT_ON_FLOW           9723
#define HLP_QOS_DEL_QOSOBJECT_ON_FLOW_EX        9724
#define HLP_QOS_DEL_FLOWSPEC_ON_FLOW            9725
#define HLP_QOS_DEL_FLOWSPEC_ON_FLOW_EX         9726
#define HLP_QOS_DEL_FLOW_ON_IF                  9727
#define HLP_QOS_DEL_FLOW_ON_IF_EX               9728
#define HLP_QOS_DEL_IF                          9729
#define HLP_QOS_DEL_IF_EX                       9730
#define HLP_QOS_DEL_DSRULE                      9731
#define HLP_QOS_DEL_DSRULE_EX                   9732
#define HLP_QOS_DEL_SDMODE                      9733
#define HLP_QOS_DEL_SDMODE_EX                   9734
#define HLP_QOS_DEL_QOSOBJECT                   9735
#define HLP_QOS_DEL_QOSOBJECT_EX                9736
#define HLP_QOS_DEL_FLOWSPEC                    9737
#define HLP_QOS_DEL_FLOWSPEC_EX                 9738

#define HLP_QOS_SET_FILTER_ON_FLOW              9741
#define HLP_QOS_SET_FILTER_ON_FLOW_EX           9742
#define HLP_QOS_SET_FLOW_ON_IF                  9743
#define HLP_QOS_SET_FLOW_ON_IF_EX               9744
#define HLP_QOS_SET_IF                          9745
#define HLP_QOS_SET_IF_EX                       9746
#define HLP_QOS_SET_GLOBAL                      9747
#define HLP_QOS_SET_GLOBAL_EX                   9748

#define HLP_QOS_SHOW_FILTER_ON_FLOW             9761
#define HLP_QOS_SHOW_FILTER_ON_FLOW_EX          9762
#define HLP_QOS_SHOW_FLOW_ON_IF                 9763
#define HLP_QOS_SHOW_FLOW_ON_IF_EX              9764
#define HLP_QOS_SHOW_IF                         9765
#define HLP_QOS_SHOW_IF_EX                      9766
#define HLP_QOS_SHOW_DSMAP                      9767
#define HLP_QOS_SHOW_DSMAP_EX                   9768
#define HLP_QOS_SHOW_SDMODE                     9769
#define HLP_QOS_SHOW_SDMODE_EX                  9770
#define HLP_QOS_SHOW_QOSOBJECT                  9771
#define HLP_QOS_SHOW_QOSOBJECT_EX               9772
#define HLP_QOS_SHOW_FLOWSPEC                   9773
#define HLP_QOS_SHOW_FLOWSPEC_EX                9774
#define HLP_QOS_SHOW_GLOBAL                     9775
#define HLP_QOS_SHOW_GLOBAL_EX                  9776


// Output messages

        // OSPF messages
#define MSG_OSPF_GLOBAL_INFO                    20401
#define MSG_OSPF_AREA_INFO                      20402
#define MSG_OSPF_INTERFACE_INFO                 20403
#define MSG_OSPF_IF_NBR_HEADER                  20404
#define MSG_OSPF_NEIGHBOR_INFO                  20405
#define MSG_OSPF_VIRTUAL_INTERFACE_INFO         20406
#define MSG_OSPF_AREA_RANGE_HEADER              20407
#define MSG_OSPF_AREA_RANGE_INFO                20408
#define MSG_OSPF_PROTOCOL_FILTER_ACTION         20410
#define MSG_OSPF_PROTOCOL_FILTER                20411
#define MSG_OSPF_NO_PROTOCOL_FILTER             20412
#define MSG_OSPF_ROUTE_FILTER_ACTION            20413
#define MSG_OSPF_ROUTE_FILTER                   20414
#define MSG_OSPF_NO_ROUTE_FILTER                20415
#define MSG_OSPF_PROTOCOL_FILTER_HEADER         20416
#define MSG_OSPF_ROUTE_FILTER_HEADER            20417


        // RIP messages
#define MSG_RIP_GLOBAL_INFO                     20501
#define MSG_RIP_PEER_HEADER                     20502
#define MSG_RIP_PEER_ADDR                       20503

#define MSG_RIP_IF_INFO                         20551
#define MSG_RIP_FLAGS                           20552
#define MSG_RIP_IF_UNICAST_HEADER               20553
#define MSG_RIP_IF_UNICAST_PEER                 20554
#define MSG_RIP_IF_ACCEPT_FILTER_HEADER         20555
#define MSG_RIP_IF_ANNOUNCE_FILTER_HEADER       20556
#define MSG_RIP_IF_FILTER                       20557

        // BOOTP messages
#define MSG_BOOTP_GLOBAL_INFO                   20601
#define MSG_BOOTP_SERVER_HEADER                 20602
#define MSG_BOOTP_SERVER_ADDR                   20603
#define MSG_BOOTP_IF_INFO                       20604

        // IGMP messages
#define MSG_IGMP_GLOBAL_INFO                    20701
#define MSG_IGMP_IF_INFO_V1                     20702
#define MSG_IGMP_IF_INFO_V2                     20703
#define MSG_IGMP_STATIC_GROUP_HEADER            20704
#define MSG_IGMP_STATIC_GROUP_ENTRY             20705
#define MSG_IGMP_PROXY_IF_INFO                  20706

        // Connection sharing messages
#define MSG_AUTODHCP_GLOBAL_INFO                20801
#define MSG_AUTODHCP_INTERFACE_INFO             20802
#define MSG_AUTODHCP_EXCLUSION_HEADER           20803
#define MSG_AUTODHCP_EXCLUSION                  20804
#define MSG_DNSPROXY_GLOBAL_INFO                20811
#define MSG_DNSPROXY_INTERFACE_INFO             20812
#define MSG_NAT_GLOBAL_INFO                     20821
#define MSG_NAT_INTERFACE_INFO                  20822
#define MSG_NAT_ADDRESS_MAPPING_HEADER          20823
#define MSG_NAT_ADDRESS_MAPPING                 20824
#define MSG_NAT_ADDRESS_RANGE_HEADER            20825
#define MSG_NAT_ADDRESS_RANGE                   20826
#define MSG_NAT_PORT_MAPPING_HEADER             20827
#define MSG_NAT_PORT_MAPPING                    20828

    // RDISC messages
#define MSG_RDISC_IF_INFO                       20901
#define MSG_RDISC_IF_ENTRY                      20902
#define MSG_RDISC_IF_HEADER                     20903

    // MIB messages
#define MSG_MIB_IGMP_ROUTER_INTERFACE           21041
#define MSG_MIB_IGMP_RAS_CLIENT_GROUP_TABLE     21042
#define MSG_MIB_IGMP_PROXY_INTERFACE            21043
#define MSG_MIB_IGMP_ROUTER_GROUP_TABLE         21044
#define MSG_MIB_IGMP_PROXY_GROUP_TABLE          21045
#define MSG_MIB_IGMP_ROUTER_GROUP_INFO          21046
#define MSG_MIB_IGMP_PROXY_GROUP_INFO           21047
#define MSG_MIB_IGMP_ROUTER_NO_ENTRIES          21048
#define MSG_MIB_IGMP_PROXY_NO_ENTRIES           21049
#define MSG_MIB_IGMP_GROUP_IF_TABLE             21050
#define MSG_MIB_GROUP_IF_INFO                   21051
#define MSG_MIB_IGMP_GROUP_NO_ENTRIES           21053
#define MSG_MIB_IGMP_GROUP_NO_ENTRY             21054

        // QOS messages
#define MSG_QOS_GLOBAL_INFO                     21101
#define MSG_QOS_FLOWSPEC_INFO                   21111
#define MSG_QOS_SDMODE_INFO                     21121
#define MSG_QOS_DSMAP_INFO                      21131
#define MSG_QOS_DSRULE_INFO                     21132
#define MSG_QOS_IF_INFO                         21141
#define MSG_QOS_FLOW_INFO                       21151
#define MSG_QOS_QOSOBJECT_INFO                  21161

     // !@#
#define MSG_IP_ADDR_NOT_FOUND                   21502
#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_IF_NBR_NOT_FOUND                    21506
#define EMSG_NO_INTERFACE                       21512
#define MSG_NO_HELPER                           21516
#define MSG_NO_HELPERS                          21517
#define EMSG_INTERFACE_EXISTS                   21525
#define EMSG_PROTO_NOT_INSTALLED                21526
#define EMSG_PROTO_INSTALLED                    21527
#define MSG_IP_BAD_IP_MASK                      21528
#define MSG_IP_ADDR_PRESENT                     21529
#define MSG_CTRL_C_TO_QUIT                      21530

#define MSG_BOOTP_MIB_OPT                       21552


    // RIP MIB
#define MSG_RIP_MIB_GS                          22000
#define MSG_RIP_MIB_PS                          22001
#define MSG_RIP_MIB_PS_HDR                      22002
#define MSG_RIP_MIB_IFSTATS                     22003
#define MSG_RIP_MIB_IFSTATS_HDR                 22004
#define MSG_RIP_MIB_IFBIND_HDR                  22005
#define MSG_RIP_MIB_IFBIND                      22006
#define MSG_RIP_MIB_IFBIND_ADDR                 22007
#define MSG_RIP_MIB_LINE                        22008


    // DHCP relay agent messages
    
#define MSG_BOOTP_MIB_GC                        22051
#define MSG_BOOTP_MIB_DHCP_SERVER_HEADER        22052
#define MSG_BOOTP_MIB_DHCP_SERVER               22053
#define MSG_BOOTP_MIB_IF_CONFIG                 22054
#define MSG_BOOTP_MIB_IF_BINDING                22055
#define MSG_BOOTP_MIB_IF_ADDRESS_HEADER         22056
#define MSG_BOOTP_MIB_IF_ADDRESS                22057
#define MSG_BOOTP_MIB_IF_STATS                  22058


     // OSPF MIB

#define MSG_OSPF_MIB_AREA                       22100
#define MSG_OSPF_MIB_AREA_HDR                   22101
#define MSG_OSPF_MIB_LSDB                       22102
#define MSG_OSPF_MIB_LSDB_HDR                   22103
#define MSG_OSPF_MIB_VIRTIF                     22104
#define MSG_OSPF_MIB_VIRTIF_HDR                 22105
#define MSG_OSPF_MIB_NBR                        22106
#define MSG_OSPF_MIB_NBR_HDR                    22107

#define EMSG_PROTO_NO_GLOBAL_INFO               25010           
#define EMSG_PROTO_NO_IF_INFO                   25011
#define EMSG_RSVD_KEYWORD                       25013
#define EMSG_BAD_IF_TYPE                        25014


// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      33001
#define STRING_PROTO_RIP                        33008
#define STRING_PROTO_OSPF                       33013
#define STRING_PROTO_BOOTP                      33015
#define STRING_PROTO_IGMP                       33017
#define STRING_PROTO_NAT                        33025
#define STRING_PROTO_DNS_PROXY                  33026
#define STRING_PROTO_DHCP_ALLOCATOR             33027
#define STRING_PROTO_QOS_MANAGER                33028

    // transmission types
#define STRING_BROADCAST                        37001
#define STRING_NBMA                             37002
#define STRING_PT2PT                            37003

    // Miscellaneous strings
#define STRING_CREATED                          38001
#define STRING_DELETED                          38002
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004

#define STRING_YES                              38013
#define STRING_NO                               38014
#define STRING_Y                                38015
#define STRING_N                                38016

#define STRING_NONE                             38021
#define STRING_PASSWD                           38022

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

#define STRING_FILTER_INCLUDE                   38061
#define STRING_FILTER_EXCLUDE                   38062

#define STRING_BOUND                            38071
#define STRING_BOUND_ENABLED                    38072
#define STRING_UNBOUND                          38073

#define STRING_UP                               38074
#define STRING_DOWN                             38075


//rip
#define STRING_RIP1                             38081
#define STRING_RIP1COMPAT                       38082
#define STRING_RIP2                             38083

#define STRING_PEER_ALSO                        38091
#define STRING_PEER_ONLY                        38092

#define STRING_PERIODIC                         38101
#define STRING_DEMAND                           38102

#define STRING_RIP_IF_ENABLED                   38103
#define STRING_RIP_IF_BOUND                     38104

//qos
#define STRING_QOS_IF_ENABLED                   38081
#define STRING_QOS_IF_BOUND                     38082

#define STRING_SERVICE_BESTEFFORT               38086
#define STRING_SERVICE_CONTROLLEDLOAD           38087
#define STRING_SERVICE_GUARANTEED               38088
#define STRING_SERVICE_QUALITATIVE              38089

#define STRING_SDMODE_BORROW                    38095
#define STRING_SDMODE_SHAPE                     38096
#define STRING_SDMODE_DISCARD                   38097
#define STRING_SDMODE_BORROW_PLUS               38098


//igmp
#define STRING_IGMP_ROUTER_V1                   38111
#define STRING_IGMP_ROUTER_V2                   38112
#define STRING_IGMP_PROXY                       38113

#define STRING_IGMP_IFTYPE_PERMANENT            38114
#define STRING_IGMP_IFTYPE_RAS_ROUTER           38115
#define STRING_IGMP_IFTYPE_RAS_SERVER           38116
#define STRING_IGMP_IFTYPE_RAS_CLIENT           38117
#define STRING_IGMP_IFTYPE_PERMANENT_PROXY      38118
#define STRING_IGMP_IFTYPE_DEMANDDIAL_PROXY     38119
#define STRING_IGMP_IFTYPE_UNKNOWN              38120
    
#define STRING_IGMP_NOT_BOUND                   38132
#define STRING_IGMP_ENABLED_BY_RTRMGR           38133
#define STRING_IGMP_ENABLED_IN_CONFIG           38134
#define STRING_IGMP_ENABLED_BY_MGM              38135
#define STRING_IGMP_FORWARD_JOINS_TO_MGM        38136
#define STRING_IGMP_QUERIER                     38137
#define STRING_IGMP_NON_QUERIER                 38138
#define STRING_IGMP_FLAG_L                      38139
#define STRING_IGMP_FLAG_S                      38140
#define STRING_IGMP_SPACE                       38141
#define STRING_IGMP_INFINITY                    38142
#define STRING_IGMP_Y                           38143
#define STRING_IGMP_DASH                        38144



#define STRING_FULL_XLATE                       38201
#define STRING_ADDRESS_XLATE                    38202
#define STRING_PRIVATE_XLATE                    38203
#define STRING_DEFAULT_INTERFACE                38206
#define STRING_TCP                              38207
#define STRING_UDP                              38208


//ospf

#define STRING_STUB                             38301
#define STRING_ROUTER                           38302
#define STRING_NETWORK                          38303
#define STRING_SUMMARY                          38304
#define STRING_ASSUMMARY                        38305
#define STRING_ASEXTERN                         38306

#define STRING_ATTEMPT                          38321
#define STRING_INIT                             38322
#define STRING_TWOWAY                           38323
#define STRING_EXCHSTART                        38324
#define STRING_EXCHANGE                         38325
#define STRING_LOADING                          38326
#define STRING_FULL                             38327

#define STRING_LOOPBACK                         38331
#define STRING_WAITING                          38332
#define STRING_DR                               38333
#define STRING_BDR                              38334


#define STRING_UNKNOWN                          50001




// Error messages
#define MSG_IP_DIM_ERROR                        60006
#define MSG_IP_NO_ENTRIES                       60015
#define EMSG_CORRUPT_INFO                       60016
#define MSG_IP_NO_GLOBAL_INFO                   60017
#define EMSG_NOT_ENOUGH_MEMORY                  60024
#define EMSG_BAD_OPTION_VALUE                   60025
#define EMSG_BAD_OPTION_ENUMERATION             60028
#define EMSG_VALID_OPTION_VALUE                 60029

#define MSG_IP_AREA_NOT_FOUND                   60103
#define MSG_IP_INTERFACE_NOT_FOUND              60112

// OSPF error messages
#define MSG_IP_AREA_NO_BACKBONE                 60201
#define MSG_IP_VI_NO_BACKBONE                   60202
#define MSG_IP_BAD_TRANSIT_AREA                 60203
#define MSG_IP_STUB_TRANSIT_AREA                60204
#define MSG_IP_TRANSIT_AREA_NOT_FOUND           60205
#define MSG_IP_BAD_RANGE                        60206
#define MSG_IP_NO_AREA                          60208
#define MSG_IP_BAD_ADDR_MASK                    60209

#define MSG_IP_OSPF_INTERFACE_NOT_FOUND         60220
#define MSG_IP_OSPF_MULTIPLE_INTERFACE_PARAM    60221
#define MSG_IP_OSPF_DEFAULT_PRESENT             60222
#define MSG_IP_OSPF_DEFAULT_NOT_ALLOWED         60223
#define MSG_IP_OSPF_ADDRESS_NOT_FOUND           60224

// RIP error messages
#define MSG_IP_RIP_FILTER_PRESENT               60211
#define MSG_IP_RIP_FILTER_NOT_PRESENT           60212
#define MSG_IP_RIP_INVALID_FILTER               60213

// NAT messages
#define MSG_IP_NAT_NO_ADDRESS_POOL              60251
#define MSG_IP_NAT_NO_ADDRESS_RANGE             60252
#define MSG_IP_NAT_ADDRESS_MAPPING_NEEDS_RANGE  60253
#define MSG_IP_NAT_PORT_MAPPING_NEEDS_RANGE     60254
#define MSG_IP_NAT_BAD_RANGE_END                60255
#define MSG_IP_AUTODHCP_BAD_EXCLUSION           60256
#define MSG_IP_NAT_ADDRESS_MAPPING_INVALID      60257
#define MSG_IP_NAT_PORT_MAPPING_INVALID         60258

// igmp
#define EMSG_STATIC_MGM_GROUP_FOR_PROXY         60301
#define EMSG_STATIC_GROUP_EXISTS                60302
#define EMSG_STATIC_GROUP_NOT_FOUND             60303
#define EMSG_IGMP_MULTIPLE_STATIC_GROUPS        60304
#define EMSG_IGMP_PROXY_EXISTS                  60305

//
// Error messages for mib calls
//

#define HLP_RIP_MIB_SHOW_STATS                63001
#define HLP_RIP_MIB_SHOW_STATS_EX             63002
#define HLP_RIP_MIB_SHOW_IFSTATS              63003
#define HLP_RIP_MIB_SHOW_IFSTATS_EX           63004
#define HLP_RIP_MIB_SHOW_IFBINDING            63005
#define HLP_RIP_MIB_SHOW_IFBINDING_EX         63006
#define HLP_RIP_MIB_SHOW_PEERSTATS            63007
#define HLP_RIP_MIB_SHOW_PEERSTATS_EX         63008

#define HLP_IGMP_MIB_SHOW_IF_STATS             63101
#define HLP_IGMP_MIB_SHOW_IF_STATS_EX          63102
#define HLP_IGMP_MIB_SHOW_IF_TABLE             63103
#define HLP_IGMP_MIB_SHOW_IF_TABLE_EX          63104
#define HLP_IGMP_MIB_SHOW_GROUP_TABLE         63105
#define HLP_IGMP_MIB_SHOW_GROUP_TABLE_EX      63106
#define HLP_IGMP_MIB_SHOW_RAS_GROUP_TABLE     63107
#define HLP_IGMP_MIB_SHOW_RAS_GROUP_TABLE_EX  63108
#define HLP_IGMP_MIB_SHOW_PROXY_GROUP_TABLE   63109
#define HLP_IGMP_MIB_SHOW_PROXY_GROUP_TABLE_EX 63110

#define HLP_OSPF_MIB_SHOW_AREA                63201
#define HLP_OSPF_MIB_SHOW_AREA_EX             63202
#define HLP_OSPF_MIB_SHOW_LSDB                63203
#define HLP_OSPF_MIB_SHOW_LSDB_EX             63204
#define HLP_OSPF_MIB_SHOW_NEIGHBOR            63205
#define HLP_OSPF_MIB_SHOW_NEIGHBOR_EX         63206
#define HLP_OSPF_MIB_SHOW_VIRTUALIF           63207
#define HLP_OSPF_MIB_SHOW_VIRTUALIF_EX        63208

#define HLP_BOOTP_MIB_SHOW_GLOBAL_CONFIG      63301
#define HLP_BOOTP_MIB_SHOW_GLOBAL_CONFIG_EX   63302
#define HLP_BOOTP_MIB_SHOW_IF_CONFIG          63303
#define HLP_BOOTP_MIB_SHOW_IF_CONFIG_EX       63304
#define HLP_BOOTP_MIB_SHOW_IF_BINDING         63305
#define HLP_BOOTP_MIB_SHOW_IF_BINDING_EX      63306
#define HLP_BOOTP_MIB_SHOW_IF_STATS           63307
#define HLP_BOOTP_MIB_SHOW_IF_STATS_EX        63308

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\pchqosm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    pchqosm.h

Abstract:

    The file contains precompiled header 
    for the QOS Mgr Protocol.

Revision History:

--*/

#ifndef __PCHQOSM_H_
#define __PCHQOSM_H_

// DO NOT CHANGE ORDER UNLESS YOU KNOW WHAT YOU ARE DOING

#include <nt.h>                 // Include file for NT API applications
#include <ntrtl.h>              // NT runtime USER & KERNEL mode routines
#include <nturtl.h>             // NT runtime USER mode routines

#include <windows.h>            // Include file for Windows applications

#undef   FD_SETSIZE
#define  FD_SETSIZE  256        // Max sockets a WinSock application can use
#include <winsock2.h>           // Interface to WinSock 2 API
#include <ws2tcpip.h>           // WinSock 2 Extension for TCP/IP protocols

#include <routprot.h>           // Interface to Router Manager
#include <rtmv2.h>              // Interface to Routing Table Manager v2
#include <iprtrmib.h>           // MIB variables handled by Router Manager
#include <mgm.h>                // Interface to Multicast Group Manager

#include <mprerror.h>           // Router specific error codes
#include <rtutils.h>            // Utility functions (Log, Trace, ...)

#define  INITGUID
#include <tcguid.h>             // Traffic Control API GUIDS
#include <ndisguid.h>           // Other NDIS adapter  GUIDS
#include <ntddndis.h>           // Needed for "ADDRESS_LIST"
#include <qos.h>                // QOS related definitions
#include <traffic.h>            // Traffic Control API description
#include <tcerror.h>            // Traffic Control API error codes

#include "ipqosrm.h"            // QOS Mgr <-> IP RtrMgr Interface

#include "qosmlog.h"            // Localizable log messages list
#include "qosmdbg.h"            // Logging n' Tracing Facilities

#include "sync.h"               // ReadWriteLock, LockedList Ops

#include "qosmmain.h"           // Global Structure Definitions

#endif // __PCHQOSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmapi.c

Abstract:

    The file contains IP router manager API 
    implementations for the Qos Mgr.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop


DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceChar
    )

/*++

Routine Description:

    Initializes some global data structures in Qos Mgr.

    We initialize some variables here instead of in
    QosmDllStartup as it might not be safe to perform
    some operations in the context of DLL's DLLMain.

    We also export the appropriate callbacks to RM.

    This function is called when RM loads the protocol.

Arguments:

    None

Return Value:

    Status of the operation

--*/

{
    if(RoutingChar->dwProtocolId != MS_IP_QOSMGR)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if  ((RoutingChar->fSupportedFunctionality
          & (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES)) !=
         (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES))
    {
        return ERROR_NOT_SUPPORTED;
    }

    RoutingChar->fSupportedFunctionality =
        (RF_ROUTING | RF_DEMAND_UPDATE_ROUTES);

    //
    // Since we are not a service advertiser (and IPX thing)
    //

    ServiceChar->fSupportedFunctionality = 0;


    RoutingChar->pfnStartProtocol      = StartProtocol;
    RoutingChar->pfnStartComplete      = StartComplete;
    RoutingChar->pfnStopProtocol       = StopProtocol;
    RoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
    RoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
    RoutingChar->pfnQueryPower         = NULL;
    RoutingChar->pfnSetPower           = NULL;

    RoutingChar->pfnAddInterface       = AddInterface;
    RoutingChar->pfnDeleteInterface    = DeleteInterface;
    RoutingChar->pfnInterfaceStatus    = InterfaceStatus;
    RoutingChar->pfnGetInterfaceInfo   = GetInterfaceInfo;
    RoutingChar->pfnSetInterfaceInfo   = SetInterfaceInfo;

    RoutingChar->pfnGetEventMessage    = GetEventMessage;

    RoutingChar->pfnUpdateRoutes       = UpdateRoutes;

    RoutingChar->pfnConnectClient      = NULL;
    RoutingChar->pfnDisconnectClient   = NULL;

    RoutingChar->pfnGetNeighbors       = NULL;
    RoutingChar->pfnGetMfeStatus       = NULL;

    RoutingChar->pfnMibCreateEntry     = MibCreateEntry;
    RoutingChar->pfnMibDeleteEntry     = MibDeleteEntry;
    RoutingChar->pfnMibGetEntry        = MibGetEntry;
    RoutingChar->pfnMibSetEntry        = MibSetEntry;
    RoutingChar->pfnMibGetFirstEntry   = MibGetFirstEntry;
    RoutingChar->pfnMibGetNextEntry    = MibGetNextEntry;
    RoutingChar->pfnMibSetTrapInfo     = MibSetTrapInfo;
    RoutingChar->pfnMibGetTrapInfo     = MibGetTrapInfo;

    return NO_ERROR;
}


DWORD
WINAPI
StartProtocol (
    IN      HANDLE                          NotificationEvent,
    IN      PSUPPORT_FUNCTIONS              SupportFunctions,
    IN      LPVOID                          GlobalInfo,
    IN      ULONG                           InfoVer,
    IN      ULONG                           InfoSize,
    IN      ULONG                           InfoCnt
    )
{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    TraceEnter("StartProtocol");

    GlobalConfig = (IPQOS_GLOBAL_CONFIG *) GlobalInfo;

    do
    {
        //
        // Copy RM support functions to global var
        //

        Globals.SupportFunctions = *SupportFunctions;

        //
        // First update your global configuration
        //

        Status = QosmSetGlobalInfo(GlobalConfig, 
                                   InfoSize);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Update state to "initialization done"
        //

        Globals.State = IPQOSMGR_STATE_RUNNING;
    }
    while (FALSE);

    TraceLeave("StartProtocol");

    return Status;
}


DWORD
WINAPI
StartComplete (
    VOID
    )
{
    TraceEnter("StartComplete");
    TraceLeave("StartComplete");

    return NO_ERROR;
}


DWORD
WINAPI
StopProtocol (
    VOID
    )
{
    TraceEnter("StopProtocol");
    TraceLeave("StopProtocol");

    return NO_ERROR;
}


DWORD
WINAPI
GetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN OUT  PULONG                          BufferSize,
    OUT     PULONG                          InfoVer,
    OUT     PULONG                          InfoSize,
    OUT     PULONG                          InfoCnt
    )
{
    DWORD                  Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

#if 1
    *InfoVer = *InfoCnt = 1;
#endif

    Trace2(ENTER, "GetGlobalInfo: Info: %p, Size: %08x",
                   GlobalInfo, 
                   BufferSize);

    Status = QosmGetGlobalInfo(GlobalInfo,
                               BufferSize,
                               InfoSize);

    Trace1(LEAVE, "GetGlobalInfo Returned: %u", Status);

    return Status;
}


DWORD
WINAPI
SetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN      ULONG                           InfoVer,
    IN      ULONG                           InfoSize,
    IN      ULONG                           InfoCnt
    )
{
    DWORD   Status;

    Trace2(ENTER, "SetGlobalInfo: Info: %p, Size: %08x",
                   GlobalInfo, 
                   InfoSize);

    Status = QosmSetGlobalInfo(GlobalInfo,
                               InfoSize);

    Trace1(LEAVE, "GetGlobalInfo: Returned %u", Status);

    return Status;
}



DWORD
WINAPI
AddInterface (
    IN      LPWSTR                         InterfaceName,
    IN      ULONG                          InterfaceIndex,
    IN      NET_INTERFACE_TYPE             InterfaceType,
    IN      DWORD                          MediaType,
    IN      WORD                           AccessType,
    IN      WORD                           ConnectionType,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoVer,
    IN      ULONG                          InfoSize,
    IN      ULONG                          InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface, NextInterface;
    PIPQOS_IF_CONFIG        InterfaceConfig;
    PLIST_ENTRY             p;
    BOOL                    LockInited;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    TraceEnter("AddInterface");

    //
    // Validate input parameters before creating 'if'
    //

    if ((!InterfaceName) || (!InterfaceInfo))
    {
        return ERROR_INVALID_PARAMETER;
    }

    InterfaceConfig = (PIPQOS_IF_CONFIG) InterfaceInfo;

    Interface = NULL;

    LockInited = FALSE;

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            NextInterface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (NextInterface->InterfaceIndex >= InterfaceIndex)
            {
                break;
            }
        }

        if ((p != &Globals.IfList) &&
               (NextInterface->InterfaceIndex == InterfaceIndex))
        {
            Status = ERROR_ALREADY_EXISTS;
            break;
        }

        //
        // Allocate a new interface structure
        //

        Interface = AllocNZeroMemory(sizeof(QOSMGR_INTERFACE_ENTRY));

        if (Interface == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Fill the interface info from input
        //

        Interface->InterfaceIndex = InterfaceIndex;

        wcscpy(Interface->InterfaceName, 
               InterfaceName);

        //
        // Initialize lock to guard this interface
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Interface->InterfaceLock);

            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();

                Trace1(ANY,
                       "AddInterface: Failed to create read/write lock %x",
                       Status);

                LOGERR0(CREATE_RWL_FAILED, Status);

                break;
            }

        Interface->Flags = InterfaceType;

        Interface->State = InterfaceConfig->QosState;

        Interface->NumFlows = 0;

        InitializeListHead(&Interface->FlowList);

        //
        // Fill in the TC information for this IF
        //

        QosmOpenTcInterface(Interface);

        //
        // Update state to reflect the intf config 
        //

        Status = QosmSetInterfaceInfo(Interface,
                                      InterfaceConfig,
                                      InfoSize);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Insert interface on sorted global list
        //

        InsertTailList(p, &Interface->ListByIndexLE);

        Globals.NumIfs++;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    if (Status != NO_ERROR)
    {
        //
        // Some error occurred - clean up and return
        //

        if (Interface->TciIfHandle)
        {
            TcCloseInterface(Interface->TciIfHandle);
        }

        if (LockInited)
        {
            DELETE_READ_WRITE_LOCK(&Interface->InterfaceLock);
        }
    
        if (Interface)
        {
            FreeMemory(Interface);
        }
    }

    TraceLeave("AddInterface");

    return Status;
}


DWORD
WINAPI
DeleteInterface (
    IN      ULONG                          InterfaceIndex
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    TraceEnter("DeleteInterface");

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Delete the interface from the global list
        //

        RemoveEntryList(&Interface->ListByIndexLE);

        Globals.NumIfs--;

        //
        // Free any handles associated with this if
        //

        if (Interface->TciIfHandle)
        {
            TcCloseInterface(Interface->TciIfHandle);
        }

        //
        // Free all memory allocated to the interface
        //

        DELETE_READ_WRITE_LOCK(&Interface->InterfaceLock);

        if (Interface->InterfaceConfig)
        {
            FreeMemory(Interface->InterfaceConfig);
        }

        FreeMemory(Interface);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    TraceLeave("DeleteInterface");

    return Status;
}


DWORD
WINAPI
InterfaceStatus (
    IN      ULONG                          InterfaceIndex,
    IN      BOOL                           InterfaceActive,
    IN      DWORD                          StatusType,
    IN      PVOID                          StatusInfo
    )
{
    TraceEnter("InterfaceStatus");
    TraceLeave("InterfaceStatus");

    return NO_ERROR;
}


DWORD
WINAPI
GetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoVer,
    OUT     PULONG                         InfoSize,
    OUT     PULONG                         InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

#if 1
    *InfoVer = *InfoCnt = 1;
#endif

    Trace3(ENTER, "GetInterfaceInfo: Index: %5u, Info: %p, Size: %08x",
                   InterfaceIndex,
                   InterfaceInfo, 
                   BufferSize);

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Get the interface info from the interface
        //
        
        Status = QosmGetInterfaceInfo(Interface,
                                      InterfaceInfo,
                                      BufferSize,
                                      InfoSize);
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    Trace1(LEAVE, "GetInterfaceInfo: Returned %u", Status);

    return Status;
}


DWORD
WINAPI
SetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoVer,
    IN      ULONG                          InfoSize,
    IN      ULONG                          InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    Trace3(ENTER, "SetInterfaceInfo: Index: %5u, Info: %p, Size: %08x",
                   InterfaceIndex,
                   InterfaceInfo, 
                   InfoSize);

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Set the interface info on the interface
        //
        
        Status = QosmSetInterfaceInfo(Interface,
                                      InterfaceInfo,
                                      InfoSize);
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    Trace1(LEAVE, "SetInterfaceInfo: Returned %u", Status);

    return Status;
}

DWORD
WINAPI
GetEventMessage (
    OUT     ROUTING_PROTOCOL_EVENTS        *Event,
    OUT     MESSAGE                        *Result
    )
{
    TraceEnter("GetEventMessage");
    TraceLeave("GetEventMessage");

    return ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
UpdateRoutes (
    IN      ULONG                          InterfaceIndex
    )
{
    TraceEnter("UpdateRoutes");
    TraceLeave("UpdateRoutes");

    return NO_ERROR;
}


DWORD
WINAPI
MibCreateEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibCreateEntry");
    TraceLeave("MibCreateEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibDeleteEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibDeleteEntry");
    TraceLeave("MibDeleteEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData,
    OUT     PULONG                         OutputDataSize,
    OUT     PVOID                          OutputData
    )
{
    TraceEnter("MibGetEntry");
    TraceLeave("MibGetEntry");

    return ERROR_INVALID_PARAMETER;
}


DWORD
WINAPI
MibSetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibSetEntry");
    TraceLeave("MibSetEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetFirstEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetFirstEntry");
    TraceLeave("MibGetFirstEntry");

    return ERROR_INVALID_PARAMETER;
}


DWORD
WINAPI
MibGetNextEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetNextEntry");
    TraceLeave("MibGetNextEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibSetTrapInfo (
    IN     HANDLE                          Event,
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibSetTrapInfo");
    TraceLeave("MibSetTrapInfo");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetTrapInfo (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetTrapInfo");
    TraceLeave("MibGetTrapInfo");

    return ERROR_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmdsrv.c ===
/*++

Copyright 1997 - 98, Microsoft Corporation

Module Name:

    qosmdsrv.c

Abstract:

    Contains routines that are invoked by
    the QosMgr DLL to control diffserv.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

//
// Traffic Control Handlers/Functionality
//

VOID 
TcNotifyHandler(
    IN      HANDLE                         ClRegCtx,
    IN      HANDLE                         ClIfcCtx,
    IN      ULONG                          Event,
    IN      HANDLE                         SubCode,
    IN      ULONG                          BufSize,
    IN      PVOID                          Buffer
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;

    switch (Event)
    {
    case TC_NOTIFY_IFC_UP:

        //
        // New interface - check if we have this interface
        //

        break;

    case TC_NOTIFY_IFC_CLOSE:

        //
        // An existing interface has been closed by system
        //

        ACQUIRE_GLOBALS_READ_LOCK();

        do
        {
            //
            // Make sure that the interface still exists on list
            //

            for (p = Globals.IfList.Flink; 
                 p != &Globals.IfList; 
                 p = p->Flink)
            {
                Interface =
                   CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

                if (Interface == ClIfcCtx)
                {
                    break;
                }
            }

            if (p == &Globals.IfList)
            {
                //
                // Must have been deleted in a parallel thread
                //

                break;
            }

            ACQUIRE_INTERFACE_WRITE_LOCK(Interface);

            Interface->TciIfHandle = NULL;

            //
            // This call would result in invalidating all flows
            // in the list as TciIfHandle is set to NULL above
            //

            QosmSetInterfaceInfo(Interface,
                                 Interface->InterfaceConfig,
                                 Interface->ConfigSize);

            RELEASE_INTERFACE_WRITE_LOCK(Interface);
        }
        while (FALSE);

        RELEASE_GLOBALS_READ_LOCK();

        break;
    }

    return;
}

DWORD
QosmOpenTcInterface(
    IN      PQOSMGR_INTERFACE_ENTRY        Interface
    )
{
    PTC_IFC_DESCRIPTOR CurrInterface;
    PTC_IFC_DESCRIPTOR Buffer;
    DWORD              BufferSize;
    DWORD              Status;

    //
    // First enumerate all interfaces and
    // get a interface with matching name
    //

    BufferSize = 0;

    Buffer = NULL;

    do
    {
        if (BufferSize)
        {
            //
            // Try to increase the buffer size
            //

            if (Buffer)
            {
                FreeMemory(Buffer);
            }

            Buffer = AllocMemory(BufferSize);

            if (!Buffer)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        Status = TcEnumerateInterfaces(Globals.TciHandle,
                                       &BufferSize,
                                       Buffer);
    }
    while (Status == ERROR_INSUFFICIENT_BUFFER);

    if (Status == NO_ERROR)
    {
        Status = ERROR_NOT_FOUND;

        //
        // Find the QOS interface with matching GUID
        //

        CurrInterface = Buffer;

        while (BufferSize > 0)
        {
            if (!_wcsicmp(CurrInterface->pInterfaceID,
                          Interface->InterfaceName))
            {
                // Found the interface - copy qos name

                wcscpy(Interface->AlternateName,
                       CurrInterface->pInterfaceName);

                // Open the interface and cache handle

                Status = TcOpenInterfaceW(Interface->AlternateName,
                                          Globals.TciHandle,
                                          Interface,
                                          &Interface->TciIfHandle);
                break;
            }

            BufferSize -= CurrInterface->Length;

            (PUCHAR) CurrInterface += CurrInterface->Length;
        }
    }

    if (Buffer)
    {
        FreeMemory(Buffer);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    qosmdbg.h

Abstract:
    Debugging in QOS Mgr Protocol DLL

Revision History:

--*/

#ifndef __QOSMDBG_H__
#define __QOSMDBG_H__

//
// Bypass the system assert
//

#ifdef  ASSERT
#undef  ASSERT
#endif 
#define ASSERT(a)               { if ((a) == FALSE) DbgBreakPoint(); }

//
// Constants used for tracing
//

#define QOSM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define QOSM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define QOSM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define QOSM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define QOSM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define QOSM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define QOSM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define QOSM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define QOSM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define QOSM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define QOSM_TRACE_CONFIG          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define QOSM_TRACE_FLOW            ((DWORD)0x04000000 | TRACE_USE_MASK)
#define QOSM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define QOSM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define QOSM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define QOSM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define QOSM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

#define TRACEHANDLE         Globals.TracingHandle

#define START_TRACING()     TRACEHANDLE = TraceRegister("QOSM")
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define QOSM_LOGGING_NONE      0
#define QOSM_LOGGING_ERROR     1
#define QOSM_LOGGING_WARN      2
#define QOSM_LOGGING_INFO      3

//
// Event logging macros
//

#define LOGHANDLE       Globals.LoggingHandle
#define LOGLEVEL        Globals.LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//
#define START_LOGGING()     LOGHANDLE = RouterLogRegister("QOSM")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif // __QOSMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmlog.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmlog.h

Abstract:

    This file is processed by mapmsg to produce a .mc file,
    then the .mc file is compiled by the message compiler,
    and the resulting binary is included in QOSMGR's resource file.

    Don't change the comments following the manifest constants
    without understanding how mapmsg works.

Revision History:

--*/

#define QOSMLOG_BASE                          43000

#define QOSMLOG_INIT_CRITSEC_FAILED           (QOSMLOG_BASE + 1)
/*
 * QOSMGR was unable to initialize a critical section.
 * The data is the exception code.
 */

#define QOSMLOG_CREATE_SEMAPHORE_FAILED       (QOSMLOG_BASE + 2)
/*
 * QOSMGR was unable to create a semaphore.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_EVENT_FAILED           (QOSMLOG_BASE + 3)
/*
 * QOSMGR was unable to create an event.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_RWL_FAILED             (QOSMLOG_BASE + 4)
/*
 * QOSMGR was unable to create a synchronization object.
 * The data is the error code.
 */



#define QOSMLOG_HEAP_CREATE_FAILED            (QOSMLOG_BASE + 5)
/*
 * QOSMGR was unable to create a heap.
 * The data is the error code.
 */

#define QOSMLOG_HEAP_ALLOC_FAILED             (QOSMLOG_BASE + 6)
/*
 * QOSMGR was unable to allocate memory from its heap.
 * The data is the error code.
 */



#define QOSMLOG_CREATE_THREAD_FAILED          (QOSMLOG_BASE + 7)
/*
 * QOSMGR was unable to create a thread.
 * The data is the error code.
 */



#define QOSMLOG_WSASTARTUP_FAILED             (QOSMLOG_BASE + 8)
/*
 * QOSMGR was unable to start Windows Sockets.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_SOCKET_FAILED          (QOSMLOG_BASE + 9)
/*
 * QOSMGR was unable to create a socket.
 * The data is the error code.
 */

#define QOSMLOG_BIND_IF_FAILED                (QOSMLOG_BASE + 10)
/*
 * QOSMGR could not bind to IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define QOSMLOG_RECVFROM_FAILED               (QOSMLOG_BASE + 11)
/*
 * QOSMGR was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define QOSMLOG_SENDTO_FAILED                 (QOSMLOG_BASE + 12)
/*
 * QOSMGR was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define QOSMLOG_SET_MCAST_IF_FAILED           (QOSMLOG_BASE + 13)
/*
 * QOSMGR could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define QOSMLOG_JOIN_GROUP_FAILED             (QOSMLOG_BASE + 14)
/*
 * QOSMGR could not join the multicast group 224.0.0.9
 * on the local interface with IP address %1.
 * The data is the error code.
 */



#define QOSMLOG_QOSMGR_STARTED                (QOSMLOG_BASE + 15)
/*
 * QOSMGR has started successfully.
 */

#define QOSMLOG_QOSMGR_ALREADY_STARTED        (QOSMLOG_BASE + 16)
/*
 * QOSMGR received a start request when it was already running.
 */

#define QOSMLOG_RTM_REGISTER_FAILED           (QOSMLOG_BASE + 17)
/*
 * IPRIPv2 was unable to register with the Routing Table Manager.
 * The data is the error code.
 */

#define QOSMLOG_QOSMGR_STOPPED                (QOSMLOG_BASE + 18)
/*
 * QOSMGR has stopped.
 */



#define QOSMLOG_NETWORK_MODULE_ERROR          (QOSMLOG_BASE + 19)
/*
 * QOSMGR encountered a problem in the Network Module.
 * The data is the error code.
 */



#define QOSMLOG_PACKET_TOO_SMALL              (QOSMLOG_BASE + 20)
/*
 * QOSMGR received a packet which was smaller than the minimum size
 * allowed for QOSMGR packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define QOSMLOG_PACKET_HEADER_CORRUPT         (QOSMLOG_BASE + 21)
/*
 * QOSMGR received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define QOSMLOG_PACKET_VERSION_INVALID        (QOSMLOG_BASE + 22)
/*
 * QOSMGR received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 



#define QOSMLOG_TIMER_MODULE_ERROR            (QOSMLOG_BASE + 23)
/*
 * QOSMGR encountered a problem in the Timer Module.
 * The data is the error code.
 */



#define QOSMLOG_PROTOCOL_MODULE_ERROR         (QOSMLOG_BASE + 24)
/*
 * QOSMGR encountered a problem in the Protocol Module.
 * The data is the error code.
 */



#define QOSMLOG_TC_REGISTER_FAILED            (QOSMLOG_BASE + 25)
/*
 * QOSMGR could not register with the traffic control API.
 * The data is the error code.
 */



#define QOSMLOG_TC_DEREGISTER_FAILED          (QOSMLOG_BASE + 26)
/*
 * QOSMGR could not deregister with the traffic control API.
 * The data is the error code.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosminfo.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosminfo.c

Abstract:

    The file contains global and interface
    config functions for QOS Mgr protocol.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

DWORD
WINAPI
QosmGetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    )

/*++
  
Routine Description:

    Returns the global config info for this protocol.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    //
    // Validate all input params before reading the global info
    //

    if (BufferSize == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        *InfoSize = Globals.ConfigSize;

        if ((*BufferSize < *InfoSize) || 
            (GlobalInfo == NULL))
        {
            //
            // Either the size was too small or there was no storage
            //

            Trace1(CONFIG, 
                   "GetGlobalInfo: Buffer size too small: %u",
                   *BufferSize);

            *BufferSize = *InfoSize;

            Status = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        *BufferSize = *InfoSize;

        GlobalConfig = (PIPQOS_GLOBAL_CONFIG) GlobalInfo;

        CopyMemory(GlobalConfig,
                   Globals.GlobalConfig,
                   *InfoSize);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    return Status;
}


DWORD
WINAPI
QosmSetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN      ULONG                          InfoSize
    )

/*++
  
Routine Description:

    Sets the global config info for this protocol.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    //
    // Update the global config information.
    //

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        GlobalConfig = AllocMemory(InfoSize);

        if (GlobalConfig == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Copy the new config information
        //

        CopyMemory(GlobalConfig, GlobalInfo, InfoSize);

        Globals.ConfigSize = InfoSize;

        //
        // Set up rest of the global state
        //

        if (GlobalConfig->LoggingLevel <= IPQOS_LOGGING_INFO)
        {
            Globals.LoggingLevel = GlobalConfig->LoggingLevel;
        }

        //
        // Cleanup old global information
        //

        if (Globals.GlobalConfig)
        {
            FreeMemory(Globals.GlobalConfig);
        }

        Globals.GlobalConfig = GlobalConfig;

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    return Status;
}

DWORD
WINAPI
QosmGetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    )

/*++
  
Routine Description:

    Gets the inteface config info for this protocol
    for this interface.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation

--*/

{
    PIPQOS_IF_CONFIG InterfaceConfig;
    DWORD            Status;

    //
    // Validate all input params before reading interface info
    //

    if (BufferSize == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_INTERFACE_READ_LOCK(Interface);

    do
    {
        *InfoSize = Interface->ConfigSize;

        if ((*BufferSize < *InfoSize) || 
            (InterfaceInfo == NULL))
        {
            //
            // Either the size was too small or there was no storage
            //

            Trace1(CONFIG, 
                   "GetInterfaceInfo: Buffer size too small: %u",
                   *BufferSize);

            *BufferSize = *InfoSize;

            Status = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        *BufferSize = *InfoSize;

        InterfaceConfig = (PIPQOS_IF_CONFIG) InterfaceInfo;

        CopyMemory(InterfaceConfig,
                   Interface->InterfaceConfig,
                   *InfoSize);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_INTERFACE_READ_LOCK(Interface);

    return Status;
}

DWORD
WINAPI
QosmSetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoSize
    )

/*++
  
Routine Description:

    Sets the interface config info for this protocol
    on this interface.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_IF_CONFIG     InterfaceConfig;
    PIPQOS_IF_FLOW       FlowConfig;
    PQOSMGR_FLOW_ENTRY   Flow;
    UINT                 i;
    PLIST_ENTRY          p, q;
    PTC_GEN_FLOW         FlowInfo;
    ULONG                FlowSize;
    HANDLE               FlowHandle;
    DWORD                Status;

    //
    // Update the interface config information.
    //

    ACQUIRE_INTERFACE_WRITE_LOCK(Interface);

    do
    {
        //
        // Allocate memory to store new config
        //

        InterfaceConfig = AllocMemory(InfoSize);

        if (InterfaceConfig == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Copy the new config information
        //

        CopyMemory(InterfaceConfig, InterfaceInfo, InfoSize);

        Interface->ConfigSize = InfoSize;

        //
        // Set up rest of interface state
        //

        if (Interface->State != InterfaceConfig->QosState)
        {
            if (InterfaceConfig->QosState == IPQOS_STATE_DISABLED)
            {
                //
                // Disable all flows on this interface
                //

                ;
            }
            else
            {
                //
                // Renable all flows on this interface
                //

                ;
            }

            Interface->State = InterfaceConfig->QosState;
        }

        //
        // Update the flow information on if
        //

        //
        // First mark all flows as needing refresh
        //

        for (p = Interface->FlowList.Flink;
             p != &Interface->FlowList;
             p = p->Flink)
        {
            Flow = CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

            ASSERT(!(Flow->Flags & FLOW_FLAG_DELETE));

            Flow->Flags |= FLOW_FLAG_DELETE;
        }

        //
        // If we do not have an TC interface handle,
        // we delete all flows as they are obsolete
        //

        if (Interface->TciIfHandle)
        {
            //
            // Set each flow if it has changed from before
            //

            FlowConfig = IPQOS_GET_FIRST_FLOW_ON_IF(InterfaceConfig);

            for (i = 0; i < InterfaceConfig->NumFlows; i++)
            {
                //
                // Search for a flow with the same name
                //

                for (p = Interface->FlowList.Flink;
                     p != &Interface->FlowList;
                     p = p->Flink)
                {
                    Flow = 
                        CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

                    if (!_wcsicmp(Flow->FlowName, FlowConfig->FlowName))
                    {
                        break;
                    }
                }

                if (p == &Interface->FlowList)
                {
                    //
                    // No flow by this name - add new one
                    //

                    Flow = NULL;
                }

                //
                // Get a flow info from description
                //

                Status = GetFlowFromDescription(&FlowConfig->FlowDesc, 
                                                &FlowInfo, 
                                                &FlowSize);

                if (Status == NO_ERROR)
                {
                    do
                    {
                        if ((Flow) && 
                            (FlowSize == Flow->FlowSize) &&
                            (EqualMemory(FlowInfo, Flow->FlowInfo, FlowSize)))
                        {
                            //
                            // No change in the flow info yet,
                            // this flow still remains valid
                            //

                            Flow->Flags &= ~FLOW_FLAG_DELETE;

                            Status = ERROR_ALREADY_EXISTS;

                            break;
                        }

                        if (Flow)
                        {
                            //
                            // Flow info changed - modify flow
                            //

                            Status = TcModifyFlow(Flow->TciFlowHandle,
                                                  FlowInfo);

                            if (Status != NO_ERROR)
                            {
                                break;
                            }

                            Flow->Flags &= ~FLOW_FLAG_DELETE;

                            //
                            // Update cached flow info
                            //

                            FreeMemory(Flow->FlowInfo);
                            Flow->FlowInfo = FlowInfo;
                            Flow->FlowSize = FlowSize;
                        }
                        else
                        {
                            //
                            // Add the new flow using the TC API
                            //

                            Status = TcAddFlow(Interface->TciIfHandle,
                                               NULL,
                                               0,
                                               FlowInfo,
                                               &FlowHandle);

                            if (Status != NO_ERROR)
                            {
                                break;
                            }

                            //
                            // Addition of a new flow in TC
                            //

                            Flow = AllocMemory(sizeof(QOSMGR_FLOW_ENTRY));

                            if (Flow == NULL)
                            {
                                Status = TcDeleteFlow(FlowHandle);

                                ASSERT(Status);

                                Status = ERROR_NOT_ENOUGH_MEMORY;

                                break;
                            }

                            //
                            // Initialize flow and insert in list
                            //

                            Flow->TciFlowHandle = FlowHandle;

                            Flow->Flags = 0;

                            Flow->FlowInfo = FlowInfo;
                            Flow->FlowSize = FlowSize;

                            wcscpy(Flow->FlowName, FlowConfig->FlowName);

                            InsertTailList(p, &Flow->OnInterfaceLE);
                        }
                    }
                    while (FALSE);
                    
                    if (Status != NO_ERROR)
                    {
                        FreeMemory(FlowInfo);
                    }
                }

                //
                // Move to the next flow in config
                //

                FlowConfig = IPQOS_GET_NEXT_FLOW_ON_IF(FlowConfig);
            }
        }

        //
        // Cleanup all flows that are obsolete
        //

        for (p = Interface->FlowList.Flink;
             p != &Interface->FlowList; 
             p = q)
        {
            Flow = CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

            q = p->Flink;

            if (Flow->Flags & FLOW_FLAG_DELETE)
            {
                //
                // Delete the flow from the TC API
                //

                Status = TcDeleteFlow(Flow->TciFlowHandle);

                if (Status != NO_ERROR)
                {
                    Flow->Flags &= ~FLOW_FLAG_DELETE;

                    continue;
                }

                //
                // Remove flow from this flow list
                //

                RemoveEntryList(p);

                //
                // Free the flow and its resources
                //

                if (Flow->FlowInfo)
                {
                    FreeMemory(Flow->FlowInfo);
                }

                FreeMemory(Flow);
            }
        }

        //
        // Cleanup old interface information
        //

        if (Interface->InterfaceConfig)
        {
            FreeMemory(Interface->InterfaceConfig);
        }

        Interface->InterfaceConfig = InterfaceConfig;

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_INTERFACE_WRITE_LOCK(Interface);

    return Status;
}


DWORD
GetFlowFromDescription(
    IN      PIPQOS_NAMED_FLOW              FlowDesc,
    OUT     PTC_GEN_FLOW                  *FlowInfo,
    OUT     ULONG                         *FlowSize
    )
{    
    FLOWSPEC       *CurrFlowspec;
    FLOWSPEC        SendFlowspec;
    FLOWSPEC        RecvFlowspec;
    FLOWSPEC       *Flowspec;
    PTC_GEN_FLOW    Flow;
    QOS_OBJECT_HDR *QosObject;
    PWCHAR          FlowspecName;
    PWCHAR          QosObjectName;
    PUCHAR          CopyAtPtr;
    ULONG           ObjectsLength;
    ULONG           i;

#if 1
    //
    // Check for the existence of sending flowspec
    //

    if (FlowDesc->SendingFlowspecName[0] == L'\0')
    {
        return ERROR_INVALID_DATA;
    }
#endif

    //
    // Get the sending and receiving flowspecs
    //

    for (i = 0; i < 2; i++)
    {
        if (i)
        {
            FlowspecName = FlowDesc->RecvingFlowspecName;
            CurrFlowspec = &RecvFlowspec;
        }
        else
        {
            FlowspecName = FlowDesc->SendingFlowspecName;
            CurrFlowspec = &SendFlowspec;
        }

        FillMemory(CurrFlowspec, sizeof(FLOWSPEC), QOS_NOT_SPECIFIED);

        if (FlowspecName[0] != L'\0')
        {
            Flowspec = GetFlowspecFromGlobalConfig(FlowspecName);

            if (Flowspec == NULL)
            {
                return ERROR_INVALID_DATA;
            }

            *CurrFlowspec = *Flowspec;
        }
    }

    //
    // Calculate the size of the TC_GEN_FLOW block
    //

    QosObjectName = IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc);

    ObjectsLength = 0;

    for (i = 0; i < FlowDesc->NumTcObjects; i++)
    {
        //
        // Get object's description in global info
        //

        QosObject = GetQosObjectFromGlobalConfig(QosObjectName);

        if (QosObject == NULL)
        {
            //
            // Incomplete description
            //

            return ERROR_INVALID_DATA;
        }

        ObjectsLength += QosObject->ObjectLength;

        QosObjectName= IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(QosObjectName);
    }

    *FlowSize = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + ObjectsLength;

    *FlowInfo = Flow = AllocMemory(*FlowSize);

    if (Flow == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill in the flow information now
    //

    Flow->ReceivingFlowspec = RecvFlowspec;

    Flow->SendingFlowspec = SendFlowspec;

    Flow->TcObjectsLength = ObjectsLength;

    //
    // Repeat the loop above filling info
    //

    QosObjectName = IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc);

    CopyAtPtr = (PUCHAR) &Flow->TcObjects[0];

    for (i = 0; i < FlowDesc->NumTcObjects; i++)
    {
        //
        // Get object's description in global info
        //

        QosObject = GetQosObjectFromGlobalConfig(QosObjectName);

        // We just checked above for its existence
        ASSERT(QosObject != NULL);

        CopyMemory(CopyAtPtr,
                   QosObject, 
                   QosObject->ObjectLength);

        CopyAtPtr += QosObject->ObjectLength;

        QosObjectName= IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(QosObjectName);
    }

     return NO_ERROR;
}

FLOWSPEC *
GetFlowspecFromGlobalConfig(
    IN      PWCHAR                         FlowspecName
    )
{
    IPQOS_NAMED_FLOWSPEC *Flowspec;
    UINT                  i;

    Flowspec = IPQOS_GET_FIRST_FLOWSPEC_IN_CONFIG(Globals.GlobalConfig);

    for (i = 0; i < Globals.GlobalConfig->NumFlowspecs; i++)
    {
        if (!_wcsicmp(Flowspec->FlowspecName, FlowspecName))
        {
            break;
        }

        Flowspec = IPQOS_GET_NEXT_FLOWSPEC_IN_CONFIG(Flowspec);
    }

    if (i < Globals.GlobalConfig->NumFlowspecs)
    {
        return &Flowspec->FlowspecDesc;
    }

    return NULL;
}

QOS_OBJECT_HDR *
GetQosObjectFromGlobalConfig(
    IN      PWCHAR                         QosObjectName
    )
{
    IPQOS_NAMED_QOSOBJECT *QosObject;
    UINT                   i;

    QosObject = IPQOS_GET_FIRST_QOSOBJECT_IN_CONFIG(Globals.GlobalConfig);

    for (i = 0; i < Globals.GlobalConfig->NumQosObjects; i++)
    {
        if (!_wcsicmp(QosObject->QosObjectName, QosObjectName))
        {
            break;
        }

        QosObject = IPQOS_GET_NEXT_QOSOBJECT_IN_CONFIG(QosObject);
    }

    if (i < Globals.GlobalConfig->NumFlowspecs)
    {
        return &QosObject->QosObjectHdr;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmain.c ===
/*++

Copyright 1997 - 98, Microsoft Corporation

Module Name:

    qosmmain.c

Abstract:

    Contains routines that are invoked when
    the QosMgr DLL is loaded or unloaded.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

// All Global variables
QOSMGR_GLOBALS  Globals;

BOOL
WINAPI
DllMain(
    IN      HINSTANCE                       Instance,
    IN      DWORD                           Reason,
    IN      PVOID                           Unused
    )

/*++

Routine Description:

    This is the DLL's main entrypoint handler which
    initializes the Qos Mgr component. 
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    static BOOL QosmInitialized = FALSE;

    UNREFERENCED_PARAMETER(Unused);

    switch(Reason) 
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(Instance);

        //
        // Initialize the Qos Mgr Component
        //

        QosmInitialized = QosmDllStartup();

        return QosmInitialized;

    case DLL_PROCESS_DETACH:

        //
        // Cleanup the Qos Mgr Component
        //

        if (QosmInitialized)
        {
            QosmDllCleanup();
        }
    }

    return TRUE;
}


BOOL
QosmDllStartup(
    VOID
    )

/*++

Routine Description:

    Initializes all global data structures in Qos Mgr.
    Called by DLL Main when the process is attached.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    TCI_CLIENT_FUNC_LIST TcHandlers;    
    BOOL                 ListLockInited;
    DWORD                Status;
    UINT                 i;

    ListLockInited = FALSE;

    do
    {
        ZeroMemory(&Globals, sizeof(QOSMGR_GLOBALS));

        // Globals.State = IPQOSMRG_STATE_STOPPED;

        //
        // Enable logging and tracing for debugging purposes
        //
  
        START_TRACING();
        START_LOGGING();

#if DBG_TRACE
        Globals.TracingFlags = QOSM_TRACE_ANY;
#endif

        //
        // Create a private heap for Qos Mgr's use
        //

        Globals.GlobalHeap = HeapCreate(0, 0, 0);
  
        if (Globals.GlobalHeap == NULL)
        {
            Status = GetLastError();

            Trace1(ANY, 
                   "QosmDllStartup: Failed to create a global private heap %x",
                   Status);

            LOGERR0(HEAP_CREATE_FAILED, Status);
            
            break;
        }

        //
        // Initialize lock to guard global list of interfaces
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Globals.GlobalsLock);

            ListLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
          
                Trace1(ANY, 
                       "QosmDllStartup : Failed to create read/write lock %x",
                       Status);
      
                LOGERR0(CREATE_RWL_FAILED, Status);

                break;
            }
        
        //
        // Initialize global list and table of active interfaces
        //

        Globals.NumIfs = 0;

        InitializeListHead(&Globals.IfList);

        //
        // Register with the traffic control API to control QOS
        //

        ZeroMemory(&TcHandlers, sizeof(TCI_CLIENT_FUNC_LIST));

        TcHandlers.ClNotifyHandler = TcNotifyHandler;

        Status = TcRegisterClient(CURRENT_TCI_VERSION,
                                  NULL,
                                  &TcHandlers,
                                  &Globals.TciHandle);

        if (Status != NO_ERROR)
        {
            Trace1(ANY, 
                   "QosmDllStartup: Failed to register with the TC API %x",
                   Status);

            LOGERR0(TC_REGISTER_FAILED, Status);
            
            break;
        }

        Globals.State = IPQOSMGR_STATE_STARTING;

        return TRUE;

    }
    while (FALSE);

    //
    // Some error occured - clean up and return the error code
    //

    if (ListLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Globals.GlobalsLock);
    }

    if (Globals.GlobalHeap != NULL)
    {
        HeapDestroy(Globals.GlobalHeap);
    }

    STOP_LOGGING();
    STOP_TRACING();

    return FALSE;
}


BOOL
QosmDllCleanup(
    VOID
    )

/*++

Routine Description:

    Cleans up all global data structures at unload time.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    DWORD   Status;

    // We should have freed all ifs to avoid any leaks
    ASSERT(Globals.NumIfs == 0);

    //
    // Cleanup and deregister with traffic control API
    //

    Status = TcDeregisterClient(Globals.TciHandle);

    if (Status != NO_ERROR)
    {
        Trace1(ANY, 
               "QosmDllCleanup: Failed to deregister with the TC API %x",
               Status);

        LOGERR0(TC_DEREGISTER_FAILED, Status);
    }

    //
    // Free resources allocated like locks and memory
    //

    DELETE_READ_WRITE_LOCK(&Globals.GlobalsLock);

    //
    // Cleanup the heap and memory allocated in it
    //

    HeapDestroy(Globals.GlobalHeap);

    //
    // Stop debugging aids like tracing and logging
    //

    STOP_LOGGING();
    STOP_TRACING();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmain.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmmain.h

Abstract:

    The file contains the global structure
    definitions for QOS Mgr protocol.

Revision History:

--*/

#ifndef __QOSMMAIN_H
#define __QOSMMAIN_H

//
// Global information for the QOS Mgr
//

#define IF_HASHTABLE_SIZE          16

typedef struct _QOSMGR_GLOBALS
{
    HANDLE            LoggingHandle;    // 
    ULONG             LoggingLevel;     // Handles to debugging functionality
    ULONG             TracingHandle;    //

    DWORD             TracingFlags;     // Flags that control debug tracing

    HANDLE            GlobalHeap;       // Handle to the private memory heap

                                        //
    HANDLE             NotificationEvnt;// Callbacks and events to interact 
    SUPPORT_FUNCTIONS  SupportFunctions;// with the router manager (See API)
                                        //

    READ_WRITE_LOCK   GlobalsLock;      // Lock protecting all the info below

    ULONG             ConfigSize;       // Number of bytes in global config

    PIPQOS_GLOBAL_CONFIG
                      GlobalConfig;     // Pointer to global configuration

    IPQOS_GLOBAL_STATS
                      GlobalStats;      // Global statistics

    ULONG             State;            // State of the QOS Mgr component

    HANDLE            TciHandle;        // Traffic Control Registration Handle

    ULONG             NumIfs;           // Num of Ifs on which QOS is active
    LIST_ENTRY        IfList;           // List of Ifs sorted by index    
}
QOSMGR_GLOBALS, *PQOSMGR_GLOBALS;


//
// Codes describing states of IPQOSMGR.
//

#define IPQOSMGR_STATE_STOPPED   0
#define IPQOSMGR_STATE_STARTING  1
#define IPQOSMGR_STATE_RUNNING   2
#define IPQOSMGR_STATE_STOPPING  3


//
// Per Interface Information for QOS Mgr
//
typedef struct _QOSMGR_INTERFACE_ENTRY
{
    LIST_ENTRY        ListByIndexLE;    // Linkage into index sorted list

    DWORD             InterfaceIndex;   // Interface index for this entry

    WCHAR             InterfaceName[MAX_STRING_LENGTH];
                                        // Router name for the interface

    READ_WRITE_LOCK   InterfaceLock;    // Lock protecting all info below

    DWORD             Flags;            // ACTIVE, MULTIACCESS ...

    DWORD             State;            // QOS Enabled or Disabled

    ULONG             ConfigSize;       // Num of bytes in interface config

    PIPQOS_IF_CONFIG  InterfaceConfig;  // Interface configuration

    IPQOS_IF_STATS    InterfaceStats;   // Interface statistics    

    HANDLE            TciIfHandle;      // Handle to corr. TC interface

    WCHAR             AlternateName[MAX_STRING_LENGTH];
                                        // Traffic Control name for 'if'

    ULONG             NumFlows;         // Number of flows configured on 'if'
    LIST_ENTRY        FlowList;         // List of configured flows on 'if'
} 
QOSMGR_INTERFACE_ENTRY, *PQOSMGR_INTERFACE_ENTRY;

#define IF_FLAG_ACTIVE      ((DWORD)0x00000001)
#define IF_FLAG_MULTIACCESS ((DWORD)0x00000002)

#define INTERFACE_IS_ACTIVE(i)              \
            ((i)->Flags & IF_FLAG_ACTIVE) 

#define INTERFACE_IS_INACTIVE(i)            \
            !INTERFACE_IS_ACTIVE(i)

#define INTERFACE_IS_MULTIACCESS(i)         \
            ((i)->Flags & IF_FLAG_MULTIACCESS) 

#define INTERFACE_IS_POINTTOPOINT(i)        \
            !INTERFACE_IS_MULTIACCESS(i)


//
// Per Flow Information in QOS Mgr
//

typedef struct _QOSMGR_FLOW_ENTRY
{
    LIST_ENTRY        OnInterfaceLE;    // Linkage into index sorted list

    HANDLE            TciFlowHandle;    // Handle to the flow in TC API

    DWORD             Flags;            // Flags for certain flow properties

    ULONG             FlowSize;         // Size of the flow's information
    PTC_GEN_FLOW      FlowInfo;         // Flow information - flowspecs etc.

    WCHAR             FlowName[MAX_STRING_LENGTH];
                                        // Router name for the diffserv flow
}
QOSMGR_FLOW_ENTRY, *PQOSMGR_FLOW_ENTRY;

#define FLOW_FLAG_DELETE ((DWORD)0x00000001)

//
// Global Extern Declarations
//
extern QOSMGR_GLOBALS Globals;


//
// Macros used in allocating and operating on memory
//
#define ZeroMemory             RtlZeroMemory
#define CopyMemory             RtlCopyMemory
#define FillMemory             RtlFillMemory
#define EqualMemory            RtlEqualMemory

#define AllocOnStack(nb)       _alloca((nb))

#define AllocMemory(nb)        HeapAlloc(Globals.GlobalHeap,     \
                                         0,                      \
                                         (nb))

#define ReallocMemory(nb)      HeapReAlloc(Globals.GlobalHeap,   \
                                         0,                      \
                                         (nb))

#define AllocNZeroMemory(nb)   HeapAlloc(Globals.GlobalHeap,     \
                                         HEAP_ZERO_MEMORY,       \
                                         (nb))

#define FreeMemory(ptr)        HeapFree(Globals.GlobalHeap,      \
                                        0,                       \
                                        (ptr))

#define FreeNotNullMemory(ptr)  {                                \
                                  if (!(ptr)) FreeMemory((ptr)); \
                                }
//
// Prototypes relating to global lock management
//

#define ACQUIRE_GLOBALS_READ_LOCK()                              \
    ACQUIRE_READ_LOCK(&Globals.GlobalsLock)

#define RELEASE_GLOBALS_READ_LOCK()                              \
    RELEASE_READ_LOCK(&Globals.GlobalsLock)

#define ACQUIRE_GLOBALS_WRITE_LOCK()                             \
    ACQUIRE_WRITE_LOCK(&Globals.GlobalsLock)

#define RELEASE_GLOBALS_WRITE_LOCK()                             \
    RELEASE_WRITE_LOCK(&Globals.GlobalsLock)

//
// Prototypes relating to interface lock management
//

#define ACQUIRE_INTERFACE_READ_LOCK(Interface)                   \
    ACQUIRE_READ_LOCK(&Interface->InterfaceLock)

#define RELEASE_INTERFACE_READ_LOCK(Interface)                   \
    RELEASE_READ_LOCK(&Interface->InterfaceLock)

#define ACQUIRE_INTERFACE_WRITE_LOCK(Interface)                  \
    ACQUIRE_WRITE_LOCK(&Interface->InterfaceLock)

#define RELEASE_INTERFACE_WRITE_LOCK(Interface)                  \
    RELEASE_WRITE_LOCK(&Interface->InterfaceLock)

//
// Prototypes relating to DLL startup, cleanup
//

BOOL
QosmDllStartup(
    VOID
    );

BOOL
QosmDllCleanup(
    VOID
    );


//
// Prototypes for router manager interface
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT  PMPR_ROUTING_CHARACTERISTICS    RoutingChar,
    IN OUT  PMPR_SERVICE_CHARACTERISTICS    ServiceChar
    );

DWORD
WINAPI
StartProtocol (
    IN      HANDLE                          NotificationEvent,
    IN      PSUPPORT_FUNCTIONS              SupportFunctions,
    IN      LPVOID                          GlobalInfo,
    IN      ULONG                           StructureVersion,
    IN      ULONG                           StructureSize,
    IN      ULONG                           StructureCount
    );

DWORD
WINAPI
StartComplete (
    VOID
    );

DWORD
WINAPI
StopProtocol (
    VOID
    );

DWORD
WINAPI
GetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN OUT  PULONG                          BufferSize,
    OUT     PULONG                          StructureVersion,
    OUT     PULONG                          StructureSize,
    OUT     PULONG                          StructureCount
    );

DWORD
WINAPI
SetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN      ULONG                           StructureVersion,
    IN      ULONG                           StructureSize,
    IN      ULONG                           StructureCount
    );

DWORD
WINAPI
AddInterface (
    IN      LPWSTR                         InterfaceName,
    IN      ULONG                          InterfaceIndex,
    IN      NET_INTERFACE_TYPE             InterfaceType,
    IN      DWORD                          MediaType,
    IN      WORD                           AccessType,
    IN      WORD                           ConnectionType,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          StructureVersion,
    IN      ULONG                          StructureSize,
    IN      ULONG                          StructureCount
    );

DWORD
WINAPI
DeleteInterface (
    IN      ULONG                          InterfaceIndex
    );

DWORD
WINAPI
InterfaceStatus (
    IN      ULONG                          InterfaceIndex,
    IN      BOOL                           InterfaceActive,
    IN      DWORD                          StatusType,
    IN      PVOID                          StatusInfo
    );

DWORD
WINAPI
GetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN  OUT PULONG                         BufferSize,
    OUT     PULONG                         StructureVersion,
    OUT     PULONG                         StructureSize,
    OUT     PULONG                         StructureCount
    );

DWORD
WINAPI
SetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          StructureVersion,
    IN      ULONG                          StructureSize,
    IN      ULONG                          StructureCount
    );

DWORD
WINAPI
GetEventMessage (
    OUT     ROUTING_PROTOCOL_EVENTS        *Event,
    OUT     MESSAGE                        *Result
    );

DWORD
WINAPI
UpdateRoutes (
    IN      ULONG                          InterfaceIndex
    );

DWORD
WINAPI
MibCreateEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibDeleteEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibGetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData,
    OUT     PULONG                         OutputDataSize,
    OUT     PVOID                          OutputData
    );

DWORD
WINAPI
MibSetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibGetFirstEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibGetNextEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibSetTrapInfo (
    IN     HANDLE                          Event,
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibGetTrapInfo (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

//
// Helper functions to operate on info blocks
//

DWORD
WINAPI
QosmGetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    );

DWORD
WINAPI
QosmSetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN      ULONG                          InfoSize
    );

DWORD
WINAPI
QosmGetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    );

DWORD
WINAPI
QosmSetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoSize
    );

//
// Prototypes relating to TC functionality
//

VOID 
TcNotifyHandler(
    IN      HANDLE                         ClRegCtx,
    IN      HANDLE                         ClIfcCtx,
    IN      ULONG                          Event,
    IN      HANDLE                         SubCode,
    IN      ULONG                          BufSize,
    IN      PVOID                          Buffer
    );

DWORD
QosmOpenTcInterface(
    IN      PQOSMGR_INTERFACE_ENTRY        Interface
    );

DWORD
GetFlowFromDescription(
    IN      PIPQOS_NAMED_FLOW              FlowDesc,
    OUT     PTC_GEN_FLOW                  *FlowInfo,
    OUT     ULONG                         *FlowSize
    );

FLOWSPEC *
GetFlowspecFromGlobalConfig(
    IN      PWCHAR                         FlowspecName
    );

QOS_OBJECT_HDR *
GetQosObjectFromGlobalConfig(
    IN      PWCHAR                         QosObjectName
    );

#endif // __QOSMMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmtest.cxx ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmtest.cxx

Abstract:

    The file contains code to test the
    QOS Mgr protocol.

Revision History:

--*/

#include "qosmtest.h"

int 
_cdecl
main()
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmtest.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmtest.h

Abstract:

    The file contains declarations for testing
    QOS Mgr functionality.

Revision History:

--*/

#ifndef __QOSMTEST_H_
#define __QOSMTEST_H_

#include <windows.h>

#include <stdio.h>
#include <wchar.h>

#endif // __QOSMTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmsg.h ===
//
// Net error file for basename QOSMLOG_BASE = 43000
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: QOSMLOG_INIT_CRITSEC_FAILED
//
// MessageText:
//
//  QOSMGR was unable to initialize a critical section.
//  The data is the exception code.
//
#define QOSMLOG_INIT_CRITSEC_FAILED      0x0000A7F9L

//
// MessageId: QOSMLOG_CREATE_SEMAPHORE_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a semaphore.
//  The data is the error code.
//
#define QOSMLOG_CREATE_SEMAPHORE_FAILED  0x0000A7FAL

//
// MessageId: QOSMLOG_CREATE_EVENT_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create an event.
//  The data is the error code.
//
#define QOSMLOG_CREATE_EVENT_FAILED      0x0000A7FBL

//
// MessageId: QOSMLOG_CREATE_RWL_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a synchronization object.
//  The data is the error code.
//
#define QOSMLOG_CREATE_RWL_FAILED        0x0000A7FCL

//
// MessageId: QOSMLOG_HEAP_CREATE_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a heap.
//  The data is the error code.
//
#define QOSMLOG_HEAP_CREATE_FAILED       0x0000A7FDL

//
// MessageId: QOSMLOG_HEAP_ALLOC_FAILED
//
// MessageText:
//
//  QOSMGR was unable to allocate memory from its heap.
//  The data is the error code.
//
#define QOSMLOG_HEAP_ALLOC_FAILED        0x0000A7FEL

//
// MessageId: QOSMLOG_CREATE_THREAD_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a thread.
//  The data is the error code.
//
#define QOSMLOG_CREATE_THREAD_FAILED     0x0000A7FFL

//
// MessageId: QOSMLOG_WSASTARTUP_FAILED
//
// MessageText:
//
//  QOSMGR was unable to start Windows Sockets.
//  The data is the error code.
//
#define QOSMLOG_WSASTARTUP_FAILED        0x0000A800L

//
// MessageId: QOSMLOG_CREATE_SOCKET_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a socket.
//  The data is the error code.
//
#define QOSMLOG_CREATE_SOCKET_FAILED     0x0000A801L

//
// MessageId: QOSMLOG_BIND_IF_FAILED
//
// MessageText:
//
//  QOSMGR could not bind to IP address %1.
//  Please make sure TCP/IP is installed and configured correctly.
//  The data is the error code.
//
#define QOSMLOG_BIND_IF_FAILED           0x0000A802L

//
// MessageId: QOSMLOG_RECVFROM_FAILED
//
// MessageText:
//
//  QOSMGR was unable to receive an incoming message
//  on the local interface with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_RECVFROM_FAILED          0x0000A803L

//
// MessageId: QOSMLOG_SENDTO_FAILED
//
// MessageText:
//
//  QOSMGR was unable to send a packet from the interface with IP address %1
//  to the IP address %2.
//  The data is the error code.
//
#define QOSMLOG_SENDTO_FAILED            0x0000A804L

//
// MessageId: QOSMLOG_SET_MCAST_IF_FAILED
//
// MessageText:
//
//  QOSMGR could not request multicasting on the local interface
//  with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_SET_MCAST_IF_FAILED      0x0000A805L

//
// MessageId: QOSMLOG_JOIN_GROUP_FAILED
//
// MessageText:
//
//  QOSMGR could not join the multicast group 224.0.0.9
//  on the local interface with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_JOIN_GROUP_FAILED        0x0000A806L

//
// MessageId: QOSMLOG_QOSMGR_STARTED
//
// MessageText:
//
//  QOSMGR has started successfully.
//
#define QOSMLOG_QOSMGR_STARTED           0x0000A807L

//
// MessageId: QOSMLOG_QOSMGR_ALREADY_STARTED
//
// MessageText:
//
//  QOSMGR received a start request when it was already running.
//
#define QOSMLOG_QOSMGR_ALREADY_STARTED   0x0000A808L

//
// MessageId: QOSMLOG_RTM_REGISTER_FAILED
//
// MessageText:
//
//  IPRIPv2 was unable to register with the Routing Table Manager.
//  The data is the error code.
//
#define QOSMLOG_RTM_REGISTER_FAILED      0x0000A809L

//
// MessageId: QOSMLOG_QOSMGR_STOPPED
//
// MessageText:
//
//  QOSMGR has stopped.
//
#define QOSMLOG_QOSMGR_STOPPED           0x0000A80AL

//
// MessageId: QOSMLOG_NETWORK_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Network Module.
//  The data is the error code.
//
#define QOSMLOG_NETWORK_MODULE_ERROR     0x0000A80BL

//
// MessageId: QOSMLOG_PACKET_TOO_SMALL
//
// MessageText:
//
//  QOSMGR received a packet which was smaller than the minimum size
//  allowed for QOSMGR packets. The packet has been discarded.
//  It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define QOSMLOG_PACKET_TOO_SMALL         0x0000A80CL

//
// MessageId: QOSMLOG_PACKET_HEADER_CORRUPT
//
// MessageText:
//
//  QOSMGR received a packet with an invalid header. The packet has been
//  discarded. It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define QOSMLOG_PACKET_HEADER_CORRUPT    0x0000A80DL

//
// MessageId: QOSMLOG_PACKET_VERSION_INVALID
//
// MessageText:
//
//  QOSMGR received a packet with an invalid version in its header.
//  The packet has been discarded. It was received on the local interface
//  with IP address %1, and it came from the neighboring router
//  with IP address %2.
//
#define QOSMLOG_PACKET_VERSION_INVALID   0x0000A80EL

//
// MessageId: QOSMLOG_TIMER_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Timer Module.
//  The data is the error code.
//
#define QOSMLOG_TIMER_MODULE_ERROR       0x0000A80FL

//
// MessageId: QOSMLOG_PROTOCOL_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Protocol Module.
//  The data is the error code.
//
#define QOSMLOG_PROTOCOL_MODULE_ERROR    0x0000A810L

//
// MessageId: QOSMLOG_TC_REGISTER_FAILED
//
// MessageText:
//
//  QOSMGR could not register with the traffic control API.
//  The data is the error code.
//
#define QOSMLOG_TC_REGISTER_FAILED       0x0000A811L

//
// MessageId: QOSMLOG_TC_DEREGISTER_FAILED
//
// MessageText:
//
//  QOSMGR could not deregister with the traffic control API.
//  The data is the error code.
//
#define QOSMLOG_TC_DEREGISTER_FAILED     0x0000A812L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

      PerfUtil.h

Abstract:

    Header file for performance utility functions

--*/

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// Definitions for utility functions
#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// Delcare prototypes for utility functions
void convertIndices(BYTE *, int, DWORD, DWORD);
DWORD GetQueryType(IN LPWSTR);
BOOL IsNumberInUnicodeList(DWORD, LPWSTR);
VOID CorrectInstanceName(PWCHAR);

#endif // _PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PerfUtil.c

Abstract:

    This file implements utility functions for performance monitoring functions

Author:

	Eliot Gillum (t-eliotg) - July 5, 1998

Revision History

--*/

#include <windows.h>
#include <winperf.h>
#include "PerfUtil.h"


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";
WCHAR NULL_STRING[] = L"\0";    // pointer to null string 


// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


// convertIndices() 
// Takes a pointer to an array of PERF_COUNTER_DEFINITIONs and converts their indices 
// to be absolute by adding the appropriate value (dwFirstCounter/dwFirstHelp)
//
// BYTE *buf				Pointer to an array of PERF_COUNTER_DEFINITIONs
// int numCounters          The number of PERF_COUNTER_DEFINITIONs to convert
// DWORD dwFirstCounter		Absolute index of the first counter in the series
// DWORD dwFirstHelp		Absolute index of the first help index in the series
void convertIndices(BYTE *buf, int numCounters, DWORD dwFirstCounter, DWORD dwFirstHelp)
{
	int i;

	// then the counter indices
	for (i=0; i<numCounters; i++) {
		((PERF_COUNTER_DEFINITION *)buf)->CounterNameTitleIndex += dwFirstCounter;
		((PERF_COUNTER_DEFINITION *)buf)->CounterHelpTitleIndex += dwFirstHelp;
		buf += sizeof(PERF_COUNTER_DEFINITION);
	}
}


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
       
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:
    TRUE:   dwNumber was found in the list of unicode number strings
    FALSE:  dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimiter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

VOID
CorrectInstanceName(PWCHAR IfcName)
{
    WCHAR  SpecialChars[] = L")(#\\/";
    int    k;
    int    r;
    WCHAR *p;

    //
    // perfmon does not allow the following characters in the name. We need to munge the name
    // and replace them with some other character.
    //
    for(r=0; SpecialChars[r]; r++) 
    {
        p = IfcName;
        while((p = wcschr(p, SpecialChars[r])))
        {
            *p = L'-';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h through the
// structure RTL_RESOURCE and several functions.  However, that
// implementation has the potential for starving a thread trying to acquire
// write accesss, if there are a large number of threads interested in
// acquiring read access.  Such a scenario is avoided in the implementation
// given in this header. However, a mapping is also given to the
// RTL_RESOURCE functionality, so that the protocol can be compiled to use
// either form
//

#ifdef USE_RWL

//
// use IPRIP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


#define ACQUIRE_READ_LOCK(pRWL)                                             \
    AcquireReadLock(pRWL)

#define RELEASE_READ_LOCK(pRWL)                                             \
    ReleaseReadLock(pRWL)

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
    AcquireWriteLock(pRWL)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
    ReleaseWriteLock(pRWL)

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
    (ReleaseReadLock(pRWL), AcquireWriteLock(pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (ReleaseWriteLock(pRWL), AcquireReadLock(pRWL))


#else // i.e. !USE_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // USE_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          LL_Head;
    CRITICAL_SECTION    LL_Lock;
    DWORD               LL_Created;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)                                             \
            InitializeListHead(&(pLL)->LL_Head);                            \
            InitializeCriticalSection(&(pLL)->LL_Lock);                     \
            (pLL)->LL_Created = 0x12345678

#define LOCKED_LIST_CREATED(pLL)                                            \
            ((pLL)->LL_Created == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                                \
            PLIST_ENTRY _ple;                                               \
            (pLL)->LL_Created = 0;                                          \
            DeleteCriticalSection(&(pLL)->LL_Lock);                         \
            while (!IsListEmpty(&(pLL)->LL_Head)) {                         \
                _ple = RemoveHeadList(&(pLL)->LL_Head);                     \
                FREE(CONTAINING_RECORD(_ple,type,field));                   \
            }                                                               \
        }

#define ACQUIRE_LIST_LOCK(pLL)                                              \
            EnterCriticalSection(&(pLL)->LL_Lock)

#define RELEASE_LIST_LOCK(pLL)                                              \
            LeaveCriticalSection(&(pLL)->LL_Lock)

#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\netshell\diffserv\qos-protocol\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    sync.c
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// Implementation of synchronization routines.
//============================================================================

#include "pchqosm.h"

#pragma hdrstop

#ifdef USE_RWL

//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}



//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0)
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0)
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
}



//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}

#endif // USE_RWL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\pschdprf.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PschdPrf.c

Abstract:

    This file implements the Extensible Objects for the PSched Flow and 
        Pipe object types.  In particular, it implements the three Open, 
        Collect, and Close functions called by PerfMon/SysMon.

Author:

    Eliot Gillum (t-eliotg)   June 14, 1998
    
Revision History
    Rajesh Sundaram : Reworked the code to work with flows/instances coming up and down.

--*/

// Useful macro


#define WRITEBUF(_addr, _len)           memcpy(pdwBuf,(_addr),(_len));      pdwBuf = (PULONG)((PUCHAR)pdwBuf + (_len));
#define MULTIPLE_OF_EIGHT(_x)  (((_x)+7) & ~7)


#include <windows.h>
#include <winerror.h>
#include <string.h>
#include <wtypes.h>
#include <ntprfctr.h>
#include <malloc.h>
#include <ntddndis.h>
#include <qos.h>
#include <ntddpsch.h>
#include <objbase.h>
#include "PschdPrf.h"
#include "PerfUtil.h"
#include "PschdCnt.h"
#include <rtutils.h>

// Psched Performance Key
#define PSCHED_PERF_KEY TEXT("SYSTEM\\CurrentControlSet\\Services\\PSched\\Performance")

HINSTANCE   ghInst;                 // module instance handle
DWORD       dwOpenCount = 0;        // count of "Open" threads
BOOL        bInitOK = FALSE;        // true = DLL initialized OK
HANDLE      ghTciClient;            // TCI client handle
HANDLE      ghClRegCtx;             // TCI Client Registration Context
PPIPE_INFO  gpPI;                   // Pipe and flow information array
ULONG       gTotalIfcNameSize;      // Number of bytes of all the interface names (incl. NULL term. char)
ULONG       gTotalFlowNameSize;     // Number of bytes of all the flow names (incl. NULL term. char)
ULONG       giIfcBufSize = 1024;    // set the initial buffer size to 1kb
DWORD       gPipeStatLen;           // Length of the buffer used to define all the 
                                    // Pipe statistics that will be reported by the 
                                    // underlying components
DWORD       gFlowStatLen;           // Length of the buffer used to define all the 
                                    // Flow statistics that will be reported by the
                                    // underlying components
CRITICAL_SECTION ghPipeFlowCriticalSection;

#if DBG
//
// For tracing support.
//

#define DBG_INFO  (0x00010000 | TRACE_USE_MASK)
#define DBG_ERROR (0x00020000 | TRACE_USE_MASK)

DWORD   gTraceID = INVALID_TRACEID;

#define Trace0(_mask, _str)     TracePrintfEx(gTraceID, _mask, _str)
#define Trace1(_mask, _str, _a) TracePrintfEx(gTraceID, _mask, _str, _a)

#else

#define Trace0(_mask, _str)
#define Trace1(_mask, _str, _a)

#endif

//  Function Prototypes
//
//      these are used to ensure that the data collection functions
//      accessed by Perflib will have the correct calling format.
PM_OPEN_PROC        OpenPschedPerformanceData;
PM_COLLECT_PROC     CollectPschedPerformanceData;
PM_CLOSE_PROC       ClosePschedPerformanceData;


// Declared in PschdDat.c
extern PERF_OBJECT_TYPE           PsPipeObjType;
extern PS_PIPE_PIPE_STAT_DEF      PsPipePipeStatDef;
extern PS_PIPE_CONFORMER_STAT_DEF PsPipeConformerStatDef;
extern PS_PIPE_SHAPER_STAT_DEF    PsPipeShaperStatDef;
extern PS_PIPE_SEQUENCER_STAT_DEF PsPipeSequencerStatDef;
extern PERF_OBJECT_TYPE           PsFlowObjType;
extern PS_FLOW_FLOW_STAT_DEF      PsFlowFlowStatDef;
extern PS_FLOW_CONFORMER_STAT_DEF PsFlowConformerStatDef;
extern PS_FLOW_SHAPER_STAT_DEF    PsFlowShaperStatDef;
extern PS_FLOW_SEQUENCER_STAT_DEF PsFlowSequencerStatDef;

void closePipeFlowInfo(PPIPE_INFO *ppPI);


BOOL
getFlowInfo(IN PPIPE_INFO pPI, IN ULONG flowCount)
{

    HANDLE                   hEnum;
    ULONG                    size;
    PVOID                    pFlowBuf;
    static ULONG             FlowBufSize=1024;
    ULONG                    j;
    ULONG                    BytesWritten;
    ULONG                    status;
    ULONG                    nameSize;

    // initialize the enumeration handle
    hEnum = NULL;
    
    for(j=0; j<pPI->numFlows; j++) 
    {
        size = ((wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR));
        gTotalFlowNameSize -= MULTIPLE_OF_EIGHT(size);
    }

    PsFlowObjType.NumInstances -= pPI->numFlows;
    PsFlowObjType.NumInstances += flowCount;
    pPI->numFlows = flowCount;

    if(pPI->pFlowInfo)
        free(pPI->pFlowInfo);

    if(flowCount)
    {
        pPI->pFlowInfo = (PFLOW_INFO) malloc(flowCount * sizeof(FLOW_INFO));

        //
        // We cannot allocate memory for the flow names. There is nothing much we can do here.
        // let's pretend as though there are no flows.
        //

        if(!pPI->pFlowInfo)
        {
           Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
           PsFlowObjType.NumInstances -= flowCount;
           pPI->numFlows = 0;
           return FALSE;
        }
        else
        {
            memset(pPI->pFlowInfo, 0, sizeof(FLOW_INFO) * flowCount);
        }

        // allocate the flow enumeration buffer
        pFlowBuf = malloc(FlowBufSize);

        if(!pFlowBuf)
        {
           Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
           free(pPI->pFlowInfo);
           pPI->pFlowInfo = NULL;
           PsFlowObjType.NumInstances -= flowCount;
           pPI->numFlows = 0;
           return FALSE;
        }
        
        // initialize the enumeration handle
        hEnum = NULL;
        
        // enumerate each flow and remember its name
        for (j=0; j<pPI->numFlows; j++) 
        {
            PENUMERATION_BUFFER pEnum;
            LPQOS_FRIENDLY_NAME pFriendly;
            ULONG               TcObjectLength, FriendlyNameFound;

		// If this is not the first time but the enumeration handle is NULL, bail with whatever we have so far
		if( (j > 0) && (!hEnum))
		{
		   free(pFlowBuf);
                PsFlowObjType.NumInstances -= flowCount;
                pPI->numFlows = j;
                return TRUE;
		}	

            // get the next flow
            BytesWritten = FlowBufSize;
            flowCount = 1;
            status = TcEnumerateFlows(pPI->hIfc, &hEnum, &flowCount, &BytesWritten, pFlowBuf);

            while (ERROR_INSUFFICIENT_BUFFER == status) 
            {
                free(pFlowBuf);
                FlowBufSize *= 2;
                BytesWritten = FlowBufSize;
                pFlowBuf = malloc(BytesWritten);
                if(!pFlowBuf)
                {
                   Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
                   free(pPI->pFlowInfo);
                   pPI->pFlowInfo = NULL;
                   PsFlowObjType.NumInstances -= flowCount;
                   pPI->numFlows = 0;
                   return FALSE;
                   
                }
                status = TcEnumerateFlows(pPI->hIfc, &hEnum, &flowCount, &BytesWritten, pFlowBuf);
            }

            if (    (NO_ERROR != status) 
                ||  (BytesWritten == 0) )
            {
                if ( status )
                    Trace1(DBG_ERROR, L"[getFlowInfo]: TcEnumerateFlows failed with 0x%x \n", status);
                else if ( BytesWritten == 0 )
                    Trace0(DBG_ERROR, L"[getFlowInfo]: TcEnumerateFlows returned 0 bytes \n");

                free(pFlowBuf);
                free(pPI->pFlowInfo);
                pPI->pFlowInfo = NULL;
                PsFlowObjType.NumInstances -= flowCount;
                pPI->numFlows = 0;
                return FALSE;
            }
            
            // save the flow's name
            pEnum = (PENUMERATION_BUFFER)pFlowBuf;
            FriendlyNameFound = 0;
            pFriendly = (LPQOS_FRIENDLY_NAME)pEnum->pFlow->TcObjects;
            TcObjectLength = pEnum->pFlow->TcObjectsLength;

            while(0)
            {
                if(pFriendly->ObjectHdr.ObjectType == QOS_OBJECT_FRIENDLY_NAME)
                {
                    // We found a friendly name. Lets use it.
                    memcpy(
                        pPI->pFlowInfo[j].FriendlyName, 
                        pFriendly->FriendlyName, 
                        PS_FRIENDLY_NAME_LENGTH *sizeof(WCHAR) );
                        
                    pPI->pFlowInfo[j].FriendlyName[PS_FRIENDLY_NAME_LENGTH] = L'\0';
                    nameSize = (wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR);
                    gTotalFlowNameSize += MULTIPLE_OF_EIGHT(nameSize);
                    FriendlyNameFound = 1;
                    break;
                }
                else {
                    // Move on to the next QoS object.
                    TcObjectLength -= pFriendly->ObjectHdr.ObjectLength;
                    pFriendly = (LPQOS_FRIENDLY_NAME)((PCHAR) pFriendly + pFriendly->ObjectHdr.ObjectLength);
                }
            }
            
            if(!FriendlyNameFound) 
            {
                //
                // If there is no friendly name, the Instance name becomes the friendly name.
                //
                memcpy(pPI->pFlowInfo[j].FriendlyName, 
                       ((PENUMERATION_BUFFER)pFlowBuf)->FlowName, 
                       PS_FRIENDLY_NAME_LENGTH * sizeof(WCHAR) );
                pPI->pFlowInfo[j].FriendlyName[PS_FRIENDLY_NAME_LENGTH] = L'\0';
                nameSize = (wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR);
                gTotalFlowNameSize += MULTIPLE_OF_EIGHT(nameSize);
            }

            //
            // We have to always store the instance name since we call TcQueryFlow with this name.
            //

            nameSize = (wcslen(((PENUMERATION_BUFFER)pFlowBuf)->FlowName) + 1) * sizeof(WCHAR);
            memcpy(pPI->pFlowInfo[j].InstanceName, ((PENUMERATION_BUFFER)pFlowBuf)->FlowName, nameSize);

        }
        
        free(pFlowBuf);
    }
    else 
    {
        pPI->pFlowInfo = NULL;
        Trace0(DBG_INFO, L"[getFlowInfo]: No flows to enumerate \n");
    }

    return TRUE;
}

// getPipeFlowInfo() initializes an array of PIPE_INFO structs to contain
// up-to-date information about the pipes available and the flows installed on them
//
// Parameters: ppPI - pointer to a pointer to an array of PIPE_INFO structs
// Return value:  TRUE if all info in *ppPI is valid, FALSE otherwise
BOOL getPipeFlowInfo(OUT        PPIPE_INFO      *ppPI)
{
    ULONG                    status;
    ULONG                    BytesWritten;
    ULONG                    i,j,k;
    PVOID                    pIfcDescBuf = NULL;
    PTC_IFC_DESCRIPTOR       currentIfc;
    PPIPE_INFO               pPI = NULL;
    HANDLE                   hEnum;
    PVOID                    pFlowBuf;
    static ULONG             FlowBufSize=1024;
    ULONG                    flowCount;
    ULONG                    nameSize;
    ULONG                    size;
    PPERF_COUNTER_DEFINITION pCntDef;

    PsPipeObjType.NumInstances=0;
    PsFlowObjType.NumInstances = 0;

    pIfcDescBuf = (PVOID)malloc(giIfcBufSize);

    if (NULL == pIfcDescBuf) 
    {
        Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
        return FALSE;
    }

    BytesWritten = giIfcBufSize;
    status = TcEnumerateInterfaces(ghTciClient, &BytesWritten, pIfcDescBuf);

    while (ERROR_INSUFFICIENT_BUFFER==status) 
    {
        free(pIfcDescBuf);
        giIfcBufSize *= 2;
        pIfcDescBuf = (PTC_IFC_DESCRIPTOR)malloc(giIfcBufSize);

        if (NULL == pIfcDescBuf)
        {
            Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
            return FALSE;
        }

        BytesWritten = giIfcBufSize;

        status = TcEnumerateInterfaces(ghTciClient, &BytesWritten, pIfcDescBuf);
    }

    if (NO_ERROR!=status) 
    {
        // If we're not going to be able to enumerate the interfaces, we have no alternatives

        Trace1(DBG_ERROR, L"[getPipeFlowInfo]: TcEnumerateInterfaces failed with 0x%x\n", status);
        free(pIfcDescBuf);
        return FALSE;
    }
    
    // Figure out the number of interfaces

    for (i=0; i<BytesWritten; i+=((PTC_IFC_DESCRIPTOR)((BYTE *)pIfcDescBuf+i))->Length)
    {
        PsPipeObjType.NumInstances++;
    }
    
    
    // Open each interface and remember the handle to it

    if (0 != PsPipeObjType.NumInstances) {

        // Allocate space for our structs

        *ppPI=(PPIPE_INFO)malloc(PsPipeObjType.NumInstances * sizeof(PIPE_INFO) );

        if (NULL == *ppPI) 
        {
            Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
            free(pIfcDescBuf);
            return FALSE;
        }
        else
        {
            memset(*ppPI, 0, sizeof(PIPE_INFO) * PsPipeObjType.NumInstances);
        }

        pPI = *ppPI;    // less typing, cleaner source code
        
        gTotalIfcNameSize = 0;

        gTotalFlowNameSize = 0;
        
        currentIfc = pIfcDescBuf;

        // Initialize struct information for each interface

        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) 
        {
            // remember the inteface's name

            nameSize = (wcslen(currentIfc->pInterfaceName) + 1) * sizeof(WCHAR);

            pPI[i].IfcName = malloc(nameSize);
            if (NULL == pPI[i].IfcName) 
            {
                Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
                goto Error;
            }
            wcscpy(pPI[i].IfcName, currentIfc->pInterfaceName);
            
            //
            // add this name size to gTotalIfcNameSize.
            //
            gTotalIfcNameSize += MULTIPLE_OF_EIGHT(nameSize);
           
            //
            // open the interface
            //
            status = TcOpenInterface(
                        pPI[i].IfcName, 
                        ghTciClient, 
                        &pPI[i], 
                        &pPI[i].hIfc);
            if (status != NO_ERROR) 
            {
                Trace1(DBG_ERROR, L"[getPipeFlowInfo]: TcOpenInterface failed with 0x%x\n", status);
                goto Error;
            }

            //
            // Enumerate the flows on the interface
            // find out how many flows to expect
            //

            pPI[i].numFlows   = 0;
            pPI[i].pFlowInfo = 0;
            status = TcQueryInterface(pPI[i].hIfc, 
                                      (LPGUID)&GUID_QOS_FLOW_COUNT, 
                                      TRUE, 
                                      &BytesWritten, 
                                      &flowCount);

            if (NO_ERROR != status) 
            {
                Trace1( DBG_ERROR, 
                        L"[getPipeFlowInfo]: TcQueryInterface failed with 0x%x, ignoring this error\n", 
                        status);
            }
            else 
            {
                getFlowInfo(&pPI[i], flowCount);
            }
            
            // move to the next interface
            currentIfc = (PTC_IFC_DESCRIPTOR)((PBYTE)currentIfc + currentIfc->Length);
        }
    }
    
    // determine what components will be contributing stats, if there any stats to get
    if (PsPipeObjType.NumInstances > 0) {
        
        //
        // compute the counter definition lengths. Each set of counters is preceeded by a PERF_OBJECT_TYPE, followed
        // by 'n' PERF_COUNTER_DEFINITIONS. All these are aligned on 8 byte boundaries, so we don't have to do any 
        // fancy aligining.
        //

        PsPipeObjType.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + 
            sizeof(PsPipePipeStatDef) + 
            sizeof(PsPipeConformerStatDef) + 
            sizeof(PsPipeShaperStatDef) + 
            sizeof(PsPipeSequencerStatDef);

        PsFlowObjType.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + 
            sizeof(PsFlowFlowStatDef) + 
            sizeof(PsFlowConformerStatDef) + 
            sizeof(PsFlowShaperStatDef) + 
            sizeof(PsFlowSequencerStatDef);
        
        // compute the sizes of the stats buffers. 
        gPipeStatLen = FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +  // initial offset
            sizeof(PS_ADAPTER_STATS) +                 // every interface has adapter stats
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_CONFORMER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_SHAPER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_DRRSEQ_STATS);
        
        gFlowStatLen = FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +  // initial offset
            sizeof(PS_FLOW_STATS) +                    // the flow's stats 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_CONFORMER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_SHAPER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_DRRSEQ_STATS);

        // Align these to 8 byte boundaries.
        gPipeStatLen = MULTIPLE_OF_EIGHT(gPipeStatLen);
        gFlowStatLen = MULTIPLE_OF_EIGHT(gFlowStatLen);
        
        // update the number of counters to be reported for each object type
        PsPipeObjType.NumCounters = PIPE_PIPE_NUM_STATS + PIPE_CONFORMER_NUM_STATS + 
            PIPE_SHAPER_NUM_STATS + PIPE_SEQUENCER_NUM_STATS;
        
        PsFlowObjType.NumCounters = FLOW_FLOW_NUM_STATS + FLOW_CONFORMER_NUM_STATS + 
            FLOW_SHAPER_NUM_STATS + FLOW_SEQUENCER_NUM_STATS;
    }

    // free up resources
    free(pIfcDescBuf);
    
    // Everything worked so return that we're happy
    return TRUE;

Error:

    closePipeFlowInfo(ppPI);

    return FALSE;    
}       

// closePipeFlowInfo() is the counterpart to getPipeFlowInfo()
// It closes all open interfaces and flows, as well as freeing memory
//
// Parameters: ppPI - pointer to a pointer to an array of valid PIPE_INFO structs
// Return value:  None
void closePipeFlowInfo(PPIPE_INFO *ppPI)
{
    ULONG i;
    PPIPE_INFO pPI=*ppPI;           // makes for less typing and cleaner code
    ULONG BytesWritten, flowCount;

    // If the PipeInfo is null, don't free it.
    if( !pPI )
    	return;

    BytesWritten = sizeof(flowCount);
    
    // free up resources associated with each interface, then close the interface
    for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) 
    {
       if(pPI[i].IfcName)
       {
          free(pPI[i].IfcName);
       }

       if(pPI[i].pFlowInfo)
       {
          free(pPI[i].pFlowInfo);
       }

        // Deregister for flow count notifications.
        TcQueryInterface(pPI[i].hIfc, 
                         (LPGUID)&GUID_QOS_FLOW_COUNT, 
                         FALSE, 
                         &BytesWritten, 
                         &flowCount);

        TcCloseInterface(pPI[i].hIfc);
    }
    
    // now free up the whole buffer
    free(*ppPI);

    // If it is freed, set it to null
    *ppPI = NULL;
}


// This func recieves notifcations from traffic.dll and makes the appropriate
// updates to internal structures
void tciNotifyHandler(IN    HANDLE  ClRegCtx,
                      IN    HANDLE  ClIfcCtx,
                      IN    ULONG   Event,
                      IN    HANDLE  SubCode,
                      IN    ULONG   BufSize,
                      IN    PVOID   Buffer)
{
    switch (Event) 
    {
      case TC_NOTIFY_IFC_UP:
      case TC_NOTIFY_IFC_CLOSE:
      case TC_NOTIFY_IFC_CHANGE:
          
        // we'll need sync'ed access
        EnterCriticalSection(&ghPipeFlowCriticalSection);

        if (dwOpenCount) {
            // now reinit the data struct
            closePipeFlowInfo(&gpPI);
            getPipeFlowInfo(&gpPI);
        }

        LeaveCriticalSection(&ghPipeFlowCriticalSection);

        break;

      case TC_NOTIFY_PARAM_CHANGED:
          
        // A flow has been closed by the TC interface
        // for example: after a remote call close, or the whole interface
        // is going down
        //
        // we'll need sync'ed access
        EnterCriticalSection(&ghPipeFlowCriticalSection);

        if (dwOpenCount) {
            if(!memcmp((LPGUID) SubCode, &GUID_QOS_FLOW_COUNT, sizeof(GUID))) {
                PULONG FlowCount = (PULONG) Buffer;
                getFlowInfo(ClIfcCtx, *FlowCount);
            }
        }

        LeaveCriticalSection(&ghPipeFlowCriticalSection);
        break;

      default:
        break;
    }
}


DWORD APIENTRY OpenPschedPerformanceData(LPWSTR lpDeviceNames)
/*++
Routine Description:

    This routine will open and map the memory used by the PSched driver to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PSched)

Return Value:

    None.
--*/

{
    LONG    status;
    HKEY    hPerfKey;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;
    TCI_CLIENT_FUNC_LIST tciCallbFuncList = {tciNotifyHandler, NULL, NULL, NULL};

    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    if (InterlockedIncrement(&dwOpenCount) == 1)
    {
    
#if DBG
        gTraceID = TraceRegister(L"PschdPrf");
#endif

        // get counter and help index base values
        // update static data structures by adding base to 
        // offset value in structure.

        status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                                PSCHED_PERF_KEY,
                                0L,
                                KEY_READ,
                                &hPerfKey);
        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx( hPerfKey, 
                                    TEXT("First Counter"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstCounter,
                                    &size);
        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            RegCloseKey(hPerfKey);
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(   hPerfKey, 
                                    TEXT("First Help"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size);

        RegCloseKey(hPerfKey);

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            
            goto OpenExitPoint;
        }

        // Convert Pipe object and counters from offset to absolute index
        PsPipeObjType.ObjectNameTitleIndex += dwFirstCounter;
        PsPipeObjType.ObjectHelpTitleIndex += dwFirstHelp;
        convertIndices((BYTE *)&PsPipePipeStatDef, 
                       sizeof PsPipePipeStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeConformerStatDef,
                       sizeof PsPipeConformerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeShaperStatDef,
                       sizeof PsPipeShaperStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeSequencerStatDef, 
                       sizeof PsPipeSequencerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);

        // Convert Flow object and counters from offset to absolute index
        PsFlowObjType.ObjectNameTitleIndex += dwFirstCounter;
        PsFlowObjType.ObjectHelpTitleIndex += dwFirstHelp;
        convertIndices((BYTE *)&PsFlowFlowStatDef,
                       sizeof PsFlowFlowStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowConformerStatDef,
                       sizeof PsFlowConformerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowShaperStatDef,
                       sizeof PsFlowShaperStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowSequencerStatDef,
                       sizeof PsFlowSequencerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        
        // initialize with traffic.dll
        if (TcRegisterClient(CURRENT_TCI_VERSION, ghClRegCtx, &tciCallbFuncList, &ghTciClient)!=NO_ERROR)
        {
            // if we can't connect with traffic.dll we are a non admin thread in OpenPschedPerformanceData. 
            // We cannot fail because of this, because an admin thread might call us at our collect routine.
            // We'll try to register as the Traffic Control client in the Collect Thread.
            //
            ghTciClient = 0;
        }
        else 
        {
        
            // we'll need sync'ed access
            EnterCriticalSection(&ghPipeFlowCriticalSection);

            // get all necessary info about pipes and flows currently installed
            if (getPipeFlowInfo(&gpPI)!=TRUE) {

                // we didn't get all the info we wanted, so we're 
                // going to have to try again, including re-registering

                LeaveCriticalSection(&ghPipeFlowCriticalSection);

                TcDeregisterClient(ghTciClient);
                goto OpenExitPoint;
            }

            LeaveCriticalSection(&ghPipeFlowCriticalSection);
        }

        // if we got to here, then we're all ready
        bInitOK = TRUE;
    }
    
    Trace0(DBG_INFO, L"[OpenPschedPerformanceData]: success \n");

    status = ERROR_SUCCESS; // for successful exit

    return status;
    
OpenExitPoint:
    Trace1(DBG_ERROR, L"[OpenPschedPerformanceData]: Failed with 0x%x \n", status);
    
    return status;
}

DWORD APIENTRY CollectPschedPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++
Routine Description:

    This routine will return the data for the PSched counters. 

    The data is returned in the foll. format. The steps below are carried out for Pipe/Flows.
    
    1. First, we write the PERF_OBJECT_TYPE for the Pipe (and/or) the Flow Counters.

    2. for(i=0; i<NumCounters; i++)
          Write PERF_COUNTER_DEFINITION for counter i;

    3. for(i=0; i<NumInstances; i++)
          Write PERF_INSTANCE_DEFINITION for instance i;
          Write Instance Name
          Write PERF_COUNTER_BLOCK
          Write the Stats;

Arguments:

   IN       LPWSTR   lpValueName
                     pointer to a wide character string passed by registry.

    IN OUT   LPVOID   *lppData
        IN: pointer to the address of the buffer to receive the completed 
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
        OUT: points to the first byte after the data structure added by this
             routine. This routine updated the value at lppdata after appending
             its data.

   IN OUT   LPDWORD  lpcbTotalBytes
        IN: the address of the DWORD that tells the size in bytes of the 
            buffer referenced by the lppData argument
        OUT: the number of bytes added by this routine is written to the 
             DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
        IN: the address of the DWORD to receive the number of objects added 
            by this routine 
        OUT: the number of objects added by this routine is written to the 
            DWORD pointed to by this argument

Return Value:

    ERROR_MORE_DATA if buffer passed is too small to hold data
                    any error conditions encountered could be reported to the event log if
                    event logging support were added.

    ERROR_SUCCESS   if success or any other error. Errors, however could
                    also reported to the event log.
--*/
{
    ULONG                    i,j;
    ULONG                    SpaceNeeded;
    PDWORD                   pdwBuf;
    DWORD                    dwQueryType;
    DWORD                    status;
    DWORD                    bufSize;
    PS_PERF_COUNTER_BLOCK    pcb;
    PERF_INSTANCE_DEFINITION pid={0, 0, 0, PERF_NO_UNIQUE_ID, sizeof(pid), 0};
    ULONG                    size;
    PVOID                    pStatsBuf;

    // save the size of the buffer
    bufSize = *lpcbTotalBytes;
    
    // default to returning nothing
    *lpcbTotalBytes = (DWORD) 0;
    *lpNumObjectTypes = (DWORD) 0;

    // Before doing anything else, see if Open went OK
    if (!bInitOK)
    {
        // unable to continue because open failed.
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: open failed \n");    
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // See if this is a foreign (i.e. non-NT) computer data request 
    dwQueryType = GetQueryType (lpValueName);
    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: received QUERY_FOREIGN \n");    
        return ERROR_SUCCESS;
    }

    //  Is PerfMon requesting PSched items?
    if (dwQueryType == QUERY_ITEMS)
    {
        if (   !(IsNumberInUnicodeList(PsPipeObjType.ObjectNameTitleIndex, 
                                           lpValueName))
            && !(IsNumberInUnicodeList(PsFlowObjType.ObjectNameTitleIndex, 
                                           lpValueName)) ) {
            // request received for data object not provided by this routine

            Trace0(DBG_INFO, L"[CollectPschedPerformanceData]: Not for psched \n");
            return ERROR_SUCCESS;
        }
    }

    // from this point on, we need sync'ed access
    EnterCriticalSection(&ghPipeFlowCriticalSection);

    // we might need to rereigster as a Traffic control client. 
    if(ghTciClient == NULL)
    {
        TCI_CLIENT_FUNC_LIST tciCallbFuncList = {tciNotifyHandler, NULL, NULL, NULL};

        status = TcRegisterClient(CURRENT_TCI_VERSION, ghClRegCtx, &tciCallbFuncList, &ghTciClient);

        if(status != NO_ERROR)
        {
            Trace1(DBG_ERROR, L"[CollectPschedPerformanceData]: Could not register as Traffic Client. Error 0x%x \n",
                   status);
            LeaveCriticalSection(&ghPipeFlowCriticalSection);

            return ERROR_SUCCESS;
        }

        // get all necessary info about pipes and flows currently installed
        if (getPipeFlowInfo(&gpPI)!=TRUE) {

            LeaveCriticalSection(&ghPipeFlowCriticalSection);

            Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: getPipeFlowInfo failed \n");

            return ERROR_SUCCESS;

        }
    }

    //
    // We have to write the PERF_OBJECT_TYPE unconditionally even if there are no instances. So, we proceed
    // to compute the space needed even when there are no flows. 
    //

    // Calculate the space needed for the pipe stats. 
    SpaceNeeded = PsPipeObjType.DefinitionLength + gTotalIfcNameSize + (PsPipeObjType.NumInstances *
                                                    (sizeof pid + sizeof pcb + gPipeStatLen) );

    SpaceNeeded += PsFlowObjType.DefinitionLength + gTotalFlowNameSize + (PsFlowObjType.NumInstances *
                                                        (sizeof pid + sizeof pcb + gFlowStatLen) );

    if (bufSize < SpaceNeeded)
    {
        LeaveCriticalSection(&ghPipeFlowCriticalSection);
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Need More data\n");    
        return ERROR_MORE_DATA;
    }
    
    pdwBuf = (PDWORD)*lppData;
    
    // Record the total length of the pipe stats
    PsPipeObjType.TotalByteLength = 
        PsPipeObjType.DefinitionLength + gTotalIfcNameSize + (PsPipeObjType.NumInstances *
                                          (sizeof pid + sizeof pcb + gPipeStatLen) );
    
    // copy object and counter definitions, increment count of object types
    WRITEBUF(&PsPipeObjType,sizeof PsPipeObjType);
    WRITEBUF(&PsPipePipeStatDef, sizeof PsPipePipeStatDef);
    WRITEBUF(&PsPipeConformerStatDef, sizeof PsPipeConformerStatDef);
    WRITEBUF(&PsPipeShaperStatDef, sizeof PsPipeShaperStatDef);
    WRITEBUF(&PsPipeSequencerStatDef, sizeof PsPipeSequencerStatDef);

    (*lpNumObjectTypes)++;
    
    //
    // for each pipe, write out its instance definition, counter block, and actual stats
    //
   
    if(ghTciClient)
    { 
        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) {
    
            PWCHAR InstanceName;
            
            //
            // Write out the PERF_INSTANCE_DEFINITION, which identifies an interface and gives it a name.
            //
            
            pid.NameLength = (wcslen(gpPI[i].IfcName)+1) * sizeof(WCHAR);
            pid.ByteLength = sizeof pid + MULTIPLE_OF_EIGHT(pid.NameLength);
            WRITEBUF(&pid, sizeof pid);
    
            InstanceName = (PWCHAR) pdwBuf;
    
            memcpy(pdwBuf, gpPI[i].IfcName, pid.NameLength);
            pdwBuf = (PULONG)((PUCHAR)pdwBuf + MULTIPLE_OF_EIGHT(pid.NameLength));
            
            CorrectInstanceName(InstanceName);
               
            //
            // get pipe stats and copy them to the buffer
            //
            size = gPipeStatLen;
            pStatsBuf = malloc(size);
            if (NULL == pStatsBuf) 
            {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                LeaveCriticalSection(&ghPipeFlowCriticalSection);
                Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                return ERROR_SUCCESS;
            }
            
            status = TcQueryInterface(gpPI[i].hIfc, 
                                      (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                      FALSE, 
                                      &size, 
                                      pStatsBuf);
            
            if (ERROR_INSUFFICIENT_BUFFER==status) 
            {
                free(pStatsBuf);
                size = gPipeStatLen = MULTIPLE_OF_EIGHT(size);
                pStatsBuf = (PPS_COMPONENT_STATS)malloc(gPipeStatLen);
                if (NULL == pStatsBuf)
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                    return ERROR_SUCCESS;
                }
                status = TcQueryInterface(gpPI[i].hIfc, 
                                          (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                          FALSE, 
                                          &size, 
                                          pStatsBuf);
            }
            if (NO_ERROR != status) {
                
                Trace1(DBG_ERROR, L"[CollectPschedPerformanceData]: TcQueryInterface failed with 0x%x \n", status);
                memset ( pStatsBuf, 0, gPipeStatLen );
            }
            
            //
            // Now, write the PERF_COUNTER_BLOCK
            //
            pcb.pcb.ByteLength = gPipeStatLen + sizeof(pcb);
            WRITEBUF(&pcb,sizeof pcb);
            
            //
            // Write out all the counters.
            //
                
            WRITEBUF(pStatsBuf,gPipeStatLen);
            
            free(pStatsBuf);
        }
    }
    
    // set the pointer to where the pipe object type said the next object would start
    pdwBuf = (PDWORD)( ((BYTE *)*lppData) + PsPipeObjType.TotalByteLength );
        
    // first copy flow data def (object_type struct).
    // Record the total length of the flow stats
    PsFlowObjType.TotalByteLength = 
            PsFlowObjType.DefinitionLength + gTotalFlowNameSize + (PsFlowObjType.NumInstances *
                                              (sizeof pid + sizeof pcb + gFlowStatLen) );
        
    // copy object and counter definitions, increment count of object types
    WRITEBUF(&PsFlowObjType,sizeof PsFlowObjType);
    WRITEBUF(&PsFlowFlowStatDef, sizeof PsFlowFlowStatDef);
    WRITEBUF(&PsFlowConformerStatDef, sizeof PsFlowConformerStatDef);
    WRITEBUF(&PsFlowShaperStatDef, sizeof PsFlowShaperStatDef);
    WRITEBUF(&PsFlowSequencerStatDef, sizeof PsFlowSequencerStatDef);
    (*lpNumObjectTypes)++;

    // if there are any flows, process them
        
    if (PsFlowObjType.NumInstances && ghTciClient) {

        // initialize parent structure
        pid.ParentObjectTitleIndex = PsPipeObjType.ObjectNameTitleIndex;
        
        // loop over each interface checking for flow installed on them
        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) {
            
            // keep parent instance up to date
            pid.ParentObjectInstance = i;
            
            for (j=0; j<gpPI[i].numFlows; j++) {
                PWCHAR InstanceName;

                // copy flow instance definition and name
                pid.NameLength = (wcslen(gpPI[i].pFlowInfo[j].FriendlyName)+1) * sizeof(WCHAR);
                pid.ByteLength = sizeof(pid) + MULTIPLE_OF_EIGHT(pid.NameLength);
                WRITEBUF(&pid,sizeof pid);
                InstanceName = (PWCHAR) pdwBuf;

                memcpy(pdwBuf, gpPI[i].pFlowInfo[j].FriendlyName, pid.NameLength);
                pdwBuf = (PULONG)((PUCHAR)pdwBuf + MULTIPLE_OF_EIGHT(pid.NameLength));

                CorrectInstanceName(InstanceName);
                
                // get flow stats and copy them to the buffer
                size = gFlowStatLen;
                pStatsBuf = malloc(size);
                if (NULL == pStatsBuf) {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                    return ERROR_SUCCESS;
                }
                status = TcQueryFlow(gpPI[i].pFlowInfo[j].InstanceName, (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                     &size, pStatsBuf);
                if (ERROR_INSUFFICIENT_BUFFER==status) {
                    free(pStatsBuf);
                    size = gFlowStatLen = MULTIPLE_OF_EIGHT(size);
                    pStatsBuf = (PPS_COMPONENT_STATS)malloc(gFlowStatLen);
                    if (NULL == pStatsBuf)
                    {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        LeaveCriticalSection(&ghPipeFlowCriticalSection);
                        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                        return ERROR_SUCCESS;
                    }
                    status = TcQueryFlow(gpPI[i].pFlowInfo[j].InstanceName, (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                         &size, pStatsBuf);
                }
                if (NO_ERROR != status) {
                    
                    free(pStatsBuf);
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace1(DBG_ERROR, 
                             L"[CollectPschedPerformanceData]: TcQueryFlow failed with status 0x%x \n", status);

                    return ERROR_SUCCESS;
                }

                // copy flow instance counter_block 
                pcb.pcb.ByteLength = gFlowStatLen + sizeof(pcb);

                WRITEBUF(&pcb,sizeof pcb);

                WRITEBUF(pStatsBuf, gFlowStatLen);
                
                free(pStatsBuf);
            }
        }
    }
    
    // update the data pointer
    *lpcbTotalBytes = PsPipeObjType.TotalByteLength + PsFlowObjType.TotalByteLength;
    *lppData = ((PBYTE)*lppData) + *lpcbTotalBytes;
    
    // free up the sync lock
    LeaveCriticalSection(&ghPipeFlowCriticalSection);

    Trace0(DBG_INFO, L"[CollectPschedPerformanceData]: Succcess \n");
    return ERROR_SUCCESS;
}


/*
Routine Description:
    This routine closes the open handles to PSched device performance counters

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
*/
DWORD APIENTRY ClosePschedPerformanceData()
{

    EnterCriticalSection(&ghPipeFlowCriticalSection);

    if(InterlockedDecrement(&dwOpenCount) == 0)
    {
        LeaveCriticalSection(&ghPipeFlowCriticalSection);

        // Clean up with traffic.dll and free up resources
        closePipeFlowInfo(&gpPI);

        // then deregister
        if(ghTciClient)
            TcDeregisterClient(ghTciClient);

        // get rid of the mutex
        
#if DBG
        TraceDeregister(gTraceID);
#endif
    } else {
        LeaveCriticalSection(&ghPipeFlowCriticalSection);
    }

    return ERROR_SUCCESS;
}


//////////////////////////////////////////////////////////////////////
//
// PERF UTILITY STUFF BELOW!
//
//////////////////////////////////////////////////////////////////////
BOOL WINAPI DllEntryPoint(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ghInst = hDLL;

            // initialize the mutex
            __try {
                InitializeCriticalSection(&ghPipeFlowCriticalSection);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;
        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&ghPipeFlowCriticalSection);
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
    } // switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\pschddat.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PschdDat.c

Abstract:

    This file declares and initializes object and counter data definitions

Author:

    Eliot Gillum (t-eliotg)   July 5, 1998
    
Revision History

--*/

#include <windows.h>
#include <ntddndis.h>
#include "PschdPrf.h"
#include "PSchdCnt.h"


//
// Pipe object and counter definition declarations
//

PERF_OBJECT_TYPE PsPipeObjType = {
        sizeof(PERF_OBJECT_TYPE),         // TotalByteLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),         // DefinitionLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),         // HeaderLength
        PSCHED_PIPE_OBJ,                  // ObjectNameTitleIndex
        0,                                // ObjectNameTitle
        PSCHED_PIPE_OBJ,                  // ObjectHelpTitleIndex
        0,                                // ObjectHelpTitle
        PERF_DETAIL_NOVICE,               // DetailLevel
        0,                                // NumCounters - to be modified later
        0,                                // DefaultCounter
        0,                                // Number of object instances ( seq #)
        0,                                // CodePage
        {0,0},                            // Perf Time
        {0,0}                             // Perf Freq
    };

PS_PIPE_PIPE_STAT_DEF PsPipePipeStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_OUT_OF_PACKETS,
        0,
        PIPE_OUT_OF_PACKETS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_OUT_OF_PACKETS_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_OPENED,
        0,
        PIPE_FLOWS_OPENED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_OPENED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_CLOSED,
        0,
        PIPE_FLOWS_CLOSED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_CLOSED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_REJECTED,
        0,
        PIPE_FLOWS_REJECTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_REJECTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_MODIFIED,
        0,
        PIPE_FLOWS_MODIFIED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_MODIFIED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOW_MODS_REJECTED,
        0,
        PIPE_FLOW_MODS_REJECTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOW_MODS_REJECTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_SIMULTANEOUS_FLOWS,
        0,
        PIPE_MAX_SIMULTANEOUS_FLOWS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_SIMULTANEOUS_FLOWS_OFFSET
    }
};

PS_PIPE_CONFORMER_STAT_DEF PsPipeConformerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_SCHEDULED,
        0,
        PIPE_NONCONF_PACKETS_SCHEDULED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET
    }
};

PS_PIPE_SHAPER_STAT_DEF PsPipeShaperStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_SHAPER,
        0,
        PIPE_AVE_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_SHAPER_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_SHAPER,
        0,
        PIPE_MAX_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_SHAPER_OFFSET
    }
};

PS_PIPE_SEQUENCER_STAT_DEF PsPipeSequencerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_SEQ,
        0,
        PIPE_AVE_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_SEQ,
        0,
        PIPE_MAX_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_NETCARD,
        0,
        PIPE_MAX_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_NETCARD,
        0,
        PIPE_AVE_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_TRANSMITTED,
        0,
        PIPE_NONCONF_PACKETS_TRANSMITTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET
    }
};


//
// Flow object and counter definition declarations
//

PERF_OBJECT_TYPE PsFlowObjType = {
        sizeof(PERF_OBJECT_TYPE),      // TotalByteLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),      // DefinitionLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),      // HeaderLength
        PSCHED_FLOW_OBJ,               // ObjectNameTitleIndex
        0,                             // ObjectNameTitle
        PSCHED_FLOW_OBJ,               // ObjectHelpTitleIndex
        0,                             // ObjectHelpTitle
        PERF_DETAIL_NOVICE,            // DetailLevel
        0,                             // NumCounters - to be modified later
        5,                             // DefaultCounter -- Ave packets in seq
        0,                             // Number of object instances ( seq #)
        0,                             // CodePage
        {0,0},                         // Perf Time
        {0,0}                          // Perf Freq
    };

PS_FLOW_FLOW_STAT_DEF PsFlowFlowStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_DROPPED,
        0,
        FLOW_PACKETS_DROPPED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_DROPPED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_SCHEDULED,
        0,
        FLOW_PACKETS_SCHEDULED,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph thousands of packets instead of packets
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_TRANSMITTED,
        0,
        FLOW_PACKETS_TRANSMITTED,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph thousands of packets instead of packets
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_SCHEDULED,
        0,
        FLOW_BYTES_SCHEDULED,
        0,
        -6,                     // scale the graph by 10^-6, i.e. graph MBs instead of bytes
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_TRANSMITTED,
        0,
        FLOW_BYTES_TRANSMITTED,
        0,
        -6,                     // scale the graph by 10^-6, i.e. graph MBs instead of bytes
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_TRANSMITTED_PERSEC,
        0,
        FLOW_BYTES_TRANSMITTED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kb/s instead of bytes/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_SCHEDULED_PERSEC,
        0,
        FLOW_BYTES_SCHEDULED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kb/s instead of bytes/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_TRANSMITTED_PERSEC,
        0,
        FLOW_PACKETS_TRANSMITTED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kilopackets/sec instead of packets/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_SCHEDULED_PERSEC,
        0,
        FLOW_PACKETS_SCHEDULED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kilopackets/sec instead of packets/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_DROPPED_PERSEC,
        0,
        FLOW_PACKETS_DROPPED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_DROPPED_OFFSET
    }
};

PS_FLOW_CONFORMER_STAT_DEF PsFlowConformerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_SCHEDULED,
        0,
        FLOW_NONCONF_PACKETS_SCHEDULED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET
    }
};

PS_FLOW_SHAPER_STAT_DEF PsFlowShaperStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_SHAPER,
        0,
        FLOW_AVE_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_SHAPER_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_SHAPER,
        0,
        FLOW_MAX_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_SHAPER_OFFSET
    }
};

PS_FLOW_SEQUENCER_STAT_DEF PsFlowSequencerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_SEQ,
        0,
        FLOW_AVE_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_SEQ,
        0,
        FLOW_MAX_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_NETCARD,
        0,
        FLOW_MAX_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_NETCARD,
        0,
        FLOW_AVE_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_TRANSMITTED,
        0,
        FLOW_NONCONF_PACKETS_TRANSMITTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\pschdcnt.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    PschdCnt.h

Abstract:

    Offset definition file for extensible counter objects and counters

    These "relative" offsets must start at 0 and be multiples of 2 (i.e.
    even numbers). In the Open Procedure, they will be added to the 
    "First Counter" and "First Help" values for the device they belong to, 
    in order to determine the absolute location of the counter and 
    object names and corresponding Explain text in the registry.

    This file is used by the extensible counter DLL code as well as the 
    counter name and Explain text definition file (.INI) file that is used
    by LODCTR to load the names into the registry.

Revision History:

--*/

// PerfMon objects
#define PSCHED_FLOW_OBJ                             0
#define PSCHED_PIPE_OBJ                             2

// Flow counters
#define FLOW_PACKETS_DROPPED                        4
#define FLOW_PACKETS_SCHEDULED                      6
#define FLOW_PACKETS_TRANSMITTED                    8
#define FLOW_AVE_PACKETS_IN_SHAPER                  10
#define FLOW_MAX_PACKETS_IN_SHAPER                  12
#define FLOW_AVE_PACKETS_IN_SEQ                     14
#define FLOW_MAX_PACKETS_IN_SEQ                     16
#define FLOW_BYTES_SCHEDULED                        18
#define FLOW_BYTES_TRANSMITTED                      20
#define FLOW_BYTES_TRANSMITTED_PERSEC               22
#define FLOW_BYTES_SCHEDULED_PERSEC                 24
#define FLOW_PACKETS_TRANSMITTED_PERSEC             26
#define FLOW_PACKETS_SCHEDULED_PERSEC               28
#define FLOW_PACKETS_DROPPED_PERSEC                 30
#define FLOW_NONCONF_PACKETS_SCHEDULED              32
#define FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC       34
#define FLOW_NONCONF_PACKETS_TRANSMITTED            36
#define FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC     38
#define FLOW_MAX_PACKETS_IN_NETCARD                 40
#define FLOW_AVE_PACKETS_IN_NETCARD                 42

// Pipe counters
#define PIPE_OUT_OF_PACKETS                         44
#define PIPE_FLOWS_OPENED                           46
#define PIPE_FLOWS_CLOSED                           48
#define PIPE_FLOWS_REJECTED                         50
#define PIPE_FLOWS_MODIFIED                         52
#define PIPE_FLOW_MODS_REJECTED                     54
#define PIPE_MAX_SIMULTANEOUS_FLOWS                 56
#define PIPE_NONCONF_PACKETS_SCHEDULED              58
#define PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC       60
#define PIPE_NONCONF_PACKETS_TRANSMITTED            62
#define PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC     64
#define PIPE_AVE_PACKETS_IN_SHAPER                  66
#define PIPE_MAX_PACKETS_IN_SHAPER                  68
#define PIPE_AVE_PACKETS_IN_SEQ                     70
#define PIPE_MAX_PACKETS_IN_SEQ                     72
#define PIPE_MAX_PACKETS_IN_NETCARD                 74
#define PIPE_AVE_PACKETS_IN_NETCARD                 76
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pslog\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    User space log viewer

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <windef.h>
//#include <winbase.h>
#include <windows.h>

#include <ntosp.h>
#include <ndis.h>

#include <string.h>
#include <stdio.h>
//#include <stdlib.h>

#include "psched.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pschdprf\pschdprf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

      PschdPrf.h

Abstract:

    Header file for the PSched Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  

--*/

#ifndef _PSCHDPRF_H_
#define _PSCHDPRF_H_

#include <winperf.h>
#include <qos.h>
#include <objbase.h>
#include <tcguid.h>
#include <traffic.h>
#include <ntddpsch.h>
#include "pschdcnt.h"


// Useful Macros


// Necessary data structures

#define PS_FRIENDLY_NAME_LENGTH 128

typedef struct _FLOW_INFO
{
    WCHAR InstanceName[MAX_STRING_LENGTH+1];
    WCHAR FriendlyName[PS_FRIENDLY_NAME_LENGTH+1];
} FLOW_INFO, *PFLOW_INFO;

typedef struct _PIPE_INFO
{
        HANDLE hIfc;                                   // (open) HANDLE to the interface
        LPTSTR IfcName;                                // Interface name
        ULONG numFlows;                                // Flow counter for this pipe
        PFLOW_INFO pFlowInfo;                          // Pointer to array of FLOW_INFOs 
} PIPE_INFO, *PPIPE_INFO;

typedef struct _PS_PERF_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK pcb;
    DWORD              pad;
} PS_PERF_COUNTER_BLOCK, *PPS_PERF_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundaries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

//
//  PSched Flow Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.


// Interface specific counters
// Pipe counters
#define PIPE_OUT_OF_PACKETS_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, OutOfPackets))

#define PIPE_FLOWS_OPENED_OFFSET                (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsOpened))

#define PIPE_FLOWS_CLOSED_OFFSET                (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsClosed))

#define PIPE_FLOWS_REJECTED_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsRejected))

#define PIPE_FLOWS_MODIFIED_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsModified))

#define PIPE_FLOW_MODS_REJECTED_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowModsRejected))

#define PIPE_MAX_SIMULTANEOUS_FLOWS_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, MaxSimultaneousFlows))

#define PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET   (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_CONFORMER_STATS, NonconformingPacketsScheduled))

#define PIPE_AVE_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, AveragePacketsInShaper))

#define PIPE_MAX_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, MaxPacketsInShaper))

#define PIPE_AVE_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInSequencer))

#define PIPE_MAX_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInSequencer))

#define PIPE_MAX_PACKETS_IN_NETCARD_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInNetcard))

#define PIPE_AVE_PACKETS_IN_NETCARD_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInNetcard))

#define PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, NonconformingPacketsTransmitted))

#define PIPE_PIPE_NUM_STATS         (7)
typedef struct _PS_PIPE_PIPE_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     OutOfPackets;
    PERF_COUNTER_DEFINITION     FlowsOpened;
    PERF_COUNTER_DEFINITION     FlowsClosed;
    PERF_COUNTER_DEFINITION     FlowsRejected;
    PERF_COUNTER_DEFINITION     FlowsModified;
    PERF_COUNTER_DEFINITION     FlowModsRejected;
    PERF_COUNTER_DEFINITION     MaxSimultaneousFlows;
} PS_PIPE_PIPE_STAT_DEF, *PPS_PIPE_PIPE_STAT_DEF;

#define PIPE_CONFORMER_NUM_STATS    (2)
typedef struct _PS_PIPE_CONFORMER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     NonconfPacketsScheduled;
    PERF_COUNTER_DEFINITION     NonconfPacketsScheduledPerSec;
} PS_PIPE_CONFORMER_STAT_DEF, *PPS_PIPE_CONFORMER_STAT_DEF;

#define PIPE_SHAPER_NUM_STATS       (2)
typedef struct _PS_PIPE_SHAPER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     AvePacketsInShaper;
    PERF_COUNTER_DEFINITION     MaxPacketsInShaper;
} PS_PIPE_SHAPER_STAT_DEF, *PPS_PIPE_SHAPER_STAT_DEF;

#define PIPE_SEQUENCER_NUM_STATS    (6)
typedef struct _PS_PIPE_SEQUENCER_STAT_DEF
{
    PERF_COUNTER_DEFINITION     AvePacketsInSeq;
    PERF_COUNTER_DEFINITION     MaxPacketsInSeq;
    PERF_COUNTER_DEFINITION     MaxPacketsInNetcard;
    PERF_COUNTER_DEFINITION     AvePacketsInNetcard;
    PERF_COUNTER_DEFINITION     NonconfPacketsTransmitted;
    PERF_COUNTER_DEFINITION     NonconfPacketsTransmittedPerSec;
} PS_PIPE_SEQUENCER_STAT_DEF, *PPS_PIPE_SEQUENCER_STAT_DEF;


// Flow counters

#define FLOW_PACKETS_DROPPED_OFFSET             (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, DroppedPackets))

#define FLOW_PACKETS_SCHEDULED_OFFSET           (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, PacketsScheduled))

#define FLOW_PACKETS_TRANSMITTED_OFFSET         (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, PacketsTransmitted))

#define FLOW_BYTES_SCHEDULED_OFFSET             (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, BytesScheduled))

#define FLOW_BYTES_TRANSMITTED_OFFSET           (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, BytesTransmitted))

#define FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET   (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_CONFORMER_STATS, NonconformingPacketsScheduled))

#define FLOW_AVE_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, AveragePacketsInShaper))

#define FLOW_MAX_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, MaxPacketsInShaper))

#define FLOW_AVE_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInSequencer))

#define FLOW_MAX_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInSequencer))

#define FLOW_MAX_PACKETS_IN_NETCARD_OFFSET     (sizeof(PS_PERF_COUNTER_BLOCK) +                                  \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_FLOW_STATS) +                                          \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_CONFORMER_STATS) +                                     \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_SHAPER_STATS) +                                        \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInNetcard))

#define FLOW_AVE_PACKETS_IN_NETCARD_OFFSET     (sizeof(PS_PERF_COUNTER_BLOCK) +                                  \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_FLOW_STATS) +                                          \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_CONFORMER_STATS) +                                     \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_SHAPER_STATS) +                                        \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInNetcard))

#define FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, NonconformingPacketsTransmitted))

#define FLOW_FLOW_NUM_STATS (10)
typedef struct _PS_FLOW_FLOW_STAT_DEF 
{
    PERF_COUNTER_DEFINITION PacketsDropped;
    PERF_COUNTER_DEFINITION PacketsScheduled;
    PERF_COUNTER_DEFINITION PacketsTransmitted;
    PERF_COUNTER_DEFINITION BytesScheduled;
    PERF_COUNTER_DEFINITION BytesTransmitted;
    PERF_COUNTER_DEFINITION BytesTransmittedPerSec;
    PERF_COUNTER_DEFINITION BytesScheduledPerSec;
    PERF_COUNTER_DEFINITION PacketsTransmittedPerSec;
    PERF_COUNTER_DEFINITION PacketsScheduledPerSec;
    PERF_COUNTER_DEFINITION PacketsDroppedPerSec;
} PS_FLOW_FLOW_STAT_DEF, *PPS_FLOW_FLOW_STAT_DEF;

#define FLOW_CONFORMER_NUM_STATS (2)
typedef struct _PS_FLOW_CONFORMER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION NonconfPacketsScheduled;
    PERF_COUNTER_DEFINITION NonconfPacketsScheduledPerSec;
} PS_FLOW_CONFORMER_STAT_DEF, *PPS_FLOW_CONFORMER_STAT_DEF;

#define FLOW_SHAPER_NUM_STATS (2)
typedef struct _PS_FLOW_SHAPER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION AvePacketsInShaper;
    PERF_COUNTER_DEFINITION MaxPacketsInShaper;
} PS_FLOW_SHAPER_STAT_DEF, *PPS_FLOW_SHAPER_STAT_DEF;

#define FLOW_SEQUENCER_NUM_STATS (6)
typedef struct _PS_FLOW_SEQUENCER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION AvePacketsInSeq;
    PERF_COUNTER_DEFINITION MaxPacketsInSeq;
    PERF_COUNTER_DEFINITION MaxPacketsInNetcard;
    PERF_COUNTER_DEFINITION AvePacketsInNetcard;
    PERF_COUNTER_DEFINITION NonconfPacketsTransmitted;
    PERF_COUNTER_DEFINITION NonconfPacketsTransmittedPerSec;
} PS_FLOW_SEQUENCER_STAT_DEF, *PPS_FLOW_SEQUENCER_STAT_DEF;

#pragma pack ()


#endif //_PSCHDPRF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\clstate.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clstate.c

Abstract:

    state machine for gpc client vcs

Author:

    Yoram Bernet    (yoramb)    28-Dec-1997
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

    Rajesh Sundaram (rajeshsu) 04-Apr-1998 - reworked completly as another state 
                                            (CL_INTERNAL_CALL_COMPLETE) added.

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

/* End Forward */

/*++

Routine Description:

    Initiate a close call on this VC and notify the GPC. Always called with the VC lock held.

Return Value:

    None

--*/
VOID
InternalCloseCall(
    PGPC_CLIENT_VC Vc
    )
{
    PADAPTER Adapter = Vc->Adapter;

    PsDbgOut(DBG_INFO,
             DBG_STATE,
             ("[InternalCloseCall]: Adapter %08X, ClVcState is %s on VC %x\n",
              Vc->Adapter, GpcVcState[Vc->ClVcState], Vc));

    switch(Vc->ClVcState){

      case CL_INTERNAL_CLOSE_PENDING:
          
          //
          // We could get here if we get an unbind at our wan instance with a 
          // NDIS_STATUS_WAN_LINE_DOWN. We could be trying to do an InternalClose
          // from both places. 
          //

          PsAssert(Vc->Flags & INTERNAL_CLOSE_REQUESTED);

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          break;
          
      case CL_CALL_PENDING:
      case CL_MODIFY_PENDING:

          //
          // We've been asked to close before the call 
          // has completed. 
          //
          // Set a flag so that we'll close it when the 
          // call completes.
          //

          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));

          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          break;

      case CL_INTERNAL_CALL_COMPLETE:

          //
          // The call has been completed, but we may or may not 
          // have told the GPC. Wait till we tell the GPC. We will
          // complete this when we transistion to CL_CALL_COMPLETE
          //
          
          PsAssert(!IsBestEffortVc(Vc));
          
          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          break;
          
      case CL_CALL_COMPLETE:
          
          //
          // Transition to CL_INTERNAL_CLOSE_PENDING and
          // ask the GPC to close.
          //
          
          Vc->ClVcState = CL_INTERNAL_CLOSE_PENDING;

          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          CmCloseCall(Vc);

          break;
        
      case CL_GPC_CLOSE_PENDING:

          //
          // The GPC has already asked us to close. Now, 
          // we are also closing down - We need not do 
          // anything here - Need not even inform the GPC.
          // we can just pretend as the InternalClose never
          // happened

          Vc->Flags &= ~INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          break;
        
      default:
          
          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[InternalCloseCall]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));

          PsAssert(0);
          break;
    }
}

VOID
CallSucceededStateTransition(
    PGPC_CLIENT_VC Vc
    )
{

    PsDbgOut(DBG_INFO,
             DBG_STATE,
             ("[CallSucceededStateTransition]: Adapter %08X, ClVcState is %s on VC %x\n",
              Vc->Adapter, GpcVcState[Vc->ClVcState], Vc));

    PS_LOCK(&Vc->Lock);

    switch(Vc->ClVcState){

      case CL_GPC_CLOSE_PENDING:

          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[CallSucceededStateTransition]: bad state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          break;

      case CL_INTERNAL_CALL_COMPLETE:
        
          PsAssert(!IsBestEffortVc(Vc));

#if DBG
          if(Vc->Flags & GPC_MODIFY_REQUESTED) {
              PsAssert(! (Vc->Flags & GPC_CLOSE_REQUESTED));
          }

          if(Vc->Flags & GPC_CLOSE_REQUESTED) {
              PsAssert(! (Vc->Flags & GPC_MODIFY_REQUESTED));
          }
#endif
          //
          // Note that if both a modify & a internal remove is requested, 
          // we just satisfy the modify. When the modify goes into internal
          // call complete, we will satify the remove
          //
          if(Vc->Flags & GPC_MODIFY_REQUESTED) {

              NDIS_STATUS Status;

              Vc->ClVcState = CL_MODIFY_PENDING;
              Vc->Flags &= ~GPC_MODIFY_REQUESTED;

              PS_UNLOCK(&Vc->Lock);

              Status = CmModifyCall(Vc);

              if(Status != NDIS_STATUS_PENDING) {
                  
                  CmModifyCallComplete(Status, Vc, Vc->ModifyCallParameters);
              }
              
              break;
              
          }
          
          if(Vc->Flags & GPC_CLOSE_REQUESTED) {
              
              // 
              // The GPC has asked us to close after it
              // was notified of the call completion but
              // before we managed to transition to the
              // CL_CALL_COMPLETE state.
              //
            
              Vc->ClVcState = CL_GPC_CLOSE_PENDING;

              PS_UNLOCK(&Vc->Lock);

              CmCloseCall(Vc);

              break;
          }
          
          if(Vc->Flags & INTERNAL_CLOSE_REQUESTED){
              
              //
              // We had an internal close request while
              // the call was pending. The GPC has already
              // been notified, so - we need to ask it to
              // close.
              //
              
              Vc->ClVcState = CL_INTERNAL_CLOSE_PENDING;

              PS_UNLOCK(&Vc->Lock);

              CmCloseCall(Vc);

              break;
          }
          
          Vc->ClVcState = CL_CALL_COMPLETE;

          PS_UNLOCK(&Vc->Lock);

          break;
          
      case CL_MODIFY_PENDING:
          //
          // Typically, just transition to CL_CALL_COMPLETE
          //
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          PsAssert(!(Vc->Flags & GPC_MODIFY_REQUESTED));
          PsAssert(!IsBestEffortVc(Vc));
          
          Vc->ClVcState = CL_INTERNAL_CALL_COMPLETE;
          
          PS_UNLOCK(&Vc->Lock);
          
          break;
          
      case CL_CALL_PENDING:
          //
          // Typically, just transition to CL_INTERNAL_CALL_COMPLETE.
          //
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          PsAssert(!(Vc->Flags & GPC_MODIFY_REQUESTED));
          
          //
          // Call succeeded. Leave it up.
          //
          if(IsBestEffortVc(Vc)) 
          {
              Vc->ClVcState = CL_CALL_COMPLETE;
          }
          else 
          {
            Vc->ClVcState = CL_INTERNAL_CALL_COMPLETE;
          }
          PS_UNLOCK(&Vc->Lock);

          break;
          
      default:
          
          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[CallSucceededStateTransition]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);
    }
}

        
/* end clstate.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\pslog\main.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    User space log viewer

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#define UNICODE
#define INITGUID
#include "precomp.h"

void ClNotifyHandler( HANDLE ClRegCtx, HANDLE ClIfcCtx, ULONG Event, HANDLE SubCode, ULONG BufSize, PVOID Buffer )
{
}

static PCHAR SendRecvActions[] = {
    "",
    "ENTER",
    "NO_RESOURCES",
    "LOW_RESOURCES",
    "INDICATING",
    "RETURNED",
    "NOT_OURS",
    "OURS",
    "RETURNING",
    "TRANSFERRING",
    "NOT READY"};

#define FILE   1
#define CONFIG 2
#define LEVEL  4
#define MASK   8

VOID
ParseOidRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    static PCHAR OIDActions[] =
    {
        "",
        "MpSetInformation",
        "MpQueryInformation",
        "SetRequestComplete",
        "QueryRequestComplete"
    };
    TRACE_RECORD_OID *record = (TRACE_RECORD_OID *)DataStart;

    *Size = sizeof(TRACE_RECORD_OID);

    if(record->Now.QuadPart){

        printf("[%I64u]: OID: %5s:%9s:(%d:%d):%p:%08X:%08X\n",
                 record->Now.QuadPart,
                 OIDActions[record->Action],
                 record->Local == TRUE?"Local":"Non Local",
                 record->PTState,
                 record->MPState,
                 record->Adapter,
                 record->Oid,
                 record->Status);
    }
    else {
        printf("OID: %5s:%9s:(%d:%d):%p:%08X:%08X\n",
                 OIDActions[record->Action],
                 record->Local == TRUE?"Local":"Non Local",
                 record->PTState,
                 record->MPState,
                 record->Adapter,
                 record->Oid,
                 record->Status);
    }
}

VOID
ParseStringRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    TRACE_RECORD_STRING *record = (TRACE_RECORD_STRING *) DataStart;

    *Size = sizeof(TRACE_RECORD_STRING);

    if(record->Now.QuadPart){
        printf("%I64u:%s",
               record->Now.QuadPart,
               record->StringStart);
    }
    else{
        printf("%s",
               record->StringStart);
    }

}

VOID
ParseSchedRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    TRACE_RECORD_SCHED * record = (TRACE_RECORD_SCHED *)DataStart;
    static PCHAR SchedModules[] = {
        "NOP",
        "TB CONFORMER",
        "SHAPER",
        "DRR SEQ",
        "CBQ"};

    static PCHAR SchedActions[] = {
        "NOP",
        "ENQUEUE",
        "DEQUEUE",
        "CONFORMANCE",
        "DISCARD"};

    LARGE_INTEGER ArrivalTime, ConformanceTime;

    ConformanceTime.QuadPart = record->ConformanceTime;
    ArrivalTime.QuadPart = record->ArrivalTime;

    printf("SCHED:%s:VC %p:%p:%u:%s:%d:%I64u:[%u,%u]:%I64u:[%u,%u]:%u\n",
           SchedModules[record->SchedulerComponent],
           record->VC,
           record->Packet,
           record->PacketLength,
           SchedActions[record->Action],
           record->Priority,
           ArrivalTime.QuadPart,
           ArrivalTime.HighPart,
           ArrivalTime.LowPart,
           ConformanceTime.QuadPart,
           ConformanceTime.HighPart,
           ConformanceTime.LowPart,
           record->PacketsInComponent);

    *Size = sizeof(TRACE_RECORD_SCHED);
}

VOID
ParseRecvRecord(
    CHAR * DataStart,
    PULONG size
    )
{

    static PCHAR RecvEvents[] = {
        "",
        "CL_RECV_PACKET",
        "MP_RETURN_PACKET",
        "CL_RECV_INDICATION",
        "CL_RECV_COMPLETE",
        "MP_TRANSFER_DATA",
        "CL_TRANSFER_COMPLETE"};

    TRACE_RECORD_RECV *record = (TRACE_RECORD_RECV*)DataStart;

    *size = sizeof(TRACE_RECORD_RECV);

    printf("%I64u:Adapter %p:%s:%s:%p:%p \n",
            record->Now.QuadPart,
            record->Adapter,
            RecvEvents[record->Event],
            SendRecvActions[record->Action],
            record->Packet1,
            record->Packet2);
}

VOID
ParseSendRecord(
    CHAR * DataStart,
    PULONG Size
    )
{
    TRACE_RECORD_SEND* record = (TRACE_RECORD_SEND *)DataStart;
    static PCHAR SendEvents[] = {
        "",
        "MP_SEND",
        "MP_CO_SEND",
        "DUP_PACKET",
        "DROP_PACKET",
        "CL_SEND_COMPLETE" };


    *Size = sizeof(TRACE_RECORD_SEND);

    printf("%I64u:Adapter %p:%s:%s:%p:%p:%p\n",
            record->Now.QuadPart,
            record->Adapter,
            SendEvents[record->Event],
            SendRecvActions[record->Action],
            record->Vc,
            record->Packet1,
            record->Packet2);

}

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG Size
    )
{
    CHAR * recordEnd;
    LONG records;
    BOOLEAN success;
    CHAR hold;
    ULONG bytesread;
    ULONG TotalValidBytesRead = 0;

    records = 0;

    while(TRUE)
    {
        hold = *(DataStart+4);

        switch(hold)
        {

          case RECORD_TSTRING:

              ParseStringRecord(DataStart, &bytesread);
              break;

          case RECORD_OID:
              ParseOidRecord(DataStart, &bytesread);
              break;

          case RECORD_SCHED:

              ParseSchedRecord(DataStart, &bytesread);
              break;

          case RECORD_RECV:
              ParseRecvRecord(DataStart, &bytesread);
              break;

          case RECORD_SEND:
              ParseSendRecord(DataStart, &bytesread);
              break;
          default:

              printf("Unrecognized record type!\n");

              //
              // we cannot proceed - we don't know how much to advance it by.
              //

              return;
        }

        records++;

        TotalValidBytesRead += bytesread;

        if(TotalValidBytesRead >= Size){
            printf("\nDONE:Completed parsing trace buffer. %d records found.\n", records);
            break;
        }

        DataStart += bytesread;
    }
}

BOOLEAN TcDone(
    HANDLE ClientHandle,
    HANDLE InterfaceHandle
    )

{
    ULONG Status;

    Status = TcCloseInterface(InterfaceHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("TcCloseInterface failed : Status = %d \n", Status);
    }

    Status = TcDeregisterClient(ClientHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("TcDeregisterClient failed : Status = %d \n", Status);
    }

    return TRUE;

}

BOOLEAN TcInit(
    PHANDLE ClientHandle,
    PHANDLE InterfaceHandle
    )
{
    TCI_CLIENT_FUNC_LIST ClientHandlerList;
    ULONG                Size = 100 * sizeof(TC_IFC_DESCRIPTOR);
    PTC_IFC_DESCRIPTOR   InterfaceBuffer;
    ULONG x, Status;

    memset( &ClientHandlerList, 0, sizeof(ClientHandlerList) );
    ClientHandlerList.ClNotifyHandler = ClNotifyHandler;

    InterfaceBuffer = (PTC_IFC_DESCRIPTOR) malloc(Size);
    if(!InterfaceBuffer)
        return FALSE;

    //
    // Register the TC client.
    //
    Status = TcRegisterClient(CURRENT_TCI_VERSION,
                              NULL,
                              &ClientHandlerList,
                              ClientHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("Cannot register as TC client \n");
        free(InterfaceBuffer);
        return FALSE;
    }

    //
    // Enumerate interfaces.
    //

    Status = TcEnumerateInterfaces(
        *ClientHandle,
        &Size,
        InterfaceBuffer);

    if(ERROR_INSUFFICIENT_BUFFER == Status)
    {
        free(InterfaceBuffer);

        InterfaceBuffer = (PTC_IFC_DESCRIPTOR) malloc(Size);

		if ( !InterfaceBuffer ) 
		{
            TcDeregisterClient(*ClientHandle);

            printf("Unable to allocate memory to call TcEnumerateInterfaces\n");

            return FALSE;
		}
		
        Status = TcEnumerateInterfaces(
            *ClientHandle,
            &Size,
            InterfaceBuffer);

        if(!NT_SUCCESS(Status))
        {
            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            printf("TcEnumerateInterfaces failed with error %d \n", Status);

            return FALSE;
        }
    }
    else
    {
        if(!NT_SUCCESS(Status))
        {
            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            printf("TcEnumerateInterfaces failed with error %d \n", Status);

            return FALSE;
        }
    }

    if(Size)
    {
        Status = TcOpenInterface(
            InterfaceBuffer->pInterfaceName,
            *ClientHandle,
            NULL,
            InterfaceHandle);

        if(!NT_SUCCESS(Status))
        {
            //
            printf("TcOpenInterface failed for interface %ws with Status %d \n",
                   InterfaceBuffer->pInterfaceName, Status);

            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            return FALSE;
        }

    }
    else
    {
        printf("No Traffic Interfaces \n");
        return FALSE;
    }

    return TRUE;
}


int __cdecl main(int argc, char **argv)
{

    HANDLE  ClientHandle, InterfaceHandle;
    BOOLEAN flags = 0;
    ULONG   mask, level;
    ULONG   DataSize;
    CHAR    *Buffer;

    if (argc < 2) goto usage;

    argv++; argc--;

    while( argc>0 && argv[0][0] == '-' )  {

        switch (argv[0][1])
        {

          case 'F':
          case 'f':
              flags |= FILE;
              break;

          case 'c':
          case 'C':
              flags |= CONFIG;
              break;

          case 'l':
          case 'L':
              if(sscanf(&argv[0][2], "%d", &level) == 1)
              {
                  if((ULONG)level > 10) 
                  {
                      goto usage;
                  }
                  flags |= LEVEL;
              }
              else 
              {
                 goto usage;
              }
              break;

          case 'm':
          case 'M':
              if(argv[0][2]!='0' && argv[0][3]!='x')
              {
                  goto usage;
              }

              if(sscanf(&argv[0][2], "%x", &mask) == 1)
              {
                   flags |= MASK;
              }
              else goto usage;

              break;

          default:
              goto usage;
        }
        argv++; argc--;
    }

    if((flags & CONFIG) && (flags & (FILE|LEVEL|MASK)))
    {
        goto usage;
    }

    if(TcInit(&ClientHandle, &InterfaceHandle))
    {
        ULONG size = sizeof(ULONG);
        ULONG chk;
        if(TcQueryInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           FALSE,
                           &size,
                           &chk) != STATUS_SUCCESS)
        {
            printf("Does not work on free bits \n");
        }

        if(flags & LEVEL)
        {

            TcSetInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_LEVEL,
                           sizeof(level),
                           &level);
        }

        if(flags & MASK)
        {
            printf("Setting Mask to 0x%x \n", mask);
            TcSetInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           sizeof(mask),
                           &mask);
        }

        if(flags & CONFIG)
        {
            TcQueryInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           FALSE,
                           &size,
                           &mask);

            TcQueryInterface(InterfaceHandle,
                             (LPGUID)&GUID_QOS_LOG_LEVEL,
                             FALSE,
                             &size,
                             &level);

            printf("Masks supported\n");
            printf("            DBG_INIT                0x00000001 \n");
            printf("            DBG_MINIPORT            0x00000002 \n");
            printf("            DBG_PROTOCOL            0x00000004 \n");
            printf("            DBG_SEND                0x00000008 \n");
            printf("            DBG_RECEIVE             0x00000010 \n");
            printf("            DBG_IO                  0x00000020 \n");
            printf("            DBG_MEMORY              0x00000040 \n");
            printf("            DBG_CM                  0x00000080 \n");
            printf("            DBG_REFCNTS             0x00000100 \n");
            printf("            DBG_VC                  0x00000200 \n");
            printf("            DBG_GPC_QOS             0x00000400 \n");
            printf("            DBG_WAN                 0x00000800 \n");
            printf("            DBG_STATE               0x00001000 \n");
            printf("            DBG_ROUTINEOIDS         0x00002000 \n");
            printf("            DBG_SCHED_TBC           0x00004000 \n");
            printf("            DBG_SCHED_SHAPER        0x00008000 \n");
            printf("            DBG_SCHED_DRR           0x00010000 \n");
            printf("            DBG_WMI                 0x00020000 \n");

            printf("\nLevels supported\n");
            printf("            DBG_DEATH               1\n");
            printf("            DBG_CRITICAL_ERROR      2\n");
            printf("            DBG_FAILURE             4\n");
            printf("            DBG_INFO                6\n");
            printf("            DBG_TRACE               8\n");
            printf("            DBG_VERBOSE             10\n");
            printf("\n Current Level is %d, Current Mask is 0x%x \n", level, mask);
        }

        if(flags & FILE)
        {
            ULONG Status;

            Status = TcQueryInterface(InterfaceHandle,
                                      (LPGUID)&GUID_QOS_LOG_THRESHOLD,
                                      FALSE,
                                      &size,
                                      &DataSize);

            DataSize *= 2;

            if(NT_SUCCESS(Status))
            {
                if(DataSize != 0)
                {
                    Buffer = (PCHAR) malloc(DataSize);

                    Status = TcQueryInterface(InterfaceHandle,
                                              (LPGUID)&GUID_QOS_LOG_DATA,
                                              FALSE,
                                              &DataSize,
                                              Buffer);
                    if(NT_SUCCESS(Status))
                    {
                        ParseBuffer(Buffer, DataSize);
                    }
                    else
                    {
                        printf("Query for the data buffer failed with status %d \n", Status);
                    }

                    free(Buffer);
                }
                else
                {
                    printf("No Data in buffer. \n");
                }
            }
            else
            {
                printf("Failed to read the sched bytes unread \n");
            }
        }

        TcDone(InterfaceHandle, ClientHandle);
    }

    return 0;

usage:
    printf("Usage %s [-f | -c | -m<0xmask> | -l<level> ] \n", argv[0]);
    printf("          -f          : dump the tt log on screen.                    \n");
    printf("          -c          : Print the current value of the mask and level \n");
    printf("          -m<0xvalue> : Set the mask to this value                    \n");
    printf("          -l<value>   : Set the level to this value (0-10)            \n");

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\adapter.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    adapter.h

Abstract:

    defines for adapter binding/unbinding routines

Author:

    Charlie Wickham (charlwi) 24-Apr-1996

Environment:

    Kernel Mode

Revision History:

--*/

/* External */

/* Static */

/* Prototypes */ 

//
// Protocol functions
//

VOID
CleanUpAdapter(
    IN      PADAPTER     Adapter);

VOID
ClBindToLowerMp(
    OUT     PNDIS_STATUS Status,
    IN      NDIS_HANDLE  BindContext,
    IN      PNDIS_STRING MpDeviceName,
    IN      PVOID        SystemSpecific1,
    IN      PVOID        SystemSpecific2
        );

VOID
ClLowerMpCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ClLowerMpOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
ClUnbindFromLowerMp(
    OUT PNDIS_STATUS Status,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    );

NDIS_STATUS
MpInitialize(
        OUT PNDIS_STATUS OpenErrorStatus,
        OUT PUINT        SelectedMediumIndex,
        IN  PNDIS_MEDIUM MediumArray,
        IN  UINT         MediumArraySize,
        IN  NDIS_HANDLE  MiniportAdapterHandle,
        IN  NDIS_HANDLE  WrapperConfigurationContext
        );

PADAPTER
FindAdapterByWmiInstanceName(
    USHORT   StringLength,
    PWSTR    StringStart,
    PPS_WAN_LINK *WanLink
    );


PADAPTER
FindAdapterById(
    ULONG   InterfaceId,
    ULONG   LinkId,
    PPS_WAN_LINK *PsWanLink
    );


VOID
DerefAdapter(
    PADAPTER Adapter,
    BOOLEAN  AdapterListLocked);

VOID
CleanupAdapter(
    PADAPTER Adapter
    );


VOID
ClUnloadProtocol(
    VOID
    );

VOID
MpHalt(
        IN      NDIS_HANDLE                             MiniportAdapterContext
        );

NDIS_STATUS
MpReset(
        OUT PBOOLEAN                            AddressingReset,
        IN      NDIS_HANDLE                             MiniportAdapterContext
        );

NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    );

NDIS_STATUS
UpdateWanSchedulingPipe(PPS_WAN_LINK WanLink);

HANDLE
GetNdisPipeHandle (
    IN HANDLE PsPipeContext
    );

NDIS_STATUS
UpdateAdapterBandwidthParameters(
    PADAPTER Adapter
    );

NDIS_STATUS
FindSchedulingComponent(
    PNDIS_STRING ComponentName,
    PPSI_INFO *Component
    );

VOID 
PsAdapterWriteEventLog(
	IN	NDIS_STATUS	 EventCode,
	IN	ULONG		 UniqueEventValue,
	IN  PNDIS_STRING String,
	IN	ULONG		 DataSize,
	IN	PVOID		 Data		OPTIONAL
    );

VOID
PsGetLinkSpeed(
    IN PADAPTER Adapter
);

VOID
PsUpdateLinkSpeed(
    PADAPTER      Adapter,
    ULONG         RawLinkSpeed,
    PULONG        RemainingBandWidth,
    PULONG        LinkSpeed,
    PULONG        NonBestEffortLimit,
    PPS_SPIN_LOCK Lock
);



/* End Prototypes */

/* end adapter.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\adapter.c ===
/*++
Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    routines for binding/unbinding to/from underlying miniport drivers

Author:
    Charlie Wickham (charlwi)  24-Apr-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* Defines */


/* External */

/* Static */

#define DRIVER_COUNTED_BLOCK             \
{                                        \
    ++DriverRefCount;                    \
    NdisResetEvent(&DriverUnloadEvent);  \
}

#define DRIVER_COUNTED_UNBLOCK                     \
        {                                          \
            PS_LOCK(&DriverUnloadLock);            \
            if( --DriverRefCount == 0)             \
                NdisSetEvent(&DriverUnloadEvent);  \
            PS_UNLOCK(&DriverUnloadLock);          \
        } 

/* Forward */ 

NDIS_STATUS
PsInitializeDeviceInstance(PADAPTER Adapter);

NDIS_STATUS
GetFrameSize(
    PADAPTER Adapter
    );

NDIS_STATUS
InitializeAdapter(
    PADAPTER Adapter, 
    NDIS_HANDLE BindContext, 
    PNDIS_STRING MpDeviceName, 
    PVOID SystemSpecific1);

NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    );

VOID
DeleteAdapter(PVOID Adapter, BOOLEAN AdapterListLocked);

VOID
ClUnloadProtocol(
    VOID
    );

VOID
MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );


NDIS_STATUS
GetSchedulerPipeContext(
    PADAPTER Adapter,
    PPS_PIPE_CONTEXT *AdapterPipeContext,
    PPSI_INFO *AdapterPsComponent,
    PULONG ShutdownMask
    );

NDIS_STATUS
FindProfile(
    IN PNDIS_STRING ProfileName,
    OUT PPS_PROFILE *Profile
    );

NDIS_STATUS
RegisterPsComponent(
    IN PPSI_INFO PsiComponentInfo,
    ULONG Size,
    PPS_DEBUG_INFO DebugInfo
    );

NDIS_STATUS
FindSchedulingComponent(
    IN PNDIS_STRING ComponentName,
    OUT PPSI_INFO *Component
    );

NDIS_STATUS
PsReadMiniportOIDs(
    IN  PADAPTER Adapter
    );

VOID
CloseAllGpcVcs(
    IN PADAPTER Adapter);

/* End Forward */


NTSTATUS
PsIoctl(
        IN      PDEVICE_OBJECT  pdo,
        IN      PIRP            pirp
        )
{
    PIO_STACK_LOCATION     pirpSp;
    ULONG                  ioControlCode;
    PLIST_ENTRY            NextAdapter;
    PADAPTER               Adapter;
    NTSTATUS               Status ;
    PGPC_CLIENT_VC         Vc;
    PLIST_ENTRY            NextVc;
    PPS_WAN_LINK           WanLink;
    
    PVOID                   pIoBuf;
    ULONG                   InputBufferLength;
    ULONG                   OutputBufferLength;

    USHORT				    Port = 0;
    ULONG				    Ip = 0;
    PTIMESTMP_REQ           pTsReq = NULL;


#if DBG
    KIRQL                   OldIrql;
    KIRQL                   NewIrql;
    OldIrql = KeGetCurrentIrql();
#endif

    pirpSp        = IoGetCurrentIrpStackLocation(pirp);
    ioControlCode = pirpSp->Parameters.DeviceIoControl.IoControlCode;

    pirp->IoStatus.Status      = Status = STATUS_SUCCESS;
    pirp->IoStatus.Information = 0;

    /* Both input and output buffers are mapped to "SystemBuffer" in case of direct-IO */
    pIoBuf      = pirp->AssociatedIrp.SystemBuffer;

    InputBufferLength  	= pirpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength 	= pirpSp->Parameters.DeviceIoControl.OutputBufferLength;

    switch(pirpSp->MajorFunction)
    {
        case IRP_MJ_DEVICE_CONTROL:

            switch (ioControlCode) 
            {
                case IOCTL_PSCHED_ZAW_EVENT:

                    while(InterlockedExchange(&gZAWState, ZAW_STATE_IN_USE) != ZAW_STATE_READY)
                    {
                        //
                        // Some other thread is in this loop. Let's wait 
                        //
                        NdisResetEvent(&gZAWEvent);
                        NdisWaitEvent(&gZAWEvent, 0);
                    }

                    PsReadDriverRegistryData();
                   
                    //
                    // Handle the per adapter settings.
                    //
            
                    PS_LOCK(&AdapterListLock);
            
                    NextAdapter = AdapterList.Flink;

                    while(NextAdapter != &AdapterList) 
                    {
                        Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
                        
                        PS_LOCK_DPC(&Adapter->Lock);
            
                        if(Adapter->PsMpState != AdapterStateRunning)
                        {
                            PS_UNLOCK_DPC(&Adapter->Lock);

                            NextAdapter = NextAdapter->Flink;

                            continue;
                        }
                        
                        REFADD(&Adapter->RefCount, 'IOTL'); 
            
                        PS_UNLOCK_DPC(&Adapter->Lock);

                        PS_UNLOCK(&AdapterListLock);
            
                        PsReadAdapterRegistryData(Adapter,
                                                  &MachineRegistryKey,
                                                  &Adapter->RegistryPath
                                                  );
                        //
                        // This will apply the effects of the following registry parameters.
                        //
                        // NonBestEffortLimit
                        // TimerResolution (since we update the scheduling pipe)
                        //

                        if(Adapter->MediaType != NdisMediumWan)
                        {
                            UpdateAdapterBandwidthParameters(Adapter);
                            
                            //
                            // Set 802.1p/TOS for b/e Vc
                            //
                            Adapter->BestEffortVc.UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
                            Adapter->BestEffortVc.UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
                            Adapter->BestEffortVc.IPPrecedenceNonConforming = Adapter->IPServiceTypeBestEffortNC;
                        }
                        else
                        {
                            PS_LOCK(&Adapter->Lock);
                            
                            NextVc = Adapter->WanLinkList.Flink;
                            
                            while( NextVc != &Adapter->WanLinkList)
                            {
                                WanLink = CONTAINING_RECORD(NextVc, PS_WAN_LINK, Linkage);
                                
                                PS_LOCK_DPC(&WanLink->Lock);
                                
                                WanLink->BestEffortVc.UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
                                WanLink->BestEffortVc.UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
                                WanLink->BestEffortVc.IPPrecedenceNonConforming = 
                                    Adapter->IPServiceTypeBestEffortNC;
                                
                                if(WanLink->State == WanStateOpen)
                                {
                                    REFADD(&WanLink->RefCount, 'IOTL');
                                    
                                    PS_UNLOCK_DPC(&WanLink->Lock);
                                    
                                    PS_UNLOCK(&Adapter->Lock);
                                    
                                    UpdateWanLinkBandwidthParameters(WanLink);
                                    
                                    PS_LOCK(&Adapter->Lock);
                                    
                                    NextVc = NextVc->Flink;
                                    
                                    REFDEL(&WanLink->RefCount, TRUE, 'IOTL');
                                    
                                }
                                else 
                                {
                                    PS_UNLOCK_DPC(&WanLink->Lock);
                                    
                                    NextVc = NextVc->Flink;
                                    
                                }
                            }
                            
                            PS_UNLOCK(&Adapter->Lock);
                            
                        }

                        //
                        // Apply the new TOS/802.1p mapping to the VCs.
                        //
                        PS_LOCK(&Adapter->Lock);
                        
                        NextVc = Adapter->GpcClientVcList.Flink;
                        
                        while ( NextVc != &Adapter->GpcClientVcList )
                        {
                            
                            Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);
                            
                            NextVc = NextVc->Flink;
                            
                            PS_LOCK_DPC(&Vc->Lock);
                            
                            if(Vc->ClVcState == CL_CALL_COMPLETE          ||
                               Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE )
                            {
                                SetTOSIEEEValues(Vc);
                            }
                            
                            PS_UNLOCK_DPC(&Vc->Lock);
                        }
                        
                        PS_UNLOCK(&Adapter->Lock);

                        PS_LOCK(&AdapterListLock);

                        NextAdapter = NextAdapter->Flink;
                   
                        REFDEL(&Adapter->RefCount, TRUE, 'IOTL'); 
                    
                    }
                
                    PS_UNLOCK(&AdapterListLock);

                    InterlockedExchange(&gZAWState, ZAW_STATE_READY);
                    NdisSetEvent(&gZAWEvent);

                    break;

                default:
                    Status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;
        
        case IRP_MJ_CREATE:
            break;
                
        case IRP_MJ_CLOSE:
            break;

        case IRP_MJ_CLEANUP:
            break;

        case IRP_MJ_READ:
            break;

        case IRP_MJ_SHUTDOWN:
            break;            
                
        default:
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    if( Status == STATUS_SUCCESS)
    {
        pirp->IoStatus.Status      = Status;
        IoCompleteRequest(pirp, IO_NETWORK_INCREMENT);
    }
    else
    {
        pirp->IoStatus.Status = Status;
        IoCompleteRequest(pirp, IO_NO_INCREMENT);
    }

    PsAssert( OldIrql == KeGetCurrentIrql());

    return Status;
}

NDIS_STATUS
PsIoctlInit()
{
    int                 i;
    NDIS_STATUS         Status;
    PDRIVER_DISPATCH    DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];

    for(i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DispatchTable[i] = PsIoctl;
    }

    DispatchTable[IRP_MJ_SYSTEM_CONTROL] = WMIDispatch;

    Status = NdisMRegisterDevice(MpWrapperHandle,
                                 &PsDriverName,
                                 &PsSymbolicName,
                                 DispatchTable,
                                 &PsDeviceObject,
                                 &PsDeviceHandle);

    if(Status == NDIS_STATUS_SUCCESS) 
    {
        InitShutdownMask |= SHUTDOWN_DELETE_DEVICE;

        PsDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        IoWMIRegistrationControl(PsDeviceObject, WMIREG_ACTION_REGISTER);
    }
    else 
    {
        PsDeviceHandle = PsDeviceObject = 0;
    }
    return Status;

}

VOID
PsAddDevice()
{
    //
    // The first Adapter will create the DeviceObject which will enable us to receive 
    // irps and become a WMI data provider. The last DeviceObject will unregister from
    // WMI and delete the DeviceObject. 
    //

    MUX_ACQUIRE_MUTEX( &CreateDeviceMutex );

    ++AdapterCount;

    if(AdapterCount == 1) 
    {
        //
        // This is the first adapter, so we create a DeviceObject
        // that allows us to get irps and registers as a WMI data
        // provider.

        PsIoctlInit();
    }

    MUX_RELEASE_MUTEX( &CreateDeviceMutex);
}

NDIS_STATUS
PsInitializeDeviceInstance(PADAPTER Adapter)
{
    NDIS_STATUS Status;

    PsAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL,
             ("[PSInitializeDeviceInstance]: Adapter %08X, InitializeDeviceInstance with %ws \n",
              Adapter, 
              Adapter->UpperBinding.Buffer));
        
    Status = NdisIMInitializeDeviceInstanceEx(LmDriverHandle,
                                              &Adapter->UpperBinding,
                                              Adapter);
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("[PsInitializeDeviceInstance]: Adapter %08X, can't init PS device (%08X)\n",
                  Adapter, 
                  Status));
        
        PsAdapterWriteEventLog(
            EVENT_PS_INIT_DEVICE_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);
        
    }
    
    return Status;
}

VOID
PsDeleteDevice()
{
    //
    // The first Adapter will create the DeviceObject which will enable us to receive 
    // irps and become a WMI data provider. The last DeviceObject will unregister from
    // WMI and delete the DeviceObject. In order to prevent a race condition we prevent 
    // any mpinitialize threads from looking at the AdapterCount. This is achieved by 
    // re-setting the WMIAddEvent. It is not sufficient just to do this based on 
    // interlocked operations on AdapterCount.
    //

    MUX_ACQUIRE_MUTEX( &CreateDeviceMutex );

    --AdapterCount;
    
    if(AdapterCount == 0) 
    {
        //
        // Delete the DeviceObject, since this is the last Adapter.
        //
        
        if(PsDeviceObject) 
        {
            IoWMIRegistrationControl(PsDeviceObject, WMIREG_ACTION_DEREGISTER);
            
            NdisMDeregisterDevice(PsDeviceHandle);
            
            PsDeviceHandle = PsDeviceObject = 0;
        }
    }

    MUX_RELEASE_MUTEX( &CreateDeviceMutex);
}


// No of retries to query the frame size
#define	MAX_GET_FRAME_SIZE_RETRY_COUNT	3
#define	WAIT_TIME_FOR_GET_FRAME_SIZE	3



VOID
ClBindToLowerMp(
    OUT     PNDIS_STATUS                    Status,
    IN      NDIS_HANDLE                     BindContext,
    IN      PNDIS_STRING                    MpDeviceName,
    IN      PVOID                           SystemSpecific1,
    IN      PVOID                           SystemSpecific2
    )

/*++

Routine Description:

    Bind to the underlying MP. Allocate space for an adapter structure,
    initializing its fields. Try to open the adapter indicated in MpDeviceName.

Arguments:

    Status          : Placeholder for the driver to return a Status to NDIS.

    BindContext     : Handle represents NDIS's context for the bind request. 
                      This has to be saved and returned when we call 
                      NdisCompleteBindAdapter

    SystemSpecific1 : Points to a registy path for the driver to obtain adapter 
                      specific configuration.
                      
    MpDeviceName    : DeviceName can refer to a NIC managed by an underlying NIC 
                      driver, or it can be the name of a virtual NIC exported by 
                      an intermediate NDIS driver that is layered between the 
                      called intermediate driver and the NIC driver managing the 
                      adapter to which transmit requests are directed. 

    SystemSpecific2 : Unused, reserved for future use.


Return Values:

    None

--*/

{
    PADAPTER    Adapter;
    NDIS_STATUS OpenAdapterStatus;
    NDIS_STATUS OpenErrorStatus;
    NDIS_STATUS LocalStatus;
    UINT        MediaIndex;
    NDIS_MEDIUM MediumArray[] = {
        NdisMediumFddi,
        NdisMedium802_5,
        NdisMedium802_3,
        NdisMediumWan
        };
    UINT        MediumArraySize = sizeof(MediumArray)/sizeof(NDIS_MEDIUM);
    UINT		GetFrameSizeRetryCount = 0;

    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL | DBG_INIT, 
             ("[ClBindToLowerMp]: MpDeviceName %ws\n", MpDeviceName->Buffer));


    PS_LOCK(&DriverUnloadLock);

    //
    // (a) The driver can get unloaded before we complete the bind thread. 
    // (b) we can get bound as the driver is getting unloaded. 
    //
    // if (a) happens, we block the driver unload and unblock when we finish the bind.
    // if (b) happens, we fail the bind call.

    if(gDriverState != DriverStateLoaded) {

        *Status = NDIS_STATUS_FAILURE;

        PS_UNLOCK(&DriverUnloadLock);

        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL|DBG_INIT, 
                 ("[ClBindToLowerMp]: Driver is being unloaded \n"));

        return;
    }

    DRIVER_COUNTED_BLOCK;

    PS_UNLOCK(&DriverUnloadLock);

    //
    // Get a new adapter context struct and initialize it with configuration
    // data from the registry.
    //

    PsAllocatePool(Adapter, sizeof(ADAPTER), AdapterTag);

    if(Adapter == NULL) {

        PsAdapterWriteEventLog(
            (ULONG)EVENT_PS_RESOURCE_POOL,
            0,
            MpDeviceName,
            0,
            NULL);

        *Status = NDIS_STATUS_RESOURCES;

        DRIVER_COUNTED_UNBLOCK;

        return;
    }

    // 
    // Initialize the adapter. 
    //

    *Status = InitializeAdapter(Adapter, BindContext, MpDeviceName, SystemSpecific1);

    Adapter->ShutdownMask |= SHUTDOWN_BIND_CALLED;

    if(*Status != NDIS_STATUS_SUCCESS) {

        PsDeleteDevice();

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

        DRIVER_COUNTED_UNBLOCK;

        return;
    }


    NdisOpenAdapter(&OpenAdapterStatus,
                    &OpenErrorStatus,
                    &Adapter->LowerMpHandle,
                    &MediaIndex,
                    MediumArray,
                    MediumArraySize,
                    ClientProtocolHandle,
                    Adapter,
                    MpDeviceName,
                    0,
                    NULL);

    if(OpenAdapterStatus == NDIS_STATUS_PENDING)
    {
        NdisWaitEvent(&Adapter->BlockingEvent, 0);
        NdisResetEvent(&Adapter->BlockingEvent);

    } 
    else 
    {
        Adapter->FinalStatus = OpenAdapterStatus;
    }

    if(Adapter->FinalStatus == NDIS_STATUS_SUCCESS)
    {
        Adapter->MediaType = MediumArray[MediaIndex];

        //
        // Take a ref for the open
        //
        REFADD(&Adapter->RefCount, 'NDOP');
        
    }
    else 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_PROTOCOL,
                 ("[ClBindToLowerMp]: Adapter %08X, binding failed (Status = %08X) \n", 
                  Adapter, 
                  Status));

        *Status = Adapter->FinalStatus;

        PsAdapterWriteEventLog(
            EVENT_PS_BINDING_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Adapter->FinalStatus),
            &Adapter->FinalStatus);

        PsDeleteDevice();

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

        DRIVER_COUNTED_UNBLOCK;

        return;
    }

    //
    // Get the information pertaining to the miniport below us.
    //


    while(1)
   {
	    *Status = GetFrameSize(Adapter);

	    if(*Status != NDIS_STATUS_SUCCESS) 
	    {
	    	if( GetFrameSizeRetryCount == MAX_GET_FRAME_SIZE_RETRY_COUNT)
	      {
	        	goto ErrorCloseOpen;
	      }        	
	    	else
	      {
	    		GetFrameSizeRetryCount++;
	    		NdisMSleep( WAIT_TIME_FOR_GET_FRAME_SIZE * 1000 * 1000);
		}    		
	    }
	    else
          {
          	break;
	    }
    }
   
    Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
    
    *Status = UpdateAdapterBandwidthParameters(Adapter);
    
    if(*Status != NDIS_STATUS_SUCCESS)
    {
        if(*Status != NDIS_STATUS_ADAPTER_NOT_READY)
        {
            PsDbgOut(DBG_FAILURE, 
                     DBG_PROTOCOL | 
                     DBG_INIT,
                     ("[ClBindToLowerMp]: Adapter %08X, couldn't add pipe %08X\n",
                      Adapter, 
                      Status));
            
            goto ErrorCloseOpen;
        }
        else 
        {
            // The scheduling components have not registered. Let's not call NdisIMInitializeDeviceInstance.
            //
            *Status = NDIS_STATUS_SUCCESS;
            
            Adapter->PsMpState = AdapterStateWaiting;
        }
    	}

    // Let's move the creation of IM device here, to see what happens.
    *Status = PsInitializeDeviceInstance(Adapter);

    if(*Status != NDIS_STATUS_SUCCESS)
    {
    	goto ErrorCloseOpen;
    }

   // Ignore the status
    PsReadMiniportOIDs(Adapter);

    PsUpdateLinkSpeed(Adapter, Adapter->RawLinkSpeed,
                      &Adapter->RemainingBandWidth,
                      &Adapter->LinkSpeed,
                      &Adapter->NonBestEffortLimit,
                      &Adapter->Lock);


// This will repro the NetReady bug anywhere, anytime.
//	NdisMSleep( 5 * 1000 * 1000 );

    REFDEL(&Adapter->RefCount, FALSE, 'NDOP');


    DRIVER_COUNTED_UNBLOCK;

    return;

ErrorCloseOpen:


    // 
    // if we have opened an underlying call manager, close it now.
    //
    
    if(Adapter->MediaType == NdisMediumWan) {

        PS_LOCK(&Adapter->Lock);

        if(Adapter->ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY){

            Adapter->ShutdownMask &= ~SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

            PS_UNLOCK(&Adapter->Lock);
            
            PsDbgOut(DBG_TRACE, DBG_WAN | DBG_MINIPORT,
                     ("[ClBindToLowerMp]: Adapter %08X Closing the WAN address family", Adapter));
            
            LocalStatus = NdisClCloseAddressFamily(Adapter->WanCmHandle);
            
        }
        else
        {
            PS_UNLOCK(&Adapter->Lock);
        }
    }

    //
    // Close the open since we opened it above
    //

    if(Adapter->LowerMpHandle) 
    {
        NdisCloseAdapter(&LocalStatus, Adapter->LowerMpHandle);
        
        if(LocalStatus == NDIS_STATUS_PENDING) 
        {
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            
            NdisResetEvent(&Adapter->BlockingEvent);
        }
       
        REFDEL(&Adapter->RefCount, FALSE, 'NDOP'); 
        
    }

    PsDeleteDevice();

    REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

    DRIVER_COUNTED_UNBLOCK;

    return;

} // ClBindToLowerMp


VOID
LinkSpeedQueryComplete(
    PADAPTER Adapter,
    NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for link speed query during a status indication. Notify
    the scheduling alg. that we have a new adapter

Arguments:

    the usual...

Return Value:

    None

--*/

{
    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL,
             ("[LinkSpeedQueryComplete]: Adapter %08X, Status %x, Link speed %d\n", 
              Adapter, Status, 
              Adapter->LinkSpeed*100));
    
    if ( !NT_SUCCESS( Status )) 
    {
        Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_LINK_SPEED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);
        
    }
          
    UpdateAdapterBandwidthParameters(Adapter);
}

VOID
PsGetLinkSpeed (
    IN PADAPTER Adapter
)
{
    NDIS_STATUS Status;

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_LINK_SPEED,
                                  &Adapter->RawLinkSpeed,
                                  sizeof(Adapter->RawLinkSpeed),
                                  LinkSpeedQueryComplete);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        LinkSpeedQueryComplete(Adapter, Status);
    }
}


NDIS_STATUS
PsReadMiniportOIDs(
    IN  PADAPTER Adapter
    )

/*++

Routine Description:

    Complete the binding on the lower miniport. Initialize the 
    adapter structure, query the MP for certain funtionality and 
    initialize the associated PS miniport device

Arguments:

    see the DDK

Return Values:

    None

--*/

{
    NDIS_STATUS          Status;
    PWSTR                SecondaryName;
    NDIS_HARDWARE_STATUS HwStatus;
    NDIS_MEDIA_STATE     MediaState = 0xFFFFFFFF;
    NDIS_STRING          PsDevName;
    ULONG                MacOptions;
    ULONG                LinkSpeed;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("[PsReadMiniportOIDs]: Adapter %08X \n", Adapter));


    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MEDIA_CONNECT_STATUS,
                                  &MediaState,
                                  sizeof( MediaState ),
                                  NULL);
   
    PsAssert(Status != NDIS_STATUS_INVALID_OID || Status != NDIS_STATUS_NOT_SUPPORTED);

    if(Status == NDIS_STATUS_SUCCESS && MediaState == NdisMediaStateConnected){
    
        Status = MakeLocalNdisRequest(Adapter,
                                      NULL,
                                      NdisRequestLocalQueryInfo,
                                      OID_GEN_LINK_SPEED,
                                      &Adapter->RawLinkSpeed,
                                      sizeof(LinkSpeed),
                                      NULL);
        if(Status != NDIS_STATUS_SUCCESS){ 
            
            PsDbgOut(DBG_INFO, 
                     DBG_PROTOCOL,
                     ("[PsReadMiniportOIDs]: Adapter %08X, Can't get link "
                      "speed - Status %08X\n", Adapter, Status));
            
            Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;

            PsAdapterWriteEventLog(
                EVENT_PS_QUERY_OID_GEN_LINK_SPEED,
                0,
                &Adapter->MpDeviceName,
                sizeof(Status),
                &Status);
        }
        
        PsDbgOut(DBG_INFO, 
                 DBG_PROTOCOL, 
                 ("[PsReadMiniportOIDs] Adapter %08X, Link speed %d\n",
                  Adapter, 
                  Adapter->RawLinkSpeed*100));
    } 
    else{

        //
        // We can continue, even though we don't yet have the 
        // link speed. We'll update it later.
        //
        
        Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
        
        PsDbgOut(DBG_INFO, 
                 DBG_PROTOCOL,
                 ("[PsReadMiniportOIDs]: Adapter %08X, Media not connected\n",
                  Adapter));
        
    }
 
    return Status;

} // PsReadMiniportOIDs

VOID
PsUpdateLinkSpeed(
    PADAPTER      Adapter,
    ULONG         RawLinkSpeed,
    PULONG        RemainingBandWidth,
    PULONG        LinkSpeed,
    PULONG        NonBestEffortLimit,
    PPS_SPIN_LOCK Lock
)
{
    ULONG              NewNonBestEffortLimit;

    PS_LOCK(Lock);

    if(RawLinkSpeed == UNSPECIFIED_RATE)
    {

        //
        // It is legit to have an unspecified rate - We pend
        // all finite rate flows till we know the link speed.
        // Indefinite rate flows will be admitted.
        //
        
        *LinkSpeed = UNSPECIFIED_RATE;
        Adapter->PipeHasResources = FALSE;
    }
    else 
    {
        //
        // RawLinkSpeed is in 100 bps units. Convert it to 100 Bytes per second
        // and then into Bytes Per Second.
        //
        *LinkSpeed = RawLinkSpeed / 8;
        *LinkSpeed = (ULONG)(*LinkSpeed * 100); 
        
        PsDbgOut(DBG_TRACE, DBG_PROTOCOL, 
                 ("[PsUpdateLinkSpeed]: Adapter %08X, Link Speed %d \n", 
                  Adapter, *LinkSpeed)); 
        
        Adapter->PipeHasResources = TRUE;
        
        //
        // The NBE is a % of the link speed. If the link speed changes, we need to
        // change this value.
        //
        
        NewNonBestEffortLimit = Adapter->ReservationLimitValue * (*LinkSpeed / 100);
        
        PsDbgOut(DBG_INFO, DBG_PROTOCOL,
                 ("[PsUpdateLinkSpeed]: Adapter %08X, LinkSpeed %d, NBE %d, "
                  " Remaining b/w = %d, New NBE = %d \n",
                  Adapter, *LinkSpeed, *NonBestEffortLimit, 
                  *RemainingBandWidth, NewNonBestEffortLimit));
        
        if(NewNonBestEffortLimit >= *NonBestEffortLimit) {
            
            //
            // The bandwidth has increased - we need not do anything with
            // the flows that have already been created. Also, if RemainingBandWidth < 
            // NonBestEffortLimit, then some of the resources have been allocated to flows
            // that were already created - We need to subtract this from the new 
            // RemainingBandWidth.
            //
            
            *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
            
            *NonBestEffortLimit = NewNonBestEffortLimit;
        }
        else {
            
            //
            // Sigh. The bandwidth has decreased. We may need to delete some of the flows
            //
            
            if(*RemainingBandWidth == *NonBestEffortLimit) 
            {
                
                //
                // No flows were created as yet - Just update the 2 values
                //
                *NonBestEffortLimit = *RemainingBandWidth = NewNonBestEffortLimit;
            }
            else {
                if((*NonBestEffortLimit - *RemainingBandWidth) <= (NewNonBestEffortLimit)) {
                    
                    //
                    // The flows that were created are under the new limit.
                    //
                    
                    *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
                    
                    *NonBestEffortLimit = NewNonBestEffortLimit;
                }
                else 
                {
                    *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
                    *NonBestEffortLimit = NewNonBestEffortLimit;

                    PsAdapterWriteEventLog(
                        EVENT_PS_ADMISSIONCONTROL_OVERFLOW,
                        0,
                        &Adapter->MpDeviceName,
                        0,
                        NULL);
                }
            }
            
        }

    }

    PS_UNLOCK(Lock);
}


NDIS_STATUS
UpdateAdapterBandwidthParameters(
    PADAPTER Adapter
    )

{
    PsUpdateLinkSpeed(Adapter, Adapter->RawLinkSpeed,
                      &Adapter->RemainingBandWidth,
                      &Adapter->LinkSpeed,
                      &Adapter->NonBestEffortLimit,
                      &Adapter->Lock);

    return UpdateSchedulingPipe(Adapter);
}



VOID
ClLowerMpOpenAdapterComplete(
    IN  PADAPTER Adapter,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    Signal that the binding on the lower miniport is complete

Arguments:

    see the DDK

Return Values:

    None

--*/

{

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("[ClLowerMpOpenAdapterComplete]: Adapter %08X\n", 
                                       Adapter));

    //
    // stuff the final status in the Adapter block and signal 
    // the bind handler to continue
    //

    Adapter->FinalStatus = Status;
    NdisSetEvent( &Adapter->BlockingEvent );

} // ClLowerMpOpenAdapterComplete


NDIS_STATUS
GetFrameSize(
    PADAPTER Adapter
    )

/*++

Routine Description:

    This routine queries the underlying adapter to derive the total
    frame size and the header size. (Total = Frame + Header)

Arguments:

    Adapter - pointer to adapter context block

Return Value:

    None

--*/

{
    NDIS_STATUS Status;
    ULONG       i;
    ULONG       FrameSize;            // doesn't include the header

    //
    // max amount of data w/o the MAC header
    //

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MAXIMUM_FRAME_SIZE,
                                  &FrameSize,
                                  sizeof(FrameSize),
                                  NULL);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("[GetFrameSize]: Adapter %08X, Can't get frame size - Status %08X\n",
                 Adapter, 
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        return Status;
    }

    //
    // this one includes the header
    //

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MAXIMUM_TOTAL_SIZE,
                                  &Adapter->TotalSize,
                                  sizeof(Adapter->TotalSize),
                                  NULL);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("(%08X) GetFrameSize: Can't get total size - Status %08X\n",
                 Adapter, 
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        return Status;

    }

    //
    // figure the real header size
    //

    if (Adapter->TotalSize <= FrameSize)
        Status = NDIS_STATUS_FAILURE;
    else
        Adapter->HeaderSize = Adapter->TotalSize - FrameSize;

    return Status;

}   // GetFrameSize


NDIS_STATUS
GetSchedulerPipeContext(
    PADAPTER Adapter,
    PPS_PIPE_CONTEXT *AdapterPipeContext,
    PPSI_INFO *AdapterPsComponent,
    PULONG  ShutdownMask
    )

/*++

Routine Description:

    Allocate the pipe context area for the scheduler.

Arguments:

    Adapter - pointer to adapter context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    ULONG            Index = 0;
    PPS_PROFILE      ProfileConfig;
    PPSI_INFO        PsComponent;
    ULONG            ContextLength = 0;
    ULONG            FlowContextLength = 0;
    ULONG            ClassMapContextLength = 0;
    PPS_PIPE_CONTEXT PipeContext, PrevContext;
    ULONG            PacketReservedLength = sizeof(PS_SEND_PACKET_CONTEXT);
    PVOID            PipeCxt;

    ProfileConfig  = &DefaultSchedulerConfig;

    for (Index = 0; Index < ProfileConfig->ComponentCnt; Index++) 
    {
        ContextLength += 
            ProfileConfig->ComponentList[Index]->PipeContextLength;
        FlowContextLength += 
            ProfileConfig->ComponentList[Index]->FlowContextLength;
        ClassMapContextLength +=
            ProfileConfig->ComponentList[Index]->ClassMapContextLength;

        PacketReservedLength += ProfileConfig->ComponentList[Index]->PacketReservedLength;
    }

    Adapter->FlowContextLength = FlowContextLength;
    Adapter->ClassMapContextLength = ClassMapContextLength;
    Adapter->PacketContextLength = PacketReservedLength;

    if(AdapterPipeContext)
    {
        PacketReservedLength = sizeof(PS_SEND_PACKET_CONTEXT);

        PsAllocatePool( PipeContext, ContextLength, PipeContextTag );

        *AdapterPipeContext = PipeContext;

        if ( *AdapterPipeContext == NULL ) {
    
            return NDIS_STATUS_RESOURCES;
        }

        *ShutdownMask |= SHUTDOWN_FREE_PS_CONTEXT;
    
        // Set up the context buffer
    
        PrevContext = NULL;
    
        for (Index = 0; Index < ProfileConfig->ComponentCnt; Index++) 
        {
            PsComponent = ProfileConfig->ComponentList[Index];
     
            PipeContext->NextComponentContext = (PPS_PIPE_CONTEXT)
                ((UINT_PTR)PipeContext + PsComponent->PipeContextLength);
            PipeContext->PrevComponentContext = PrevContext;
    
            if(Index+1 == ProfileConfig->ComponentCnt)
            {
                PipeContext->NextComponent = 0;
            }
            else 
            {
                PipeContext->NextComponent = 
                    ProfileConfig->ComponentList[Index + 1];
            }
    
            if (PsComponent->PacketReservedLength > 0) 
            {
                PipeContext->PacketReservedOffset = PacketReservedLength;
                PacketReservedLength += 
                PsComponent->PacketReservedLength;
            } else 
            {
                PipeContext->PacketReservedOffset = 0;
            }

            PrevContext = PipeContext;
            PipeContext = PipeContext->NextComponentContext;
        }

        *AdapterPsComponent = ProfileConfig->ComponentList[0];
    }
    

    return NDIS_STATUS_SUCCESS;


} // GetSchedulerPipeContext

NDIS_STATUS
UpdateWanSchedulingPipe(PPS_WAN_LINK WanLink)
{
     NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;
     PS_PIPE_PARAMETERS PipeParameters;
     PADAPTER           Adapter = WanLink->Adapter;
 
     // 
     // Initialize pipe parameters.
     // UNSPECIFIED_RATE indicates that the link speed is currently
     // unknown. This is a legitimate initialization value.
     //

     PS_LOCK(&Adapter->Lock);

     PS_LOCK_DPC(&WanLink->Lock);

     PipeParameters.Bandwidth            = WanLink->LinkSpeed;
     PipeParameters.MTUSize              = Adapter->TotalSize;
     PipeParameters.HeaderSize           = Adapter->HeaderSize;
     PipeParameters.Flags                = Adapter->PipeFlags;
     PipeParameters.MaxOutstandingSends  = Adapter->MaxOutstandingSends;
     PipeParameters.SDModeControlledLoad = Adapter->SDModeControlledLoad;
     PipeParameters.SDModeGuaranteed     = Adapter->SDModeGuaranteed;
     PipeParameters.SDModeNetworkControl = Adapter->SDModeNetworkControl;
     PipeParameters.SDModeQualitative    = Adapter->SDModeQualitative;
     PipeParameters.RegistryPath         = &Adapter->RegistryPath;
 
     PS_UNLOCK_DPC(&WanLink->Lock);

     PS_UNLOCK(&Adapter->Lock);
 
     //
     // Initialize the pipe for only the first time
     //
 
     if ( !(WanLink->ShutdownMask & SHUTDOWN_DELETE_PIPE )) {
 
         //
         // Allocate and initialize the context buffer for the scheduler.
         //
 
         Status = GetSchedulerPipeContext( Adapter, 
                                           &WanLink->PsPipeContext, 
                                           &WanLink->PsComponent, 
                                           &WanLink->ShutdownMask );

         if ( !NT_SUCCESS( Status )) 
         {
             return Status;
         }

         WanLink->BestEffortVc.PsPipeContext = WanLink->PsPipeContext;
         WanLink->BestEffortVc.PsComponent   = WanLink->PsComponent;

        // Need to set the pipe's media type here.. //
         PipeParameters.MediaType = NdisMediumWan;
 
         Status = (*WanLink->PsComponent->InitializePipe)(
             Adapter,
             &PipeParameters,
             WanLink->PsPipeContext,
             &PsProcs,
             NULL);
 
         if (NT_SUCCESS(Status))
         {
             WanLink->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
         }
 
     }
     else{
 
         // Pipe's already been initialized. This is a modify
 
         Status = (*WanLink->PsComponent->ModifyPipe)(
             WanLink->PsPipeContext,
             &PipeParameters);
     }
 
     return Status;
  
}



NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    )

/*++

Routine Description:

    Initialize a scheduling pipe on the adapter. Always called with a LOCK
    held.

Arguments:

    Adapter - pointer to adapter context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;
    PS_PIPE_PARAMETERS PipeParameters;

    // 
    // Initialize pipe parameters.
    // UNSPECIFIED_RATE indicates that the link speed is currently
    // unknown. This is a legitimate initialization value.
    //
    PS_LOCK(&Adapter->Lock);

    PipeParameters.Bandwidth            = Adapter->LinkSpeed;
    PipeParameters.MTUSize              = Adapter->TotalSize;
    PipeParameters.HeaderSize           = Adapter->HeaderSize;
    PipeParameters.Flags                = Adapter->PipeFlags;
    PipeParameters.MaxOutstandingSends  = Adapter->MaxOutstandingSends;
    PipeParameters.SDModeControlledLoad = Adapter->SDModeControlledLoad;
    PipeParameters.SDModeGuaranteed     = Adapter->SDModeGuaranteed;
    PipeParameters.SDModeNetworkControl = Adapter->SDModeNetworkControl;
    PipeParameters.SDModeQualitative    = Adapter->SDModeQualitative;
    PipeParameters.RegistryPath         = &Adapter->RegistryPath;

    PS_UNLOCK(&Adapter->Lock);

    //
    // Initialize the pipe for only the first time
    //

    if ( !(Adapter->ShutdownMask & SHUTDOWN_DELETE_PIPE )) 
    {

        //
        // We don't run the scheduling components on the Adapter structure for NDISWAN.
        // Each wanlink has its own set of scheduling components. But, we still need to compute the 
        // PacketPool Length and allocate the Packet Pool - Hence we have to call GetSchedulerPipeContext
        //

        if(Adapter->MediaType == NdisMediumWan)
        {
            //
            // Allocate and initialize the context buffer for the scheduler.
            //
    
            Status = GetSchedulerPipeContext( Adapter, 
                                              NULL,
                                              NULL,
                                              NULL);
        }
        else 
        {
            Status = GetSchedulerPipeContext( Adapter, 
                                              &Adapter->PsPipeContext, 
                                              &Adapter->PsComponent, 
                                              &Adapter->ShutdownMask);

        }
    
        if ( !NT_SUCCESS( Status )) 
        {
            return Status;
        }

        if(Adapter->MediaType == NdisMediumWan)
        {

            Adapter->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
            
            PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT));
            PsAssert(!Adapter->PsPipeContext);
            PsAssert(!Adapter->PsComponent);
            
        }
        else 
        {
            // Need to set the pipe's media type here.. //
            PipeParameters.MediaType = Adapter->MediaType;
        
            Status = (*Adapter->PsComponent->InitializePipe)(
                Adapter,
                &PipeParameters,
                Adapter->PsPipeContext,
                &PsProcs,
                NULL);
            
            if (NT_SUCCESS(Status)) {
                
                Adapter->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
            }
            else 
            {
                return Status;
            }
        }
        

    }
    else
    {
        // Pipe's already been initialized. This is a modify

        if(Adapter->MediaType != NdisMediumWan) 
        {
            Status = (*Adapter->PsComponent->ModifyPipe)(
                            Adapter->PsPipeContext,
                            &PipeParameters);
        }
    }

    return Status;

} // UpdateSchedulingPipe
 

NDIS_STATUS
MpInitialize(
        OUT PNDIS_STATUS    OpenErrorStatus,
        OUT PUINT           SelectedMediumIndex,
        IN  PNDIS_MEDIUM    MediumArray,
        IN  UINT            MediumArraySize,
        IN  NDIS_HANDLE     MiniportAdapterHandle,
        IN  NDIS_HANDLE     WrapperConfigurationContext
        )

/*++

Routine Description:

    Packet scheduler's device initialization routine. The list of media types is
    checked to be sure it is one that we support. If so, match up the name of
    the device being opened with one of the adapters to which we've bound.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER        Adapter;
    NDIS_STATUS     Status;
    BOOLEAN         FakingIt           = FALSE;
    NDIS_STRING     MpDeviceName;


    //
    // We're being called to initialize one of our miniport
    // device instances. We triggered this by calling 
    // NdisIMInitializeDeviceInstance when we were asked to 
    // bind to the adapter below us. We provided a pointer
    // to the ADAPTER struct corresponding to the actual 
    // adapter we opened. We can get that back now, with the
    // following call.
    //

    Adapter = NdisIMGetDeviceContext(MiniportAdapterHandle);

    PsStructAssert(Adapter);
    PsDbgOut(DBG_TRACE, DBG_MINIPORT | DBG_INIT, ("[MpInitialize]: Adapter %08X \n", Adapter));
     
    Adapter->ShutdownMask |= SHUTDOWN_MPINIT_CALLED;

    // 
    // We assume that the faster packet APIs will be used, and initialize our per-packet pool. If we don't get a packet-stack,
    // we'll initialize the NDIS packet pool and free the per-packet pool (since the NDIS packet pool will have space for a per-packet
    // pool).
    //
    // We cannot know about the old or new packet stack API at bind time (because even if we did know our position in the packet stack, and 
    // initialized the old APIs, we could get a newly allocated packet from an IM above us which will have room for a packet stack).
    //

    Adapter->SendBlockPool = NdisCreateBlockPool((USHORT)Adapter->PacketContextLength,
                                                 FIELD_OFFSET(PS_SEND_PACKET_CONTEXT, FreeList),
                                                 NDIS_PACKET_POOL_TAG_FOR_PSCHED,
                                                 NULL);
    
    if(!Adapter->SendBlockPool)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Can't allocate packet pool \n",
                 Adapter));

        Status = NDIS_STATUS_RESOURCES;
        
        PsAdapterWriteEventLog(
            EVENT_PS_RESOURCE_POOL,
            0,
            &Adapter->MpDeviceName,
            0,
            NULL);
        
        goto MpInitializeError;
    }

    
    //
    // We can also get the instance name for the corresponding 
    // adapter. This is the name which WMI will be using to 
    // refer to this instance of us. 
    //

    Status = NdisMQueryAdapterInstanceName(&Adapter->WMIInstanceName, MiniportAdapterHandle);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Failed to get WMI instance name.\n",
                 Adapter,
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_WMI_INSTANCE_NAME_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        goto MpInitializeError;
    }

    //
    // lookup our media type in the supplied media array
    //
    // if we're NdisMediumWan, then we have to fake out the
    // protocol and pretend that we're NdisMedium802_3, so 
    // fake it for now.
    //

    if(Adapter->MediaType == NdisMediumWan){

        FakingIt = TRUE;
        Adapter->MediaType = NdisMedium802_3;
    }

    if (MediumArray != 0) {
        for(--MediumArraySize ; MediumArraySize > 0;) {

            if(MediumArray[ MediumArraySize ] == Adapter->MediaType){
                break;
            }

            if(MediumArraySize == 0){
                break;
            }

            --MediumArraySize;
        }
    }

    if(MediumArraySize == 0 && MediumArray[ 0 ] != Adapter->MediaType){

        if(FakingIt)
        {
            FakingIt = FALSE;
            Adapter->MediaType = NdisMediumWan;
        }

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Unsupported Media \n",
                 Adapter));

        Status =  NDIS_STATUS_UNSUPPORTED_MEDIA;

        goto MpInitializeError;
    }

    if(FakingIt){

        FakingIt = FALSE;
        Adapter->MediaType = NdisMediumWan;
    }

    *SelectedMediumIndex = MediumArraySize;

    //
    // finish the initialization process by set our attributes
    //

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         Adapter,
                         0xFFFF,
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT  |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                         NDIS_ATTRIBUTE_DESERIALIZE            | 
                         NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER    |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         0);

    //
    // Set the default value for the device state flag as PM capable (for both miniport
    // and protocol). Device is ON by default
    //
    Adapter->MPDeviceState = NdisDeviceStateD0;
    Adapter->PTDeviceState = NdisDeviceStateD0;

    Adapter->PsNdisHandle = MiniportAdapterHandle;

    //
    // We create the b/e VC here (rather than the bind handler) because 
    // this will be called only after all scheduling components have registered.
    // 

    if(Adapter->MediaType != NdisMediumWan) {

        Status = CreateBestEffortVc(Adapter, 
                                    &Adapter->BestEffortVc, 
                                    0);
        
        if(Status != NDIS_STATUS_SUCCESS) 
        {
            PsDbgOut(DBG_CRITICAL_ERROR, DBG_MINIPORT | DBG_INIT,
                     ("[MpInitialize]: Adapter %08X, cannot create b/e VC ! \n", 
                      Adapter));
          
            goto MpInitializeError;
        }
    }

    Adapter->PsMpState = AdapterStateRunning;

    //
    // This is for mpinitialize, will be deref'd on mphalt.
    //
    REFADD(&Adapter->RefCount, 'NDHT');

    PS_LOCK(&AdapterListLock);

    if(WMIInitialized && !Adapter->IfcNotification)
    {
        //
        // WMI has been initialized correctly. i.e we can post events
        // at this point. 
        //

        Adapter->IfcNotification = TRUE;

        PS_UNLOCK(&AdapterListLock);

        TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_UP);
    }
    else 
    {
        //
        // WMI has not been initialized. Since this adapter is already on the 
        // list, the interface up event will be posted when IRP_MN_REGINFO 
        // completes.
        //
        
        PS_UNLOCK(&AdapterListLock);
    }

    NdisSetEvent(&Adapter->MpInitializeEvent);

    return NDIS_STATUS_SUCCESS;

MpInitializeError:
    Adapter->PsNdisHandle = 0;
    NdisSetEvent(&Adapter->MpInitializeEvent);
    return Status;

} // MpInitialize



PADAPTER
FindAdapterById(
    ULONG   InterfaceId,
    ULONG   LinkId,
    PPS_WAN_LINK *PsWanLink
    )
{
    PLIST_ENTRY NextAdapter;
    PLIST_ENTRY NextLink;
    PPS_WAN_LINK WanLink;
    PADAPTER AdapterInList;

    *PsWanLink = NULL;

    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;

    while(NextAdapter != &AdapterList){

        AdapterInList = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

        PS_LOCK_DPC(&AdapterInList->Lock);

        //
        // If it's closing, blow right by it.
        //

        if(AdapterInList->PsMpState != AdapterStateRunning)
        {
            PS_UNLOCK_DPC(&AdapterInList->Lock);

            NextAdapter = NextAdapter->Flink;

            continue;
        }

        if(AdapterInList->MediaType != NdisMediumWan)
        {
            if(AdapterInList->InterfaceID.InterfaceId != InterfaceId)
            {
                PS_UNLOCK_DPC(&AdapterInList->Lock);

                NextAdapter = NextAdapter->Flink;

                continue;
            }
            
            REFADD(&AdapterInList->RefCount, 'ADVC');

            PS_UNLOCK_DPC(&AdapterInList->Lock);

            PS_UNLOCK(&AdapterListLock);

            return(AdapterInList);
        }
        else 
        {

           if(AdapterInList->WanBindingState & WAN_ADDR_FAMILY_OPEN)
           {
              //
              // Wan adapters are searched by the name stored with 
              // their links.
              //
              
              NextLink = AdapterInList->WanLinkList.Flink;
              
              while(NextLink != &AdapterInList->WanLinkList){
                 
                 WanLink = CONTAINING_RECORD(NextLink, PS_WAN_LINK, Linkage);
                 
                 if((WanLink->State == WanStateOpen) &&
                    (LinkId == WanLink->InterfaceID.LinkId) &&
                    (InterfaceId == WanLink->InterfaceID.InterfaceId)) {
                        REFADD(&AdapterInList->RefCount, 'ADVC');
                        REFADD(&WanLink->RefCount, 'WANV');

                        PS_UNLOCK_DPC(&AdapterInList->Lock);
                        PS_UNLOCK(&AdapterListLock);
                        *PsWanLink = WanLink;
                        return(AdapterInList);
                 }
                 NextLink = NextLink->Flink;
              }
           }
        }
              
        PS_UNLOCK_DPC(&AdapterInList->Lock);
        NextAdapter = NextAdapter->Flink;
        
    }
    
    PS_UNLOCK(&AdapterListLock);
    return NULL;

} // FindAdapterByWmiInstanceName




PADAPTER
FindAdapterByWmiInstanceName(
    USHORT       StringLength,
    PWSTR        StringStart,
    PPS_WAN_LINK *PsWanLink
    )

/*++

Routine Description:

    Find the miniport instance that matches the instance name passed in.

Arguments:

    StringLength - Number of bytes / 2

    StringStart - pointer to a buffer containing a wide string

    PsWanLink - if this is an interface search, then the WAN link
        representing the interface will be returned in this location.
        If it is not an interface search or no matching WanLink is 
        found, NULL will be returned.

    InterfaceSearch - if TRUE, this is a search for an interface. For
        LAN adapters, an interface is equivalent to an adapter. For WAN
        adapters, interfaces are links. Otherwise, it's a search for an 
        adapter.

Return Value:

    pointer to ADAPTER struct, otherwise NULL

--*/

{
    PLIST_ENTRY NextAdapter;
    PLIST_ENTRY NextLink;
    PPS_WAN_LINK WanLink;
    PADAPTER AdapterInList;

    *PsWanLink = NULL;

    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;

    while(NextAdapter != &AdapterList){

        AdapterInList = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

        PS_LOCK_DPC(&AdapterInList->Lock);

        //
        // If it's closing, blow right by it.
        //

        if(AdapterInList->PsMpState != AdapterStateRunning)
        {
            PS_UNLOCK_DPC(&AdapterInList->Lock);

            NextAdapter = NextAdapter->Flink;

            continue;
        }

        if(AdapterInList->MediaType != NdisMediumWan)
        {

           if(StringLength == AdapterInList->WMIInstanceName.Length){
              
              //
              // At least they are of equal length.
              //

              if(NdisEqualMemory(StringStart,
                                 AdapterInList->WMIInstanceName.Buffer,
                                 StringLength)){
                 
                 REFADD(&AdapterInList->RefCount, 'ADVC');

                 PS_UNLOCK_DPC(&AdapterInList->Lock);

                 PS_UNLOCK(&AdapterListLock);

                 return(AdapterInList);
              }
           }

        }
        else 
        {

           if(AdapterInList->WanBindingState & WAN_ADDR_FAMILY_OPEN)
           {
              //
              // Wan adapters are searched by the name stored with 
              // their links.
              //
              
              NextLink = AdapterInList->WanLinkList.Flink;
              
              while(NextLink != &AdapterInList->WanLinkList){
                 
                 WanLink = CONTAINING_RECORD(NextLink, PS_WAN_LINK, Linkage);
                 
                 if(WanLink->State == WanStateOpen)
                 {
                    
                    if(StringLength == WanLink->InstanceName.Length){
                       
                       //
                       // At least they are of equal length.
                       //
                       
                       if(NdisEqualMemory(StringStart,
                                          WanLink->InstanceName.Buffer,
                                          StringLength)){
                          
                          REFADD(&AdapterInList->RefCount, 'ADVC');
                          REFADD(&WanLink->RefCount, 'WANV');
                          
                          PS_UNLOCK_DPC(&AdapterInList->Lock);
                          PS_UNLOCK(&AdapterListLock);
                          *PsWanLink = WanLink;
                          return(AdapterInList);
                       }
                    }
                 }
                 
                 NextLink = NextLink->Flink;
              }
           }
        }
              
        PS_UNLOCK_DPC(&AdapterInList->Lock);
        NextAdapter = NextAdapter->Flink;
        
    }
    
    PS_UNLOCK(&AdapterListLock);
    return NULL;

} // FindAdapterByWmiInstanceName

VOID
CleanUpAdapter(
    IN PADAPTER Adapter)
{

    NDIS_STATUS Status;

    PsAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_DOWN);

    // 
    // Close all the VCs
    //
        
    CloseAllGpcVcs(Adapter);


    // 
    // if we have opened an underlying call manager, close it now.
    //
    
    if(Adapter->MediaType == NdisMediumWan) {

        PS_LOCK(&Adapter->Lock);

        if(Adapter->ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY){

            Adapter->ShutdownMask &= ~SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

            PS_UNLOCK(&Adapter->Lock);
            
            PsDbgOut(DBG_TRACE, DBG_WAN | DBG_MINIPORT,
                     ("[CleanupAdapter]: Adapter %08X Closing the WAN address family", Adapter));
            
            Status = NdisClCloseAddressFamily(Adapter->WanCmHandle);
            
        }
        else
        {
            PS_UNLOCK(&Adapter->Lock);
        }
    }
}

VOID
ClUnbindFromLowerMp(
        OUT     PNDIS_STATUS  Status,
        IN      NDIS_HANDLE   ProtocolBindingContext,
        IN      NDIS_HANDLE   UnbindContext
        )

/*++

Routine Description:

    Called by NDIS to indicate that an adapter is going away. 
    Since this is an integrated call manager/miniport, we will
    have to close the call manager with the adapter. To do so,
    we must first ask the clients of our call manager part to 
    close us. We will have to pend until then.

    Release our reference
    on the adapter and set the closing flag to true to prevent any further
    references from being obtained.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER    Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS LocalStatus;
    BOOLEAN     VirtualMp;
    ULONG    ShutdownMask;

    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL | DBG_INIT,
             ("[ClUnbindFromLowerMp]: Adapter %08X, %ws, UnbindContext %x \n",
              Adapter,
              Adapter->MpDeviceName.Buffer,
              UnbindContext));

    PsStructAssert( Adapter );
    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_UNBIND_CALLED));

    //
    // If the unbind is not happening from the context of the unload, we need to Make sure that 
    // unload waits for this unbind to complete. We do that by setting the DriverUnloadEvent.
    //

    PS_LOCK(&DriverUnloadLock);

    DRIVER_COUNTED_BLOCK;

    PS_UNLOCK(&DriverUnloadLock);

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState == AdapterStateWaiting) 
    {
        VirtualMp = FALSE;
    }
    else
    {
        VirtualMp = TRUE;
    }

    Adapter->PsMpState = AdapterStateClosing;

    Adapter->ShutdownMask |= SHUTDOWN_UNBIND_CALLED;

    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER));

    if (Adapter->PendedNdisRequest) {
        PNDIS_REQUEST PendedRequest = (PNDIS_REQUEST)Adapter->PendedNdisRequest;

        Adapter->PendedNdisRequest = NULL;
        ClRequestComplete(Adapter, PendedRequest, NDIS_STATUS_FAILURE);
    }

    ShutdownMask = Adapter->ShutdownMask;
    Adapter->ShutdownMask |= SHUTDOWN_CLEANUP_ADAPTER;

    PS_UNLOCK(&Adapter->Lock);

    if ( !(ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER))
        CleanUpAdapter(Adapter);
        
    //
    // DeInitialize the device instance if we have been called in the MpInitialize handler.
    //
    if(Adapter->PsNdisHandle) 
    {
        //
        // Either the mpinitialize has happened or its in progress. If it is in progress,
        // we need to Wait till it completes.
        //

        NdisWaitEvent(&Adapter->MpInitializeEvent, 0);

        //
        // The MpInitialize (that we could have been waiting for in the above step) could have failed : 
        // So we need to check this handle again.
        //

        if(Adapter->PsNdisHandle)
        {
        
            *Status = NdisIMDeInitializeDeviceInstance(Adapter->PsNdisHandle);

            PsDbgOut(DBG_INFO,
                     DBG_PROTOCOL | DBG_INIT,
                     ("[ClUnbindFromLowerMp]: Adapter %08X, deiniting device, "
                      "status %x\n", Adapter, *Status));
            goto Done;
        }
    }
    else 
    {
        if(VirtualMp)
        {
            //
            // We have never been called in MpInitialize. Try to cancel the NdisIMInitializeDeviceInstance
            // call.
            //
            
            PsDbgOut(DBG_INFO, 
                     DBG_PROTOCOL | DBG_INIT,
                     ("[ClUnbindFromLowerMp]: Adapter %08X, calling NdisIMCancelDeviceInstance with %ws \n",
                      Adapter, Adapter->UpperBinding.Buffer));
            
            *Status = NdisIMCancelInitializeDeviceInstance(LmDriverHandle, &Adapter->UpperBinding);
            
            if(*Status != NDIS_STATUS_SUCCESS)
            {
                //
                // An mpinitialize is in progress or is going to happen soon. Let's wait for it to
                // complete.
                //
                PsDbgOut(DBG_INFO, 
                         DBG_PROTOCOL | DBG_INIT,
                         ("[ClUnbindFromLowerMp]: Adapter %08X, Waiting for MpInitialize to "
                          "finish (NdisIMCancelDeviceInstance failed) \n", Adapter));
                
                NdisWaitEvent(&Adapter->MpInitializeEvent, 0);
                
                //
                // The MpInitialize (that we could have been waiting for in the above step) could have failed : 
                // So we need to check this handle again.
                //
                
                if(Adapter->PsNdisHandle)
                {
                    *Status = NdisIMDeInitializeDeviceInstance(Adapter->PsNdisHandle);
                    
                    PsDbgOut(DBG_INFO,
                             DBG_PROTOCOL | DBG_INIT,
                             ("[ClUnbindFromLowerMp]: Adapter %08X, deiniting device, "
                              "status %x\n", Adapter, *Status));
                    
                    goto Done;
                }
            }
            else
            {
                //
                // Great. We can be assured that we will never get called in the MpInitializeHandler anymore.
                // Proceed to close the binding below.
                //
            }
        }
    }

    //
    // Close the open. We have to do this only if we don't call NdisIMDeInitializeDeviceInstance. If 
    // we ever call NdisIMDeInitializeDeviceInstance, then we close the open in the MpHalt handler.
    //

    if(Adapter->LowerMpHandle) 
    {
        NdisCloseAdapter(Status, Adapter->LowerMpHandle);

        PsDbgOut(DBG_INFO,
                 DBG_PROTOCOL | DBG_INIT,
                 ("[ClUnbindFromLowerMp]: Adapter %08X, closing adapter, "
                  "status %x\n", Adapter, *Status));

        if (*Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            NdisResetEvent(&Adapter->BlockingEvent);
        
            *Status = Adapter->FinalStatus;
        }
       
        REFDEL(&Adapter->RefCount, FALSE, 'NDOP'); 

    }
    else 
    {

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_PROTOCOL | DBG_INIT,
                 ("[ClUnbindFromLowerMp]: Adapter %08X, unbind cannot deinit/close adpater \n",
                  Adapter));
        
        *Status = NDIS_STATUS_FAILURE;

        PsAssert(0);

    }

Done:

    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL | DBG_INIT,
             ("[ClUnbindFromLowerMp]: Exiting with Status = %08X \n", *Status));

    DRIVER_COUNTED_UNBLOCK;

} // UnbindAdapter



VOID
DeleteAdapter(
    PVOID    Handle,
    BOOLEAN  AdapterListLocked
    )

/*++

Routine Description:

    Decrement the ref counter associated with this structure. When it goes to
    zero, close the adapter, and delete the memory associated with the struct

Arguments:

    Adapter - pointer to adapter context block

Return Value:

    number of references remaining associated with this structure

--*/

{
    PADAPTER Adapter = (PADAPTER) Handle;

        Adapter->PsMpState = AdapterStateClosed;

        //
        // if we initialized the pipe, tell the scheduler that this pipe is going away
        //
        
        if ( Adapter->MediaType != NdisMediumWan && Adapter->ShutdownMask & SHUTDOWN_DELETE_PIPE ) {
            
            (*Adapter->PsComponent->DeletePipe)( Adapter->PsPipeContext );
        }
        
        if ( Adapter->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT ) {
            
            PsFreePool(Adapter->PsPipeContext);
        }

        if(Adapter->pDiffServMapping)
        {
            PsFreePool(Adapter->pDiffServMapping);
        }
        
        //
        // return packet pool resources
        //
        
        if(Adapter->SendPacketPool != 0)
        {
           NdisFreePacketPool(Adapter->SendPacketPool);
        }

        if(Adapter->RecvPacketPool != 0)
        {
           NdisFreePacketPool(Adapter->RecvPacketPool);
        }

        if(Adapter->SendBlockPool)
        {
            NdisDestroyBlockPool(Adapter->SendBlockPool);
        }

        
        //
        // free adapter lock from dispatcher DB 
        //
        
        NdisFreeSpinLock(&Adapter->Lock);
        
        //
        // Free various allocations for the adapter, then the adapter
        //
        
        if(Adapter->IpNetAddressList){
            PsFreePool(Adapter->IpNetAddressList);
        }
        
        if(Adapter->IpxNetAddressList){
            PsFreePool(Adapter->IpxNetAddressList);
        }
        
        if(Adapter->MpDeviceName.Buffer) {
            PsFreePool(Adapter->MpDeviceName.Buffer);
        }
        
        if(Adapter->UpperBinding.Buffer) {
            PsFreePool(Adapter->UpperBinding.Buffer);
        }
        
        if(Adapter->RegistryPath.Buffer) {
            PsFreePool(Adapter->RegistryPath.Buffer);
        }
        
        if(Adapter->WMIInstanceName.Buffer) {
            
            //
            // We should not call PsFreePool since this memory is allocated by NDIS
            //
            
            ExFreePool(Adapter->WMIInstanceName.Buffer);
        }

        if(Adapter->ProfileName.Buffer) {
            PsFreePool(Adapter->ProfileName.Buffer);
        }
       
        if(!AdapterListLocked) 
        {
            PS_LOCK(&AdapterListLock);

            RemoveEntryList(&Adapter->Linkage);

            PS_UNLOCK(&AdapterListLock);
        }
        else 
        {
            RemoveEntryList(&Adapter->Linkage);
        }

        NdisSetEvent(&Adapter->RefEvent);

        PsFreePool(Adapter);
        

} 


VOID
ClLowerMpCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for NdisCloseAdapter. All that should be left is to free
    the pool associated with the structure

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("[ClLowerMpCloseAdapterComplete]: Adapter %08X \n", Adapter));

    PsStructAssert( Adapter );

    PsAssert(Status == NDIS_STATUS_SUCCESS);

    Adapter->FinalStatus = Status;

    Adapter->LowerMpHandle = 0;

    //
    // Clean up WanLinks. This cannot be done (in CleanUpAdapter) before we call NdisCloseAdapter, because
    // NDIS can unbind us in the middle of an ClStatusIndication, and can cause a race condition. Also, we 
    // can all PsDeleteDevice only after this (because we might want to send some status indications.
    //
        
    AskWanLinksToClose(Adapter);

    PsDeleteDevice();

    NdisSetEvent(&Adapter->BlockingEvent);

} // LowerMpCloseAdapterComplete


VOID
ClUnloadProtocol(
    VOID
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{

}


VOID
MpHalt(
        IN      NDIS_HANDLE                             MiniportAdapterContext
        )

/*++

Routine Description:

    This handler is called on Memphis. It indicates that the PS MP is no more
    and we should avoid calling NdisIMDeInitializeDeviceInstance...

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)MiniportAdapterContext;
    ULONG Status;

    PsDbgOut(DBG_TRACE, DBG_MINIPORT, ("[MpHalt]: Adapter %08X\n", Adapter));

    PsStructAssert(Adapter);

    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_MPHALT_CALLED));
    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_PROTOCOL_UNLOAD));

    PS_LOCK(&Adapter->Lock);

    //
    // If we ever get called in our unbind handler, we should not call
    // NdisImDeInitializeDeviceInstance.
    //

    Adapter->ShutdownMask |= SHUTDOWN_MPHALT_CALLED;

    Adapter->PsMpState = AdapterStateClosing;

    if(!(Adapter->ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER))
    {
        Adapter->ShutdownMask |= SHUTDOWN_CLEANUP_ADAPTER;

        PS_UNLOCK(&Adapter->Lock);

        CleanUpAdapter(Adapter);
    }
    else 
    {
        PS_UNLOCK(&Adapter->Lock);
    }

    //
    // Close the b/e VC in the mphalt call. This prevents us from taking a lock 
    // in the send path. We are assured that we will not get any sends after we
    // get called in the mphalt handler.
    //

    if(Adapter->MediaType != NdisMediumWan)
    {
        PS_LOCK(&Adapter->Lock);

        PS_LOCK_DPC(&Adapter->BestEffortVc.Lock);
    
        InternalCloseCall(&Adapter->BestEffortVc);
    }

    if(Adapter->LowerMpHandle) {

        NdisCloseAdapter(&Status, Adapter->LowerMpHandle);

        if(Status == NDIS_STATUS_PENDING) {
            
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            NdisResetEvent(&Adapter->BlockingEvent);

            Status = Adapter->FinalStatus;
        }

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');
    }

    //
    // Deref for the MpInitialize
    //
    REFDEL(&Adapter->RefCount, FALSE, 'NDHT');

}


HANDLE
GetNdisPipeHandle (
    IN HANDLE PsPipeContext
    )

/*++

Routine Description:

    Return the NDIS handle for the adapter to the requesting scheduling component.

Arguments:

    PsPipeContext - Pipe context

Return Values:

    Adapter NDIS handle.

--*/

{
    return ((PADAPTER)PsPipeContext)->PsNdisHandle;
} // GetNdisPipeHandle




STATIC NDIS_STATUS
FindProfile(
    PNDIS_STRING ProfileName,
    PPS_PROFILE  *Profile
    )

/*++
  Routine Description:

      Find the named profile in the list of profiles

  Arguments

      ProfileName - Name of the profile to look for.

  Return Value:
    NDIS_STATUS_SUCCESS if everything worked ok

e--*/
{
    NDIS_STATUS Status;
    PLIST_ENTRY NextComponent;
    PPS_PROFILE PsiInfo;

    //
    // compare names until we find the right one
    //

    NextComponent = PsProfileList.Flink;
    while ( NextComponent != &PsProfileList ) {

        PsiInfo = CONTAINING_RECORD( NextComponent, PS_PROFILE, Links );

        if ( ProfileName->Length == PsiInfo->ProfileName.Length ) {

            if ( NdisEqualMemory(
                    ProfileName->Buffer,
                    PsiInfo->ProfileName.Buffer,
                    ProfileName->Length )) {

                break;
            }
        }

        NextComponent = NextComponent->Flink;
    }


    if ( NextComponent != &PsProfileList ) {

        *Profile = PsiInfo;
        Status = NDIS_STATUS_SUCCESS;
    } else {

        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
} // FindProfile



NDIS_STATUS
InitializeAdapter(
    PADAPTER Adapter, 
    PVOID BindContext, 
    PNDIS_STRING MpDeviceName, 
    PVOID SystemSpecific1)
{
    NDIS_STATUS LocalStatus;
    PNDIS_STRING PsParamsKey = (PNDIS_STRING) SystemSpecific1;

    NdisZeroMemory(Adapter, sizeof(ADAPTER));

    PS_INIT_SPIN_LOCK(&Adapter->Lock);
    REFINIT(&Adapter->RefCount, Adapter, DeleteAdapter);
    REFADD(&Adapter->RefCount, 'NDOP');
    Adapter->PsMpState            = AdapterStateInitializing;
    Adapter->BindContext          = BindContext;
    Adapter->ShutdownMask         = 0;

    NdisInitializeEvent(&Adapter->BlockingEvent);
    NdisResetEvent(&Adapter->BlockingEvent);

    NdisInitializeEvent(&Adapter->RefEvent);
    NdisResetEvent(&Adapter->RefEvent);

    NdisInitializeEvent(&Adapter->LocalRequestEvent);
    NdisResetEvent(&Adapter->LocalRequestEvent);

    NdisInitializeEvent(&Adapter->MpInitializeEvent);
    NdisResetEvent(&Adapter->MpInitializeEvent);

    //
    // Initialize the Lists that we are maintaining
    //

    InitializeListHead(&Adapter->WanLinkList);
    InitializeListHead(&Adapter->GpcClientVcList);


    //
    // By default, Adapter comes in RSVP mode
    //
    Adapter->AdapterMode = AdapterModeRsvpFlow;

    //
    // add adapter on list of known adapters
    //

    NdisInterlockedInsertTailList(&AdapterList, 
                                  &Adapter->Linkage, 
                                  &AdapterListLock.Lock );

    PsAddDevice();

    //
    // We maintain a list of network addresses enabled on
    // each adapter, for IP and for IPX, separately.
    //

    PsAllocatePool(Adapter->IpNetAddressList,
                   sizeof(NETWORK_ADDRESS_LIST),
                   PsMiscTag);

    if(!Adapter->IpNetAddressList) 
    {
        goto ERROR_RESOURCES;
    }

    Adapter->IpNetAddressList->AddressCount = 0;

    PsAllocatePool(Adapter->IpxNetAddressList,
                   sizeof(NETWORK_ADDRESS_LIST),
                   PsMiscTag);

    if(!Adapter->IpxNetAddressList)
    {
        goto ERROR_RESOURCES;
    }

    Adapter->IpxNetAddressList->AddressCount = 0;


    //
    // Allocate a buffer to hold the name of the underlying 
    // adpater. 
    //

    Adapter->MpDeviceName.Length        = MpDeviceName->Length;
    Adapter->MpDeviceName.MaximumLength = MpDeviceName->MaximumLength;

    PsAllocatePool(Adapter->MpDeviceName.Buffer,
                   MpDeviceName->MaximumLength,
                   PsMiscTag);

    if(Adapter->MpDeviceName.Buffer == NULL) 
    {
        goto ERROR_RESOURCES;
    }
    else
    {

        NdisZeroMemory(
            Adapter->MpDeviceName.Buffer,
            Adapter->MpDeviceName.MaximumLength);

        NdisMoveMemory(
            Adapter->MpDeviceName.Buffer,
            MpDeviceName->Buffer,
            MpDeviceName->Length);
    }

    //
    // Allocate a buffer to hold PsParams Key. This will be
    // used by the adapter to read external scheduling component
    // specific interface parameters when they register.
    //

    Adapter->RegistryPath.Length = PsParamsKey->Length;
    Adapter->RegistryPath.MaximumLength = PsParamsKey->MaximumLength;

    PsAllocatePool(Adapter->RegistryPath.Buffer,
                   Adapter->RegistryPath.MaximumLength,
                   PsMiscTag);

    if(Adapter->RegistryPath.Buffer == NULL)
    {
        goto ERROR_RESOURCES;
    }
    else
    {
        NdisMoveMemory(
            Adapter->RegistryPath.Buffer,
            PsParamsKey->Buffer,
            PsParamsKey->MaximumLength);
    }

    //
    // Read the per adapter registry info
    //

    LocalStatus = PsReadAdapterRegistryDataInit(Adapter,
                                                (PNDIS_STRING)SystemSpecific1);

    if(LocalStatus != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL | DBG_INIT,
                 ("[InitializeAdapter]: Couldn't get registry data %ws (Status = %08X) \n",
                  MpDeviceName->Buffer, LocalStatus));

        return LocalStatus;
    }

    LocalStatus = PsReadAdapterRegistryData(Adapter,
                                            &MachineRegistryKey,
                                            (PNDIS_STRING)SystemSpecific1);

    if(LocalStatus != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL | DBG_INIT,
                 ("[InitializeAdapter]: Couldn't get registry data %ws (Status = %08X) \n",
                  MpDeviceName->Buffer, LocalStatus));
    }

    return LocalStatus;

ERROR_RESOURCES:
    PsAdapterWriteEventLog(
        (ULONG)EVENT_PS_RESOURCE_POOL,
        0,
        MpDeviceName,
        0,
        NULL);

    return NDIS_STATUS_RESOURCES;
}


NDIS_STATUS
FindSchedulingComponent(
    PNDIS_STRING ComponentName,
    PPSI_INFO *Component
    )

/*++

Routine Description:

    Find the named component in the list of external scheduling components

Arguments:

    ComponentName - name of component to look for

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    NDIS_STATUS Status;
    PLIST_ENTRY NextComponent;
    PPSI_INFO PsiInfo;

    //
    // get the list lock and compare names until we find the right one
    //


    NextComponent = PsComponentList.Flink;
    while ( NextComponent != &PsComponentList ) {

        PsiInfo = CONTAINING_RECORD( NextComponent, PSI_INFO, Links );

        if ( ComponentName->Length == PsiInfo->ComponentName.Length ) {

            if ( NdisEqualMemory(
                    ComponentName->Buffer,
                    PsiInfo->ComponentName.Buffer,
                    ComponentName->Length )) {

                break;
            }
        }

        NextComponent = NextComponent->Flink;
    }

    if ( NextComponent != &PsComponentList ) {

        *Component = PsiInfo;
        Status = NDIS_STATUS_SUCCESS;
    } else {

        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
} // FindSchedulingComponent

VOID
CloseAllGpcVcs(
    PADAPTER Adapter
    )

/*++

Routine Description:

    Close all the VCs associated with an adapter

Return Value:

    None

--*/

{
    PGPC_CLIENT_VC Vc;
    PLIST_ENTRY    NextVc;


    //
    // Close all the GPC client VCs.
    //
    PS_LOCK(&Adapter->Lock);

    NextVc = Adapter->GpcClientVcList.Flink;

    while(NextVc != &Adapter->GpcClientVcList)
    {
        Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);

        PsAssert(Vc);

        PS_LOCK_DPC(&Vc->Lock);

        if(Vc->ClVcState == CL_INTERNAL_CLOSE_PENDING || Vc->Flags & INTERNAL_CLOSE_REQUESTED)
        {
            PS_UNLOCK_DPC(&Vc->Lock);

            NextVc = NextVc->Flink;
        }
        else
        {
            InternalCloseCall(Vc);

            PS_LOCK(&Adapter->Lock);

            //
            // Sigh. We can't really get hold to the NextVc in a reliable manner. When we call 
            // InternalCloseCall on the Vc, it releases the Adapter Lock (since it might have to
            // make calls into NDIS). Now, in this window, the next Vc could go away, and we 
            // could point to a stale Vc. So, we start at the head of the list. 
            // Note that this can never lead to a infinite loop, since we don't process the 
            // internal close'd VCs repeatedly.
            //

            NextVc = Adapter->GpcClientVcList.Flink;

        }

    }    

    PS_UNLOCK(&Adapter->Lock);

} // CloseAllGpcVcs

VOID
PsAdapterWriteEventLog(
    IN  NDIS_STATUS  EventCode,
    IN  ULONG        UniqueEventValue,
    IN  PNDIS_STRING DeviceName,
    IN  ULONG        DataSize,
    IN  PVOID        Data       OPTIONAL
    )

{

    //
    // The String List is the device name, and it has a \Device against it.
    //
    PWCHAR StringList[1];
    NDIS_STRING Prefix = NDIS_STRING_CONST("\\Device\\");

    if(DeviceName->Length > Prefix.Length)
    {
        StringList[0] = (PWCHAR) ((PUCHAR) DeviceName->Buffer + Prefix.Length);

        NdisWriteEventLogEntry(PsDriverObject,
                               EventCode,
                               UniqueEventValue,
                               1,
                               &StringList,
                               DataSize,
                               Data);
    }
}

/* end adapter.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\cmvc.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmvc.h

Abstract:


Author:

    Rajesh Sundaram (rajeshsu), 1st Aug 1998.

Revision History:

--*/

#ifndef _CMVC_
#define _CMVC_

/* Prototypes */

NDIS_STATUS
CreateBestEffortVc(
    PADAPTER Adapter, 
    PGPC_CLIENT_VC Vc, 
    PPS_WAN_LINK WanLink);

NDIS_STATUS
CmCreateVc(
    PGPC_CLIENT_VC *Vc, 
    PADAPTER Adapter,
    PPS_WAN_LINK WanLink,
    PCO_CALL_PARAMETERS CallParams, 
    GPC_HANDLE GpcCfInfoHandle, 
    PCF_INFO_QOS CfInfoPtr,
    GPC_CLIENT_HANDLE ClientContext);

NDIS_STATUS
CmMakeCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmModifyCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmCloseCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE ProtocolVcContext
    );

VOID
FillInCmParams(
    PCO_CALL_MANAGER_PARAMETERS CmParams,
    SERVICETYPE                 ServiceType,
    ULONG                       TokenRate,
    ULONG                       PeakBandwidth,
    ULONG                       TokenBucketSize,
    ULONG                       DSMode,
    ULONG                       Priority);


VOID
CompleteMakeCall(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS Status);

VOID
ModifyCallComplete(
    PGPC_CLIENT_VC      Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS         Status
    );

/* End Prototypes */

#endif /* _CMVC_ */

/* end cmvc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\clstate.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clstate.h

Abstract:

    defines for gpc client state machine code

Author:

    Yoram Bernet (yoramb) 28-Dec-1997

Revision History:

--*/

#ifndef _CLSTATE_
#define _CLSTATE_

/* Prototypes */

VOID
InternalCloseCall(
    PGPC_CLIENT_VC Vc
    );

VOID
CallSucceededStateTransition(
    PGPC_CLIENT_VC Vc
    );

/* End Prototypes */

#endif /* _CLSTATE_ */

/* end clstate.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\cmvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmvc.c

Abstract:

Author:
    Charlie Wickham (charlwi)  13-Sep-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

NDIS_STATUS
ValidateCallParameters(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters
    );

NDIS_STATUS
AcquireFlowResources(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS NewCallParams,
    PCO_CALL_MANAGER_PARAMETERS OldCallParams,
    PULONG                      RemainingBandWidthChanged
    );

VOID
ReturnFlowResources(
    PGPC_CLIENT_VC Vc,
    PULONG         RemainingBandWidthChanged
    );

VOID
CancelAcquiredFlowResources(
    PGPC_CLIENT_VC Vc
    );

/* End Forward */

NDIS_STATUS
CmCreateVc(PGPC_CLIENT_VC      *GpcClientVc, 
           PADAPTER             Adapter,
           PPS_WAN_LINK         WanLink,
           PCO_CALL_PARAMETERS  CallParams, 
           GPC_HANDLE           GpcCfInfoHandle, 
           PCF_INFO_QOS         CfInfoPtr,
           GPC_CLIENT_HANDLE    ClientContext)
{

    PGPC_CLIENT_VC Vc;

    *GpcClientVc = NULL;

    PsAllocFromLL(&Vc, &GpcClientVcLL, GpcClientVc);

    if(Vc == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    InitGpcClientVc(Vc, 0, Adapter);
    SetLLTag(Vc, GpcClientVc);

    //
    // Allocate space for the instance name for the Vc. 
    //
    PsAllocatePool(Vc->InstanceName.Buffer,
                   Adapter->WMIInstanceName.Length + VcPrefix.Length + INSTANCE_ID_SIZE,
                   PsMiscTag);

    if(!Vc->InstanceName.Buffer)
    {
        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
        return NDIS_STATUS_RESOURCES;
    }

    Vc->CfInfoHandle   = GpcCfInfoHandle;
    Vc->CfType         = ClientContext;
    Vc->CfInfoQoS      = CfInfoPtr;
    Vc->CallParameters = CallParams;

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState == AdapterStateRunning)
    {
        //
        // Insert the Vc in the adapter list
        //
        InsertHeadList(&Adapter->GpcClientVcList, &Vc->Linkage);
        PS_UNLOCK(&Adapter->Lock);
    }
    else 
    {
        PsFreePool(Vc->InstanceName.Buffer);
        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
        PS_UNLOCK(&Adapter->Lock);
        return GPC_STATUS_NOTREADY;
    }


    if(WanLink) {

        Vc->Flags |= GPC_WANLINK_VC;

        // 
        // We need to link the VC to the WanLink. This has to be done because
        // we have to clean up when we get a NDIS_STATUS_WAN_LINE_DOWN
        //

        Vc->AdapterStats = &WanLink->Stats;
        Vc->WanLink = WanLink;
        Vc->PsPipeContext = WanLink->PsPipeContext;
        Vc->PsComponent   = WanLink->PsComponent;
    }
    else 
    {

        Vc->AdapterStats  = &Adapter->Stats;
        Vc->PsPipeContext = Adapter->PsPipeContext;
        Vc->PsComponent   = Adapter->PsComponent;
    }

    *GpcClientVc = Vc;

    return NDIS_STATUS_SUCCESS;

} // CmCreateVc




BOOLEAN
IsIsslowFlow(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    LONG                        ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_MEDIA_PARAMETERS        CallMgrParams = CallParameters->MediaParameters;
    ULONGLONG                   i,j,k;

    ParamsLength = (LONG)CallMgrParams->MediaSpecific.Length;
    QoSObject = (LPQOS_OBJECT_HDR)CallMgrParams->MediaSpecific.Parameters;

    while(ParamsLength > 0)
    {
        if(QoSObject->ObjectType == QOS_OBJECT_WAN_MEDIA)
        {
            if((Vc->WanLink->LinkSpeed <= Adapter->ISSLOWLinkSpeed) && 
                (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_BESTEFFORT))
            {
                i = (ULONGLONG) Adapter->ISSLOWTokenRate * (ULONGLONG) CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                j = (ULONGLONG) Adapter->ISSLOWPacketSize * (ULONGLONG) CallParameters->CallMgrParameters->Transmit.TokenRate;
                k = (ULONGLONG) Adapter->ISSLOWTokenRate * (ULONGLONG)Adapter->ISSLOWPacketSize;

                if((i+j)<k)
                    return TRUE;
            }

            return FALSE;
        }
        else 
        {
            if( ((LONG)QoSObject->ObjectLength <= 0) ||
                ((LONG)QoSObject->ObjectLength > ParamsLength) )
            {

                return(FALSE);
            }

            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    return FALSE;
}






NDIS_STATUS
CmMakeCall(
    IN PGPC_CLIENT_VC Vc
)
{
    ULONG                       CmParamsLength;
    NDIS_STATUS                 Status;
    ULONG                       RemainingBandWidthChanged;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_CALL_PARAMETERS         CallParameters   = Vc->CallParameters;

    //
    // Validate parameters
    //

    Status = ValidateCallParameters(Vc, CallParameters->CallMgrParameters);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmMakeCall]: Vc %08X, invalid QoS parameters\n", 
                 Vc));

        return Status;
    }

    //
    // make sure we can admit the flow onto our adapter. if this 
    // succeeds, the resources are committed and we'll have to call
    // CancelAcquiredFlowResources to return them.
    //

    Status = AcquireFlowResources(Vc, 
                                  CallParameters->CallMgrParameters, 
                                  NULL,
                                  &RemainingBandWidthChanged);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmMakeCall]: Vc %08X, no flow resc\n", 
                 Vc));

        return Status;
    }

    //
    // In the integrated call manager/miniport model, the activation 
    // is internal. Activating the Vc consists of adding the flow to the 
    // scheduler. If it succeeds, we will later call NdisMCmActivateVc,    
    // just as a courtesy, to notify NDIS.
    //

    if( Adapter->MediaType == NdisMediumWan     && 
        !IsBestEffortVc(Vc)                     &&
        IsIsslowFlow( Vc, CallParameters ) )
    {
        //  Need to do this before we add a flow to the sched components.
        Vc->Flags |= GPC_ISSLOW_FLOW;
    }        


    Status = AddFlowToScheduler(NEW_VC, Vc, CallParameters, 0);

    //  Let's revert it back, to avoid any side effects..
    Vc->Flags = Vc->Flags & ~GPC_ISSLOW_FLOW;
    

    if(Status != NDIS_STATUS_SUCCESS)
    {

        PsDbgOut(DBG_FAILURE,
                 DBG_VC,
                 ("[CmMakeCall]: Vc %08X, AddFlowToScheduler failed %08X\n",
                  Vc,
                  Status));

        CancelAcquiredFlowResources(Vc);

        return(Status);
    }

    //
    //  A flow has been added to psched after this point. So, whenever the Vc goes away, Psched's flow 
    //  has to be removed from an explicit call.
    //

    Vc->bRemoveFlow = TRUE;


    // 
    // If there is an NDIS 5.0, connection oriented driver below us, then
    // we need to call it, with the call parameters, to complete the VC
    // setup. 
    //

    if(Adapter->MediaType == NdisMediumWan &&
       !IsBestEffortVc(Vc))
    {
        Status = WanMakeCall(Vc, CallParameters);

        PsAssert(Status == NDIS_STATUS_PENDING);

        return Status;
    }
    else 
    {
        if(TRUE == RemainingBandWidthChanged) 
        {
            LONG RemainingBandWidth;

            PS_LOCK(&Adapter->Lock);
                
            RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
            PS_UNLOCK(&Adapter->Lock);
            
            PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
        }

        Vc->TokenRateChange = 0;

        return NDIS_STATUS_SUCCESS;
    }
}

VOID
CompleteMakeCall(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS Status
    )
{
    PADAPTER             Adapter  = Vc->Adapter;

    PsAssert(Adapter->MediaType == NdisMediumWan);

    PsAssert(!IsBestEffortVc(Vc));

    if(Status != NDIS_STATUS_SUCCESS) 
    {
        CancelAcquiredFlowResources(Vc);

    }

    Vc->TokenRateChange = 0;

    CmMakeCallComplete(Status, Vc, CallParameters);
}


NDIS_STATUS
CmModifyCall(
    IN  PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    Modify the QoS of an existing flow based on the supplied call params.
    First see if the request can be handled locally.

Arguments:

    See the DDK...

Return Values:

    NDIS_STATUS_SUCCESS if everything worked ok.

--*/

{
    NDIS_STATUS         Status;
    ULONG               CmParamsLength;
    PCO_CALL_PARAMETERS CallParameters;
    PADAPTER            Adapter;
    ULONG               RemainingBandWidthChanged;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    PsAssert(Vc->TokenRateChange == 0);

    //
    // Validate parameters
    //

    CallParameters = Vc->ModifyCallParameters;
    Status = ValidateCallParameters(Vc, CallParameters->CallMgrParameters);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmModifyCallQoS]: Vc %08X, invalid QoS parameters\n", 
                 Vc));

        return Status;
    }

    //
    // make sure we can admit the flow onto our adapter. if this 
    // succeeds, the resources are committed and we'll have to call
    // CancelAcquiredFlowResources to return them.
    //

    Status = AcquireFlowResources(Vc, 
                                  CallParameters->CallMgrParameters,
                                  Vc->CallParameters->CallMgrParameters,
                                  &RemainingBandWidthChanged);


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmModifyCallQoS]: Vc %08X, no flow resc\n", 
                 Vc));

        return Status;
    }

    Status = AddFlowToScheduler(MODIFY_VC, Vc, CallParameters, Vc->CallParameters);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE,
                 DBG_VC,
                 ("[CmModifyCallQoS]: Vc %08X, failed %08X\n",
                  Vc,
                  Status));

        //
        // Free the copy we made, Cancel the committed resources.
        //

        CancelAcquiredFlowResources(Vc);

        return(Status);
    }

    // 
    // If there is an NDIS 5.0, connection oriented driver below us, then
    // we need to call it, with the call parameters, to complete the VC
    // setup.
    //

    if(Adapter->MediaType == NdisMediumWan){

        Status = WanModifyCall(Vc, CallParameters);

        PsAssert(Status == NDIS_STATUS_PENDING);

        return(Status);
    }
    else
    {

        if(TRUE == RemainingBandWidthChanged) {

            LONG RemainingBandWidth;

            PS_LOCK(&Adapter->Lock);
                
            RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
            PS_UNLOCK(&Adapter->Lock);
            
            PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
        }

        Vc->TokenRateChange = 0;
 
        return(NDIS_STATUS_SUCCESS);
    }
} // CmModifyCallQoS

VOID
ModifyCallComplete(
    PGPC_CLIENT_VC      Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS         Status
    )
{
    PADAPTER Adapter = Vc->Adapter;

    PsAssert(Adapter->MediaType == NdisMediumWan);
    PsAssert(!IsBestEffortVc(Vc));

    if(Status != NDIS_STATUS_SUCCESS) {

        //
        // Undo the add flow done above, by reversing the new and old parameters.
        //
        ValidateCallParameters(Vc, Vc->CallParameters->CallMgrParameters);

        Status = AddFlowToScheduler(MODIFY_VC, Vc, Vc->CallParameters, CallParameters);

        CancelAcquiredFlowResources(Vc);
    }

    Vc->TokenRateChange = 0;

    CmModifyCallComplete(Status, Vc, CallParameters);
}



NDIS_STATUS
CmCloseCall(
    PGPC_CLIENT_VC Vc
    )
{
    NDIS_STATUS   Status;
    PADAPTER      Adapter = Vc->Adapter;
    ULONG         RemainingBandWidthChanged;

    PsStructAssert(Adapter);
    //    
    // 	Here, we used to call RemoveFlowFromScheduler, which used to call "DeleteFlow". Instead, we will
    //  call a new interface "EmptyPacketsFromScheduler", which will call "EmptyFlow" to empty all the
    //  packets queued up in each of the components corresponding to this flow.
    //
	
    EmptyPacketsFromScheduler( Vc );

    ReturnFlowResources(Vc, &RemainingBandWidthChanged);

    if(TRUE == RemainingBandWidthChanged) {

        LONG RemainingBandWidth;

        PS_LOCK(&Adapter->Lock);
                
        RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
        PS_UNLOCK(&Adapter->Lock);
            
        PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
    }
    
    if(!IsBestEffortVc(Vc)) 
    {
        CmCloseCallComplete(NDIS_STATUS_SUCCESS, Vc);
    }
    else 
    {
        DerefClVc(Vc);
    }

    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
CmDeleteVc(
    IN PGPC_CLIENT_VC Vc
    )
{

    PsAssert(Vc->RefCount == 0);

    if(Vc->InstanceName.Buffer) {

        PsFreePool(Vc->InstanceName.Buffer);
    }

    if( Vc->bRemoveFlow)
    {
        Vc->bRemoveFlow = FALSE;
        RemoveFlowFromScheduler(Vc);
    }                

    if(Vc->PsFlowContext) {
        
        if(Vc->Adapter->MediaType == NdisMediumWan) {

            if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext) {

                PsFreePool(Vc->PsFlowContext);
            }
            else {

                if(Vc == &Vc->WanLink->BestEffortVc) {

                    PsFreePool(Vc->PsFlowContext);
                }
            }
        }
        else {

            if(Vc->PsFlowContext != Vc->Adapter->BestEffortVc.PsFlowContext) {

                PsFreePool(Vc->PsFlowContext);
            }
            else {
            
                if(Vc == &Vc->Adapter->BestEffortVc) {
                    
                    PsFreePool(Vc->PsFlowContext);
                }
            }
        }
    }

    NdisFreeSpinLock(&Vc->Lock);

    NdisFreeSpinLock(&Vc->BytesScheduledLock);

    NdisFreeSpinLock(&Vc->BytesTransmittedLock);

    
    if(Vc->CallParameters){

        PsFreePool(Vc->CallParameters);
        Vc->CallParameters = NULL;
    }


    if(!IsBestEffortVc(Vc))
    {
        PS_LOCK(&Vc->Adapter->Lock);

        RemoveEntryList(&Vc->Linkage);

        PS_UNLOCK(&Vc->Adapter->Lock);

        if(Vc->Flags & GPC_WANLINK_VC) 
        {
            REFDEL(&Vc->WanLink->RefCount, FALSE, 'WANV');
        }

        REFDEL(&Vc->Adapter->RefCount, FALSE, 'ADVC');


        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
    }
    else 
    {
        PADAPTER Adapter = Vc->Adapter;

        if(Vc->Flags & GPC_WANLINK_VC) 
        {
            REFDEL(&Vc->WanLink->RefCount, FALSE, 'WANV');
        }

        REFDEL(&Adapter->RefCount, FALSE, 'ADVC');
    }

    return(NDIS_STATUS_SUCCESS);

} // CmDeleteVc


VOID
FillInCmParams(
    PCO_CALL_MANAGER_PARAMETERS CmParams,
    SERVICETYPE ServiceType,
    ULONG TokenRate,
    ULONG PeakBandwidth,
    ULONG TokenBucketSize,
    ULONG DSMode,
    ULONG Priority)
{
    PCO_SPECIFIC_PARAMETERS SpecificParameters;
    QOS_SD_MODE * QoSObjectSDMode;
    QOS_PRIORITY * QoSObjectPriority;
    QOS_OBJECT_HDR * QoSObjectHdr;

    CmParams->Transmit.ServiceType = ServiceType;
    CmParams->Transmit.TokenRate = TokenRate;
    CmParams->Transmit.PeakBandwidth = PeakBandwidth;
    CmParams->Transmit.TokenBucketSize = TokenBucketSize;

    CmParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CmParams->CallMgrSpecific.Length = 0;

    SpecificParameters = 
        (PCO_SPECIFIC_PARAMETERS)&CmParams->CallMgrSpecific.Parameters;

    if(DSMode != QOS_UNSPECIFIED){

        CmParams->CallMgrSpecific.Length += sizeof(QOS_SD_MODE);
        QoSObjectSDMode = (QOS_SD_MODE *)SpecificParameters;
        QoSObjectSDMode->ObjectHdr.ObjectType = QOS_OBJECT_SD_MODE;
        QoSObjectSDMode->ObjectHdr.ObjectLength = sizeof(QOS_SD_MODE);
        QoSObjectSDMode->ShapeDiscardMode = DSMode;
        (QOS_SD_MODE *)SpecificParameters++;
    }

    if(Priority != QOS_UNSPECIFIED){

        CmParams->CallMgrSpecific.Length += sizeof(QOS_PRIORITY);
        QoSObjectPriority = (QOS_PRIORITY *)SpecificParameters;
        QoSObjectPriority->ObjectHdr.ObjectType = QOS_OBJECT_PRIORITY;
        QoSObjectPriority->ObjectHdr.ObjectLength = sizeof(QOS_PRIORITY);
        QoSObjectPriority->SendPriority = (UCHAR)Priority;
        (QOS_PRIORITY *)SpecificParameters++;
    }

    QoSObjectHdr = (QOS_OBJECT_HDR *)SpecificParameters;
    QoSObjectHdr->ObjectType = QOS_OBJECT_END_OF_LIST;
    QoSObjectHdr->ObjectLength = sizeof(QOS_OBJECT_HDR);
}
   

NDIS_STATUS
ValidateCallParameters(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters
    )
{
    ULONG               TokenRate = CallParameters->Transmit.TokenRate;
    SERVICETYPE         ServiceType = CallParameters->Transmit.ServiceType;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    UCHAR               SendPriority;
    ULONG               SDMode;
    ULONG               PeakBandwidth;
    LONG                ParamsLength;
    LPQOS_OBJECT_HDR    QoSObject;
    ULONG               Class;
    ULONG               DSFieldCount;
    LPQOS_DIFFSERV_RULE pDiffServRule;
    ULONG               i;
    ULONG               ShapingRate;

    ParamsLength = (LONG)CallParameters->CallMgrSpecific.Length;
    PeakBandwidth = CallParameters->Transmit.PeakBandwidth;

    //
    // By default, we want to shape to the TokenRate
    //
    Vc->ShapeTokenRate = TokenRate;

    QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrSpecific.Parameters;

    while (ParamsLength > sizeof(QOS_OBJECT_HDR)) {

        switch(QoSObject->ObjectType){

          case QOS_OBJECT_TRAFFIC_CLASS:

            if (ParamsLength < sizeof(QOS_TRAFFIC_CLASS))
                return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;

             Class = (((LPQOS_TRAFFIC_CLASS)QoSObject)->TrafficClass);
             
             if(Class > USER_PRIORITY_MAX_VALUE)
             {
                return QOS_STATUS_INVALID_TRAFFIC_CLASS;
             }
             
             break;
             
          case QOS_OBJECT_DS_CLASS:

            if (ParamsLength < sizeof(QOS_DS_CLASS))
                return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;
        
             Class = (((LPQOS_DS_CLASS)QoSObject)->DSField);
           
             if(Class > PREC_MAX_VALUE)
             {
                return QOS_STATUS_INVALID_DS_CLASS;
             }
             
             break;

          case QOS_OBJECT_SHAPING_RATE:

            if (ParamsLength < sizeof(QOS_SHAPING_RATE))
                return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;

              ShapingRate = (((LPQOS_SHAPING_RATE)QoSObject)->ShapingRate);

              if(ShapingRate == 0 || ShapingRate > TokenRate)
              {
                  return QOS_STATUS_INVALID_SHAPE_RATE;
              }
              else 
              {
                  //
                  // If this QoS object is present, we want to shape to this 
                  // rate.
                  //
                  Vc->ShapeTokenRate = ShapingRate;
              }

              break;

        case QOS_OBJECT_PRIORITY:

            if (ParamsLength < sizeof(QOS_PRIORITY))
                return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;

            SendPriority = ((LPQOS_PRIORITY)QoSObject)->SendPriority;

            if((SendPriority < 0) || (SendPriority > 7)){

                // bad priority value - reject

                return(QOS_STATUS_INVALID_QOS_PRIORITY);
            }

            break;

        case QOS_OBJECT_SD_MODE:

            if (ParamsLength < sizeof(QOS_SD_MODE))
                return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;

            SDMode = ((LPQOS_SD_MODE)QoSObject)->ShapeDiscardMode;

            // 
            // Since SDMode is a ULONG, it can never be < TC_NONCONF_BORROW, which has a value of 0.
            // so, we just check to see if SDMode is > TC_NONCONF_BORROW_PLUS. This covers all cases.
            //

            if(SDMode > TC_NONCONF_BORROW_PLUS){

                // bad shape discard mode - reject

                return(QOS_STATUS_INVALID_SD_MODE);
            }

            if((SDMode > TC_NONCONF_BORROW) && 
               (TokenRate == UNSPECIFIED_RATE)){

                // must have TokenRate specified if any SDMode
                // other than TC_NONCONF_BORROW

                return(QOS_STATUS_INVALID_TOKEN_RATE);
            }

            break;

            // Pass any provider specific objects that we don't recognize
        default:
            return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
         }

        if(
            ((LONG)QoSObject->ObjectLength <= 0) ||
            ((LONG)QoSObject->ObjectLength > ParamsLength)
          ) {

            return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
        }

        ParamsLength -= QoSObject->ObjectLength;
        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + 
                                       QoSObject->ObjectLength);

    }

    if (ParamsLength == sizeof(QOS_OBJECT_HDR)) {
        if (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST) {
            return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
        }
    } else if (ParamsLength != 0) {
        return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
    }

    // 
    // If there is a specified PeakBandwidth, it must be geq to the
    // TokenRate - meaning - there must be a TokenRate specified also.
    // This is reasonable for LAN, although ATM does allow a 
    // PeakBandwidth to be specified with no TokenRate.
    //
    // We also reject a TokenRate of zero. 
    //

    if(PeakBandwidth != UNSPECIFIED_RATE){

        if(TokenRate == UNSPECIFIED_RATE){

            return(QOS_STATUS_INVALID_PEAK_RATE);
        }

        if(TokenRate > PeakBandwidth){

            return(QOS_STATUS_INVALID_PEAK_RATE);
        }
    }

    if(TokenRate == 0){

        return(QOS_STATUS_INVALID_TOKEN_RATE);
    }

    switch(ServiceType){

    case SERVICETYPE_BESTEFFORT:
    case SERVICETYPE_NETWORK_CONTROL:
    case SERVICETYPE_QUALITATIVE:

        break;

    case SERVICETYPE_CONTROLLEDLOAD:
    case SERVICETYPE_GUARANTEED:

        // Must specify a TokenRate for these services

        if(TokenRate == QOS_UNSPECIFIED) {

            return(QOS_STATUS_INVALID_TOKEN_RATE);
        }
        break;

    default:

        return(QOS_STATUS_INVALID_SERVICE_TYPE);
    }
    
    return(Status);
}



NDIS_STATUS
AcquireFlowResources(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_MANAGER_PARAMETERS NewCallParams,
    PCO_CALL_MANAGER_PARAMETERS OldCallParams,
    PULONG RemainingBandWidthChanged
    
    )

/*++

Routine Description:

    See if this adapter can support the requested flow. If it can, 
    NDIS_STATUS_SUCCESS is returned, indicating that the resources
    have been committed.

Arguments:

    Vc - pointer to vc's context block
    NewCallParams - struct describing the flow to add or to modify to.
    OldCallParams - in case of a modify, this describes the old params.
    

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    PADAPTER        Adapter;
    ULONG           OldTokenRate;
    SERVICETYPE     OldServiceType;
    ULONG           NewTokenRate   = NewCallParams->Transmit.TokenRate;
    SERVICETYPE     NewServiceType = NewCallParams->Transmit.ServiceType;
    NDIS_STATUS     Status         = NDIS_STATUS_SUCCESS;
    PULONG          RemainingBandWidth;
    PULONG          NonBestEffortLimit;
    PPS_SPIN_LOCK Lock;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    *RemainingBandWidthChanged = FALSE;

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        NonBestEffortLimit = &Vc->WanLink->NonBestEffortLimit;
        Lock = &Vc->WanLink->Lock;
        return NDIS_STATUS_SUCCESS;
    }
    else 
    {
        RemainingBandWidth = &Adapter->RemainingBandWidth;
        NonBestEffortLimit = &Adapter->NonBestEffortLimit;
        Lock = &Adapter->Lock;
    }


    if(OldCallParams)
    {
        OldTokenRate = OldCallParams->Transmit.TokenRate;
        OldServiceType = OldCallParams->Transmit.ServiceType;
    }

    //
    // sanity check passed; now see if we have the resouces locally
    //
    // for best-effort flows, the token rate, for the purpose of
    // admission control, is considered to be zero
    //

    if(NewServiceType == SERVICETYPE_BESTEFFORT || NewServiceType == SERVICETYPE_NETWORK_CONTROL ||
       NewServiceType == SERVICETYPE_QUALITATIVE)
    {

        NewTokenRate = 0;
    }

    // 
    // Handle add differently from a modify
    //

    if(!OldCallParams){

        PS_LOCK(Lock);
    
        if((((LONG)(*RemainingBandWidth)) < 0) || (NewTokenRate > *RemainingBandWidth)){

            PS_UNLOCK(Lock);

            return(NDIS_STATUS_RESOURCES);

        }
        else{

            if(NewTokenRate) {
                
                *RemainingBandWidthChanged = TRUE;
            }

            *RemainingBandWidth -= NewTokenRate;

            //
            // Record the change we made, in case we have
            // to cancel the addition.
            //

            Vc->TokenRateChange = NewTokenRate;
            Vc->RemainingBandwidthIncreased = FALSE;

            PsAssert((*RemainingBandWidth <=  *NonBestEffortLimit));

            PS_UNLOCK(Lock);
        }
    }
    else{

        //
        // it's a modify
        // 
        // If the OldServiceType is best-effort, 
        // then the OldTokenRate can be considered
        // to be zero, for the purpose of admission control.
        //

        if(OldServiceType == SERVICETYPE_BESTEFFORT || 
           OldServiceType == SERVICETYPE_NETWORK_CONTROL ||
           OldServiceType == SERVICETYPE_QUALITATIVE)
        {

            OldTokenRate = 0;
        }

        PS_LOCK(Lock);

        if(NewTokenRate != OldTokenRate){

            if((((LONG) *RemainingBandWidth) < 0 )||
               ((NewTokenRate > OldTokenRate) && 
                ((NewTokenRate - OldTokenRate) > 
                 (*RemainingBandWidth)))){
                
                //
                // asked for more and none was available
                //
           
                PS_UNLOCK( Lock );

                return(NDIS_STATUS_RESOURCES);

            }
            else{

                //
                // either asked for less or rate increment was available
                //

                *RemainingBandWidth -= NewTokenRate;
                *RemainingBandWidth += OldTokenRate;

                if((NewTokenRate != 0) || (OldTokenRate != 0)) {

                    *RemainingBandWidthChanged = TRUE;
                }
                   
                //
                // Now we've acquired the resources. If
                // the VC activation fails for any reason,
                // we'll need to return resources. We should
                // return the difference between the old token
                // rate and the new token rate, not the new token
                // rate.
                //

                if(NewTokenRate > OldTokenRate){

                    // Can't use signed ints, cause we'll lose range

                    Vc->TokenRateChange = NewTokenRate - OldTokenRate;
                    Vc->RemainingBandwidthIncreased = FALSE;

                }
                else{

                    Vc->TokenRateChange = OldTokenRate - NewTokenRate;
                    Vc->RemainingBandwidthIncreased = TRUE;
                }

                PS_UNLOCK( Lock );
            }
        }
        else{

            PS_UNLOCK(Lock);
        }

    }

    return Status;

} // AcquireFlowResources

VOID
CancelAcquiredFlowResources(
    PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    Called when a modify or add flwo failed, after we did admission control.

Arguments:

    Vc - pointer to client vc's context block

Return Value:

    None

--*/

{
    PADAPTER        Adapter;
    PPS_SPIN_LOCK Lock;
    PULONG RemainingBandWidth;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        Lock = &Vc->WanLink->Lock;
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        return;
    }
    else 
    {
        Lock = &Adapter->Lock;
        RemainingBandWidth = &Adapter->RemainingBandWidth;
    }

    if(!Vc->TokenRateChange){

        return;
    }

    PS_LOCK( Lock );

    if(Vc->RemainingBandwidthIncreased){

        *RemainingBandWidth -= Vc->TokenRateChange;
    }
    else{

        *RemainingBandWidth += Vc->TokenRateChange;
    }

    // 
    // Now that we have already returned the correct TokenRate, we need to set it to 0
    // so that this is not used in subsequent VC operations.
    //

    Vc->TokenRateChange = 0;

    // PsAssert(Adapter->RemainingBandWidth <= Adapter->NonBestEffortLimit);

    PS_UNLOCK( Lock );

} // CancelAcquiredFlowResources


VOID
ReturnFlowResources(
    PGPC_CLIENT_VC Vc,
    PULONG RemainingBandWidthChanged
    )

/*++

Routine Description:

    Return all the resources acquired for this flow

Arguments:
 
    Vc - pointer to client vc's context block

Return Value:

    None

--*/

{
    PADAPTER                      Adapter;
    PCO_CALL_MANAGER_PARAMETERS   CmParams    = Vc->CallParameters->CallMgrParameters;
    ULONG                         TokenRate   = CmParams->Transmit.TokenRate;
    SERVICETYPE                   ServiceType = CmParams->Transmit.ServiceType;
    PPS_SPIN_LOCK                 Lock;
    PULONG                        RemainingBandWidth;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    *RemainingBandWidthChanged = FALSE;

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        Lock = &Vc->WanLink->Lock;
        return;
    }
    else 
    {
        RemainingBandWidth = &Adapter->RemainingBandWidth;
        Lock = &Adapter->Lock;
    }

    if (ServiceType == SERVICETYPE_BESTEFFORT      || 
        ServiceType == SERVICETYPE_NETWORK_CONTROL || 
        ServiceType == SERVICETYPE_QUALITATIVE)
    {

        return;

    }

    *RemainingBandWidthChanged = TRUE;

    PsAssert((LONG)TokenRate > 0);

    PS_LOCK( Lock );

    *RemainingBandWidth += TokenRate;

    // PsAssert(Adapter->RemainingBandWidth <= Adapter->NonBestEffortLimit);

    PS_UNLOCK( Lock );

} // ReturnFlowResources


NDIS_STATUS
CreateBestEffortVc(
    PADAPTER Adapter,
    PGPC_CLIENT_VC Vc,
    PPS_WAN_LINK WanLink
    )
{
    PCO_CALL_PARAMETERS         CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParameters;
    PCO_MEDIA_PARAMETERS        MediaParameters;
    ULONG                       CallParamsLength;
    NDIS_STATUS                 Status;
    int                         i;


    InitGpcClientVc(Vc, GPC_CLIENT_BEST_EFFORT_VC, Adapter);
    SetLLTag(Vc, GpcClientVc);

    //
    //  Invalidate all the port numbers
    for( i = 0; i < PORT_LIST_LEN; i++)
    {
        Vc->SrcPort[i] = 0;
        Vc->DstPort[i] = 0;
    }

    //  Next Insertion will be at index 0
    Vc->NextSlot = 0;
    
    //
    // Allocate the resources for the call manager parameters.
    //

    CallParamsLength = sizeof(CO_CALL_PARAMETERS) +
                       sizeof(CO_CALL_MANAGER_PARAMETERS) +
                       sizeof(QOS_SD_MODE) +
                       sizeof(QOS_OBJECT_HDR) +
                       FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
                       FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    if(Adapter->MediaType == NdisMediumWan) 
    {
        CallParamsLength += sizeof(QOS_WAN_MEDIA);
        Vc->PsPipeContext = WanLink->PsPipeContext;
        Vc->PsComponent   = WanLink->PsComponent;
        Vc->AdapterStats  = &WanLink->Stats;
        Vc->WanLink       = WanLink;
        Vc->Flags        |= GPC_WANLINK_VC;

        if(Adapter->BestEffortLimit != UNSPECIFIED_RATE) 
        {
            //
            // If LBE is specified over WAN, use UBE
            //
                
            PsAdapterWriteEventLog(
                EVENT_PS_WAN_LIMITED_BESTEFFORT,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);

            Adapter->BestEffortLimit = UNSPECIFIED_RATE;
        }
    }
    else
    {
        Vc->PsPipeContext = Adapter->PsPipeContext;
        Vc->PsComponent   = Adapter->PsComponent;
        Vc->AdapterStats  = &Adapter->Stats;
    }

    PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

    if(CallParams == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    //
    // build a call params struct describing the flow
    //

    NdisZeroMemory(CallParams, CallParamsLength);

    //
    // Build the Call Manager Parameters.
    //
    CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);

    if(Adapter->BestEffortLimit == UNSPECIFIED_RATE)
    {
        FillInCmParams(CallMgrParameters,
                       SERVICETYPE_BESTEFFORT,
                       (ULONG)UNSPECIFIED_RATE,
                       (ULONG)UNSPECIFIED_RATE,
                       Adapter->TotalSize,
                       QOS_UNSPECIFIED,
                       QOS_UNSPECIFIED);
    }
    else 
    {
        // 
        // Limited Best Effort
        //

        PsAssert(Adapter->MediaType != NdisMediumWan);

        if(Adapter->BestEffortLimit >= Adapter->LinkSpeed) {

            // If the specified limit is greater than the link speed,
            // then we should operate in unlimited best-effort mode.
            
            
            PsAdapterWriteEventLog(
                EVENT_PS_BAD_BESTEFFORT_LIMIT,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);
            
            PsDbgOut(DBG_INFO,
                     DBG_PROTOCOL,
                     ("[CreateBestEffortVc]: b/e limit %d exceeds link speed %d\n",
                      Adapter->BestEffortLimit,
                      Adapter->LinkSpeed));
            
            Adapter->BestEffortLimit = UNSPECIFIED_RATE;

            FillInCmParams(CallMgrParameters,
                           SERVICETYPE_BESTEFFORT,
                           (ULONG)UNSPECIFIED_RATE,
                           (ULONG)UNSPECIFIED_RATE,
                           Adapter->TotalSize,
                           QOS_UNSPECIFIED,
                           QOS_UNSPECIFIED);
            
        }
        else
        {
            FillInCmParams(CallMgrParameters,
                           SERVICETYPE_BESTEFFORT,
                           Adapter->BestEffortLimit,
                           (ULONG)UNSPECIFIED_RATE,
                           Adapter->TotalSize,
                           TC_NONCONF_SHAPE,
                           QOS_UNSPECIFIED);
        }
    }


    //
    // Build the MediaParameters.
    //

    CallParams->MediaParameters = 
                    (PCO_MEDIA_PARAMETERS)(CallMgrParameters + 1);

    MediaParameters = (PCO_MEDIA_PARAMETERS)((PUCHAR)
                            CallMgrParameters +
                            sizeof(CO_CALL_MANAGER_PARAMETERS) +
                            sizeof(QOS_SD_MODE) +
                            sizeof(QOS_OBJECT_HDR));

    MediaParameters->Flags = 0;
    MediaParameters->ReceivePriority = 0;
    MediaParameters->ReceiveSizeHint = 0;
    MediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    MediaParameters->MediaSpecific.Length = 0;

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParameters;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)MediaParameters;

    if(Adapter->MediaType == NdisMediumWan) {

        LPQOS_WAN_MEDIA WanMedia;
        MediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) MediaParameters->MediaSpecific.Parameters;

        NdisZeroMemory(WanMedia, sizeof(QOS_WAN_MEDIA));

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       &WanLink->OriginalRemoteMacAddress,
                       6);

    }

    Vc->CallParameters = CallParams;

    Status = CmMakeCall(Vc);

    PsAssert(Status != NDIS_STATUS_PENDING);

    if(Status == NDIS_STATUS_SUCCESS)
    {

        REFADD(&Adapter->RefCount, 'ADVC');
        if(Adapter->MediaType == NdisMediumWan)
        {
            REFADD(&WanLink->RefCount, 'WANV');
        }
        //
        // Also save the non conforming value - so that the sequencer can stamp it
        // for non conforming packets. This will not change between reboots & hence
        // need not be done in the ModifyCfInfo
        //
        
        Vc->UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
       
        switch(Vc->CallParameters->CallMgrParameters->Transmit.ServiceType)
        {
          case SERVICETYPE_CONTROLLEDLOAD:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeControlledLoad;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeControlledLoadNC;
              break;
          case SERVICETYPE_GUARANTEED:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeGuaranteed;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeGuaranteedNC;
              break;
          case SERVICETYPE_BESTEFFORT:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeBestEffortNC;
              break;
          case SERVICETYPE_QUALITATIVE:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeQualitative;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeQualitativeNC;
              break;
          case SERVICETYPE_NETWORK_CONTROL:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeNetworkControl;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeNetworkControlNC;
              break;
        }
        
        //
        // Transistion to the Call complete state
        //
        
        CallSucceededStateTransition(Vc);

    }

    return Status;
}

/* end cmvc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\config.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This file contains all routines necessary for the support of dynamic
    configuration.

Author:

    Rajesh Sundaram (rajeshsu)

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

//
// Forward declaration for using #pragma

NDIS_STATUS
PsReadAdapterRegistryDataInit(PADAPTER     Adapter,
                              PNDIS_STRING AdapterKey
                              );

NDIS_STATUS
PsReadAdapterRegistryData(PADAPTER     Adapter,
                         PNDIS_STRING MachineKey,
                         PNDIS_STRING AdapterKey);


#pragma alloc_text(PAGE, PsReadAdapterRegistryData)
#pragma alloc_text(PAGE, PsReadAdapterRegistryDataInit)


//
// Local functions used to access the registry.
//

NDIS_STATUS 
PsReadRegistryInt(
    IN NDIS_HANDLE  ConfigHandle,
    IN PNDIS_STRING ValueName,
    IN ULONG        ValueDefault,
    IN OUT PULONG   ValuePtr,
    IN ULONG        ValueMin,
    IN ULONG        ValueMax,
    IN BOOLEAN      Subkey,
    IN PNDIS_STRING SubKeyName,
    IN HANDLE       SubKeyHandle,
    IN BOOLEAN      ZAW
)
{
    PNDIS_CONFIGURATION_PARAMETER ConfigParam;
    NDIS_STATUS                   Status;
    NTSTATUS                      NtStatus;
    ULONG                         Value;

    RTL_QUERY_REGISTRY_TABLE ServiceKeys[] = 
    {
        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0},

        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0},
        
        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0}
    };

    if(Subkey)
    {
        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("[PsReadSingleParameter]: Subkey %ws, Key %ws \n", 
                  SubKeyName->Buffer, ValueName->Buffer));

        NdisReadConfiguration(&Status,
                              &ConfigParam,
                              SubKeyHandle,
                              ValueName,
                              NdisParameterInteger);
    }
    else 
    {
        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("[PsReadSingleParameter]: Subkey NULL, Key %ws \n", ValueName->Buffer));

        NdisReadConfiguration(&Status,
                              &ConfigParam,
                              ConfigHandle,
                              ValueName,
                              NdisParameterInteger);

    }

    if(Status == NDIS_STATUS_SUCCESS)
    {
        *ValuePtr = ConfigParam->ParameterData.IntegerData;

        if(*ValuePtr < ValueMin || *ValuePtr > ValueMax)
        {
            PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                     ("[PsReadSingleParameter]: Per adapter:  %d does not fall in range (%d - %d) \n",
                      *ValuePtr, ValueMin, ValueMax));

            *ValuePtr = ValueDefault;
        }

        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("\t\t Per adapter: 0x%x \n", *ValuePtr));

        return Status;
    }
    else 
    {
        if(ZAW)
        {
            //
            // See if we can read it from the per machine area. We need to use the RtlAPIs for this.
            //
            if(Subkey)
            {
                ServiceKeys[0].QueryRoutine  = NULL;
                ServiceKeys[0].Flags         = RTL_QUERY_REGISTRY_SUBKEY;
                ServiceKeys[0].Name          = SubKeyName->Buffer;
                ServiceKeys[0].EntryContext  = NULL;
                ServiceKeys[0].DefaultType   = REG_NONE;
                ServiceKeys[0].DefaultData   = NULL;
                ServiceKeys[0].DefaultLength = 0;
                
                ServiceKeys[1].QueryRoutine  = NULL;
                ServiceKeys[1].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
                ServiceKeys[1].Name          = ValueName->Buffer;
                ServiceKeys[1].EntryContext  = &Value;
                ServiceKeys[1].DefaultType   = REG_DWORD;
                ServiceKeys[1].DefaultData   = NULL;
                ServiceKeys[1].DefaultLength = 0;
            }
            else 
            {
                ServiceKeys[0].QueryRoutine  = NULL;
                ServiceKeys[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
                ServiceKeys[0].Name          = ValueName->Buffer;
                ServiceKeys[0].EntryContext  = &Value;
                ServiceKeys[0].DefaultType   = REG_DWORD;
                ServiceKeys[0].DefaultData   = NULL;
                ServiceKeys[0].DefaultLength = 0;
            }
            
            
            NtStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE,
                MachineRegistryKey.Buffer,
                ServiceKeys,
                NULL,
                NULL);
            
            if(NT_SUCCESS(NtStatus))
            {
                *ValuePtr = Value;
                
                if(*ValuePtr < ValueMin || *ValuePtr > ValueMax)
                {
                    PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                             ("[PsReadSingleParameter]: ZAW %ws %d does not fall in range (%d - %d) \n",
                              ValueName->Buffer, *ValuePtr, ValueMin, ValueMax));

                    *ValuePtr = ValueDefault;
                }
                
                PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, ("\t\tZAW 0x%x \n", *ValuePtr));

                return NDIS_STATUS_SUCCESS;
            }
            else
            {
                *ValuePtr = ValueDefault;
                PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, 
                         ("\t\tNot in ZAW/Adapter, Using default %d \n", *ValuePtr));

                return NtStatus;
            }
        }
        else 
        {
            *ValuePtr = ValueDefault;
            PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, 
                     ("\t\tNot in ZAW/Adapter, Using default %d \n", *ValuePtr));

            return Status;

        }
    }
}


NTSTATUS
PsReadRegistryString(IN NDIS_HANDLE  ConfigHandle,
             IN PNDIS_STRING Key,
             IN PNDIS_STRING Buffer
             )
{
    NDIS_STATUS                   Status;
    PNDIS_CONFIGURATION_PARAMETER ConfigParam;
    
    NdisReadConfiguration(&Status,
                          &ConfigParam,
                          ConfigHandle,
                          Key,
                          NdisParameterMultiString);

    if(Status == NDIS_STATUS_SUCCESS)
    {
        Buffer->Length        = ConfigParam->ParameterData.StringData.Length;
        Buffer->MaximumLength = Buffer->Length + sizeof(WCHAR);

        PsAllocatePool(Buffer->Buffer,
                       Buffer->MaximumLength,
                       PsMiscTag);

        if(Buffer->Buffer)
        {
            RtlCopyUnicodeString(Buffer, &ConfigParam->ParameterData.StringData);
        } else {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    return Status;
}


STATIC VOID
ReadProfiles(
    NDIS_HANDLE                   ConfigHandle
    )
/*++

Routine Description:
    This routine is used by the driver to read the Profiles key from the
    registry. The profile is a multiple string list of available profiles.
    Each entry on this list identifies another value under Psched\Parameters
    which contains the list of modules that comprise the profile.

Arguments:
    ConfigHandle - Handle to the registry entry

Return Value:
--*/
{
    NDIS_STATUS                   Status;
    PNDIS_CONFIGURATION_PARAMETER pConfigParam;
    PNDIS_CONFIGURATION_PARAMETER pProfileParam;
    PPS_PROFILE                   pProfileInfo;
    PWSTR                         r, p;
    UINT                          i, j, cnt;
    NDIS_STRING                   ProfileKey = NDIS_STRING_CONST("Profiles");
    NDIS_STRING                   StringName;
    BOOLEAN                       StubFlag;
    NDIS_STRING                   StubComponent = NDIS_STRING_CONST("SchedulerStub");

    NdisReadConfiguration( &Status,
                           &pConfigParam,
                           ConfigHandle,
                           &ProfileKey,
                           NdisParameterMultiString);

    if ( NT_SUCCESS( Status ))
    {
        //
        // pConfigParam now contains a list of profiles.
        //
        for (p = pConfigParam->ParameterData.StringData.Buffer, i = 0;
             *p != L'\0';
             i++)
        {

            //
            // Allocate a new PS_PROFILE entry and store it into
            // a global list.
            //

            PsAllocatePool(pProfileInfo, sizeof(PS_PROFILE), ProfileTag);

            if(!pProfileInfo)
            {
                //
                // Don't have to worry about freeing the previous profiles as they will get freed
                // when we clear the PsProfileList.
                //

                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                         ("[ReadProfiles]: cannot allocate memory to hold profile \n"));

                break;
            }

            NdisZeroMemory(pProfileInfo, sizeof(PS_PROFILE));
            InsertHeadList( &PsProfileList, &pProfileInfo->Links );

            // Copy the Profile Name
            // 1. Initialize the unicode strings
            // 2. Allocate memory for the string
            // 3. Copy the string over.

            RtlInitUnicodeString(&StringName, p);
            RtlInitUnicodeString(&pProfileInfo->ProfileName, p);
            PsAllocatePool(pProfileInfo->ProfileName.Buffer,
                           pProfileInfo->ProfileName.MaximumLength,
                           ProfileTag);

            if(!pProfileInfo->ProfileName.Buffer)
            {
                //
                // Again, cleanup of the other profils will be done when we clean up the ProfileList
                //

                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                         ("[ReadProfiles]: cannot allocate memory to hold profile's name \n"));

                break;
            }

            NdisZeroMemory(pProfileInfo->ProfileName.Buffer,
                           pProfileInfo->ProfileName.MaximumLength);
            RtlCopyUnicodeString(&pProfileInfo->ProfileName, &StringName);


            PsDbgOut(DBG_TRACE,
                     DBG_INIT,
                     ("[ReadProfiles]: Adding profile %ws \n",
                      pProfileInfo->ProfileName.Buffer));

            // The last scheduling component of every profile should
            // be a stub component. If this component is not present
            // in the profile, we have to add it manually.

            StubFlag = FALSE;
            cnt = 0;

            //
            // Each of the name identifies another value under
            // "Psched\Parameters". This value contains the list of
            // components that comprize the profile.
            //

            NdisReadConfiguration( &Status,
                                   &pProfileParam,
                                   ConfigHandle,
                                   &pProfileInfo->ProfileName,
                                   NdisParameterMultiString);
            if(NT_SUCCESS (Status))
            {
                // Read the components and associate with a
                // PSI_INFO.

                NDIS_STRING ComponentName;
                for (r = pProfileParam->ParameterData.StringData.Buffer, j=0;
                     *r != L'\0'; j++)
                {
                    PSI_INFO *PsiComponentInfo = 0;
                    RtlInitUnicodeString(&ComponentName, r);
                    PsDbgOut(DBG_TRACE, DBG_INIT,
                             ("[ReadProfiles]: Adding component %ws to "
                              "Profile %ws \n",
                              ComponentName.Buffer,
                              pProfileInfo->ProfileName.Buffer));

                    if(!StubFlag && (RtlCompareUnicodeString(&ComponentName,
                                                            &StubComponent,
                                                            FALSE)== 0))
                        StubFlag = TRUE;

                    if(cnt == MAX_COMPONENT_PER_PROFILE)
                    {
                        PsDbgOut(DBG_CRITICAL_ERROR,
                                 DBG_INIT,
                                 ("[ReadProfiles]: Profile %ws cannot have "
                                  "more than %d components \n",
                                  pProfileInfo->ProfileName.Buffer,
                                  MAX_COMPONENT_PER_PROFILE));
                    }
                    else
                    {
                        if(FindSchedulingComponent(&ComponentName, &PsiComponentInfo) ==
                           NDIS_STATUS_FAILURE)
                        {
                            //
                            // The component does not exist. Therefore, we
                            // store the unregistered component in the list
                            //

                            PsDbgOut(DBG_TRACE, DBG_INIT,
                                     ("[ReadProfiles]: Adding add-in component"
                                      " %ws to list\n", ComponentName.Buffer));

                            PsAllocatePool(PsiComponentInfo,
                                           sizeof(PSI_INFO),
                                           ComponentTag);

                            if(!PsiComponentInfo)
                            {
                                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                                         ("[ReadProfiles]: No memory to store add-in components \n"));

                                break;

                            }

                            pProfileInfo->UnregisteredAddInCnt ++;

                            NdisZeroMemory(PsiComponentInfo, sizeof(PSI_INFO));

                            RtlInitUnicodeString(&PsiComponentInfo->ComponentName, r);

                            PsAllocatePool(
                                PsiComponentInfo->ComponentName.Buffer,
                                ComponentName.MaximumLength,
                                ComponentTag);

                            if(!PsiComponentInfo->ComponentName.Buffer)
                            {
                                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                                         ("[ReadProfiles]: No memory to store add-in components \n"));

                                PsFreePool(PsiComponentInfo);

                                break;
                            }

                            RtlCopyUnicodeString(&PsiComponentInfo->ComponentName,
                                                 &ComponentName);

                            PsiComponentInfo->Registered = FALSE;

                            PsiComponentInfo->AddIn = TRUE;

                            InsertHeadList(&PsComponentList, &PsiComponentInfo->Links );
                        }

                        // Add the component to the profile.
                        pProfileInfo->ComponentList[cnt++]=PsiComponentInfo;

                        pProfileInfo->ComponentCnt = cnt;
                    }
                    r = (PWSTR)((PUCHAR)r + ComponentName.Length +
                                sizeof(WCHAR));
                }
            }

            if(!StubFlag)
            {
                PsDbgOut(DBG_INFO, DBG_INIT,
                         ("[ReadProfiles]: Profile %ws should end in a stub "
                          "component. Adding a stub component \n",
                          pProfileInfo->ProfileName.Buffer));

                // Needn't worry about overflow, as we have allocated an
                // extra one for the stub component.

                pProfileInfo->ComponentList[cnt++] = &SchedulerStubInfo;
                pProfileInfo->ComponentCnt = cnt;
            }
            p = (PWSTR)((PUCHAR)p + pProfileInfo->ProfileName.Length
                        + sizeof(WCHAR));
        }
    }
}


NDIS_STATUS
PsReadDriverRegistryDataInit (
    )
/*++

Routine Description:

    This routine is called by the driver to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults in this module.

Arguments:

    RegistryPath - The name of the driver's node in the registry.

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NDIS_HANDLE  ConfigHandle;
    NDIS_STATUS  Status;
    NDIS_STRING  PSParamsKey        = NDIS_STRING_CONST("PSched\\Parameters");
#if DBG
    ULONG        Size;
    NTSTATUS     NtStatus;

    NDIS_STRING DebugLevelKey       = NDIS_STRING_CONST("DebugLevel");
    NDIS_STRING DebugMaskKey        = NDIS_STRING_CONST("DebugMask");
    NDIS_STRING TraceLogLevelKey    = NDIS_STRING_CONST("TraceLogLevel");
    NDIS_STRING TraceLogMaskKey     = NDIS_STRING_CONST("TraceLogMask");
    NDIS_STRING TraceBufferSizeKey  = NDIS_STRING_CONST("TraceBufferSize");
    NDIS_STRING ClassificationTypeKey  = NDIS_STRING_CONST("ClassificationType");

#endif

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &PSParamsKey);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                 ("[PsReadDriverRegistryDataInit]: cannot read registry \n"));

        return Status;
    }

#if DBG

    PsReadRegistryInt(
        ConfigHandle,
        &DebugLevelKey,
        0,
        &DbgTraceLevel,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &DebugMaskKey,
        0,
        &DbgTraceMask,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceLogLevelKey,
        DBG_VERBOSE,
        &LogTraceLevel,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceLogMaskKey,
        (DBG_INIT  |  DBG_IO  |  DBG_GPC_QOS  | DBG_MINIPORT | DBG_PROTOCOL | 
         DBG_VC    |  DBG_WMI |  DBG_STATE    | DBG_WAN),
        &LogTraceMask,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceBufferSizeKey,
        TRACE_BUFFER_SIZE,
        &Size,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ClassificationTypeKey,
        0,
        &ClassificationType,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);


    SchedInitialize(Size);
#endif

    ReadProfiles(ConfigHandle);

    NdisCloseConfiguration( ConfigHandle );

    return STATUS_SUCCESS;
}


NDIS_STATUS
PsReadDriverRegistryData(
    )
{
    ULONG                  TimerResolution;
    ULONG                  desiredResolution;
    NDIS_STRING            PSParamsKey        = NDIS_STRING_CONST("PSched\\Parameters");
    NDIS_STRING            TimerResolutionKey = NDIS_STRING_CONST("TimerResolution");
    NTSTATUS               NtStatus;
    NDIS_HANDLE            ConfigHandle;
    NDIS_STATUS            Status;

    // No value was specified in the registry. Let's just keep it at the system's default.
    // But, we need to query this value so that we can respond correctly to OID_QOS_TIMER_RESOLUTION
    //
    if(gTimerSet)
    {
        //
        // Timer was set initially, but now it has been blown away. So, let's get back to the 
        // system default.
        //
        gTimerSet = 0;

        gTimerResolutionActualTime = ExSetTimerResolution(0, FALSE);
    }
    else 
    {
        //
        // Timer has never been set. Let's remember the system defaults.
        //

        gTimerResolutionActualTime = KeQueryTimeIncrement();
    }

    return STATUS_SUCCESS;
}


NDIS_STATUS
PsReadAdapterRegistryDataInit(PADAPTER     Adapter,
                              PNDIS_STRING AdapterKey
                              )
{
    ULONG       DisableDRR, IntermediateSystem;
    NTSTATUS    NtStatus;
    NDIS_HANDLE ConfigHandle, ServiceKeyHandle;
    NDIS_STRING DisableDRRKey          = NDIS_STRING_CONST("DisableDRR");
    NDIS_STRING IntermediateSystemKey  = NDIS_STRING_CONST("IntermediateSystem");
    NDIS_STRING BestEffortLimitKey     = NDIS_STRING_CONST("BestEffortLimit");
    NDIS_STRING ISSLOWTokenRateKey     = NDIS_STRING_CONST("ISSLOWTokenRate");
    NDIS_STRING ISSLOWPacketSizeKey    = NDIS_STRING_CONST("ISSLOWPacketSize");
    NDIS_STRING ISSLOWLinkSpeedKey     = NDIS_STRING_CONST("ISSLOWLinkSpeed");
    NDIS_STRING ISSLOWFragmentSizeKey  = NDIS_STRING_CONST("ISSLOWFragmentSize");
    NDIS_STRING BestEffortKey          = NDIS_STRING_CONST("ServiceTypeBestEffort");
    NDIS_STRING NonConformingKey       = NDIS_STRING_CONST("ServiceTypeNonConforming");
    NDIS_STRING ControlledLoadKey      = NDIS_STRING_CONST("ServiceTypeControlledLoad");
    NDIS_STRING GuaranteedKey          = NDIS_STRING_CONST("ServiceTypeGuaranteed");
    NDIS_STRING QualitativeKey         = NDIS_STRING_CONST("ServiceTypeQualitative");
    NDIS_STRING NetworkControlKey      = NDIS_STRING_CONST("ServiceTypeNetworkControl");
    NDIS_STRING ShapeDiscardModeKey    = NDIS_STRING_CONST("ShapeDiscardMode");
    NDIS_STRING UpperBindingsKey       = NDIS_STRING_CONST("UpperBindings");
    NDIS_STRING ProfileKey             = NDIS_STRING_CONST("Profile");
    NDIS_STATUS Status;

    PAGED_CODE();

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, AdapterKey);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT ,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X, Could not open config handle \n", 
                  Adapter));

        return Status;
    }


    PsReadRegistryString(
        ConfigHandle,
        &UpperBindingsKey,
        &Adapter->UpperBinding);

    if(!Adapter->UpperBinding.Buffer)
    {
        PsAdapterWriteEventLog(
            (ULONG)EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA,
            0,
            &Adapter->MpDeviceName,
            0,
            NULL);
        
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X: Missing UpperBindings key ", Adapter));

        NdisCloseConfiguration(ConfigHandle);
        
        return  NDIS_STATUS_FAILURE;
    }

    PsReadRegistryString(
        ConfigHandle,
        &ProfileKey,
        &Adapter->ProfileName);


    PsReadRegistryInt(
        ConfigHandle,
        &DisableDRRKey,
        0,
        &DisableDRR,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &IntermediateSystemKey,
        0,
        &IntermediateSystem,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &BestEffortLimitKey,
        UNSPECIFIED_RATE,
        &Adapter->BestEffortLimit,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    //
    // Read the ISSLOW related parameters.
    //

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWFragmentSizeKey,
        DEFAULT_ISSLOW_FRAGMENT_SIZE,
        &Adapter->ISSLOWFragmentSize,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWTokenRateKey,
        DEFAULT_ISSLOW_TOKENRATE,
        &Adapter->ISSLOWTokenRate,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWPacketSizeKey,
        DEFAULT_ISSLOW_PACKETSIZE,
        &Adapter->ISSLOWPacketSize,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWLinkSpeedKey,
        DEFAULT_ISSLOW_LINKSPEED,
        &Adapter->ISSLOWLinkSpeed,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    //
    // Read the ShapeDiscardMode for the service types.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &ShapeDiscardModeKey,
                                   &ServiceKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X, Using defaults for ShapeDiscardMode"
                  "since key cannot be opened \n", Adapter));

        Adapter->SDModeGuaranteed      = TC_NONCONF_SHAPE;
        Adapter->SDModeControlledLoad  = TC_NONCONF_BORROW;
        Adapter->SDModeQualitative     = TC_NONCONF_BORROW;
        Adapter->SDModeNetworkControl  = TC_NONCONF_BORROW;

    }
    else 
    {

        PsReadRegistryInt(
            ConfigHandle,
            &GuaranteedKey,
            TC_NONCONF_SHAPE,
            &Adapter->SDModeGuaranteed,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);
    
        PsReadRegistryInt(
            ConfigHandle,
            &ControlledLoadKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeControlledLoad,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);
    
        PsReadRegistryInt(
            ConfigHandle,
            &QualitativeKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeQualitative,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);

        PsReadRegistryInt(
            ConfigHandle,
            &NetworkControlKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeNetworkControl,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);

        NdisCloseConfiguration(ServiceKeyHandle);
    }

    NdisCloseConfiguration(ConfigHandle);
        
    if(DisableDRR)
    {
        Adapter->PipeFlags |= PS_DISABLE_DRR;
    }

    if(IntermediateSystem)
    {
        Adapter->PipeFlags |= PS_INTERMEDIATE_SYS;
    }

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PsReadAdapterRegistryData(PADAPTER     Adapter,
                         PNDIS_STRING MachineKey,
                         PNDIS_STRING AdapterKey)

/*++

Routine Description:

    Obtain the PSched specific info associated with the underlying MP.

Arguments:

    AdapterKey   - location of the per adapter key in the registry
    MachineKey   - location of the per Machine key in the registry
    Adapter      - pointer to the adapter structure

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    NDIS_STRING BestEffortKey          = NDIS_STRING_CONST("ServiceTypeBestEffort");
    NDIS_STRING NonConformingKey       = NDIS_STRING_CONST("ServiceTypeNonConforming");
    NDIS_STRING ControlledLoadKey      = NDIS_STRING_CONST("ServiceTypeControlledLoad");
    NDIS_STRING GuaranteedKey          = NDIS_STRING_CONST("ServiceTypeGuaranteed");
    NDIS_STRING QualitativeKey         = NDIS_STRING_CONST("ServiceTypeQualitative");
    NDIS_STRING NetworkControlKey      = NDIS_STRING_CONST("ServiceTypeNetworkControl");
    NDIS_STRING TcpTrafficKey          = NDIS_STRING_CONST("ServiceTypeTcpTraffic");
    NDIS_STRING MaxOutstandingSendsKey = NDIS_STRING_CONST("MaxOutstandingSends");
    NDIS_STRING NonBestEffortLimitKey  = NDIS_STRING_CONST("NonBestEffortLimit");
    NDIS_STRING DiffservKeyC           = NDIS_STRING_CONST("DiffservByteMappingConforming");
    NDIS_STRING DiffservKeyNC          = NDIS_STRING_CONST("DiffservByteMappingNonConforming");
    NDIS_STRING UserKey                = NDIS_STRING_CONST("UserPriorityMapping");
    NDIS_STATUS Status;
    NDIS_HANDLE SubKeyHandle, ConfigHandle;
    ULONG       Value;

    PAGED_CODE();

    PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
             ("\n [PsReadAdapterRegistryData]: Adapter %08X (%ws): Reading Registry Data \n", 
              Adapter, Adapter->RegistryPath.Buffer));

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &Adapter->RegistryPath);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Could not open config handle \n", 
                  Adapter));

        return Status;
    }
    
    PsReadRegistryInt(ConfigHandle,
                        &MaxOutstandingSendsKey,
                        DEFAULT_MAX_OUTSTANDING_SENDS,
                        &Adapter->MaxOutstandingSends,
                        1,
                        0xffffffff,
                        FALSE,
                        NULL,
                        NULL,
                        TRUE);

    PsReadRegistryInt(ConfigHandle,
                        &NonBestEffortLimitKey,
                        RESERVABLE_FRACTION,
                        &Adapter->ReservationLimitValue,
                        0,
                        200,
                        FALSE,
                        NULL,
                        NULL,
                        TRUE);

    //
    // Read the conforming values of DiffservByteMapping.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &DiffservKeyC,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "DiffservByteMappingConforming since key cannot be opened \n", Adapter));

        Adapter->IPServiceTypeBestEffort       = PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeControlledLoad   = PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT;
        Adapter->IPServiceTypeGuaranteed       = PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT;
        Adapter->IPServiceTypeQualitative      = PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT;
        Adapter->IPServiceTypeNetworkControl   = PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT;
        Adapter->IPServiceTypeTcpTraffic       = PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT;
    }
    else 
    {
        PsReadRegistryInt(ConfigHandle,
                          &TcpTrafficKey,
                          PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeTcpTraffic = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &BestEffortKey,
                          PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeBestEffort = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &ControlledLoadKey,
                          PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeControlledLoad = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &GuaranteedKey,
                          PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeGuaranteed = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &QualitativeKey,
                          PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeQualitative    = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &NetworkControlKey,
                          PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeNetworkControl = (UCHAR)Value;
        
        NdisCloseConfiguration(SubKeyHandle);
    }
        
    //
    // Read the non-conforming values of DiffservByteMapping.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &DiffservKeyNC,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "DiffservByteMappingNonConforming since key cannot be opened \n", Adapter));

        Adapter->IPServiceTypeBestEffortNC     = PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeControlledLoadNC = PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT;
        Adapter->IPServiceTypeGuaranteedNC     = PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT;
        Adapter->IPServiceTypeQualitativeNC    = PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT;
        Adapter->IPServiceTypeNetworkControlNC = PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeTcpTrafficNC     = PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT;
    }
    else
    {
        PsReadRegistryInt(ConfigHandle,
                          &TcpTrafficKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeTcpTrafficNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &BestEffortKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeBestEffortNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &ControlledLoadKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeControlledLoadNC = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &GuaranteedKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeGuaranteedNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &QualitativeKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeQualitativeNC    = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                          &NetworkControlKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_NETWORK_CONTROL_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeNetworkControlNC = (UCHAR)Value;
        
        NdisCloseConfiguration(SubKeyHandle);
    }

    //
    // Read the 802.1p values. The nonconforming in 802.1p does not depend on the 
    // service type. 
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &UserKey,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "UserPriorityMapping since key cannot be opened \n", Adapter));
        Adapter->UserServiceTypeBestEffort       = PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT;
        Adapter->UserServiceTypeControlledLoad   = PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT;
        Adapter->UserServiceTypeGuaranteed       = PS_USER_SERVICETYPE_GUARANTEED_DEFAULT;
        Adapter->UserServiceTypeQualitative      = PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT;
        Adapter->UserServiceTypeNetworkControl   = PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT;
        Adapter->UserServiceTypeNonConforming    = PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT;
        Adapter->UserServiceTypeTcpTraffic       = PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT;
    }
    else 
    {
        PsReadRegistryInt(ConfigHandle,
                            &TcpTrafficKey,
                            PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeTcpTraffic = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                            &BestEffortKey,
                            PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeBestEffort = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                            &ControlledLoadKey,
                            PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeControlledLoad = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &GuaranteedKey,
                            PS_USER_SERVICETYPE_GUARANTEED_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeGuaranteed = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &QualitativeKey,
                            PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeQualitative    = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &NonConformingKey,
                            PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeNonConforming  = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &NetworkControlKey,
                            PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeNetworkControl = (UCHAR)Value;

        NdisCloseConfiguration(SubKeyHandle);
    }
                        
    //
    // Now, we need to take this number, swap the bits around and put it in the higher order bits.
    // The DSCP codepoint is as follows:
    //
    //      --------------------------------
    // Bits | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    //      --------------------------------
    //      |           DSCP        |  CU   |
    //      --------------------------------
    //
    // Where DSCP - Differentiated services code point
    //         CU - Currently unused.
    //
    Adapter->IPServiceTypeBestEffort       = Adapter->IPServiceTypeBestEffort       << 2;
    Adapter->IPServiceTypeControlledLoad   = Adapter->IPServiceTypeControlledLoad   << 2;
    Adapter->IPServiceTypeGuaranteed       = Adapter->IPServiceTypeGuaranteed       << 2; 
    Adapter->IPServiceTypeQualitative      = Adapter->IPServiceTypeQualitative      << 2;
    Adapter->IPServiceTypeNetworkControl   = Adapter->IPServiceTypeNetworkControl   << 2;
    Adapter->IPServiceTypeBestEffortNC     = Adapter->IPServiceTypeBestEffortNC     << 2;
    Adapter->IPServiceTypeControlledLoadNC = Adapter->IPServiceTypeControlledLoadNC << 2;
    Adapter->IPServiceTypeGuaranteedNC     = Adapter->IPServiceTypeGuaranteedNC     << 2; 
    Adapter->IPServiceTypeQualitativeNC    = Adapter->IPServiceTypeQualitativeNC    << 2;
    Adapter->IPServiceTypeNetworkControlNC = Adapter->IPServiceTypeNetworkControlNC << 2;
    Adapter->IPServiceTypeTcpTraffic       = Adapter->IPServiceTypeTcpTraffic       << 2;
    Adapter->IPServiceTypeTcpTrafficNC     = Adapter->IPServiceTypeTcpTrafficNC     << 2;

    NdisCloseConfiguration(ConfigHandle);

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\config.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This file defines all constants and structures necessary for support of
    dynamic configuration.

Author:

    Charlie Wickham (charlwi) 26-Feb-1995

Revision History:

--*/

#include <ndis.h>

#ifndef _CONFIG_
#define _CONFIG_


/* Prototypes */ /* Generated by Emacs 19.17.0 on Thu Mar 09 08:42:15 1995 */

NDIS_STATUS
PsReadDriverRegistryData();

NDIS_STATUS
PsReadDriverRegistryDataInit();

NDIS_STATUS
PsReadAdapterRegistryData(
    IN PADAPTER Adapter,
    IN PNDIS_STRING MachineName,
    IN PNDIS_STRING AdapterName);

NDIS_STATUS
PsReadAdapterRegistryDataInit(
    IN PADAPTER Adapter,
    IN PNDIS_STRING AdapterName);


/* End Prototypes */

#endif /* _CONFIG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\conformr.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Conformr.c

Abstract:

    Token Bucket Conformer.  This module is a scheduling component that
    assigns conformance times to packets, based on the token bucket
    algorithm.

Author:
	Intel->YoramB->RajeshSu->SanjayKa.


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop


#ifdef QUEUE_LIMIT
ULONG gPhysMemSize;     // size of physical memory (in MB), used for shaper queue limit default

#endif // QUEUE_LIMIT


//
// For maintaining shaper Pipe & Flow Stats.
//
#define SHAPER_AVERAGING_ARRAY_SIZE         256
#define SHAPER_FLOW_AVERAGING_ARRAY_SIZE    256


// The conformer's pipe information

typedef struct _TBC_PIPE {

    // ContextInfo -            Generic context info
    // MaxPacket -              Maximum packet size for pipe
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // HeaderLength -           Length of MAC header for this pipe
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.

    PS_PIPE_CONTEXT ContextInfo;

    PS_CONFORMER_STATS  cStats;
    PS_SHAPER_STATS     sStats;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;
    ULONG PacketsInShaper;    

    ULONG MaxPacket;
    LIST_ENTRY ActiveFlows;
    ULONG TimerStatus;
    ULONG TimerResolution;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    ULONG HeaderLength;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;

    ULONG TimerUnloadFlag;
    NDIS_EVENT TimerUnloadEvent;

    // Need this to figure out the timer-wheel size //
    NDIS_MEDIUM MediaType;

    // Timer wheel parameters   //
    PVOID                   pTimerWheel;
    ULONG                   TimerWheelShift;
    NDIS_MINIPORT_TIMER     Timer;
    NDIS_SPIN_LOCK          Lock;

    ULONG                   SetSlotValue;
    LARGE_INTEGER           SetTimerValue;
    LARGE_INTEGER           ExecTimerValue;
    ULONG                   ExecSlot;

} TBC_PIPE, *PTBC_PIPE;


#define TIMER_UNINITIALIZED     0
#define TIMER_INACTIVE          1
#define TIMER_SET               2
#define TIMER_PROC_EXECUTING    3

typedef enum _FLOW_STATE {
    TS_FLOW_CREATED = 1,
    TS_FLOW_DELETED
} FLOW_STATE;

// The conformer's flow information

typedef struct _TBC_FLOW {

    // ContextInfo -            Generic context info
    // Lock -                   Protects flow data
    // TokenRate -              TokenRate from generic QoS
    // Capacity -               TokenBucketSize from generic QoS
    // PeakRate -               PeakBandwidth from generic QoS
    // MinPolicedUnit -         MinimumPolicedUnit from generic QoS
    // Mode -                   Flow S/D mode
    // NoConformance -          Indicates whether flow is exempt from conformance algorithm
    // LastConformanceTime -    Absolute tb conformance time of last non-discarded packet
    // PeakConformanceTime -    Earliest time next packet can be sent, based on peak rate
    // LastConformanceCredits - Number of credits at LastConformanceTime
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.

    PS_FLOW_CONTEXT ContextInfo;
    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Links;
    ULONG Mode;
    ULONG Shape;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER FlowEligibilityTime;
    ULONG LoopCount;
    ULONG TokenRate;
    ULONG Capacity;
    ULONG PeakRate;
    ULONG MinPolicedUnit;
    ULONG NoConformance;
    LARGE_INTEGER LastConformanceTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG LastConformanceCredits;
    HANDLE PsFlowContext;
#ifdef QUEUE_LIMIT
    ULONG QueueSize;
    ULONG QueueSizeLimit;
    ULONG DropOverLimitPacketsFromHead;
    ULONG UseDefaultQueueLimit;
#endif // QUEUE_LIMIT   

    PS_CONFORMER_STATS  cStats;
    PS_SHAPER_STATS     sStats;
    ULONG PacketsInShaper;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;

    FLOW_STATE      State;
} TBC_FLOW, *PTBC_FLOW;


// Macros used during token bucket conformance calculation

#define EARNED_CREDITS(_t,_r) ((ULONG)(( (_t) * (_r) ) / OS_TIME_SCALE))
#define TIME_TO_EARN_CREDITS(_c,_r) (((LONGLONG)(_c) * OS_TIME_SCALE) / (_r) )
#define TIME_TO_SEND(_c,_r) (((LONGLONG)(_c) * OS_TIME_SCALE) / (_r) )

#define PACKET_IS_CONFORMING(_ttime, _curtime, _r) \
    ( ((_ttime).QuadPart - (_curtime).QuadPart) <= (_r) )

#define LOCK_FLOW(_f)   NdisAcquireSpinLock(&(_f)->Lock)
#define UNLOCK_FLOW(_f) NdisReleaseSpinLock(&(_f)->Lock)

#define PacketIsEligible(_pktinfo, _flow, _curtime, _r) \
    ( (_pktinfo)->DelayTime.QuadPart <= ((_curtime).QuadPart + (_r)) )

#define FlowIsEligible(_flow, _curtime, _r) \
    ( (_flow)->FlowEligibilityTime.QuadPart <= ((_curtime).QuadPart  + (_r)) )

#define LOCK_PIPE(_p)   NdisAcquireSpinLock(&(_p)->Lock)
#define UNLOCK_PIPE(_p) NdisReleaseSpinLock(&(_p)->Lock)

//
// Define the maximum number of time for which a packet can live in the shaper. If a packet becomes conformant at 
// a time that is > this value, it gets discarded. This is to prevent apps from queueing up packets in the shaper 
// for a very long time (and exiting immediately causing a bugcheck when the app terminates after 5 min.). Note that
// this applies only to shape mode flows.
//

#define     MAX_TIME_FOR_PACKETS_IN_SHAPER  250000

#define     TIMER_WHEEL_QTY                 8              // in ms //
#define     TIMER_WHEEL_SHIFT               3
#define     MSIN100NS                       10000           // these many ticks are there in 1 ms //

#define     WAN_TIMER_WHEEL_SHIFT           8         // how many TIMER_WHEEL_QTY will it have? //
#define     LAN_TIMER_WHEEL_SHIFT           11         // how many TIMER_WHEEL_QTY will it have? //

#define     DUMMY_SLOT                      (0xffffffff)
#define     DUMMY_TIME                      (0)


/* External */

/* Static */

/* Forward */

NDIS_STATUS
TbcInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
TbcModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
TbcDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
TbcCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
TbcModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
TbcDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
TbcEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );
    

NDIS_STATUS 
TbcCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

NDIS_STATUS 
TbcDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

BOOLEAN
TbcSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    );


VOID
TbcSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);


VOID
TbcQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

/* End Forward */


extern VOID
ServiceActiveFlows(
    PVOID SysArg1,
    PVOID Context,
    PVOID SysArg2,
    PVOID SysArg3);


VOID
InitializeTbConformer(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for token bucket conformer.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
#ifdef QUEUE_LIMIT
    ULONG bytesWritten;
    SYSTEM_BASIC_INFORMATION sbi;
#endif // QUEUE_LIMIT

    Info->PipeContextLength = ((sizeof(TBC_PIPE)+7) & ~7);
    Info->FlowContextLength = ((sizeof(TBC_FLOW)+7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = TbcInitializePipe;
    Info->ModifyPipe = TbcModifyPipe;
    Info->DeletePipe = TbcDeletePipe;
    Info->CreateFlow = TbcCreateFlow;
    Info->ModifyFlow = TbcModifyFlow;
    Info->DeleteFlow = TbcDeleteFlow;
    Info->EmptyFlow =  TbcEmptyFlow;
    Info->CreateClassMap = TbcCreateClassMap;
    Info->DeleteClassMap = TbcDeleteClassMap;
    Info->SubmitPacket = TbcSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = TbcSetInformation;
    Info->QueryInformation = TbcQueryInformation;

#ifdef QUEUE_LIMIT
    NtQuerySystemInformation(SystemBasicInformation, 
                             &sbi, 
                             sizeof(SYSTEM_BASIC_INFORMATION),
                             &bytesWritten);
    gPhysMemSize = sbi.NumberOfPhysicalPages * sbi.PageSize;
    // convert to MB
    gPhysMemSize >>= 20;
#endif // QUEUE_LIMIT    

} // InitializeTbConformer


//
//  Unload routine: currently does nothing
//
void
UnloadConformr()
{

}






NDIS_STATUS
TbcInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for token bucket conformer.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    NDIS_STATUS     Status;
    HANDLE          NdisHandle;
    int             i = 0;
    PLIST_ENTRY     pList = NULL;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC,
             ("PSCHED: Conformer pipe initialized. Bandwidth = %u\n", PipeParameters->Bandwidth));

    Pipe->MaxPacket = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    Pipe->PsPipeContext = PsPipeContext;
    (*PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;
    Pipe->PsProcs = PsProcs;
    Pipe->HeaderLength = PipeParameters->HeaderSize;
    Pipe->ControlledLoadMode = PipeParameters->SDModeControlledLoad;
    Pipe->GuaranteedMode = PipeParameters->SDModeGuaranteed;
    Pipe->NetworkControlMode = PipeParameters->SDModeNetworkControl;
    Pipe->Qualitative = PipeParameters->SDModeQualitative;
    Pipe->IntermediateSystem = (PipeParameters->Flags & PS_INTERMEDIATE_SYS) ? TRUE : FALSE;
    Pipe->MediaType = PipeParameters->MediaType;

    InitializeListHead(&Pipe->ActiveFlows);
    NdisHandle = (*PsProcs->NdisPipeHandle)(PsPipeContext);

    // 1. Initialize the spin lock that protects the timer wheel //
    NdisAllocateSpinLock(&Pipe->Lock);

    // 2. Initialize the timer for the timer wheel //
    if (NdisHandle != NULL) 
    {
        NdisMInitializeTimer(
                &Pipe->Timer,
                NdisHandle,
                ServiceActiveFlows,
                Pipe);
                
        Pipe->TimerStatus = TIMER_INACTIVE;
    }
    else 
    {
        // Why would it come here.... ? //
        Pipe->TimerStatus = TIMER_UNINITIALIZED;
    }

    // Remember what kind of pipe are we installing now.. //
    if( Pipe->MediaType == NdisMediumWan )
        Pipe->TimerWheelShift = WAN_TIMER_WHEEL_SHIFT;
    else
        Pipe->TimerWheelShift = LAN_TIMER_WHEEL_SHIFT;


    // These values should always be initialized    //
    Pipe->pTimerWheel = NULL;
    Pipe->SetSlotValue =            DUMMY_SLOT;
    Pipe->SetTimerValue.QuadPart =  DUMMY_TIME;

    Pipe->cStats.NonconformingPacketsScheduled = 0;
    Pipe->PacketsInShaper = 0;
    Pipe->PacketsInShaperAveragingArray = NULL;

    NdisZeroMemory(&Pipe->sStats, sizeof(PS_SHAPER_STATS));

    Status = CreateAveragingArray(&Pipe->PacketsInShaperAveragingArray,
                                  SHAPER_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        NdisFreeSpinLock( &Pipe->Lock );
        return(Status);
    }

    NdisInitializeEvent(&Pipe->TimerUnloadEvent);
    Pipe->TimerUnloadFlag = 0;

    Status = (*Pipe->ContextInfo.NextComponent->InitializePipe)(
                PsPipeContext,
                PipeParameters,
                Pipe->ContextInfo.NextComponentContext,
                PsProcs,
                Upcalls);

    if (Status != NDIS_STATUS_SUCCESS) 
    {
        DeleteAveragingArray(Pipe->PacketsInShaperAveragingArray);
        NdisFreeSpinLock( &Pipe->Lock );
    }

    return Status;

} // TbcInitializePipe



NDIS_STATUS
TbcModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow;
    PLIST_ENTRY Entry;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC,
             ("PSCHED: Conformer pipe modified. Bandwidth = %u\n", PipeParameters->Bandwidth));

    LOCK_PIPE(Pipe);

    (*Pipe->PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;

    UNLOCK_PIPE(Pipe);    

    return (*Pipe->ContextInfo.NextComponent->ModifyPipe)(
                Pipe->ContextInfo.NextComponentContext,
                PipeParameters);

} // TbcModifyPipe



VOID
TbcDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    BOOLEAN Cancelled;

    if (Pipe->TimerStatus == TIMER_SET) 
    {
        BOOLEAN TimerCancelled;
        NdisMCancelTimer(&Pipe->Timer, &TimerCancelled );

        if( !TimerCancelled )
        {
            //  Need to handle the case where the Timer could not be cancelled. In this case, the DPC could be running,
            //  and we will have to wait here before going further  
        }
        else
        {        
            Pipe->TimerStatus = TIMER_INACTIVE;
        }            
    }

    DeleteAveragingArray(Pipe->PacketsInShaperAveragingArray);

    //  Every pipe does not necessarily have a Timer-wheel now  //
    if( Pipe->pTimerWheel )
        PsFreePool( Pipe->pTimerWheel);
        
    NdisFreeSpinLock(&Pipe->Lock);

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer pipe deleted\n"));    

    (*Pipe->ContextInfo.NextComponent->DeletePipe)(Pipe->ContextInfo.NextComponentContext);

} // TbcDeletePipe



#ifdef QUEUE_LIMIT
/*
    SetDefaultFlowQueueLimit() - Sets the queue size limit on a flow using a formula based on
                                 the amount of physical memory in the system and the overall
                                 bandwidth of the flow.

        OUT PTS_FLOW Flow                       - Pointer to the flow to set the limit on
        IN PCO_CALL_PARAMETERS CallParameters   - Call parameters containing the flow's 
                                                  bandwidth requirements
*/
static void 
SetDefaultFlowQueueLimit (
    OUT PTS_FLOW Flow,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    ULONG FlowBandwidth;  // = either PeakRate or TokenRate+BucketSize

    // determine the "flow bandwidth"
    // if the peak rate is specified, use it as flow b/w
    if (CallParameters->CallMgrParameters->Transmit.PeakBandwidth != QOS_NOT_SPECIFIED)
        FlowBandwidth = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    // otherwise use tokenrate + bucket size
    else if (QOS_NOT_SPECIFIED == CallParameters->CallMgrParameters->Transmit.TokenBucketSize)
        FlowBandwidth = CallParameters->CallMgrParameters->Transmit.TokenRate;
    else FlowBandwidth = CallParameters->CallMgrParameters->Transmit.TokenRate +
        CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    
    // then use it to compute the queue limit (first in time units)
    Flow->QueueSizeLimit = (ULONG)(40.0 * log10(0.2 * gPhysMemSize) / log10(FlowBandwidth));
    // convert time limit to size limit
    Flow->QueueSizeLimit *= FlowBandwidth;
}
#endif // QUEUE_LIMIT



NDIS_STATUS
TbcCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for token bucket conformer.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
    HANDLE NdisHandle;
    NDIS_STATUS Status;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_SD_MODE ShapeDiscardObject = NULL;
    ULONG Mode;
    ULONG PeakRate;

    ULONG           Slot= 0;
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LONGLONG        DeltaTimeInMs;
    PLIST_ENTRY     pList = NULL;
    LARGE_INTEGER   CurrentTime;
    

#ifdef QUEUE_LIMIT
    LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE ShaperOverLimitDropModeObject = NULL;
    LPQOS_SHAPER_QUEUE_LIMIT ShaperQueueLimitObject = NULL;
#endif // QUEUELIMIT


    if (Pipe->TimerStatus == TIMER_UNINITIALIZED) {
        NdisHandle = (*Pipe->PsProcs->NdisPipeHandle)(Pipe->PsPipeContext);

        if (NdisHandle != NULL) {
            NdisMInitializeTimer(
                    &Pipe->Timer,
                    NdisHandle,
                    ServiceActiveFlows,
                    Pipe);
            Pipe->TimerStatus = TIMER_INACTIVE;
        }
        else {
            return NDIS_STATUS_FAILURE;
        }
    }

    NdisAllocateSpinLock(&Flow->Lock);

    // Get the required values from the flowspec.  We assume here that the PS wrapper
    // has performed the required validity checks:
    //     TokenRate <= PeakRate
    //     TokenRate > 0
    Flow->State = TS_FLOW_CREATED;
    Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
    Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    Flow->PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    Flow->MinPolicedUnit =
        (CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize == QOS_NOT_SPECIFIED) ?
        0 : CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize;

    if (Flow->Capacity == QOS_NOT_SPECIFIED) 
    {
        if( Pipe->MaxPacket > (CallParameters->CallMgrParameters->Transmit.TokenRate / 100) ) 
            Flow->Capacity = Pipe->MaxPacket;
        else
            Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenRate / 100;
    }

    // Look for the Shape/Discard object in the call manager specific parameters.
    // If it is found, save the pointer.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_SD_MODE) {
                ShapeDiscardObject = (LPQOS_SD_MODE)QoSObject;
#ifdef QUEUE_LIMIT
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_DROP_MODE) {
                ShaperOverLimitDropModeObject = (LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE)QoSObject;
            }
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_LIMIT) {
                ShaperQueueLimitObject = (LPQOS_SHAPER_QUEUE_LIMIT)QoSObject;
            }
#endif // QUEUE_LIMIT                
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    // If no Shape/Discard object was found, set the default value for the
    // "Discard" parameter.  Otherwise set it to the value specified by the
    // object.

    if (ShapeDiscardObject == NULL) {
        switch (CallParameters->CallMgrParameters->Transmit.ServiceType) {
            case SERVICETYPE_CONTROLLEDLOAD:
                Mode = Pipe->ControlledLoadMode;
                break;
            case SERVICETYPE_GUARANTEED:
                Mode = Pipe->GuaranteedMode;
                break;
          case SERVICETYPE_NETWORK_CONTROL:
                Mode = Pipe->NetworkControlMode;
                break;
          case SERVICETYPE_QUALITATIVE:
                Mode = Pipe->Qualitative;
                break;
            default:
                Mode = TC_NONCONF_BORROW;
        }
    }
    else {
        Mode = ShapeDiscardObject->ShapeDiscardMode;
    }

    Flow->Mode = Mode;
    
    Flow->NoConformance = ((Mode == TC_NONCONF_BORROW_PLUS) ||
                           (Flow->TokenRate == QOS_NOT_SPECIFIED));

    PsGetCurrentTime(&Flow->LastConformanceTime);

    Flow->PeakConformanceTime = Flow->LastConformanceTime;
    Flow->LastConformanceCredits = Flow->Capacity;
    Flow->PsFlowContext = PsFlowContext;

    PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    if (Flow->Mode == TC_NONCONF_SHAPE) {
        Flow->Shape = TRUE;
    } else if ((PeakRate != QOS_NOT_SPECIFIED) &&
               (Flow->Mode != TC_NONCONF_BORROW_PLUS) &&
               !Pipe->IntermediateSystem) {
        Flow->Shape = TRUE;
    } else {
        Flow->Shape = FALSE;
    }


#ifdef QUEUE_LIMIT
    Flow->QueueSize = 0;
    // If the flow is shaped, set the queue limiting params.  If not specified, use defaults
    if (Flow->Shape) {
        // set the drop mode
        if (NULL != ShaperOverLimitDropModeObject) {
            Flow->DropOverLimitPacketsFromHead = (BOOLEAN) ShaperOverLimitDropModeObject->DropMode;
        }
        else {
            // default to this behavior
            Flow->DropOverLimitPacketsFromHead = TRUE;
        }

        // set the queue limit
        if (NULL != ShaperQueueLimitObject) {
            Flow->UseDefaultQueueLimit = FALSE;
            Flow->QueueSizeLimit = ShaperQueueLimitObject->QueueSizeLimit;
        }
        else {
            Flow->UseDefaultQueueLimit = TRUE;
            // default to a size based on the flow's bandwidth and physical memory
            SetDefaultFlowQueueLimit(Flow, CallParameters);
        }
    }
#endif // QUEUE_LIMIT

    InitializeListHead(&Flow->PacketQueue);
    PsGetCurrentTime(&Flow->FlowEligibilityTime);

    Flow->cStats.NonconformingPacketsScheduled = 0;
    Flow->PacketsInShaper = 0;
    Flow->PacketsInShaperAveragingArray = NULL;
    
    NdisZeroMemory(&Flow->sStats, sizeof(PS_SHAPER_STATS));

    Status = CreateAveragingArray(&Flow->PacketsInShaperAveragingArray,
                                                                  SHAPER_FLOW_AVERAGING_ARRAY_SIZE);
    if(Status != NDIS_STATUS_SUCCESS){
        return(Status);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PsFlowContext = %08X) created. Rate = %u\n", 
             Flow,
             Flow->PsFlowContext, 
             Flow->TokenRate));

             
    Status = (*Pipe->ContextInfo.NextComponent->CreateFlow)(
                Pipe->ContextInfo.NextComponentContext,
                PsFlowContext,
                CallParameters,
                Flow->ContextInfo.NextComponentContext);

    LOCK_PIPE( Pipe );
                    
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        NdisFreeSpinLock(&Flow->Lock);
        DeleteAveragingArray(Flow->PacketsInShaperAveragingArray);
    }

    UNLOCK_PIPE( Pipe );

    return Status;

} // TbcCreateFlow



NDIS_STATUS
TbcModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_SD_MODE ShapeDiscardObject = NULL;
    ULONG Mode;
    ULONG PeakRate;
    LARGE_INTEGER CurrentTime;

#ifdef QUEUE_LIMIT
    LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE ShaperOverLimitDropModeObject = NULL;
    LPQOS_SHAPER_QUEUE_LIMIT ShaperQueueLimitObject = NULL;
#endif // QUEUE_LIMIT    

    // Look for the Shape/Discard object in the call manager specific parameters.
    // If it is found, save the pointer.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_SD_MODE) {
                ShapeDiscardObject = (LPQOS_SD_MODE)QoSObject;
#ifdef QUEUE_LIMIT
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_DROP_MODE) {
                ShaperOverLimitDropModeObject = (LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE)QoSObject;
            }
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_LIMIT) {
                ShaperQueueLimitObject = (LPQOS_SHAPER_QUEUE_LIMIT)QoSObject;
            }
#endif // QUEUE_LIMIT
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;

    LOCK_FLOW(Flow);

    //
    // There are basically 2 parameters that have to be corrected in this function:
    // They are (a) LastConformanceTime (b) LastConformanceCredits.
    // (1) If LastConformanceTime is in the future: Goto step(4).
    // (2)	(a) Figure out how many bytes were accumulated between LastConformanceTime and CurrentTime.
    //		(b) If Accumulated Credits is greater than Bucket size, Accumulated Credits = Bucket size.
    //		(c) Set LastConformanceTime to CurrentTime.
    // (3) PeakConformanceTime will not be changed.
    // (4) Change the Flow parameters, as specified in the Modify-call.

    PsGetCurrentTime(&CurrentTime);

    if( Flow->LastConformanceTime.QuadPart < CurrentTime.QuadPart)
    {
	    ULONG	Credits;

	    Credits = Flow->LastConformanceCredits + 
			EARNED_CREDITS( CurrentTime.QuadPart - Flow->LastConformanceTime.QuadPart, Flow->TokenRate);

	    if( Credits > Flow->Capacity)
	        Flow->LastConformanceCredits = Flow->Capacity;
	    else
	        Flow->LastConformanceCredits = Credits;

	    Flow->LastConformanceTime.QuadPart = CurrentTime.QuadPart;	
    }


    if (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_NOCHANGE) {

        // Get the new flowspec values.  Again we assume the PS wrapper has done
        // the required validity checks.

        Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
        Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
        Flow->PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
        Flow->MinPolicedUnit =
            (CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize == QOS_NOT_SPECIFIED) ?
            0 : CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize;

        if (Flow->Capacity == QOS_NOT_SPECIFIED) 
        {
            if( Pipe->MaxPacket > (CallParameters->CallMgrParameters->Transmit.TokenRate / 100) ) 
                Flow->Capacity = Pipe->MaxPacket;
            else
                Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenRate / 100;
        }

        if (ShapeDiscardObject == NULL) {

            // Re-calculate the Shape parameter if the user has never specified
            // a Shape/Discard object.

            switch (CallParameters->CallMgrParameters->Transmit.ServiceType) {
                case SERVICETYPE_CONTROLLEDLOAD:
                    Mode = Pipe->ControlledLoadMode;
                    break;
                case SERVICETYPE_GUARANTEED:
                    Mode = Pipe->GuaranteedMode;
                    break;
              case SERVICETYPE_NETWORK_CONTROL:
                    Mode = Pipe->NetworkControlMode;
                    break;
              case SERVICETYPE_QUALITATIVE:
                    Mode = Pipe->Qualitative;
                    break;
              default:
                    Mode = TC_NONCONF_BORROW;
            }
        }
    }
    else
    {
        // The ServiceType has not changed. We can use the existing mode.

        Mode = Flow->Mode;
    }
        

    if (ShapeDiscardObject != NULL) {
        Mode = ShapeDiscardObject->ShapeDiscardMode;
    }

    Flow->Mode = Mode;
    Flow->NoConformance = ((Mode == TC_NONCONF_BORROW_PLUS) ||
                           (Flow->TokenRate == QOS_NOT_SPECIFIED));

    if (Flow->Mode == TC_NONCONF_SHAPE) {
        Flow->Shape = TRUE;
    } else if ((PeakRate != QOS_NOT_SPECIFIED) &&
               (Flow->Mode != TC_NONCONF_BORROW_PLUS) &&
               !Pipe->IntermediateSystem) {
        Flow->Shape = TRUE;
    } else {
        Flow->Shape = FALSE;
    }                           

 
#ifdef QUEUE_LIMIT
    // If the flow is shaped, check the queue limiting params.  If specified, use
    if (Flow->Shape) {
        // modify drop mode
        if (NULL != ShaperOverLimitDropModeObject) {
            Flow->DropOverLimitPacketsFromHead = (BOOLEAN) ShaperOverLimitDropModeObject->DropMode;
        }

        // modify queue limit
        if (NULL != ShaperQueueLimitObject) {
            Flow->UseDefaultQueueLimit = FALSE;
            Flow->QueueSizeLimit = ShaperQueueLimitObject->QueueSizeLimit;
        }
        // if they haven't overridden the limit, recompute it in case bandwidth req's changed
        else if (Flow->UseDefaultQueueLimit) {
            SetDefaultFlowQueueLimit(Flow, CallParameters);
        }
    }
#endif // QUEUE_LIMIT    

    UNLOCK_FLOW(Flow);

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08x (PsFlowContext %08X) modified. Rate = %u\n", 
             Flow, Flow->PsFlowContext, Flow->TokenRate));

    return (*Pipe->ContextInfo.NextComponent->ModifyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                CallParameters);

} // TbcModifyFlow



VOID
TbcDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PS context %08X) deleted\n", 
             Flow, Flow->PsFlowContext));

    NdisFreeSpinLock(&Flow->Lock);

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if (!IsListEmpty(&Flow->PacketQueue)) {

        // Remove flow from active list

        RemoveEntryList(&Flow->Links);

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);

        }
    }

    DeleteAveragingArray(Flow->PacketsInShaperAveragingArray);

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) 
    {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet,  NDIS_STATUS_FAILURE);
    }

    (*Pipe->ContextInfo.NextComponent->DeleteFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);

} // TbcDeleteFlow




VOID
TbcEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PS context %08X) emptied\n", 
             Flow, Flow->PsFlowContext));

	InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list
        RemoveEntryList(&Flow->Links);

		while (!IsListEmpty(&Flow->PacketQueue)) 
		{
			// Drop any packets that remain queued for this flow.
	        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
	        InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
	    }
	}

	Flow->State = TS_FLOW_DELETED;

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) 
    {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet,  NDIS_STATUS_FAILURE);
    }

    (*Pipe->ContextInfo.NextComponent->EmptyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);

} // TbcModifyFlow




static NDIS_STATUS 
TbcCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->CreateClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}



static NDIS_STATUS 
TbcDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->DeleteClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}


void
InsertFlow( PTBC_PIPE           Pipe,
            PTBC_FLOW           Flow,
            LARGE_INTEGER       CurrentTime,
            PPACKET_INFO_BLOCK  PacketInfo,
            PNDIS_PACKET        Packet,
            ULONG               ExecSlot,
            LARGE_INTEGER       ExecTimeInTenMs)
{
    /* So, the packet is not eligible to be sent out right now, and the pkt-queue is empty.. */

    ULONG           Slot= 0;
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LARGE_INTEGER   DeltaTimeInTenMs, CurrentTimeInTenMs;
    PLIST_ENTRY     pList = NULL;
    BOOLEAN         TimerCancelled;

    PsDbgSched(DBG_INFO, 
               DBG_SCHED_SHAPER,
               SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, 0, 
               CurrentTime.QuadPart,
               PacketInfo->DelayTime.QuadPart,
               Pipe->PacketsInShaper,
               0);

    /* Conf time in ms and 10ms */
    Ms.QuadPart = OS_TIME_TO_MILLISECS( Flow->FlowEligibilityTime.QuadPart );
    TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

    /* Diff in 10 MS */
    DeltaTimeInTenMs.QuadPart = TenMs.QuadPart - ExecTimeInTenMs.QuadPart;
    

    /* Figure out the Slot for this time.. */
    Slot = (ULONG)( (TenMs.QuadPart) & (( 1 << Pipe->TimerWheelShift) - 1) );

    /* Update the loop count too */
    Flow->LoopCount = (ULONG)( DeltaTimeInTenMs.QuadPart >> Pipe->TimerWheelShift );

    if( Slot == ExecSlot)
        Slot = ( (Slot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
        
    /* Need to insert the flow to the timer-wheel in slot's position*/
    InsertTailList(pList, &Flow->Links);
}




VOID
ServiceActiveFlows(
    PVOID SysArg1,
    PVOID Context,
    PVOID SysArg2,
    PVOID SysArg3)

/*++

Routine Description:

    Service the active flow list after a timer expiration.

Arguments:

    Context -       Pointer to pipe context information

Return Values:


--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)Context;
    PTBC_FLOW Flow;
    LARGE_INTEGER CurrentTime;
    LONGLONG RelTimeInMillisecs;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    BOOLEAN DoneWithFlow;

    PLIST_ENTRY CurrentLink;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEnd;

    ULONG           i = 0;
    ULONG           SetSlot= 0;
    ULONG           CurrentSlot = 0;
    
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LONGLONG        DeltaTimeInMs;

    LIST_ENTRY SendList;
    LIST_ENTRY FlowList;

    InitializeListHead(&SendList);
    InitializeListHead(&FlowList);

    LOCK_PIPE(Pipe);
    
    PsGetCurrentTime(&CurrentTime);

    /* start from here.. */
    i = SetSlot = Pipe->SetSlotValue;

    Ms.QuadPart = OS_TIME_TO_MILLISECS( CurrentTime.QuadPart);
    TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

    // Need to make sure that SetTimerValue is lesser than TenMs //
    if( Pipe->SetTimerValue.QuadPart > TenMs.QuadPart)
    {
        // Why is the timer firing earlier than when it is slated to? 
        TenMs.QuadPart = 1;
        NdisMSetTimer(&Pipe->Timer, (UINT)(TenMs.QuadPart << TIMER_WHEEL_SHIFT));
        UNLOCK_PIPE(Pipe);
        return;
    }

    /* run till here.. */
    CurrentSlot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

    /* Indicate that the timer is running */
    Pipe->TimerStatus = TIMER_PROC_EXECUTING;
    Pipe->ExecTimerValue.QuadPart = Pipe->SetTimerValue.QuadPart;
    Pipe->ExecSlot = Pipe->SetSlotValue;


    ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* SetSlot ));
    ListEnd = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)*  CurrentSlot ));

    while(1)
    {
        while( !IsListEmpty( ListHead) )
        {
            CurrentLink = ListHead->Flink;
            Flow = CONTAINING_RECORD(CurrentLink, TBC_FLOW, Links);
            RemoveEntryList(&Flow->Links);

            PsAssert(!IsListEmpty(&Flow->PacketQueue));
            DoneWithFlow = FALSE;

            InitializeListHead( &SendList );

            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if( Flow->LoopCount > 0 )
            {
                Flow->LoopCount--;
                InsertTailList( &FlowList, &Flow->Links );
                continue;
            }

            while( FlowIsEligible(Flow, CurrentTime, ((TIMER_WHEEL_QTY/2) * MSIN100NS)))
            {
                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Packet = PacketInfo->NdisPacket;

                DoneWithFlow = IsListEmpty(&Flow->PacketQueue);

                Pipe->PacketsInShaper--;
                Flow->PacketsInShaper--;

                if(gEnableAvgStats)
                {
                    Pipe->sStats.AveragePacketsInShaper =
                        RunningAverage(Pipe->PacketsInShaperAveragingArray, 
                                       Pipe->PacketsInShaper);

                    Flow->sStats.AveragePacketsInShaper =
                        RunningAverage(Flow->PacketsInShaperAveragingArray, 
                                       Flow->PacketsInShaper);

                }
                
                PsDbgSched(DBG_INFO,
                           DBG_SCHED_SHAPER,
                           SHAPER, PKT_DEQUEUE, Flow->PsFlowContext,
                           Packet, PacketInfo->PacketLength, 0, 
                           CurrentTime.QuadPart,
                           PacketInfo->DelayTime.QuadPart,
                           Pipe->PacketsInShaper,
                           0);


                InsertTailList( &SendList, &PacketInfo->SchedulerLinks);

                if( !DoneWithFlow)
                {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->FlowEligibilityTime.QuadPart = PacketInfo->DelayTime.QuadPart;
                }
                else
                {
                    break;
                }
            }

            if( !DoneWithFlow)
            {
                /* Need to insert in the right place.. */
                InsertFlow( Pipe, Flow, CurrentTime, PacketInfo, Packet, i, Pipe->ExecTimerValue);
            }

            /* send the packet corresponding to this flow here */
            UNLOCK_PIPE(Pipe);
            
            while( !IsListEmpty( &SendList ))
            {
				PPACKET_INFO_BLOCK PacketInfo;

            	PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&SendList);

	            if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
	                        Pipe->ContextInfo.NextComponentContext,
	                        Flow->ContextInfo.NextComponentContext,
	                        (PacketInfo->ClassMapContext != NULL) ?
	                          ((PPS_CLASS_MAP_CONTEXT)PacketInfo->ClassMapContext)->NextComponentContext: NULL,
	                        PacketInfo)) 
	            {
	                (*Pipe->PsProcs->DropPacket)(	Pipe->PsPipeContext, 
	                								Flow->PsFlowContext, 
	                								PacketInfo->NdisPacket, 
	                								NDIS_STATUS_FAILURE);
	            }
            }

            LOCK_PIPE(Pipe);
        }

        /* Now, we need to re-insert back all the non-zero loop counts into the same buckets (before we move on ) */
        while( !IsListEmpty( &FlowList) )
        {
            CurrentLink = RemoveHeadList( &FlowList );
            InsertTailList(ListHead, CurrentLink);
        }            
        
        /* We have traversed the whole length.. */
        if(ListHead == ListEnd)
            break;

        /* Need to move ListHead to next slot.. */
        i = ( (i+1) & ((1 << Pipe->TimerWheelShift) - 1)  );
        ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* i));

        Pipe->ExecSlot = i;
        Pipe->ExecTimerValue.QuadPart ++;
    }


    //
    //  Need to find the "next non-empty slot" and set the timer. 
    //  If no such slot is found, do not set the timer.
    //

    i = ( CurrentSlot + 1) & ((1 << Pipe->TimerWheelShift) - 1) ;
    
    TenMs.QuadPart = 1;

    while(1)
    {
        ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* i));

        if( !IsListEmpty( ListHead) )
        {
            // found a non-empty slot //
            Pipe->SetSlotValue = i;
            Pipe->SetTimerValue.QuadPart = (Ms.QuadPart >> TIMER_WHEEL_SHIFT) + TenMs.QuadPart;

            Pipe->TimerStatus = TIMER_SET;
    	    NdisMSetTimer(&Pipe->Timer, (UINT)(TenMs.QuadPart << TIMER_WHEEL_SHIFT));

    	    UNLOCK_PIPE(Pipe);
    	    return;
        }

        if( i == CurrentSlot)
            break;

        i = ((i +1) & ((1 << Pipe->TimerWheelShift) - 1) );
        TenMs.QuadPart  = TenMs.QuadPart + 1;
    }

    Pipe->TimerStatus = TIMER_INACTIVE;
    UNLOCK_PIPE(Pipe);
    return;

} // ServiceActiveFlows





BOOLEAN
TbcSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PNDIS_PACKET Packet = PacketInfo->NdisPacket;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ConformanceTime;
    LARGE_INTEGER TransmitTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG Credits;
    ULONG PacketLength;
    BOOLEAN TimerCancelled;
    LONGLONG RelTimeInMillisecs;
    BOOLEAN Status;
#ifdef QUEUE_LIMIT
    PPACKET_INFO_BLOCK PacketToBeDroppedInfo;
#endif // QUEUE_LIMIT


    PsGetCurrentTime(&CurrentTime);


    if (Flow->NoConformance) {

        // The conformance time calculation is not performed for certain types of
        // flows.  If the flow does not have a specified rate, we cannot really do
        // token bucket.  Flows that use the "borrow+" shape/discard mode only use
        // their rate as a relative weight.  For either of these types of flows
        // there is no distinction between conforming and non-conforming traffic.
        // So, we just set the "conformance" time to the current time to insure
        // that all packets will be handled as conforming in subsequent components.

        PacketInfo->ConformanceTime.QuadPart = CurrentTime.QuadPart;

    }
    else {

	// We decided to not use the MinPolicedSize as per WMT request. This makes the overhead
	// calculation complicated and incorrect.
        PacketLength = 	//(PacketInfo->PacketLength < Flow->MinPolicedUnit) ? Flow->MinPolicedUnit : 
			PacketInfo->PacketLength;

        LOCK_FLOW(Flow);

        // Set ConformanceTime to the earliest time at which the packet may
        // possibly go out, based on the token bucket parameters, and Credits
        // to the number of credits available at that time.


        if (CurrentTime.QuadPart > Flow->LastConformanceTime.QuadPart) {

            ConformanceTime = CurrentTime;
            Credits = Flow->LastConformanceCredits +
                      EARNED_CREDITS(
                            CurrentTime.QuadPart - Flow->LastConformanceTime.QuadPart,
                            Flow->TokenRate);
        }
        else {
            ConformanceTime = Flow->LastConformanceTime;
            Credits = Flow->LastConformanceCredits;
        }

        if (Credits > Flow->Capacity) {
            Credits = Flow->Capacity;
        }

        // Now check whether there are enough credits to send the packet at ConformanceTime

        if (Credits < PacketLength) {

            // If there aren't enough credits, update ConformanceTime to the time at which
            // there will be enough credits

            ConformanceTime.QuadPart +=
                (LONGLONG)TIME_TO_EARN_CREDITS(PacketLength - Credits, Flow->TokenRate);


            // Now update Credits to be the number of credits available at ConformanceTime,
            // taking this packet into account.  In this case, the number of credits
            // at ConformanceTime will be zero.

            Credits = 0;

            // If it has to wait to earn credits, it's non-conforming
            Flow->cStats.NonconformingPacketsScheduled ++;
            Pipe->cStats.NonconformingPacketsScheduled ++;
        }
        else {
            // There are enough credits, so the packet can be sent at ConformanceTime.  Update
            // Credits to be the number of credits available at ConformanceTime, taking this
            // packet into account.    
            
            Credits -= PacketLength;
        }

        // Calculate the adjusted conformance time, which is the maximum of the
        // token bucket conformance time and the peak conformance time.  

        if (Flow->PeakRate != QOS_NOT_SPECIFIED) 
        { 
            PeakConformanceTime =   (Flow->PeakConformanceTime.QuadPart < CurrentTime.QuadPart) ?
                                    CurrentTime : Flow->PeakConformanceTime;

            TransmitTime =  (PeakConformanceTime.QuadPart < ConformanceTime.QuadPart) ?
                            ConformanceTime : PeakConformanceTime;

        } else {

            PeakConformanceTime = Flow->LastConformanceTime;
            TransmitTime = ConformanceTime;
        }

        // Perform mode-specific operations.  For discard mode flows, check whether
        // the packet should be dropped.  For all flows, set the packet conformance
        // times based on the pipe/flow mode.  The packet's conformance time is the
        // time at which the packet should be considered conforming.  The delay time
        // is the earliest time at which a packet is eligible for sending.

        // When deciding whether to drop a packet, we consider a packet conforming if
        // its conformance time is within half a clock tick of the current time.

        if (Flow->Mode == TC_NONCONF_DISCARD) {

            if (Pipe->IntermediateSystem) {
                if (!PACKET_IS_CONFORMING(TransmitTime, CurrentTime, Pipe->TimerResolution)) {
                    UNLOCK_FLOW(Flow);


                    PsDbgSched(DBG_TRACE, DBG_SCHED_TBC,
                               TBC_CONFORMER, PKT_DISCARD, Flow->PsFlowContext,
                               Packet, PacketInfo->PacketLength, 0,
                               CurrentTime.QuadPart,
                               TransmitTime.QuadPart, 0, 0);

                    return FALSE;
                }
            } else {
                if (!PACKET_IS_CONFORMING(ConformanceTime, CurrentTime, Pipe->TimerResolution)) {
                    UNLOCK_FLOW(Flow);


                    PsDbgSched(DBG_TRACE, DBG_SCHED_TBC, 
                               TBC_CONFORMER, PKT_DISCARD, Flow->PsFlowContext,
                               Packet, PacketInfo->PacketLength, 0,
                               CurrentTime.QuadPart,
                               ConformanceTime.QuadPart, 0, 0);

                    return FALSE;
                }
            }
        }

        // Set the packet conformance times

        if (Pipe->IntermediateSystem) {

            if (Flow->Mode == TC_NONCONF_SHAPE) {

                // Both conformance times are the adjusted conformance time.

                PacketInfo->ConformanceTime.QuadPart =
                PacketInfo->DelayTime.QuadPart = TransmitTime.QuadPart;

                //
                // If the packet is going to remain for > 5 min, discard it.
                //
                if(TransmitTime.QuadPart > CurrentTime.QuadPart &&
                   OS_TIME_TO_MILLISECS((TransmitTime.QuadPart - CurrentTime.QuadPart)) 
                   > MAX_TIME_FOR_PACKETS_IN_SHAPER)
                {
                    UNLOCK_FLOW(Flow);
                    return FALSE;
                }

            } else {

                // Packet's conformance time is the adjusted conformance time,
                // and the delay time is the current time.

                PacketInfo->ConformanceTime.QuadPart = TransmitTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = CurrentTime.QuadPart;
            }
        } else {

            if (Flow->Mode == TC_NONCONF_SHAPE) {

                // Packet's conformance time is the token bucket conformance time,
                // and the delay time is the adjusted conformance time.

                PacketInfo->ConformanceTime.QuadPart = ConformanceTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = TransmitTime.QuadPart;

                //
                // If the packet is going to remain for > 5 min, discard it.
                //
                if(TransmitTime.QuadPart > CurrentTime.QuadPart &&
                   OS_TIME_TO_MILLISECS((TransmitTime.QuadPart - CurrentTime.QuadPart)) 
                   > MAX_TIME_FOR_PACKETS_IN_SHAPER)
                {
                    UNLOCK_FLOW(Flow);
                    return FALSE;
                }

            } else {

                // Packet's conformance time is the token bucket conformance time, and
                // the delay time is the peak conformance time.

                PacketInfo->ConformanceTime.QuadPart = ConformanceTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = PeakConformanceTime.QuadPart;
            }
        }

        // Update the flow's variables

        if (Flow->PeakRate != QOS_NOT_SPECIFIED) {
            Flow->PeakConformanceTime.QuadPart = 
                PeakConformanceTime.QuadPart + (LONGLONG)TIME_TO_SEND(PacketLength, Flow->PeakRate);
        }
        
        Flow->LastConformanceTime = ConformanceTime;
        Flow->LastConformanceCredits = Credits;
                
        UNLOCK_FLOW(Flow);

    }

    // Pass the packet on

    PsDbgSched(DBG_INFO, DBG_SCHED_TBC, 
               TBC_CONFORMER, PKT_CONFORMANCE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, 0,
               CurrentTime.QuadPart,
               (Pipe->IntermediateSystem) ? 
               TransmitTime.QuadPart : ConformanceTime.QuadPart, 0, 0);


    if (!Flow->Shape) 
    {
        // No shaping in effect. Pass the packet on.

        /*  Since the packet is not being shaped, it could be non-conformant. So, need to reset it's 802.1p and 
            IP-Precedence values. */

        if( (!Flow->NoConformance)  &&
            !PACKET_IS_CONFORMING(PacketInfo->ConformanceTime, CurrentTime, Pipe->TimerResolution))
        {
            NDIS_PACKET_8021Q_INFO  VlanPriInfo;

            VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo);
            VlanPriInfo.TagHeader.UserPriority = PacketInfo->UserPriorityNonConforming;
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) = VlanPriInfo.Value;
            // Reset the TOS byte for IP Packets.
            if(NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP) {

                if(!PacketInfo->IPHdr) {

                    PacketInfo->IPHdr = GetIpHeader(PacketInfo->IPHeaderOffset, Packet);
                }
                    
                SET_TOS_XSUM(Packet, 
                             PacketInfo->IPHdr, 
                             PacketInfo->TOSNonConforming);
            }
        }            
            
        return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                    Pipe->ContextInfo.NextComponentContext,
                    Flow->ContextInfo.NextComponentContext,
                    (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                    PacketInfo);
    }

    LOCK_PIPE(Pipe);

    if(Flow->State == TS_FLOW_DELETED) 
	{
        UNLOCK_PIPE(Pipe);
        return FALSE;
    }

    
    /*  At this point, the conf-time of the packet is in TransmitTime 
        and the packetino->DelayTime has this info.
    */

    PacketInfo->FlowContext = FlowContext;

    // If packet queue is not empty just queue the packet regardless of
    // whether it is eligible.  If it is eligible, the timer proc will
    // detect this and send the packet.  If not, it will insert the flow
    // into the correct location in the flow list if necessary.

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        PsDbgSched(DBG_INFO, 
                   DBG_SCHED_SHAPER,
                   SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, 0, 
                   0,
                   PacketInfo->DelayTime.QuadPart,
                   Pipe->PacketsInShaper,
                   0);

        PacketInfo->ClassMapContext = ClassMapContext;
        InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);
    }
    else if(PacketIsEligible(PacketInfo, Flow, CurrentTime, ((TIMER_WHEEL_QTY/2) * MSIN100NS) ))
    {
            // Packet is eligible, so pass the packet on.
            UNLOCK_PIPE(Pipe);

            PsDbgSched(DBG_INFO, 
                       DBG_SCHED_SHAPER,
                       SHAPER, PKT_DEQUEUE, Flow->PsFlowContext,
                       Packet, PacketInfo->PacketLength, 0, 
                       CurrentTime.QuadPart,
                       PacketInfo->DelayTime.QuadPart,
                       Pipe->PacketsInShaper,
                       0);

            return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                        Pipe->ContextInfo.NextComponentContext,
                        Flow->ContextInfo.NextComponentContext,
                        (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                        PacketInfo);
    }
    else
    {
        //  So, the packet is not eligible to be sent out right now, and the pkt-queue is empty 

        ULONG           Slot= 0;
        LARGE_INTEGER   Ms;
        LARGE_INTEGER   TenMs;
        LARGE_INTEGER   CurrentTimeInMs, CurrentTimeInTenMs;
        LONGLONG        DeltaTimeInMs;
        PLIST_ENTRY     pList = NULL;
        BOOL            Success = FALSE;
        //
        //  The first thing we do here is: If there is no timer allocated for this pipe, allocate one    
        //  The FIRST packet to be shaped on the pipe will take a hit due to this..
        //
        
        if( !Pipe->pTimerWheel )
        {
            ULONG i =0;
            
            PsAllocatePool( Pipe->pTimerWheel, 
                            (sizeof(LIST_ENTRY) << Pipe->TimerWheelShift ), 
                            TimerTag);

            if( !Pipe->pTimerWheel)
            {
                UNLOCK_PIPE(Pipe);

                // If we could not allocate memory for the timer, we are not going to shape the packet  //
                return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                        Pipe->ContextInfo.NextComponentContext,
                        Flow->ContextInfo.NextComponentContext,
                        (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                        PacketInfo);
            }        

            //  Initialize the Timer wheel  //
            pList = (PLIST_ENTRY)(Pipe->pTimerWheel);                    
            for( i = 0; i < (ULONG) (1 << Pipe->TimerWheelShift); i++)
            {
                InitializeListHead( pList );
                pList = (PLIST_ENTRY)((PCHAR)pList + sizeof(LIST_ENTRY));
            }
        }


        Ms.QuadPart= 0;

        PsDbgSched(DBG_INFO, 
                   DBG_SCHED_SHAPER,
                   SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, 0, 
                   CurrentTime.QuadPart,
                   PacketInfo->DelayTime.QuadPart,
                   Pipe->PacketsInShaper,
                   0);

        PacketInfo->ClassMapContext = ClassMapContext;
        InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);

        /* update the eligibility timer of the flow.. */
        Flow->FlowEligibilityTime.QuadPart = PacketInfo->DelayTime.QuadPart;

        /* Conf time in ms and 10ms */
        Ms.QuadPart = OS_TIME_TO_MILLISECS( Flow->FlowEligibilityTime.QuadPart );
        TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

        CurrentTimeInMs.QuadPart = OS_TIME_TO_MILLISECS( CurrentTime.QuadPart);
        CurrentTimeInTenMs.QuadPart = CurrentTimeInMs.QuadPart >> TIMER_WHEEL_SHIFT;

        /* Update the loop count too */
        Flow->LoopCount = (ULONG)( (TenMs.QuadPart - CurrentTimeInTenMs.QuadPart) >> Pipe->TimerWheelShift );

        if( Pipe->TimerStatus == TIMER_INACTIVE)
        {
            /* Figure out the Slot for this time.. */
            Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1 ) );

            Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - (Flow->LoopCount << Pipe->TimerWheelShift);
            Pipe->SetSlotValue = Slot;

            /* Need to insert the flow to the timer-wheel in slot's position*/
            pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
            InsertTailList(pList, &Flow->Links);

            Pipe->TimerStatus = TIMER_SET;
            NdisMSetTimer(&Pipe->Timer, (UINT)((Pipe->SetTimerValue.QuadPart - CurrentTimeInTenMs.QuadPart) << TIMER_WHEEL_SHIFT) );
        }
        else if( Pipe->TimerStatus == TIMER_SET)
        {
            if( TenMs.QuadPart <= Pipe->SetTimerValue.QuadPart)
            {
                Flow->LoopCount = 0;
                    
                /* Try to cancel the timer and re-set it */
                NdisMCancelTimer( &Pipe->Timer, (PBOOLEAN)&Success );

                if( Success)
                {
                    /* Figure out the Slot for this time.. */
                    Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                    // Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - Flow->LoopCount * Pipe->TimerWheelSize ;
                    Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - (Flow->LoopCount << Pipe->TimerWheelShift) ;
                    Pipe->SetSlotValue = Slot;

                    /* Need to insert the flow to the timer-wheel in slot's position*/
                    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                    InsertTailList(pList, &Flow->Links);

                    NdisMSetTimer(&Pipe->Timer, (UINT)((Pipe->SetTimerValue.QuadPart - CurrentTimeInTenMs.QuadPart) << TIMER_WHEEL_SHIFT));
                }
                else
                {
                    /* Need to insert the flow to the timer-wheel in slot's position*/
                    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Pipe->SetSlotValue) );
                    InsertTailList(pList, &Flow->Links);
                }                
            }
            else
            {
                Flow->LoopCount = (ULONG)( (TenMs.QuadPart - Pipe->SetTimerValue.QuadPart) >> Pipe->TimerWheelShift );

                /* Figure out the Slot for this time.. */
                Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
        }
        else 
        {
            PsAssert( Pipe->TimerStatus == TIMER_PROC_EXECUTING);

            if( TenMs.QuadPart <= Pipe->ExecTimerValue.QuadPart)
            {
                PsAssert( Flow->LoopCount == 0);        
        
                Slot = (ULONG)((Pipe->ExecSlot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
            else
            {
                Flow->LoopCount = (ULONG)( (TenMs.QuadPart - Pipe->ExecTimerValue.QuadPart) >> Pipe->TimerWheelShift );

                /* Figure out the Slot for this time.. */
                Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                if( Slot == Pipe->ExecSlot)
                    Slot = ( (Slot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
        }
    }

    Pipe->PacketsInShaper++;
    if(Pipe->PacketsInShaper > Pipe->sStats.MaxPacketsInShaper){
        Pipe->sStats.MaxPacketsInShaper = Pipe->PacketsInShaper;
    }
    
    Flow->PacketsInShaper++;
    if (Flow->PacketsInShaper > Flow->sStats.MaxPacketsInShaper) {
        Flow->sStats.MaxPacketsInShaper = Flow->PacketsInShaper;
    }


    if(gEnableAvgStats)
    {
        Pipe->sStats.AveragePacketsInShaper =
            RunningAverage(Pipe->PacketsInShaperAveragingArray, Pipe->PacketsInShaper);

        Flow->sStats.AveragePacketsInShaper =
            RunningAverage(Flow->PacketsInShaperAveragingArray, Flow->PacketsInShaper);
    }

    UNLOCK_PIPE(Pipe);

    return TRUE;

} // TbcSubmitPacket



VOID
TbcSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
  

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          if(Flow) 
          {
              NdisZeroMemory(&Flow->cStats, sizeof(PS_CONFORMER_STATS));
              NdisZeroMemory(&Flow->sStats, sizeof(PS_SHAPER_STATS));
          }
          else 
          {  
              NdisZeroMemory(&Pipe->cStats, sizeof(PS_CONFORMER_STATS));
              NdisZeroMemory(&Pipe->sStats, sizeof(PS_SHAPER_STATS));
          }

          break;
      default:
          break;
    }

    (*Pipe->ContextInfo.NextComponent->SetInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
TbcQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
    ULONG   Size;
    ULONG   cSize, sSize;
    ULONG RemainingLength;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          cSize =   sizeof(PS_CONFORMER_STATS)  +   FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
          sSize =   sizeof(PS_SHAPER_STATS)     +   FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
          Size  =   cSize + sSize;

          if(*Status == NDIS_STATUS_SUCCESS) 
          {
              //
              // The previous component has succeeded - Let us
              // see if we can write the data
              //

              RemainingLength = Len - *BytesWritten;
    
              if(RemainingLength < Size) {

                  *Status = NDIS_STATUS_BUFFER_TOO_SHORT;

                  *BytesNeeded = Size + *BytesWritten;

                  *BytesWritten = 0;

              }
              else {

                  PPS_COMPONENT_STATS Cstats = (PPS_COMPONENT_STATS) Data;

                  *BytesWritten += Size;
                  
                  *BytesNeeded = 0;

                  if(Flow) 
                  {
                      // Per flow stats
                      Cstats->Type = PS_COMPONENT_CONFORMER;
                      Cstats->Length = sizeof(PS_CONFORMER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Flow->cStats, sizeof(PS_CONFORMER_STATS));

                      // Move the pointer to point after the conf. stats.. //
                      Cstats = (PPS_COMPONENT_STATS)((PUCHAR)Cstats + cSize);

                      Cstats->Type = PS_COMPONENT_SHAPER;
                      Cstats->Length = sizeof(PS_SHAPER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Flow->sStats, sizeof(PS_SHAPER_STATS));
                      
                      
                  }
                  else 
                  {
                      // Per adapter stats
                      Cstats->Type = PS_COMPONENT_CONFORMER;
                      Cstats->Length = sizeof(PS_CONFORMER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->cStats, sizeof(PS_CONFORMER_STATS));

                      // Move the pointer to point after the shaper. stats.. //
                      Cstats = (PPS_COMPONENT_STATS)((PUCHAR)Cstats + cSize);
                      
                      Cstats->Type = PS_COMPONENT_SHAPER;
                      Cstats->Length = sizeof(PS_SHAPER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->sStats, sizeof(PS_SHAPER_STATS));
                  }


                  // 
                  // Advance Data so that the next component can update its stats
                  //
                  Data = (PVOID) ((PUCHAR)Data + Size);
              }
          }
          else {

              *BytesNeeded += Size;
              
              *BytesWritten = 0;
          }


          break;
          
      default:

          break;
    }

    (*Pipe->ContextInfo.NextComponent->QueryInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext : 0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\drrseq.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.h

Abstract:

    Defines for Priotiry/DRR Sequencer

Author:


Revision History:

--*/

#ifndef _DRRSEQ_H_
#define _DRRSEQ_H_

#include "PktSched.h"

VOID
InitializeDrrSequencer(
    PPSI_INFO Info);

void
UnloadSequencer();

#endif /* _DRRSEQ_H_ */

/* end DRRSeq.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\globals.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    global defines and definitions

Author:

    Charlie Wickham (charlwi) 19-Apr-1996

Revision History:

--*/

#ifndef _GLOBALS_
#define _GLOBALS_



//
// Macros 
//

#define IsDeviceStateOn(_a) ((_a)->MPDeviceState == NdisDeviceStateD0 && (_a)->PTDeviceState == NdisDeviceStateD0)


#define IsBestEffortVc(_vc)  (_vc->Flags & GPC_CLIENT_BEST_EFFORT_VC)

#define InitGpcClientVc(x, flags, _adapter)            \
    NdisZeroMemory((x), sizeof(GPC_CLIENT_VC));        \
    (x)->Adapter = (_adapter);                         \
    PS_INIT_SPIN_LOCK(&(x)->Lock);                     \
    (x)->RefCount = 1;                                 \
    (x)->ClVcState = CL_CALL_PENDING;                  \
    (x)->Flags = (flags);


// given a pointer to an NDIS_PACKET, return a pointer to PS' protocol
// context area.
//
#define PS_SEND_PACKET_CONTEXT_FROM_PACKET(_pkt)   \
    ((PPS_SEND_PACKET_CONTEXT)((_pkt)->ProtocolReserved))

#define PS_RECV_PACKET_CONTEXT_FROM_PACKET(_pkt)   \
    ((PPS_RECV_PACKET_CONTEXT)((_pkt)->MiniportReserved))


#define MIN_PACKET_POOL_SIZE            0x000000FF
#define MAX_PACKET_POOL_SIZE            0x0000FFFF-MIN_PACKET_POOL_SIZE

#define DEFAULT_MAX_OUTSTANDING_SENDS   0xFFFFFFFF     /* Just making sure we don't do DRR by default..*/
#define DEFAULT_ISSLOW_TOKENRATE        8192           /* In Bytes per second = 64 Kbps */
#define DEFAULT_ISSLOW_PACKETSIZE       200            /* In Bytes */
#define DEFAULT_ISSLOW_FRAGMENT_SIZE    100            /* In Bytes */
#define DEFAULT_ISSLOW_LINKSPEED        19200          /* In Bytes  per second = 128 Kbps */

#define PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT          0
#define PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT      0x18
#define PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT          0x28
#define PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT         0
#define PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT     0x30
#define PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT          0
#define PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT       0
#define PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT   0
#define PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT       0
#define PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT      0
#define PS_IP_SERVICETYPE_NONCONFORMING_NETWORK_CONTROL_DEFAULT  0
#define PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT       0

#define PS_IP_DS_CODEPOINT_MASK                    0x03  //
#define PREC_MAX_VALUE                             0x3f  // Range for the prec value.


#define PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT   1
#define PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT      0
#define PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT  4
#define PS_USER_SERVICETYPE_GUARANTEED_DEFAULT      5
#define PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT     0
#define PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT 7
#define PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT      0
#define USER_PRIORITY_MAX_VALUE                     7 // Range (0-7) for 802.1p

#define WAN_TABLE_INITIAL_SIZE                     16
#define WAN_TABLE_INCREMENT                        32
extern PULONG_PTR     g_WanLinkTable;
extern USHORT         g_NextWanIndex;
extern USHORT         g_WanTableSize;


//  Timer Wheel params  //
extern      ULONG               TimerTag;
extern      ULONG               TsTag;


#define INSTANCE_ID_SIZE                (sizeof(WCHAR) * 20)

//
// the TC-API supports the following service types.
//
// SERVICETYPE_BESTEFFORT
// SERVICETYPE_NETWORK_CONTROL
// SERVICETYPE_QUALITATIVE
// SERVICETYPE_CONTROLLEDLOAD
// SERVICETYPE_GUARANTEED
// SERVICETYPE_NONCONFORMING 
//

#define NUM_TC_SERVICETYPES                        6
//
// These are the states for the GPC client's VCs. We need to keep a fair 
// amount of state because we can get closes from the call manager below us, 
// from an unbind, or from the GPC.
//

typedef enum _CL_VC_STATE {
    CL_VC_INITIALIZED = 1,
    CL_CALL_PENDING,
    CL_INTERNAL_CALL_COMPLETE,
    CL_CALL_COMPLETE,
    CL_MODIFY_PENDING,
    CL_GPC_CLOSE_PENDING,
    CL_INTERNAL_CLOSE_PENDING
} CL_VC_STATE;

typedef enum _PS_DEVICE_STATE {
    PS_DEVICE_STATE_READY = 0,
    PS_DEVICE_STATE_ADDING,
    PS_DEVICE_STATE_DELETING
} PS_DEVICE_STATE;


extern  ULONG   CreateDeviceMutex;

//
// Simple Mutual Exclusion constructs used in preference to
// using KeXXX calls since we don't have Mutex calls in NDIS.
// These can only be called at passive IRQL.
//

#define MUX_ACQUIRE_MUTEX(_pMutexCounter)                               \
{                                                                       \
    while (NdisInterlockedIncrement(_pMutexCounter) != 1)               \
    {                                                                   \
        NdisInterlockedDecrement(_pMutexCounter);                       \
        NdisMSleep(10000);                                              \
    }                                                                   \
}

#define MUX_RELEASE_MUTEX(_pMutexCounter)                               \
{                                                                       \
    NdisInterlockedDecrement(_pMutexCounter);                           \
}


//
// CL_VC_STATE is further modified by these flags.
//

// Indicates that the GPC has requested a close, 
// which we will need to complete.

// COMPLETE_GPC_CLOSE      : GPC has requested a close which we will need to 
//                           complete. 
// INTERNAL_CLOSE_REQUESTED: Indicates that an internal close has been 
//                           requested and should be processed upon completion
//                           of the call.

#define GPC_CLOSE_REQUESTED        0x00000001   
#define INTERNAL_CLOSE_REQUESTED   0x00000002   
#define GPC_CLIENT_BEST_EFFORT_VC  0x00000008
#define GPC_MODIFY_REQUESTED       0x00000010  
#define GPC_WANLINK_VC             0x00000020
#define GPC_ISSLOW_FLOW            0x00000040


//
// These are the states for the BE Vc. In addition to keeping the standard
// CL Vc states for this Vc, we also keep some specific state. The BE Vc
// is initially BE_VC_INITIALIZED. It becomes BE_VC_RUNNING after it has 
// successfully been opened. When it is time to shut down the BE Vc, it 
// goes to BE_VC_CLOSING if there are no pending packets, or to 
// BE_WAITING_FOR_PENDING_PACKETS, if there are pending packets.
//

extern PUCHAR GpcVcState[];

//
// The best effort VC structure for each adapter is contained in 
// the adapter structure. Also - each vc points to the adapter 
// with which it is associated. Therefore, pointers to best-effort 
// VCs can be identified beause they are the same address as the
// offset of the best-effort VC in the adapter struct with which
// they are associated.
//


//
// current state of PS's MP device
//
typedef enum _ADAPTER_STATE {
    AdapterStateInitializing = 1,
    AdapterStateRunning,
    AdapterStateWaiting,
    AdapterStateDisabled,
    AdapterStateClosing,
    AdapterStateClosed
} ADAPTER_STATE;

typedef enum _DRIVER_STATE {
    DriverStateLoaded = 1,
    DriverStateUnloading,
    DriverStateUnloaded
} DRIVER_STATE;

typedef enum _ADAPTER_MODE {
    AdapterModeDiffservFlow = 1,
    AdapterModeRsvpFlow
} ADAPTER_MODE;

//
// shutdown mask values
//

#define SHUTDOWN_CLOSE_WAN_ADDR_FAMILY       0x00000002   // Per adapter
#define SHUTDOWN_DELETE_PIPE                 0x00000008   // Per adapter
#define SHUTDOWN_FREE_PS_CONTEXT             0x00000010   // Per adapter
#define SHUTDOWN_UNBIND_CALLED               0x00000020   // Per adapter
#define SHUTDOWN_MPHALT_CALLED               0x00000040   // Per adapter
#define SHUTDOWN_CLEANUP_ADAPTER             0x00000080   // Per adapter
#define SHUTDOWN_PROTOCOL_UNLOAD             0x00000100   // Per adapter
#define SHUTDOWN_BIND_CALLED                 0x00000200   // Per adapter
#define SHUTDOWN_MPINIT_CALLED               0x00000400   // per adapter

#define SHUTDOWN_RELEASE_TIMERQ         0x00010000
#define SHUTDOWN_DEREGISTER_PROTOCOL    0x00040000
#define SHUTDOWN_DELETE_DEVICE          0x00080000
#define SHUTDOWN_DELETE_SYMLINK         0x00100000
#define SHUTDOWN_DEREGISTER_GPC         0x00200000
#define SHUTDOWN_DEREGISTER_MINIPORT    0x00400000

#define LOCKED 0
#define UNLOCKED 1

#define NEW_VC 0
#define MODIFY_VC 1


//
// QOS related
//

#define QOS_UNSPECIFIED (ULONG)-1

//
// bandwidth related
//

#define UNSPECIFIED_RATE                -1 // indefinite bandwidth
#define RESERVABLE_FRACTION         80 // percentage of link speed

//
// state flags for WAN AF bindings
//

#define WAN_ADDR_FAMILY_OPEN            0x00000001

//
// types of VCs. Note that dummy VCs are created to represent WAN links.
// This allows them to be registered with WMI. They are differentiated by
// the VC type.
//

#define VC_FLOW         1
#define VC_WAN_INTFC    2

typedef struct _PS_SPIN_LOCK 
{
    NDIS_SPIN_LOCK Lock;
#if DBG
    LONG  LockAcquired;
    UCHAR LastAcquiredFile[8];
    ULONG LastAcquiredLine;
    UCHAR LastReleasedFile[8];
    ULONG LastReleasedLine;
#endif
} PS_SPIN_LOCK, *PPS_SPIN_LOCK;



#define BEVC_LIST_LEN   3       //  We have these many BEVCs to do DRR.
#define PORT_LIST_LEN   1       //  Each BEVC will store upto these many port numbers.



typedef struct _GPC_CLIENT_VC {

    //
    // LLTag - for tracking allocation from and freeing to LL list.
    //
    // Lock
    //
    // RefCount
    //
    //
    // Linkage - to put on the adapter block list
    //
    // ClVcState
    //
    // Flags - further modify state
    //
    // AdapterBlk - pointer to associated ADAPTER_BLK context
    //
    // CfInfoHandle - handle to CfInfo
    //
    // InstanceName - copy of instance name registered with WMI for this flow
    //
    // CfType - GPC classification family associated with this VC
    //
    // VcHandle - handle to VC created for this flow
    //
    // CallParameters - pointer to call parameters saved while a MakeCall or
    //                  ModifyCallQoS is in progress
    //
    // AdapterStats - pointer to the Adapter Stats (for non WAN links) or 
    //                per WAN stats.

    STRUCT_LLTAG;
    ULONG                   RefCount;
    CL_VC_STATE             ClVcState;
    struct _ADAPTER         *Adapter;
    ULONG                   Flags;
    PS_SPIN_LOCK            Lock;

    LIST_ENTRY              Linkage;
    NDIS_STRING             InstanceName;

    UCHAR                   IPPrecedenceNonConforming;
    UCHAR                   UserPriorityConforming;
    UCHAR                   UserPriorityNonConforming;
    GPC_HANDLE              CfInfoHandle;
    PCF_INFO_QOS            CfInfoQoS;
    PCF_INFO_QOS            ModifyCfInfoQoS;
    GPC_HANDLE              CfType;
    NDIS_HANDLE             NdisWanVcHandle;
    PCO_CALL_PARAMETERS     CallParameters;
    PCO_CALL_PARAMETERS     ModifyCallParameters;
    PPS_ADAPTER_STATS       AdapterStats;
    struct _PS_WAN_LINK     *WanLink;

    //
    // For the Scheduling Components
    //
    PPS_FLOW_CONTEXT        PsFlowContext;
    PS_FLOW_STATS           Stats;
    ULONG                   TokenRateChange;
    ULONG                   RemainingBandwidthIncreased;
    ULONG                   ShapeTokenRate;
    ULONG                   ISSLOWFragmentSize;

    //
    // These are used to optmize the send path. Over non Wan links, these point to
    // Adapter->PsComponent and Adapter->PsPipeContext. Over WanLinks, these point
    // to WanLink->PsComponent and WanLink->PspipeContext.
    //
    PPSI_INFO               PsComponent;
    PPS_PIPE_CONTEXT        PsPipeContext;
    PSU_SEND_COMPLETE       SendComplete;
    PPS_PIPE_CONTEXT        SendCompletePipeContext;

    //
    //  This flag is added to indicate whether the RemoveFlow() should be called upon ref-count=0 
    //
    BOOL                    bRemoveFlow;

    //  We'll hold on to flows in this array    //
    USHORT                  SrcPort[PORT_LIST_LEN];
    USHORT                  DstPort[PORT_LIST_LEN];
    USHORT                  NextSlot;

} GPC_CLIENT_VC, *PGPC_CLIENT_VC;


typedef struct _DIFFSERV_MAPPING {
    PGPC_CLIENT_VC   Vc;
    UCHAR            ConformingOutboundDSField;
    UCHAR            NonConformingOutboundDSField;
    UCHAR            ConformingUserPriority;
    UCHAR            NonConformingUserPriority;
} DIFFSERV_MAPPING, *PDIFFSERV_MAPPING;


typedef struct _ADAPTER {

    LIST_ENTRY Linkage;

    //
    // MpDeviceName, UpperBinding - unicode device names for 
    // the underlying MP device and the UpperBinding exposed. 
    // The buffers for the strings are allocated with the 
    // adapter and need to be freed with it.
    //
    // ShutdownMask - mask of operations to perform during 
    // unbinding from lower MP
    //

    PS_SPIN_LOCK Lock;
    REF_CNT RefCount;

    NDIS_STRING MpDeviceName;
    NDIS_STRING UpperBinding;
    NDIS_STRING WMIInstanceName;
    NDIS_STRING ProfileName;

    // Points to the "psched\parameter\adapter\...\"
    NDIS_STRING RegistryPath;


    ULONG ShutdownMask;
    PNETWORK_ADDRESS_LIST IpNetAddressList;
    PNETWORK_ADDRESS_LIST IpxNetAddressList;

    //
    // PsMpState - init'ing, running, or closing
    //
    // PsNdisHandle - the handle that identifies the PS device to NDIS
    //
    // BlockingEvent - used to synchronize execution of functions that are
    // awaiting completion
    //
    // FinalStatus - holds status returned in completion routine
    //
    // SendBlockPool    - Pool Handle for per-packet info in the send path
    // SendPacketPool   - Pool handle for NDIS packets in the send path. 
    // RecvPacketPool   - Pool handle for NDIS packets in the recv path. 
    //
    // RawLinkSpeed - link speed as determined by OID_GEN_LINK_SPEED,
    // in 100 bps units.
    //
    // BestEffortLimit - Bps for internal best effort VC; 
    //
    // NonBestEffortLimit - Bps for total non best effort flows;
    //
    // ReservationLimitValue - The % of bandwidth that has to be used for non b/e flows.
    //
    // BestEffortVc - internal best effort VC struct
    //
    // BestEffortVcCreated - set after the VC has been created
    //
    // WanLinkList - list of WAN links on the underlying NDISWAN
    //

    ADAPTER_STATE PsMpState;
    NDIS_HANDLE PsNdisHandle;
    NDIS_EVENT BlockingEvent;
    NDIS_EVENT RefEvent;
    NDIS_EVENT MpInitializeEvent;
    NDIS_EVENT LocalRequestEvent;
    NDIS_STATUS FinalStatus;
    NDIS_HANDLE  SendPacketPool;
    NDIS_HANDLE  RecvPacketPool;
    NDIS_HANDLE  SendBlockPool;  
    ULONG RawLinkSpeed;
    ULONG BestEffortLimit;
    ULONG NonBestEffortLimit;
    ULONG ReservationLimitValue;
    GPC_CLIENT_VC BestEffortVc;
    LIST_ENTRY WanLinkList;

    
    //
    // Scheduler info:
    //
    // PSComponent - pointer to info first scheduling component
    //
    // PSPipeContext - scheduling component's context area for pipe
    //
    // BestEffortPSFlowContext - scheduling component's context area 
    //  for best effort VC
    //
    // FlowContextLength - length of flow context area for scheduler
    //
    // PacketContextLength - length of packet context area
    //
    // SendComplete - scheduler's send completion routine
    //

    PPSI_INFO PsComponent;
    PPS_PIPE_CONTEXT PsPipeContext;
    ULONG PipeContextLength;
    BOOLEAN PipeHasResources;
    ULONG FlowContextLength;
    ULONG PacketContextLength;
    ULONG ClassMapContextLength;

    //
    // Underlying adapter info - handle, type, etc.
    // LowerMPHandle - the binding handle to the underlying MP
    // BindContext - used in BindAdapterHandler 
    // MediaType - self explanatory I would hope
    // LinkSpeed - in 100 bits/sec
    // TotalSize - max # of bytes including the header.
    // RemainingBandWidth - amount of schedulable bytes/second left on this adapter
    // PipeFlags - copy of flags parameter handed to scheduler during pipe initialization
    // HeaderSize - number of bytes in MAC header for this adapter
    // IPHeaderOffset - offset of the IP header - This could be different from HeaderSize because
    //                  the transport could add a LLC/SNAP header.
    // Stats - per adapter stats counters
    // SDModeControlledLoad - Default handling for non-conforming controlled load traffic
    // SDModeGuaranteed - Default handling for non-conforming guaranteed service traffic
    // MaxOutstandingSends - Maximum number of outstanding sends allowed

    NDIS_HANDLE LowerMpHandle;
    NDIS_MEDIUM MediaType;
    NDIS_HANDLE BindContext;
    ULONG LinkSpeed;
    ULONG TotalSize;
    ULONG RemainingBandWidth;
    ULONG PipeFlags;
    ULONG HeaderSize;
    ULONG IPHeaderOffset;
    PS_ADAPTER_STATS Stats;
    ULONG SDModeControlledLoad;
    ULONG SDModeGuaranteed;
    ULONG SDModeNetworkControl;
    ULONG SDModeQualitative;
    ULONG MaxOutstandingSends;

    //
    // WanCmHandle - handle to the WAN call manager, as returned from 
    //              NdisClOpenAddressFamily.
    //

    NDIS_HANDLE WanCmHandle;

    //
    // WanBindingState - state of WAN call manager binding

    ULONG WanBindingState;

    UCHAR IPServiceTypeBestEffort;
    UCHAR IPServiceTypeControlledLoad;
    UCHAR IPServiceTypeGuaranteed;
    UCHAR IPServiceTypeNetworkControl;
    UCHAR IPServiceTypeQualitative;
    UCHAR IPServiceTypeTcpTraffic;
    UCHAR IPServiceTypeBestEffortNC;
    UCHAR IPServiceTypeControlledLoadNC;
    UCHAR IPServiceTypeGuaranteedNC;
    UCHAR IPServiceTypeNetworkControlNC;
    UCHAR IPServiceTypeQualitativeNC;
    UCHAR IPServiceTypeTcpTrafficNC;

    UCHAR UserServiceTypeNonConforming;
    UCHAR UserServiceTypeBestEffort;
    UCHAR UserServiceTypeControlledLoad;
    UCHAR UserServiceTypeGuaranteed;
    UCHAR UserServiceTypeNetworkControl;
    UCHAR UserServiceTypeQualitative;
    UCHAR UserServiceTypeTcpTraffic;

    //
    // No of CfInfos - In the send path, this is used to determine whether we 
    // have to classify the packet or send it over the b/e VC
    //
    ULONG CfInfosInstalled;
    ULONG FlowsInstalled;
    LIST_ENTRY GpcClientVcList;
    ULONG WanLinkCount;

    LARGE_INTEGER VcIndex;

    PDIFFSERV_MAPPING pDiffServMapping;
    ADAPTER_MODE AdapterMode;
    ULONG ISSLOWTokenRate;
    ULONG ISSLOWPacketSize;
    ULONG ISSLOWFragmentSize;
    ULONG ISSLOWLinkSpeed;
    BOOLEAN IndicateRcvComplete;
    BOOLEAN IfcNotification;
    BOOLEAN StandingBy;
    ULONG OutstandingNdisRequests;
    NDIS_DEVICE_POWER_STATE MPDeviceState;
    NDIS_DEVICE_POWER_STATE PTDeviceState;
    USHORT ProtocolType;
    struct _PS_NDIS_REQUEST *PendedNdisRequest;
    TC_INTERFACE_ID InterfaceID;

} ADAPTER, *PADAPTER;



//
// Wan links are created when we get a WAN_LINE_UP from an underlying 
// NDISWAN. There may be multiple WAN links per adapter. Each WAN link
// has a single best-effort VC on it and may have any number of additional 
// VCs (one per flow).
//

//
// WAN VC - describes a VC associated with this WAN link
//

typedef enum _WAN_STATE {
    WanStateOpen = 1,
    WanStateClosing
} WAN_STATE;

typedef struct _PS_WAN_LINK 
{
    WAN_STATE               State;
    LIST_ENTRY              Linkage;
    ULONG                   RawLinkSpeed;     // In 100 bps
    ULONG                   LinkSpeed;        // In Bps (Bytes per second)
    UCHAR                   OriginalLocalMacAddress[ARP_802_ADDR_LENGTH];
    UCHAR                   OriginalRemoteMacAddress[ARP_802_ADDR_LENGTH];
    REF_CNT                 RefCount;
    DIAL_USAGE              DialUsage;
    USHORT                  ProtocolType;
    ULONG                   LocalIpAddress;
    ULONG                   RemoteIpAddress;
    ULONG                   LocalIpxAddress;
    ULONG                   RemoteIpxAddress;
    PS_ADAPTER_STATS        Stats;
    PS_SPIN_LOCK            Lock;
    ULONG                   FlowsInstalled;
    NDIS_STRING             InstanceName;
    NDIS_STRING             MpDeviceName;
    PADAPTER                Adapter;
    ULONG                   RemainingBandWidth;
    ULONG                   NonBestEffortLimit;
    PPSI_INFO               PsComponent;
    PPS_PIPE_CONTEXT        PsPipeContext;
    ULONG                   ShutdownMask;
    USHORT                  UniqueIndex;
    ETH_HEADER              SendHeader;
    ETH_HEADER              RecvHeader;
    ADAPTER_MODE            AdapterMode;
    PDIFFSERV_MAPPING       pDiffServMapping;
    ULONG                   CfInfosInstalled;
    TC_INTERFACE_ID         InterfaceID;

    GPC_CLIENT_VC           BestEffortVc;
    GPC_CLIENT_VC           BeVcList[ BEVC_LIST_LEN ];
    int                     NextVc;
    

} PS_WAN_LINK, *PPS_WAN_LINK;
    
//
// our NdisRequest super structure. There are two types of NdisRequests: 
// originated by the upper layer which go straight through to the 
// underlying miniport and originated by the PS. The latter also 
// degenerates into blocking and nonblocking.
//
// Since upper layer NdisRequests are unbundled to MPs, we need to 
// allocate our own structure to rebuild and issue the request to 
// the lower layer. We need some addt'l space to hold pointers to the 
// BytesWritten/BytesRead and BytesNeeded parameters of the original 
// request. These are tagged on at the end so the NdisRequest completion 
// routine can set those values in the NdisRequest originally issued to PS.
//
// There are allocated by NdisAllocateFromNPagedLookasideList, there is a STRUCT_LLTAG.
// LocalRequest means the request was issued by PS and shouldn't be 
// completed to the higher layer. If a LocalCompletion routine is specified, 
// then this is a nonblocking request.
//
// OriginalNdisRequest is used to complete a higher layer CoRequest.
//

typedef VOID (*LOCAL_NDISREQUEST_COMPLETION_FUNCTION)(PADAPTER,
                                                      NDIS_STATUS);
typedef struct _PS_NDIS_REQUEST {
    NDIS_REQUEST ReqBuffer; // Must be first!!!
    STRUCT_LLTAG;
    PULONG BytesReadOrWritten;
    PULONG BytesNeeded;
    BOOLEAN LocalRequest;
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION LocalCompletionFunc;
} PS_NDIS_REQUEST, *PPS_NDIS_REQUEST;


//
// use Generic NdisRequest types to indicate NdisRequests that 
// were originated by PS
//

#define NdisRequestLocalSetInfo     NdisRequestGeneric1
#define NdisRequestLocalQueryInfo   NdisRequestGeneric2

//
// Packet context structure. This area resides at the start of 
// the ProtocolReserved area of each packet
//
// Info - packet info block for this packet. Includes information 
//      potentially needed by the scheduling components: queue links, 
//      conformance time, packet length.
//
// AdapterVCLink - links packet on Adapter VC's list of outstanding 
//      packets. Once a packet is removed from the timer Q for sending, 
//      it is also removed from this list. This list is used to free 
//      packets that are awaiting transmission when the adapter VC is 
//      deactivate. Packets in the process of being transmitted
//      aren't linked since a reference was taken out for each packet 
//      associated with the adapter VC.
//
// The following vars are used only during the sending of a packet:
//
// OriginalPacket - a pointer to the original packet (duh) handed to us by
//      the upper layer.
//
// AdapterVC - pointer back to AdapterVC struct. Used during send completion so
//      completion is propagated to higher layer in the correct manner
//
// SchedulingComponentInfo - Any packet context area required by the scheduling
//     components is stored after the PS's packet context.  If none of the
//     components need additional context area, then this area is not included.
//
// MediaSpecificInfo - used to hold packet priority for MPs that allow packet
//     priority to be specified. Included in the proto reserved area only if
//     the lower MP supports priority queueing. Immediately follows the 
//     packet context struct if included
//
// SubmittedToScheduler - some packets bypass the scheduler. These should not 
//     be submitted to the scheduler's completion routine.
//

typedef struct _PS_SEND_PACKET_CONTEXT
{
    PACKET_INFO_BLOCK Info;
    PNDIS_PACKET      OriginalPacket;
    SINGLE_LIST_ENTRY FreeList;
    PGPC_CLIENT_VC    Vc;
} PS_SEND_PACKET_CONTEXT, *PPS_SEND_PACKET_CONTEXT;

typedef struct _PS_RECV_PACKET_CONTEXT
{
    PNDIS_PACKET OriginalPacket;
} PS_RECV_PACKET_CONTEXT, *PPS_RECV_PACKET_CONTEXT;

// 
//  Ndis requires a minimum of 8 bytes for the MediaSpecific parameters.
//  We'll create a dummy media specific parmeter block:
//

typedef struct _PS_MEDIA_PARAMETERS{

    CO_MEDIA_PARAMETERS StdMediaParameters;
    UCHAR LinkId[6]; // Used by NdisWan
    NDIS_STRING InstanceName; 

} PS_MEDIA_PARAMETERS, *PPS_MEDIA_PARAMETERS;


typedef struct _RUNNING_AVERAGE {
    ULONG *Elements;
    ULONG Index;
    ULONG Sum;
    ULONG Size;    
} RUNNING_AVERAGE, *PRUNNING_AVERAGE;

#if CBQ
//
// Context used by AddCfInfo for "ClassMap" to be sent back 
// to the GPC. 
//
typedef struct _CLASS_MAP_CONTEXT_BLK {
    PADAPTER Adapter;
    PPS_CLASS_MAP_CONTEXT ComponentContext;
    PPS_WAN_LINK WanLink;
} CLASS_MAP_CONTEXT_BLK, *PCLASS_MAP_CONTEXT_BLK;
#endif

typedef struct _PS_INTERFACE_INDEX {
    PADAPTER     Adapter;
    PPS_WAN_LINK WanLink;
} PS_INTERFACE_INDEX_CONTEXT, *PPS_INTERFACE_INDEX_CONTEXT;

//
// define for determing if media is LAN oriented
//

#define NDIS_MEDIA_LAN( _adpt ) (( _adpt )->MediaType == NdisMedium802_3 || \
                                 ( _adpt )->MediaType == NdisMedium802_5 || \
                                 ( _adpt )->MediaType == NdisMediumFddi || \
                                 ( _adpt )->MediaType == NdisMediumDix)



//
// global vars (not based on a device instance)
//

extern ULONG                  InitShutdownMask;
extern ULONG                  AdapterCount;
extern ULONG                  DriverRefCount;
extern BOOLEAN                WMIInitialized;
extern DRIVER_STATE           gDriverState;
extern LIST_ENTRY             AdapterList;
extern LIST_ENTRY             PsComponentList;
extern LIST_ENTRY             PsProfileList;
extern NDIS_HANDLE            ClientProtocolHandle;
extern NDIS_HANDLE            CallMgrProtocolHandle;
extern NDIS_HANDLE            MpWrapperHandle;
extern NDIS_HANDLE            LmDriverHandle;
extern NDIS_HANDLE            PsDeviceHandle;
extern PDRIVER_OBJECT         PsDriverObject;
extern PDEVICE_OBJECT         PsDeviceObject;
extern HANDLE                 PsDeviceHandle;
extern NPAGED_LOOKASIDE_LIST  NdisRequestLL;
extern NPAGED_LOOKASIDE_LIST  AdapterVcLL;
extern NPAGED_LOOKASIDE_LIST  ClientVcLL;
extern NPAGED_LOOKASIDE_LIST  GpcClientVcLL;
extern NDIS_EVENT             DriverUnloadEvent;

extern NDIS_STRING            PsDriverName;
extern NDIS_STRING            PsSymbolicName;
extern NDIS_STRING            PsMpName;
extern NDIS_STRING            WanPrefix;
extern NDIS_STRING            VcPrefix;
extern NDIS_STRING            MachineRegistryKey;

extern PSI_INFO               TbConformerInfo;
extern PSI_INFO               ShaperInfo;
extern PSI_INFO               DrrSequencerInfo;
extern PSI_INFO               SchedulerStubInfo;
extern PSI_INFO               TimeStmpInfo;

extern PS_PROFILE             DefaultSchedulerConfig;

extern PS_PROCS               PsProcs;

extern ULONG                  gEnableAvgStats;
extern ULONG                  gEnableWindowAdjustment;
extern NDIS_STRING            gsEnableWindowAdjustment;

// Global locks

extern PS_SPIN_LOCK AdapterListLock;
extern PS_SPIN_LOCK DriverUnloadLock;
    
// Timer

extern ULONG gTimerResolutionActualTime;
extern ULONG gTimerSet;

//
// ZAW
//
extern NDIS_EVENT gZAWEvent;
extern ULONG      gZAWState;
#define ZAW_STATE_READY  0
#define ZAW_STATE_IN_USE 1

// GPC Interface

#define PS_QOS_CF       0x00000001
#define PS_CLASS_MAP_CF 0x00000002
#define GPC_NO_MATCH (ULONG)-1

extern GPC_EXPORTED_CALLS GpcEntries;
extern GPC_HANDLE GpcQosClientHandle;
#if CBQ
extern GPC_HANDLE GpcClassMapClientHandle;
#endif
extern PS_DEVICE_STATE DeviceState;

extern PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];

//
// NULL Component hacks for now [ShreeM]
//
extern PS_RECEIVE_PACKET       TimeStmpRecvPacket;
extern PS_RECEIVE_INDICATION   TimeStmpRecvIndication;

//
//  This is the RawLinkSpeed below which we trigger DRR
//
#define MAX_LINK_SPEED_FOR_DRR      7075 //( 56.6 * 1000 / 8)  // 56.6 kbps converted to bytes/sec


#endif/* _GLOBALS_ */

/* end globals.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\conformr.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Conformr.h

Abstract:

    Defines for token bucket conformer

Author:


Revision History:

--*/

#ifndef _CONFORMR_H_
#define _CONFORMR_H_

#include "PktSched.h"

VOID
InitializeTbConformer(
    PPSI_INFO Info);

void
UnloadConformr();

#endif /* _CONFORMR_H_ */

/* end Conformr.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\debug.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    debug defines shared between the KD extensions and the driver

Author:

    Charlie Wickham (charlwi) 11-May-1995

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

//
//
// Debug Level and Mask definitions.
//

#define DBG_DEATH               1
#define DBG_CRITICAL_ERROR      2
#define DBG_FAILURE             4
#define DBG_INFO                6
#define DBG_TRACE               8
#define DBG_VERBOSE             10

#define DBG_INIT                0x00000001
#define DBG_MINIPORT            0x00000002
#define DBG_PROTOCOL            0x00000004
#define DBG_SEND                0x00000008
#define DBG_RECEIVE             0x00000010
#define DBG_IO                  0x00000020
#define DBG_MEMORY              0x00000040
#define DBG_CM                  0x00000080
#define DBG_REFCNTS             0x00000100
#define DBG_VC                  0x00000200
#define DBG_GPC_QOS             0x00000400
#define DBG_WAN                 0x00000800
#define DBG_STATE               0x00001000
#define DBG_ROUTINEOIDS         0x00002000
#define DBG_SCHED_TBC           0x00004000
#define DBG_SCHED_SHAPER        0x00008000
#define DBG_SCHED_DRR           0x00010000
#define DBG_WMI                 0x00020000
#define DBG_ZAW                 0x00040000
#define DBG_ALL                 0xFFFFFFFF

//
// these tags are used in Lookaside lists therefore need to be 
// available regardless of the type of build
//

extern ULONG NdisRequestTag;
extern ULONG GpcClientVcTag;
extern ULONG WanLinkTag;
extern ULONG PsMiscTag;
extern ULONG WMITag;
#define NDIS_PACKET_POOL_TAG_FOR_PSCHED 'pPDN'

// We mark all memory allocated via PsAllocateXXX with a signature 
// immediately following allocation, and with another signature 
// immediately preceeding freeing.

#define ALLOCATED_MARK  (UCHAR) 0xDD
#define FREED_MARK      (UCHAR) 0xBB

//
// NT Debugging routines
//


//
// signatures for data structures
//

extern ULONG AdapterTag;
extern ULONG CmParamsTag;
extern ULONG PipeContextTag;
extern ULONG FlowContextTag;
extern ULONG ClassMapContextTag;
extern ULONG ProfileTag;
extern ULONG ComponentTag;
extern ULONG WanTableTag;

#if DBG
extern CHAR VersionNumber[];
extern CHAR VersionHerald[];
extern CHAR VersionTimestamp[];

#define DEBUGCHK    DbgBreakPoint()

#define STATIC

//
// these correspond to DebugLevel and DebugMask in Psched\Parameters
//

extern ULONG DbgTraceLevel;
extern ULONG DbgTraceMask;
extern ULONG LogTraceLevel;
extern ULONG LogTraceMask;
extern ULONG LogId;
extern ULONG DbgTraceControl;
extern ULONG ClassificationType;

#define PsDbgSched(_DebugLevel, _DebugMask, _r, _s, _t, _u, _v, _w, _x1, _x2, _y, _z){\
    if ((LogTraceLevel >= _DebugLevel) &&          \
        ((_DebugMask) & LogTraceMask)){            \
             DbugSched(_r, _s, _t, _u, _v, _w, (_x1), (_x2), _y, _z);\
    }\
}

#define PsDbgRecv(_DebugLevel, _DebugMask, _event, _action, _a, _p1, _p2) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                  \
        ((_DebugMask) & LogTraceMask)){                                    \
            DbugRecv(_event, _action, _a, _p1, _p2);                       \
    }                                                                      \
}

#define PsDbgSend(_DebugLevel, _DebugMask, _event, _action, _a, _v, _p1, _p2) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                      \
        ((_DebugMask) & LogTraceMask)){                                        \
            DbugSend(_event, _action, _a, _v, _p1, _p2);                       \
    }                                                                          \
}

#define PsDbgOid(_DebugLevel, _DebugMask, Action, Local, PTState, MPState, Adapter, Oid, Status) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                       \
        ((_DebugMask) & LogTraceMask)){                                         \
            DbugOid(Action, Local, PTState, MPState, Adapter, Oid, Status);     \
    }                                                                           \
}

#define PsDbgOut(_DebugLevel, _DebugMask, _Out){   \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint("PSched: ");                       \
        DbgPrint _Out;                              \
    }                                               \
    if ((LogTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & LogTraceMask)){             \
        DbugSchedString _Out;                       \
    }                                               \
}

#define PsDbgOutNoID(_DebugLevel, _DebugMask, _Out) {   \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint _Out;                              \
    }                                               \
    if ((LogTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & LogTraceMask)){             \
        DbugSchedString _Out;                       \
    }                                               \
}

#define PS_LOCK(_s)                                 {               \
    NdisAcquireSpinLock(&((_s)->Lock));                             \
    PsAssert((_s)->LockAcquired == FALSE);                          \
    (_s)->LockAcquired = TRUE;                                      \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
}

#define PS_UNLOCK(_s)                                               \
{                                                                   \
    PsAssert((_s)->LockAcquired == TRUE);                           \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastReleasedLine = __LINE__;                              \
    strncpy((_s)->LastReleasedFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisReleaseSpinLock(&((_s)->Lock));                             \
}

#define PS_LOCK_DPC(_s) {                                           \
    PsAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);                 \
    NdisDprAcquireSpinLock(&((_s)->Lock));                          \
    PsAssert((_s)->LockAcquired == FALSE);                          \
    (_s)->LockAcquired = TRUE;                                      \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
}

#define PS_UNLOCK_DPC(_s)                                           \
{                                                                   \
    PsAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);                 \
    PsAssert((_s)->LockAcquired == TRUE);                           \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastReleasedLine = __LINE__;                              \
    strncpy((_s)->LastReleasedFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisDprReleaseSpinLock(&((_s)->Lock));                          \
}

#define PS_INIT_SPIN_LOCK(_s) {                                     \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisAllocateSpinLock(&((_s)->Lock));                            \
}

#define KdPrint( x )    DbgPrint x

#define STRUCT_LLTAG   ULONG LLTag

#define PsStructAssert(_tag) if ((_tag) != NULL && *(PULONG)((PUCHAR)_tag - sizeof(ULONG)) != _tag##Tag) {\
    DbgPrint( "PSched: structure assertion failure for type " #_tag " in file " __FILE__ " line %d\n", __LINE__ );\
    DEBUGCHK;\
    }

#define PsAssert(c)    if (!(c)) {\
    DbgPrint( "PSched: assertion @ line %d in file " __FILE__ " \n", __LINE__ );\
    DEBUGCHK;\
    }

//
// allocate memory from nonpaged pool and set the tag in the checked
// version of the structure
//

#define PsAllocatePool( _addr, _size, _tag )                                  \
{                                                                             \
    PCHAR _Temp;                                                              \
    ULONG _Size = (_size) + 2 * sizeof(ULONG);                                \
    _Temp = ExAllocatePoolWithTag( NonPagedPool, (_Size), (_tag));            \
    if ( _Temp ) {                                                            \
        NdisFillMemory( _Temp, _Size, ALLOCATED_MARK);                        \
        *(PULONG)_Temp = _Size;                                               \
        *(PULONG)(_Temp + sizeof(ULONG)) = _tag;                              \
        (PCHAR)(_addr) = _Temp + 2 * sizeof(ULONG);                           \
    }                                                                         \
    else{                                                                     \
        (PCHAR)(_addr) = _Temp;                                               \
    }                                                                         \
}

#define PsFreePool(_addr)                                                   \
{                                                                           \
    PCHAR _Temp = (PCHAR)(_addr) - 2 * sizeof(ULONG);                       \
    ULONG _Size = *(PULONG)_Temp;                                           \
    NdisFillMemory( _Temp, _Size, FREED_MARK);                              \
    ExFreePool(_Temp);                                                      \
}

//
// structures allocated from lookaside lists don't go through PsAllocateXXX.
// so - if we wanna tag these, we'll have to macro the LL routines.
//

#define PsAllocFromLL(_ptr, _list, _tag) \
    *_ptr = NdisAllocateFromNPagedLookasideList(_list); \
    if(*_ptr != 0) {\
        *_ptr->LLTag = _tag##Tag; \
    }

#define PsFreeToLL(_ptr, _list, _tag) \
    PsAssert(_ptr->LLTag == _tag##Tag); \
    _ptr->LLTag = (ULONG)0; \
    NdisFreeToNPagedLookasideList(_list, _ptr); \

#define CheckLLTag(_ptr, _tag) \
    PsAssert(_ptr->LLTag == _tag##Tag); 

#define SetLLTag(_ptr, _tag) (_ptr)->LLTag = _tag##Tag;

#else // DBG

#define DEBUGCHK
#define PsDbgSched(_DebugLevel, _DebugMask, _r, _s, _t, _u, _v, _w, _x1, _x2, _y, _z)
#define PsDbgRecv(_DebugLevel, _DebugMask, _event, _action, _a, _p1, _p2) 
#define PsDbgSend(_DebugLevel, _DebugMask, _event, _action, _a, _v, _p1, _p2)
#define PsDbgOut(s,t,u)
#define PsDbgOid(p,q,s,t,u,v,w,x,y)
#define PsDbgOutNoID(s,t,u)
#define PsDbg(r, s, t, u)
#define KdPrint( x )
#define STRUCT_LLTAG          /##/
#define PsStructAssert( t )
#define PsAssert(c)
#define PS_LOCK(_s)           NdisAcquireSpinLock(&((_s)->Lock))
#define PS_UNLOCK(_s)         NdisReleaseSpinLock(&((_s)->Lock))
#define PS_LOCK_DPC(_s)       NdisDprAcquireSpinLock(&((_s)->Lock))
#define PS_UNLOCK_DPC(_s)     NdisDprReleaseSpinLock(&((_s)->Lock))
#define PS_INIT_SPIN_LOCK(_s) NdisAllocateSpinLock(&((_s)->Lock))

#define PsAllocatePool( _addr, _size, _tag )                       \
    _addr = ExAllocatePoolWithTag( NonPagedPool, (_size), (_tag)); \
    if ( _addr ) {                                                 \
        NdisZeroMemory( _addr, _size );                            \
    }

#define PsFreePool(_addr)  ExFreePool(_addr)

//
// structures allocated from lookaside lists don't go through PsAllocateXXX.
// so - if we wanna tag these, we'll have to macro the LL routines.
//

#define PsAllocFromLL(_ptr, _list, _tag) \
    *_ptr = (PVOID)NdisAllocateFromNPagedLookasideList(_list); \

#define PsFreeToLL(_ptr, _list, _tag) \
    NdisFreeToNPagedLookasideList(_list, _ptr);

#define CheckLLTag(_ptr, _tag) 
#define SetLLTag(_ptr, _tag)

#define STATIC static

#endif // DBG

#endif /* _DEBUG_ */

/* end debug.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\drrseq.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.c

Abstract:

    Priority/DRR Sequencer.  This module is a scheduling component that
    determines the order in which submitted packets should be sent.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

// The sequencer classifies each flow into an internal "priority group" based
// on the flow's service type and conformance status. Within each priority
// group, there may be one or more priority levels or offsets.  The total
// number of internal priority levels is the sum of the priority levels for
// each priority group.  The internal priority assigned to each flow is
// calculated from the priority group and the relative priority within the
// group, which is obtained from the QOS Priority object.  The 802.1 priority,
// is set by the wrapper. The non conforming values are obtained from the 
// packet.
//
// The flows of the following servicetypes have no internal priority.
//     SERVICETYPE_BESTEFFORT
//     SERVICETYPE_NONCONFORMING
//     SERVICETYPE_QUALITATIVE.
// 
// SERVICETYPE_BESTEFFORT is treated as SERVICETYPE_QUALITATIVE in the sequencer, so the no of priority
// groups is 1 less than the no. of servicetypes.

#define RELATIVE_PRIORITIES             8
#define PRIORITY_GROUPS                 (NUM_TC_SERVICETYPES - 1)
#define INTERNAL_PRIORITIES             (((PRIORITY_GROUPS - 2) * RELATIVE_PRIORITIES) + 2)
#define DEFAULT_PRIORITY_OFFSET         3
#define DEFAULT_MIN_QUANTUM             1500

#define PRIORITY_GROUP_NON_CONFORMING   0
#define PRIORITY_GROUP_BEST_EFFORT      1
#define PRIORITY_GROUP_CONTROLLED_LOAD  2
#define PRIORITY_GROUP_GUARANTEED       3
#define PRIORITY_GROUP_NETWORK_CONTROL  4

//
// For maintaining stats
//
#define SEQUENCER_AVERAGING_ARRAY_SIZE      256
#define NETCARD_AVERAGING_ARRAY_SIZE        256
#define SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE     256


// The DRR Sequencer's pipe information

typedef struct _DSEQ_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe and flow data
    // Flags -                  See below
    // Flows -                  List of all installed flows
    // ActiveFlows -            Lists of flows that are waiting to send packets
    // PriorityLevels -         Number of priority offsets for each priority group
    // StartPriority -          Lowest internal priority value for each priority group
    // ActiveFlowCount -        Number of active flows for each service type
    // MaxOutstandingSends -    Maximum number of outstanding sends
    // OutstandingSends -       Number of outstanding sends
    // PacketsInNetcardAveragingArray
    // PacketsInSequencer -     Current number packets in sequencer
    // PacketsInSequencerAveragingArray
    // Bandwidth -              Link speed
    // MinimumQuantum -         Minimum quantum size for DRR
    // MinimumRate -            Smallest rate currently assigned to a flow
    // TimerResolution -        Timer resolution in OS time units
    // PsFlags -                Flags from pipe parameters
    // PsPipeContext -          PS's pipe context value

    PS_PIPE_CONTEXT ContextInfo;

    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInNetcardAveragingArray;
    ULONG PacketsInSequencer;
    PRUNNING_AVERAGE PacketsInSequencerAveragingArray;

    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Flows;
    LIST_ENTRY ActiveFlows[INTERNAL_PRIORITIES];
    ULONG PriorityLevels[PRIORITY_GROUPS];
    ULONG StartPriority[PRIORITY_GROUPS];
    ULONG ActiveFlowCount[PRIORITY_GROUPS];
    ULONG TotalActiveFlows;
    ULONG MaxOutstandingSends;

    ULONG ConfiguredMaxOutstandingSends;
    //  This is added to keep track of what the Registry/User-asked value of MOS is, while we might
    //  have changed MOS to be able to do DRR on this Pipe/WanLink. When we switch back from DRR mode
    //  with MOS=1, we'll use this going forward.

    ULONG IsslowFlowCount;
    //  This is added to keep track of the number of active/current ISSLOW flows. We will do DRR on this
    //  WanLink (if it is a WanLink) only if this count is 0.
    
    ULONG OutstandingSends;
    ULONG Bandwidth;
    ULONG MinimumQuantum;
    ULONG MinimumRate;
    ULONG TimerResolution;
    ULONG PsFlags;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    PSU_SEND_COMPLETE PreviousUpcallsSendComplete;
    PPS_PIPE_CONTEXT   PreviousUpcallsSendCompletePipeContext;
    
} DSEQ_PIPE, *PDSEQ_PIPE;

// Pipe flag values

#define DSEQ_DEQUEUE            1
#define DSEQ_PASSTHRU           2

typedef enum _FLOW_STATE {
    DRRSEQ_FLOW_CREATED = 1,
    DRRSEQ_FLOW_DELETED
} FLOW_STATE;

// The DRR Sequencer's flow information

typedef struct _DSEQ_FLOW {

    // ContextInfo -            Generic context info
    // ActiveLinks -            Links in active flow list
    // Links -                  Links in installed flow list
    // PacketQueue -            Self-explanatory
    // PacketSendTime -         Send time for current packet
    // LastConformanceTime -    Absolute conformance time of last packet
    // TokenRate -              TokenRate from GQOS
    // UserPriority -           Priority offset assigned by user
    // Priority -               Internal priority
    // PriorityGroup -          Priority group for flow
    // Quantum -                Quantum assigned to flow for DRR
    // DeficitCounter -         Current value of DRR deficit counter
    // Flags -                  See below
    // PsFlowContext -          PS's flow context value
    // BucketSize -             TokenBucketSize from GQOS
    // NumPacketsInSeq -                Number of packets from this flow in the sequencer
    // PacketsInSeqAveragingArray-Data for computing average packets in seq from this flow

    PS_FLOW_CONTEXT ContextInfo;
    LIST_ENTRY ActiveLinks;
    LIST_ENTRY Links;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER PacketSendTime;
    LARGE_INTEGER LastConformanceTime;
    ULONG TokenRate;
    ULONG UserPriority;
    ULONG Priority;
    ULONG PriorityGroup;
    ULONG Quantum;
    ULONG DeficitCounter;
    ULONG Flags;
    HANDLE PsFlowContext;
    ULONG BucketSize;

    ULONG PacketsInSequencer;
    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInSeqAveragingArray;

    FLOW_STATE  State;
    
} DSEQ_FLOW, *PDSEQ_FLOW;

#define MAX_DEQUEUED_PACKETS            8

//
//  Values for Drr Seq Flow flags: [ Don't know why 1 was not used here]
#define FLOW_USER_PRIORITY              0x00000002
//      GPC_ISSLOW_FLOW                 0x00000040      Indicates that this is an ISSLOW flow. 
//                                                      Make sure not to use the same flag for something else.


// The following macro checks a packet for conformance based on the flow's
// LastPacketTime, the current time, and the timer resolution.

#define PacketIsConforming(_flow, _packetinfo, _curtime, _r)              \
    ( (_flow)->PacketSendTime.QuadPart <= ((_curtime).QuadPart + (_r)) && \
      (_packetinfo)->PacketLength <= (_flow)->BucketSize                  \
    )

#define AdjustLastPacketTime(_flow, _curtime, _r) \
    if ((_curtime).QuadPart > ((_flow)->PacketSendTime.QuadPart + (_r))) \
        if ((_curtime).QuadPart > ((_flow)->LastConformanceTime.QuadPart - (_r))) \
            (_flow)->PacketSendTime = (_flow)->LastConformanceTime; \
        else \
            (_flow)->PacketSendTime = (_curtime);

#define LOCK_PIPE(_p)   NdisAcquireSpinLock(&(_p)->Lock)
#define UNLOCK_PIPE(_p) NdisReleaseSpinLock(&(_p)->Lock)

/* External */

/* Static */

/* Forward */

NDIS_STATUS
DrrSeqInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
DrrSeqModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
DrrSeqDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
DrrSeqCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
DrrSeqModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
DrrSeqDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
DrrSeqEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

static NDIS_STATUS 
DrrSeqCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

static NDIS_STATUS 
DrrSeqDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

BOOLEAN
DrrSeqSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    );

VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

VOID
DrrSetInformation(
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);

VOID
DrrQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);
VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

/* End Forward */


VOID
InitializeDrrSequencer(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for the DRR sequencer.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    Info->PipeContextLength = ((sizeof(DSEQ_PIPE) + 7) & ~7);
    Info->FlowContextLength = ((sizeof(DSEQ_FLOW) + 7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = DrrSeqInitializePipe;
    Info->ModifyPipe = DrrSeqModifyPipe;
    Info->DeletePipe = DrrSeqDeletePipe;
    Info->CreateFlow = DrrSeqCreateFlow;
    Info->ModifyFlow = DrrSeqModifyFlow;
    Info->DeleteFlow = DrrSeqDeleteFlow;
    Info->EmptyFlow =  DrrSeqEmptyFlow;
    Info->CreateClassMap = DrrSeqCreateClassMap;
    Info->DeleteClassMap = DrrSeqDeleteClassMap;
    Info->SubmitPacket = DrrSeqSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = DrrSetInformation;
    Info->QueryInformation = DrrQueryInformation;

} // InitializeDrrSequencer



VOID
CleanupDrrSequencer(
    VOID)

/*++

Routine Description:

    Cleanup routine for the DRR sequencer.

Arguments:

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
} // CleanupDrrSequencer



VOID
AdjustFlowQuanta(
    PDSEQ_PIPE Pipe,
    ULONG MinRate)

/*++

Routine Description:

    Adjust the quantum value for all flows based on the new minimum value.  If MinRate
    is unspecified then a search for the new minimum rate will be performed.

Arguments:

    Pipe -      Pointer to pipe context information
    MinRate -   New value for minimum rate, or GQPS_UNSPECIFIED to force a search

Return Values:


--*/
{
    PDSEQ_FLOW Flow;
    PLIST_ENTRY Entry;

    if (MinRate == QOS_NOT_SPECIFIED) {

        if (Pipe->Bandwidth > 0) {
            MinRate = Pipe->Bandwidth;
        }
        for (Entry = Pipe->Flows.Flink; Entry != &Pipe->Flows; Entry = Entry->Flink) {
            Flow = CONTAINING_RECORD(Entry, DSEQ_FLOW, Links);

            if ((Flow->TokenRate < MinRate) && (Flow->PriorityGroup > PRIORITY_GROUP_BEST_EFFORT) &&
                (Flow->PriorityGroup != PRIORITY_GROUP_NETWORK_CONTROL)) {
                MinRate = Flow->TokenRate;
            }
        }
    }

    for (Entry = Pipe->Flows.Flink; Entry != &Pipe->Flows; Entry = Entry->Flink) {
        Flow = CONTAINING_RECORD(Entry, DSEQ_FLOW, Links);

        if ((Flow->TokenRate == QOS_NOT_SPECIFIED) ||   
            (Flow->PriorityGroup == PRIORITY_GROUP_NETWORK_CONTROL) ||
            (Flow->PriorityGroup <= PRIORITY_GROUP_BEST_EFFORT)) {

            Flow->Quantum = Pipe->MinimumQuantum;
        } else {
            Flow->Quantum = (ULONG) (((ULONGLONG)(Flow->TokenRate) * (ULONGLONG)(Pipe->MinimumQuantum)  ) / MinRate);
        }

        PsAssert((LONG)Flow->Quantum > 0);
    }

    Pipe->MinimumRate = MinRate;
    PsAssert(Pipe->MinimumRate != 0);
            
} // AdjustFlowQuanta



VOID
DequeuePackets(
    PDSEQ_PIPE Pipe)

/*++

Routine Description:

    Select the next packet(s) to send.  The lock must be held upon entry to this
    routine.

Arguments:

    Pipe -       Pointer to pipe context information

Return Values:


--*/
{
    PDSEQ_FLOW Flow;
    LARGE_INTEGER CurrentTime;
    PLIST_ENTRY LowPriorityList = &Pipe->ActiveFlows[0];
    PLIST_ENTRY CurrentLink;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    ULONG Priority;
    ULONG PriorityGroup;
    PPACKET_INFO_BLOCK PacketsToSend[MAX_DEQUEUED_PACKETS];
    ULONG SendingPriority[MAX_DEQUEUED_PACKETS];
    ULONG PacketSendCount = 0;
    ULONG MaxDequeuedPackets = Pipe->MaxOutstandingSends - Pipe->OutstandingSends;
    ULONG i;

    //  Need to call this to disable the user APCs after this point.
    //  Note that the DDK says it should be called at PASSIVE. But it can very well be
    //  called at DISPATCH.
    KeEnterCriticalRegion();

    Pipe->Flags |= DSEQ_DEQUEUE;

    PsGetCurrentTime(&CurrentTime);

    PsAssert(Pipe->MaxOutstandingSends >= Pipe->OutstandingSends);

    if (MaxDequeuedPackets > MAX_DEQUEUED_PACKETS) {
        MaxDequeuedPackets = MAX_DEQUEUED_PACKETS;
    }

    // First update the conformance status of the flows in the lowest priority list
    CurrentLink = LowPriorityList->Flink;
    while (CurrentLink != LowPriorityList) {
        // Get the flow pointer from the linkage and set new value for CurrentLink

        Flow = CONTAINING_RECORD(CurrentLink, DSEQ_FLOW, ActiveLinks);
        CurrentLink = CurrentLink->Flink;

        // If this flow's priority is higher than the DRR priority, then
        // it is a candidate for a status change.

        if (Flow->Priority > 0) {
            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if (PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {

                // Move flow to higher priority list

                Flow->DeficitCounter = Flow->Quantum;
                RemoveEntryList(&Flow->ActiveLinks);
                InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
            }
        }
    }

    // Now select the next packet(s) to send
        
    for (PriorityGroup = PRIORITY_GROUPS - 1;
         ((PriorityGroup > 0) && (Pipe->ActiveFlowCount[PriorityGroup] == 0));
         PriorityGroup--) ;

    Priority = Pipe->StartPriority[PriorityGroup] + Pipe->PriorityLevels[PriorityGroup] - 1;

    while ((PacketSendCount < MaxDequeuedPackets) &&
           (Pipe->TotalActiveFlows > 0) &&
           Priority < INTERNAL_PRIORITIES) {

        if (!IsListEmpty(&Pipe->ActiveFlows[Priority])) {

            // Get first flow in the current list, and get a pointer to the info
            // about the first packet

            CurrentLink = Pipe->ActiveFlows[Priority].Flink;
            Flow = CONTAINING_RECORD(CurrentLink, DSEQ_FLOW, ActiveLinks);
            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if (Pipe->PsFlags & PS_DISABLE_DRR) {

                // DRR is disabled.  Remove the first packet from the queue
                // and send it.

                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Flow->LastConformanceTime.QuadPart = PacketInfo->ConformanceTime.QuadPart;

                if (Priority > 0) {
                    AdjustLastPacketTime(Flow, CurrentTime, Pipe->TimerResolution);
                } else {
                    Flow->PacketSendTime = CurrentTime;
                }

                InterlockedIncrement( &Pipe->OutstandingSends );

                if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
                    Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
                }

                if(gEnableAvgStats)
                {
                    //
                    // Track max packets outstanding. This is a measure
                    // of how congested the media gets. Of course, it
                    // will be clipped by the MaxOutstandingSends parameter.
                    // So - for a valid reading, need to set MOS very large.
                    //

                    Pipe->Stats.AveragePacketsInNetcard =
                        RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                                       Pipe->OutstandingSends);
                }
                
                SendingPriority[PacketSendCount] = Priority;
                PacketsToSend[PacketSendCount++] = PacketInfo;

                // For logging purposes...

                PacketInfo->ConformanceTime = Flow->PacketSendTime;

                // If the flow has no more packets to send, remove it from the list.
                // Otherwise move it to the end of the appropriate list, depending on
                // the conformance time of the next packet.

                RemoveEntryList(&Flow->ActiveLinks);

                if (IsListEmpty(&Flow->PacketQueue)) {
                    Pipe->TotalActiveFlows--;
                    Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
                }
                else {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->PacketSendTime.QuadPart += 
                        (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);
                    if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
                        InsertTailList(LowPriorityList, &Flow->ActiveLinks);
                    } else {
                        InsertTailList(&Pipe->ActiveFlows[Priority], &Flow->ActiveLinks);
                    }
                }
            }
            else if (PacketInfo->PacketLength <= Flow->DeficitCounter) {

                // DRR is being used and the flow has a large enough deficit counter
                // to send the packet.  Remove the packet from the queue and send it.

                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Flow->LastConformanceTime.QuadPart = PacketInfo->ConformanceTime.QuadPart;

                if (Priority > 0) {
                    AdjustLastPacketTime(Flow, CurrentTime, Pipe->TimerResolution);
                } else {
                    Flow->PacketSendTime = CurrentTime;
                }
                Flow->DeficitCounter -= PacketInfo->PacketLength;
                InterlockedIncrement( &Pipe->OutstandingSends );

                if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
                    Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
                }


                if(gEnableAvgStats)
                {
                    
                    //
                    // Track max packets outstanding. This is a measure
                    // of how congested the media gets. Of course, it
                    // will be clipped by the MaxOutstandingSends parameter.
                    // So - for a valid reading, need to set MOS very large.
                    //
                    Pipe->Stats.AveragePacketsInNetcard =
                        RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                                       Pipe->OutstandingSends);
                }

                SendingPriority[PacketSendCount] = Priority;
                PacketsToSend[PacketSendCount++] = PacketInfo;

                // For logging purposes...

                PacketInfo->ConformanceTime = Flow->PacketSendTime;

                // If the flow has no more packets to send, remove it from the list.
                // If the flow still has conforming packets to send, leave it at the head
                // of the list.  If the flow has non-conforming packets to send, move it
                // to the lowest priority list.  If we are servicing the zero priority
                // level, then no conformance checking is necessary.

                if (IsListEmpty(&Flow->PacketQueue)) {
                    RemoveEntryList(&Flow->ActiveLinks);
                    Pipe->TotalActiveFlows--;
                    Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
                }
                else {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->PacketSendTime.QuadPart += 
                        (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);
                    if ((Priority > 0) &&
                        !PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {

                        Flow->DeficitCounter = Flow->Quantum;
                        RemoveEntryList(&Flow->ActiveLinks);
                        InsertTailList(LowPriorityList, &Flow->ActiveLinks);
                    }
                }
            }
            else {

                // The packet cannot be sent because the flow's deficit counter
                // is too small.  Place the flow at the end of the same priority
                // queue and increment the flow's deficit counter by its quantum.

                Flow->DeficitCounter += Flow->Quantum;
                RemoveEntryList(&Flow->ActiveLinks);
                InsertTailList(&Pipe->ActiveFlows[Priority], &Flow->ActiveLinks);
            }
        }
        else {
            Priority--;
        }
    }

    //
    // We're gonna send these now, which means they're leaving the
    // sequencer. Update the stats.
    //

    Pipe->PacketsInSequencer -= PacketSendCount;
    Flow->PacketsInSequencer -= PacketSendCount;

    if(gEnableAvgStats)
    {
        Flow->Stats.AveragePacketsInSequencer =
                    RunningAverage(Flow->PacketsInSeqAveragingArray, 
                                               Flow->PacketsInSequencer);
    }

    // Send the next group of packets

    UNLOCK_PIPE(Pipe);
    if (PacketSendCount == 0) {
        PsDbgOut(DBG_CRITICAL_ERROR, DBG_SCHED_DRR, ("PSCHED: No packets selected\n"));
    }
    for (i = 0; i < PacketSendCount; i++) {
        PacketInfo = PacketsToSend[i];
        Flow = (PDSEQ_FLOW)PacketInfo->FlowContext;

        Packet = PacketInfo->NdisPacket;

        //
        // The 802.1 priority is already set by the wrapper. But, if the packet
        // is non-conforming, then we want to reset it. We also want to clear
        // the IP Precedence Bits.
        //
        if ((SendingPriority[i] == 0)) {

            //
            // Non conforming packet!
            //
            NDIS_PACKET_8021Q_INFO    VlanPriInfo;

            VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo);
            VlanPriInfo.TagHeader.UserPriority = PacketInfo->UserPriorityNonConforming;
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) = VlanPriInfo.Value;

            Flow->Stats.NonconformingPacketsTransmitted ++;
            Pipe->Stats.NonconformingPacketsTransmitted ++;

            //
            // Reset the TOS byte for IP Packets.
            //
            if(NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP) {

                if(!PacketInfo->IPHdr) {

                    PacketInfo->IPHdr = GetIpHeader(PacketInfo->IPHeaderOffset, Packet);
                }
                    
                SET_TOS_XSUM(Packet, 
                             PacketInfo->IPHdr, 
                             PacketInfo->TOSNonConforming);
            }
        }

        PsDbgSched(DBG_INFO, DBG_SCHED_DRR,
                   DRR_SEQUENCER, PKT_DEQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, SendingPriority[i],
                   CurrentTime.QuadPart,
                   PacketInfo->ConformanceTime.QuadPart,
                   Pipe->PacketsInSequencer,
                   0);


        if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                (PacketInfo->ClassMapContext != NULL) ?
                  ((PPS_CLASS_MAP_CONTEXT)PacketInfo->ClassMapContext)->NextComponentContext : NULL,
                PacketInfo)) {

            (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet, NDIS_STATUS_FAILURE);

        }
    }
    
    LOCK_PIPE(Pipe);

    Pipe->Flags &= ~DSEQ_DEQUEUE;

    //  Re-enable the APCs again.
    KeLeaveCriticalRegion();

} // DequeuePackets



NDIS_STATUS
DrrSeqInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for the DRR sequencer.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    HANDLE NdisHandle;
    ULONG i;
    ULONG PriorityLevel = 0;
    PS_UPCALLS DrrSeqUpcalls;
    NDIS_STATUS Status;

    NdisAllocateSpinLock(&Pipe->Lock);
    Pipe->Flags = 0;

    //
    // Relative Priorities allow us to further subdivide each priority group
    // into sub priorities. This does not exist for NonConforming, BestEffort,
    // and Qualitative.
    //

    Pipe->PriorityLevels[PRIORITY_GROUP_NON_CONFORMING]    = 1;
    Pipe->PriorityLevels[PRIORITY_GROUP_BEST_EFFORT]       = 1;
    Pipe->PriorityLevels[PRIORITY_GROUP_CONTROLLED_LOAD]   = RELATIVE_PRIORITIES;
    Pipe->PriorityLevels[PRIORITY_GROUP_GUARANTEED]        = RELATIVE_PRIORITIES;
    Pipe->PriorityLevels[PRIORITY_GROUP_NETWORK_CONTROL]   = RELATIVE_PRIORITIES;

    InitializeListHead(&Pipe->Flows);
    for (i = 0; i < INTERNAL_PRIORITIES; i++) {
        InitializeListHead(&Pipe->ActiveFlows[i]);
    }
    for (i = 0; i < PRIORITY_GROUPS; i++) {
        Pipe->ActiveFlowCount[i] = 0;
        Pipe->StartPriority[i] = PriorityLevel;
        PriorityLevel += Pipe->PriorityLevels[i];
    }

    Pipe->TotalActiveFlows = 0;
    Pipe->OutstandingSends = 0;
    NdisZeroMemory(&Pipe->Stats, sizeof(PS_DRRSEQ_STATS));
    Pipe->PacketsInSequencer = 0;
    Pipe->PacketsInSequencerAveragingArray = NULL;
    Pipe->PacketsInNetcardAveragingArray = NULL;
    
    Status = CreateAveragingArray(&Pipe->PacketsInSequencerAveragingArray,
                                  SEQUENCER_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

    Status = CreateAveragingArray(&Pipe->PacketsInNetcardAveragingArray,
                                  NETCARD_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);

        return(Status);
    }

    Pipe->MinimumQuantum = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    if (Pipe->MinimumQuantum == 0) {
        Pipe->MinimumQuantum = DEFAULT_MIN_QUANTUM;
    }
    Pipe->Bandwidth = PipeParameters->Bandwidth;

    // This will be set to something more realistic when the first flow is created.

    Pipe->MinimumRate = (PipeParameters->Bandwidth > 0) ? PipeParameters->Bandwidth : QOS_NOT_SPECIFIED;
    PsAssert(Pipe->MinimumRate != 0);
    Pipe->PsFlags = PipeParameters->Flags;
    Pipe->IsslowFlowCount = 0;
    Pipe->ConfiguredMaxOutstandingSends = Pipe->MaxOutstandingSends = PipeParameters->MaxOutstandingSends;

    //  Change the MOS if necessary..
    if( ( PipeParameters->MediaType == NdisMediumWan)   &&
        ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) )
    {
        Pipe->MaxOutstandingSends = 1;
    }

    (*PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;
    Pipe->PsPipeContext = PsPipeContext;
    Pipe->PsProcs = PsProcs;

    if(Upcalls)
    {
        Pipe->PreviousUpcallsSendComplete = Upcalls->SendComplete;
        Pipe->PreviousUpcallsSendCompletePipeContext = Upcalls->PipeContext;
    }
    else
    {
        Pipe->PreviousUpcallsSendComplete = 0;
        Pipe->PreviousUpcallsSendCompletePipeContext = 0;
    }

    DrrSeqUpcalls.SendComplete = DrrSeqSendComplete;
    DrrSeqUpcalls.PipeContext = ComponentPipeContext;

    /* This put the DrrSeq in the pass-thru mode when the MaxOutStandingSends ==  MAX */
    if( Pipe->MaxOutstandingSends   == 0xffffffff )
        Pipe->Flags |=  DSEQ_PASSTHRU;
    else
        Pipe->Flags &=  ~ DSEQ_PASSTHRU;

    PsDbgOut(DBG_INFO, 
             DBG_SCHED_DRR, 
             ("PSCHED: DrrSeq pipe initialized at %x.\n", 
             &Pipe));

    
    Status = (*Pipe->ContextInfo.NextComponent->InitializePipe)(
                PsPipeContext,
                PipeParameters,
                Pipe->ContextInfo.NextComponentContext,
                PsProcs,
                &DrrSeqUpcalls);
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        NdisFreeSpinLock(&Pipe->Lock);
        DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);
        DeleteAveragingArray(Pipe->PacketsInNetcardAveragingArray);
    }

    return Status;
    
} // DrrSeqInitializePipe


// 
//  Unload routine: currently do nothing
//
void
UnloadSequencer()
{

}



NDIS_STATUS
DrrSeqModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    ULONG MinQuantum = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    BOOLEAN AdjustQuanta = FALSE;
    ULONG MinRate = Pipe->MinimumRate;

    LOCK_PIPE(Pipe);

    (*Pipe->PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;

    if ((MinQuantum > 0) && (MinQuantum != Pipe->MinimumQuantum)) {
        Pipe->MinimumQuantum = MinQuantum;
        AdjustQuanta = TRUE;
    }
    
    Pipe->Bandwidth = PipeParameters->Bandwidth;
    Pipe->ConfiguredMaxOutstandingSends = Pipe->MaxOutstandingSends = PipeParameters->MaxOutstandingSends;

    //  Change the MOS if necessary..
    if( ( PipeParameters->MediaType == NdisMediumWan)   &&
        ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) )
    {
        Pipe->MaxOutstandingSends = 1;
    }

    //  This put the DrrSeq in the pass-thru mode when the MaxOutStandingSends ==  MAX 
    if( Pipe->MaxOutstandingSends   == 0xffffffff )
    {
        // Make sure not to do this. It could lead to packets queued up in the sequencer being never sent
        // [ Pipe->Flags |=  DSEQ_PASSTHRU; ] 
    }        
    else
    {
        Pipe->Flags &=  ~ DSEQ_PASSTHRU;
    }        
    
    if (Pipe->MinimumRate > Pipe->Bandwidth) {
        MinRate = QOS_NOT_SPECIFIED;
        AdjustQuanta = TRUE;
    }

    if (AdjustQuanta) {
        AdjustFlowQuanta(Pipe, MinRate);
    }
    UNLOCK_PIPE(Pipe);

    return (*PipeContext->NextComponent->ModifyPipe)(
                PipeContext->NextComponentContext,
                PipeParameters);

} // DrrSeqModifyPipe



VOID
DrrSeqDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;

    DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);
    DeleteAveragingArray(Pipe->PacketsInNetcardAveragingArray);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq pipe deleted\n"));

    PsAssert(Pipe->OutstandingSends == 0);
    NdisFreeSpinLock(&Pipe->Lock);

    (*Pipe->ContextInfo.NextComponent->DeletePipe)(Pipe->ContextInfo.NextComponentContext);

} // DrrSeqDeletePipe



NDIS_STATUS
DrrSeqCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for the DRR sequencer.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;
    SERVICETYPE ServiceType;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    ULONG UserPriority;
    ULONG i;
    NDIS_STATUS Status;

    ServiceType = CallParameters->CallMgrParameters->Transmit.ServiceType;
    if ((ServiceType < SERVICETYPE_BESTEFFORT) || (ServiceType > SERVICETYPE_QUALITATIVE)) {
        return NDIS_STATUS_FAILURE;
    }
    Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
    Flow->BucketSize = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    InitializeListHead(&Flow->PacketQueue);
    PsGetCurrentTime(&Flow->PacketSendTime);
    Flow->LastConformanceTime = Flow->PacketSendTime;
    Flow->PsFlowContext = PsFlowContext;
    Flow->State = DRRSEQ_FLOW_CREATED;

    // Set the flow's priority group based on service type.

    switch (ServiceType) {
        case SERVICETYPE_CONTROLLEDLOAD:
            Flow->PriorityGroup = PRIORITY_GROUP_CONTROLLED_LOAD;
            break;
        case SERVICETYPE_GUARANTEED:
            Flow->PriorityGroup = PRIORITY_GROUP_GUARANTEED;
            break;
        case SERVICETYPE_NETWORK_CONTROL:
            Flow->PriorityGroup = PRIORITY_GROUP_NETWORK_CONTROL;
            break;
        case SERVICETYPE_QUALITATIVE:
        default:
            Flow->PriorityGroup = PRIORITY_GROUP_BEST_EFFORT;
    }

    Flow->Flags = 0;

    // Save the flow in a list so that quantum values can be adjusted if
    // a new flow is added with a smaller rate than the existing flows.

    LOCK_PIPE(Pipe);

    InsertTailList(&Pipe->Flows, &Flow->Links);

    // If this flow's rate is smaller than the rate assigned to any existing
    // flow, adjust the other flow's quantum values accordingly.

    if (ServiceType == SERVICETYPE_BESTEFFORT || ServiceType == SERVICETYPE_NETWORK_CONTROL ||
        ServiceType == SERVICETYPE_QUALITATIVE) {
        Flow->Quantum = Pipe->MinimumQuantum;
    }
    else if (Flow->TokenRate < Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, Flow->TokenRate);
    }
    else {
        Flow->Quantum = (ULONG)( (ULONGLONG)(Flow->TokenRate) * (ULONGLONG)(Pipe->MinimumQuantum) / Pipe->MinimumRate );
        PsAssert((LONG)Flow->Quantum > 0);
    }
    Flow->DeficitCounter = 0;

    //  If this is a RAS-ISSLOW flow, need to set the MOS back to whatever requested by the user..
    if( ((PGPC_CLIENT_VC)(PsFlowContext))->Flags & GPC_ISSLOW_FLOW)
    {
        Pipe->MaxOutstandingSends = Pipe->ConfiguredMaxOutstandingSends;
        Pipe->IsslowFlowCount++;
        Flow->Flags |= GPC_ISSLOW_FLOW;
    }

    
    UNLOCK_PIPE(Pipe);

    // Now set default values for UserPriority 

    UserPriority = (Pipe->PriorityLevels[Flow->PriorityGroup] - 1) / 2;

    // Look for the priority object and traffic class in the call manager specific parameters

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_PRIORITY) {
                UserPriority = ((LPQOS_PRIORITY)QoSObject)->SendPriority;
                Flow->Flags |= FLOW_USER_PRIORITY;
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    Flow->UserPriority = UserPriority;
    if (UserPriority < Pipe->PriorityLevels[Flow->PriorityGroup]) {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] + UserPriority;
    }
    else {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] +
                         Pipe->PriorityLevels[Flow->PriorityGroup] - 1;
    }

    Flow->PacketsInSequencer = 0;
    NdisZeroMemory(&Flow->Stats, sizeof(PS_DRRSEQ_STATS));

    Status = CreateAveragingArray(&Flow->PacketsInSeqAveragingArray,
                                  SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS){
        LOCK_PIPE(Pipe);
        RemoveEntryList(&Flow->Links);
        if(Flow->TokenRate == Pipe->MinimumRate) {
            AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
        }

        UNLOCK_PIPE(Pipe);
        return(Status);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, 
            ("PSCHED: DrrSeq flow created. Quantum = %u, Priority = %u\n", Flow->Quantum, Flow->Priority));


    Status =  (*Pipe->ContextInfo.NextComponent->CreateFlow)(
                Pipe->ContextInfo.NextComponentContext,
                PsFlowContext,
                CallParameters,
                Flow->ContextInfo.NextComponentContext);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        DeleteAveragingArray(Flow->PacketsInSeqAveragingArray);
        LOCK_PIPE(Pipe);
        RemoveEntryList(&Flow->Links);
        if(Flow->TokenRate == Pipe->MinimumRate) {
            AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
        }

        UNLOCK_PIPE(Pipe);
    }

    return Status;

} // DrrSeqCreateFlow



NDIS_STATUS
DrrSeqModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    SERVICETYPE ServiceType;
    ULONG TokenRate;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_PRIORITY PriorityObject = NULL;
    ULONG i;
    ULONG OldPriorityGroup;
    ULONG OldRate;
    ULONG OldPriority;
    PPACKET_INFO_BLOCK PacketInfo;
    LARGE_INTEGER CurrentTime;

    ServiceType = CallParameters->CallMgrParameters->Transmit.ServiceType;
    if ((ServiceType != SERVICETYPE_NOCHANGE) && 
        ((ServiceType < SERVICETYPE_BESTEFFORT) || (ServiceType > SERVICETYPE_QUALITATIVE))) {
            return NDIS_STATUS_FAILURE;
    }

    // Look for the priority and traffic class objects in the call manager
    // specific parameters, and save the pointers if found.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_PRIORITY) {
                PriorityObject = (LPQOS_PRIORITY)QoSObject;
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    LOCK_PIPE(Pipe);

    OldPriorityGroup = Flow->PriorityGroup;
    OldPriority = Flow->Priority;

    if (ServiceType != SERVICETYPE_NOCHANGE) 
    {
        // Set the flow's priority group based on service type.

        switch (ServiceType) {
            case SERVICETYPE_CONTROLLEDLOAD:
                Flow->PriorityGroup = PRIORITY_GROUP_CONTROLLED_LOAD;
                break;
            case SERVICETYPE_GUARANTEED:
                Flow->PriorityGroup = PRIORITY_GROUP_GUARANTEED;
                break;
            case SERVICETYPE_NETWORK_CONTROL:
                Flow->PriorityGroup = PRIORITY_GROUP_NETWORK_CONTROL;
                break;
            case SERVICETYPE_QUALITATIVE:
            default:
                Flow->PriorityGroup = PRIORITY_GROUP_BEST_EFFORT;
        }

        TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;

        OldRate = Flow->TokenRate;
        if ((TokenRate != OldRate) || (OldPriorityGroup != Flow->PriorityGroup)) {

            // If this flow's rate is smaller than the rate assigned to any existing
            // flow, adjust the other flows' quantum values accordingly.  If this flow's
            // old rate was equal to the minimum rate, then locate the new minimum rate and
            // adjust the other flows' quantum values accordingly.

            Flow->TokenRate = TokenRate;
            if ((OldRate == Pipe->MinimumRate) && (OldPriorityGroup > PRIORITY_GROUP_BEST_EFFORT) &&
                (OldPriorityGroup != PRIORITY_GROUP_NETWORK_CONTROL)) {
                AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
            }
            else if (Flow->PriorityGroup <= PRIORITY_GROUP_BEST_EFFORT || Flow->PriorityGroup == PRIORITY_GROUP_NETWORK_CONTROL) {
                Flow->Quantum = Pipe->MinimumQuantum;
            }
            else if (TokenRate < Pipe->MinimumRate) {
                AdjustFlowQuanta(Pipe, TokenRate);
            }
            else {
                PsAssert(Pipe->MinimumRate != 0);
                Flow->Quantum = (ULONG)((ULONGLONG)(TokenRate * Pipe->MinimumQuantum) / Pipe->MinimumRate);
                PsAssert((LONG)Flow->Quantum > 0);
            }

        }

        Flow->BucketSize = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    }

    // Now set the new values for UserPriority and Priority

    if (PriorityObject != NULL) {
        Flow->UserPriority = PriorityObject->SendPriority;
        Flow->Flags |= FLOW_USER_PRIORITY;
    }
    else if ((Flow->Flags & FLOW_USER_PRIORITY) == 0) {
        Flow->UserPriority = (Pipe->PriorityLevels[Flow->PriorityGroup] - 1) / 2;
    }

    if (Flow->UserPriority < Pipe->PriorityLevels[Flow->PriorityGroup]) {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] + Flow->UserPriority;
    }
    else {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] +
                         Pipe->PriorityLevels[Flow->PriorityGroup] - 1;
    }

    // Move the flow to the proper priority list if necessary

    if ((Flow->Priority != OldPriority) && !IsListEmpty(&Flow->PacketQueue)) {
        Pipe->ActiveFlowCount[OldPriorityGroup]--;
        RemoveEntryList(&Flow->ActiveLinks);
        PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
        PsGetCurrentTime(&CurrentTime);
        Flow->DeficitCounter = Flow->Quantum;
        Pipe->ActiveFlowCount[Flow->PriorityGroup]++;
        if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
            InsertTailList(&Pipe->ActiveFlows[0], &Flow->ActiveLinks);
        } else {
            InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
        }
    }

    UNLOCK_PIPE(Pipe);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR,
            ("PSCHED: DrrSeq flow modified. Quantum = %u, Priority = %u\n", Flow->Quantum, Flow->Priority));


    return (*Pipe->ContextInfo.NextComponent->ModifyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                CallParameters);

} // DrrSeqModifyFlow
VOID
DrrSeqDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if( (Flow->State & DRRSEQ_FLOW_DELETED) != 0)
    {
        UNLOCK_PIPE(Pipe);
        goto DELETE_SEQ_FLOW;
    }        
        
    Flow->State = DRRSEQ_FLOW_DELETED;

    RemoveEntryList(&Flow->Links);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list

        RemoveEntryList(&Flow->ActiveLinks);
        Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
        Pipe->TotalActiveFlows--;

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
        }
    }

    if (Flow->TokenRate == Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
    }

    if( Flow->Flags & GPC_ISSLOW_FLOW)
    {
        // If this is an ISSLOW flow, we have one less now.
        Pipe->IsslowFlowCount--;

        if(Pipe->IsslowFlowCount == 0)
        {
            // If there are no more ISSLOW flows, turn DRR back on.
            Pipe->MaxOutstandingSends = 1;
        }            
    }

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext,  Packet, NDIS_STATUS_FAILURE);
    }

DELETE_SEQ_FLOW:

    DeleteAveragingArray(Flow->PacketsInSeqAveragingArray);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq flow deleted\n"));

    (*Pipe->ContextInfo.NextComponent->DeleteFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);
} 




VOID
DrrSeqEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    Flow->State = DRRSEQ_FLOW_DELETED;

    RemoveEntryList(&Flow->Links);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list

        RemoveEntryList(&Flow->ActiveLinks);
        Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
        Pipe->TotalActiveFlows--;

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
        }
    }

    if (Flow->TokenRate == Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
    }

    if( Flow->Flags & GPC_ISSLOW_FLOW)
    {
        // If this is an ISSLOW flow, we have one less now.
        Pipe->IsslowFlowCount--;

        if(Pipe->IsslowFlowCount == 0)
        {
            // If there are no more ISSLOW flows, turn DRR back on.
            Pipe->MaxOutstandingSends = 1;
        }            
    }

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext,  Packet, NDIS_STATUS_FAILURE);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq flow emptied\n"));

    (*Pipe->ContextInfo.NextComponent->EmptyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);
} 




static NDIS_STATUS 
DrrSeqCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->CreateClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}



static NDIS_STATUS 
DrrSeqDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->DeleteClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}




BOOLEAN
DrrSeqSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for the DRR sequencer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    Always returns TRUE

--*/
{
    PDSEQ_PIPE Pipe =   (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow =   (PDSEQ_FLOW)FlowContext;
    LARGE_INTEGER       CurrentTime;
    PNDIS_PACKET Packet = PacketInfo->NdisPacket;
    BOOLEAN FlowInactive;
    PGPC_CLIENT_VC      Vc = Flow->PsFlowContext;

    if(Pipe->Flags & DSEQ_PASSTHRU)
    {
        InterlockedIncrement( &Pipe->OutstandingSends );

        if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
            Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
        }


        if(gEnableAvgStats)
        {
            //
            // Track max packets outstanding. This is a measure
            // of how congested the media gets. Of course, it
            // will be clipped by the MaxOutstandingSends parameter.
            // So - for a valid reading, need to set MOS very large.
            //
            Pipe->Stats.AveragePacketsInNetcard =
                RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                               Pipe->OutstandingSends);
        }

        //
        // Note: The 802.1p is already set by the wrapper
        //

        if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                PacketInfo)) {

            (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet, NDIS_STATUS_FAILURE);

        }

        return TRUE;
    }
    

    LOCK_PIPE(Pipe);

    if (Flow->State == DRRSEQ_FLOW_DELETED) 
    {
         UNLOCK_PIPE(Pipe);
         return FALSE;
    }

    //
    // On WanLinks, when we are doing DRR, we need to put a maximum on the queue-limit.
    // NDISWAN has a queue limit of 132KBytes on a modem link; So, we'll limit it to 120
    // packets by default.
    //

    if( ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) &&
        ( Pipe->MaxOutstandingSends == 1) &&
	( Pipe->PacketsInSequencer >= 120) )
    {
	    UNLOCK_PIPE( Pipe);
	    return FALSE;
    }


    //
    //  There is one case where the PIPE might go away because the send-complete happened
    //  on a VC belonging to it before the send returned. So, to prevent that, we add a 
    //  Ref on that VC and take it out just before the send returns.
    //

    //  Add a Ref.
    InterlockedIncrement(&Vc->RefCount);

    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    Pipe->PacketsInSequencer++;

    if(Pipe->PacketsInSequencer > Pipe->Stats.MaxPacketsInSequencer){
        Pipe->Stats.MaxPacketsInSequencer = Pipe->PacketsInSequencer;
    }

    Flow->PacketsInSequencer++;
    if (Flow->PacketsInSequencer > Flow->Stats.MaxPacketsInSequencer){
        Flow->Stats.MaxPacketsInSequencer = Flow->PacketsInSequencer;
    }



    if(gEnableAvgStats)
    {
        //
        // Track packets in the sequencer at any time.
        //
        Pipe->Stats.AveragePacketsInSequencer = 
            RunningAverage(Pipe->PacketsInSequencerAveragingArray,
                               Pipe->PacketsInSequencer);

        Flow->Stats.AveragePacketsInSequencer =
            RunningAverage(Flow->PacketsInSeqAveragingArray, Flow->PacketsInSequencer);

    }

    FlowInactive = IsListEmpty(&Flow->PacketQueue);
    InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);

    PsGetCurrentTime(&CurrentTime);

    PsDbgSched(DBG_INFO,
               DBG_SCHED_DRR, 
               DRR_SEQUENCER, PKT_ENQUEUE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, Flow->Priority,
               CurrentTime.QuadPart,
               PacketInfo->ConformanceTime.QuadPart,
               Pipe->PacketsInSequencer,
               0);

    if (FlowInactive) {
        Flow->PacketSendTime.QuadPart += 
            (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);

        Flow->DeficitCounter = Flow->Quantum;
        Pipe->TotalActiveFlows++;
        Pipe->ActiveFlowCount[Flow->PriorityGroup]++;
        if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
            InsertTailList(&Pipe->ActiveFlows[0], &Flow->ActiveLinks);
        } else {
            InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
        }
    }

    while ((Pipe->TotalActiveFlows > 0) &&
           (Pipe->OutstandingSends < Pipe->MaxOutstandingSends) &&
           ((Pipe->Flags & DSEQ_DEQUEUE) == 0)) {

        DequeuePackets(Pipe);
    }

    UNLOCK_PIPE(Pipe);

    //  Take out the ref.
    DerefClVc(Vc);

    return TRUE;

} // DrrSeqSubmitPacket



VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    )

/*++

Routine Description:

    Send complete handler for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    Packet -            Packet that has completed sending

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;

    InterlockedDecrement( &Pipe->OutstandingSends);

    //  Need to do this only if the sequencer is not in the bypass mode //
    if( (Pipe->Flags & DSEQ_PASSTHRU) == 0)
    {
        LOCK_PIPE(Pipe);
        
        PsAssert((LONG)Pipe->OutstandingSends >= 0);

        while ((Pipe->TotalActiveFlows > 0) &&
               (Pipe->OutstandingSends < Pipe->MaxOutstandingSends) &&
               ((Pipe->Flags & DSEQ_DEQUEUE) == 0)) {

            DequeuePackets(Pipe);
        }

        UNLOCK_PIPE(Pipe);
    }

    //
    // Call the previous upcalls (if any)
    //
    if(Pipe->PreviousUpcallsSendComplete)
    {
        (*Pipe->PreviousUpcallsSendComplete)(Pipe->PreviousUpcallsSendCompletePipeContext, Packet);
    }

} // DrrSeqSendComplete



VOID
DrrSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:
          if(Flow) {
              NdisZeroMemory(&Flow->Stats, sizeof(PS_DRRSEQ_STATS));
          }
          else {
              NdisZeroMemory(&Pipe->Stats, sizeof(PS_DRRSEQ_STATS));
          }
          break;
      default:
          break;
    }
    
    (*Pipe->ContextInfo.NextComponent->SetInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
DrrQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;
    PS_COMPONENT_STATS Stats;
    ULONG Size;
    ULONG RemainingLength;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          Size = sizeof(PS_DRRSEQ_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);

          if(*Status == NDIS_STATUS_SUCCESS) 
          {
              //
              // The previous component has succeeded - Let us
              // see if we can write the data
              //

              RemainingLength = Len - *BytesWritten;
    
              if(RemainingLength < Size) {

                  *Status = NDIS_STATUS_BUFFER_TOO_SHORT;

                  *BytesNeeded = Size + *BytesWritten;

                  *BytesWritten = 0;

              }
              else {

                  PPS_COMPONENT_STATS Cstats = (PPS_COMPONENT_STATS) Data;

                  *BytesWritten += Size;
                  
                  *BytesNeeded = 0;

                  if(Flow) {

                      Cstats->Type = PS_COMPONENT_DRRSEQ;
                      Cstats->Length = sizeof(PS_DRRSEQ_STATS);
                      NdisMoveMemory(&Cstats->Stats, &Flow->Stats, sizeof(PS_DRRSEQ_STATS));
                  }
                  else {

                      Cstats->Type = PS_COMPONENT_DRRSEQ;
                      Cstats->Length = sizeof(PS_DRRSEQ_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->Stats, sizeof(PS_DRRSEQ_STATS));

                  }

                  //
                  // Advance Data so that the next component can update its stats
                  //
                  Data = (PVOID) ((PUCHAR)Data + Size);
              }
          }
          else {

              *BytesNeeded += Size;
              
              *BytesWritten = 0;
          }

          break;
          
      default:

          break;
    }

    
    (*Pipe->ContextInfo.NextComponent->QueryInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext : 0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\gpchndlr.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    GpcHndlr.c

Abstract:

    Handlers called by GPC.  

Author:

    Rajesh Sundaram (rajeshsu) 

Environment:

    Kernel Mode

Revision History:

    One of the initial designs (yoramb/charliew/rajeshsu) consisted of an
    integrated call manager with a seperate packet classifying client. The 
    design used NDIS 5.0 VCs so that they could be managed by WMI.

    The main limitation of the above approach was the fact that NDIS provided 
    mechanisms to manage miniport and VCs - We really needed a way to 
    manage other things (like WanLinks, etc).

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */


BOOLEAN
ValidateCfInfo(ULONG CfInfoSize, PCF_INFO_QOS CfInfo)
{
    //
    // Verify that the TcObjectsLength is consistent with the CfInfoSize. The
    // CfInfoSize must have been verified during the user/kernel transition. 
    // The TcObjectsLength has not. We could bugcheck if we try to search
    // beyond the buffer passed in.
    //

    if ((CfInfoSize < (FIELD_OFFSET(CF_INFO_QOS, GenFlow) +
                       FIELD_OFFSET(TC_GEN_FLOW, TcObjects) +
                       CfInfo->GenFlow.TcObjectsLength)) ||
        (CfInfo->GenFlow.TcObjectsLength > 0x00FFFFFF))        
    {

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[ValidateCfInfo]: TcObjectsLength inconsistent with "
                 "CfInfoSize \n"));

        return(FALSE);
    } else {
        return TRUE;
    }
}


GPC_STATUS
QosAddCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_HANDLE              GpcCfInfoHandle,
        IN      PTC_INTERFACE_ID        InterfaceInfo,
        IN      ULONG                   CfInfoSize,
        IN      PVOID                   CfInfoPtr,
        IN      PGPC_CLIENT_HANDLE      ClientCfInfoContext
        )

/*++

Routine Description:

    A new CF_INFO has been added to the GPC database.

Arguments:

    ClientContext       -   Client context supplied to GpcRegisterClient
    GpcCfInfoHandle     -   GPC's handle to CF_INFO
    CfInfoPtr           -   Pointer to the CF_INFO structure
    ClientCfInfoContext -   Location in which to return PS's context for CF_INFO

Return Value:

    Status

--*/

{
    PADAPTER                    Adapter;
    PGPC_CLIENT_VC              Vc;
    PCF_INFO_QOS                CfInfo;
    NDIS_STATUS                 Status;
    ULONG                       CallParamsLength;
    PCO_CALL_PARAMETERS         CallParams = 0;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS        PsMediaParameters;
    LPQOS_PRIORITY              PriorityObject;
    PPS_WAN_LINK                WanLink = NULL;
    ULONG                       TcObjAlignedLength;


    CfInfo = (PCF_INFO_QOS)CfInfoPtr;

    if (!ValidateCfInfo(CfInfoSize, CfInfo)) {
        return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;
    }


    //
    // Let's try to find the Adapter/Wanlink using the Interface/Link Id.
    //
    if(InterfaceInfo) {
        Adapter = FindAdapterById(InterfaceInfo->InterfaceId, InterfaceInfo->LinkId, &WanLink);
    } else {
        //
        // Using the instance name, we find the adapter or the wanlink. If the adapter or wanlink is not
        // ready to accept VCs, this function will return NULL. Also, if it is ready, it will take a ref 
        // on the Adapter and the WanLink.
        //
        Adapter = FindAdapterByWmiInstanceName((USHORT) CfInfo->InstanceNameLength,
                                               (PWSTR) &CfInfo->InstanceName[0],
                                               &WanLink);
    }

    if(NULL == Adapter) 
    {
        PsAssert(WanLink == NULL);

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
               ("[QosAddCfInfoNotify]: no adapter with instance name %ws\n", 
                CfInfo->InstanceName));

        return GPC_STATUS_IGNORED;
    }

    if (InterfaceInfo)
    {
        PNDIS_STRING FlowName;
        USHORT BytesToCopy;

        if (WanLink != NULL)
        {
            FlowName = &WanLink->InstanceName;
        } else {
            FlowName = &Adapter->WMIInstanceName;
        }

        BytesToCopy = (FlowName->Length > ((MAX_INSTANCE_NAME_LENGTH-1) * sizeof(WCHAR))) ?
                      ((MAX_INSTANCE_NAME_LENGTH-1) * sizeof(WCHAR)) :
                      FlowName->Length;

        memcpy(&CfInfo->InstanceName, FlowName->Buffer, BytesToCopy);
        CfInfo->InstanceNameLength = BytesToCopy;
        CfInfo->InstanceName[BytesToCopy / 2] = L'\0';
    }

    //
    // We have taken a ref on the adapter or wanlink. so we need to deref if we bail out with error. If 
    // we create the VC, then the adapter and wanlink are deref'd when the VC is deleted.
    //

    do
    {

       //
       // Allocate the resources for the call manager parameters.
       //
       TcObjAlignedLength = ((CfInfo->GenFlow.TcObjectsLength + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
       
       CallParamsLength = 
          sizeof(CO_CALL_PARAMETERS) +
          FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
          FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
          TcObjAlignedLength +
          FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
          FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

       if(Adapter->MediaType == NdisMediumWan) 
       {
          CallParamsLength += sizeof(QOS_WAN_MEDIA);
       }
       else 
       {
          if(!Adapter->PipeHasResources)
          {
             //
             // We don't want to pend GPC client VCs. The reasons are:
             //
             // a. If the cable is never plugged in, we could pend VCs indefinitely.
             //    Waste of system resources.
             //
             // b. There is no clean way for the app to cancel these pended VCs. Since
             //    we have pended the AddCfInfo to the GPC, the GPC cannot call back
             //    and ask us to delete the VC.
             //
             // But, we still need to handle the case where link speed change 
             // might be transient (10/100 case). Also, if we return error, the app
             // might retry causing busy cycles if the media is never connected. 
             // For all this, the app can register for WMI notifications for GUIDs
             // GUID_NDIS_STATUS_MEDIA_(DIS)CONNECT
             //
             //
             // Also, we probably don't want to do this for the b/e VC. Otherwise,
             // how does it work when the user installs psched and the media is 
             // unconnected ? Do we want him to reinstall psched after connecting 
             // the media ? 
             //
             
             PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                      ("[QosAddCfInfoNotify]: Adapter %08X is not plugged in \n", Adapter));
             
             Status = NDIS_STATUS_NETWORK_UNREACHABLE;
   
             break;
          }
       }

       PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

       if(CallParams == NULL) {
          
          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                   ("[QosAddCfInfoNotify]: Adapter %08X, can't allocate call"
                    "params \n", Adapter));
          
          Status =  GPC_STATUS_RESOURCES;

          break;
       }

       Status = CmCreateVc(&Vc, Adapter, WanLink, CallParams, GpcCfInfoHandle, CfInfo, 
                           ClientContext);
    
       if(!NT_SUCCESS(Status)) {
          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS, 
                   ("[QosAddCfInfoNotify]: Adapter %08X, Could not create Vc \n",
                    Adapter));
       
          break;
       }
    
       *ClientCfInfoContext = Vc;

    } while(FALSE);
    

    if(!NT_SUCCESS(Status))
    {
       if(CallParams)
       {
          PsFreePool(CallParams);
       }

       if(WanLink)
       {
          REFDEL(&WanLink->RefCount, FALSE, 'WANV');
       }

       REFDEL(&Adapter->RefCount, FALSE, 'ADVC');

       return Status;

    }

    //
    // Create a call parameters struct for the MakeCall
    //

    CallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);
    CallMgrParams->Transmit = CfInfo->GenFlow.SendingFlowspec;
    CallMgrParams->Receive = CfInfo->GenFlow.ReceivingFlowspec;
    CallMgrParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CallMgrParams->CallMgrSpecific.Length = CfInfo->GenFlow.TcObjectsLength;

    if(CfInfo->GenFlow.TcObjectsLength > 0){

        NdisMoveMemory(
            &CallMgrParams->CallMgrSpecific.Parameters,
            &CfInfo->GenFlow.TcObjects,
            CfInfo->GenFlow.TcObjectsLength);
    }

    PsMediaParameters = 
            (PCO_MEDIA_PARAMETERS)((PUCHAR)CallMgrParams + 
                FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                TcObjAlignedLength);

    PsMediaParameters->Flags = 0;
    PsMediaParameters->ReceivePriority = 0;
    PsMediaParameters->ReceiveSizeHint = CfInfo->GenFlow.SendingFlowspec.MaxSduSize;
    PsMediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    PsMediaParameters->MediaSpecific.Length = 0;

    //
    // If this flow is being installed on a Wan interface, need to
    // insert the linkId into the media specific fields. This is so that
    // NdisWan will be able to recognize the link over which to install
    // the flow.
    //

    if(WanLink){

        LPQOS_WAN_MEDIA WanMedia;
        PsMediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) PsMediaParameters->MediaSpecific.Parameters;

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       WanLink->OriginalRemoteMacAddress,
                       6);
    }

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParams;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)PsMediaParameters;

    Status = CmMakeCall(Vc);

    if(NDIS_STATUS_PENDING != Status) 
    {
        CmMakeCallComplete(Status, Vc, Vc->CallParameters);
    }

    PsDbgOut(DBG_TRACE,
             DBG_GPC_QOS,
             ("[QosAddCfInfoNotify]: Adapter %08X, Created Vc %08X - returned "
              " PENDING \n", Adapter, Vc));


    return GPC_STATUS_PENDING;
}


VOID
SetTOSIEEEValues(PGPC_CLIENT_VC Vc)
{
    ULONG                ServiceType = Vc->CallParameters->CallMgrParameters->Transmit.ServiceType;
    LPQOS_OBJECT_HDR     QoSObject;
    LONG                 ParamsLength;
    LPQOS_TRAFFIC_CLASS  Tc;
    LPQOS_DS_CLASS       Ds;
    PCF_INFO_QOS         CfInfo = (PCF_INFO_QOS) Vc->CfInfoQoS;

    //
    // Set these based on the ServiceType
    //
    switch(ServiceType)
    {
      case SERVICETYPE_CONTROLLEDLOAD:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeControlledLoad;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeControlledLoad;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeControlledLoadNC;
          break;
      case SERVICETYPE_GUARANTEED:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeGuaranteed;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeGuaranteedNC;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeGuaranteed;
          break;
      case SERVICETYPE_BESTEFFORT:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeBestEffort;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeBestEffort;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeBestEffortNC;
          break;
      case SERVICETYPE_QUALITATIVE:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeQualitative;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeQualitative;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeQualitativeNC;
          break;
      case SERVICETYPE_NETWORK_CONTROL:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeNetworkControl;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeNetworkControl;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeNetworkControlNC;
          break;
    }
    Vc->UserPriorityNonConforming = Vc->Adapter->UserServiceTypeNonConforming;

    //
    // Walk the QoS objects to see if there is a TCLASS or a DCLASS
    //
    ParamsLength = (LONG)Vc->CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    QoSObject    = (LPQOS_OBJECT_HDR)Vc->CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

    while(ParamsLength > 0) {

        switch(QoSObject->ObjectType)
        {
             case QOS_OBJECT_TCP_TRAFFIC:

                //
                // This QoS object asks us to override the ServiceType, the TCLASS and the DCLASS markings.
                // so, if we fidn this QoS object, we set the values, and return.
                //

                Vc->UserPriorityConforming    = (UCHAR) Vc->Adapter->UserServiceTypeTcpTraffic;
                CfInfo->ToSValue              = (UCHAR) Vc->Adapter->IPServiceTypeTcpTraffic;
                Vc->IPPrecedenceNonConforming = (UCHAR) Vc->Adapter->IPServiceTypeTcpTrafficNC;
                return;

             case QOS_OBJECT_TRAFFIC_CLASS:
        
                Tc = (LPQOS_TRAFFIC_CLASS)QoSObject;
                Vc->UserPriorityConforming = (UCHAR) Tc->TrafficClass;
                break;

             case QOS_OBJECT_DS_CLASS:
                Ds = (LPQOS_DS_CLASS)QoSObject;
                CfInfo->ToSValue = (UCHAR)(Ds->DSField << 2);
                break;
        }

        ParamsLength -= QoSObject->ObjectLength;

        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject +
                                   QoSObject->ObjectLength);
    }

    CfInfo->AllowedOffloads = PERMITTED_TCP_IP_OFFLOAD_TYPES;

    return;

}

VOID
CmMakeCallComplete(NDIS_STATUS Status, PGPC_CLIENT_VC Vc,
                   PCO_CALL_PARAMETERS CallParameters)
{
    PADAPTER     Adapter = Vc->Adapter;
    GPC_HANDLE   CfInfo  = Vc->CfInfoHandle;
    PPS_WAN_LINK WanLink = Vc->WanLink;
    ULONG        CurrentFlows;
    LARGE_INTEGER Increment;
    LARGE_INTEGER VcIndex;

    PsAssert(!IsBestEffortVc(Vc));
    
    Increment.QuadPart = 1;

    if(NT_SUCCESS(Status)) 
    {

        // 
        // Create an Instance name for this VC and register with WMI. 
        //
        VcIndex = ExInterlockedAddLargeInteger(&Adapter->VcIndex, Increment, &Adapter->Lock.Lock.SpinLock);

        Status = GenerateInstanceName(&VcPrefix, Vc->Adapter, &VcIndex, &Vc->InstanceName);

        //
        // Transistion from CL_CALL_PENDING to CL_INTERNAL_CALL_COMPLETE
        //

        CallSucceededStateTransition(Vc);


        PS_LOCK(&Vc->Lock);

        SetTOSIEEEValues(Vc);

        PS_UNLOCK(&Vc->Lock);

        if(Adapter->MediaType == NdisMediumWan) {


            //
            // This variable is used to optimize the send path
            //
            InterlockedIncrement(&WanLink->CfInfosInstalled);

            if((Vc->Flags & GPC_ISSLOW_FLOW)) { 

                //
                // Tell NDISWAN about the fragment size
                //
                MakeLocalNdisRequest(Adapter, 
                                     Vc->NdisWanVcHandle,
                                     NdisRequestLocalSetInfo,
                                     OID_QOS_ISSLOW_FRAGMENT_SIZE, 
                                     &Vc->ISSLOWFragmentSize, 
                                     sizeof(ULONG), 
                                     NULL);
            }

            //
            // This is used for OID_QOS_FLOW_COUNT - Better be thread safe
            //

            PS_LOCK(&WanLink->Lock);

            WanLink->FlowsInstalled ++;

            CurrentFlows = WanLink->FlowsInstalled;
            
            PS_UNLOCK(&WanLink->Lock);

            PsTcNotify(Adapter, WanLink, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
        }
        else {

            //
            // This variable is used to optimize the send path
            //
            InterlockedIncrement(&Adapter->CfInfosInstalled);

           PS_LOCK(&Adapter->Lock);

           Adapter->FlowsInstalled ++;

           CurrentFlows = Adapter->FlowsInstalled; 

           PS_UNLOCK(&Adapter->Lock);

           PsTcNotify(Adapter, 0, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));

        }

        //
        // Update Stats 
        //

        InterlockedIncrement(&Vc->AdapterStats->FlowsOpened);
        Vc->AdapterStats->MaxSimultaneousFlows =
            max(Vc->AdapterStats->MaxSimultaneousFlows, CurrentFlows);

        //
        // Notify the GPC
        //
        

        PsDbgOut(DBG_TRACE, 
                 DBG_GPC_QOS, 
                 ("[CmMakeCallComplete]: Adapter %08X, Vc %08X succeeded - "
                  " Notify GPC \n", Adapter, Vc));

        GpcEntries.GpcAddCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                     CfInfo,
                                                     Status,
                                                     Vc);

        //
        // Transistion from CL_INTERNAL_CALL_COMPLETE to CL_CALL_COMPLETE
        //

        CallSucceededStateTransition(Vc);


    }
    else {

        PsDbgOut(DBG_FAILURE, 
                 DBG_GPC_QOS,
                 ("[CmMakeCallComplete]: Adapter %08X, Vc %08X, Make Call failed.  Status = %x\n", 
                  Adapter, Vc, Status));

        InterlockedIncrement(&Vc->AdapterStats->FlowsRejected);

        GpcEntries.GpcAddCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                     CfInfo,
                                                     Status,
                                                     Vc);

        DerefClVc(Vc);
    }


} // CmMakeCallComplete

GPC_STATUS
QosClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    )

/*++

Routine Description:

    
    The GPC can issue this call to get from us the WMI manageable
    InstanceName which Ndis created for the flow associated with
    the CfInfo struct.

    We guarantee to keep the string buffer around until the CfInfo
    structure is removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    GpcCfInfoHandle -       GPC's handle to CF_INFO
    InstanceName -          We return a pointer to our string.

Return Value:

    Status

--*/

{

    PGPC_CLIENT_VC GpcClientVc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    
    if(GpcClientVc->InstanceName.Buffer){

        InstanceName->Buffer = GpcClientVc->InstanceName.Buffer;
        InstanceName->Length = GpcClientVc->InstanceName.Length;
        InstanceName->MaximumLength =
                        GpcClientVc->InstanceName.MaximumLength;

        return(NDIS_STATUS_SUCCESS);
    }
    else{

        return(NDIS_STATUS_FAILURE);
    }
}


VOID
QosAddCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{
    //
    // The PS never adds CF_INFO's so this routine should never be called
    //

    DEBUGCHK;

} // QosAddCfInfoComplete


GPC_STATUS
QosModifyCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      ULONG                   CfInfoSize,
        IN      PVOID                   NewCfInfoPtr
        )

/*++

Routine Description:

    A CF_INFO is being modified.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    NewCfInfoPtr -          Pointer to proposed CF_INFO content

Return Value:

    Status

--*/

{
    PGPC_CLIENT_VC              GpcClientVc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    PCF_INFO_QOS                NewCfInfo = (PCF_INFO_QOS)NewCfInfoPtr;
    NDIS_STATUS                 Status;
    ULONG                       CallParamsLength;
    PCO_CALL_PARAMETERS         CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS        PsMediaParameters;
    LPQOS_PRIORITY              PriorityObject;
    PADAPTER                    Adapter;
    ULONG                       TcObjAlignedLength;

    //
    // Do sanity checks
    //

    if (!ValidateCfInfo(CfInfoSize, NewCfInfo)) {
        return QOS_STATUS_TC_OBJECT_LENGTH_INVALID;
    }


    Adapter = GpcClientVc->Adapter;

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState != AdapterStateRunning) {

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosModifyCfInfoNotify]: Adapter %08X closing, cannot accept "
                  "modify request \n", Adapter));

        return GPC_STATUS_NOTREADY;
    }
    PS_UNLOCK(&Adapter->Lock);

    //
    // Allocate the resources for the call manager parameters
    //

    TcObjAlignedLength = ((NewCfInfo->GenFlow.TcObjectsLength + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
    CallParamsLength =
            sizeof(CO_CALL_PARAMETERS) +
                   FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                   TcObjAlignedLength +
                   FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    if(Adapter->MediaType == NdisMediumWan) {

        CallParamsLength += sizeof(QOS_WAN_MEDIA);
    }

    PsAllocatePool( CallParams, CallParamsLength, CmParamsTag );

    if ( CallParams == NULL ) {

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosModifyCfInfoNotify]: Adapter %08X, can't allocate call params\n"));
        
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Create a call parameters struct for the ModifyCallQoS
    //

    CallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);
    CallMgrParams->Transmit = NewCfInfo->GenFlow.SendingFlowspec;
    CallMgrParams->Receive = NewCfInfo->GenFlow.ReceivingFlowspec;
    CallMgrParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CallMgrParams->CallMgrSpecific.Length = NewCfInfo->GenFlow.TcObjectsLength;

    if (NewCfInfo->GenFlow.TcObjectsLength > 0) {
        NdisMoveMemory(
            CallMgrParams->CallMgrSpecific.Parameters,
            NewCfInfo->GenFlow.TcObjects,
            NewCfInfo->GenFlow.TcObjectsLength);
    }

    // Ndis requires at least 8 bytes of media specific! Use dummy.

    PsMediaParameters =
            (PCO_MEDIA_PARAMETERS)((PUCHAR)CallMgrParams +
                FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                TcObjAlignedLength);

    PsMediaParameters->Flags = 0;
    PsMediaParameters->ReceivePriority = 0;
    PsMediaParameters->ReceiveSizeHint = NewCfInfo->GenFlow.SendingFlowspec.MaxSduSize;
    PsMediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    PsMediaParameters->MediaSpecific.Length = 0;

    if(Adapter->MediaType == NdisMediumWan) {

        LPQOS_WAN_MEDIA WanMedia;
        PsMediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) PsMediaParameters->MediaSpecific.Parameters;

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       GpcClientVc->WanLink->OriginalRemoteMacAddress,
                       6);

    }

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParams;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)PsMediaParameters;

    GpcClientVc->ModifyCallParameters = CallParams;
    GpcClientVc->ModifyCfInfoQoS = NewCfInfo;

    PS_LOCK(&GpcClientVc->Lock);
    
    switch(GpcClientVc->ClVcState) {

      case CL_INTERNAL_CALL_COMPLETE:

          // CL_INTERNAL_CALL_COMPLETE:
          //      If we are in this state, then probably we have 
          // told the GPC about the Add, & the GPC has turned right
          // back and asked us to modify before we have got a chance
          // to transistion to CL_CALL_COMPLETE.

          //
          // Remember that we have got a modify, we will complete the modify
          // when we transistion to the CL_CALL_COMPLETE state.
          //
          
          GpcClientVc->Flags |= GPC_MODIFY_REQUESTED;
          PS_UNLOCK(&GpcClientVc->Lock);
          return NDIS_STATUS_PENDING;

      case CL_CALL_COMPLETE:

          GpcClientVc->ClVcState = CL_MODIFY_PENDING;
          PS_UNLOCK(&GpcClientVc->Lock);
          break;

      default:

          //
          // In general, we expect the call to be in the 
          // CL_CALL_COMPLETE state when a modify request comes
          // in. It could be in the following states as well:
          //
          // CALL_PENDING:
          //      If we are in this state, then we have not 
          // completed the AddCfInfo request from the GPC. This
          // should not happen.
          //
          //
          // GPC_CLOSE_PENDING:
          //      If an InternalCloseCall is requested, we
          //  change to this state before asking the GPC to
          //  close. The GPC could slip in this window and
          //  ask us to modify the call. 
          //
          // MODIFY_PENDING:
          //      We have not told the GPC about the previous modify
          //  request. Therefore, the GPC cannot ask us to modify a 
          //  call if we are in this state.
          //
          
          PsAssert(GpcClientVc->ClVcState != CL_CALL_PENDING);
          PsAssert(GpcClientVc->ClVcState != CL_MODIFY_PENDING);
          PsAssert(GpcClientVc->ClVcState != CL_GPC_CLOSE_PENDING);
          PS_UNLOCK(&GpcClientVc->Lock);

          PsFreePool(CallParams);
          GpcClientVc->ModifyCallParameters = 0;
          GpcClientVc->ModifyCfInfoQoS      = 0;

          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                   ("[QosModifyCfInfoNotify]: Adapter %08X, Vc %08X, State %08X, Flags %08X -"
                    " Not ready to modify flow !\n",
                    Adapter, GpcClientVc, GpcClientVc->ClVcState, GpcClientVc->Flags));
          
          return(GPC_STATUS_NOTREADY);
    }

    //
    // Now issue the ModifyCallQoS to the PS call manager
    //

    Status = CmModifyCall(GpcClientVc);

    if(Status != NDIS_STATUS_PENDING) {
        
        CmModifyCallComplete(Status, GpcClientVc, CallParams);
    }

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosModifyCfInfoNotify]: Adapter %08X, Vc %08X, State %08X, Flags %08X -"
              " modify flow returns pending \n",
              Adapter, GpcClientVc, GpcClientVc->ClVcState, GpcClientVc->Flags));
    
    return NDIS_STATUS_PENDING;

} // QosModifyCfInfoNotify


VOID
CmModifyCallComplete(
    IN NDIS_STATUS         Status,
    IN PGPC_CLIENT_VC      GpcClientVc,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    The call manager has finished processing a ModifyCallQoS request.

Arguments:

    See the DDK

Return Value:

--*/

{
    PADAPTER Adapter = GpcClientVc->Adapter;

    //
    // We call this to change back to the CALL_COMPLETE state.
    // We make the same call whether the modify actually completed
    // or not, since the call remains up.
    //
    // The internal best effort VC is not known by 
    // the GPC and therefore, is never modified by it.
    //

    PsAssert(!IsBestEffortVc(GpcClientVc));


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_GPC_QOS,
                 ("[CmModifyCallQoSComplete]: Adapter %08X, Vc %08x, modify QoS failed. Status = %x\n", 
                  Adapter, GpcClientVc, Status));

        PsFreePool(GpcClientVc->ModifyCallParameters);
        
        InterlockedIncrement(&GpcClientVc->AdapterStats->FlowModsRejected);

        //
        // Transistion from CL_MODIFY_PENDING to CL_INTERNAL_CALL_COMPLETE
        //
        CallSucceededStateTransition(GpcClientVc);
    }
    else 
    {
        PsDbgOut(DBG_TRACE,
                 DBG_GPC_QOS,
                 ("[CmModifyCallQoSComplete]: Adapter %08X, Vc %08X, modify QoS succeeded. \n",
                  Adapter, GpcClientVc));

        //
        // Tell NDISWAN about the fragment size
        //
        if((Adapter->MediaType == NdisMediumWan) && (GpcClientVc->Flags & GPC_ISSLOW_FLOW)) 
        {
            MakeLocalNdisRequest(Adapter, 
                                 GpcClientVc->NdisWanVcHandle,
                                 NdisRequestLocalSetInfo,
                                 OID_QOS_ISSLOW_FRAGMENT_SIZE, 
                                 &GpcClientVc->ISSLOWFragmentSize, 
                                 sizeof(ULONG), 
                                 NULL);

        }

        //
        // Update Stats 
        //
        InterlockedIncrement(&GpcClientVc->AdapterStats->FlowsModified);

        PsFreePool(GpcClientVc->CallParameters);

        GpcClientVc->CallParameters = CallParameters;
        GpcClientVc->ModifyCallParameters = NULL;
        GpcClientVc->CfInfoQoS       = GpcClientVc->ModifyCfInfoQoS;
        GpcClientVc->ModifyCfInfoQoS = 0;

        //
        // Transistion from CL_MODIFY_PENDING to CL_INTERNAL_CALL_COMPLETE
        //
        CallSucceededStateTransition(GpcClientVc);

        //
        // Mark the TOS Byte for this service type
        //
        PS_LOCK(&GpcClientVc->Lock);

        SetTOSIEEEValues(GpcClientVc);

        PS_UNLOCK(&GpcClientVc->Lock);

    }

    PsAssert(GpcEntries.GpcModifyCfInfoNotifyCompleteHandler);

    GpcEntries.GpcModifyCfInfoNotifyCompleteHandler(GpcQosClientHandle, 
                                                    GpcClientVc->CfInfoHandle, 
                                                    Status);
    //
    // Transistion from CL_INTERNAL_CALL_COMPLETE to CL_CALL_COMPLETE
    //
    CallSucceededStateTransition(GpcClientVc);

        
} // ClModifyCallQoSComplete


VOID
QosModifyCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{

} // QosModifyCfInfoComplete



GPC_STATUS
QosRemoveCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext
        )

/*++

Routine Description:

    A CF_INFO is being removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context

Return Value:

    Status

--*/

{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    NDIS_STATUS    Status;
    ULONG          CurrentFlows;
    PADAPTER       Adapter = Vc->Adapter;

    PsAssert(!IsBestEffortVc(Vc));

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosRemoveCfInfoNotify]: Adapter %08X, Vc %08X, State %08X,"
              "Flags %08X \n", Adapter, Vc, Vc->ClVcState, Vc->Flags));

    //
    // Check the state of the VC. 
    //

    PS_LOCK(&Vc->Lock);

    switch(Vc->ClVcState){

      case CL_CALL_PENDING:
      case CL_MODIFY_PENDING:
        

          // CL_NDIS_CLOSE_PENDING:
          //
          // The GPC has to close before Ndis closes. So - if we're here, the GPC has already 
          // closed, in which case - it should not be  trying to close again.
          //
          // CL_CALL_PENDING, CL_MODIFY_PENDING:
          //
          // The GPC is asking us to close a VC which we  never told it about. Note that even 
          // though we can change from CL_INTERNAL_CALL_COMPLETE  to CL_MODIFY_PENDING, 
          // the GPC can *never* ask us to close in CL_MODIFY_PENDING because
          // even if the above case happens, we have not completed the modify with the GPC.
          //
          
          PS_UNLOCK(&Vc->Lock);

          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[QosRemoveCfInfoNotify]: bad state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          return(GPC_STATUS_FAILURE);
          
      case CL_INTERNAL_CALL_COMPLETE:

          //
          // We tell the GPC in the CL_INTERNAL_CALL_COMPLETE state and then transistion 
          // to the CL_CALL_COMPLETE state. However, there is a small window when the GPC 
          // can ask us to delete this VC in the CL_INTERNAL_CALL_COMPLETE state 
          // We wait till we move to CL_CALL_COMPLETE before deleting the Vc.
          //

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);

          return (GPC_STATUS_PENDING);
          
      case CL_CALL_COMPLETE:
          
          //
          // Normal GPC close request. 
          //
          
          Vc->ClVcState = CL_GPC_CLOSE_PENDING;

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);

          Status = CmCloseCall(Vc);

          PsAssert(Status == NDIS_STATUS_PENDING);


          return(GPC_STATUS_PENDING);
          
      case CL_INTERNAL_CLOSE_PENDING:
          
          //
          // We're here cause we were about to initiate a close and we're waiting 
          // for it to complete. It looks like the GPC asked us to close, before
          // we actually asked it to close. First - check that the GPC has not
          // asked us to close prior to this request.
          //
          
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          
          // 
          // If the GPC is asking us to close, the GPC MUST fail the call when we 
          // ask it to close. So, we'll simply wait here till that happens. Note that
          // we cannot pend this call and complete it later from the Internal Close handler.
          //
          // If we Deref the VC from the Internal Close Complete handler, there could be a race
          // condition and we could be looking at a stale VC pointer. So, the VC MUST be Deref'd
          // from here. We do not have to call CmCloseCall because we called it from the InternalClose
          // handler.
          //

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);
            
          DerefClVc(Vc);

          return GPC_STATUS_SUCCESS;
          
      default:
          
          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[QosRemoveCfInfoNotify]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          return GPC_STATUS_FAILURE;
    }

} // QosRemoveCfInfoNotify



VOID
CmCloseCallComplete(
    IN NDIS_STATUS Status,
    IN PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    The call manager has finished processing a CloseCall request.

Arguments:

    See the DDK

Return Value:

--*/

{
    PADAPTER       Adapter = Vc->Adapter;
    NDIS_STATUS    LocalStatus;
    ULONG          CurrentFlows;

    PsAssert(!IsBestEffortVc(Vc)); 

    
    if(Adapter->MediaType == NdisMediumWan) {

        //
        // To optimize send path
        //
        InterlockedDecrement(&Vc->WanLink->CfInfosInstalled);
        
        PS_LOCK(&Vc->WanLink->Lock);
        
        Vc->WanLink->FlowsInstalled --;
        
        CurrentFlows = Vc->WanLink->FlowsInstalled;
        
        PS_UNLOCK(&Vc->WanLink->Lock);
        
        PsTcNotify(Adapter, Vc->WanLink, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
        
    }
    else 
    {
        //
        // To optimize send path
        //
        InterlockedDecrement(&Adapter->CfInfosInstalled);

        PS_LOCK(&Adapter->Lock);
        
        Adapter->FlowsInstalled --;
        
        CurrentFlows = Adapter->FlowsInstalled;
        
        PS_UNLOCK(&Adapter->Lock);
        
        PsTcNotify(Adapter, 0, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
    }
    
    //
    // Update stats
    //
    
    InterlockedIncrement(&Vc->AdapterStats->FlowsClosed);
    
    Vc->AdapterStats->MaxSimultaneousFlows =
        max(Vc->AdapterStats->MaxSimultaneousFlows, CurrentFlows);
    
    PS_LOCK(&Vc->Lock);

    if(Vc->Flags & INTERNAL_CLOSE_REQUESTED)
    {
        // We have asked to close this call. Let's process the close now.
        // Note that we don't really care if the GPC has asked us to close.
        // 
        // Because - 
        // 1. If we had initiated an internal close after the GPC asks us to close, we ignore the internal close, 
        //    and the above flag will not be set.
        // 2. If the GPC had asked us to close, we have pended it - We will now complete it when the GPC fails our
        //    call to close the Vc.
        //
        
        PS_UNLOCK(&Vc->Lock);
        
        PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
                 ("[CmCloseCallComplete]: Adapter %08X, Vc %08X (State %08X, Flags %08X), "
                  "Internal Close requested \n",
                  Adapter, Vc, Vc->ClVcState, Vc->Flags));

        Status = GpcEntries.GpcRemoveCfInfoHandler(GpcQosClientHandle, Vc->CfInfoHandle);
        
        if(Status != NDIS_STATUS_PENDING) {
            
            QosRemoveCfInfoComplete(NULL, Vc, Status);
        }
        
        return;
    }
    
    PS_UNLOCK(&Vc->Lock);

    //
    // Complete the request with the GPC.
    //
    GpcEntries.GpcRemoveCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                    Vc->CfInfoHandle,
                                                    GPC_STATUS_SUCCESS);

    DerefClVc(Vc);

    return;
}
       
VOID
DerefClVc(
    PGPC_CLIENT_VC Vc
    )
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(&Vc->RefCount);

    if(!RefCount)
    {
        PsDbgOut(DBG_INFO,
                 DBG_STATE,
                 ("DerefClVc: deref'd to 0. State is %s on VC %x\n",
                 GpcVcState[Vc->ClVcState], Vc));

        if(Vc->NdisWanVcHandle)
        {
            WanCloseCall(Vc);
        }
        else 
        {
            CmDeleteVc(Vc);
        }
        
    }

} // DerefClVc


    
VOID
QosRemoveCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ClientCfInfoContext;

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosRemoveCfInfoComplete]: Adapter %08X, Vc %08X "
              "(State = %08X, Flags = %08X), Status %08X \n", Vc->Adapter, Vc, 
              Vc->ClVcState, Vc->Flags, Status));

    if(Status != NDIS_STATUS_SUCCESS)
    {
        //
        // The GPC has requested a close, which has been pended. Complete that request.
        //
        
        PsDbgOut(DBG_TRACE, 
                 DBG_GPC_QOS,
                 ("[QosRemoveCfInfoComplete]: Vc %08X, completing with GPC \n", Vc));
    }
    else {
        DerefClVc(Vc);
    }

} // QosRemoveCfInfoComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\main.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.h

Abstract:

    defines for the main driver

Author:

    Rajesh Sundaram (9-17-1998)

Environment:

    Kernel Mode

Revision History:

--*/

/* External */

/* Static */

/* Prototypes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\gpccm.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    GpcCM.c

Abstract:

    Handlers called by GPC for the ClassMap address family.  

Author:

    Rajesh Sundaram (rajeshsu)   1st Aug, 1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

#if CBQ


/*++

Routine Description:

    A new CF_INFO has been added to the GPC database.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    GpcCfInfoHandle -       GPC's handle to CF_INFO
    CfInfoPtr -             Pointer to the CF_INFO structure
    ClientCfInfoContext -   Location in which to return PS's context for 
                            CF_INFO
Return Value:

    Status

--*/

GPC_STATUS
ClassMapAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_HANDLE              GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   CfInfoPtr,
	IN	PGPC_CLIENT_HANDLE      ClientCfInfoContext
	)
{
#if 0
    PCF_INFO_CLASS_MAP     CfInfo; 
    PADAPTER               Adapter;
    PGPC_CLIENT_VC         Vc;
    NDIS_STATUS            Status;
    PPS_WAN_LINK           WanLink = 0;
    PCLASS_MAP_CONTEXT_BLK pClBlk;
    PPS_CLASS_MAP_CONTEXT  ClassMapContext, PrevContext;
    PPSI_INFO              PsComponent, aPsComponent;
    PPS_PIPE_CONTEXT       PipeContext, aPipeContext;

    CfInfo = (PCF_INFO_CLASS_MAP)CfInfoPtr;

    //
    // Verify that the TcObjectsLength is consistent with the
    // CfInfoSize. The CfInfoSize must have been verified during
    // the user/kernel transition. The TcObjectsLength has not.
    // We could bugcheck if we try to search beyond the buffer 
    // passed in.
    //
    if(CfInfoSize < (FIELD_OFFSET(CF_INFO_CLASS_MAP, ClassMapInfo) +
                     FIELD_OFFSET(TC_CLASS_MAP_FLOW, Objects) +
                     CfInfo->ClassMapInfo.ObjectsLength)){

        return(ERROR_TC_OBJECT_LENGTH_INVALID);
    }

    Adapter = FindAdapterByWmiInstanceName((USHORT) CfInfo->InstanceNameLength,
                                           (PWSTR) &CfInfo->InstanceName[0],
                                           &WanLink, 
                                           TRUE);

    if(!Adapter) {
        
        return GPC_STATUS_IGNORED;
    }

    PS_LOCK(&Adapter->Lock);
    
    if(Adapter->PsMpState != AdapterStateRunning) {

        PS_UNLOCK(&Adapter->Lock);
        return NDIS_STATUS_FAILURE;
    }

    PS_UNLOCK(&Adapter->Lock);

    //
    // Create a context which will be passed back to the GPC. We should be using Lookaside Lists if 
    // we port CBQ and if this becomes a frequent operation. This will probably not be as frequent
    // as creating VCs so we should be fine.
    //

    PsAllocatePool(pClBlk,
                   sizeof(CLASS_MAP_CONTEXT_BLK),
                   PsMiscTag);

    if(!pClBlk)
    {
        return NDIS_STATUS_RESOURCES;
    }

    pClBlk->Adapter = Adapter;
    *ClientCfInfoContext = pClBlk;

    if(WanLink)
    {
        PsAssert(Adapter->MediaType == NdisMediumWan);

        PipeContext = aPipeContext   = WanLink->PsPipeContext;
        PsComponent = aPsComponent   = WanLink->PsComponent;

        pClBlk->WanLink = WanLink;

    }
    else 
    {
        PipeContext = aPipeContext    = Adapter->PsPipeContext;
        PsComponent = aPsComponent    = Adapter->PsComponent;
        pClBlk->WanLink = 0;

    }

    //
    // Allocate space for the component's context (class map context)
    // The length of the class map  context buffer for this pipe was 
    // calculated  when the pipe was initialized.
    //
    PsAllocatePool(pClBlk->ComponentContext,
                   Adapter->ClassMapContextLength, 
                   ClassMapContextTag );

    if ( pClBlk->ComponentContext == NULL ) {
       ClientCfInfoContext = 0;
        PsFreePool(pClBlk);
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Set up the context buffer
    //
    ClassMapContext = (PPS_CLASS_MAP_CONTEXT)pClBlk->ComponentContext;
    PrevContext = NULL;

    while (PsComponent != NULL) {

        ClassMapContext->NextComponentContext = (PPS_CLASS_MAP_CONTEXT)
            ((UINT_PTR)ClassMapContext + PsComponent->ClassMapContextLength);
        ClassMapContext->PrevComponentContext = PrevContext;

        PsComponent = PipeContext->NextComponent;
        PipeContext = PipeContext->NextComponentContext;

        PrevContext = ClassMapContext;
        ClassMapContext = ClassMapContext->NextComponentContext;
    }


    Status = (*aPsComponent->CreateClassMap)
        (aPipeContext,
         ClientContext,
         &CfInfo->ClassMapInfo,
         pClBlk->ComponentContext); 

    if(Status == NDIS_STATUS_SUCCESS)
    {
        if(Adapter->MediaType == NdisMediumWan) 
        {
            //
            // To optimize send path
            //
            InterlockedIncrement(&WanLink->CfInfosInstalled);
        }
        else 
        {
            //
            // To optimize send path
            //
            InterlockedIncrement(&Adapter->CfInfosInstalled);
        }
    }

    return Status;
#endif
    return GPC_STATUS_FAILURE;
}

GPC_STATUS
ClassMapModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN  ULONG                   CfInfoSize,
	IN	PVOID                   NewCfInfoPtr
	)
{
    return GPC_STATUS_FAILURE;
}

GPC_STATUS
ClassMapRemoveCfInfoNotify(
    IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	)
{
#if 0
    PADAPTER               Adapter;
    NDIS_STATUS            Status;
    PCLASS_MAP_CONTEXT_BLK pCmBlk = ClientCfInfoContext;

    Adapter = pCmBlk->Adapter;

    if(Adapter->MediaType == NdisMediumWan) 
    {
        //
        // To optimize send path
        //
        InterlockedDecrement(&WanLink->CfInfosInstalled);

        Status = (*pCmBlk->WanLink->PsComponent->DeleteClassMap)
            (pCmBlk->WanLink->PsPipeContext,
             pCmBlk->ComponentContext);
    }
    else 
    {
        //
        // To Optimize send path
        //
        InterlockedDecrement(&Adapter->CfInfosInstalled);

        Status = (*Adapter->PsComponent->DeleteClassMap)
            (Adapter->PsPipeContext,
             pCmBlk->ComponentContext);
    }
   
    PsFreePool(pCmBlk->ComponentContext);
    PsFreePool(pCmBlk);


    return Status;
#endif
    return GPC_STATUS_FAILURE;
}

VOID
ClassMapAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
    //
    // The PS never adds CF_INFO's so this routine should never be called
    //
    DEBUGCHK;
}

VOID
ClassMapModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
}

VOID
ClassMapRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
}

GPC_STATUS
ClassMapClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    )
{
    InstanceName->Length = 0;
    return(NDIS_STATUS_SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\gpchndlr.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    GpcHndlr.h

Abstract:

    GPC client handler defs

Author:

Revision History:

--*/

#ifndef _GPC_HNDLR_
#define _GPC_HNDLR_
#include "gpcifc.h"

//
// Offload types that can co-exist with packet scheduling.
//
#define PERMITTED_TCP_IP_OFFLOAD_TYPES (TCP_XMT_CHECKSUM_OFFLOAD        | \
                                        IP_XMT_CHECKSUM_OFFLOAD         | \
                                        TCP_RCV_CHECKSUM_OFFLOAD        | \
                                        IP_RCV_CHECKSUM_OFFLOAD         | \
                                        IP_CHECKSUM_OPT_OFFLOAD         | \
                                        TCP_CHECKSUM_OPT_OFFLOAD)

//
// The purpose of this is to ensure that whenever a new offload type is added
// to TCP/IP, either it is consciously disallowed or allowed.
//
C_ASSERT((PERMITTED_TCP_IP_OFFLOAD_TYPES | 
          TCP_LARGE_SEND_OFFLOAD         |
          TCP_LARGE_SEND_TCPOPT_OFFLOAD  |
          TCP_LARGE_SEND_IPOPT_OFFLOAD) == TCP_IP_OFFLOAD_TYPES);

//
// Function Prototypes.
//
GPC_STATUS
QosAddCfInfoNotify(
    IN GPC_CLIENT_HANDLE       ClientContext,
    IN GPC_HANDLE              GpcCfInfoHandle,
    IN PTC_INTERFACE_ID        InterfaceInfo,
    IN ULONG                   CfInfoSize,
    IN PVOID                   CfInfoPtr,
    IN PGPC_CLIENT_HANDLE      ClientCfInfoContext
    );

GPC_STATUS
QosClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    );

//
// Internal Completion handlers
//
VOID
CmMakeCallComplete(NDIS_STATUS Status,
                   PGPC_CLIENT_VC Vc, 
                   PCO_CALL_PARAMETERS CallParameters);

VOID
CmModifyCallComplete(
    IN NDIS_STATUS         Status,
    IN PGPC_CLIENT_VC      GpcClientVc,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
CmCloseCallComplete(
    IN NDIS_STATUS Status,
    IN PGPC_CLIENT_VC Vc
    );


VOID
QosAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
QosModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	GPC_HANDLE              CfInfo
	);

VOID
ClModifyCallQoSComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
QosModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
QosRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	);

VOID
ClCloseCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
QosRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

VOID
DerefClVc(
    IN PGPC_CLIENT_VC Vc);

NDIS_STATUS
CloseCallWithNdis(
    PGPC_CLIENT_VC Vc
    );

NDIS_STATUS
CloseCallWithGpc(
    PGPC_CLIENT_VC Vc
    );

//
// Prototypes for CF_INFO_CLASS_MAP
//
GPC_STATUS
ClassMapAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_HANDLE              GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   CfInfoPtr,
	IN	PGPC_CLIENT_HANDLE      ClientCfInfoContext
	);

GPC_STATUS
ClassMapClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    );

VOID
ClassMapAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
ClassMapModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	GPC_HANDLE              CfInfo
	);

VOID
ClassMapModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
ClassMapRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	);

VOID
ClassMapRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

VOID
SetTOSIEEEValues(PGPC_CLIENT_VC Vc);

// End prototypes

#endif // _GPC_HNDLR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\globals.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    global declarations

Author:

    Charlie Wickham (charlwi)  22-Apr-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

#include <ntverp.h>

/* External */

/* Static */

/* Forward */
/* End Forward */

ULONG InitShutdownMask;
ULONG AdapterCount;
ULONG DriverRefCount;
DRIVER_STATE gDriverState;

ULONG gEnableAvgStats = 0;
ULONG gEnableWindowAdjustment = 0;
NDIS_STRING gsEnableWindowAdjustment = NDIS_STRING_CONST("PSCHED");


//
// Lists 
//
LIST_ENTRY AdapterList;                  // List of adapters
LIST_ENTRY PsComponentList;              // List of scheduling components.
LIST_ENTRY PsProfileList;                // List of scheduling profiles.


//
// Locks
//
PS_SPIN_LOCK AdapterListLock;          // Protects AdapterList
PS_SPIN_LOCK DriverUnloadLock;         // to handle unloads, unbinds, etc.

//
//  Mutex Implementation
//
ULONG   CreateDeviceMutex = 0;



//
// Handles
//

NDIS_HANDLE ClientProtocolHandle;     // handle returned by NDIS when registering the Client
NDIS_HANDLE MpWrapperHandle;          // Ndis wrapper handle for MP section
NDIS_HANDLE LmDriverHandle;           // handle returned by NDIS when MP portion registers as LM
NDIS_HANDLE PsDeviceHandle; 


//
// PSDriverObject, PSDeviceObject - pointer to NT driver and device objects
//

PDRIVER_OBJECT PsDriverObject;
PDEVICE_OBJECT PsDeviceObject;

//
// Lookaside Lists
//
NPAGED_LOOKASIDE_LIST NdisRequestLL;  // For Ndis requests
NPAGED_LOOKASIDE_LIST GpcClientVcLL;  // For GPC Client VCs.

//
// Events
//
NDIS_EVENT             DriverUnloadEvent;
NDIS_EVENT             gZAWEvent;
ULONG                  gZAWState = ZAW_STATE_READY;

//
// name constants used during registration/initialization
//
NDIS_STRING PsSymbolicName         = NDIS_STRING_CONST("\\DosDevices\\PSched");
NDIS_STRING PsDriverName           = NDIS_STRING_CONST("\\Device\\PSched");
NDIS_STRING VcPrefix               = NDIS_STRING_CONST( "VC:");
NDIS_STRING WanPrefix              = NDIS_STRING_CONST( "WAN:");
NDIS_STRING MachineRegistryKey     = NDIS_STRING_CONST( "\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows\\PSched");
NDIS_STRING PsMpName;

//
// Default scheduling component info
//

PSI_INFO TbConformerInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TokenBucketConformer" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO ShaperInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TrafficShaper" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO DrrSequencerInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "DRRSequencer" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO TimeStmpInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TimeStmp" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO SchedulerStubInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "SchedulerStub" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};

//
// Known component configurations
//
PS_PROFILE DefaultSchedulerConfig = {
    {0, 0},
    0,
    NDIS_STRING_CONST( "DefaultSchedulerConfig" ),
    3,
    {&TbConformerInfo,
     &DrrSequencerInfo,
     &SchedulerStubInfo
    }
};

//
// PS Procs for scheduler
//

PS_PROCS PsProcs;



// 
// For the logging support
//

PVOID                  SchedTraceThreshContext;
NDIS_SPIN_LOCK         GlobalLoggingLock;
ULONG                  SchedTraceIndex = 0;
ULONG                  SchedBufferSize = 0;
ULONG                  SchedTraced = 0;
UCHAR                  *SchedTraceBuffer = 0;
ULONG                  SchedTraceBytesUnread = 0;
ULONG                  SchedTraceThreshold = 0xffffffff;
SCHEDTRACE_THRESH_PROC SchedTraceThreshProc = NULL;
BOOLEAN                TraceBufferAllocated = FALSE;
BOOLEAN                WMIInitialized = FALSE;


// Timer

ULONG  gTimerResolutionActualTime  = 0;
ULONG  gTimerSet                   = 0;


// GPC VC state machine

#if DBG
PUCHAR GpcVcState[] = {
    "ERROR_STATE",
    "CL_VC_INITIALIZED",
    "CL_CALL_PENDING",
    "CL_INTERNAL_CALL_COMPLETE",
    "CL_CALL_COMPLETE",
    "CL_MODIFY_PENDING",
    "CL_GPC_CLOSE_PENDING",
    "CL_NDIS_CLOSE_PENDING",
    "CL_WAITING_FOR_PENDING_PACKETS"
};
#endif


//
// GPC Interface
//

GPC_EXPORTED_CALLS GpcEntries;
GPC_HANDLE         GpcQosClientHandle;
#if CBQ
GPC_HANDLE         GpcClassMapClientHandle;
#endif
PS_DEVICE_STATE    DeviceState = PS_DEVICE_STATE_READY;

//
// TAGS
//

ULONG NdisRequestTag =           '0CSP';
ULONG GpcClientVcTag =           '1CSP';
ULONG WanLinkTag =               '2CSP';
ULONG PsMiscTag =                '3CSP';
ULONG WanTableTag =              '4CSP';
ULONG WMITag =                   'hCSP';

ULONG AdapterTag =               'aCSP';
ULONG CmParamsTag =              'bCSP';
ULONG PipeContextTag =           'cCSP';
ULONG FlowContextTag =           'dCSP';
ULONG ClassMapContextTag =       'eCSP';
ULONG ProfileTag =               'fCSP';
ULONG ComponentTag =             'gCSP';

ULONG TimerTag  =                'zCSP';
ULONG TsTag =                    'tCSP';

#if DBG

CHAR VersionNumber[] = "0.300";
CHAR VersionHerald[] = "PSched: Packet Scheduler Version %s built on %s\n";
CHAR VersionTimestamp[] = __DATE__ " " __TIME__;

ULONG DbgTraceLevel;
ULONG DbgTraceMask;
ULONG LogTraceLevel;
ULONG LogTraceMask;
ULONG LogId = LAST_LOG_ID;
ULONG ClassificationType = 0;

#endif


//
// NULL Component hacks for now [ShreeM]
//
PS_RECEIVE_PACKET       TimeStmpRecvPacket      = NULL;
PS_RECEIVE_INDICATION   TimeStmpRecvIndication  = NULL;

PULONG_PTR g_WanLinkTable;
USHORT     g_NextWanIndex;
USHORT     g_WanTableSize;

/* end globals.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\main.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the initialization file for the packet scheduler driver. This driver
    is used to provide Local Traffic Control

Author:

    Charlie Wickham (charlwi)  
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

//
// number of characters that are appended to the RegistryPath when constructing
// the miniport device name
//

#define MPNAME_EXTENSION_SIZE   ( 3 * sizeof(WCHAR))

/* External */

/* Static */

/* Forward */ 

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
InitializeNdisWrapper(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoMiniportInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoProtocolInit(IN PDRIVER_OBJECT DriverObject, 
               IN  PUNICODE_STRING RegistryPath);

NTSTATUS
RegisterWithGpc();

NDIS_STATUS
InitializeScheduler(VOID);

VOID
InitializationCleanup(ULONG ShutdownMask);

VOID
GetTimerInfo (OUT PULONG TimerResolution);

VOID
PSUnload(IN PDRIVER_OBJECT pDriverObject);

/* End Forward */

#pragma NDIS_INIT_FUNCTION(DriverEntry)
#pragma NDIS_INIT_FUNCTION(InitializeNdisWrapper)
#pragma NDIS_INIT_FUNCTION(DoProtocolInit)
#pragma NDIS_INIT_FUNCTION(DoMiniportInit)



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the NT OS specific driver entry point.  It kicks off initialization
    for the driver.  Currently, it is not PnP aware. Return from this routine
    only after protocol registration, layered miniport registration, and both
    miniport and higher layer protocol initialization has been done.

Arguments:

    DriverObject - NT OS specific Object
    RegistryPath - NT OS specific pointer to registry location for Psched

Return Values:

    STATUS_SUCCESS
    STATUS_FAILURE

--*/
{
    NDIS_STATUS Status;
    NTSTATUS    NtStatus;
    PVOID       DumpData;

#if DBG
    //
    // announce the version
    //
    PsDbgOut(DBG_INFO, DBG_INIT, (VersionHerald, VersionNumber, VersionTimestamp));
#endif

    //
    // store a copy of our driver object. Used by NdisWriteEventLogEntry
    //
    PsDriverObject = DriverObject;

    //
    // Initialize the Driver refcount and DriverState
    //
    gDriverState = DriverStateLoaded;
    PS_INIT_SPIN_LOCK(&DriverUnloadLock);
    NdisInitializeEvent(&DriverUnloadEvent);
    NdisSetEvent(&DriverUnloadEvent);

    NdisInitializeEvent(&gZAWEvent);

    //
    // initialize global data and ndis request lookaside list
    //

    InitializeListHead(&PsComponentList);
    InitializeListHead(&AdapterList);
    PS_INIT_SPIN_LOCK(&AdapterListLock);
    InitializeListHead(&PsProfileList);

    // Initialize scheduling components

    InitializeTbConformer(&TbConformerInfo);
    InitializeDrrSequencer(&DrrSequencerInfo);
    InitializeSchedulerStub(&SchedulerStubInfo);

    //
    // Add these components to the component list
    //

    InsertHeadList(&PsComponentList, &TbConformerInfo.Links );
    InsertHeadList(&PsComponentList, &DrrSequencerInfo.Links );
    InsertHeadList(&PsComponentList, &SchedulerStubInfo.Links );

    PsProcs.DropPacket     = DropPacket;
    PsProcs.NdisPipeHandle = GetNdisPipeHandle;
    PsProcs.GetTimerInfo   = GetTimerInfo;

    //
    // init the LLists for NdisRequest, MCM_VC, AND CLIENT_VC structs 
    // as these will be in high demand at times.
    //
    // Lookaside list depth is automatically managed by the executive. 
    //

    NdisInitializeNPagedLookasideList(&NdisRequestLL,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(PS_NDIS_REQUEST),
                                      NdisRequestTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&GpcClientVcLL,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof( GPC_CLIENT_VC ),
                                      GpcClientVcTag,
                                      (USHORT)0);

    //
    // get driver wide configuration data from the registry
    //

    Status = PsReadDriverRegistryDataInit();

    if(NT_SUCCESS(Status))
    {
        Status = PsReadDriverRegistryData();

        if(!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_INIT, ("DriverEntry: PsReadDriverRegistryData - Status: 0x%x\n",  
                                             Status));
            goto DriverEntryError;
        }
    }
    else
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT, ("DriverEntry: PsReadDriverRegistryDataInit - Status: 0x%x\n", 
                                         Status));
        goto DriverEntryError;
    }

    //
    // Initialize space for WanLinks. Note that we don't need a lock to protect
    // this table - We recognize lineups only on the NDISWAN-IP binding, so we 
    // can use the Adapter lock from the binding for synchronization.
    //

    PsAllocatePool(g_WanLinkTable, 
                   WAN_TABLE_INITIAL_SIZE * sizeof(ULONG_PTR), 
                   WanTableTag);

    if(!g_WanLinkTable)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("[DriverEntry]: Cannot allocate memory for wanlinks \n"));

        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_NO_RESOURCES_FOR_INIT,
                               0,
                               0,
                               NULL,
                               0,
                               NULL);

        goto DriverEntryError;
                 
    }
    
    g_WanTableSize = WAN_TABLE_INITIAL_SIZE;

    NdisZeroMemory(g_WanLinkTable, g_WanTableSize * sizeof(ULONG_PTR));

    //
    // The first entry is never used.
    //
    g_WanLinkTable[0] = (ULONG_PTR) -1;

    g_NextWanIndex = 1;



    // 
    // Register with the Generic Packet Classifier 
    //

    NtStatus = RegisterWithGpc();

    if(!NT_SUCCESS(NtStatus))
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("RegisterWithGpc Failed! Status: 0x%x\n", NtStatus));

        DumpData = &NtStatus;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_GPC_REGISTER_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof(NTSTATUS),
                               DumpData);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_GPC;


    //
    // initialize the wrapper with NDIS
    //

    Status = InitializeNdisWrapper( PsDriverObject, RegistryPath );

    if ( !NT_SUCCESS( Status )) {

        PsDbgOut(DBG_FAILURE, DBG_INIT, 
                 ("DriverEntry: InitializeNdisWrapper - Status: 0x%x\n", Status ));

        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_NO_RESOURCES_FOR_INIT,
                               0,
                               0,
                               NULL,
                               0,
                               NULL);

        goto DriverEntryError;
    }

    //
    // Initialize as a Miniport driver to the transports. 
    //

    Status = DoMiniportInit(PsDriverObject, RegistryPath);

    if (!NT_SUCCESS(Status)){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT | DBG_MINIPORT,
                 ("DoMiniportInit Failed! Status: 0x%x\n", Status));

        DumpData = &Status;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_REGISTER_MINIPORT_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof( Status ),
                               DumpData);
        //
        // Terminate the wrapper
        //

        NdisTerminateWrapper(MpWrapperHandle, NULL);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_MINIPORT;

    //
    // do Protocol initialize first
    //

    Status = DoProtocolInit( PsDriverObject, RegistryPath );

    if (!NT_SUCCESS(Status)){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT | DBG_PROTOCOL,
                 ("DoProtocolInit Failed! Status: 0x%x\n", Status));

        DumpData = &Status;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_REGISTER_PROTOCOL_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof( Status ),
                               DumpData);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_PROTOCOL;

    NdisIMAssociateMiniport(LmDriverHandle, ClientProtocolHandle);

    return (STATUS_SUCCESS);

    //
    // An error occured so we need to cleanup things
    //

DriverEntryError:
    InitializationCleanup(InitShutdownMask);

    NdisTerminateWrapper(MpWrapperHandle, NULL);

    return (STATUS_UNSUCCESSFUL);

} // DriverEntry



NDIS_STATUS
InitializeNdisWrapper(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initialize the Ndis wrapper for both the miniport and protocol 
    sections. Since the name in the registry path is the Protocol 
    key (PSched), 'Mp' is appended onto the end to initialize 
    the wrapper for the miniport side of the PS

Arguments:

    DriverObject - pointer to NT driver object
    RegistryPath - pointer to path to driver params in registry 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/

{
    NDIS_STATUS           Status;
    USHORT                MpDeviceNameLength;
    NDIS_PHYSICAL_ADDRESS HighAddress = NDIS_PHYSICAL_ADDRESS_CONST( -1, -1 );
    ULONG                 i;
    PWCHAR                RegistryPathBuffer;

    //
    // NT needs the MP name to be different from the protocol name
    //

    MpDeviceNameLength = RegistryPath->Length + MPNAME_EXTENSION_SIZE;

    PsAllocatePool(RegistryPathBuffer,
                   MpDeviceNameLength,
                   PsMiscTag);

    if ( RegistryPathBuffer == NULL ) {

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("Can't allocate buffer for MP Device Name\n" ));

        return NDIS_STATUS_RESOURCES;
    }

    //
    // max length includes a trailing null, while length is just the string
    //

    PsMpName.MaximumLength = MpDeviceNameLength;
    PsMpName.Length        = PsMpName.MaximumLength - sizeof( WCHAR );
    PsMpName.Buffer        = RegistryPathBuffer;

    NdisMoveMemory(PsMpName.Buffer, 
                   RegistryPath->Buffer, 
                   RegistryPath->Length );

    i = RegistryPath->Length / sizeof( WCHAR );
    RegistryPathBuffer[ i++ ] = L'M';
    RegistryPathBuffer[ i++ ] = L'P';
    RegistryPathBuffer[ i ]   = L'\0';

    NdisMInitializeWrapper(&MpWrapperHandle, 
                           DriverObject, 
                           &PsMpName, 
                           NULL);

    return ((MpWrapperHandle) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES);

} // InitializeNdisWrapper


NDIS_STATUS
DoMiniportInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Name:

    DoMiniportInit

Routine Description:

    This routines registers Psched as a Miniport driver with the NDIS wrapper.

Arguments:

    None

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/

{
    NDIS_MINIPORT_CHARACTERISTICS MiniportChars;
    NDIS_STATUS                   Status;

    MiniportChars.MajorNdisVersion = 5;
    MiniportChars.MinorNdisVersion = 0;

    MiniportChars.Reserved                = 0;
    MiniportChars.HaltHandler             = MpHalt;
    MiniportChars.InitializeHandler       = MpInitialize;
    MiniportChars.QueryInformationHandler = MpQueryInformation;
    MiniportChars.ResetHandler            = NULL;
    MiniportChars.SetInformationHandler   = MpSetInformation;
    MiniportChars.TransferDataHandler     = MpTransferData;

    //
    // Unused handlers
    //

    MiniportChars.ReconfigureHandler      = NULL;
    MiniportChars.DisableInterruptHandler = NULL;
    MiniportChars.EnableInterruptHandler  = NULL;
    MiniportChars.HandleInterruptHandler  = NULL;
    MiniportChars.ISRHandler              = NULL;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //

    MiniportChars.CheckForHangHandler     = NULL;

    //
    // Ndis 4.0 handlers. No regular send routine since we have a
    // SendPackets handler.
    //

    MiniportChars.ReturnPacketHandler     = MpReturnPacket;
    MiniportChars.SendPacketsHandler      = NULL;
    MiniportChars.AllocateCompleteHandler = NULL;
    MiniportChars.SendHandler             = MpSend;

    //
    // 4.1 handlers
    //

    MiniportChars.CoCreateVcHandler       = NULL;
    MiniportChars.CoDeleteVcHandler       = NULL;
    MiniportChars.CoActivateVcHandler     = NULL;
    MiniportChars.CoDeactivateVcHandler   = NULL;
    MiniportChars.CoSendPacketsHandler    = NULL;
    MiniportChars.CoRequestHandler        = NULL;

    Status = NdisIMRegisterLayeredMiniport(MpWrapperHandle,
                                           &MiniportChars,
                                           sizeof(MiniportChars),
                                           &LmDriverHandle);

    //
    // Hook the unload function
    //

    NdisMRegisterUnloadHandler(MpWrapperHandle, PSUnload);

    return (Status);
} // DoMiniportInit


NDIS_STATUS
DoProtocolInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    DoProtocolInit

Routine Description:

    This function registers the PS twice as a protocol - once for the protocol
    section of the LM and the other for the CM section.

Arguments:

    RegistryPath - pointer to our key in the registry

Return Values:

    NDIS_STATUS_BAD_CHARACTERISTICS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS ProtocolChars;
    NDIS_STATUS                   Status;
    NDIS_STRING                   PsName = NDIS_STRING_CONST( "PSched" );

    //
    // register the client portion of the PS
    //
    NdisZeroMemory(&ProtocolChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtocolChars.Name.Length = PsName.Length;
    ProtocolChars.Name.Buffer = (PVOID)PsName.Buffer;

    ProtocolChars.MajorNdisVersion = 5;
    ProtocolChars.MinorNdisVersion = 0;

    ProtocolChars.OpenAdapterCompleteHandler  = ClLowerMpOpenAdapterComplete;
    ProtocolChars.CloseAdapterCompleteHandler = ClLowerMpCloseAdapterComplete;
    ProtocolChars.SendCompleteHandler         = ClSendComplete;
    ProtocolChars.TransferDataCompleteHandler = ClTransferDataComplete;
    ProtocolChars.ResetCompleteHandler        = ClResetComplete;
    ProtocolChars.RequestCompleteHandler      = ClRequestComplete;
    ProtocolChars.ReceiveHandler              = ClReceiveIndication;
    ProtocolChars.ReceiveCompleteHandler      = ClReceiveComplete;
    ProtocolChars.StatusHandler               = ClStatusIndication;
    ProtocolChars.StatusCompleteHandler       = ClStatusIndicationComplete;
    ProtocolChars.ReceivePacketHandler        = ClReceivePacket;
    ProtocolChars.BindAdapterHandler          = ClBindToLowerMp;
    ProtocolChars.UnbindAdapterHandler        = ClUnbindFromLowerMp;
    ProtocolChars.UnloadHandler               = ClUnloadProtocol;
    ProtocolChars.CoSendCompleteHandler       = ClCoSendComplete;
    ProtocolChars.CoStatusHandler             = ClCoStatus;
    ProtocolChars.CoReceivePacketHandler      = ClCoReceivePacket;
    ProtocolChars.CoAfRegisterNotifyHandler   = ClCoAfRegisterNotifyHandler;
    ProtocolChars.PnPEventHandler             = ClPnPEventHandler;

    NdisRegisterProtocol(&Status,
                         &ClientProtocolHandle,
                         &ProtocolChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS) + ProtocolChars.Name.Length);

    return Status;
} // DoProtocolInit


NTSTATUS
RegisterWithGpc(
    )
/*++

Routine Name:

    RegisterWithGpc

Routine Description:

    This function initializes the Gpc and gets its list of entry points. 
    Next, it registers the PS as a client of the GPC and gets a GPC client
    handle. The PS must be a client of the GPC before it can classify packets. 

Arguments:

    GpcHandle - points to the location into which to write the handle which
    the GPC gives out to represent this client.

Return Values:

--*/
{
    NTSTATUS   Status;

    //
    // Function list for CF_INFO_QOS
    //
    GPC_CLIENT_FUNC_LIST GpcQosFuncList = {
        GpcMajorVersion,
        QosAddCfInfoComplete,
        QosAddCfInfoNotify,
        QosModifyCfInfoComplete,
        QosModifyCfInfoNotify,
        QosRemoveCfInfoComplete,
        QosRemoveCfInfoNotify,
        QosClGetCfInfoName
    };


    Status = GpcInitialize(&GpcEntries);

    if(!NT_SUCCESS(Status))
    {
        ASSERT(0);
        GpcEntries.Reserved = NULL;
        return Status;
    }

    PsAssert(GpcEntries.Reserved);
    PsAssert(GpcEntries.GpcRegisterClientHandler);

    //
    // Register for CF_INFO_QOS
    //
    Status = GpcEntries.GpcRegisterClientHandler(GPC_CF_QOS,
    GPC_FLAGS_FRAGMENT,
    1,
    &GpcQosFuncList,
    (GPC_CLIENT_HANDLE)PS_QOS_CF,
    &GpcQosClientHandle);
        
    if (!NT_SUCCESS(Status))
    {
        ASSERT(0);
        GpcQosClientHandle = NULL;
        return Status;
    }

    return Status;
}


VOID
InitializationCleanup(
    ULONG ShutdownMask
    )

/*++

Routine Description:

    This routine is responsible for cleaning up all allocated resources during
    initialization

Arguments:

    ShutdownMask - A Mask that indicates the items that need to be cleaned up.

Return Values:

    None

--*/

{
    NDIS_STATUS Status;
    PPSI_INFO   PsComponent;
    PLIST_ENTRY NextProfile, NextComponent;
    PPS_PROFILE PsProfile;

    //
    // Deregister the protocol; we should have no references that would cause
    // this to pend
    //

    if(ShutdownMask & SHUTDOWN_DEREGISTER_MINIPORT){

        if(LmDriverHandle){

            NdisIMDeregisterLayeredMiniport(LmDriverHandle);
        }
    }
        
    if(ShutdownMask & SHUTDOWN_DEREGISTER_PROTOCOL){

        if(ClientProtocolHandle){

            NdisDeregisterProtocol(&Status, ClientProtocolHandle);

            if(Status != NDIS_STATUS_SUCCESS){

                PsDbgOut(DBG_CRITICAL_ERROR, 
                         DBG_INIT, 
                         ("[InitializationCleanup]: NdisDeregisterProtocol failed - Status 0x%x \n", Status));
            }
        }

    }

    //
    // Deregister with the GPC
    //

    if(ShutdownMask & SHUTDOWN_DEREGISTER_GPC){

        PsAssert(GpcEntries.GpcDeregisterClientHandler);
        Status = GpcEntries.GpcDeregisterClientHandler(GpcQosClientHandle);

        if(Status != GPC_STATUS_SUCCESS){

            PsDbgOut(DBG_CRITICAL_ERROR, 
                     DBG_INIT, 
                     ("[InitializationCleanup]: DeregisterGpc failed - Status %08X\n", 
                      Status));
        }
    }

    //
    // Call the DeInitializeGpc as well, otherwise, FileHandles will leak.
    //
    if (GpcEntries.Reserved) {
        GpcDeinitialize(&GpcEntries);
    }
    
    //
    // free the lookaside list resources
    //

    NdisDeleteNPagedLookasideList( &NdisRequestLL );
    NdisDeleteNPagedLookasideList( &GpcClientVcLL );

    //
    // Free up the components
    //

    NextComponent = PsComponentList.Flink;

    while ( NextComponent != &PsComponentList ) {

        PsComponent = CONTAINING_RECORD( NextComponent, PSI_INFO, Links );

        if(PsComponent->AddIn == TRUE) {

            if(PsComponent->ComponentName.Buffer) {

                PsFreePool(PsComponent->ComponentName.Buffer);
            }

            NextComponent = NextComponent->Flink;

            PsFreePool(PsComponent);
        }
        else {

            NextComponent = NextComponent->Flink;
        }
    }

    //
    // Free up the Profiles 
    //

    NextProfile = PsProfileList.Flink;

    while( NextProfile != &PsProfileList) {

        PsProfile = CONTAINING_RECORD(NextProfile, PS_PROFILE, Links);

        if(PsProfile->ProfileName.Buffer) {
            PsFreePool(PsProfile->ProfileName.Buffer);
        }
        
        NextProfile = NextProfile->Flink;
        PsFreePool(PsProfile);

    }

    if(g_WanLinkTable)
    {
        PsFreePool(g_WanLinkTable);
    }

    if(PsMpName.Buffer)
        PsFreePool(PsMpName.Buffer);

    //
    // Free the locks
    //

    NdisFreeSpinLock(&AdapterListLock);
    NdisFreeSpinLock(&DriverUnloadLock);

    //
    //  TIMESTMP CLEANUP
    //  1. Get rid of all the TS_ENTRYs. Release all the memory allocated for them.
    //  2. Delete the spin lock.
    //
    UnloadConformr();
    UnloadSequencer();
    UnloadPsStub();


    // Free the logging stuff //
#if DBG

    SchedDeInitialize();

#endif

} // InitializationCleanup



/*++

Routine Description:

    This routine returns the timer resolution to the requesting scheduling component.

Arguments:

    TimerResolution - Pointer to location in which to return timer resolution.

Return Values:

    None

--*/
VOID
GetTimerInfo (
    OUT PULONG TimerResolution
    )

{
    // *TimerResolution = gTimerResolutionActualTime;
    *TimerResolution = 0;
} // GetTimerInfo



/*++

Routine Description:

    This routine is the driver unload routine.

Arguments:

    pDriverObject - The DriverObject that is being unloaded

Return Values:

    None

--*/

VOID PSUnload(
    IN PDRIVER_OBJECT pDriverObject)
{
    PADAPTER        Adapter;
    PLIST_ENTRY     NextAdapter;
    NDIS_STATUS     Status;

    PsDbgOut(DBG_INFO,
             DBG_INIT,
             ("[PsUnload]: pDriverObject: %x\n", pDriverObject));

    PS_LOCK(&DriverUnloadLock);

    gDriverState = DriverStateUnloading;

    PS_UNLOCK(&DriverUnloadLock);

    //
    // We wait here till all binds are complete. All future binds are rejected
    //
    NdisWaitEvent(&DriverUnloadEvent, 0);

    //
    // we don't have to close opens from the unload handler. Our call
    // to NdisDeRegisterProtocol will not return until it issues unbinds 
    //

    InitializationCleanup( 0xffffffff );

    PsDbgOut(DBG_INFO, DBG_INIT, (" Unloading psched....\n"));
    
    return;
}

/* end main.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\mpvc.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    mpvc.h

Abstract:

    defines for miniport VC handlers

Author:

    Charlie Wickham (charlwi) 13-Sep-1996

Revision History:

--*/

#ifndef _MPVC_
#define _MPVC_

/* Prototypes */

NDIS_STATUS
MpCreateVc(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE MiniportVcContext
    );

NDIS_STATUS
AddFlowToScheduler(
    IN ULONG                    Operation,
    IN PGPC_CLIENT_VC              Vc,
    IN OUT PCO_CALL_PARAMETERS  NewCallParameters,
    IN OUT PCO_CALL_PARAMETERS  OldCallParameters
    );


NDIS_STATUS
RemoveFlowFromScheduler(
    PGPC_CLIENT_VC Vc
    );

NDIS_STATUS
EmptyPacketsFromScheduler(
    PGPC_CLIENT_VC Vc
    );



NTSTATUS
ModifyBestEffortBandwidth(
    PADAPTER Adapter,
    ULONG BestEffortRate
    );

/* End Prototypes */

#endif /* _MPVC_ */

/* end vc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\mpvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    mpvc.c

Abstract:

    miniport handlers for VC mgmt

Author:

    Charlie Wickham (charlwi)  13-Sep-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

NDIS_STATUS
GetSchedulerFlowContext(
    PGPC_CLIENT_VC AdapterVc
    );

NDIS_STATUS
MpDeactivateVc(
    IN  NDIS_HANDLE             MiniportVcContext
    );

HANDLE
GetNdisFlowHandle (
    IN HANDLE PsFlowContext
    );

/* End Forward */


NDIS_STATUS
AddFlowToScheduler(
    IN ULONG Operation,
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS NewCallParameters,
    IN OUT PCO_CALL_PARAMETERS OldCallParameters
    )

/*++

Routine Description:

    Add the Vc to the scheduler.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                    Adapter = Vc->Adapter;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PCO_CALL_MANAGER_PARAMETERS NewCmParams;
    PCO_CALL_MANAGER_PARAMETERS OldCmParams;
    SERVICETYPE                 ServiceType;
    ULONG                       ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    ULONG                       OriginalTokenRate;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) AddFlowToScheduler\n", 
             Vc));


    NewCmParams = NewCallParameters->CallMgrParameters;
    ServiceType = NewCmParams->Transmit.ServiceType;

    //
    // We might need to change the rate at which the scheduling components shape the packet.
    //
    OriginalTokenRate = NewCmParams->Transmit.TokenRate;
    NewCmParams->Transmit.TokenRate = Vc->ShapeTokenRate;

    //
    // Is this a new VC? or a modification of an existing VC?
    //

    PS_LOCK(&Adapter->Lock);

    if(Operation == NEW_VC){

        PsAssert(!OldCallParameters);

        //
        // New Vc.
        //
        // Check the type of service we're activating. If best 
        // effort and we're limiting total best effort bandwidth,
        // and it's not our internal best effort vc, then we don't 
        // want to add the flow in the scheduler.
        //


        if((ServiceType == SERVICETYPE_BESTEFFORT) &&
           (Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
           !IsBestEffortVc(Vc)){

            PS_UNLOCK(&Adapter->Lock);

            //
            // Just merge the VC into the internal, existing best 
            // effort VC. The internal best-effort VC is created 
            // internally without calling AddFlowToScheduler.
            //
            // Give this VC the same flow context as our internal. 
            // The scheduler then thinks it is all the same VC
            //

            if(Adapter->MediaType == NdisMediumWan) {

                Vc->PsFlowContext = Vc->WanLink->BestEffortVc.PsFlowContext;

            }
            else {

                Vc->PsFlowContext = Adapter->BestEffortVc.PsFlowContext;
            }

            Status = NDIS_STATUS_SUCCESS;
        }
        else{

            //
            // Need to actually create a new flow in the scheduler.
            // first allocate the flow context buffer
            //

            PS_UNLOCK(&Adapter->Lock);

            Status = GetSchedulerFlowContext(Vc);

            if(Status != NDIS_STATUS_SUCCESS){

                goto Exit;
            }

            Status = (*Vc->PsComponent->CreateFlow)(
                        Vc->PsPipeContext,
                        Vc,
                        NewCallParameters,
                        Vc->PsFlowContext);

        } 
    }
    else{

        //
        // Must be a modify. Check old params.

        OldCmParams = OldCallParameters->CallMgrParameters;

        //
        // If BestEffortLimit != UNSPECIFIED_RATE, then there
        // are two special cases we have to handle:
        //
        // 1. A non-private flow, created for SERVICETYPE_BESTEFFORT
        //      is being modified to a ServiceType other than best-effort.
        //
        // 2. A non-private flow, created for a ServiceType other 
        //      than best-effort, is now being modified to best-effort.
        //
        // In the first case, we have to call the scheduler to 
        // create a flow, since previously the client's flow was
        // just merged with a single best-effort flow.
        //
        // In the second case, we have to close the flow that existed
        // and remap the client's flow to the single best-efort flow,
        // thereby merging the client's flow with the existing b/e
        // flow.
        //

        if((Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
           (OldCmParams->Transmit.ServiceType == SERVICETYPE_BESTEFFORT) &&
           (NewCmParams->Transmit.ServiceType != SERVICETYPE_BESTEFFORT)){

            //
            // Unmerge
            //

            PS_UNLOCK(&Adapter->Lock);

            Status = GetSchedulerFlowContext(Vc);

            if(Status != NDIS_STATUS_SUCCESS){

                goto Exit;
            }

            Status = (*Vc->PsComponent->CreateFlow)(
                      Vc->PsPipeContext,
                      Vc,
                      NewCallParameters,
                      Vc->PsFlowContext);

        }
        else{

            if((Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
               (OldCmParams->Transmit.ServiceType != SERVICETYPE_BESTEFFORT) &&
               (NewCmParams->Transmit.ServiceType == SERVICETYPE_BESTEFFORT)){

                // 
                // Merge
                //

                PS_UNLOCK(&Adapter->Lock);

                (*Vc->PsComponent->DeleteFlow)( 
                          Vc->PsPipeContext, 
                          Vc->PsFlowContext);

                Vc->PsFlowContext = Adapter->BestEffortVc.PsFlowContext;

                Status = NDIS_STATUS_SUCCESS;
            }
            else{

                PS_UNLOCK(&Adapter->Lock);

                Status = (*Vc->PsComponent->ModifyFlow)(
                          Vc->PsPipeContext,
                          Vc->PsFlowContext,
                          NewCallParameters);

            }
        }

    } // Modify

Exit:

    //
    // Revert the call parameters.
    //
    NewCmParams->Transmit.TokenRate = OriginalTokenRate;

    return(Status);

} // AddFlowToScheduler 


NDIS_STATUS
GetSchedulerFlowContext(
    PGPC_CLIENT_VC AdapterVc
    )

/*++

Routine Description:

    Allocate the pipe context area for the scheduler.

Arguments:

    AdapterVc- pointer to adapter VC context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    PADAPTER Adapter = AdapterVc->Adapter;
    NDIS_STATUS Status;
    PPSI_INFO *SchedulerConfig;
    PPSI_INFO PsComponent = AdapterVc->PsComponent;
    ULONG ContextLength = 0;
    ULONG FlowContextLength = 0;
    ULONG Index = 0;
    PPS_PIPE_CONTEXT PipeContext = AdapterVc->PsPipeContext;
    PPS_FLOW_CONTEXT FlowContext;
    PPS_FLOW_CONTEXT PrevContext;

    //
    // The length of the flow context buffer for this pipe was calculated
    // when the pipe was initialized.
    //

    PsAllocatePool(AdapterVc->PsFlowContext, 
                   Adapter->FlowContextLength, 
                   FlowContextTag );

    if ( AdapterVc->PsFlowContext == NULL ) {

        return NDIS_STATUS_RESOURCES;
    }

    // Set up the context buffer

    FlowContext = (PPS_FLOW_CONTEXT)AdapterVc->PsFlowContext;
    PrevContext = NULL;

    while (PsComponent != NULL) {

        FlowContext->NextComponentContext = (PPS_FLOW_CONTEXT)
            ((UINT_PTR)FlowContext + PsComponent->FlowContextLength);
        FlowContext->PrevComponentContext = PrevContext;

        PsComponent = PipeContext->NextComponent;
        PipeContext = PipeContext->NextComponentContext;

        PrevContext = FlowContext;
        FlowContext = FlowContext->NextComponentContext;
    }

    return NDIS_STATUS_SUCCESS;

} // GetSchedulerFlowContext





NDIS_STATUS
EmptyPacketsFromScheduler(
    PGPC_CLIENT_VC Vc    
    )

/*++

Routine Description:

	Cleans up (DROPS) the pending packets on this Vc in each of the components 
	
--*/

{
    PADAPTER Adapter = Vc->Adapter;
    NDIS_STATUS Status;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) EmptyPacketsFromScheduler\n", Vc));


    if(Adapter->MediaType == NdisMediumWan) {

        if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Vc->WanLink->BestEffortVc){
                
                (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }

    }
    else {

        if(Vc->PsFlowContext != Adapter->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Adapter->BestEffortVc){
                
                (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }
    }
        
    return NDIS_STATUS_SUCCESS;

} 




NDIS_STATUS
RemoveFlowFromScheduler(
    PGPC_CLIENT_VC Vc    
    )

/*++

Routine Description:

    Notify the PSA that the flow is going away

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = Vc->Adapter;
    NDIS_STATUS Status;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) RemoveFlowFromScheduler\n", Vc));

    //
    // if this is a user vc which is merged into the scheduler's 
    // internal best effort flow, then delete the vc without affecting 
    // the scheduler. if it is not, then remove it from the scheduler
    // and delete the vc.
    //

    if(Adapter->MediaType == NdisMediumWan) {

        if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Vc->WanLink->BestEffortVc){
                
                (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }

    }
    else {

        if(Vc->PsFlowContext != Adapter->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Adapter->BestEffortVc){
                
                (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }
    }
        
    return NDIS_STATUS_SUCCESS;

} // RemoveFlowFromScheduler


NTSTATUS
ModifyBestEffortBandwidth(
    PADAPTER Adapter,
    ULONG BestEffortRate)
{
    PCO_CALL_PARAMETERS CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParameters;
    ULONG CallParamsLength;
    PGPC_CLIENT_VC Vc;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);
    Vc = &Adapter->BestEffortVc;
    CheckLLTag(Vc, GpcClientVc);
 
    //
    // This handles a TC API request to modify the default 
    // best-effort bandwidth.  Note that the b/e bandwidth 
    // can only be modified if the PS is in limited b/e mode.
    //
    // Also - note that the b/e bandwidth can only be modified 
    // while the adapter is in the Running state. We do not
    // have to worry about locking the VC since the b/e VC 
    // will not be manipulated while it is in the running state
    // except by this thread.
    //

    PS_LOCK(&Adapter->Lock);
    
    if((Adapter->BestEffortLimit == UNSPECIFIED_RATE))
    {
        PS_UNLOCK(&Adapter->Lock);
        return(STATUS_WMI_NOT_SUPPORTED);
    }

    if((BestEffortRate > Adapter->LinkSpeed) ||
       (BestEffortRate == 0)){

        PS_UNLOCK(&Adapter->Lock);
        return(STATUS_INVALID_PARAMETER);
    }
    else{

        if(Adapter->PsMpState != AdapterStateRunning){

            PS_UNLOCK(&Adapter->Lock);
            return(STATUS_WMI_NOT_SUPPORTED);
        }

        CallParamsLength = sizeof(CO_CALL_PARAMETERS) +
                           sizeof(CO_CALL_MANAGER_PARAMETERS) +
                           sizeof(QOS_SD_MODE) +
                           sizeof(QOS_OBJECT_HDR);

        PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

        if(CallParams == NULL){

            PS_UNLOCK(&Adapter->Lock);
            PsDbgOut(DBG_FAILURE, DBG_VC,
                    ("ModifyBestEffortBandwidth: can't allocate call parms\n"));

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // build a call params struct describing the flow
        //

        CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);

        NdisFillMemory(CallParams,
                       CallParamsLength,
                       (UCHAR)QOS_UNSPECIFIED);

        CallParams->Flags = 0;
        CallParams->CallMgrParameters = CallMgrParameters;
        CallParams->MediaParameters = NULL;

        FillInCmParams(CallMgrParameters,
                       SERVICETYPE_BESTEFFORT,
                       BestEffortRate,
                       (ULONG)UNSPECIFIED_RATE,
                       Adapter->TotalSize,
                       TC_NONCONF_SHAPE,
                       QOS_UNSPECIFIED);

        Status = (*Vc->PsComponent->ModifyFlow)(
                  Vc->PsPipeContext,
                  Vc->PsFlowContext,
                  CallParams);

        if(Status == NDIS_STATUS_SUCCESS){

            Adapter->BestEffortLimit = BestEffortRate;
        }

        PS_UNLOCK(&Adapter->Lock);

        PsFreePool(CallParams);

        return(Status);
    }
}
        



/* end mpvc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\osdep.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    osdep.h

Abstract:

    defines for OS specific routines

Author:

    Charlie Wickham (charlwi) 17-Sep-1996

Revision History:

--*/

#ifndef _OSDEP_
#define _OSDEP_

//
// shortest timer period in 100 ns units
//

#define TIMER_GRANULARITY    10000

#endif /* _OSDEP_ */

/* end osdep.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\ndisreq.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ndisreq.h

Abstract:

    defines for NdisRequest related routines

Author:

    Charlie Wickham (charlwi) 01-May-1996

Revision History:

--*/

#ifndef _NDISREQ_
#define _NDISREQ_

//
// Private OIDs that are used by psched
//

#define NDIS_STATUS_INTERFACE_CHANGE                0xFF000001

#if DBG
#define OID_QOS_LOG_BUFFER_SIZE                     0xFF010100
#define OID_QOS_LOG_THRESHOLD                       0xFF010101
#define OID_QOS_LOG_DATA                            0xFF010102
#define OID_QOS_LOG_MASK                            0xFF010105
#define OID_QOS_LOG_LEVEL                           0xFF010106
#define QOS_STATUS_LOG_THRESHOLD                    0xFF00000A
#endif

#define OID_QOS_MAX_OUTSTANDING_SENDS               0xFF010103
#define OID_QOS_DISABLE_DRR                         0xFF010104

/* Prototypes */ /* Generated by Emacs 19.17.0 on Mon May 06 15:54:14 1996 */

VOID
PsScheduleInterfaceIdWorkItem(
    IN PADAPTER     Adapter,
    IN PPS_WAN_LINK WanLink
    );

VOID
ClRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    );

NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    );


NDIS_STATUS
MpQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );


NDIS_STATUS
MpSetInformation( 
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    );

VOID
TcIndicateInterfaceChange(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN NDIS_STATUS Status
    );

NDIS_STATUS
CollectWanNetworkAddresses(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN OUT ULONG *Len,
    IN PVOID Data);


NDIS_STATUS
CollectNetworkAddresses(
    IN PADAPTER Adapter,
    IN OUT ULONG *Len,
    IN PVOID Data
    );

#if DBG
VOID
IndicateLogThreshold(
    IN PVOID Context
    );
#endif
/* End Prototypes */

#endif /* _NDISREQ_ */

/* end ndisreq.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\psstub.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    PsStub.h

Abstract:

    Defines for scheduling stub

Author:


Revision History:

--*/

#ifndef _PSSTUB_H_
#define _PSSTUB_H_

#include "PktSched.h"

VOID
InitializeSchedulerStub(
    PPSI_INFO Info);

void
UnloadPsStub();

#endif /* _PSSTUB_H_ */

/* end PsStub.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\psched.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    psched.h

Abstract:



Author:

    Charlie Wickham (charlwi) 22-Apr-1996

Revision History:

--*/

#ifndef _PSCHED_
#define _PSCHED_

#include <ntosp.h>
#include <windef.h>

#include <ndis.h>
#include <zwapi.h>
#include <ndis.h>
#include <ntddndis.h>
#include <wmistr.h>

#include <traffic.h>
#include <tcerror.h>
#include <gpcifc.h>
#include <ntddtc.h>

#include <cxport.h>
#include <ip.h>

#include "osdep.h"
#include "stdlib.h"
#include "stdio.h"
#include "stdarg.h"


typedef unsigned char       BYTE,  *PBYTE;
typedef unsigned long       DWORD, *PDWORD;
#include <llinfo.h>
#include <ddwanarp.h>
#include <ntddip.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include "refcnt.h"
#include "ntddpsch.h"
#include "debug.h"      // order dependent
#include "pktsched.h"
#include "globals.h"
#include "main.h"
#include "adapter.h"
#include "ndisreq.h"
#include "send.h"
#include "recv.h"
#include "config.h"
#include "stats.h"
#include "status.h"
#include "mpvc.h"
#include "cmvc.h"
#include "pstub.h"
#include "schedt.h"
#include "Conformr.h"
#include "drrSeq.h"
#include "psstub.h"
#include "gpchndlr.h"
#include "wansup.h"
#include "clstate.h"
#include "wmi.h"
#include "timestmp.h"

/* Prototypes */
/* End Prototypes */

#endif /* _PSCHED_ */

/* end psched.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\pstub.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    pstub.c

Abstract:

    Stubs for protocol routines

Author:

    Charlie Wickham (charlwi)  22-Apr-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.17.0 on Wed May 08 10:48:06 1996 */

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

/* End Forward */

NDIS_STATUS
ClPnPEventHandler(
    IN NDIS_HANDLE Handle,
    IN PNET_PNP_EVENT NetPnPEvent
    )
{
    PADAPTER                 Adapter     = (PADAPTER) Handle;
    PNDIS_DEVICE_POWER_STATE DeviceState = (PNDIS_DEVICE_POWER_STATE) (NetPnPEvent->Buffer);
    NDIS_DEVICE_POWER_STATE  PrevDeviceState;
    NDIS_STATUS              PnPStatus, Status;
    ULONG                    Count;

    PnPStatus = NDIS_STATUS_SUCCESS;
    
    switch(NetPnPEvent->NetEvent)
    {
      case NetEventSetPower:

        PsStructAssert(Adapter);
        PrevDeviceState        = Adapter->PTDeviceState;
        Adapter->PTDeviceState = *DeviceState;
        
        //
        // if we are being sent to standby, block outstanding requests and sends
        //

        if(*DeviceState > NdisDeviceStateD0)
        {
            //
            // For state transistion to > D0, we have to pass the request up before doing anything.
            //

            if(Adapter->PsNdisHandle)
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }

            //
            // If the physical miniport is going to standby, fail all incoming requests.
            //

            if(PrevDeviceState == NdisDeviceStateD0)
            {
                Adapter->StandingBy = TRUE;
            }

            // 
            // Wait till Oustanding IO on the binding completes. 
            //
            do
            {
                Status = NdisQueryPendingIOCount(Adapter->LowerMpHandle, &Count);

                if(Status == NDIS_STATUS_SUCCESS && Count != 0)
                {
                    NdisMSleep(10);
                }
                else 
                {
                    break;
                }

            } while(TRUE);

            PsAssert(Adapter->OutstandingNdisRequests == 0);
        }
        else 
        {
            //
            // If the physical miniport is powering up (from low power state to D0), clear the flag.
            //

            if(PrevDeviceState > NdisDeviceStateD0)
            {
                Adapter->StandingBy = FALSE;
            }

            // This is where we originate the pended ndis requests.
            if(Adapter->PendedNdisRequest)
            {
                PNDIS_REQUEST PendedRequest = (PNDIS_REQUEST) Adapter->PendedNdisRequest;
                Adapter->PendedNdisRequest = NULL;

                NdisRequest(&Status, Adapter->LowerMpHandle, PendedRequest);
                if(NDIS_STATUS_PENDING != Status)
                {
                    ClRequestComplete(Adapter, PendedRequest, Status);
                }
            }
    
            // Update link speed.
            if(IsDeviceStateOn(Adapter))
            {
                PsGetLinkSpeed(Adapter);
            }

            //
            // For state transistion to D0, we have to pass the request after doing our work.
            //

            if(Adapter->PsNdisHandle) 
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }

        }

        break;

      case NetEventReconfigure:

        if(Adapter == NULL)
        {
            NdisReEnumerateProtocolBindings(ClientProtocolHandle);
        }
        else 
        {
            //
            // For all other events, pass the request before doing anything.
            //
            if(Adapter->PsNdisHandle)
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }
        }

        break;

      default:    

        //
        // For all other events, pass the request before doing anything.
        //

        if(Adapter && Adapter->PsNdisHandle) 
        {
            PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
        }
        break;
    }

    return(PnPStatus);
}

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for NdisReset

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert( Adapter );

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("(%08X) ClResetComplete: Status = %08x\n",
                                       Adapter, Status));
}

VOID
ClCoStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID StatusBuffer,
    IN  UINT StatusBufferSize
    )
{
    PsDbgOut(DBG_TRACE,
             DBG_PROTOCOL,
             ("(%08X) PcStatusIndication: %08X\n",
              ProtocolBindingContext, GeneralStatus));

    return;
}


VOID
ClCoAfRegisterNotifyHandler(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      PCO_ADDRESS_FAMILY              AddressFamily
        )
{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert( Adapter );

    if(AddressFamily->AddressFamily == CO_ADDRESS_FAMILY_PPP)
    {
        OpenWanAddressFamily(Adapter, AddressFamily);
    }

}

/* end pstub.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\ndisreq.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ndisreq.c

Abstract:

    routines for passing NdisRequests up and down

Author:

    Charlie Wickham (charlwi)  01-May-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */


const UCHAR  gDriverDescription[] = " (Microsoft's Packet Scheduler) ";

/* Forward */ /* Generated by Emacs 19.17.0 on Mon May 06 15:54:11 1996 */

VOID
MpQueryPnPCapabilities( 
    IN OUT PPS_NDIS_REQUEST PsReqBuffer,
    IN OUT PADAPTER         pAdapt, 
    OUT PNDIS_STATUS        pStatus
    );

NDIS_STATUS
MakeNdisRequest(
    IN  PADAPTER Adapter,
    IN  NDIS_HANDLE VcHandle,
    IN  NDIS_REQUEST_TYPE RequestType,
    IN  NDIS_OID Oid,
    IN  PVOID InformationBuffer,
    IN  ULONG InformationBufferLength,
    OUT PULONG BytesReadOrWritten,
    OUT PULONG BytesNeeded,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc
    );

VOID
ClRequestComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  PNDIS_REQUEST NdisRequest,
    IN  NDIS_STATUS Status
    );

NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    );

NDIS_STATUS
RecordNetworkAddressList(
    IN PADAPTER Adapter,
    IN PPS_NDIS_REQUEST PsRequestBuffer
    );

ULONG
GetSizeAddrList(
    IN NETWORK_ADDRESS_LIST UNALIGNED *AddrList
    );

/* End Forward */

NTSTATUS
DoIpIoctl(
          IN  PWCHAR        DriverName,
          IN  DWORD         Ioctl,
          IN  PVOID         pvInArg,
          IN  DWORD         dwInSize,
          IN  PVOID         pvOutArg,
          IN  DWORD         dwOutSize)
/*++
Routine Description:
    Do an IOCTL to the stack. Used for a varity of purposes
--*/
{
    NTSTATUS                status;
    UNICODE_STRING          nameString;
    OBJECT_ATTRIBUTES       Atts;
    IO_STATUS_BLOCK         ioStatusBlock;
    HANDLE                  Handle;
    
    PAGED_CODE();

    RtlInitUnicodeString(&nameString, DriverName);
        
    InitializeObjectAttributes(&Atts,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
             
   status = ZwCreateFile(&Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &Atts,
                         &ioStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         0,
                         NULL,
                         0);

    if (!NT_SUCCESS(status))
    {
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Submit the request to the forwarder
    //
        
    status = ZwDeviceIoControlFile(
                      Handle,
                      NULL,
                      NULL,
                      NULL,
                      &ioStatusBlock,
                      Ioctl,
                      pvInArg,
                      dwInSize,
                      pvOutArg,
                      dwOutSize);
                      
    //
    // Close the device.
    //
    
    ZwClose(Handle);
    
    return status;
}

//
// This function uses one of the IP Addresses on the adapter to get the Interface Index of the 
// adapter. This function is called when IP updates the addresses on the interface. It uses this
// address and the IpHlpAPI and obtains the InterfaceID.
//
// For WanLinks, the InterfaceID is a set of 2 ULONGS - One identifies the InterfaceIndex as above
// and the other ULONG is the remote address of the server. 
//
//

VOID SetInterfaceIndex(PNDIS_WORK_ITEM pWorkItem, PVOID pWorkItemContext)
{
    PPS_INTERFACE_INDEX_CONTEXT        pInterfaceContext = (PPS_INTERFACE_INDEX_CONTEXT) pWorkItemContext;
    PTC_INTERFACE_ID                   pInterfaceID;
    IO_STATUS_BLOCK                    IoStatus;
    KEVENT                             LocalEvent;
    PIRP                               Irp;
    IPAddrEntry                        *pIpAddrTbl;
    ULONG                              k, OutBufferSize;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    DWORD                              Status, dwInBufLen, dwOutBufLen;
    BYTE                               *Context;
    ULONG                              IpAddr, IpAddrCount;
    INT                                n;
    NETWORK_ADDRESS  UNALIGNED         *pAddr;
    IPSNMPInfo                         IPSnmpInfo;

    PS_LOCK(&pInterfaceContext->Adapter->Lock);

    if(pInterfaceContext->Adapter->MediaType == NdisMediumWan)
    {
        pInterfaceID = &pInterfaceContext->WanLink->InterfaceID;
        pInterfaceID->LinkId = 0;
        IpAddr = pInterfaceContext->WanLink->LocalIpAddress;

        if(pInterfaceContext->WanLink->DialUsage != DU_CALLOUT)
            pInterfaceID->LinkId = pInterfaceContext->WanLink->RemoteIpAddress;
    }
    else 
    {
        pInterfaceID = &pInterfaceContext->Adapter->InterfaceID;
        pInterfaceID->LinkId = 0;
        pAddr = (NETWORK_ADDRESS UNALIGNED *)&pInterfaceContext->Adapter->IpNetAddressList->Address[0];

        for(n=0; n<pInterfaceContext->Adapter->IpNetAddressList->AddressCount; n++)
        {
            NETWORK_ADDRESS_IP UNALIGNED *pIpNetAddr;
    
            if(pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
            {
                pIpNetAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];
                IpAddr = pIpNetAddr->in_addr;
                break;
            }
        
            pAddr = (NETWORK_ADDRESS UNALIGNED *)(((PUCHAR)pAddr)
                                       + pAddr->AddressLength
                                       + FIELD_OFFSET(NETWORK_ADDRESS, Address));
        }

        if(n == pInterfaceContext->Adapter->IpNetAddressList->AddressCount)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: No Ip Addresses \n"));
            PS_UNLOCK(&pInterfaceContext->Adapter->Lock);
            goto Done;
        }

    }

    PS_UNLOCK(&pInterfaceContext->Adapter->Lock);

    //
    // Initialize parameters for sending the IO Request
    //

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_STATS_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    NdisZeroMemory(Context,CONTEXT_SIZE);

    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IPSNMPInfo);

    Status = DoIpIoctl(DD_TCP_DEVICE_NAME,
                       IOCTL_TCP_QUERY_INFORMATION_EX,
                       (PVOID) &trqiInBuf,
                       sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                       (PVOID)&IPSnmpInfo,
                       dwOutBufLen);

    if(NT_SUCCESS(Status))
    {

        //
        // Allocate the output buffer and send the I/O request. 
        //

        IpAddrCount = IPSnmpInfo.ipsi_numaddr + 10;
        dwOutBufLen = IpAddrCount * sizeof(IPAddrEntry);
        PsAllocatePool(pIpAddrTbl, dwOutBufLen, PsMiscTag);
    
        if(!pIpAddrTbl)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: Could not allocate memory for %d addresses \n", 
                     IPSnmpInfo.ipsi_numaddr + 10));

            goto Done;
    
        }

        NdisZeroMemory(pIpAddrTbl, dwOutBufLen);
   
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id   = IP_MIB_ADDRTABLE_ENTRY_ID;
        RtlZeroMemory(Context, CONTEXT_SIZE); 

        Status = DoIpIoctl(DD_TCP_DEVICE_NAME,
                           IOCTL_TCP_QUERY_INFORMATION_EX,
                           (PVOID) &trqiInBuf,
                           sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                           (PVOID)pIpAddrTbl,
                           dwOutBufLen);

        if(!NT_SUCCESS(Status))
        {

            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: IOCTL_TCP_QUERY_INFORMATION_EX failed with 0x%x \n", Status));
    
            PsFreePool(pIpAddrTbl);
            goto Done;
        }
    }
    else 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_PROTOCOL,
                 ("[SetInterfaceIndex]: DoIpIoctl failed with 0x%x \n", Status));
        goto Done;

    }
    
    //
    // search for the matching IP address to IpAddr
    // in the table we got back from the stack
    //
    
    for (k = 0; k < IpAddrCount; k++) {
        
        if (pIpAddrTbl[k].iae_addr == IpAddr) {
            
            //
            // found one, get the index
            //

            PS_LOCK(&pInterfaceContext->Adapter->Lock);
            pInterfaceID->InterfaceId = pIpAddrTbl[k].iae_index;
            PS_UNLOCK(&pInterfaceContext->Adapter->Lock);
            break;
        }
    }
    
    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL,
             ("[SetInterfaceIndex]: InterfaceID (0x%x:0x%x) \n", pInterfaceID->InterfaceId, pInterfaceID->LinkId));

    PsFreePool(pIpAddrTbl);

Done:

    if(pInterfaceContext->Adapter->MediaType == NdisMediumWan)
        REFDEL(&pInterfaceContext->WanLink->RefCount, FALSE, 'IOTL');

    REFDEL(&pInterfaceContext->Adapter->RefCount, FALSE, 'IOTL');

    PsFreePool(pWorkItem);
    PsFreePool(pWorkItemContext);

    return;
}

VOID PsScheduleInterfaceIdWorkItem(PADAPTER Adapter, PPS_WAN_LINK WanLink)
{
    PPS_INTERFACE_INDEX_CONTEXT pContext;
    NDIS_STATUS WorkItemStatus;
    PNDIS_WORK_ITEM pWorkItem;

    PsAllocatePool(pContext, sizeof(PS_INTERFACE_INDEX_CONTEXT), PsMiscTag);

    if(pContext)
    {
        PsAllocatePool(pWorkItem, sizeof(NDIS_WORK_ITEM), PsMiscTag);
        if(pWorkItem)
        {
            NdisInitializeWorkItem(pWorkItem, SetInterfaceIndex, pContext);
            pContext->Adapter = Adapter;
            pContext->WanLink = WanLink;

            // 
            // We have to make sure that the adapter and the wanlink are around when the WorkItem fires. 
            // The adapter and wanlink are valid at this point (see below), but there are no guarantees that
            // they will be around when the work item fires.
            //
            // 1. For LAN bindings, this function is called from the ClRequestComplete thread. The NDIS
            //    request has not yet been completed. Hence we can never have an invalid Adapter context here.
            //
            // 2. For WAN links, this function is called from the WAN_LINE_UP thread. Again, the WanLink
            //    cannot be invalid because it is called from the context of the line-up thread.
            //

            if(Adapter)
            {
                REFADD(&Adapter->RefCount, 'IOTL');
            }

            if(WanLink)
            {
                REFADD(&WanLink->RefCount, 'IOTL');
            }

            if((WorkItemStatus = NdisScheduleWorkItem(pWorkItem)) != NDIS_STATUS_SUCCESS)

            {
                PsDbgOut(DBG_TRACE, 
                         DBG_PROTOCOL, 
                         ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, NdisScheduleWorkItem failed 0x%x\n", 
                          Adapter, WorkItemStatus));

                if(WanLink)
                    REFDEL(&WanLink->RefCount, FALSE, 'IOTL');

                if(Adapter)
                    REFDEL(&Adapter->RefCount, FALSE, 'IOTL');

                PsFreePool(pContext);
                PsFreePool(pWorkItem);
            }
        }
        else 
        {
            PsDbgOut(DBG_TRACE, 
                     DBG_PROTOCOL, 
                     ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, No memory to allocate Work Item \n", Adapter));

            PsFreePool(pContext);
        }
    }
    else 
    {
      PsDbgOut(DBG_TRACE, 
               DBG_PROTOCOL, 
               ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, No memory to allocate Work Item context \n", Adapter));
    
    }
}


NDIS_STATUS
MakeNdisRequest(
        IN  PADAPTER                              Adapter,
        IN  NDIS_HANDLE                           VcHandle,
        IN  NDIS_REQUEST_TYPE                     RequestType,
        IN  NDIS_OID                              Oid,
        IN  PVOID                                 InformationBuffer,
        IN  ULONG                                 InformationBufferLength,
        OUT PULONG                                BytesReadOrWritten,
        OUT PULONG                                BytesNeeded,
        IN  LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc
        )

/*++

Routine Description:

    common handler for set and query  information, local ndis request, and
    corequest routines. An NDIS_REQUEST is built and issued to the underlying MP

Arguments:

    See the DDK...

    CompletionFunc - pointer to a function that gets called when the request
        completion handler has been called. Only used for local requests.

    RequestType also includes NdisRequestLocal{Set,Query}Info which is used
    to indicate a local request meaning the request is originated by the
    packet scheduler and needs no further completion

Return Values:

    return the value returned to us by the underlying adapter

--*/

{
    PPS_NDIS_REQUEST PsReqBuffer;
    NDIS_STATUS Status;

    PsAllocFromLL(&PsReqBuffer, &NdisRequestLL, NdisRequest);

    if(PsReqBuffer == NULL){
        
        if(RequestType == NdisRequestLocalQueryInfo || RequestType == NdisRequestLocalSetInfo)
        {
            PsFreePool(BytesReadOrWritten);
            PsFreePool(BytesNeeded);
        }

        return NDIS_STATUS_RESOURCES;
    }
    else 
        NdisZeroMemory(&PsReqBuffer->ReqBuffer, sizeof(NDIS_REQUEST));
        

    if(RequestType == NdisRequestSetInformation ||
       RequestType == NdisRequestLocalSetInfo){

        PsReqBuffer->ReqBuffer.RequestType = NdisRequestSetInformation;
        PsReqBuffer->LocalRequest = ( RequestType == NdisRequestLocalSetInfo );
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.Oid = Oid;
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBuffer = 
                                                        InformationBuffer;
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBufferLength = 
                                                        InformationBufferLength;

    }
    else{

        PsAssert(RequestType == NdisRequestQueryInformation ||
                 RequestType == NdisRequestLocalQueryInfo ||
                 RequestType == NdisRequestQueryStatistics);

        if(RequestType != NdisRequestQueryStatistics){
            PsReqBuffer->ReqBuffer.RequestType = NdisRequestQueryInformation;
            PsReqBuffer->LocalRequest = 
                        (RequestType == NdisRequestLocalQueryInfo);
        }
        else
        {
            PsReqBuffer->ReqBuffer.RequestType = NdisRequestQueryStatistics;
            PsReqBuffer->LocalRequest = 0;
        }

        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.Oid = Oid;
        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer = 
                                                    InformationBuffer;
        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength =
                                                    InformationBufferLength;

    }

    //
    // store the pointers to BytesReadOrWritten and BytesNeeded so they can be
    // updated in the completion routine if necessary. Save the completion func
    //

   