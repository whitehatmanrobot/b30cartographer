    RRETURN( hr );
}

HRESULT
CSelectionManager::HideCaret()
{
    RRETURN( CCaretTracker::SetCaretVisible( GetDoc(), FALSE ));
}

HRESULT 
CSelectionManager::AttachFocusHandler()
{
    HRESULT hr = S_OK ;

    VARIANT_BOOL varAttach = VB_TRUE;
    
    SP_IHTMLWindow2 spWindow2;
    SP_IDispatch    spDisp;
    
    BSTR bstrFocusEvent = ::SysAllocString(_T("onfocus"));
    BSTR bstrBlurEvent  = ::SysAllocString(_T("onblur"));
    Assert( ! _pIFocusWindow );
    
    IFC( _pFocusHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));    
    IFC( GetDoc()->get_parentWindow( & spWindow2));
    IFC( spWindow2->QueryInterface( IID_IHTMLWindow3, (void**) & _pIFocusWindow ));

    IFC( _pIFocusWindow->attachEvent(bstrFocusEvent , spDisp, & varAttach));
    Assert( varAttach == VB_TRUE );
    
    IFC( _pIFocusWindow->attachEvent(bstrBlurEvent, spDisp , & varAttach));
    Assert( varAttach == VB_TRUE );

    _fFocusHandlerAttached = TRUE ;

Cleanup:
    ::SysFreeString(bstrFocusEvent);
    ::SysFreeString(bstrBlurEvent);
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachFocusHandler()
{
    HRESULT hr = S_OK ;

    BSTR bstrFocusEvent = ::SysAllocString(_T("onfocus"));
    BSTR bstrBlurEvent  = ::SysAllocString(_T("onblur"));

    if (_fFocusHandlerAttached)
    {
        Assert( _pIFocusWindow );
        
        SP_IHTMLWindow3 spWindow3;
        SP_IHTMLWindow2 spWindow2;
        SP_IDispatch    spDisp;
        
        IFC( _pFocusHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));        

        IFC( _pIFocusWindow->detachEvent(bstrFocusEvent, spDisp ));   
        IFC( _pIFocusWindow->detachEvent(bstrBlurEvent , spDisp ));

        ClearInterface( & _pIFocusWindow );
        _fFocusHandlerAttached = FALSE ;
    }

Cleanup:
    ::SysFreeString(bstrFocusEvent);
    ::SysFreeString(bstrBlurEvent);

    RRETURN( hr );
}

HRESULT
CSelectionManager::RebubbleEvent( CEditEvent* pEvent )
{
    HRESULT hr;

    WHEN_DBG( _ctEvtLoop++ );
#ifndef _PREFIX_
    AssertSz( _ctEvtLoop == 1,"Recursive Rebubble Event calls");    
#endif

    hr = THR( _pActiveTracker->HandleEvent( pEvent ));

    WHEN_DBG( _ctEvtLoop -- );
    
    RRETURN1( hr, S_FALSE);
}


inline HRESULT
CFocusHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    IHTMLEventObj *pObj=NULL;
    BOOL fValidEvent = FALSE;
    SP_IHTMLDocument4 spDoc4;
    VARIANT_BOOL vbFocus;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) );
            if ( pObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor() );
                IFC( evt.Init( pObj ));

                IFC( _pMan->GetDoc()->QueryInterface( IID_IHTMLDocument4, (void**) & spDoc4 ));
                IFC( spDoc4->hasFocus( & vbFocus ));
                //
                // for Nav compat - we can have window.onBlur - that don't correspond to WM_KILLFOCUS
                // we have to do this magic - to distinguish between the bogus onblurs' and a "real" onblur
                //
                
                switch( evt.GetType() )
                {
                    case EVT_KILLFOCUS:
                        fValidEvent = vbFocus == VB_FALSE ;                    
                        break;
                        
                    case EVT_SETFOCUS:

                        fValidEvent = vbFocus == VB_TRUE  ;
                        break;                
                        
                    default:
                        AssertSz(0,"Unexpected event");
                }

                if ( fValidEvent )
                {
                    IFC( _pMan->HandleEvent( & evt ));                         
                }
            }
        }
    }
    
Cleanup:
    ReleaseInterface( pObj );
    
    return S_OK; // Attach Events expects this.
}


BOOL
CSelectionManager::CaretInPre()
{
    Assert( _pCaretTracker);
    if ( GetDisplayServices() )
    {
        SP_IHTMLCaret spCaret;    
        IGNORE_HR( GetDisplayServices()->GetCaret( & spCaret ));
        return _pCaretTracker->IsCaretInPre( spCaret );
    }
    return FALSE;
}

HRESULT
CSelectionManager::ContainsSelectionAtBrowse( IHTMLElement* pIElement )
{
    HRESULT hr;
    ELEMENT_TAG_ID eTag;
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));

    switch( eTag )
    {
        case TAGID_BODY:
        case TAGID_INPUT:
        case TAGID_TEXTAREA:
            hr = S_OK;
            break;
            
        default:
        {
            //
            // If we are not editable, and our parent is editable, then we treat this element
            // like it is at browse time, and we need to contain selection
            //
            if( (IsEditable( pIElement ) == S_FALSE) &&
                (EdUtil::IsParentEditable( GetMarkupServices(), pIElement ) == S_OK) )
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }
    
Cleanup:
    RRETURN1 ( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::GetEditContext
//
//  Synopsis:   Retrieves the element which should contain the edit context, based
//              on an element passed in, and whether or not a 'drill in' is 
//              occuring.  A drill in is when the user has done a lbutton down
//              on an element in an attempt to drill in.
//
//               - pIEnd and pIStart are NOT used 
//              TODO: Remove pIEnd and pIStart or populate them?
//
//  Arguments:  pIStartElement = Candidate element for edit context
//              ppEditThisElement = Element where edit context should be set
//              fDrillingIn = Are we drilling into the element?
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::GetEditContext( 
                            IHTMLElement* pIStartElement, 
                            IHTMLElement** ppEditThisElement, 
                            IMarkupPointer* pIStart, /* = NULL */
                            IMarkupPointer* pIEnd, /*= NULL */ 
                            BOOL fDrillingIn /*= FALSE */)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spEditableElement;              // Element which should get edit context
    SP_IHTMLElement spCurElement;                   

    BOOL fNoScope = FALSE;
    BOOL fEditable = FALSE;
    BOOL fHasReadOnly = FALSE;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

#if DBG == 1
    BOOL fSkipTableCheck = FALSE;
#endif

    SP_IHTMLElement spLastReadOnly;
    SP_IHTMLInputElement spInputElement;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLElement spNextElement;

    //
    // If we are drilling into a viewlink, then the editable element should
    // be the master
    //
    if ( fDrillingIn && _pEd->IsMasterElement( pIStartElement) == S_OK )
    {
        spEditableElement = pIStartElement;
    }

    if ( spEditableElement.IsNull() )
    {        
        if ( IsEditable( pIStartElement) == S_OK ||
             ( ! fDrillingIn && EdUtil::IsParentEditable( GetMarkupServices(), pIStartElement ) == S_OK ))
        {            
            IFC( GetMarkupServices()->GetElementTagId( pIStartElement, &eTag ));
        
            if ( fDrillingIn &&
                 IsNoScopeElement( pIStartElement, eTag) == S_OK )
            {
                //
                // Stop on a No-Scope (eg. CheckBox - or input ). If we're drilling in .
                //
                spEditableElement = (IHTMLElement*) pIStartElement;
                fNoScope = TRUE;
            }            
            else
            {
                spCurElement = (IHTMLElement*) pIStartElement; 
                //
                // If we're not drilling in - and starting at a site selectable element
                // we can then start at the ParentLayout Node - as this will be our edit context
                //
                if ( !fDrillingIn )
                {
                    if ( _pEd->IsContentElement(pIStartElement) == S_OK )
                    {
                        ParentElement( GetMarkupServices(), &spCurElement.p );
                        AssertSz( ! spCurElement.IsNull() , "Master not in Tree");
                    }

                    if ( ! spCurElement.IsNull() ) // should always be true - unless master wasn't in tree.
                    {
                        IFHRC( GetLayoutElement( GetMarkupServices(), spCurElement , & spNextElement));

                        spCurElement = spNextElement;
                    }
                    
                    if ( _pEd->IsElementSiteSelectable( spCurElement ) == S_OK )
                    {
                        IFHRC( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spNextElement ));
                        spCurElement = spNextElement;
                    }
                }       
                
                while ( ! spCurElement.IsNull() )
                {
                    
                    //
                    // marka - we no longer want to have the edit context a table. However
                    // it is still valid to call GetEditContext in PumpMessage and have to special case
                    // tables. 
                    //
                    // If the spCurElement is any derivative of a table - we will find the outermost table cell.
                    // Pumpmessage will then make the parent of this table current.
                    //
                    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));
                    BOOL fFlowLayout;
                    IFC(IsBlockOrLayoutOrScrollable(spCurElement, NULL, &fFlowLayout));

                    if ( IsTablePart( eTag ) || eTag == TAGID_TABLE )
                    {
                        SP_IHTMLElement spParentElement;
                        IFC( spCurElement->get_parentElement( & spParentElement ));
                        
                        if (! ( IsEditable( spCurElement) == S_OK &&
                                IsEditable( spParentElement ) == S_FALSE ))
                        {                             
                            IFC( _pEd->GetOutermostTableElement( spCurElement, & spNextElement ));                    
                            spCurElement = spNextElement;
#if DBG == 1
                            ELEMENT_TAG_ID eTagDbg = TAGID_NULL;
                            IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTagDbg));
                            Assert( eTagDbg == TAGID_TABLE );
#endif
                            IFHRC( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spEditableElement ));
                        }    
                        else
                        {
                            //
                            // editable -> non-editable transition.
                            //
                            spEditableElement = spCurElement;                        
#if DBG == 1                            
                            fSkipTableCheck = TRUE;
#endif                            
                        }
                        break;                                                    
                    }                     
                    else if ( eTag == TAGID_FRAMESET )
                    {
                        SP_IHTMLElement spFrameSet;
                        SP_IHTMLElement spFlow;
                        SP_IMarkupPointer spContent;
                        SP_IMarkupPointer2 spContent2;
                        SP_IMarkupContainer spContainer;
                        
                        hr = THR( GetFirstFrameElement( spCurElement , & spFrameSet ));
                        //
                        // we want to bail for S_FALSE
                        //
                        if ( hr )
                            goto Cleanup;                            
                            
#if DBG == 1
                        IFC( GetMarkupServices()->GetElementTagId( spFrameSet, & eTag ));
                        Assert( eTag == TAGID_FRAME );
#endif
                        IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spContent ));
                        IFC( spContent->QueryInterface( IID_IMarkupPointer2, (void**) & spContent2));                        
                        IFC( spContent2->MoveToContent( spFrameSet, TRUE ));
                        
                        hr = THR ( GetFirstFlowElement( spContent, & spEditableElement));
                        if ( hr == S_FALSE )
                        {
                            IFC( spContent->CurrentScope(& spEditableElement));
                        }
                            
                    }
                    else if (( fFlowLayout ||
                             ( eTag == TAGID_SELECT ) || 
                             ( _pEd->IsContentElement( spCurElement) == S_OK && fDrillingIn ) ))
                    {                            
                        spEditableElement = spCurElement;
                        break;
                    }    
                    if ( _pEd->IsContentElement(spCurElement) == S_OK && !fDrillingIn )
                    {
                        if ( GetLayoutElement( GetMarkupServices(), spCurElement, & spNextElement) == S_OK )
                            spCurElement = spNextElement;
                        else
                            break;
                    }
                    IFC( GetParentElement(GetMarkupServices(), spCurElement, & spNextElement)); 
                    if ( ! spNextElement.IsNull() )
                        spCurElement = spNextElement;
                    else 
                        break;                        
                }                    
                
                if ( spEditableElement.IsNull() )
                {
                    hr = THR( GetOutermostLayout( GetMarkupServices(), pIStartElement, & spEditableElement));
                    if ( FAILED(hr ) || hr == S_FALSE )
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }
                }                
            } // else IsNoScope()
        } // IsEditable                         
        else
        {
            //
            // We are here with the following conditions.
            //  - pIStartElement is NOT editable AND
            //  - we are drilling in OR we are NOT drilling in and our parent is not editable
            //
            // In either case, keep moving up until you hit the outermost editable element
            //
            BOOL fFoundEditableElement = IsContentEditable( pIStartElement) == S_OK && 
                                         EdUtil::IsEnabled( pIStartElement) == S_OK;

            spCurElement = (IHTMLElement*) pIStartElement;
            while ( ! spCurElement.IsNull() )
            {
                //
                // pIStartElement is never updated, and this should always be false
                // TODO: move this to be outside the loop. 
                //
                fEditable = IsContentEditable( pIStartElement) == S_OK && 
                            EdUtil::IsEnabled( pIStartElement) == S_OK;

                //
                // If the current element contains selection at browse time, or it is a 
                // viewlinked element, we need to stop walking
                //
                if ( fEditable  || 
                     ContainsSelectionAtBrowse( spCurElement ) == S_OK || 
                     _pEd->IsContentElement( spCurElement) == S_OK )
                {
                    spEditableElement = spCurElement;          
                    fFoundEditableElement = TRUE;

                    if ( ContainsSelectionAtBrowse( spCurElement ) == S_OK ||
                         _pEd->IsContentElement( spCurElement ) == S_OK )
                        break;
                }
                
                IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));

                //
                // Keep track of read-only inputs and textareas
                // 
                if ( !fHasReadOnly && !fFoundEditableElement &&
                     eTag == TAGID_INPUT || 
                     eTag == TAGID_TEXTAREA)
                {
                    VARIANT_BOOL fRet = VB_FALSE;
                    
                    if ( eTag == TAGID_INPUT )
                    {
                        IFC( spCurElement->QueryInterface( IID_IHTMLInputElement, (void**) & spInputElement));
                        IFC( spInputElement->get_readOnly( & fRet ));
                    }
                    else
                    {
                        IFC( spCurElement->QueryInterface( IID_IHTMLTextAreaElement, (void**) & spTextAreaElement));
                        IFC( spTextAreaElement->get_readOnly( & fRet ));
                    }
                    if ( fRet == VB_TRUE )
                    {
                        fHasReadOnly = TRUE;
                        spLastReadOnly = spCurElement ;
                    }
                }
                if ( fFoundEditableElement && ( ! fEditable ) )
                {
                    break;
                }
                IFC( GetParentElement(GetMarkupServices(), spCurElement, & spNextElement ));
                if ( spNextElement )
                    spCurElement = spNextElement;
                else
                    break;
            }
            
            if ( ! fFoundEditableElement )
            {
                //
                // There is no Edtiable element. Look for a ReadOnly Element.
                //
                if ( fHasReadOnly )
                {
                    spEditableElement = spLastReadOnly;
                }               
                else      
                {                     
                    //
                    // We're in browse mode, there is nothing editable.
                    // assume this is a selection in the body. Make the context the body.
                    //
                    hr = THR( GetOutermostLayout( GetMarkupServices(), pIStartElement, & spEditableElement ) );                    
                    if ( hr == S_FALSE || spEditableElement.IsNull() )
                    {
                        IFC( GetEditor()->GetBody( & spEditableElement ));                        
                    }
                    else if ( FAILED( hr ))
                    {
                        goto Cleanup;
                    }
                }                    
            }    
        }
    }

#if DBG ==1 
    IGNORE_HR( GetMarkupServices()->GetElementTagId( spEditableElement, & eTag ));
    AssertSz( eTag != TAGID_TABLE, "Found Editable element to be table");
    AssertSz( ! IsTablePart( eTag) || fSkipTableCheck , "Found editable element to be part of a table");
    Assert( ! spEditableElement.IsNull() );
    Assert( IsLayout( spEditableElement) == S_OK );
#endif

    if ( ppEditThisElement )
    {
        *ppEditThisElement = spEditableElement;
        (*ppEditThisElement)->AddRef();
    }

Cleanup:
    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::IsInEditContext( IHTMLElement* pIElement )
{
    HRESULT hr;
    BOOL fInside = FALSE;
    
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    
    IFC( GetEditor()->CreateMarkupPointer( & spStart )); 

    IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( IsInEditContext( spStart , & fInside, TRUE )); // only compare ptrs in same markup

    if ( fInside )
    {
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        IFC( IsInEditContext( spEnd , & fInside, TRUE )); // only compare ptrs in same markup
    }
    
Cleanup:
    hr = fInside ? S_OK : S_FALSE; 
    
    RRETURN1( hr, S_FALSE );
}


HRESULT
CSelectionManager::CheckCurrencyInIframe( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IObjectIdentity spIdent;
    
    IFC( pIElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

    if ( _pIEditableElement &&
         ( spIdent->IsEqualObject( GetEditableElement() ) == S_OK ||
           IsElementContentSameAsContext( pIElement) == S_OK ||    
           IsInEditContext( pIElement ) == S_OK ) )
    {
        hr = S_OK;
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );        
}

HRESULT
CSelectionManager::EnsureEditContextClick( IHTMLElement* pIElementClick, CEditEvent* pEvent, BOOL* pfChangedCurrency)
{
    HRESULT hr = S_OK ;
    Assert( pIElementClick );
    SP_IHTMLElement spCurElement = (IHTMLElement*) pIElementClick;
    SP_IHTMLElement spLayoutElement;
    SP_IHTMLElement spActiveElement;
    SP_IObjectIdentity spIdent, spIdent2;
    SP_IHTMLElement spElementThatShouldBeCurrent;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

#ifdef FORMSMODE
    if (!spCurElement.IsNull())
    {
        IFC (SetSelectionMode(spCurElement));
    }
#endif

    Assert( pIElementClick );
    if (! pIElementClick )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if ( pfChangedCurrency )
    {
        *pfChangedCurrency = FALSE;
    }

    IGNORE_HR( GetDoc()->get_activeElement( & spActiveElement ));                        
    if ( spActiveElement )
    {
        IFC( spActiveElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        IFC( GetMarkupServices()->GetElementTagId( spActiveElement, & eTag ));
    }

    IFC( GetEditableElement()->QueryInterface( IID_IObjectIdentity, (void**) & spIdent2 ));
    
    //
    // marka - in design mode, we change the currency behavior to make the parent
    // of a 'site selectable' object active.
    //
    //
    if ( !spCurElement.IsNull() &&
         EdUtil::IsParentEditable( GetMarkupServices(), spCurElement) == S_OK )
    { 
        IFC( GetLayoutElement( GetMarkupServices(), spCurElement, & spLayoutElement ));
        if ( ! spLayoutElement )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        //
        // We only do the change of currency - if a change of currency is implied.
        //
        // Hence clicking on a UI Active Div - will not change currency ( as the div is already current )
        // also clicking on any SiteSelected elmenet - will not change currency.
        // this is handled by mshtmled.dll directly
        // 
       
        BOOL fSiteSelected = IsElementSiteSelected(spLayoutElement) == S_OK ;
        
        BOOL fSiteSelectable = _pEd->IsElementSiteSelectable( spLayoutElement ) == S_OK &&
                                EdUtil::IsParentEditable( GetMarkupServices(), spLayoutElement) == S_OK ;

        if ( ( spIdent && 
               spIdent->IsEqualObject( spLayoutElement) == S_FALSE &&   // the thing we clicked on isn't the layout that's current & it's not site selected
              ! fSiteSelected ) 
              ||
             ( spIdent2 && 
               spIdent2->IsEqualObject( spLayoutElement) == S_FALSE &&   // the thing we clicked on isn't the layout that's current & it's not site selected
              ! fSiteSelected )               

            ||

            ( fSiteSelectable  &&         /* the thing we clicked on is site selectable, but it isn't site selected */
             ! fSiteSelected &&
             ! ( HasFocusAdorner() && IsElementContentSameAsContext( spLayoutElement) == S_OK  ) )
             
            ||
            
            // Special case table parts (bug 101670)
            ( eTag == TAGID_TABLE || IsTablePart( eTag) ) )
        {                               
            IFC( GetEditContext( 
                        spCurElement , 
                        & spElementThatShouldBeCurrent,
                        NULL,
                        NULL,
                        FALSE )); 

        }

        if ( ! spElementThatShouldBeCurrent.IsNull() )
        {
            //
            // Look to see if we would extend a multiple selection here. If we would
            // then don't do any currency change.
            //
            
            if ( ( ( pEvent && ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) && 
                   fSiteSelectable )
                  ||      
                   fSiteSelected
                 )                 
                && GetCommandTarget()->IsMultipleSelection() 
                && CheckAnyElementsSiteSelected() )
                    goto Cleanup ;
                
            if ( (spIdent &&
                  spIdent->IsEqualObject( spElementThatShouldBeCurrent) == S_FALSE ) 
                 ||
                  ( spIdent2 && 
                    spIdent2->IsEqualObject( spLayoutElement) == S_FALSE ))
            {
                IFC( BecomeCurrent( GetDoc(), spElementThatShouldBeCurrent ));
                if ( pfChangedCurrency ) 
                    *pfChangedCurrency = TRUE;
            }            
            IFC( SetEditContextFromElement( spElementThatShouldBeCurrent, TRUE  ));                                        
        }
    }
    else
    {
        BOOL fParentEditable;
        BOOL fEditable;
        
        //
        // This is for "browse mode" setting of the edit context.
        //
        IFC( GetEditContext( 
                    spCurElement , 
                    & spElementThatShouldBeCurrent,
                    NULL,
                    NULL,
                    TRUE )); 

        fEditable = (EdUtil::IsEditable( spElementThatShouldBeCurrent ) == S_OK);
        fParentEditable = (EdUtil::IsParentEditable( GetMarkupServices(), spElementThatShouldBeCurrent ) == S_OK);
        
        if( !fEditable && fParentEditable && spIdent &&
            spIdent->IsEqualObject( spElementThatShouldBeCurrent) == S_FALSE )
        {
            IFC( BecomeCurrent( GetDoc(), spElementThatShouldBeCurrent ));
            if ( pfChangedCurrency ) 
                *pfChangedCurrency = TRUE;
        }

        IFC( SetEditContextFromElement( spElementThatShouldBeCurrent ));  

        //
        // Listen to active element property change - so if the current eleemnt
        // becomes editable - we do the right thing - and reset our edit context.
        // 
        if ( spElementThatShouldBeCurrent )
        {
            if ( _pIActiveElement )
            {
                IFC( DetachActiveElementHandler());
            }
            IFC( AttachActiveElementHandler( spElementThatShouldBeCurrent ));        
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::AttachDragListener(IHTMLElement* pIElement)
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( ! _pIDragListener );

    ReplaceInterface( & _pIDragListener , pIElement );
    
    IFC( _pDragListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIDragListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("ondragend"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );
   
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::DetachDragListener()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIDragListener );
    
    IFC( _pDragListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIDragListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("ondragend"), spDisp ));
    
    ClearInterface( & _pIDragListener );

Cleanup:
    RRETURN( hr );

}

HRESULT 
CSelectionManager::AttachActiveElementHandler(IHTMLElement* pIElement )
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;
    
    Assert( ! _pIActiveElement );

    ReplaceInterface( & _pIActiveElement , pIElement );
    
    IFC( _pActElemHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIActiveElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachActiveElementHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIActiveElement );
    
    IFC( _pActElemHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIActiveElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));
    
    ClearInterface( & _pIActiveElement );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CSelectionManager::AttachEditContextHandler()
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( GetEditableElement());
    Assert( ! _pIBlurElement );

    ReplaceInterface( & _pIBlurElement, GetEditableElement() );
    
    IFC( _pEditContextBlurHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIBlurElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    //IFC( spElement2->attachEvent(_T("onblur"), spDisp, & varAttach));
    //Assert( varAttach == VB_TRUE );

    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachEditContextHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIBlurElement );
    
    IFC( _pEditContextBlurHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIBlurElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    //IFC( spElement2->detachEvent(_T("onblur"), spDisp ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));

    ClearInterface( & _pIBlurElement );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CActiveElementHandler::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor());
                IFC( evt.Init(  spObj , dispidMember));
                Assert( evt.GetType() == EVT_PROPERTYCHANGE );
                if( evt.GetType() == EVT_PROPERTYCHANGE )
                {
                    IFC( _pMan->OnPropertyChange( & evt ));
                }                    
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CEditContextHandler::Invoke(
                        DISPID dispidMember,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo,
                        UINT * puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            if(!pdispparams->rgvarg[0].pdispVal)
                RRETURN(hr);
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor());
                IFC( evt.Init(  spObj , dispidMember));

                switch( evt.GetType())
                {
                    case EVT_PROPERTYCHANGE:
                        IFC( _pMan->OnPropertyChange( & evt ));
                        break;
                    default:
                        AssertSz(0,"Unexpected event");
                        break;
                }                    
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::IsInsideElement( IHTMLElement* pIElement, IHTMLElement* pIElementOutside )
{
    HRESULT hr = S_FALSE;
    SP_IMarkupPointer spPointer1, spPointer2;
    SP_IMarkupPointer spPointerOutside1, spPointerOutside2;

    if (pIElement && pIElementOutside)
    {
        IFC( GetEditor()->CreateMarkupPointer( & spPointer1 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointer2 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointerOutside1 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointerOutside2 ));

        IFC( spPointer1->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spPointer2->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        IFC( spPointerOutside1->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
        IFC( spPointerOutside2->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ));

        hr = Between ( spPointer1, spPointerOutside1, spPointerOutside2 ) &&
             Between ( spPointer2, spPointerOutside1, spPointerOutside2 ) ?  S_OK : S_FALSE; 
    }

Cleanup:
    RRETURN1(hr, S_FALSE );
}

//
//
// We've recieved a currency change from Trident. Time to call our workhorse SetEditContext.
//
//

HRESULT
CSelectionManager::SetEditContextFromCurrencyChange( IHTMLElement* pIElement, DWORD dword, IHTMLEventObj* pIEventObj  )
{
    HRESULT        hr ;
    ELEMENT_TAG_ID eTag;
    SP_IHTMLElement spActive;
    SP_IHTMLElement spClippedElement;
    SP_IHTMLElement spParentElement;
    
    Assert( pIElement );
    
    WHEN_DBG(_ctSetEditContextCurChg++);

    //
    // Fire OnBeforeDeactivate to Designer Event Pump...
    //
    hr = THR(GetEditor()->DesignerPreHandleEvent( DISPID_EVMETH_ONBEFOREDEACTIVATE, pIEventObj ));
    if ( hr == S_OK )
    {
        //
        // S_OK means designer wants to consume event. 
        // we need to return S_FALSE so CDoc::SetCurrentElement gets' expected value back.
        // indicating that we don't want the currency change to occur
        //
        hr = S_FALSE;
        goto Cleanup;
    }
    else if ( FAILED(hr ))
        goto Cleanup;
        
        
    // Edit team's hack for TABLE && TD
    IGNORE_HR( GetActiveElement( GetEditor(), pIElement, & spActive , 
                            CheckCurrencyInIframe( pIElement) == S_OK ));
                            
    if (( dword == 1 || dword == 2 || dword == 4 ) && spActive )
    {
        IFC( ClipToElement( GetEditor(), spActive, pIElement, & spClippedElement ));
    }
    else
        spClippedElement = pIElement;
        
    IFC( GetMarkupServices()->GetElementTagId( spClippedElement, & eTag ));
    IFC( spClippedElement->get_parentElement( & spParentElement ));
    
    if ((eTag == TAGID_TABLE || IsTablePart( eTag)) &&
         IsEditable( spClippedElement) == S_OK &&
         IsEditable( spParentElement ) == S_OK )
    {
#ifndef _PREFIX_
        Assert( _ctSetEditContextCurChg == 1 ); // coming in here twice would be bad.
#endif
        
        SP_IHTMLElement spMakeMeCurrent;
        
        IFC( GetEditContext( spClippedElement,
                            &spMakeMeCurrent,
                             NULL,
                             NULL,
                             TRUE ));
#if DBG == 1
        SP_IObjectIdentity spIdent;
        IFC( spClippedElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        Assert( spIdent->IsEqualObject( spMakeMeCurrent ) == S_FALSE );
        IFC( GetMarkupServices()->GetElementTagId( spMakeMeCurrent, & eTag ));
#endif
        // We want the body to become current, and we want to fail the
        // table trying to become current.       
        IFC( BecomeCurrent( GetDoc(), spMakeMeCurrent ));

        hr = S_FALSE; // disallow the attempted change in currency
    }
    else 
    {       
        SP_IHTMLElement spSiteSelectable;
        BOOL fSiteSelectable;
        BOOL fParentEditable;
        
        fSiteSelectable = _pControlTracker->GetSiteSelectableElementFromElement( spClippedElement, & spSiteSelectable) == S_OK ;        
        fParentEditable = fSiteSelectable ? 
                            EdUtil::IsParentEditable( GetMarkupServices(), spSiteSelectable ) == S_OK  :
                            FALSE; 
        
        if ( ( dword == 1 || dword == 2 ) &&                     
             ( fSiteSelectable && fParentEditable ) )
        {             
            //
            // We don't want any currency changes happening as a result of clicking.
            // we handle doing the right thing in EnsureEditContextClick
            // 
            hr = S_FALSE;
            goto Cleanup;
        }
        

        //
        // Do we have to update our editing UI ? 
        //
        if ( _fDrillIn || 
            IsEditable( spClippedElement) == S_OK ||
            ( fSiteSelectable && fParentEditable ) ||
            ( GetTrackerType() == TRACKER_TYPE_Control && 
              IsInsideElement( spClippedElement, _pControlTracker->GetPrimaryElement()) == S_OK ) ||
            ( IsAtBoundaryOfViewLink( spClippedElement) == S_OK ) 
           )
        {           
            CSelectionChangeCounter selCounter(this);
            selCounter.BeginSelectionChange();
            IFC( SetEditContextFromElement( spClippedElement ));

            //
            // NOTE: We don't fire this event for mouseevents
            // as we assume that the event will come to us on HandleEvent
            // if the element consumes it - then this won't happen.
            // 
            // this seems ok as it makes the event fire almost entirely consistently.
            //
            selCounter.EndSelectionChange( dword != 1 && dword != 2  );
        }
        else
        {
            if ( _pIActiveElement )
            {
                IFC( DetachActiveElementHandler());
            }
            IFC( AttachActiveElementHandler( spClippedElement ));
        }
    }   
    
    
Cleanup:
    WHEN_DBG( _ctSetEditContextCurChg-- );
    
    RRETURN1( hr, S_FALSE );
}

        

HRESULT
CSelectionManager::SetEditContextFromElement( IHTMLElement* pIElement , BOOL fFromClick /*=FALSE*/)
{
    HRESULT hr = S_OK ;
    BOOL    fEditable, fParentEditable, fNoScope ;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IHTMLElement   spParent;
    ELEMENT_TAG_ID  eTag;

    IFC( GetEditor()->CreateMarkupPointer( & spStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    //
    // Iframe or viewlink in edit mode check.
    //
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK )
    {
        SP_IHTMLElement spMaster;
        IFC( GetEditor()->GetMasterElement( pIElement, & spMaster ));
        IFC( GetEditor()->GetParentElement( spMaster, & spParent ));
    }
    else
    {
        IFC( GetEditor()->GetParentElement(pIElement, &spParent) );
    }
    
    fEditable = IsEditable( pIElement ) == S_OK ;

    if ( spParent )
    {
        fParentEditable = IsEditable( spParent ) == S_OK ;
    }
    else
        fParentEditable = fEditable;
    
    // 
    // 'No-scopeness' for SelMan - refers to whether we have pointers outside
    // the edit context element or not.
    // For Master Elements - we position the pointers in the content
    // so setting no-scopeness here is invalid
    //
    // NOTE: - we could eliminate this hokiness by passing an IHTMLElement* to SetEditContext
    // it would constrain us to being element based however. 
    //
    IFC( GetMarkupServices()->GetElementTagId( pIElement, &eTag ) );
    
    fNoScope = IsNoScopeElement( pIElement, eTag ) == S_OK && 
       _pEd->IsMasterElement( pIElement) == S_FALSE ;

    if ( _pEd->IsMasterElement( pIElement ) == S_OK )
    {        
        IFC( PositionPointersInMaster( pIElement, spStart, spEnd ));        
        //
        // for viewlinks - we derive our editability by the editability of the element
        // inside the content.
        // 
        SP_IHTMLElement spElementGetEditability;
        IFC( spStart->CurrentScope( & spElementGetEditability));
        
        if ( _pEd->IsMasterElement(spElementGetEditability) == S_OK )
        {
            //
            // We found the master from current scope. What we do is we grovel around the sub-document
            // and find an element to derive editability from
            //

            DWORD dwBreak;
            SP_IHTMLElement spScanElement;
            
            ED_PTR( edRightLooker );
            IFC( edRightLooker.MoveToPointer( spStart ));
            IFC( edRightLooker.SetBoundary( spStart, spEnd ));
            IFC( edRightLooker.Scan( RIGHT, 
                                     BREAK_CONDITION_ANYTHING - 
                                     BREAK_CONDITION_NoScope - 
                                     BREAK_CONDITION_NoScopeBlock - 
                                     BREAK_CONDITION_NoScopeSite, 
                                     & dwBreak, 
                                     & spScanElement ));

            IFC( edRightLooker.CurrentScope( & spElementGetEditability ));

        }
        
        if ( spElementGetEditability )
        {        
            fEditable = IsEditable( spElementGetEditability ) == S_OK ;       
        }            
    }
    else if ( fNoScope )
    {
        IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd));
    }
    else
    {
        IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ));
    }

    IFC( SetEditContext(  
                        fEditable,
                        fParentEditable,
                        spStart,
                        spEnd ,
                        fNoScope,
                        fFromClick ));
                        
Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::EnsureEditContext( IMarkupPointer* pPointer )
{
    HRESULT            hr = S_OK;
    SP_IHTMLElement    spElement;
    SP_IDisplayPointer spDisp;

    IFC( pPointer->CurrentScope( & spElement));
    if ( spElement.IsNull() )
    {
        IFC( GetDisplayServices()->CreateDisplayPointer( & spDisp ) );
        IFC( spDisp->MoveToMarkupPointer( pPointer, NULL ));
        IFC( spDisp->GetFlowElement( & spElement ));
    }
    
    if ( ! spElement.IsNull() )
    {
        hr = THR( EnsureEditContext( spElement, TRUE ));
    }
    else
    {
        AssertSz(0, "Unable to find an element");
        hr = E_FAIL;
    }        
    
Cleanup:
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::DoPendingTasks()
{   
    HRESULT hr = S_OK;
    
    if ( _pIElementExitStart )
    {
        IFC( DoPendingElementExit());
        if ( hr == S_FALSE )
            hr = S_OK; // don't bubble this back hr = S_FALSE, means a change in currency did not occur
        Assert( ! _pIElementExitStart || _fInPendingElementExit );

        
        
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EnsureEditContext( IHTMLElement* pIElement, BOOL fDrillIn )
{
    HRESULT            hr = S_OK;
    SP_IHTMLElement    spEditContextElement; 
    SP_IHTMLElement    spMaster;
    BOOL               fIsContent = FALSE ;

    IFC( DoPendingTasks());
    
    IFC( GetEditContext( pIElement,
                    & spEditContextElement,
                    NULL,
                    NULL,
                    fDrillIn ));

    if ( ! spEditContextElement ) 
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    
    if( _pEd->IsContentElement( spEditContextElement ) == S_OK )
    {
        fIsContent = TRUE;
        IFC( _pEd->GetMasterElement( spEditContextElement, & spMaster ));
    }
    
    //
    // _pElemEditContext should always be in sync with _pElemCurrent
    // however there are some cases where _pElemCurrent gets set to the root and testing 
    // for pEditContextEleemnt == _pElemEditContext is not sufficient
    //
    if ( ! fIsContent )
    {
        hr = THR( BecomeCurrent( GetDoc(), spEditContextElement ));
    }
    else
    {
        hr = THR( BecomeCurrent( GetDoc(), spMaster ));
    }
    
    if (FAILED(hr ) || ( hr == S_FALSE ))
    {
        goto Cleanup ;
    }
    
    //
    // The Edit Context is not Editable, and calling becomeCurrent is NOT sufficient to set
    // the EditContext. This is valid if we were called in browse mode.
    // We call SetEditContext directly
    //
    hr = THR( SetEditContextFromElement( spEditContextElement ));
    
    //
    // There are cases where become current may fail. A common one is 
    // from forced currency changes (via script) - during a focus change
    // change in currency.
    // 
    // During focus changes - we set the ELEMENTLOCK_FOCUS flag. Any forced 
    // currency changes via calls to become current - will fail - until
    // the end of the focus change has occurred.
    //
    // A common example of this is the Find Dialog's use of the select method
    // during a focus change. This is all fine - but will cause the assert below to fire
    // - so I've added the ElementLockFocus check
    //

Cleanup:
    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CSelectionManager::EnsureEditContext( ISegmentList* pSegmentList )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spTemp;
    SP_IMarkupPointer       spTemp2;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    IFC( GetEditor()->CreateMarkupPointer( & spTemp ));
    IFC( GetEditor()->CreateMarkupPointer( & spTemp2 ));

    IFC( pSegmentList->CreateIterator(& spIter) );

    // Try and retrieve the first element, will fail if there
    // is none
    IFC( spIter->Current(&spSegment) );

    IFC( spSegment->GetPointers( spTemp, spTemp2 ) );

    hr = THR( EnsureEditContext( spTemp ));

Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::SetInitialEditContext()
{
    HRESULT         hr ;
    SP_IHTMLElement spActive;
    
    IGNORE_HR( GetDoc()->get_activeElement( & spActive )); // blindly ignore HR here. if hosted by vid - we return E_FAIL for root being current !!!!   
    if ( spActive.IsNull() )
    {
        hr = THR( GetEditor()->GetBody( & spActive ));
        if ( FAILED( hr ) && spActive )
        {
            // some other failure. we bail
            goto Cleanup;
        }   
    }

    if ( ! spActive )
    {
        //
        // No body ? Doc probably isn't parsed as yet. we return s-ok - and assume 
        // edit context will be set somewhere later.
        //
        hr = S_OK;
        goto Cleanup; 
    }

    if ( ! spActive.IsNull() )
    {
        IFC( SetEditContextFromElement( spActive ));
    }
    else
    {
        AssertSz(0,"Unable to get an active element");            
        hr = E_FAIL;
    }    

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::UpdateEditContextFromElement(IHTMLElement* pIElement,
        IMarkupPointer* pIStartPointer /* =NULL */,
        IMarkupPointer* pIEndPointer /* =NULL */,
        BOOL* pfEditContextWasUpdated /* =NULL */)
{
    HRESULT hr;
    SP_IMarkupPointer   spStartPointer = pIStartPointer;
    SP_IMarkupPointer   spEndPointer = pIEndPointer;

    int iWhereStartPointer, iWhereEndPointer;

    if (pfEditContextWasUpdated)
        *pfEditContextWasUpdated = FALSE;
    
    //  If we are not given a start markup pointer, create one before our element.
    if (spStartPointer == NULL)
    {
        IFC( _pEd->CreateMarkupPointer( & spStartPointer ));
        IFC( spStartPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    }

    //  If we are not given an end markup pointer, create one after our element.
    if (spEndPointer == NULL)
    {
        IFC( _pEd->CreateMarkupPointer( & spEndPointer ));
        IFC( spEndPointer->MoveAdjacentToElement( pIElement,  ELEM_ADJ_BeforeEnd ));
    }
    
    //  Determine if our atomic parent element is outside of the edit context.
    IGNORE_HR( OldCompare( _pStartContext, spStartPointer, & iWhereStartPointer));                       
    IGNORE_HR( OldCompare( _pEndContext, spEndPointer, & iWhereEndPointer));                       

    //  If the given element is outside of the edit context, we need to change
    //  the edit context to be the given element.
    if (iWhereStartPointer > 0 || iWhereEndPointer < 0)
    {
        SetDontChangeTrackers(TRUE);
        IFC( SetEditContextFromElement(pIElement) );
        SetDontChangeTrackers(FALSE);

        if (pfEditContextWasUpdated)
            *pfEditContextWasUpdated = TRUE;
    }
    
    hr = S_OK;
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::IsEqualEditContext( IHTMLElement* pIElement )
{
    HRESULT  hr ;
    SP_IObjectIdentity spIdent;

    if ( _pEd->IsContentElement(GetEditableElement()) == S_OK )
    {
        SP_IHTMLElement spMaster;
        IFC( _pEd->GetMasterElement( GetEditableElement(), & spMaster ));
        IFC( spMaster->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));        
    }
    else
    {
        IFC( GetEditableElement()->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
    }
    
    hr = spIdent->IsEqualObject( pIElement );
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT
CSelectionManager::OnPropertyChange( CEditEvent* pEvt )
{
    HRESULT hr ;
    BSTR    bstrPropChange = NULL ;

    IFC( DYNCAST( CHTMLEditEvent, pEvt)->GetPropertyChange( & bstrPropChange ));
    if ( !StrCmpICW (bstrPropChange, L"contentEditable")
        || !StrCmpICW( bstrPropChange, L"style.visibility")
#ifdef FORMSMODE
        || !StrCmpICW (bstrPropChange, L"selectionMode")
#endif
       )
    {
        SP_IHTMLElement    spElement;
        SP_IHTMLElement    spParentElement;
        SP_IObjectIdentity spIdent;
        SP_IObjectIdentity spIdentParent;

        IFC( pEvt->GetElement( & spElement ));
        IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

        if( !StrCmpICW( bstrPropChange, L"style.visibility" ) )
        {
            if( IsElementVisible( spElement ) )
            {
                IFC( SetEditContextFromElement( spElement ) );
            }
            else
            {
                IFC( GetEditor()->GetParentElement( spElement, &spParentElement ) );

                if( spParentElement )
                {
                    IFC( SetEditContextFromElement( spParentElement ) );
                }
            }
        }
        else if( _pIEditableElement && spIdent->IsEqualObject( GetEditableElement()) == S_OK )
        {
            IFC( SetEditContextFromElement( spElement ));
        }
        else
        {
            //
            // Also listen to changes on the parent element.
            //
            IFC( GetEditor()->GetParentElement(spElement, & spParentElement ));
            IFC( spParentElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdentParent));

            if ( spIdentParent->IsEqualObject( GetEditableElement()) == S_OK )
            {
                IFC( SetEditContextFromElement( spElement ));
            }
            else if ( !StrCmpICW (bstrPropChange, L"contentEditable"))
            {
                //
                // the editability of the active element may have become true.
                // If so - we need to set our edit context to match that of the active element
                //
                
                SP_IHTMLElement spActiveElement;
                
                IFC( GetDoc()->get_activeElement( & spActiveElement ));
                if ( spIdent->IsEqualObject( spActiveElement ) == S_OK &&
                     IsEditable( spActiveElement) == S_OK )
                {
                    IFC( SetEditContextFromElement( spElement ));                   
                }
            }
        }
       
    }
    
Cleanup:
    if (bstrPropChange)
        ::SysFreeString( bstrPropChange);
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: OnLayoutChange
//
// Synopsis: A 'layout' change has occurred ( eg. we removed the layout on something that was site-seelcted)
//           Tell the trackers to fix themselves.
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::OnLayoutChange()
{
    Assert( _pActiveTracker);
    RRETURN( _pActiveTracker->OnLayoutChange());
}

HRESULT
CSelectionManager::GetFirstFrameElement( IHTMLElement* pIStartElement, IHTMLElement** ppIElement)
{
    HRESULT hr ;
    ED_PTR( edScanFrame );
    SP_IMarkupPointer spBoundaryStart;
    SP_IMarkupPointer spBoundaryEnd;
    SP_IHTMLElement   spFrameElement;
    DWORD             dwFound;
    ELEMENT_TAG_ID    eTag;
    
    Assert( pIStartElement && ppIElement );
    IFC( edScanFrame.MoveAdjacentToElement( pIStartElement, ELEM_ADJ_AfterBegin ));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryEnd ));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryStart ));

    IFC( spBoundaryStart->MoveAdjacentToElement( pIStartElement, ELEM_ADJ_AfterBegin ));
    IFC( spBoundaryEnd->MoveAdjacentToElement( pIStartElement, ELEM_ADJ_BeforeEnd ));
    
    IFC( edScanFrame.SetBoundary( spBoundaryStart, spBoundaryEnd  ));

    IFC( edScanFrame.Scan(
                            RIGHT ,
                            BREAK_CONDITION_Site,
                            & dwFound,
                            & spFrameElement ));

    if ( edScanFrame.CheckFlag( dwFound, BREAK_CONDITION_Site ))
    {
        IFC( GetMarkupServices()->GetElementTagId( spFrameElement, & eTag ));
        
        if ( eTag == TAGID_FRAME )
        {
            *ppIElement = (IHTMLElement*) spFrameElement;
            (*ppIElement)->AddRef();
        }
        else
            hr = S_FALSE;
    }
    else
        hr = S_FALSE;
Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
CSelectionManager::GetFirstFlowElement( IMarkupPointer* pStart, IHTMLElement** ppIElement)
{
    HRESULT hr;
    ED_PTR( edScanFrame );
    SP_IHTMLElement     spFrameElement;
    SP_IMarkupContainer spContainer;
    SP_IMarkupPointer   spBoundaryEnd;
    DWORD               dwFound;
    
    Assert( pStart && ppIElement );
    IFC( edScanFrame.MoveToPointer( pStart ));

    IFC( pStart->GetContainer( & spContainer));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryEnd ));
    IFC( spBoundaryEnd->MoveToContainer( spContainer, FALSE ));
    
    IFC( edScanFrame.SetBoundary( pStart, spBoundaryEnd  ));

    IFC( edScanFrame.Scan(
                            RIGHT ,
                            BREAK_CONDITION_EnterTextSite ,
                            & dwFound,
                            & spFrameElement ));

    if ( edScanFrame.CheckFlag( dwFound, BREAK_CONDITION_EnterTextSite ))
    {
        *ppIElement = (IHTMLElement*) spFrameElement;
        (*ppIElement)->AddRef();
    }
    else
        hr = S_FALSE;
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT 
CSelectionManager::PositionCaretAtPoint(POINT ptGlobal)
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer spDispPointer ;
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToPoint(ptGlobal, COORD_SYSTEM_GLOBAL, NULL, 0, NULL));
    IFC (PositionCaret( spDispPointer));
    
Cleanup :
    RRETURN (hr);
}

HRESULT
CSelectionManager::BeginSelectionUndo()
{
    CSelectionUndo undoSel( DYNCAST( CEditorDoc , GetEditor() )); 
    
    return S_OK;
}

HRESULT
CSelectionManager::EndSelectionUndo()
{
    CDeferredSelectionUndo DeferredUndo( DYNCAST( CEditorDoc, GetEditor() ));   
    
    return S_OK;
}

HRESULT
CSelectionManager::OnSelectedElementExit(                                             
                                            IMarkupPointer* pIStart, 
                                            IMarkupPointer * pIEnd,
                                            IMarkupPointer* pIContentStart,
                                            IMarkupPointer* pIContentEnd
                                            )
{
    Assert( _pActiveTracker );

    return ( _pActiveTracker->OnExitTree(  pIStart, pIEnd, pIContentStart, pIContentEnd  ));
}

HRESULT
CSelectionManager::OnChangeType( SELECTION_TYPE eType , ISelectionServicesListener * pIListener )
{
    HRESULT hr = S_OK;

    if ( ! _pActiveTracker ) // possible to call this on shutdown.
        return S_OK;

    SP_IUnknown spUnk;
    
    if ( pIListener )
    {
        IFC( pIListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
        
        //
        //
        // we assume that if we're being changed - then we don't have to do anything
        // as the type change is handled by the existing selection tracker update mechanism
        //
        if( (IUnknown*) spUnk != (IUnknown*) this )
        {
            EnsureDefaultTrackerPassive();
        }
    }
    
Cleanup:
    RRETURN( hr );    
}

HRESULT
CSelectionManager::GetTypeDetail( BSTR* p)
{
    *p = SysAllocString(_T("undefined"));
    return S_OK;
}

//+---------------------------------------------------------------------
//
// Method: MshtmledOwnsSelectionServices
//
// Synopsis: Do we own the things in selection services ? If not it's 
//           considered bad to do things like change trackers etc.
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::WeOwnSelectionServices()
{
    HRESULT hr;
    SP_IUnknown spUnk;
    SP_ISelectionServicesListener spListener;
    
    IFC( GetSelectionServices()->GetSelectionServicesListener( & spListener ));
    if ( spListener )
    {
        IFC( spListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
       
        hr = (IUnknown*) spUnk == (IUnknown*) this  ? S_OK : S_FALSE ;
    }
    else
        hr = E_FAIL ;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

BOOL
CSelectionManager::CheckAnyElementsSiteSelected()
{
    if ( GetTrackerType() == TRACKER_TYPE_Control )
    {
        CControlTracker* pControlTracker = DYNCAST( CControlTracker, _pActiveTracker );
        if (pControlTracker)
        {
            if (pControlTracker->NumberOfSelectedItems() > 0)
                return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CSelectionManager::GetSiteSelectableElementFromElement( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    RRETURN1( _pControlTracker->GetSiteSelectableElementFromElement( pIElement, ppIElement), S_FALSE ) ;
}

HRESULT
CSelectionManager::EnableModeless( BOOL fEnable )
{
    HRESULT hr;
    
    hr = THR( _pActiveTracker->EnableModeless( fEnable ));

    RRETURN( hr );
}

HRESULT
CSelectionManager::CheckUnselectable(IHTMLElement* pIElement)
{
    HRESULT hr;
    BSTR    bstrUnselectable = SysAllocString(_T("unselectable"));
    BSTR    bstrOn = SysAllocString(_T("on"));
    BOOL fUnselectable;

    IFC( CheckAttribute( pIElement, & fUnselectable, bstrUnselectable, bstrOn ));

    hr = fUnselectable ? S_OK : S_FALSE;
    
Cleanup:
    SysFreeString( bstrUnselectable );
    SysFreeString( bstrOn );

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::MoveToSelectionAnchor (
            IMarkupPointer * pIAnchor )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }

    Assert( _pActiveTracker == _pSelectTracker );
    
    RRETURN( _pSelectTracker->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CSelectionManager::MoveToSelectionEnd (
            IMarkupPointer* pISelectionEnd )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }
    Assert( _pActiveTracker == _pSelectTracker );

    RRETURN( _pSelectTracker->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CSelectionManager::MoveToSelectionAnchor (
            IDisplayPointer * pIAnchor )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }

    Assert( _pActiveTracker == _pSelectTracker );
    
    RRETURN( _pSelectTracker->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CSelectionManager::MoveToSelectionEnd (
            IDisplayPointer* pISelectionEnd )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }
    Assert( _pActiveTracker == _pSelectTracker );

    RRETURN( _pSelectTracker->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CSelectionManager::IsEditContextUIActive()
{
    HRESULT hr;
    
    hr = ( HasFocusAdorner() && _pAdorner->IsEditable()  ) ? S_OK : S_FALSE;

    RRETURN1( hr, S_FALSE ) ;
}    

//
//
// Is this element at the boundary of the view link ? 
//
//
HRESULT
CSelectionManager::IsAtBoundaryOfViewLink( IHTMLElement* pIElement )
{
    HRESULT hr;

    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer2 spContainer2;
    SP_IHTMLElement spMaster;
    SP_IMarkupPointer spElem;
    SP_IMarkupPointer spInsideMasterStart;
    SP_IMarkupPointer spInsideMasterEnd ;
    BOOL fEqual;
    ELEMENT_TAG_ID eTag;

    Assert( pIElement );
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    if ( eTag == TAGID_INPUT )
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    IFC( GetEditor()->CreateMarkupPointer( & spElem ));
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMasterStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMasterEnd ));

    IFC( spElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    IFC( spElem->GetContainer( & spContainer ));
    IFC( spContainer->QueryInterface( IID_IMarkupContainer2, (void**) & spContainer2 ));

    IFC( spContainer2->GetMasterElement( & spMaster ));
    if ( spMaster )
    {
        IFC( PositionPointersInMaster( spMaster, spInsideMasterStart, spInsideMasterEnd ));
        IFC( spInsideMasterStart->IsEqualTo( spElem, & fEqual ));
        
        hr = fEqual ? S_OK : S_FALSE;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::RequestRemoveAdorner( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spEditElement;
    ELEMENT_TAG_ID eTag;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));    
    IFC( GetEditableElement( & spEditElement ));

    if ( IsAtBoundaryOfViewLink( spEditElement) == S_OK ||
         GetEditableTagId() == TAGID_IFRAME )
    {
        //
        // Is the element we're site selecting inside or outside the viewlink ?
        //
        SP_IMarkupPointer spElemStart;
        SP_IMarkupPointer spElemEnd;
        IFC( GetEditor()->CreateMarkupPointer( & spElemStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spElemEnd ));

        IFC( spElemStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spElemEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        BOOL fStartInsideContext = Between( spElemStart, _pStartContext, _pEndContext );
        BOOL fEndInsideContext = Between( spElemEnd, _pStartContext, _pEndContext );

        if ( ! ( fStartInsideContext && fEndInsideContext ) )
        {
            DestroyAdorner();
        }           
    }
    else
    {
        DestroyAdorner();
    }        
        
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::IsContextWithinContainer
//
//  Synopsis:   Checks to see if the edit context is contained within the
//              current container.  This method uses flat markup pointers,
//              so sub-containers for things like viewlinks and will be
//              correctly retrieved.
//
//  Arguments:  pIContainer = Markup container to check context against
//              pfContained = OUTPUT - Success flag
//
//  Returns:    HRESULT indicating success.
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::IsContextWithinContainer(IMarkupContainer *pIContainer, BOOL *pfContained)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    BOOL                fResult;

    Assert( pIContainer && pfContained );
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned  ));
    Assert( fPositioned );
#endif

    *pfContained = FALSE;
    
    // Create markup pointers and position them on the 
    // start and end of the container in question
    
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

    IFC( spStart->MoveToContainer( pIContainer, TRUE ) );
    IFC( spEnd->MoveToContainer( pIContainer, FALSE ) );

    // Check to see if we are contained
    IFC( _pStartContext->IsRightOfOrEqualTo( spStart, &fResult ) );
    if( !fResult )
        goto Cleanup;

    IFC( _pEndContext->IsLeftOfOrEqualTo( spEnd, &fResult ) );
    if( !fResult )
        goto Cleanup;

    *pfContained = TRUE;

Cleanup:

    RRETURN(hr);
}

HRESULT
CSelectionManager::FindAtomicElement(IHTMLElement* pIElement, IHTMLElement** ppIAtomicParentElement, BOOL fFindTopmost /*=TRUE*/)
{
    HRESULT     hr = S_FALSE;
    BSTR        bstrAtomic = SysAllocString(_T("atomicSelection"));
    BSTR        bstrOn = SysAllocString(_T("true"));
    BOOL        fAtomic = FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spAtomicElement;

    if (bstrAtomic == NULL || bstrOn == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }    

    if (GetEditor()->GetActiveCommandTarget()->IsAtomicSelection())
    {
        //  Walk up the tree until we find an element with atomic
        //  selection turned on or until we hit the root.  If fFindTopmost
        //  is true we find the topmost atomic element.  Otherwise we
        //  just find the first one starting with pIElement.

        ReplaceInterface( &spElement , pIElement );
        while (1)
        {
            SP_IHTMLElement spParentElement;
            ELEMENT_TAG_ID  eTag;

            IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
            if (eTag == TAGID_INPUT || eTag == TAGID_GENERIC)
            {
                SP_IHTMLElement spMaster;

                if( GetMasterElement(GetMarkupServices(), spElement, &spMaster) == S_OK )
                {
                    ReplaceInterface( &spElement , (IHTMLElement*)spMaster );
                }
            }

            //  Get the atomicSelection attribute value
            IFC( CheckAttribute( spElement, & fAtomic, bstrAtomic, bstrOn ));

            if (fAtomic)
            {
                //  We found an atomic element.  Keep a pointer to it,
                //  break if we don't care to find the topmost.
                ReplaceInterface(&spAtomicElement, (IHTMLElement*)spElement);

                if (!fFindTopmost)
                    break;
            }
    
            //  atomicSelection not set.  Walk up the tree.
            IFC(GetParentElement(GetMarkupServices(), spElement, &spParentElement));
            if (spParentElement == NULL)
                break;

            ReplaceInterface( &spElement , (IHTMLElement*)spParentElement );
        }
    }
    
    hr = (spAtomicElement != NULL) ? S_OK : S_FALSE;
    
Cleanup:

    if (ppIAtomicParentElement)
        ReplaceInterface(ppIAtomicParentElement, (IHTMLElement*)spAtomicElement);

    SysFreeString( bstrAtomic );
    SysFreeString( bstrOn );

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::CheckAtomic(IHTMLElement *pIElement)
{
    HRESULT hr = S_FALSE;
    BOOL    fAtomic = FALSE;
    SP_IHTMLElement spAtomicParentElement;
    
    if (pIElement == NULL)
        goto Cleanup;

    //  First determine if atomic selection is enabled.
    if (GetEditor()->GetActiveCommandTarget()->IsAtomicSelection())
    {
        IFC( FindAtomicElement(pIElement, &spAtomicParentElement, FALSE) );

        if (spAtomicParentElement)
        {
            fAtomic = TRUE;
        }
    }
    
    hr = fAtomic ? S_OK : S_FALSE;
    
Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::AdjustPointersForAtomic( IMarkupPointer *pStart, IMarkupPointer *pEnd )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    int                 wherePointer = SAME;
    BOOL                fStartAdjusted = FALSE;

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    IFC( pStart->CurrentScope(&spElement) );
    if ( CheckAtomic( spElement ) == S_OK )
    {
        SP_IMarkupPointer   spTestPointer;
        BOOL                fAtBeforeEndOrAfterBegin = FALSE;

        IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
        if (wherePointer == SAME)
        {
            IFC( spTestPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ) );
            IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) );
                fStartAdjusted = TRUE;
            }
            else
            {
                IFC( spTestPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ) );
                IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
                if (fAtBeforeEndOrAfterBegin)
                {
                    IFC( pStart->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ) );
                    fStartAdjusted = TRUE;
                }
            }
        }
        else
        {
            IFC( spTestPointer->MoveAdjacentToElement( spElement,
                                            (wherePointer == LEFT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );

            IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pStart->MoveAdjacentToElement( spElement,
                                        (wherePointer == LEFT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                fStartAdjusted = TRUE;
            }
        }
    }

    if (fStartAdjusted && wherePointer == SAME)
    {
        IFC( pEnd->MoveToPointer(pStart) );
    }
    else
    {
        IFC( pEnd->CurrentScope(&spElement) );
        if ( CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtBeforeEndOrAfterBegin = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spElement ,
                                            (wherePointer == RIGHT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );

            IFC( spTestPointer->IsEqualTo(pEnd, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pEnd->MoveAdjacentToElement( spElement,
                                        (wherePointer == RIGHT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::FireOnSelect(IHTMLElement* pIElement)
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbResult;
    SP_IMarkupPointer spPointer;
    
    ((IHTMLEditor*) GetEditor())->AddRef();
    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, ( void**) & spElement3 ));

    if ( _fInFireOnSelect) 
    {
        goto Cleanup; // bail to not have any rentrcny
    }
    
    _fInFireOnSelect = TRUE;
    IFC( spElement3->fireEvent( _T("onselect"), NULL, & vbResult ));
    _fInFireOnSelect = FALSE;

    //
    // Check to see if element is still in tree - by trying to move a pointer to it.
    //
    IFC( spPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin));
    
    if ( _fFailFireOnSelect )
    {
        hr = E_FAIL;
        _fFailFireOnSelect = FALSE;
    }
    
Cleanup:
    ((IHTMLEditor*)GetEditor())->Release();
    
    RRETURN( hr );
}

HRESULT
CSelectionManager::FireOnSelectStart( CEditEvent* pEvent, BOOL* pfOkToSelect, CEditTracker* pTracker )
{
    HRESULT hr;
    SP_IHTMLElement spElement;

    IFC( pEvent->GetElement( & spElement ));
    IFC( FireOnSelectStart( spElement, pfOkToSelect, pTracker ));

Cleanup:
    RRETURN( hr );
}

//+===============================================================================
//
// Method: FireOnSelectStart..
//
// Synopsis - Fire On Select Start back to the element and return the result.
//
//--------------------------------------------------------------------------------
HRESULT
CSelectionManager::FireOnSelectStart( IHTMLElement* pIElement, BOOL * pfOkToSelect , CEditTracker* pTracker )
{
    HRESULT hr     = S_OK ;
    BOOL fireValue = FALSE;

    Assert( !pTracker || !pTracker->IsDormant() );
    Assert( pfOkToSelect != NULL );

    if ( _fInFireOnSelectStart) 
    {
        goto Cleanup; // bail to not have any rentrcny
    }
    _fInFireOnSelectStart = TRUE;
    fireValue = EdUtil::FireOnSelectStart(pIElement) ;
    _fInFireOnSelectStart = FALSE;

    IFC( DoPendingTasks() );
    
    //
    // we fired select start, but something 'bad' happened - and we got made dormant.
    //
    if ( pTracker && pTracker->IsDormant() )
    {
        Assert( GetActiveTracker() != pTracker );
        hr = E_FAIL;
    }        
Cleanup:
    *pfOkToSelect = _fFailFireOnSelectStart ? FALSE : fireValue;
    _fFailFireOnSelectStart = FALSE;
    
    RRETURN (hr);
}


HRESULT 
CSelectionManager::TerminateTypingBatch()
{
    HRESULT hr = S_OK;
    
    if (_pCaretTracker)
        hr = THR(_pCaretTracker->TerminateTypingBatch());

    RRETURN(hr);
}

       
HRESULT
CSelectionManager::StartExitTreeTimer()
{
    HRESULT hr = S_OK;


    Assert(! _fInExitTimer && ! _pITimerWindow );

    //
    // Temp fix for 101237
    // NOTE!  If this EVER gets re'enabled, make sure this object gets addref'd and
    // released properly
    //
#if 0   
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;
    IFC( GetDoc()->get_parentWindow(&_pITimerWindow));
    IFC(_pITimerWindow->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)&_pExitTimer;

    IFC(spWindow3->setInterval(&varCallBack, 
                               0 , 
                               &varLang, &_lTimerID));
#endif

    _fInExitTimer = TRUE;
    
//Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectionManager::StopExitTreeTimer()
{
    HRESULT hr = S_OK ;



#if 0
    Assert( _fInExitTimer && _pITimerWindow );
    IFC( _pITimerWindow->clearInterval(_lTimerID));
#endif

    // Release the cached'd window
    ReleaseInterface( _pITimerWindow );
    _pITimerWindow = NULL;
    
    _fInExitTimer = FALSE;
//Cleanup:
    RRETURN (hr);
}

HRESULT
CExitTreeTimer::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;

    if( _pMan )
    {
        if ( _pMan->_pIElementExitStart )
        {
            IFC( _pMan->DoPendingElementExit());
            Assert( ! _pMan->_pIElementExitStart || _pMan->_fInPendingElementExit );
        }

        if ( _pMan->_fInExitTimer )
        {
            IFC( _pMan->StopExitTreeTimer());
        }
    }
 Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectionManager::GetAdornedElement( IHTMLElement** ppIElement )
{ 
    HRESULT hr = S_OK ;
    
    Assert( HasFocusAdorner());

    if ( ! HasFocusAdorner() || ! ppIElement )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    *ppIElement = _pAdorner->GetAdornedElement(); 
    (*ppIElement)->AddRef();
    
Cleanup:
    RRETURN( hr );
}


VOID
CSelectionManager::EndSelectionChange( BOOL fSucceed /*=TRUE*/)
{
    _ctSelectionChange--;

    //  Sometimes we one of the calls to end selection change may be with fSucceed true,
    //  but we weren't firing onselectionchange unless the last call was fSucceed true.
    //  Now we'll set a flag so that if we are called with fSucceed true at any point
    //  during the event handling, we'll fire onselectionchange.
    if (fSucceed)
        _fSelectionChangeSucceeded = fSucceed;

    if ( _ctSelectionChange == 0 && _fSelectionChangeSucceeded )
    {
        _fSelectionChangeSucceeded = FALSE;

        //
        // We don't fire OnSelectionChange if the caret isn't in an editable region.
        //
        IGNORE_HR( GetEditor()->FireOnSelectionChange( ( GetTrackerType() == TRACKER_TYPE_Caret ||
                                                         (GetTrackerType() == TRACKER_TYPE_Selection && 
                                                          _pSelectTracker->IsWaitingForMouseUp()) ) ? 

                                                        IsContextEditable() || _fDestroyedTextSelection :
                                                        TRUE  ) ); 
    }
}


HRESULT
CSelectionManager::AttachDropListener(IHTMLElement *pDragElement /*=NULL*/)
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLElement spElement;
    
    Assert( ! _pIDropListener );

    IGNORE_HR( GetEditor()->GetBody( & spElement ));

    //  Viewlinks may not have a BODY element, so in that case we'll use the drag element.
    if (!spElement && pDragElement)
    {
        spElement = pDragElement;
    }

    if (spElement)
    {
        ReplaceInterface( & _pIDropListener , (IHTMLElement*) spElement );
        
        IFC( _pDropListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
        IFC( _pIDropListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
        IFC( spElement2->attachEvent(_T("ondrop"), spDisp, & varAttach ));
        Assert( varAttach == VB_TRUE );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachDropListener()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIDropListener );
    
    if (_pIDropListener)
    {
        IFC( _pDropListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
        IFC( _pIDropListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
        IFC( spElement2->detachEvent(_T("ondrop"), spDisp ));
    }
    
    ClearInterface( & _pIDropListener );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::BeginDrag(IHTMLElement *pDragElement /*=NULL*/)
{
    HRESULT hr;
    Assert( ! _fDontScrollIntoView );
    IFC( AttachDropListener(pDragElement));
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EndDrag()
{
    HRESULT hr;
    IFC( DetachDropListener());
    _fDontScrollIntoView = FALSE;

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: OnDropFail
//
// Synopsis: We don't want to cause any scroll into views to occur if OnDrop failed
//           IE5.5 bug 103831
//
//------------------------------------------------------------------------------------


VOID
CSelectionManager::OnDropFail()
{
    _fDontScrollIntoView = TRUE;
}



CSelectionChangeCounter::CSelectionChangeCounter(CSelectionManager *pManager)
{
    Assert(pManager);
    _pManager = pManager;
    _ctSelectionChange = 0;
}

CSelectionChangeCounter::~CSelectionChangeCounter()
{
    Assert(_ctSelectionChange >= 0);
    
    if (_ctSelectionChange > 0)
    {
        TraceTag((tagSelectionChangeCounter, "_ctSelectionChange is %d, should be 0", _ctSelectionChange));
        
        while (_ctSelectionChange)
        {
            EndSelectionChange(FALSE);
        }
    }
}

VOID
CSelectionChangeCounter::BeginSelectionChange()
{
    _pManager->BeginSelectionChange();

    _ctSelectionChange++;
}

VOID
CSelectionChangeCounter::EndSelectionChange(BOOL fSucceed /*=TRUE*/)
{
    _pManager->EndSelectionChange(fSucceed);
    _ctSelectionChange--;
    Assert(_ctSelectionChange >= 0);
}

VOID
CSelectionChangeCounter::SelectionChanged(BOOL fSucceed /*=TRUE*/)
{
    BeginSelectionChange();
    EndSelectionChange(fSucceed);
}



//+====================================================================================
//
// Method:     CSelectionManager::FreezeVirtualCaretPos
//
// Synopsis:   Enter the mode that will freeze virtual caret position. Virtual Caret 
//             position is the X/Y coordinate used as the starting position for up/down line
//             movement. In consecutive up/down line movement case, we want to let 
//             caret move in a vertical/horizontal line as much as possible. If the real caret
//             move up/down lines using the virtual caret position, we will have the desired
//             behavior.  
//
//             Note that virtual caret position might be undefined if there is no previous up/down 
//             movement. Also the Editor can reset virtual caret position in many 
//             occasions that it sees appropriate. This function explicitly asks Editor NOT to reset 
//             virtual caret psotion. 
//
//             We use the X value in horizontal text flow case and Y value in vertical text flow case.
//
// Argument:
//             fReCompute:  TRUE    recompute the Virtual Caret Position with current real caret
//                          FALSE   use current Virtual Caret Position. be it defined or underfined
// Returns:       
//             S_OK:    If MoveStart has been preserved
//             E_FAIL:  if caret tracker is not the active tracker
//
// Note:       This method is only meanful if caret tracker is in control
//
//+=====================================================================================
HRESULT
CSelectionManager::FreezeVirtualCaretPos(BOOL fReCompute)
{
    HRESULT             hr = S_OK;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spMarkup;
    SP_IDisplayPointer  spDisplay;
    POINT               ptLoc;

    if (!_pCaretTracker || _pCaretTracker != _pActiveTracker)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (fReCompute)
    {
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDisplay) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDisplay) );
        IFC( EdUtil::GetDisplayLocation(GetEditor(), spDisplay, &ptLoc, TRUE) );
        
        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );                        
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );

        _pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
        IFC( _pCaretTracker->_ptVirtualCaret.UpdatePosition(spMarkup, ptLoc) );
    }
    
    _pCaretTracker->GetVirtualCaret().FreezePosition(TRUE);

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method:     CSelectionManager::UnFreezeVirtualCaretPos
//
// Synopsis:   We are free to reset virtual caret position.  
//
// Argument:   fReset: TRUE     reset virtual caret position to underfined value
//                     FALSE    don't reset virtual caret position.  
//              
// Returns:       
//             S_OK:     Success
//             E_FAIL:   caret tracker is not in control
//
// Note:       This method is only meanful if caret tracker is in control
//
//+=====================================================================================
HRESULT
CSelectionManager::UnFreezeVirtualCaretPos(BOOL fReset)
{
    HRESULT     hr = S_OK;

    if (!_pCaretTracker || _pCaretTracker != _pActiveTracker)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
    if (fReset)
    {
        _pCaretTracker->GetVirtualCaret().InitPosition();
    }
    else
    {
        //
        // Update MoveStart with current caret CP
        //
        POINT               ptLoc;
        SP_IMarkupPointer   spMarkup;
        SP_IHTMLCaret       spCaret;

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );
        _pCaretTracker->GetVirtualCaret().PeekPosition(&ptLoc);
        IFC( _pCaretTracker->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) );
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT
CSelectionManager::FirePreDrag()
{
    IHTMLEditHost2 *pEditHost2 = GetEditor()->GetEditHost2();

    if (pEditHost2)
    {
        IGNORE_HR( pEditHost2->PreDrag() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\stdafx.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.CXX
//
//  Contents:   Source file that includes ATL standard files
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#pragma warning(disable:4701)   /* local variable  may be used without having been initialized */
#include "stdafx.h"

#pragma warning(disable:4189)   /* local variable is initialized but not referenced */

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\stdafx.h ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.H
//
//  Contents:   Include file for standard ATL include files
//
//-------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_)
#define AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_MIN_CRT
//#define _ATL_MIN_CRT
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

//
// NOTE: ATL depends on the *presence* of _DEBUG to switch into DEBUG mode.
// Trident *always* sets _DEBUG to some value. This causes a problem when
// building a retail build in the Trident tree. 
// undef'ing _DEBUG when _DEBUG is zero solves the problem.
//
#if _DEBUG == 0
# undef _DEBUG
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <stddef.h>
#include <malloc.h>

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void   __cdecl ATL_free(void *);
void * __cdecl ATL_malloc(size_t);
void * __cdecl ATL_realloc(void *, size_t);

#define lstrlenW _tcslen
#define lstrcmpiW StrCmpIW
#define lstrcpynW StrCpyNW
#define lstrcpyW StrCpyW
#define lstrcatW StrCatW

#undef HIMETRIC_PER_INCH

#undef SubclassWindow
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

typedef INT Direction;

#pragma warning( disable : 4510 4610 )  

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#undef malloc
#undef free
#undef realloc


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\sload.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       SLOAD.CXX
//
//  Contents:   Implementation of CSpringLoader class.
//
//  Classes:    CSpringLoader
//
//  History:    07-13-98 - OliverSe - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

using namespace EdUtil;

MtDefine(CSpringLoader, Utilities, "CSpringLoader")

DeclareTag(tagDisableSpringLoader, "Springloader", "Disable Spring Loader")


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::Get(*)Command
//
//  Synopsis:   Inline accessors for commands.
//
//-----------------------------------------------------------------------------

inline IMarkupServices2 *
CSpringLoader::GetMarkupServices()
{
    return _pCommandTarget->GetEditor()->GetMarkupServices();
}

inline IDisplayServices *
CSpringLoader::GetDisplayServices()
{
    return _pCommandTarget->GetEditor()->GetDisplayServices();
}

inline CCommand *
CSpringLoader::GetCommand(DWORD cmdID)
{
    return _pCommandTarget->GetEditor()->GetCommandTable()->Get(cmdID);
}

inline CBaseCharCommand *
CSpringLoader::GetBaseCharCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_BOLD || cmdID == IDM_ITALIC || cmdID == IDM_UNDERLINE || cmdID == IDM_SUBSCRIPT || cmdID == IDM_SUPERSCRIPT || 
           cmdID == IDM_FONTSIZE || cmdID == IDM_FONTNAME || cmdID == IDM_FORECOLOR || cmdID == IDM_BACKCOLOR || 
           cmdID == IDM_STRIKETHROUGH);
    return ((CBaseCharCommand *) GetCommand(cmdID));
}

inline CCharCommand *
CSpringLoader::GetCharCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_BOLD || cmdID == IDM_ITALIC || cmdID == IDM_UNDERLINE || cmdID == IDM_SUBSCRIPT || cmdID == IDM_SUPERSCRIPT ||
           cmdID == IDM_STRIKETHROUGH);
    return ((CCharCommand *) GetCommand(cmdID));
}

inline CFontCommand *
CSpringLoader::GetFontCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_FONTSIZE || cmdID == IDM_FONTNAME || cmdID == IDM_FORECOLOR || cmdID == IDM_BACKCOLOR);
    return ((CFontCommand *) GetCommand(cmdID));
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::CSpringLoader, ~CSpringLoader
//
//  Synopsis:   Constructor and destructor.
//
//-----------------------------------------------------------------------------

CSpringLoader::CSpringLoader(CMshtmlEd * pCommandTarget)
{
    _grfFlags() = 0;
    _pCommandTarget = pCommandTarget;
    _pmpPosition = NULL;

    Assert(_pCommandTarget);
}

CSpringLoader::~CSpringLoader()
{
    // Free springload cache.
    Reset();

    ReleaseInterface(_pmpPosition);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoad
//
//  Synopsis:   Loads the spring loader by copying the formats found found
//              at the position passed in.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoad(IMarkupPointer * pmpPosition, DWORD dwMode /* =0 */)
{
    CSelectionManager * pSelMan;
    SP_IMarkupPointer   spmpSpringLoadFormatting;
    SP_IHTMLComputedStyle spComputedStyle;
    CVariant            varName, varSize, varColor, varBackColor;
    HRESULT             hr = S_OK;
    VARIANT_BOOL        fBold, fItalic, fUnderline, fSuperscript, fSubscript, fStrikeThrough;

    Assert(GetMarkupServices() && pmpPosition);

    // Save off the mode
    _dwMode = dwMode;
    
    // Reset springloader if requested.
    if (dwMode & SL_RESET)
        Reset();

    if (_fSpringLoaded)
        goto Cleanup;

    pSelMan = _pCommandTarget->GetEditor()->GetSelectionManager();
    Assert(pSelMan);
    if (!pSelMan->CanContextAcceptHTML())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(CopyMarkupPointer(_pCommandTarget->GetEditor(), pmpPosition, &spmpSpringLoadFormatting));
    if (S_OK != hr)
        goto Cleanup;

    // Handle AdjustForInsert modes.

    if (dwMode & SL_ADJUST_FOR_INSERT_LEFT)
        IGNORE_HR(AdjustPointerForInsert(spmpSpringLoadFormatting, LEFT, LEFT));
    else if (dwMode & SL_ADJUST_FOR_INSERT_RIGHT)
        IGNORE_HR(AdjustPointerForInsert(spmpSpringLoadFormatting, RIGHT, RIGHT));
    
    // Handle compose settings mode.
    if (dwMode & SL_TRY_COMPOSE_SETTINGS)
    {
        // Attempt to springload compose settings if there is no formatting.
        hr = THR(SpringLoadComposeSettings(spmpSpringLoadFormatting));
        if (hr != S_FALSE)
            goto Cleanup;
    }
    //
    // Obtain current formats.
    //

    IFC( GetDisplayServices()->GetComputedStyle(spmpSpringLoadFormatting, &spComputedStyle) );

    //
    // Convert font formats to variants.
    //

    IFC(GetFontCommand(IDM_FONTNAME)->ConvertFormatDataToVariant(spComputedStyle, &varName));
    IFC(GetFontCommand(IDM_FONTSIZE)->ConvertFormatDataToVariant(spComputedStyle, &varSize));
    IFC(GetFontCommand(IDM_FORECOLOR)->ConvertFormatDataToVariant(spComputedStyle, &varColor));
    IFC(GetFontCommand(IDM_BACKCOLOR)->ConvertFormatDataToVariant(spComputedStyle, &varBackColor));

    //
    // Copy the formats into the spring loader.
    //

    IFC( spComputedStyle->get_bold(&fBold) );
    IFC( spComputedStyle->get_italic(&fItalic) );
    IFC( spComputedStyle->get_underline(&fUnderline) );
    IFC( spComputedStyle->get_superScript(&fSuperscript) );
    IFC( spComputedStyle->get_subScript(&fSubscript) );
    IFC( spComputedStyle->get_strikeOut(&fStrikeThrough) );
    
    SetFormats(BOOL_FROM_VARIANT_BOOL(fBold),
               BOOL_FROM_VARIANT_BOOL(fItalic),
               BOOL_FROM_VARIANT_BOOL(fUnderline),
               BOOL_FROM_VARIANT_BOOL(fSuperscript),
               BOOL_FROM_VARIANT_BOOL(fSubscript),
               BOOL_FROM_VARIANT_BOOL(fStrikeThrough),
               &varName,
               &varSize,
               &varColor,
               &varBackColor);
 
    // We are now springloaded.
    MarkSpringLoaded(spmpSpringLoadFormatting);

Cleanup:

    VariantClear(&varName);
    VariantClear(&varSize);
    VariantClear(&varColor);
    VariantClear(&varBackColor);

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::Fire
//
//  Synopsis:   Applies the springloaded formats information
//              as long as it is valid and wherever it differs
//              from the existing format at the caret.
//
//----------------------------------------------------------------------------

HRESULT
CSpringLoader::Fire(IMarkupPointer * pmpStart, IMarkupPointer * pmpEnd /*=NULL*/, BOOL fMoveCaretToStart /*=TRUE*/ )
{
    IMarkupPointer    * pmpCaret = NULL;
    IHTMLCaret        * pCaret = NULL;
    IHTMLElement      * pElemBlock = NULL;
    CFontCommand      * pFontCommand;
    SP_IHTMLComputedStyle spComputedStyle;
    VARIANT             var;
    BOOL                fFontPropertyChange, fHasEnd = pmpEnd != NULL;
    HRESULT             hr = S_OK;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Max;
    VARIANT_BOOL        fAttribute;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    if (!_fSpringLoaded)
        goto Cleanup;

    Assert(GetMarkupServices() && pmpStart);
    VariantInit(&var);

    //
    // Obtain current formats.
    //

    IFC( GetDisplayServices()->GetComputedStyle(pmpStart, &spComputedStyle) );

    //
    // Create ending markup pointer if one wasn't passed in, and position it next to pmpStart.
    //

    if (!fHasEnd)
    {
        hr = THR(GetEditor()->CreateMarkupPointer(&pmpEnd));
        if (hr)
            goto Cleanup;

        hr = THR(pmpEnd->MoveToPointer(pmpStart));
        if (S_OK != hr)
            goto Cleanup;
    }

    //
    // Before we add any elements, make sure our segment pointers pmpStart
    // and pmpEnd have opposite gravity so that they move outward as we
    // insert or split elements. 
    //

    hr = THR(EnsureCaretPointers(fMoveCaretToStart?pmpStart:pmpEnd, &pCaret, &pmpCaret));

    if (FAILED(hr))
        goto Cleanup;

    // Remember the gravity so we can restore it at Cleanup
    hr = THR(pmpStart->Gravity(& eGravity));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpStart->SetGravity(POINTER_GRAVITY_Left));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpEnd->SetGravity(POINTER_GRAVITY_Right));
    if (S_OK != hr)
        goto Cleanup;

    //
    // If there is any difference between the springloaded formats and the
    // current formats, apply the necessary commands.
    //

    //
    // Span class.
    //

    if (V_VT(&_varSpanClass) != VT_NULL && V_VT(&_varSpanClass) != VT_EMPTY)
    {
        Assert(V_VT(&_varSpanClass) == VT_BSTR);

        BOOL fInSpanScope = InSpanScope(pmpStart);

        if (!fInSpanScope)
        {
            CInsertCommand * pInsertSpanCommand = DYNCAST(CInsertCommand, GetCommand(IDM_INSERTSPAN));

            pInsertSpanCommand->SetAttributeValue(V_BSTR(&_varSpanClass));

            hr = THR(pInsertSpanCommand->ApplyCommandToSegment(pmpStart, pmpEnd, NULL, FALSE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SPAN, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    IFC( spComputedStyle->get_bold(&fAttribute) );

    if (_fBold ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fBold)
            hr = THR(GetCharCommand(IDM_BOLD)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_BOLD)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_STRONG, _fBold));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_italic(&fAttribute) );
    
    if (_fItalic ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fItalic)
            hr = THR(GetCharCommand(IDM_ITALIC)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_ITALIC)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_EM, _fItalic));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_underline(&fAttribute) );
    
    if (_fUnderline ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fUnderline)
            hr = THR(GetCharCommand(IDM_UNDERLINE)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_UNDERLINE)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_U, _fUnderline));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_subScript(&fAttribute) );
    
    if (_fSubscript ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fSubscript)
            hr = THR(GetCharCommand(IDM_SUBSCRIPT)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_SUBSCRIPT)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SUB, _fSubscript));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_superScript(&fAttribute) );
    
    if (_fSuperscript ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fSuperscript)
            hr = THR(GetCharCommand(IDM_SUPERSCRIPT)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_SUPERSCRIPT)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SUP, _fSuperscript));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_strikeOut(&fAttribute) );
    
    if (_fStrikeThrough ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fStrikeThrough)
        {
            IFC( GetCharCommand(IDM_STRIKETHROUGH)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE) )
        }
        else
        {
            IFC( GetCharCommand(IDM_STRIKETHROUGH)->Remove(_pCommandTarget, pmpStart, pmpEnd) );
        }

        IFC( UpdatePointerPositions(pmpStart, pmpEnd, TAGID_STRIKE, _fStrikeThrough) );
    }

    //
    // Font name.
    //

    Assert(V_VT(&_varName) == VT_BSTR || V_VT(&_varName) == VT_NULL);

    if (V_VT(&_varName) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FONTNAME);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varName);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varName, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Font size.
    //

    if (V_VT(&_varSize) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FONTSIZE);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varSize);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varSize, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Fore color.
    //

    if (V_VT(&_varColor) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FORECOLOR);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varColor);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varColor, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Back color.
    //

    if (V_VT(&_varBackColor) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_BACKCOLOR);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varBackColor);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varBackColor, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Move the caret to the position of the segment.
    //

    if (pCaret)
    {
        SP_IDisplayPointer spDispPointer;
    
        IFC( pmpCaret->MoveToPointer(fMoveCaretToStart?pmpStart:pmpEnd) );

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( spDispPointer->MoveToMarkupPointer(pmpCaret, NULL) )

        IFC( pCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE) );
    }
    
Cleanup:

    // Always reset when we are done firing
    Reset();
    
    if (!fHasEnd)
    {
        ReleaseInterface(pmpEnd);
    }

    ReleaseInterface(pmpCaret);
    ReleaseInterface(pCaret);
    ReleaseInterface(pElemBlock);

    // 
    // Restore the gravity for pmpStart
    //
    if (eGravity != POINTER_GRAVITY_Max)
        IGNORE_HR(pmpStart->SetGravity(eGravity));

    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSpringLoader::FireOnEmptyLine
//
//  Synopsis:   Fires the spring loader on empty lines.  Handles the 
//              determination of whether the block pointed to by pmpStart 
//              (or the caret) is empty.  If the caret or the parameter 
//              points to an empty block the spring loader is fired.
//
//  Arguments:  pmpStart = optional param for start pointer
//              fMoveCaret = should we move the caret after the fire?
//
//  Returns:    HRESULT indicating whether the function was successful
//
//--------------------------------------------------------------------------
HRESULT
CSpringLoader::FireOnEmptyLine(IMarkupPointer *pmpStart /* =NULL */, BOOL fMoveCaret /*= FALSE */)
{
    HRESULT             hr = S_OK;
    CBlockPointer       bpBlock(_pCommandTarget->GetEditor());
    BOOL                bEmpty = FALSE;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spCaretPos;
    BOOL                fHasStart = (pmpStart != NULL);

    Assert(GetMarkupServices());

    if( IsSpringLoaded() )
    {
        if( !fHasStart )
        {  
            GetEditor()->CreateMarkupPointer( &pmpStart );
            IFC( GetDisplayServices()->GetCaret( &spCaret ));
            IFC( spCaret->MoveMarkupPointerToCaret( pmpStart ) );
        }

        // Position our block pointer and check if it is empty
        IFC( bpBlock.MoveTo( pmpStart, LEFT ) );
        IFC( bpBlock.IsEmpty( &bEmpty ) );

        // TODO - Make sure we are not firing the compose settings
        if( bEmpty == TRUE )
        {
            IFC( Fire( pmpStart, NULL, fMoveCaret ) );
        }
    }
    
Cleanup:
    if( !fHasStart )
    {
        ReleaseInterface( pmpStart );
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::Reset
//
//  Synopsis:   Resets the springloaded format information.
//
//----------------------------------------------------------------------------

void
CSpringLoader::Reset(IMarkupPointer * pmpPosition)
{   
    // Don't reset springloader at the same position it was loaded.
    if (IsSpringLoadedAt(pmpPosition))
        return;
        
    ClearInterface(&_pmpPosition);

    _grfFlags() = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::IsSpringLoadedAt
//
//  Synopsis:   Returns TRUE iff springloader is loaded at spec markup pointer.
//
//----------------------------------------------------------------------------

BOOL
CSpringLoader::IsSpringLoadedAt(IMarkupPointer * pmpPosition)
{
    HRESULT hr;
    int iPosition;

    if (!_fSpringLoaded || !_pmpPosition || !pmpPosition)
        return FALSE;

    hr = THR(OldCompare( _pmpPosition, pmpPosition, &iPosition));
    if (S_OK != hr)
        return FALSE;
    
    return iPosition == SAME
        || (   iPosition == RIGHT
            && IsSeparatedOnlyByPhraseScopes(_pmpPosition, pmpPosition));
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SetFormats
//
//  Synopsis:   Saves the format info passed in.
//
//-----------------------------------------------------------------------------

void
CSpringLoader::SetFormats( BOOL       fBold,
                           BOOL       fItalic,
                           BOOL       fUnderline,
                           BOOL       fSuperscript,
                           BOOL       fSubscript,
                           BOOL       fStrikeThrough,
                           CVariant * pvarName,
                           CVariant * pvarSize,
                           CVariant * pvarColor,
                           CVariant * pvarBackColor)
{
    HRESULT hr = S_OK;
    _fSuperscript = fSuperscript;
    _fSubscript = fSubscript;
    _fBold = fBold;
    _fItalic = fItalic;
    _fUnderline = fUnderline;
    _fStrikeThrough = fStrikeThrough;
    
    hr = VariantCopy(&_varName, pvarName);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = VariantCopy(&_varSize, pvarSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = VariantCopy(&_varColor, pvarColor);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr  = VariantCopy(&_varBackColor, pvarBackColor);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
Cleanup:
    return;
}


void
CSpringLoader::MarkSpringLoaded(IMarkupPointer * pmpPosition)
{
    HRESULT hr;

    // Remember the position we are being springloaded at.
    ClearInterface(&_pmpPosition);

    if (pmpPosition)
    {
        hr = THR(GetEditor()->CreateMarkupPointer(&_pmpPosition));
        if (S_OK != hr)
            goto Cleanup;

        hr = THR(_pmpPosition->MoveToPointer(pmpPosition));
        if (S_OK != hr)
            goto Cleanup;

        Assert(_pmpPosition);
    }

    _fSpringLoaded = TRUE;

Cleanup:
    return;
}


HRESULT
CSpringLoader::EnsureCaretPointers( IMarkupPointer  * pmpPosition,
                                    IHTMLCaret     ** ppCaret,
                                    IMarkupPointer ** ppmpCaret )
{
    IMarkupPointer    * pmpCaret = NULL;
    IHTMLCaret        * pCaret = NULL;
    BOOL                fEqual = FALSE;
    HRESULT             hr;

    Assert(_fSpringLoaded && pmpPosition && GetMarkupServices());

    hr = THR(GetDisplayServices()->GetCaret(&pCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pCaret->MoveMarkupPointerToCaret(pmpCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpCaret->IsEqualTo(pmpPosition, &fEqual));
    if (S_OK != hr)
        goto Cleanup;

    if (!fEqual)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(pmpCaret->SetGravity(POINTER_GRAVITY_Right));

Cleanup:

    if (S_OK != hr)
    {
        hr = S_FALSE;
        ReleaseInterface(pmpCaret);
        ReleaseInterface(pCaret);
    }
    else
    {
        *ppmpCaret = pmpCaret;
        *ppCaret = pCaret;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::UpdatePointerPositions
//
//  Synopsis:   Moves springloader pointers into newly created, empty scope.
//
//----------------------------------------------------------------------------

HRESULT
CSpringLoader::UpdatePointerPositions( IMarkupPointer * pmpStart,
                                       IMarkupPointer * pmpEnd,
                                       ELEMENT_TAG_ID   tagIdScope,
                                       BOOL             fApplyElement )
{
    MARKUP_CONTEXT_TYPE mctContext;
    IHTMLElement      * pElemScope = NULL;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    ELEMENT_TAG_ID      tagId;
    HRESULT             hr = S_OK;
    BOOL                bEqual;

    Assert(_fSpringLoaded && pmpStart && pmpEnd && pMarkupServices);

    IFC( pmpStart->IsEqualTo(pmpEnd, &bEqual) );
    if (bEqual)
        return S_OK; // done - already in correct position

    //
    // Move start pointer.
    //

    hr = THR(pmpStart->Right(FALSE, &mctContext, &pElemScope, NULL, NULL));
    if (S_OK != hr)
        goto Cleanup;

    if (!pElemScope)
        goto MoveEndPointer;

    hr = THR(pMarkupServices->GetElementTagId(pElemScope, &tagId));
    if (S_OK != hr)
        goto Cleanup;

    // If we are entering/exiting a scope as expected, go ahead and walk all pointers.
    if (   mctContext == (fApplyElement?CONTEXT_TYPE_EnterScope:CONTEXT_TYPE_ExitScope)
        && tagId == tagIdScope )
    {
        hr = THR(pmpStart->Right(TRUE, NULL, NULL, NULL, NULL));
        if (S_OK != hr)
            goto Cleanup;
    } // else an optimization prevented us from creating any gaps

MoveEndPointer:

    ClearInterface(&pElemScope);

    //
    // Move end pointer.
    //

    hr = THR( pmpEnd->Left(FALSE, &mctContext, &pElemScope, NULL, NULL));
    if (hr || !pElemScope)
        goto Cleanup;

    hr = THR(pMarkupServices->GetElementTagId(pElemScope, &tagId));
    if (S_OK != hr)
        goto Cleanup;

    // If we are entering/exiting a scope as expected, go ahead and walk all pointers.
    if (   mctContext == (fApplyElement?CONTEXT_TYPE_EnterScope:CONTEXT_TYPE_ExitScope)
        && tagId == tagIdScope )
    {
        hr = THR(pmpEnd->Left(TRUE, NULL, NULL, NULL, NULL));
        if (S_OK != hr)
            goto Cleanup;
    }

Cleanup:

    ReleaseInterface(pElemScope);
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::PrivateExec
//
//  Synopsis:   Opportunity for spring loader to intercept a command and - if
//              it hasn't already - prime itself.
//
//              This is only done for a selected number of IDM commands and
//              if the selection / range is empty (caret).
//
//  Returns:    S_OK if the command was handled.  S_FALSE if the command
//              has not been handled.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::PrivateExec( DWORD             nCmdID,
                            VARIANTARG      * pvarargIn,
                            VARIANTARG      * pvarargOut,
                            ISegmentList    * pSegmentList )
{
    IMarkupPointer      *pmpPosition = NULL;
    HRESULT             hr;
    CSelectionManager   *pSelMan;

    Assert(GetMarkupServices());
    Assert(pSegmentList || _fSpringLoaded);

    
    //
    // Determine whether the spring loader can handle this command
    // and if so return start and end markup pointers.
    //

    hr = THR(CanHandleCommand(nCmdID, pSegmentList, &pmpPosition, pvarargIn));
    if (S_OK != hr)
        goto Cleanup;

    //
    // Springload if we haven't already.
    //

    if (!_fSpringLoaded)
    {

        // Retrieve the current selection manager
        pSelMan = _pCommandTarget->GetEditor()->GetSelectionManager();
        Assert(pSelMan);

        // Terminate any IME compositions
#ifndef NO_IME
        if( pSelMan->IsIMEComposition() )
        {
            pSelMan->TerminateIMEComposition(TERMINATE_NORMAL);
        }
#endif // NO_IME        
        
        hr = THR(SpringLoad(pmpPosition));
        if (S_OK != hr)
            goto Cleanup;
    }

    //
    // Cache / handle the command.
    //

    switch (nCmdID)
    {
    case IDM_BOLD:
        _fBold = !_fBold;
        break;
    case IDM_ITALIC:
        _fItalic = !_fItalic;
        break;
    case IDM_UNDERLINE:
        _fUnderline = !_fUnderline;
        break;
    case IDM_SUBSCRIPT:
        _fSubscript = !_fSubscript;
        break;
    case IDM_SUPERSCRIPT:
        _fSuperscript = !_fSuperscript;
        break;
    case IDM_STRIKETHROUGH:
        _fStrikeThrough = !_fStrikeThrough;
        break;
    case IDM_FONTNAME:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varName, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varName);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    case IDM_FONTSIZE:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varSize, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            // Some apps assume VT_I4 is coming back (eg. Home Publisher)
            if (V_VT(&_varSize) == VT_BSTR)
            {
                if (FAILED(VariantChangeTypeSpecial(pvarargOut, &_varSize,  VT_I4)))
                {
                    hr = VariantCopy(pvarargOut, &_varSize);                    
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                hr = VariantCopy(pvarargOut, &_varSize);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
        
            }
        }
        break;
    case IDM_FORECOLOR:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varColor, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varColor);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    case IDM_BACKCOLOR:
        if (pvarargIn)
        {    
            hr = VariantCopy(&_varBackColor, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varBackColor);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    }

    if (pvarargOut && V_VT(pvarargOut)==VT_NULL)
    {
        // If the springloader couldn't answer, let the command answer.
        Assert(IDM_FONTNAME == nCmdID || IDM_FONTSIZE == nCmdID || IDM_FORECOLOR == nCmdID || IDM_BACKCOLOR == nCmdID);
        Assert(!pvarargIn);
        hr = S_FALSE;
    }

Cleanup:

    ReleaseInterface(pmpPosition);

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::PrivateQueryStatus
//
//  Synopsis:   Opportunity for spring loader to intercept a query status
//              request that has been cached in the spring loader, but hasn't
//              been applied to (or removed from) the selection / range.
//
//              This is only done for a selected number of IDM commands and if
//              the springloader is loaded.
//
//  Returns:    S_OK if the query was handled.  S_FALSE if the query
//              has not been handled.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::PrivateQueryStatus(DWORD nCmdID, OLECMD rgCmds[])
{
    OLECMD * pCmd = &rgCmds[0];
    HRESULT  hr = S_FALSE;

    Assert(pCmd);

    if (!_fSpringLoaded)
        goto Cleanup;

    //
    // Query the spring loader for the command state.
    //

    hr = S_OK;

    switch (nCmdID)
    {
    case IDM_BOLD:
    case IDM_TRISTATEBOLD:
        pCmd->cmdf = _fBold ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_ITALIC:
    case IDM_TRISTATEITALIC:
        pCmd->cmdf = _fItalic ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_UNDERLINE:
    case IDM_TRISTATEUNDERLINE:
        pCmd->cmdf = _fUnderline ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_SUBSCRIPT:
        pCmd->cmdf = _fSubscript ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_SUPERSCRIPT:
        pCmd->cmdf = _fSuperscript ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_STRIKETHROUGH:
        pCmd->cmdf = _fStrikeThrough ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_FONTNAME:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_FONTSIZE:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_FORECOLOR:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_BACKCOLOR:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    default:
        hr = S_FALSE;
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::CanHandleCommand
//
//  Synopsis:   Determines whether the selection passed in is empty and the
//              command is supported.
//
//  Returns:    S_OK if the command can be handled by the springloader.
//              S_FALSE if the command cannot been handled.
//
//              If S_OK, also return pmpPosition markup pointer.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::CanHandleCommand( DWORD             nCmdID,
                                 ISegmentList    * pSegmentList,
                                 IMarkupPointer ** ppmpPosition,
                                 VARIANTARG      * pvarargIn )
{
    IMarkupPointer    * pmpStart, * pmpEnd;
    CSegmentListIter    iter;
    BOOL                fEmpty = FALSE;
    int                 iPosition;
    HRESULT             hr = S_OK;
    int                 nLength = 0;

    Assert(GetMarkupServices());

    switch (nCmdID)
    {
    case IDM_BOLD:
    case IDM_ITALIC:
    case IDM_UNDERLINE:
    case IDM_SUBSCRIPT:
    case IDM_SUPERSCRIPT:
    case IDM_STRIKETHROUGH:
        break;

    case IDM_FONTNAME:
    case IDM_FONTSIZE:
    case IDM_FORECOLOR:
    case IDM_BACKCOLOR:
    case IDM_INSERTSPAN:

        if (_fSpringLoaded || pvarargIn)
            break;

        // fall through
    default:
        hr = S_FALSE;
        goto Cleanup;
    }

    if (!pSegmentList)
    {
        Assert(_fSpringLoaded);
        goto Cleanup;
    }

    //
    // Make sure we have an only one segment in our selection.    
    //

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    IFC( GetSegmentCount( pSegmentList, &nLength ) );

    if( fEmpty == TRUE || nLength > 1 )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = iter.Init(GetEditor(), pSegmentList);
    if (FAILED(hr))
        goto Cleanup;

    hr = iter.Next(&pmpStart, &pmpEnd);
    if (FAILED(hr))
        goto Cleanup;

    if (!pmpStart || !pmpEnd)
    {
        hr = S_FALSE;
        goto Cleanup;
    }


    if (ppmpPosition)
    {
        // APPCOMPAT: Outlook is creating an "nbsp" selection before the user
        // can type in a new line.  Thus the pmpStart and pmpEnd pointers are
        // temporarily in different positions, and that is why we perform
        // the following comparison only when we are actually springloading
        // (ppmpStart not NULL) and not when we are already springloaded.

        hr = THR(OldCompare( pmpStart, pmpEnd, &iPosition));
        if (S_OK != hr)
            goto Cleanup;

        // If the position is different, selection 6is not empty.
        if (iPosition)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        //
        // At this point we know, we have an empty selection (range).
        //

        *ppmpPosition = pmpStart;
        pmpStart->AddRef();
    }

    hr = S_OK;

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadComposeSettings
//
//  Synopsis:   Loads the default font settings made by the host into the spring
//              loader.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoadComposeSettings(IMarkupPointer * pmpNewPosition, BOOL fReset, BOOL fOutsideSpan)
{
    Assert(_pCommandTarget && _pCommandTarget->GetEditor());
    struct COMPOSE_SETTINGS * pComposeSettings = _pCommandTarget->GetEditor()->GetComposeSettings();
    BOOL                      fSpringLoadAcrossLayout = FALSE;
    HRESULT                   hr = S_OK;

    if (fReset)
        Reset();

    // Determine whether we are allowed to springload compose settings at the
    // position specified.

    if (   !pComposeSettings
        || !pComposeSettings->_fComposeSettings
        || _fSpringLoaded) // don't springload again
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Check whether we can springload compose settings at the position passed in.
    //

    hr = THR(CanSpringLoadComposeSettings(pmpNewPosition, &fSpringLoadAcrossLayout, fOutsideSpan));
    if (hr || fSpringLoadAcrossLayout)
        goto Cleanup;


    //
    // Check if there is already some paragraph formatting associated with the empty line.
    // If so, spring load it instead of the compose font.
    //
    hr = THR(SpringLoadParagraphFormatting(pmpNewPosition));
    if (hr != S_FALSE)
        goto Cleanup;

    //
    // Finally, springload compose settings.
    //

    Assert(pComposeSettings && pComposeSettings->_fComposeSettings);

    _fBold        = pComposeSettings->_fBold;
    _fItalic      = pComposeSettings->_fItalic;
    _fUnderline   = pComposeSettings->_fUnderline;
    _fSuperscript = pComposeSettings->_fSuperscript;
    _fSubscript   = pComposeSettings->_fSubscript;
    _fStrikeThrough = FALSE; // no compose font support for strikethrough 

    hr = VariantCopy(&_varName, &pComposeSettings->_varFont);
    if (FAILED(hr))
        goto Cleanup;
    hr = VariantCopy(&_varSpanClass, &pComposeSettings->_varSpanClass);
    if (FAILED(hr))
        goto Cleanup;
    
    if (pComposeSettings->_color & CColorValue::MASK_FLAG)
        V_VT(&_varColor)= VT_NULL;
    else
    {
        V_VT(&_varColor)    = VT_I4;
        V_I4(&_varColor)    = pComposeSettings->_color;
    }

    if (pComposeSettings->_colorBg & CColorValue::MASK_FLAG)
        V_VT(&_varBackColor)= VT_NULL;
    else
    {
        V_VT(&_varBackColor)= VT_I4;
        V_I4(&_varBackColor)= pComposeSettings->_colorBg;
    }

    if (pComposeSettings->_lSize == -1)
        V_VT(&_varSize)     = VT_NULL;
    else
    {
        V_VT(&_varSize)     = VT_I4;
        // Sizes in this spring loader are in the 1..7 range
        V_I4(&_varSize)     = pComposeSettings->_lSize;
    }

    // We are now springloaded.
    MarkSpringLoaded(pmpNewPosition);
    hr = S_OK;

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CSpringLoader::CanSpringLoadComposeSettings(IMarkupPointer * pmpNewPosition, BOOL * pfCanOverrideSpringLoad, BOOL fOutsideSpan, BOOL fDontJump)
{
    IHTMLElement      * pElemWalk = NULL;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    BOOL                fInHTMLEditMode = IsDocumentInHTMLEditMode();
    HRESULT             hr;

    Assert(pMarkupServices);

    // Not passing in a position pretty much means a free ticket to springloading.
    if (fInHTMLEditMode && !pmpNewPosition)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // If we are not in html edit mode, don't springload compose settings.
    if ( !fInHTMLEditMode )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get our nearest parent element (scope).
    hr = THR(pmpNewPosition->CurrentScope(&pElemWalk));
    if (S_OK != hr)
        goto Cleanup;

    // If we are not in a body container, don't springload.
    if( !pElemWalk || HasNonBodyContainer(pMarkupServices, pElemWalk))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (fOutsideSpan)
    {
        // If we are in "format text outside any of our span tags in compose settings" mode, and
        // we are outside one of our span tags, allow springloading occur next to text.
        Assert(_pCommandTarget && _pCommandTarget->GetEditor());
        struct COMPOSE_SETTINGS * pComposeSettings = _pCommandTarget->GetEditor()->GetComposeSettings();
        if (pComposeSettings && pComposeSettings->_fUseOutsideSpan && !InSpanScope(pmpNewPosition))
            goto Cleanup;
    }

    // Walk up the parent element chain in search of the first block elemnent.  If it is
    // empty, allow springloading of compose settings.  If it isn't, don't allow it.
    while (pElemWalk)
    {
        IHTMLElement * pElemParent;
        BOOL           fBlockElement;

        // Look for a block element.
        hr = THR(IsBlockOrLayoutOrScrollable(pElemWalk, &fBlockElement));
        if (hr)
            goto Cleanup;

        // If we find a block element, we are making the decision now.
        if (fBlockElement)
        {
            // Blocks that already have formats associated with them
            // don't allow compose settings.
            if (IsCharFormatBlock(pElemWalk))
            {
                hr = S_FALSE;
            }
            else if (!IsBlockEmptyForSpringLoading(pmpNewPosition, pElemWalk, fDontJump))
            {
                if (!fDontJump)
                {
                    // If the position doesn't have formatting, attempt to springload
                    // formatting from text found nearby.
                    BOOL fSpringLoaded = SpringLoadFormatsAcrossLayout(pmpNewPosition, pElemWalk, pfCanOverrideSpringLoad!=NULL);
                    if (fSpringLoaded)
                    {
                        if (pfCanOverrideSpringLoad)
                            *pfCanOverrideSpringLoad = TRUE;
                        goto Cleanup;
                    }
                }

                hr = S_FALSE;
            }

            goto Cleanup;
        }

        hr = THR(GetEditor()->GetParentElement(pElemWalk, &pElemParent));
        if (hr)
            goto Cleanup;

        ReleaseInterface(pElemWalk);
        pElemWalk = pElemParent;
    }

    hr = S_FALSE;

Cleanup:

    ReleaseInterface(pElemWalk);

    RRETURN1(hr, S_FALSE);
}


BOOL
CSpringLoader::IsCharFormatBlock(IHTMLElement * pElem)
{
    IMarkupServices * pMarkupServices = GetMarkupServices();
    BOOL              fResult = FALSE;
    ELEMENT_TAG_ID    tagid;
    HRESULT           hr;

    Assert(pMarkupServices);

    hr = THR(pMarkupServices->GetElementTagId(pElem, &tagid));
    if (hr || !pElem)
        goto Cleanup;

    fResult = tagid >= TAGID_H1 && tagid <= TAGID_H6 || tagid == TAGID_PRE;

Cleanup:

    return fResult;
}


BOOL
CSpringLoader::CanJumpOverElement(IHTMLElement * pElem)
{
    BOOL fCanJump = IsCharFormatBlock(pElem);

    if (!fCanJump)
    {
        ELEMENT_TAG_ID tagid;
        HRESULT hr = THR(GetMarkupServices()->GetElementTagId(pElem, &tagid));
        if (!hr && pElem && tagid == TAGID_A)
            fCanJump = TRUE;
    }

    if (!fCanJump)
        IGNORE_HR(IsBlockOrLayoutOrScrollable(pElem, NULL, &fCanJump));

    return fCanJump;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::InSpanScope
//
//  Synopsis:   Checks whether the FIRST (!) span encountered up the parent
//              chain has the springloaded class.
//              loader.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::InSpanScope(IMarkupPointer * pmpPosition)
{
    IMarkupServices * pMarkupServices = GetMarkupServices();
    IHTMLElement    * pElem = NULL;
    ELEMENT_TAG_ID    tagId = TAGID_NULL;
    BOOL              fInSpanScope = FALSE;
    CVariant          varSpanClass;
    HRESULT           hr;

    Assert(pmpPosition && V_VT(&_varSpanClass) == VT_BSTR);

    //
    // Look for span on parent chain.
    //

    IFC( pmpPosition->CurrentScope( &pElem ) );

    while (tagId != TAGID_SPAN)
    {
        IHTMLElement * pElemParent = NULL;

        if (!pElem)
            goto Cleanup;

        hr = THR(pMarkupServices->GetElementTagId(pElem, &tagId));
        if (hr)
            goto Cleanup;

        if (tagId == TAGID_SPAN)
            break;
        else if (tagId == TAGID_BODY)
            goto Cleanup;

        hr = THR(GetEditor()->GetParentElement(pElem, &pElemParent));
        if (hr)
            goto Cleanup;

        ReleaseInterface(pElem);
        pElem = pElemParent;
    }

    // Found span.
    Assert(tagId == TAGID_SPAN && pElem);

    //
    // Check class name.
    //

    hr = THR(pElem->getAttribute(_T("class"), 0, &varSpanClass));
    if (hr)
        goto Cleanup;

    if (   V_VT(&varSpanClass) == VT_BSTR
        && !_tcscmp(V_BSTR(&varSpanClass), V_BSTR(&_varSpanClass)) )
    {
        fInSpanScope = TRUE;
    }

    if (!fInSpanScope)
    {
        hr = THR(pElem->getAttribute(_T("className"), 0, &varSpanClass));
        if (hr)
            goto Cleanup;

        if (   V_VT(&varSpanClass) == VT_BSTR
            && !_tcscmp(V_BSTR(&varSpanClass), V_BSTR(&_varSpanClass)) )
        {
            fInSpanScope = TRUE;
        }
    }

Cleanup:

    ReleaseInterface(pElem);
    return fInSpanScope;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsSeparatedOnlyByPhraseScopes
//
//  Synopsis:   Checks if the two markup pointers are only separated by phrase
//              or span element enter scopes.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsSeparatedOnlyByPhraseScopes(IMarkupPointer * pmpLeft, IMarkupPointer * pmpRight)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    SP_IHTMLElement     spElemWalk;
    SP_IMarkupPointer   spmpWalk;
    MARKUP_CONTEXT_TYPE mctContext;
    int                 iPosition = RIGHT;
    BOOL                fRet = FALSE;
    ELEMENT_TAG_ID      tagId;
    HRESULT             hr;

    Assert(pMarkupServices && pmpLeft && pmpRight);
    Assert(S_OK == THR(OldCompare( pmpLeft, pmpRight, &iPosition)) && iPosition == RIGHT);

    IFC(CopyMarkupPointer(_pCommandTarget->GetEditor(), pmpLeft, &spmpWalk));

    while (S_OK == THR(OldCompare( spmpWalk, pmpRight, &iPosition)) && iPosition == RIGHT)
    {
        IFC(spmpWalk->Right(TRUE, &mctContext, &spElemWalk, NULL, NULL));

        if (   (mctContext != CONTEXT_TYPE_EnterScope && mctContext != CONTEXT_TYPE_ExitScope)
            || !spElemWalk
            || S_OK != THR(pMarkupServices->GetElementTagId(spElemWalk, &tagId))
            || (!_pCommandTarget->GetEditor()->IsPhraseElement(spElemWalk) &&
                tagId != TAGID_DIV) // APPCOMPAT: 57834 Outlook 98 - allow going through DIVs
           )
        {
            goto Cleanup;
        }
    }

    fRet = iPosition == SAME;

Cleanup:

    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsDocumentInHTMLEditMode
//
//  Synopsis:   Checks if the document is in HTML edit mode for compose font.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsDocumentInHTMLEditMode()
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IOleCommandTarget * pDoc = NULL;
    OLECMD              cmd;
    BOOL                fDocumentInHTMLEditMode = TRUE;
    HRESULT             hr;

    hr = THR(pMarkupServices->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &pDoc));
    if (hr || !pDoc)
        goto Cleanup;

    cmd.cmdID = IDM_HTMLEDITMODE;
    hr = THR(pDoc->QueryStatus((GUID *)&CGID_MSHTML, 1, &cmd, NULL));
    fDocumentInHTMLEditMode = hr != S_OK || MSOCMDSTATE_DOWN == cmd.cmdf;

Cleanup:

    ReleaseInterface(pDoc);

    return fDocumentInHTMLEditMode;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsBlockEmptyForSpringLoading
//
//  Synopsis:   Checks if the block element passed in is empty for spring
//              loading purposes. It is empty if it contains no chars or if
//              all the chars that it contains are synthetic chars.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsBlockEmptyForSpringLoading(IMarkupPointer * pmpStart, IHTMLElement * pElemBlock, BOOL fDontJump)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pmpBlockDelimiter = NULL;
    IMarkupPointer    * pmpWalk = NULL;
    IHTMLElement      * pElemWalk = NULL;
    ELEMENT_TAG_ID      tagId;
    MARKUP_CONTEXT_TYPE mctContext;
    long                cch;
    TCHAR               ch;
    BOOL                fEmpty = FALSE;
    int                 iResult, cNBSP = 0, iDirection;
    HRESULT             hr;
    BOOL                fAllowWhitespace = TRUE;

#if DBG==1
    BOOL fBlockElement;
    Assert(pMarkupServices);
    Assert(pElemBlock && (S_OK == THR(IsBlockOrLayoutOrScrollable(pElemBlock, &fBlockElement))) && fBlockElement);
#endif // DBG==1

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpBlockDelimiter));
    if (hr)
        goto Cleanup;

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpWalk));
    if (hr)
        goto Cleanup;

    //
    // Look to the left and right in search for text.
    //

    for (iDirection = -1 ; iDirection <= 1 ; iDirection += 2)
    {
        hr = THR(pmpWalk->MoveToPointer(pmpStart));
        if (hr)
            goto Cleanup;

        if (iDirection == -1)
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_AfterBegin));
        else
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_BeforeEnd));
        if (hr)
            goto Cleanup;

        // Search left or right.
        while (S_OK == THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult)) && (iResult*iDirection) < 0)
        {
            BOOL fStopLooking = FALSE;

            // Walk one character at a time.
            ClearInterface(&pElemWalk);
            cch = 1;
            if (iDirection == -1)
                hr = THR(pmpWalk->Left(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            else
                hr = THR(pmpWalk->Right(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            if (hr)
                goto Cleanup;

            switch (mctContext)
            {
            case CONTEXT_TYPE_EnterScope:
                // We can jump over layouts (TABLE, nested DIV, BUTTON, etc).
                if (!fDontJump && pElemWalk && CanJumpOverElement(pElemWalk))
                {
                    IGNORE_HR(pmpWalk->MoveAdjacentToElement(pElemWalk, ((iDirection==-1)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd)));
                    fAllowWhitespace = FALSE;
                }
                break;

            case CONTEXT_TYPE_NoScope:
                // BRs mean we're done looking in that direction.
                if (pElemWalk && S_OK == THR(pMarkupServices->GetElementTagId(pElemWalk, &tagId)) && TAGID_BR == tagId)
                    fStopLooking = TRUE;
                break;

            case CONTEXT_TYPE_Text:
                // If we find non-whitespace text, the search is over.
                if (cch && (!fAllowWhitespace || !IsWhiteSpace(ch)) && (WCH_NBSP != ch || ++cNBSP >= 4))
                    goto Cleanup;
                break;
            }

            if (fStopLooking)
                break;
        }
    }

    // If we make it here, the blockelement is empty (has no text).
    fEmpty = TRUE;

Cleanup:

    ReleaseInterface(pmpBlockDelimiter);
    ReleaseInterface(pmpWalk);
    ReleaseInterface(pElemWalk);

    return fEmpty;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadFormatsAcrossLayout
//
//  Synopsis:   If the markup ptr is next to a site, then springload using
//              formats copied from the other side of the site.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::SpringLoadFormatsAcrossLayout(IMarkupPointer * pmpPosition, IHTMLElement * pElemBlock, BOOL fActuallySpringLoad)
{
    IMarkupPointer    * pmpBlockDelimiter = NULL;
    IMarkupPointer    * pmpWalk = NULL;
    IMarkupPointer    * pmpAcrossLayout = NULL;
    IHTMLElement      * pElemWalk = NULL;
    IHTMLElement      * pElemToLeft = NULL, * pElemToRight = NULL;
    MARKUP_CONTEXT_TYPE mctContext;
    long                cch;
    TCHAR               ch;
    DWORD               dwSpringLoad = 0;
    int                 iResult, iDirection, cNBSP = 0;
    HRESULT             hr;

    Assert(GetMarkupServices() && pmpPosition && pElemBlock);

    //
    // 1. Optimization and important first cut:  If we are directly next to real (formatted) text, don't override formatting.
    //

    cch = 1;
    if (   S_OK != THR(pmpPosition->Left(FALSE, &mctContext, &pElemToLeft, &cch, &ch))
        || (mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch))
        goto Cleanup;
    cch = 1;
    if (   S_OK != THR(pmpPosition->Right(FALSE, &mctContext, &pElemToRight, &cch, &ch))
        || (mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch))
        goto Cleanup;

    //
    // 2. Next see if an adjust for insert gets us next to text: First left, then right.
    //

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpWalk));
    if (hr)
        goto Cleanup;

    // Check on the left side.
    // Only if we don't have a jumpable element.  This assumes adjust for insert doesn't leave tags.
    if (!pElemToLeft || !CanJumpOverElement(pElemToLeft))
    {
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;
    
        cch = 1;
        if (   S_OK == THR(AdjustPointerForInsert(pmpWalk, LEFT, LEFT))
            && S_OK == THR(pmpWalk->Left(FALSE, &mctContext, NULL, &cch, &ch))
            && mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch)
        {
            dwSpringLoad = SL_ADJUST_FOR_INSERT_LEFT;
            pmpAcrossLayout = pmpWalk;
            pmpWalk = NULL;
            goto SpringLoad;
        }
    }

    // Check on the right side.
    // Only if we don't have a jumpable element.  This assumes adjust for insert doesn't leave tags.
    if (!pElemToRight || !CanJumpOverElement(pElemToRight))
    {
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;

        cch = 1;
        if (   S_OK == THR(AdjustPointerForInsert(pmpWalk, RIGHT, RIGHT))
            && S_OK == THR(pmpWalk->Right(FALSE, &mctContext, NULL, &cch, &ch))
            && mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch)
        {
            dwSpringLoad = SL_ADJUST_FOR_INSERT_RIGHT;
            pmpAcrossLayout = pmpWalk;
            pmpWalk = NULL;
            goto SpringLoad;
        }
    }

    //
    // 3. Look for formatted text on the other side of elements: First left then right.
    //

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpBlockDelimiter));
    if (hr)
        goto Cleanup;

    for (iDirection = -1 ; iDirection <= 1 ; iDirection += 2)
    {
        // Start out walk pointer at position specified.
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;

        // Set up pointer on block element start or end.
        if (iDirection == -1)
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_AfterBegin));
        else
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_BeforeEnd));
        if (hr)
            goto Cleanup;

        // Start walking.
        while (S_OK == THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult)) && (iResult*iDirection) < 0)
        {
            BOOL fFoundRealText = FALSE;
            BOOL fOutOfBounds = FALSE;

            // Walk one character at a time.
            ClearInterface(&pElemWalk);
            cch = 1;
            if (iDirection == -1)
                hr = THR(pmpWalk->Left(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            else
                hr = THR(pmpWalk->Right(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            if (hr)
                goto Cleanup;

            // If we find an element, see if we can jump over it in order to find the formatted text
            // on its other side.
            switch (mctContext)
            {
            case CONTEXT_TYPE_EnterScope:
                // Can jump over layouts (TABLE, nested DIV, BUTTON, etc), charformat blockelements and anchors.
                if (pElemWalk && CanJumpOverElement(pElemWalk))
                {
                    hr = THR(pmpWalk->MoveAdjacentToElement(pElemWalk, ((iDirection==-1)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd)));
                    if (hr)
                        goto Cleanup;

                    hr = THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult));
                    if (hr)
                        goto Cleanup;

                    fOutOfBounds = (iResult*iDirection) >= 0;
                }
                // fall through

            case CONTEXT_TYPE_NoScope:
                if (   pElemWalk
                    && !pmpAcrossLayout)
                {
                    hr = THR(GetEditor()->CreateMarkupPointer(&pmpAcrossLayout));
                    if (hr)
                        goto Cleanup;
                }
                break;

            case CONTEXT_TYPE_Text:
                // Check if we found REAL text (ignore spaces).
                fFoundRealText = cch && !IsWhiteSpace(ch) && (WCH_NBSP != ch || ++cNBSP >= 2);
                break;
            }

            if (fOutOfBounds)
                break;
            
            if (fFoundRealText)
            {
                if (pmpAcrossLayout)
                    dwSpringLoad = ((iDirection==-1) ? SL_ADJUST_FOR_INSERT_LEFT : SL_ADJUST_FOR_INSERT_RIGHT);

                Assert(pmpAcrossLayout || !dwSpringLoad);
                goto SpringLoad;
            }

            if (pmpAcrossLayout)
            {
                // Remember the position in front of the LEFTMOST element.
                hr = THR(pmpAcrossLayout->MoveToPointer(pmpWalk));
                if (hr)
                    goto Cleanup;
            }
        }

        ClearInterface(&pmpAcrossLayout);
    }

SpringLoad:

    if (dwSpringLoad && fActuallySpringLoad)
    {
        Assert(pmpAcrossLayout);

        // Load springloader with format settings found at pmpAcrossLayout.
        // Given that we are here, we know we have found text, and therefore no AdjustForInsert is necessary.
        hr = THR(SpringLoad(pmpAcrossLayout, 0));
        if (hr)
            goto Cleanup;

        Reposition(pmpPosition);
    }

Cleanup:

    ReleaseInterface(pmpWalk);
    ReleaseInterface(pmpBlockDelimiter);
    ReleaseInterface(pmpAcrossLayout);
    ReleaseInterface(pElemWalk);
    ReleaseInterface(pElemToLeft);
    ReleaseInterface(pElemToRight);
    
    return dwSpringLoad != 0;
}


// Springloader copy of adjust pointer for insert (in case no tracker is around).

HRESULT
CSpringLoader::AdjustPointerForInsert(IMarkupPointer * pWhereIThinkIAm, INT inBlockcDir, INT inTextDir)
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spLeftEdge;
    SP_IMarkupPointer spRightEdge;    
    CHTMLEditor * pEd = _pCommandTarget->GetEditor();
    CSelectionManager * pSelMan = pEd->GetSelectionManager();
    SP_IDisplayPointer spDispPointer;

    IFC( pSelMan->GetEditor()->CreateMarkupPointer( &spLeftEdge ));
    IFC( pSelMan->GetEditor()->CreateMarkupPointer( &spRightEdge ));
    IFC( pSelMan->MovePointersToContext( spLeftEdge, spRightEdge ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispPointer->MoveToMarkupPointer(pWhereIThinkIAm, NULL) )
    
    IFC( pEd->AdjustPointer( spDispPointer, inBlockcDir, inTextDir, spLeftEdge, spRightEdge, ADJPTROPT_AdjustIntoURL));
    IFC( spDispPointer->PositionMarkupPointer(pWhereIThinkIAm) );

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadParagraphFormatting
//
//  Synopsis:   Loads the default font settings made by the host into the spring
//              loader.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoadParagraphFormatting(IMarkupPointer *pPosition)
{
    HRESULT                 hr = S_FALSE;
    CEditPointer            epTest(_pCommandTarget->GetEditor());
    CEditPointer            epTestBR(_pCommandTarget->GetEditor());   
    BOOL                    fFoundBR;
    DWORD                   dwFound;
    SP_IHTMLComputedStyle   spComputedStyle1;
    SP_IHTMLComputedStyle   spComputedStyle2;
    BOOL                    fEqual;

    //
    // Check for the NULL case
    //
    if( !pPosition )
        goto Cleanup;
        
    IFC( epTest->MoveToPointer(pPosition) );

    //
    // Move to end of block
    //

    IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    fFoundBR = epTest.CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock);
    
    if (fFoundBR)
    {
        IFC( epTestBR->MoveToPointer(epTest) );
        IFC( epTestBR.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

        IFC( epTest.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

        if( !epTest.CheckFlag( dwFound, BREAK_CONDITION_Site ) &&
            !epTest.CheckFlag( dwFound, BREAK_CONDITION_Block ))
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        
    }
    
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    

    //
    // Get format cache info for comparison [TODO: current style]
    //

    IFC( GetDisplayServices()->GetComputedStyle(epTest, &spComputedStyle1) );

    //
    // Compare format data with that in inner most phrase element
    //

    if (fFoundBR)
        IFC( epTest->MoveToPointer(epTestBR) );
    
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_ExitPhrase, &dwFound) );
    if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitPhrase)
        && !epTest.CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_EnterPhrase, &dwFound) );
    Assert(dwFound == BREAK_CONDITION_EnterPhrase
           || dwFound == BREAK_CONDITION_NoScopeBlock);

    IFC( GetDisplayServices()->GetComputedStyle(epTest, &spComputedStyle2) );
    IFC( ComputedStylesEqual( spComputedStyle1, spComputedStyle2, &fEqual) );

    if (fEqual)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    //
    // Some formatting exists, so spring load at this position [TODO: use format data above]
    //

    IFC( SpringLoad(epTest) );

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSpringLoader::ComputedStylesEqual(IHTMLComputedStyle *pIStyle1, IHTMLComputedStyle *pIStyle2, BOOL *pfEqual)
{
    HRESULT         hr = S_OK;
    TCHAR           szFont1[LF_FACESIZE + 1];
    TCHAR           szFont2[LF_FACESIZE + 1];
    long            lSize1, lSize2;
    DWORD           dwColor1, dwColor2;
    DWORD           dwBackColor1, dwBackColor2;
    VARIANT_BOOL    bBold1, bBold2;
    VARIANT_BOOL    bUnderline1, bUnderline2;
    VARIANT_BOOL    bItalic1, bItalic2;
    VARIANT_BOOL    bSuperscript1, bSuperscript2;
    VARIANT_BOOL    bSubscript1, bSubscript2;
    
    Assert( pIStyle1 && pIStyle2 && pfEqual );

    *pfEqual = FALSE;

    //
    // Foreground color
    //
    IFC( pIStyle1->get_textColor( &dwColor1) );
    IFC( pIStyle2->get_textColor( &dwColor2) );

    if( dwColor1 != dwColor2 )
        goto Cleanup;

    //
    // Background color
    //
    IFC( pIStyle1->get_backgroundColor( &dwBackColor1) );
    IFC( pIStyle2->get_backgroundColor( &dwBackColor2) );

    if( dwBackColor1 != dwBackColor2 )
        goto Cleanup;

    //
    // Font size
    //
    IFC( pIStyle1->get_fontSize( &lSize1 ) );
    IFC( pIStyle2->get_fontSize( &lSize2 ) );
    
    if( lSize1 != lSize2 )
        goto Cleanup;

    //
    // Bold
    //
    IFC( pIStyle1->get_bold( &bBold1 ) );
    IFC( pIStyle2->get_bold( &bBold2 ) );

    if( bBold1 != bBold2 )
        goto Cleanup;

    //
    // Underline
    //
    IFC( pIStyle1->get_underline( &bUnderline1 ) );
    IFC( pIStyle2->get_underline( &bUnderline2 ) );

    if( bUnderline1 != bUnderline2 )
        goto Cleanup;

    //
    // Italic
    //
    IFC( pIStyle1->get_italic( &bItalic1 ) );
    IFC( pIStyle2->get_italic( &bItalic2 ) );

    if( bItalic1 != bItalic2 )
        goto Cleanup;

    //
    // Superscript
    //
    IFC( pIStyle1->get_superScript( &bSuperscript1 ) );
    IFC( pIStyle2->get_superScript( &bSuperscript2 ) );

    if( bSuperscript1 != bSuperscript2 )
        goto Cleanup;

    //
    // Subscript
    //
    IFC( pIStyle1->get_subScript( &bSubscript1 ) );
    IFC( pIStyle2->get_subScript( &bSubscript2 ) );

    if( bSubscript1 != bSubscript2 )
        goto Cleanup;
        
    //
    // Font name
    //
    IFC( pIStyle1->get_fontName((TCHAR *)&szFont1) );
    IFC( pIStyle2->get_fontName((TCHAR *)&szFont2) );

    if( _tcscmp(szFont1, szFont2) != 0 )
        goto Cleanup;

    *pfEqual = TRUE;
    
Cleanup:
    RRETURN(hr);
}


CHTMLEditor *
CSpringLoader::GetEditor()
{
    return _pCommandTarget->GetEditor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\editres\libmain.cxx ===
#include <windows.h>

#ifdef MARKCODE
#include "..\core\include\markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#endif
 
extern "C"
BOOL WINAPI DllMain( HINSTANCE, DWORD, LPVOID )
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\seltrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

DeclareTag(tagSelectionDumpOnCp, "Selection","DumpTreeOnCpRange")
DeclareTag(tagSelectionTrackerState, "Selection", "Selection show tracker state")
DeclareTag(tagSelectionDisableWordSel, "Selection", "Disable Word Selection Model")
DeclareTag(tagSelectionValidate, "Selection", "Validate Selection Size in edtrack")
DeclareTag(tagShowScroll,"Selection", "Show scroll pointer into  view");
DeclareTag(tagShowSelectionCp,"Selection", "Show Selection Cp");

#if DBG == 1

static const LPCTSTR strStartSelection = _T( "    ** Start_Selection (Highlight)");
static const LPCTSTR strEndSelection = _T( "    ** End_Selection (Highlight)");
static const LPCTSTR strWordPointer = _T( "    ** Word");
static const LPCTSTR strTestPointer = _T( "    ** Test");
static const LPCTSTR strPrevTestPointer = _T( "    ** Last Test");
static const LPCTSTR strImeIP = _T( "    ** IME IP");
static const LPCTSTR strImeUncommittedStart = _T( "    ** IME Uncommitted Start");
static const LPCTSTR strImeUncommittedEnd = _T( "    ** IME Uncommitted End");
static const LPCTSTR strSelServStart = _T( "    ** Start_Selection (SelServ)");
static const LPCTSTR strSelServEnd = _T( "    ** End_Selection (SelServ)");
static const LPCTSTR strShiftPointer = _T( "    ** Shift-Selection Pointer");
static const LPCTSTR strSelectionAnchorPointer = _T( "    ** Selection Anchor Pointer");
static int gDebugTestPointerCp = -100;
static int gDebugEndPointerCp = -100;
static int gDebugTestPointerMinCp = -100;
static int gDebugTestPointerMaxCp = -100;
#endif


extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);

const LONG SEL_TIMER_INTERVAL = 100;

const long scrollSize = 5;

MtDefine( CSelectTracker, Utilities , "CSelectionTracker" )

#include "selstate.hxx"

using namespace EdUtil;

//
//
// Constructors & Initializations
//
//

CSelectTracker::CSelectTracker( CSelectionManager* pManager) :
    CEditTracker( pManager )
{
    //
    // We are no longer zero-memed out on creation. We explicitly set all instance vars.
    //
    _pDispStartPointer = NULL;
    _pDispEndPointer = NULL;
    _pDispTestPointer = NULL;
    _pDispWordPointer = NULL;
    _pDispPrevTestPointer = NULL;
    _pDispShiftPointer = NULL;
    _pDispSelectionAnchorPointer = NULL;
    _pISegment = NULL;
    _pIRenderSegment = NULL;
    _pSelServStart = NULL;
    _pSelServEnd = NULL;
    _pITimerWindow = NULL;
    _fInSelTimer = FALSE;
    _pITimerWindow = NULL;
    _fInSelTimer = FALSE;
    _pISelectStartElement = NULL;
    _pIScrollingAnchorElement = NULL;
    _pIDragElement = NULL;
    _pSelectionTimer = NULL;
    _pPropChangeListener = NULL;
    _fFiredNotify = FALSE;
    _lTimerID = 0;

    Init();

}

HRESULT
CSelectTracker::InitPointers()
{
    HRESULT hr = S_OK;

    Assert( !_pDispStartPointer );
    Assert( !_pDispEndPointer );
    Assert( !_pDispTestPointer );
    Assert( !_pDispWordPointer );
    Assert( !_pDispPrevTestPointer );
    Assert( !_pDispShiftPointer );
    Assert( !_pDispSelectionAnchorPointer );

    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispStartPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispEndPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispTestPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispPrevTestPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispWordPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispShiftPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispSelectionAnchorPointer ));

    IFC( GetEditor()->CreateMarkupPointer( &_pSelServStart) );
    IFC( GetEditor()->CreateMarkupPointer( &_pSelServEnd) );

    _pSelectionTimer = new CSelectionTimer(this);
    if( !_pSelectionTimer )
        goto Error;

    _pPropChangeListener = new CPropertyChangeListener(this);
    if( !_pPropChangeListener )
        goto Error;

#if DBG == 1
    _pManager->SetDebugName( _pDispStartPointer, strStartSelection ) ;
    _pManager->SetDebugName( _pDispEndPointer, strEndSelection );
    _pManager->SetDebugName( _pDispWordPointer, strWordPointer );
    _pManager->SetDebugName( _pDispTestPointer, strTestPointer);
    _pManager->SetDebugName( _pDispPrevTestPointer, strPrevTestPointer );
    _pManager->SetDebugName( _pDispSelectionAnchorPointer, strSelectionAnchorPointer );
    _pManager->SetDebugName( _pSelServStart, strSelServStart) ;
    _pManager->SetDebugName( _pSelServEnd, strSelServEnd );
    _pManager->SetDebugName( _pDispShiftPointer, strShiftPointer );

#endif

Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

VOID
CSelectTracker::Init()
{
    _anchorMouseX = CARET_XPOS_UNDEFINED ;
    _anchorMouseY = CARET_YPOS_UNDEFINED ;
    _ptCurMouseXY.x = CARET_XPOS_UNDEFINED;
    _ptCurMouseXY.y = CARET_YPOS_UNDEFINED;
#ifdef UNIX
    _firstMessage = NULL;
#endif
    _fShift = FALSE;
    _fDragDrop = FALSE;
    _fDoubleClickWord = FALSE;
    _fState = ST_DORMANT;

    _eType = TRACKER_TYPE_Selection;
    _fEndConstrained = FALSE;
    _fMadeSelection = FALSE;
    _fAddedSegment = FALSE;
    _fInWordSel = FALSE;
    _fWordPointerSet = FALSE;
    _fWordSelDirection = FALSE;
    _fStartAdjusted = FALSE;
    _fExitedWordSelectionOnce = FALSE;

    _fStartIsAtomic = FALSE;
    _fStartAdjustedForAtomic = FALSE;
    _fEditContextUpdatedForAtomic = FALSE;
    _fTookCapture = FALSE;
    _fFiredNotify = FALSE;
    _ptVirtualCaret.InitPosition();
    _lastCaretMove = CARET_MOVE_NONE;
    _fMouseClickedInAtomicSelection = FALSE;
    WHEN_DBG( _ctStartAdjusted = 0 );
    WHEN_DBG( _ctScrollMessageIntoView = 0 );
}

HRESULT
CSelectTracker::Init2(
        CEditEvent*             pEvent ,
        DWORD                   dwTCFlags,
        IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;

    Assert( _fState == ST_DORMANT );

    hr = InitPointers();
    if ( hr )
        goto Cleanup;
#ifdef UNIX
    _firstMessage = *pMessage;
#endif

    _fState = _pManager->IsMessageInSelection(pEvent) ? ST_WAIT1 : ST_WAIT2; // marka - we should look to see if we're alredy in a selection here.
    _fDragDrop = ( _fState == ST_WAIT1);

    if( _fDragDrop )
    {
        //
        // Make sure we can retrieve the drag element.  If we were unable to retrieve the drag
        // element, we should just do a normal selection.
        //
        hr = THR( RetrieveDragElement( pEvent ) );
        if( FAILED( hr ) )
        {
            _fState = ST_WAIT2;
            _fDragDrop = NULL;
        }
    }
    
    _fShift = FALSE;

    if (!_fDragDrop)
    {
        IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );
    }

    hr = BeginSelection( pEvent );

Cleanup:
    return hr;
}


HRESULT
CSelectTracker::Init2(
        IDisplayPointer*         pDispStart,
        IDisplayPointer*         pDispEnd,
        DWORD                   dwTCFlags,
        CARET_MOVE_UNIT inLastCaretMove )
{
    HRESULT hr                  = S_OK;
    BOOL    fStartFromShiftKey  = ENSURE_BOOL( dwTCFlags & TRACKER_CREATE_STARTFROMSHIFTKEY );
    BOOL    fMouseShift         = ENSURE_BOOL( dwTCFlags & TRACKER_CREATE_STARTFROMSHIFTMOUSE );
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    BOOL    fDidSelection = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

    Assert( _fState == ST_DORMANT );

    hr = InitPointers();
    if ( hr )
        goto Cleanup;

    _fState = ST_WAIT2;
    _fDragDrop = FALSE;
    _fShift = fStartFromShiftKey ;
    SetLastCaretMove( inLastCaretMove );

    IFC( pDispStart->PositionMarkupPointer(spStart) );
    IFC( pDispEnd->PositionMarkupPointer(spEnd) );
    ResetSpringLoader(_pManager, spStart, spEnd);

    // Set the selection type
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );

    //
    // Shift selection.  If we positioned the selection tracker based off of a shift select, then we
    //
    if( fStartFromShiftKey )
    {
        IFC( UpdateShiftPointer( pDispEnd ) );
    }

    IFC( Position( pDispStart, pDispEnd, &fDidSelection, inLastCaretMove) );
    if (fDidSelection)
        goto Cleanup;

    if ( fStartFromShiftKey && fMouseShift )
    {
        //  If we started a selection with the shift key down, we want to go straight into word
        //  selection mode.
        int iWherePointer;

        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( pDispStart, pDispEnd, & iWherePointer));
        IFC( _pDispTestPointer->MoveToPointer( pDispEnd ));
        IFC( _pDispSelectionAnchorPointer->MoveToPointer( pDispStart ) );

        IFC( DoWordSelection(NULL, &fDidSelection, ( iWherePointer == RIGHT )) );
        if (fDidSelection)
        {
            IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
            IFC( UpdateShiftPointer( _pDispEndPointer ));
            IFC( UpdateSelectionSegments() );

            //  Set our current state.
            SetState( ST_WAIT2, TRUE );

            //  Reset our timers.
            StartTimer();
            StartSelTimer();

            goto Cleanup;
        }
    }

    if (GetTrackerType() == TRACKER_TYPE_Caret)
    {
        _pManager->GetActiveTracker()->GetLocation(&_ptCurMouseXY, TRUE);
    }

    // Our selection is passive if it's been set by TreePointers
    BecomePassive( TRUE );

Cleanup:
    return hr;
}

HRESULT
CSelectTracker::Init2(
        ISegmentList*           pSegmentList,
        DWORD                   dwTCFlags ,
        CARET_MOVE_UNIT inLastCaretMove   )
{
    HRESULT hr = S_OK;
    SELECTION_TYPE eType;
    ED_PTR ( edStart );
    ED_PTR ( edEnd );
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    SP_IDisplayPointer spDispStart, spDispEnd;

    IFC( pSegmentList->GetType( & eType ));
    Assert( eType == SELECTION_TYPE_Text );

    IFC( pSegmentList->CreateIterator( & spIter ));

    Assert( spIter->IsDone() != S_OK );

    IFC( spIter->Current( & spSegment ));
    IFC( spSegment->GetPointers( edStart, edEnd ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->MoveToMarkupPointer(edStart, NULL) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->MoveToMarkupPointer(edEnd, NULL) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    hr = THR( Init2(
                     spDispStart,
                     spDispEnd,
                     dwTCFlags,
                     inLastCaretMove ));
    IFC( spIter->Advance() );

    AssertSz( spIter->IsDone() == S_OK , "Multiple-text selection not implemented yet" );

Cleanup:
    RRETURN( hr );
}

CSelectTracker::~CSelectTracker()
{
    BecomeDormant( NULL, TRACKER_TYPE_None, FALSE );

    Assert( !_pITimerWindow );
}

//
//
// Virtuals for all trackers
//
//


//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::BecomeDormant(  CEditEvent      *pEvent,
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI     /* = TRUE */)

{
    HRESULT hr = S_OK;

    TraceTag( ( tagSelectionTrackerState, "CSelectTimer::BecomeDormant"));

    if ( _pManager->IsInTimer() )
        StopTimer();
    if (  _pManager->IsInCapture()  )
        ReleaseCapture();

    Assert(! _pManager->IsInCapture() );

    if ( _fInSelTimer )
        StopSelTimer();

    if ( fTearDownUI &&  pEvent )
    {
        SP_IHTMLElement spElement;
        IFC( pEvent->GetElement( & spElement));

        //
        // Only clear the selection if we are starting a selection somewhere else,
        // or if we clicked on selection but the tracker which is becoming active
        // is not the select tracker (IE: if the select tracker is becoming active,
        // we are going to be doing a drag and drop, and definitely don't want to
        // destroy selection)
        //
        if( !_pManager->IsMessageInSelection( pEvent ) ||
            typeNewTracker != TRACKER_TYPE_Selection )
        {
            IGNORE_HR( ClearSelection() );
        }
    }
    else
        IGNORE_HR( ClearSelection());

    Destroy();

    SetState( ST_DORMANT, TRUE );

Cleanup:

    RRETURN( hr );
}


BOOL
CSelectTracker::IsActive()
{
    return(  ! IsPassive() && ! IsDormant() );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::Awaken()
{
    Assert( IsDormant());
    Assert(! _pManager->IsInCapture() );

    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::Destroy()
{
    ClearInterface( & _pDispStartPointer );
    ClearInterface( & _pDispEndPointer );
    ClearInterface( & _pDispTestPointer );
    ClearInterface( & _pDispWordPointer );
    ClearInterface( & _pDispShiftPointer );
    ClearInterface( & _pDispPrevTestPointer );
    ClearInterface( & _pDispSelectionAnchorPointer );
    ClearInterface( & _pSelServStart);
    ClearInterface( & _pSelServEnd);

    if ( _pIDragElement )
    {
        ClearInterface( & _pIDragElement );
    }
    
    if ( _pISelectStartElement )
    {
        DetachPropertyChangeHandler();
        ClearInterface( & _pISelectStartElement );
    }

    if ( _pIScrollingAnchorElement )
    {
        ClearInterface( & _pIScrollingAnchorElement );
    }

    if ( _fInSelTimer )
    {
        StopSelTimer();
        Assert( ! _fInSelTimer );
    }

    if (_pSelectionTimer)
    {
        _pSelectionTimer->SetSelectTracker(NULL);
        ClearInterface( & _pSelectionTimer );
    }

    if (_pPropChangeListener)
    {
        _pPropChangeListener->SetSelectTracker(NULL);
        ClearInterface( & _pPropChangeListener );
    }
}


BOOL
CSelectTracker::IsPointerInSelection(   IDisplayPointer *pDispPointer,
                                        POINT           *pptGlobal,
                                        IHTMLElement    *pIElementOver )
{
    HRESULT             hr = S_OK;
    BOOL                fWithin = FALSE;
    BOOL                fEqual;
    int                 iWherePointer = SAME;
    IMarkupContainer    *pIContainer1 = NULL;
    IMarkupContainer    *pIContainer2 = NULL;
    SP_IMarkupPointer   spPointerStartSel;
    SP_IMarkupPointer   spSelectionPtr;
    SP_IMarkupPointer   spPointerEndSel;
    SP_IMarkupPointer   spPointer;
    
    if ( _fState == ST_WAIT2 || _fState == ST_WAITBTNDOWN2  )
    {
        //
        // just say no when selection hasn't really started.
        //
        goto Cleanup;
    }

    if ( _pISegment )
    {
        //
        // Create the pointers we need, and position them around selection
        // 
        IFC( GetEditor()->CreateMarkupPointer( &spPointerStartSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerEndSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));

        IFC( _pISegment->GetPointers(spPointerStartSel, spPointerEndSel ) );
        IFC( spPointerStartSel->IsEqualTo( spPointerEndSel, &fEqual ));

        //
        // Make sure that we are not in a 0 sized selection
        //
        if ( ! fEqual )
        {
            //
            // If the pointers aren't in equivalent containers, adjust them so they are.
            //
            IFC( pDispPointer->PositionMarkupPointer(spPointer) );
            IFC( spPointer->GetContainer( &pIContainer1 ));

            IFC( spPointerStartSel->GetContainer( & pIContainer2 ));

            if (! EqualContainers( pIContainer1 , pIContainer2 ))
            {
                IFC( GetEditor()->MovePointersToEqualContainers( spPointer, spPointerStartSel ));
            }

            IFC( _pISegment->GetPointers( spPointerStartSel, spPointerEndSel ) );
            IFC( OldCompare( spPointerStartSel, spPointer, &iWherePointer ));

            if ( iWherePointer != LEFT )
            {
                IFC( OldCompare( spPointerEndSel, spPointer, &iWherePointer));
                
                fWithin = ( iWherePointer != RIGHT ) ;
            }
        }
    }

Cleanup:
    ReleaseInterface( pIContainer1 );
    ReleaseInterface( pIContainer2 );

    return ( fWithin );
}

//+====================================================================================
//
// Method: ShouldBeginSelection
//
// Synopsis: We don't want to start selection in Anchors, Images etc.
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::ShouldStartTracker(
                            CEditEvent* pEvent,
                            ELEMENT_TAG_ID eTag,
                            IHTMLElement* pIElement,
                            SST_RESULT * peResult )
{
    HRESULT             hr = S_OK;
    SST_RESULT          eResult = SST_NO_CHANGE;
    VARIANT_BOOL        fScoped;
    IHTMLInputElement   *pInputElement = NULL;
    IDocHostUIHandler   *pHostUIHandler = NULL;
    SP_IServiceProvider spSP;
    SP_IHTMLElement2    spElement2;
    BSTR                bstrType = NULL;
    SP_IDisplayPointer  spEventPtr;                 // Display pointer where event was positioned

    Assert( peResult );

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Create a display pointer, and move it to the event.  This allows
    // us to do hit testing
    //
    IFC( GetDisplayServices()->CreateDisplayPointer( &spEventPtr ) );
    IFC( pEvent->MoveDisplayPointerToEvent ( spEventPtr, NULL ));

#if DBG == 1
    //  We may be called on an EVT_LMOUSEDOWN when clicking on an atomic element.
    //  So we want to assert _fState != ST_WAIT3RDBTNDOWN only if the element
    //  we clicked on was not atomic.
    if( _fState == ST_WAIT3RDBTNDOWN)
    {
        SP_IHTMLElement spElement;
        
        IFC ( pEvent->GetElement( &spElement ));
        if (_pManager->CheckAtomic(spElement) != S_OK)
        {
            AssertSz(FALSE, "_fState != ST_WAIT3RDBTNDOWN");
        }
    }
#endif

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_canHaveChildren(&fScoped));

    if ( ! IsDormant() && IsShiftKeyDown() )
    {
        goto Cleanup;
    }

    if ( IsShiftKeyDown() && _pManager->GetSelectionType() == SELECTION_TYPE_Caret )
    {
        goto Cleanup;
    }

    if ( pEvent->GetType() == EVT_RMOUSEDOWN )
    {
        if( IsPassive() || IsActive() )
            eResult = SST_NO_BUBBLE;
        else
            eResult = SST_NO_CHANGE;

        goto Cleanup;
    }

    //
    // Always allow the selection manager to start
    // if the event is within an existing selection (drag -n- drop)
    //
    if ( _pManager->IsMessageInSelection( pEvent ) )
    {
        Assert( ! IsDormant());
        eResult = SST_CHANGE;
    }
    //
    // Make sure selection is allowed here.  We don't want to allow selection
    // in no-scope elements, unless they are an input or an IFRAME.
    //
    else if ( GetEditor()->AllowSelection( pIElement, pEvent ) != S_OK )
    {
        goto Cleanup;
    }
    else if ( !fScoped && (eTag != TAGID_INPUT) && (eTag != TAGID_IFRAME) && !(pEvent->GetHitTestResult() & HT_RESULTS_Glyph) )
    {
        goto CheckAtomic;
    }
    else
    {
        switch ( eTag )
        {
            case TAGID_BUTTON:
            {
                eResult  = _pManager->IsContextEditable() ? SST_CHANGE : SST_NO_CHANGE;
            }
            break;

            case TAGID_INPUT:
            {
                if ( ( eTag == TAGID_INPUT )
                    && S_OK == THR( pIElement->QueryInterface ( IID_IHTMLInputElement, ( void** ) & pInputElement ))
                    && S_OK == THR(pInputElement->get_type(&bstrType)))
                {
                    if (   !StrCmpIC( bstrType, TEXT("image") )
                        || !StrCmpIC( bstrType, TEXT("radio") )
                        || !StrCmpIC( bstrType, TEXT("checkbox") ))
                    {
                        goto CheckAtomic;
                    }
                    else if ( !StrCmpIC( bstrType, TEXT("button")) &&
                              !_pManager->IsContextEditable() )
                    {
                        //
                        // disallow selecting in a button if it's not editable.
                        //
                        goto CheckAtomic;
                    }
                    else
                    {
                        eResult = SST_CHANGE;
                    }

                }
                break;
            }

            default:
                eResult = SST_CHANGE;
                break;
        }
    }

    //
    // This code is no longer required. We used to require this for clicking on the magic div
    // in a text selection.
    //
    // In IE5.0 - a click on a site selected element in a text selection - would constitute a drag.
    // if you moused up - you could then get a caret in the magic div
    //
    // In IE 5.5 - we now site select the element in this case
    // so this is no longer required
    //

#if 0
    //
    // verify it's really ok to start a selection by firing on edit focus.
    //

    if ( eResult == SST_CHANGE )
    {
        //
        // This case is for you have a text selection through the "magic div",
        // and you click on the magic div. We don't fire the event on the edit context
        // but on the element you clicked on
        //
        if ( ! _pManager->IsDontFireEditFocus() )
        {
            if ( IsPassive() &&
                 (CControlTracker::IsThisElementSiteSelectable( _pManager, eTag, pIElement) ) )
            {
                eResult = FireOnBeforeEditFocus( pIElement, _pManager->IsParentEditable() ) ? SST_CHANGE : SST_NO_CHANGE;
            }
            else
            {
                eResult = _pManager->FireOnBeforeEditFocus() ? SST_CHANGE : SST_NO_CHANGE ;
            }
        }
    }
    Assert( ! _pManager->IsIMEComposition());
#endif

CheckAtomic:
    
    //  Bug 104792: Change if the user clicked on a control in an atomic element.
    if (eResult == SST_NO_CHANGE && _pManager->CheckAtomic(pIElement) == S_OK)
    {
        eResult = SST_CHANGE;
    }

Cleanup:

    if( hr == CTL_E_INVALIDLINE )
    {
        //
        // Tried to start selection where a display pointer could not be positioned.
        // Don't change the tracker
        //
        hr = S_OK;
        eResult = SST_NO_CHANGE;
    }

    *peResult = eResult ;

    SysFreeString(bstrType);

    ReleaseInterface( pHostUIHandler );
    ReleaseInterface( pInputElement );

    RRETURN( hr );
}


BOOL
CSelectTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    return ( _fState == ST_WAIT3RDBTNDOWN );
}

BOOL
CSelectTracker::IsWaitingForMouseUp()
{
    return ( _fState == ST_WAIT2 ||
             _fState == ST_WAITCLICK ||
             _fState == ST_WAITBTNDOWN2 ||
             _fState == ST_MAYSELECT2 ||
             _fState == ST_WAIT3RDBTNDOWN );

}

HRESULT
CSelectTracker::GetLocationForDisplayPointer(
                    IDisplayPointer *pDispPointer,
                    POINT           *pPoint,
                    BOOL            fTranslate
                    )
{
    HRESULT             hr;
    SP_ILineInfo        spLineInfo;
    SP_IMarkupPointer   spPointer;
    IHTMLElement        *pIFlowElement = NULL;

    Assert( pPoint );

    IFR( pDispPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if( fTranslate )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( pDispPointer->GetFlowElement(&pIFlowElement) );

        if (!pIFlowElement)
        {
            IFC(_pManager->GetEditableElement(&pIFlowElement));
        }

        IFC( GetDisplayServices()->TransformPoint(pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, pIFlowElement) );
    }

Cleanup:
    ReleaseInterface(pIFlowElement);
    return S_OK;
}

//
// Always takes _pDispEndPointer!!!
//
//
HRESULT
CSelectTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    return GetLocationForDisplayPointer( _pDispEndPointer, pPoint, fTranslate);
}


//+====================================================================================
//
// Method: CalculateBOL
//
// Synopsis: Get our BOL'ness.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::CalculateBOL()
{
    IGNORE_HR( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
}

HRESULT
CSelectTracker::Position(
                    IDisplayPointer* pDispStart,
                    IDisplayPointer* pDispEnd)
{
    HRESULT hr = S_OK;

    IFC( Position(pDispStart, pDispEnd, NULL, CARET_MOVE_NONE) );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::Position(   IDisplayPointer *pDispStart,
                            IDisplayPointer *pDispEnd,
                            BOOL            *pfDidSelection,
                            CARET_MOVE_UNIT inCaretMove)
{
    HRESULT             hr = S_OK;
    POINTER_GRAVITY     eGravity;
    BOOL                fAdjust = FALSE;
    BOOL                fEndIsAtomic = FALSE;
    SP_ILineInfo        spLineInfo;
    SP_IHTMLElement     spFlowElement;
    SP_IHTMLElement     spAtomicElement;
    SP_IMarkupPointer   spEndPointer;
    BOOL                fBlockEmpty;
    BOOL                fBetweenBlocks;
    CBlockPointer       ptrBlock( GetEditor() );
    POINT               ptLoc;
    BOOL                fStartIsAtomic = FALSE;

#if DBG==1
    BOOL fPositioned = FALSE;
    hr = _pDispStartPointer->IsPositioned(& fPositioned );
    Assert( ! fPositioned);
#endif
    //
    // We assume that you can only set a position on a New Tracker.
    //
    Assert( ! _fAddedSegment );

    IFC( MoveStartToPointer( pDispStart ));
    IFC( MoveEndToPointer( pDispEnd ));

    //
    // copy gravity - important for commands
    //
    IFC(  pDispStart->GetPointerGravity( &eGravity ) );            // need to maintain gravity
    IFC( _pDispStartPointer->SetPointerGravity( eGravity ) );
    IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

    IFC( pDispEnd->GetPointerGravity( &eGravity ));            // need to maintain gravity
    IFC( _pDispEndPointer->SetPointerGravity( eGravity ));
    IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );
    IFC( GetLocation(&_ptCurMouseXY, FALSE) );

    IFC( GetCurrentScope(_pDispStartPointer, &spAtomicElement) );
    fStartIsAtomic = ( _pManager->CheckAtomic( spAtomicElement ) == S_OK );

    IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
    fEndIsAtomic = ( _pManager->CheckAtomic( spAtomicElement) == S_OK );

    if (fStartIsAtomic && !(!fEndIsAtomic && inCaretMove == CARET_MOVE_FORWARD))
    {
        _fStartIsAtomic = TRUE;

        IFC( AdjustForAtomic( _pDispStartPointer, spAtomicElement, TRUE, NULL, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }

    if (fEndIsAtomic && !(!fStartIsAtomic && inCaretMove == CARET_MOVE_BACKWARD))
    {
        fEndIsAtomic = TRUE;

        IFC( AdjustForAtomic( _pDispEndPointer, spAtomicElement, FALSE, NULL, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }

    if (fStartIsAtomic || fEndIsAtomic)
    {
        //
        // We need to fix up display gravity properly since atomic selection
        // was initiated programmatically. We do not have gravity information
        // properly setup as such. 
        //
        // IEV6-7270-2000/08/07-zhenbinx
        //
        int iWherePointer = 0;
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare(_pDispStartPointer, _pDispEndPointer, &iWherePointer) );
        if (iWherePointer == RIGHT)  // start < end
        {
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
        else
        {
            IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
    }
    

    IFC( _pDispStartPointer->GetFlowElement( & spFlowElement )) ;
    IFC( AttachPropertyChangeHandler( spFlowElement ));

    if ( _fShift )
    {
        // Before we call AdjustSelection, we should try and do major adjustments here.
        //
        // A major adjustment includes selecting additional words or characters during
        // a single selection move.
        //
        // For example, If we were between blocks and we tried to move forward, then
        // we need to call MovePointer() again to select the first character in the next block.
        //
        // Likewise, if we were moving forwards or backwards by one character or
        // on word, and we ended up on a table boundary with content in that
        // boundary, we need to select the content.  This fixes VID issues like
        // bug 71907.
        //
        fBetweenBlocks = IsBetweenBlocks( _pDispShiftPointer );

        IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
        IFC( _pDispShiftPointer->PositionMarkupPointer(spEndPointer) );

        if( inCaretMove == CARET_MOVE_FORWARD     || inCaretMove == CARET_MOVE_BACKWARD ||
            inCaretMove == CARET_MOVE_WORDFORWARD || inCaretMove == CARET_MOVE_WORDBACKWARD )
        {
            IFC( ptrBlock.MoveTo( spEndPointer, GetPointerDirection(inCaretMove) ) );
            IFC( ptrBlock.IsEmpty( &fBlockEmpty ) );

            if( fBetweenBlocks ||
                ( IsAtEdgeOfTable( Reverse(GetPointerDirection(inCaretMove)), spEndPointer) &&
                  !fBlockEmpty ) )
            {
                IFC( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc));
            }
        }

        //  If the end is atomic, we do not want to move it to the shift pointer since we
        //  already positioned it earlier.
        if (!fEndIsAtomic)
        {
            IFC( _pDispEndPointer->MoveToPointer( _pDispShiftPointer ) );
        }

        IFC( AdjustSelection( & fAdjust ));
    }
    IFC( ConstrainSelection(TRUE, NULL, _fStartIsAtomic, fEndIsAtomic) );

    IFC( CreateSelectionSegments() );
    IFC( FireOnSelect());

    SetMadeSelection( TRUE );

#if DBG == 1
    {
        SP_ISegmentList spSegmentList;
        BOOL            fEmpty = FALSE;
        HRESULT         hrDbg;

        hrDbg = GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList );
        if( !hrDbg ) spSegmentList->IsEmpty(&fEmpty);

        Assert( !fEmpty );
    }
#endif

Cleanup:

    RRETURN ( hr );

}


//
//
// Message Handling
//
//

//+---------------------------------------------------------------------------
//
//  Member:     CSelectTracker::GetAction
//
//  Synopsis:   Get the action to be taken, given the state we are in.
//
//----------------------------------------------------------------------------
ACTIONS
CSelectTracker::GetAction(CEditEvent* pEvent)
{
    unsigned int LastEntry = sizeof (ActionTable) / sizeof (ActionTable[0]);
    unsigned int i;
    ACTIONS Action = A_ERR;

    Assert (_fState <= ST_WAITCLICK );

    // Discard any spurious mouse move messages
    if ( pEvent->GetType() == EVT_MOUSEMOVE  )
    {
        POINT pt;
        IGNORE_HR( pEvent->GetPoint( & pt ));

        if (!IsValidMove ( & pt ))
        {
            Action = A_DIS;
        }

    }

    if ( Action != A_DIS )
    {
        // Lookup the state-message tabl to find the appropriate action
        // ActionTable[LastEntry - 1]._iJMessage = pMessage->message;
        for (i = 0; i < LastEntry; i++)
        {
            if ( (ActionTable[i]._iJMessage == pEvent->GetType()) || ( i == LastEntry ) )
            {
                Action = ActionTable[i]._aAction[_fState];
                break;
            }
        }
    }
    return (Action);
}

HRESULT
CSelectTracker::HandleEvent(
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;

    switch( pEvent->GetType() )
    {
        case EVT_RMOUSEUP:
        {
            // Destroy the selection tracker if the user right clicks on another valid
            // selection location.
            if ( ! _pManager->IsMessageInSelection(  pEvent )  &&
                   ( GetEditor()->AllowSelection( GetEditableElement(), pEvent ) == S_OK ) )
            {
                    IGNORE_HR( pEvent->MoveDisplayPointerToEvent(
                                            _pDispStartPointer,
                                            GetEditableElement() ));


                    IFC( _pManager->PositionCaret( _pDispStartPointer ));
            }
        }
        break;

        case EVT_LMOUSEUP:
        case EVT_LMOUSEDOWN:
        case EVT_TIMER:
        case EVT_DBLCLICK:
        case EVT_MOUSEMOVE:
        case EVT_CLICK:
        case EVT_INTDBLCLK:

            if ( IsPassive() )
            {
#if DBG == 1
                BOOL fWentDormant = FALSE;
#endif

                if ( ( pEvent->GetType() == EVT_LMOUSEDOWN) && ( pEvent->IsShiftKeyDown() ) )
                {
                        BOOL fDidSelection = FALSE;
                        BOOL fEqual;

                        IFC(DoSelection( pEvent, FALSE, &fDidSelection ));
                        if (fDidSelection)
                            goto Cleanup;

                        //
                        // If we are equal, create a caret tracker, selection has disappeared
                        //
                        IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, & fEqual ));
                        if ( fEqual )
                        {
#if DBG == 1
                            fWentDormant = TRUE;
#endif
                            BecomePassive( TRUE );
                        }
                }
#ifndef _PREFIX_
                Assert( (_fState == ST_PASSIVE) || fWentDormant ); // make sure we're still passive
#endif

                //
                // If we get here - we're passive. Make sure we're not in capture
                //
                if (  _pManager->IsInCapture()  )
                    ReleaseCapture();

                if ( _pManager->IsInTimer() )
                    StopTimer();

                if ( _fInSelTimer )
                {
                    StopSelTimer();
                    Assert( ! _fInSelTimer );
                }
            }
            else
            {
                hr = HandleMessagePrivate( pEvent  );
            }
            break;

        case EVT_KEYPRESS:
            hr = THR( HandleChar( pEvent));
            break;


        case EVT_KEYDOWN:
            if ( IsPassive() )
                hr = THR( HandleKeyDown( pEvent  ));
            else
                hr = THR( HandleMessagePrivate( pEvent ));
            break;

        case EVT_KEYUP:
            if ( IsPassive() )
                hr = THR ( HandleKeyUp ( pEvent ));
            break;

        case EVT_KILLFOCUS:
        case EVT_LOSECAPTURE:
            //
            // A focus change/loss of capture has occured.
            // If we have capture - this is a bad thing.
            // a sample of this is throwing up a dialog from a script.
            //

            IFC( OnLoseCapture());
            break;

#ifndef NO_IME
        case EVT_IME_STARTCOMPOSITION:
            hr = THR( HandleImeStartComposition( pEvent ));
            break;
#endif // !NO_IME

    }
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectTracker::EnableModeless( BOOL fEnable )
{
    HRESULT hr = S_OK;

    if ( ! fEnable ) // dialog is coming up. we better shut ourselves down.
    {
        hr = THR( OnLoseCapture()) ;
    }

    RRETURN( hr );
}

HRESULT
CSelectTracker::OnLoseCapture()
{
    if ( ! IsPassive() )
    {
        if ( _pManager->IsInFireOnSelectStart() )
        {
            //
            // If we are in a FireOnSelectStart - gracefully bail.
            //
            _pManager->SetFailFireOnSelectStart( TRUE );
        }
        else
        {
            BecomePassive(TRUE);
        }
    }
    return S_OK;
}

HRESULT
CSelectTracker::HandleMessagePrivate(
                CEditEvent* pEvent)
{
    HRESULT hr = S_OK;
    BOOL fHandledDrag = FALSE;
    BOOL fSelect;
    ACTIONS Action = A_UNK;

    // If we have not already decided what to do with the message ...
    Action = GetAction (pEvent) ;

    switch (Action)
    {
    case A_ERR: // Spurious error, bail out please
        AssertSz(0,"Unexpected event for State");
        if ( _pManager->IsInCapture() )
            ReleaseCapture();
        IFC( _pManager->PositionCaret( _pDispStartPointer ));
        break;

    case A_DIS: // Discard the message
        break;

    case A_IGN: // Do nothing, just ignore the message, let somebody else process it
        hr = S_FALSE;

        //
        // the code below is to eat keystrokes while dragging and make sure they dont'
        // get translated into commands - eg. IDM_DELETE.
        //
        if ( ( pEvent->GetType() == EVT_KEYDOWN ) && ! IsPassive() )
        {
            hr = S_OK; // eat all keystrokes while dragging.
        }
        break;

    case A_5_16: // ST_WAIT2 & EVT_LBUTTONUP
        SetState( ST_WAITCLICK );
        break;

    case A_16_7: // ST_WAITCLICK & EVT_CLICK
        SetState( ST_WAITBTNDOWN2 );
        break;

    case A_5_6: // ST_WAIT2 & EVT_MOUSEMOVE
        // if the bubblable onselectstart event is cancelled, don't
        // go into DuringSelection State, and cnx the tracker

        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );

        if( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();
            StopTimer();
            IFC(_pManager->PositionCaret(_pDispStartPointer));
        }
        else
        {
            HWND hwnd = NULL;
            SP_IOleWindow spOleWindow;

            StopTimer();

            _pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow);
            if (spOleWindow)
                spOleWindow->GetWindow(&hwnd);

            if (hwnd)
            {
                UINT uDragDelay = GetProfileIntA("windows", "DragDelay", DD_DEFDRAGDELAY);
                KillTimer(hwnd, 1);
                if (uDragDelay)
                    SetTimer(hwnd, 1, uDragDelay, 0);
            }

            //  Bug 110575: During very quick selections we may get a mouse down and mouse up
            //  before setting the state to ST_WAIT2.  This causes us to be in this selection
            //  mode while the mouse button is already up.  We'll check to make sure that the
            //  mouse button is down before we initiate a selection.
            if (!pEvent->IsLeftButton())
            {
                if (  _pManager->IsInCapture()  )
                    ReleaseCapture();
                BecomePassive( TRUE );
                break;
            }

            HRESULT hrCapture;

            if ( ! _fTookCapture )
            {
                hrCapture = THR( TakeCapture());
                _fTookCapture = TRUE;
            }
            else
                hrCapture = S_OK;

            if (SUCCEEDED( hrCapture ))
            {
                BOOL fDidSelection = FALSE;
                IFC( DoSelection( pEvent, FALSE, &fDidSelection ));
                if (fDidSelection)
                    goto Cleanup;

                SetState( ST_DOSELECTION ) ;
            }

        }
        break;

    case A_1_4: // ST_WAIT1 & EVT_LBUTTONUP
        {
            ClearSelection();
            SetState( ST_WAITBTNDOWN1 ) ;

            //
            // Scenario.  User left mouse downs on something that is already
            // selected, and then immediately releases the left mouse button.
            // A click has occured on selected text.  We can't swallow the
            // LBUTTON_UP event because the on-click needs to occur for
            // elements (so that navigation can occur if the user clicked on a
            // hyperlink, for instance)
            //
            hr = S_FALSE;
        }
        break;

    case A_1_2: // ST_WAIT1 & EVT_MOUSEMOVE
        {
            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_FALSE;
            SetState( ST_DRAGOP );
        }
        break;

    case A_2_14: // ST_DRAGOP & EVT_LBUTTONUP
        // hr = SetCaret( pMessage );
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        IFC( _pManager->PositionCaret( _pDispStartPointer ));
        break;

    case A_3_14 :  // ST_MAYDRAG & (EVT_LBUTTONUP || EVT_RBUTTONUP)
    case A_4_14m : // ST_WAITBTNDOWN1 & EVT_MOUSEMOVE (was b05)
        // In this case, the cp is *never* updated to the
        // new position. So go and update it. Remember SetCaret
        // also kills any existing selections.
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        //  If the user clicked in an atomic element that was part of
        //  a text selection, we don't want to clear the selection.
        //  In this case the selection would have been constrained to
        //  the atomic element and we want to keep it that way on mouse up.
        if ( _fMouseClickedInAtomicSelection)
        {
            BecomePassive();
        }
        else
        {
            ClearSelection();

            IFC( _pManager->PositionCaret( _pDispStartPointer ));
        }
        break;

    case A_3_2: // ST_MAYDRAG & EVT_TIMER

        if ( _pManager->IsInTimer() )
            StopTimer();
        // Convert to a move message with correct coordinates
        POINT pt;
        GetMousePoint(&pt);
        if ( IsValidMove( & pt ) )
        {
            hr = S_FALSE;
            SetState( ST_DRAGOP );
            fHandledDrag = TRUE;
            DoTimerDrag();
        }

        break;

    case A_3_2m: // ST_MAYDRAG & EVT_MOUSEMOVE
        {
            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_FALSE;
            SetState( ST_DRAGOP );
        }
        break;

    case A_4_8 :// ST_WAITBTNDOWN1 & EVT_INTDBLCLK
    case A_7_8 :// ST_WAITBTNDOWN2 & EVT_LBUTTONUP (was b60)
    case A_16_8:
        if ( _fDragDrop )
            _fDragDrop = FALSE;


        StopTimer();
        StartTimer();

        // only do this for this branch of the state diagram.
        // the event for the other branch is fired in A_16_7
        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) ); 
            
        // if the bubblable onselectstart event is cancelled, don't
        // go into DoSelection State, and cnx the tracker

        if ( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            BOOL fPositioned = FALSE;
            IGNORE_HR( _pDispStartPointer->IsPositioned( & fPositioned));
            if ( ! fPositioned )
            {
                //
                // Bad things have happened - probably tree has been torn down from under us.
                // we shut down this tracker.
                //
                _pManager->EnsureDefaultTrackerPassive();
                goto Cleanup;
            }
            
            IFC(_pManager->PositionCaret( _pDispStartPointer ));
        }
        else
        {
            BOOL    fDidSelection = FALSE;
            hr = DoSelectWord( pEvent, &fDidSelection );
            if (fDidSelection)
                goto Cleanup;

            SetState( ST_SELECTEDWORD );
#ifdef UNIX
            if (CheckSelectionWasReallyMade())
            {
                if (!_hwndDoc)
                    _pManager->GetEditor()->GetViewServices()->GetViewHWND(&_hwndDoc);
                SendMessage(_hwndDoc, EVT_GETTEXTPRIMARY, (WPARAM)&_firstMessage, IDM_CLEARSELECTION);
            }
#endif
        }
        break;

    case A_6_14 :   // ST_DOSELECTION & (EVT_LBUTTONUP || EVT_RBUTTONUP )
    case A_9_14 :   // ST_SELECTEDPARA & EVT_LBUTTONUP (was b90)
    case A_10_14m : // ST_WAIT3RDBTNDOWN & EVT_MOUSEMOVE
    case A_12_14 :  // ST_MAYSELECT2 & EVT_LBUTTONUP (was c50)
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( Action == A_6_14 )
        {
            BOOL        fDidSelection = FALSE;
            hr = THR( DoSelection( pEvent, TRUE, &fDidSelection ));
            if (fDidSelection)
            {
                goto Cleanup;
            }
            else if (hr)
            {
                AssertSz(0, "An error occurred in DoSelection");

                //  An error occurred in DoSelection.  Since we're going to go passive
                //  here, we'll ignore this error and continue.
                hr = S_OK;
            }

#ifdef UNIX // Now we have a selection we can paste using middle button paste.
            if (CheckSelectionWasReallyMade())
            {
                if (!_hwndDoc)
                    _pManager->GetEditor()->GetViewServices()->GetViewHWND(&_hwndDoc);
                SendMessage(_hwndDoc, EVT_GETTEXTPRIMARY, (WPARAM)&_firstMessage, IDM_CLEARSELECTION);
            }
#endif
        }

        if ( _fState == ST_SELECTEDPARA )
        {
            hr = S_FALSE; // don't consume event so on-click gets fired.
        }

        BecomePassive( TRUE);


        break;

    case A_6_6:     // ST_DOSELECTION & EVT_TIMER (CSynthEditEvent already constructed)
    case A_6_6m:    // ST_DOSELECTION & EVT_MOUSEMOVE

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }

        // Remain in same state
        break;

    case A_10_9: // ST_WAIT3RDBTNDOWN & EVT_LBUTTONDOWN

        if ( _pManager->IsInTimer() )
            StopTimer();

        SetState( ST_SELECTEDPARA );
        {
            BOOL    fDidSelection = FALSE;
            DoSelectParagraph( pEvent, &fDidSelection );
            if (fDidSelection)
                goto Cleanup;
        }
        break;

    case A_11_6: // ST_MAYSELECT1 & EVT_MOUSEMOVE (was c40)
        // if the bubblable onselectstart event is cancelled, don't
        // go into DoSelection State, and cnx the tracker

        //  Bug 110575: During very quick selections we may get a mouse down and mouse up
        //  before setting the state to ST_MAYSELECT1.  This causes us to be in this selection
        //  mode while the mouse button is already up.  We'll check to make sure that the
        //  mouse button is down before we initiate a selection.
        if (!pEvent->IsLeftButton())
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();
            if ( _pManager->IsInTimer() )
                StopTimer();
            BecomePassive( TRUE );
            break;
        }

        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );
        if ( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            _pManager->PositionCaret( _pDispStartPointer );
            break;
        }
        // else not canceled so fall through

    case A_8_6 : // ST_SELECTEDWORD & EVT_MOUSEMOVE
    case A_12_6: // ST_MAYSELECT2 & EVT_MOUSEMOVE (was c60)
        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( ! _fTookCapture )
        {
            TakeCapture();
            _fTookCapture = TRUE;
        }

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }
        SetState( ST_DOSELECTION );
        break;

    case A_9_6: // ST_SELECTEDPARA & EVT_MOUSEMOVE
        if ( ! _fTookCapture )
        {
            TakeCapture();
            _fTookCapture = TRUE;
        }

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }
        SetState( ST_DOSELECTION );
        break;

    case A_8_10: // ST_SELECTEDWORD & EVT_LBUTTONUP

        StopTimer();
        StartTimer();

        SetState( ST_WAIT3RDBTNDOWN );
        break;

    case A_1_14  : // ST_WAIT1          & EVT_RBUTTONUP
    case A_2_14r : // ST_DRAGOP         & EVT_RBUTTONUP
    case A_7_14  : // ST_WAITBTNDOWN2   & EVT_KEYDOWN
                   // ST_WAITBTNDOWN2   & EVT_MOUSEMOVE
    case A_10_14 : // ST_WAIT3RDBTNDOWN & EVT_KEYDOWN
    case A_11_14 : // ST_MAYSELECT1     & EVT_LBUTTONUP (was c30)
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( _fMadeSelection )
        {
            BecomePassive( TRUE );
        }
        else
        {
            //
            // Scenario.  User left mouse downs on text in document, and holds
            // mouse button down without moving the mouse.  We swallow the
            // LBUTTON_UP because the message occurs 'in selection', but we
            // still need to post an EVT_CLICK.  In order to do this, we have
            // to return S_FALSE
            //
            hr = (Action == A_11_14) ? S_FALSE : S_OK;
            _pManager->PositionCaret( _pDispStartPointer );
        }
        break;

    //
    // ST_KEYDOWN
    // Become Passive & Handle the Key.
    //
    // This is a "psuedo-state" - we really transition to ST_PASSIVE
    // however - we do a HandleKeyDown as well.
    //
    //
    case A_1_15:
    case A_3_15:
    case A_4_15:
    case A_5_15:
    case A_7_15:
    case A_8_15:
    case A_10_15:
    case A_12_15:
    case A_9_15:
    case A_16_15:
        //
        // Ignore the Control Key, as it's used in Drag & Drop or during selection etc.
        //
        if ( pEvent->IsControlKeyDown())
            break;

        BecomePassive( TRUE);
        //
        // If no selection was made - become passive will turn active tracker to a caret.
        // so we check for our state.
        //
        if ( IsPassive() )
        {
            hr = HandleKeyDown(
                        pEvent);
        }
        else
        {
            Assert( _pManager->GetActiveTracker() != this );
            hr = _pManager->RebubbleEvent( pEvent );
        }

        break;

    default:
        AssertSz (0, "Should never come here!");
        break;
    }

    if ( ( _fState == ST_DRAGOP ) &&
         ( ! fHandledDrag ) )
    {
        BecomePassive(); // DO NOT PASS A NOTIFY CODE HERE - IT WILL BREAK DRAG AND DROP
        hr = S_FALSE;
        DoTimerDrag();
    }

//
// We dump the select state for Dbg on - and the trace tag is on. Or we compiled with TRACKER_RETAIL_DUMP
//

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif

        DumpSelectState( pEvent, Action ) ;

#if DBG == 1
    }
#endif

#endif


Cleanup:
    RRETURN1 ( hr, S_FALSE );

}

//+====================================================================================
//
// Method: HandleChar
//
// Synopsis: Delete the Selection, and cause this tracker to end ( & kill us ).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::HandleChar(
                CEditEvent* pEvent )

{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spFlowElement;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL     bMultiLine = VARIANT_FALSE;
    SP_IMarkupPointer   spStart, spEnd;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

    LONG keyCode;
    IFC( pEvent->GetKeyCode( & keyCode ));

    if ( _pManager->IsContextEditable() && IsPassive() )
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(spStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(spEnd) );

        if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ))
        {
            if ( keyCode == VK_ESCAPE )
                goto Cleanup; // BAIL - we don't want to type a character

            if (keyCode == VK_RETURN)
            {
                Assert(_pDispStartPointer);
                IFR( _pDispStartPointer->GetFlowElement(&spFlowElement) );
                if ( spFlowElement )
                {
                    IFR(spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                    IFR(spElement3->get_isMultiLine(&bMultiLine));
                }


                if (bMultiLine)
                {
                    IFC( _pManager->DeleteRebubble( pEvent ));
                }
                else
                    return S_FALSE;
            }
            else
            {

                if (keyCode == VK_TAB)
                {
                    BOOL fPre;

                    IFC( GetStartSelection()->PositionMarkupPointer(spStart) );
                    IFC( GetEditor()->IsPointerInPre(spStart, &fPre));
                    if (fPre)
                    {
                        IFC( GetEndSelection()->PositionMarkupPointer(spEnd) );
                        IFC( GetEditor()->IsPointerInPre(spStart, &fPre));
                        if (fPre)
                        {
                            IFC( _pManager->DeleteRebubble( pEvent ));
                            goto Cleanup;
                        }
                    }
                    hr = S_FALSE;
                }
                else if( keyCode >= ' ' )
                {
                    IFC( _pManager->DeleteRebubble( pEvent ));
                }
            }
        }
    }
Cleanup:

    RRETURN1( hr, S_FALSE);
}


HRESULT
CSelectTracker::HandleKeyUp(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG keyCode;

    hr = HandleDirectionalKeys(pEvent);
    if (S_FALSE == hr)
    {
        IGNORE_HR( pEvent->GetKeyCode( & keyCode ));
        if ( (keyCode == VK_SHIFT ) && ( _fShift ) )
        {
            BecomePassive(TRUE);
            _fShift = FALSE;

            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_OK;
        }
    }

    RRETURN1( hr, S_FALSE);
}


HRESULT
CSelectTracker::HandleKeyDown(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    CSpringLoader * psl;
    int iWherePointer = SAME;
    long eLineDir= LINE_DIRECTION_LeftToRight;
    SP_ILineInfo spLineInfo;
    LONG keyCode;
    BOOL   fVertical = FALSE;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spMarkup;
    BOOL                fSelectionChanged = FALSE;
    BOOL                fCheckIfMovedIntoAtomicElement = FALSE;
    int                 iDirectionForAtomicAdjustment = SAME;

    Assert( IsPassive());

    if ( _pManager->IsContextEditable() )
    {

        IGNORE_HR( pEvent->GetKeyCode( & keyCode ));

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        
        switch( keyCode )
        {

            case VK_BACK:
            case VK_F16:
            {
                if ( _pManager->IsContextEditable() )
                {
                    psl = GetSpringLoader();
                    if (psl && _pDispStartPointer)
                    {
                        BOOL fDelaySpringLoad;
                        SP_IMarkupPointer spPointer;

                        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                        IFC( GetStartSelection()->PositionMarkupPointer(spPointer) );
                        IFC( MustDelayBackspaceSpringLoad(psl, spPointer, &fDelaySpringLoad) );

                        if (!fDelaySpringLoad)
                            IFC( psl->SpringLoad( spPointer, SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                    }

                    if ( pEvent->IsControlKeyDown() )
                    {
                        //
                        // TODO - make this use GetMoveDirection - after your checkin
                        //
                        IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
                        IFC( _pManager->PositionCaret( (iWherePointer == RIGHT ) ?
                                                        _pDispStartPointer :
                                                        _pDispEndPointer ,
                                                        pEvent ));
                    }
                    else
                    {
                        if ( CheckSelectionWasReallyMade())
                        {
                            IFC( _pManager->DeleteNoBubble());
                        }
                        else
                        {
                            _pManager->PositionCaret( _pDispStartPointer );
                        }
                    }
                }
            }
            break;


            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
                IFC( _pDispEndPointer->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_lineDirection(&eLineDir) );
                Assert( _pManager );

                //
                // See if this is in vertical layout
                //
                IFC( _pDispEndPointer->PositionMarkupPointer(spMarkup) );
                IFC( spMarkup->CurrentScope(&spElement) );
                IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );

                if (!IsShiftKeyDown())
                {
                    //
                    //  fForward    *1
                    //  fRTL        *2
                    //
                    BOOL  fForward = GetMoveDirection() ? TRUE: FALSE;
                    BOOL  fRTL     = (eLineDir == LINE_DIRECTION_LeftToRight) ? FALSE : TRUE;
                    UINT  nState   = 0;

                    if (fForward)    nState += 1;
                    if (fRTL)        nState += 2;

                    if (!fVertical) // horizontal
                    {
                        if (VK_LEFT == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 1 || nState == 2) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = LEFT;
                            break;
                        }
                        else if (VK_RIGHT == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 0 || nState == 3) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = RIGHT;
                            break;
                        }
                    }
                    else    // vertical
                    {
                        if (VK_UP == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 1 || nState == 2) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = LEFT;
                            break;
                        }
                        else if (VK_DOWN == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 0 || nState == 3) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = RIGHT;
                            break;
                        }
                    }
                    //
                    // only break for !ShiftKeyDown.
                    //
                }
                //
                // shift key is down - we fall thru.
                //

                // don't put a break here. We want to fall through
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            {
                if ( IsShiftKeyDown() )
                {
                    SP_IMarkupPointer   spOrigEndPointer;
                    SP_IHTMLElement spAtomicElement;
                    SP_IHTMLElement spElementAtSelectionAnchor;
                    SP_IHTMLElement spElementAtSelectionEnd;
                    CARET_MOVE_UNIT eMoveUnit = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);
                    Direction       eDirection = GetPointerDirection(eMoveUnit);
                    BOOL            fUpdateSelection = FALSE;

                    //  Keep track of where this end pointer was so that we can determine
                    //  whether we need to adjust out of an atomic element.
                    IFC( GetEditor()->CreateMarkupPointer(&spOrigEndPointer) );
                    IFC( _pDispEndPointer->PositionMarkupPointer(spOrigEndPointer) );

                    _fShift = TRUE;

                    //
                    // We don't have a shift pointer.  This can happen if the user shift extends a current
                    // selection.  In this case, update the shift pointer with the current end of selection
                    //
                    //
                    IFC( GetCurrentScope(_pDispShiftPointer, &spAtomicElement) );
                    if ( !HasShiftPointer() || _pManager->CheckAtomic(spAtomicElement) == S_OK )
                    {
                        IFC( UpdateShiftPointer( _pDispEndPointer ) );
                    }

                    //  If the user clicked in an atomic element and then does a shift-arrow to extend the selection
                    //  we want to keep the atomic element in the selection.  So, we need to check the selection
                    //  anchor pointer to see if the user clicked in an atomic element.  We will need to swap start
                    //  and end pointers as well depending on which direction the selection is extended.

                    IFC( GetCurrentScope(_pDispSelectionAnchorPointer, &spElementAtSelectionAnchor) );
                    if ( _pManager->CheckAtomic(spElementAtSelectionAnchor) ==  S_OK)
                    {
                        SP_IDisplayPointer      spDispTestPointer;
                        BOOL                    fSwapPointersForAtomicSelectionAnchor;

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispTestPointer) );

                        if (eDirection == LEFT)
                        {
                            //  We need to swap pointers if the end pointer is at the right edge of the atomic element
                            //  and the start pointer is to the left of the anchor pointer.

                            IFC( EdUtil::AdjustForAtomic(GetEditor(), spDispTestPointer, spElementAtSelectionAnchor, FALSE, RIGHT) );
                            IFC( _pDispEndPointer->IsLeftOf(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            if (!fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispEndPointer->IsEqualTo(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                            if (fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispStartPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                        }
                        else
                        {
                            //  We need to swap pointers if the end pointer is at the left edge of the atomic element
                            //  and the start pointer is to the right of the anchor pointer.

                            IFC( EdUtil::AdjustForAtomic(GetEditor(), spDispTestPointer, spElementAtSelectionAnchor, FALSE, LEFT) );
                            IFC( _pDispEndPointer->IsRightOf(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            if (!fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispEndPointer->IsEqualTo(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                            if (fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                        }

                        if (fSwapPointersForAtomicSelectionAnchor)
                        {
                            SP_IDisplayPointer      spDispTemp;

                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispTemp) );
                            IFC( spDispTemp->MoveToPointer(_pDispStartPointer) );
                            IFC( _pDispStartPointer->MoveToPointer(_pDispEndPointer) );
                            IFC( _pDispEndPointer->MoveToPointer(spDispTemp) );
                            IFC( _pDispShiftPointer->MoveToPointer(_pDispEndPointer) );
                            IFC( AdjustPointerForInsert( _pDispEndPointer, RIGHT, RIGHT ));
                            IFC( _pDispEndPointer->PositionMarkupPointer(spOrigEndPointer) );
                        }
                    }

                    hr = MoveSelection( eMoveUnit );

                    //  See if our selection ended up in an atomic element,
                    IFC( GetCurrentScope(_pDispEndPointer, &spElementAtSelectionEnd) );
                    if ( _pManager->FindAtomicElement(spElementAtSelectionEnd, &spAtomicElement) == S_OK )
                    {
                        //  We need to first see if we moved into the inside edge of the atomic element.
                        //  If so, we do not want to move again.

                        SP_IMarkupPointer   spPointer;
                        BOOL                fAtOutsideEdge = FALSE;
                        
                        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                        IFC( spPointer->MoveAdjacentToElement( spAtomicElement,
                                            (eDirection == RIGHT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
                        IFC( spPointer->IsEqualTo(spOrigEndPointer, &fAtOutsideEdge) );

                        if (!fAtOutsideEdge)
                        {
                            SP_IMarkupPointer   spAnotherPointer;

                            IFC( GetEditor()->CreateMarkupPointer(&spAnotherPointer) );
                            IFC( spAnotherPointer->MoveAdjacentToElement( spAtomicElement,
                                            (eDirection == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                            IFC( spAnotherPointer->IsEqualTo(spOrigEndPointer, &fAtOutsideEdge) );
                        }
                        if (fAtOutsideEdge)
                        {
                            IFC( spPointer->MoveAdjacentToElement( spAtomicElement,
                                                    (eDirection == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                        }

                        IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
                        fUpdateSelection = TRUE;
                    }

                    IFC( GetCurrentScope(_pDispStartPointer, &spAtomicElement) );
                    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
                    {
                        IFC( AdjustOutOfAtomicElement(_pDispStartPointer, spAtomicElement, eDirection) );
                        fUpdateSelection = TRUE;
                    }

                    if (fUpdateSelection)
                    {
                        IFC( UpdateSelectionSegments() );
                    }

                    //
                    // If the selection pointers collapse to the same point - we will start a caret.
                    //
                    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
                    if ( iWherePointer == SAME )
                    {
                        ClearSelection();
                        _pManager->PositionCaret( _pDispStartPointer );
                        fCheckIfMovedIntoAtomicElement = TRUE;
                    }
                }
                else if ( _pManager->IsContextEditable())
                {
                    SP_IDisplayPointer spDispPointer;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

                    CARET_MOVE_UNIT cmuMove;
                    cmuMove = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical ) ;

                    if ( cmuMove != CARET_MOVE_NONE )
                    {
                        IFC( GetCaretStartPoint( cmuMove,
                                                 spDispPointer ));

                        _pManager->PositionCaret( spDispPointer );

                        if (_pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Caret)
                        {
                            //
                            // Update the CaretTracker's _ptVirtualCaret if current _ptVirtualCaret
                            // preserves the caret "xy location". Which implies that this is a
                            // result of keynav into Atomic element. 
                            //
                            if (cmuMove == CARET_MOVE_PREVIOUSLINE || cmuMove == CARET_MOVE_NEXTLINE)
                            {
                                {
                                    SP_IMarkupPointer   spMarkup;
                                    POINT               ptLoc;
                                    BOOL                fFreeze;
                                    CCaretTracker   *pCaretTracker = DYNCAST(CCaretTracker, _pManager->GetActiveTracker());
                                    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
                                    IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                                    IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
                                    //
                                    // Update the pointer/(and location if possible).
                                    //
                                    fFreeze = pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
                                    IFC( pCaretTracker->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) ); 
                                    pCaretTracker->GetVirtualCaret().FreezePosition(fFreeze);
                                }
                            }
                        }

                        fSelectionChanged = TRUE;
                        fCheckIfMovedIntoAtomicElement = TRUE;

                        if (keyCode == VK_HOME)
                            iDirectionForAtomicAdjustment = LEFT;
                        else if (keyCode == VK_END)
                            iDirectionForAtomicAdjustment = RIGHT;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
            break;

#ifndef NO_IME
            case VK_KANJI:
                if (   949 == GetKeyboardCodePage()
                    && _pManager->IsContextEditable()
                    && EndPointsInSameFlowLayout())
                {
                    BOOL fEndAfterStart;
                    SP_IMarkupPointer spPointer;

                    IFC( _pDispEndPointer->IsRightOf( _pDispStartPointer, &fEndAfterStart ) );
                    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

                    if (fEndAfterStart)
                    {
                        IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) );
                    }
                    else
                    {
                        IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
                    }

                    _pManager->StartHangeulToHanja( spPointer, pEvent );
                }
                hr = S_OK;
                break;
#endif // !NO_IME
        }

        //  We don't want to position our caret inside of the atomic element, so check to make sure that
        //  we are outside of it.  We only care about cases where we have transitioned to a caret.  We
        //  don't want to transition back to atomic selection here.

        if (fCheckIfMovedIntoAtomicElement && _pManager->GetTrackerType() == TRACKER_TYPE_Caret)
        {
            SP_IHTMLCaret       spCaret;
            SP_IDisplayPointer  spDispPointer;

            IFC( GetDisplayServices()->GetCaret( &spCaret ));
            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
            IFC( GetCurrentScope(spDispPointer, &spElement) );

            if (_pManager->CheckAtomic(spElement) == S_OK)
            {
                SP_IHTMLCaret pc;
                IFC( GetDisplayServices()->GetCaret( &pc ));
                IFC( AdjustOutOfAtomicElement(spDispPointer, spElement, iDirectionForAtomicAdjustment) );
                IFC( pc->MoveCaretToPointer(spDispPointer, FALSE, CARET_DIRECTION_INDETERMINATE) );
            }
        }

        if (fSelectionChanged)
        {
            CSelectionChangeCounter selCounter(_pManager);
            selCounter.SelectionChanged();
        }
        
        if (S_FALSE == hr)
        {
            hr = HandleDirectionalKeys(pEvent);
        }

    }

Cleanup:

    return ( hr );
}









//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for EVT_TIMER messages.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::OnTimerTick()
{
    HRESULT                 hr = S_OK;

    if ( _pManager->IsInFireOnSelectStart() )
        return S_OK; // do nothing for timer ticks when we're in the middle of OnSelectStart

    StopTimer();

    switch (_fState)
    {
    case ST_MAYDRAG: // A_3_2 - start a drag.
        BecomePassive(); // DO NOT PASS A NOTIFY CODE HERE - IT WILL BREAK DRAG AND DROP
        hr = DoTimerDrag();
        goto Cleanup; // bail - as the tracker is dead.

    case ST_WAIT1:  // === A_1_3
        StartTimer();
        SetState( ST_MAYDRAG ) ;
        break;

    case ST_WAITBTNDOWN1: // === A_4_14t == A_4_14m
        // In this case, the cp is *never* updated to the
        // new position. So go and update it. Remember SetCaret
        // also kills any existing selections.

        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        // If we clicked in an atomic element, do not clear the selection during this timer event.
        if ( _fMouseClickedInAtomicSelection)
        {
            BecomePassive();
        }
        else
        {
            ClearSelection();

            _pManager->PositionCaret( _pDispStartPointer );

            {
                CSelectionChangeCounter selCounter(_pManager);
                selCounter.SelectionChanged();
            }
        }
        break;

    case ST_WAIT2:  // === A_5_11

        SetState( ST_MAYSELECT1 );
        break;

    case ST_WAITCLICK:
    case ST_WAITBTNDOWN2:   // === A_7_14
    case ST_WAIT3RDBTNDOWN: // === A_10_14
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();


        if (( _fMadeSelection ) && ( CheckSelectionWasReallyMade() ))
        {
            BecomePassive( TRUE );
        }
        else
        {
            _pManager->PositionCaret( _pDispStartPointer );
        }
        break;

    case ST_SELECTEDWORD:   // === A_8_12

        SetState( ST_MAYSELECT2 ) ;
        break;


    case ST_PASSIVE:
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();
        break;
    // ST_START, ST_DRAGOP, ST_MAYDRAG, ST_DOSELECTION,
    // ST_SELECTEDPARA, ST_MAYSELECT1, ST_MAYSELECT2
    default:
        AssertSz (0, "Invalid state & message combination!");
        break;
    }

    WHEN_DBG( DumpSelectState( NULL, A_UNK, TRUE ) );

Cleanup:
    RRETURN(hr);
}

#ifndef NO_IME
CSpringLoader *
CIme::GetSpringLoader()
{
    CSpringLoader * psl = NULL;
    CHTMLEditor   * pEditor;

    if (!_pManager)
        goto Cleanup;

    pEditor = _pManager->GetEditor();

    if (!pEditor)
        goto Cleanup;

    psl = pEditor->GetPrimarySpringLoader();

Cleanup:
    return psl;
}

HRESULT
CSelectTracker::HandleImeStartComposition(
    CEditEvent* pEvent)
{
    // We want to kill the current selection.
    // Bubble on up: CSelectTracker -> CCaretTracker -> CImeTracker

    if( GetEditor()->PointersInSameFlowLayout( _pDispStartPointer, _pDispEndPointer, NULL))
    {
        if ( _pManager->IsContextEditable() )
        {
            _pManager->DeleteRebubble( pEvent );
        }
    }

    return S_OK;
}

#endif // !(NO_IME)

//
//
// Selection Handling & Management
//
//

//+=================================================================================================
// Method: Begin Selection
//
// Synopsis: Do the things you want to do at the start of selection
//             This will involve updating the mouse position, and telling the Selection to add a Segment
//
//--------------------------------------------------------------------------------------------------

HRESULT
CSelectTracker::BeginSelection(
                        CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    POINT pt;
    BOOL fSelect;
    WHEN_DBG( int startCp;)
    SP_IHTMLElement spFlowElement;
    SP_IHTMLElement spAtomicElement;
    SP_IHTMLElement spBodyElement;
    SP_IDisplayPointer  spDispTempTestPointer;
    SP_IMarkupPointer   spPointer;
    BOOL    fClickOnAtomicElement = FALSE;

    Assert( _pDispStartPointer );

#if DBG == 1
    VerifyOkToStartSelection(pEvent);
    _ctScrollMessageIntoView = 0;
#endif

#if DBG == 1
    IFC( pEvent->GetPoint( & pt ));
    TraceTag(( tagSelectionTrackerState, "\n---BeginSelection---\nMouse:x:%d,y:%d", pt.x, pt.y));
#endif

    IFC( pEvent->MoveDisplayPointerToEvent ( _pDispStartPointer, NULL ));
    IFC( _pDispSelectionAnchorPointer->MoveToPointer(_pDispStartPointer) );

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(spPointer) );
    IGNORE_HR( GetEditor()->GetBody(&spBodyElement) );
    IFC( EdUtil::GetScrollingElement(GetMarkupServices(), spPointer, spBodyElement, &_pIScrollingAnchorElement, TRUE) );

#if DBG == 1
    startCp = GetCp( _pDispStartPointer );
#endif

    hr = MoveEndToPointer( _pDispStartPointer );
    if ( hr )
    {
        AssertSz( 0, "CSelectTracker::BeginSelection: Unable to position EndPointer");
        goto Cleanup;
    }

    // If atomic selection is on for the current element, we need to select the entire element
    // on the initial mouse click.

    IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
    if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
    {
        BOOL    fStartDidSelection = FALSE;
        BOOL    fEndDidSelection = FALSE;

        IFC( AdjustForAtomic( _pDispStartPointer, spAtomicElement, TRUE , & pt, &fStartDidSelection));
        IFC( AdjustForAtomic( _pDispEndPointer, spAtomicElement, FALSE , & pt, &fEndDidSelection));

        if (fStartDidSelection || fEndDidSelection)
        {
            goto Cleanup;
        }

        fClickOnAtomicElement = TRUE;
        _fStartIsAtomic = TRUE;
        _fStartAdjustedForAtomic = TRUE;

        //  Bug 102485: check to make sure click didn't occur in a selection (_fState != ST_WAIT1)
        //  before setting state to ST_WAIT2.
        if (_fState != ST_WAIT1)
            SetState( ST_WAIT2 );

        SetMadeSelection(TRUE);
        StartTimer();
        StartSelTimer();
    }

    //
    // BUG BUG - this is a bit expensive - but here I want to hit test EOL
    // and previously I didn't.
    //
    // Why do we want to hit test EOL here ? Otherwise we'll get bogus changes
    // in direction.
    //


    ReplaceInterface(&spDispTempTestPointer, _pDispTestPointer);

    //  If we adjusted for an atomic element, we want to move the test pointer with it.  The
    //  event pt may be inside of a nested markup.  We need to make sure that these pointers
    //  remain in the same markup.
    if (_fStartAdjustedForAtomic)
    {
        IFC( _pDispTestPointer->MoveToPointer( _pDispStartPointer ));
    }
    else
    {
        IFC( pEvent->MoveDisplayPointerToEvent( _pDispTestPointer, NULL , TRUE ));
    }

    if (_pDispTestPointer == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    IFC( pEvent->GetPoint( & pt ));
    IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));

    //
    // Set the tree the mouse is in.
    //

    if ( ! _fDragDrop )
    {
        BOOL		fSameMarkup;

        hr = ConstrainSelection( TRUE , & pt );

        // ConstrainSelection may have moved start pointer out of the markup where the event occurred.  In this
        // case we want to make sure we move the test pointer out with it to keep them in the same markup.
        IGNORE_HR( ArePointersInSameMarkup(GetEditor(), _pDispTestPointer, _pDispStartPointer, &fSameMarkup) );
        if (!fSameMarkup)
        {
	        IFC( _pDispTestPointer->MoveToPointer( _pDispStartPointer ));
        }

        IFC( CreateSelectionSegments() );

#if DBG == 1
        {
            SP_ISegmentList spSegmentList;
            BOOL            fEmpty = FALSE;
            HRESULT         hrDbg;

            hrDbg = GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList );
            if( !hrDbg ) spSegmentList->IsEmpty(&fEmpty);

            Assert( !fEmpty );
        }
#endif

    }

    Assert( ! hr );

    _ptCurMouseXY.x = _anchorMouseX = pt.x;
    _ptCurMouseXY.y = _anchorMouseY = pt.y;

    if (!fClickOnAtomicElement)
    {
        IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
        if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
        {
            _fStartIsAtomic = TRUE;
        }

        // ignore control-click for drag drop - they may want to copy
        if ( pEvent->IsControlKeyDown() && !_fDragDrop )
        {
            // Fire an event notification to determine whether to allow selection
            IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );

            if( fSelect )
            {
                BOOL    fDidSelection = FALSE;
                DoSelectParagraph( pEvent, &fDidSelection );
                if (fDidSelection)
                    goto Cleanup;
                SetState( ST_SELECTEDPARA );
            }
        }
        else if( (pEvent->GetHitTestResult() & HT_RESULTS_Glyph) && !_fDragDrop )
        {
            IFC( DoSelectGlyph(pEvent) );
            SetState( ST_PASSIVE );
        }
        else
        {
            StartTimer();
            StartSelTimer();
        }
    }


    IFC( _pDispStartPointer->GetFlowElement( & spFlowElement ));
    IFC( AttachPropertyChangeHandler( spFlowElement ));

Cleanup:
    if( FAILED(hr ))
    {
        //
        // We should have NEVER "began selection" on a place where we knew
        // we wouldn't be able to position a display pointer
        //
        Assert( hr != CTL_E_INVALIDLINE );

        _pManager->EnsureDefaultTrackerPassive( pEvent );

        if ( _pManager->IsInCapture())
            ReleaseCapture();
        if ( _pManager->IsInTimer())
            StopTimer();
    }

    RRETURN ( hr );
}

//+=================================================================================================
// Method: During Selection
//
// Synopsis: Do the things you want to do at the during a selection
//             Tell the selection to extend the current segment.
//
//--------------------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DoSelection(
                    CEditEvent* pEvent,
                    BOOL fAdjustSelection /*=FALSE*/,
                    BOOL* pfDidSelection /*=NULL*/)
{
    HRESULT hr = S_OK;
    Assert( _pDispEndPointer );

    BOOL fValidTree = TRUE ;
    BOOL fAdjustedSel = FALSE;
    int iWherePointer = SAME;
    BOOL fValidLayout = FALSE;
    HRESULT hrTestTree;
    BOOL fInEdit;
    SP_IMarkupPointer spPointer;
    SP_IHTMLElement spFlowElement;
    SP_IHTMLElement     spElement;
    SP_IDisplayPointer  spDispPointer;
    POINT pt;
    BOOL fSameMarkup = TRUE;
    BOOL fScrollSelectAnchorElement = FALSE;

#if DBG==1
    int endCp = 0;
    int startCp = 0;
    int testCp = 0;
    int oldEndCp = GetCp( _pDispEndPointer );
    int oldStartCp = GetCp( _pDispStartPointer );
    int newSelSize = 0;
    int oldSelSize = 0;
    int selDelta = 0;

    Assert(GetEditor()->ShouldIgnoreGlyphs() == FALSE);
#endif

    IFC( pEvent->GetPoint( & pt ));

    Assert( ! _fDragDrop );

    if (  fAdjustSelection ||
          ( pt.x != _ptCurMouseXY.x) ||
          ( pt.y != _ptCurMouseXY.y) ||
          ( pEvent->GetType() == EVT_TIMER ) )  // ignore spurious mouse moves.
    {
        //
        // When performing a selection, always pass NULL into the MoveDisplayPointerToEvent()
        // method if we are inside our editable element.  This way, hit testing works correctly
        // on elements with their own flow layout (like images, tables, etc.) that need to be hit
        // tested against their own layout, rather than the editable element (which could be the body,
        // for instance).  If we are outside our editable element, then pass in the editable element
        // to perform hit testing against.  This allows virtual hit testing to occur on things
        // like textareas.
        //

        // We want to make sure that we don't position _pDispTestPointer into another markup since
        // it could lead to problems where we update selection segments with pointers in different
        // markups.  We'll move a temp disp pointer to the event and see if the event occurred in
        // the same markup as where the selection started.
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( pEvent->MoveDisplayPointerToEvent( spDispPointer,
                                                _pManager->IsInEditableClientRect( pt) == S_OK ?
                                                                        NULL :
                                                                        GetEditableElement() ,
                                                TRUE));
        IFC( ArePointersInSameMarkup(_pManager->GetEditor(), spDispPointer, _pDispStartPointer, &fSameMarkup) );
        if (!fSameMarkup)
        {
            goto Cleanup;
        }

        //  See if we are extending the selection outside of the element where the selection
        //  began.  If this is the case, we want to scroll the anchor element when we call
        //  ScrollMessageIntoView.  Otherwise we'll scroll the editable element, which could
        //  be something else.
        IFC( GetCurrentScope(spDispPointer, &spElement) );
        if ( _pIScrollingAnchorElement && spElement && !SameElements(spElement, _pIScrollingAnchorElement) )
        {
            fScrollSelectAnchorElement = TRUE;
        }

        IFC( _pDispTestPointer->MoveToPointer(spDispPointer) );

        IFC( _pDispTestPointer->GetFlowElement(&spFlowElement) );
        fValidLayout = SameLayoutForJumpOver( spFlowElement,
                                              _pManager->GetEditableFlowElement());

        //
        // Ensure that we are in the edit context, and that fValidTree is set properly.
        //
        hrTestTree = _pManager->IsInEditContext( _pDispTestPointer, & fInEdit );
        Assert( fInEdit || hrTestTree || fValidTree );
        if ( hrTestTree == CTL_E_INCOMPATIBLEPOINTERS )
        {
            fValidTree = FALSE;
        }

#if DBG ==1
        testCp = GetCp( _pDispTestPointer );

        if ( IsTagEnabled( tagShowSelectionCp ))
        {
           CHAR sEvent[50];
           pEvent->toString(  sEvent );
           TraceTag((tagShowSelectionCp, "SelectionCp:%ld Event:%s", testCp , sEvent ));
        }

        if ( testCp == gDebugTestPointerCp ||
          ( testCp >= gDebugTestPointerMinCp && testCp <= gDebugTestPointerMaxCp ) )
        {
             if ( IsTagEnabled(tagSelectionDumpOnCp))
             {
                 DumpTree( _pDispTestPointer );
             }
         }
#endif

        //  Determine which direction we are going.  We compare the test pointer and the
        //  previous test pointer.  If both are equal, we use the word selection direction.
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
        BOOL fDirection = (iWherePointer == SAME ) ?
                            ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( & pt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                            ( iWherePointer == RIGHT ) ;

        // We do virtual hit testing, so we should always have fValidTree
        Assert(fValidTree);

        if ( fValidTree || !fAdjustedSel )
        {
            if ( !fValidLayout || !fInEdit )
            {
                ELEMENT_TAG_ID eTag = TAGID_NULL;
                SP_IHTMLElement spAtomicElement;

                IFC( GetEditor()->GetMarkupServices()->GetElementTagId( spFlowElement, &eTag ));
                IFC( GetCurrentScope(_pDispTestPointer, &spAtomicElement) );

                if ( !fInEdit )
                {
                    Assert( ! fInEdit && fValidTree );
                    fAdjustedSel = TRUE;

                    //
                    // TODO - I don't think I need this special case anymore.
                    // MoveMarkupPointer should magically be fixing this.
                    // but too much risk to change this now
                    //


                    //
                    // Just move the End to the Test. Constrain Selection will fix up
                    //
                    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, _pDispTestPointer) );
                    IFC( _pDispEndPointer->MoveToPointer( _pDispTestPointer ));
                }
                else if ( _pManager->IsContextEditable() ||
                          IsJumpOverAtBrowse( spFlowElement, eTag ) ||
                          _pManager->CheckAtomic( spAtomicElement )== S_OK ) // we only jump over at edit time or you can jump over this thing.
                {
                    if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
                    {
                        IFC( AdjustEndForAtomic(spAtomicElement, pt, fDirection, pfDidSelection, &fAdjustedSel) );
                        if (pfDidSelection && *pfDidSelection)
                            goto Cleanup;
                    }
                    else
                        fAdjustedSel = AdjustForSiteSelectable() ;

                }

                if ( fAdjustedSel )
                {
                    SetMadeSelection( TRUE );
                    _ptCurMouseXY.x = pt.x;
                    _ptCurMouseXY.y = pt.y;
                    IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
                }
            }

            if ( ! fAdjustedSel )
            {
                _fEndConstrained = FALSE;

                iWherePointer = SAME;
                IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispEndPointer, _pDispTestPointer, & iWherePointer )); // DO NOT IFC'IZE this. We want to do the constrain for inputs.
                if ( iWherePointer != SAME  )
                {
                    if ( ! _pManager->IsWordSelectionEnabled()
                        WHEN_DBG( || IsTagEnabled( tagSelectionDisableWordSel ))
                       )
                    {
                        MoveEndToPointer( _pDispTestPointer );
                        fAdjustedSel = TRUE;
                    }
                    else
                    {
                        SP_IHTMLElement spAtomicElement;
                        IFC( GetCurrentScope(_pDispTestPointer, &spAtomicElement) );

                        if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
                        {
                            BOOL        fBetween = TRUE;

                            IFC( AdjustEndForAtomic(spAtomicElement, pt, fDirection, pfDidSelection, &fAdjustedSel) );

                            //  Bug 102482: If we positioned the end pointer such that our initial selection
                            //  hit point is outside of the current selection, readjust the start so that it
                            //  will contain the selection hit point.

                            IFC( _pDispEndPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
                            if (fBetween)
                            {
                                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
                                if (!fBetween)
                                {
                                    //  Okay, we need to readjust our start pointer
                                    IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );

                                    //  We are already prep'd from the AdjustEndForAtomic call.  Just
                                    //  update the selection segments 'cause we're gonna exit early.
                                    if (pfDidSelection && *pfDidSelection)
                                    {
                                        IFC( UpdateSelectionSegments() );
                                    }
                                }
                            }

                            if (pfDidSelection && *pfDidSelection)
                                goto Cleanup;
                        }
                        else
                        {
                            //
                            // WORKITEM - we can enable paragraph selection mode here
                            // We should be checking _fInParagraph here. We've cut this for now.
                            //
                            Assert( fInEdit );

                            IFC( DoWordSelection( pEvent, & fAdjustedSel,fDirection ));

                            if (  _fShift || IsShiftKeyDown() )
                            {
                                IFC( UpdateShiftPointer( _pDispEndPointer ));
                                _fShift = TRUE;
                            }
                        }
                    }

                    SetMadeSelection( TRUE );
                    _ptCurMouseXY.x = pt.x;
                    _ptCurMouseXY.y = pt.y;
                    if ( fAdjustedSel )
                        IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
                }
            }
        }

        //
        // Adjust the start if it's atomic. Do this only once.
        //
        if ( _fStartIsAtomic && ! _fStartAdjustedForAtomic )
        {
            SP_IHTMLElement     spElement;

            IFC( GetCurrentScope( _pDispStartPointer, &spElement) );
            IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE , & pt, pfDidSelection));

            _fStartAdjustedForAtomic = TRUE ;

            if (*pfDidSelection)
                goto Cleanup;

            fAdjustedSel = TRUE;
        }

        if ( fAdjustSelection || fAdjustedSel )
        {
            BOOL fDidAdjust = FALSE;

            if ( fAdjustSelection )
                IFC( AdjustSelection( & fDidAdjust ));

            if ( fDidAdjust || fAdjustedSel )
            {
                SP_IMarkupPointer spStartPointer;
                SP_IMarkupPointer spEndPointer;

                if (!fInEdit && fValidTree)
                {
                    IFC( ConstrainSelection( FALSE, & pt ) );
                }
#if  DBG == 1
                endCp = GetCp( _pDispEndPointer );
                startCp = GetCp( _pDispStartPointer );
                oldSelSize = oldEndCp - oldStartCp;
                newSelSize = endCp - startCp;
                selDelta  = newSelSize - oldSelSize;

                if ( endCp == gDebugEndPointerCp ||
                  ( ( newSelSize == 0 )  && (  oldSelSize != 0  ) ) )
                {
                    if ( IsTagEnabled(tagSelectionDumpOnCp))
                    {
                        DumpTree( _pDispEndPointer );
                    }
                }
#endif
                if ( _fDoubleClickWord ) // extra funky IE 4/Word behavior
                {
                    //  Determine which direction we are going.  We compare the test pointer and the
                    //  previous test pointer.  If both are equal, we use the word selection direction.
                    IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
                    BOOL fDirectionNew = (iWherePointer == SAME ) ?
                                        ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( & pt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                                        ( iWherePointer == RIGHT ) ;

                    //
                    // WORKITEM. We should be checking _fInParagraph here. We've cut this for now.
                    //
                    Assert( fInEdit );

                    IFC( DoWordSelection( pEvent, & fAdjustedSel,fDirectionNew ));
                }

                IFC( UpdateSelectionSegments() );

                IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
                IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );

                IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
                IFC( _pDispEndPointer->PositionMarkupPointer(spEndPointer) );
                ResetSpringLoader(_pManager, spStartPointer, spEndPointer);

                IFC( ScrollMessageIntoView( pEvent, fScrollSelectAnchorElement ));

            }
        }

        else if ( pEvent->GetType() == EVT_TIMER )
        {
           //
           // Always scroll into view on EVT_TIMER. Why ?
           // So we can scroll the mousepoint into view if necessary
           //

           IFC( ScrollMessageIntoView( pEvent, fScrollSelectAnchorElement ));
        }

        IFC( AdjustStartForAtomic(fDirection) );
    }

    SetLastCaretMove( CARET_MOVE_NONE ); // Reset this to say we didn't have a MouseMove.
Cleanup:

    if (fAdjustedSel)
    {
        IGNORE_HR( EnsureAtomicSelection( pEvent ) );
    }

    if( hr == CTL_E_INVALIDLINE )
    {
        //
        // We tried to move selection into a place where a display pointer could not
        // be positioned.  In this case, we didn't adjust anything, so just return
        // S_OK;
        //
        hr = S_OK;
    }

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}



//+====================================================================================
//
// Method: DoSelectWord
//
// Synopsis: Select a word at the given point.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::DoSelectWord( CEditEvent* pEvent, BOOL* pfDidSelection /*=NULL*/ )
{
    HRESULT hr = S_OK;
    BOOL fAtStart = FALSE;
    BOOL fAtEnd = FALSE;
    IMarkupPointer* pTest = NULL;
    IHTMLElement * pIFlowElement = NULL;
    VARIANT_BOOL fDisabled = VARIANT_TRUE;
    IHTMLInputElement* pIInputElement = NULL;
    BSTR bstrType = NULL;
    BOOL fWasPassword = FALSE;
    IHTMLElement* pIElement = NULL;
    SP_IHTMLElement3 spElement3;
    CSpringLoader *psl = GetSpringLoader();
    SP_IMarkupPointer spStartPointer;
    SP_IMarkupPointer spEndPointer;
    POINT pt;

    IFC( pEvent->GetPoint(& pt ));

    // Currently, we reset for empty selections.  We may want to change this at some point.
    if (psl)
        psl->Reset();

    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
    IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );

    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );

    IFC( _pDispStartPointer->GetFlowElement( &pIFlowElement ));
    if ( ! pIFlowElement )
        goto Cleanup;

    IFC(pIFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->get_isDisabled(&fDisabled));

    if ( !fDisabled )
    {
        //
        // Special case to look to see if we are in a Password.
        // If we are - we don't want to do a word select - just select the entire contents of the password
        // Why ? Because we might then be revealing the presence of a space in the password ( gasp !)
        //
        if ( _pManager->GetEditableTagId() == TAGID_INPUT )
        {
            //
            // Get the Master.
            //
            IFC( _pManager->GetEditableElement(&pIElement) );

            IFC( pIElement->QueryInterface (
                                            IID_IHTMLInputElement,
                                            ( void** ) & pIInputElement ));

            IFC(pIInputElement->get_type(&bstrType));

            if (!StrCmpIC( bstrType, TEXT("password")))
            {
                SP_IDisplayPointer spDispPointer;

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

                IFC( spDispPointer->MoveToMarkupPointer(_pManager->GetStartEditContext(), NULL) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                IFC( MoveStartToPointer(spDispPointer) );

                IFC( _pDispEndPointer->MoveToMarkupPointer( _pManager->GetEndEditContext(), NULL));
                IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                fWasPassword = TRUE;
            }
        }

        if ( ! fWasPassword )
        {
            SP_IHTMLElement     spElement;

            IFC( GetCurrentScope(_pDispStartPointer, &spElement) );
            if ( _pManager->CheckAtomic( spElement ) == S_OK )
            {
                IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE, & pt, pfDidSelection ));
                if (*pfDidSelection)
                    goto Cleanup;
                IFC( AdjustForAtomic( _pDispEndPointer, spElement, FALSE , & pt, pfDidSelection ));
                if (*pfDidSelection)
                    goto Cleanup;
            }
            else
            {

                SP_IMarkupPointer spPointer;

                ClearInterface( & pIFlowElement );
                IFC( GetEditor()->CreateMarkupPointer( & pTest ));

                //  For atomic elements, we want to do word selection depending on where the user
                //  double clicked.  So, we really want to adjust using our anchor pointer.
                if (_fStartIsAtomic)
                {
                    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(pTest) );
                }
                else
                {
                    IFC( _pDispStartPointer ->PositionMarkupPointer(pTest) );
                }

                //
                // Move Start
                //
                IsAtWordBoundary( pTest, & fAtStart, NULL );
                if ( ! fAtStart )
                {
                    IFC( MoveWord(  pTest, MOVEUNIT_PREVWORDBEGIN));
                }
                IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) )

                //
                // See if we're in the same flow layout
                //
                if ( GetEditor()->PointersInSameFlowLayout( spPointer, pTest, NULL ))
                {
                    SP_IDisplayPointer  spDispPointer;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    IFC( spDispPointer->MoveToMarkupPointer(pTest, NULL) );
                    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    IFC( MoveStartToPointer( spDispPointer, TRUE ));
                }
                else
                {
                    SP_IDisplayPointer  spDispPointer;

                    //
                    // We know the Start went into another layout. If we go left - we will find that
                    // layout start. We position ourselves at the start of the layout boundary.
                    //

                    DWORD dwBreak = 0;
                    ED_PTR( scanPointer);
                    _pDispTestPointer->PositionMarkupPointer(scanPointer);
                    scanPointer.Scan( LEFT,
                                      BREAK_CONDITION_Site,
                                      &dwBreak);
                    Assert( scanPointer.CheckFlag(  dwBreak, BREAK_CONDITION_Site ));
                    scanPointer->Right(TRUE, NULL, NULL, NULL, NULL);

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    IFC( spDispPointer->MoveToMarkupPointer(scanPointer, _pDispTestPointer) );

                    IFC( MoveStartToPointer( spDispPointer, TRUE ));
                }

                //
                // Move End
                //

                //  For atomic elements, we want to do word selection depending on where the user
                //  double clicked.  So, we really want to adjust using our anchor pointer.
                if (_fStartIsAtomic)
                {
                    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(pTest) );
                }
                else
                {
                    IFC( _pDispEndPointer->PositionMarkupPointer(pTest) );
                }

                IsAtWordBoundary( pTest, NULL, & fAtEnd );
                if ( ! fAtEnd )
                {
                    IFC( MoveWord( pTest, MOVEUNIT_NEXTWORDBEGIN ));
                }
                //
                // See if we're in the same flow layout
                //
                IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
                if ( GetEditor()->PointersInSameFlowLayout( spPointer, pTest, NULL ))
                {
                    //
                    // See if we moved pass a block boundary.
                    //
                    ED_PTR( endPointer );
                    DWORD dwBreakCondition = 0;

                    endPointer.MoveToPointer( pTest );

                    if ( ! fAtEnd )
                    {
                        endPointer.SetBoundary(
                                _pManager->GetStartEditContext(),
                                _pManager->GetEndEditContext());
                        endPointer.Scan( LEFT,
                                         BREAK_CONDITION_Text |
                                         BREAK_CONDITION_Block |
                                         BREAK_CONDITION_NoScopeBlock |
                                         BREAK_CONDITION_Site ,
                                         & dwBreakCondition);

                        WHEN_DBG( SetDebugName( endPointer, _T(" Word Block Scanner")));
                        BOOL fHitBlock =   endPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Block | BREAK_CONDITION_NoScopeBlock  );

                        if ( fHitBlock )
                        {
                            //
                            // We found an Exit Block. Instead of doing a move word - scan
                            // from the end looking for a block boundary.
                            //
                            _pDispEndPointer->PositionMarkupPointer(endPointer);
                            endPointer.Scan( RIGHT,
                                                BREAK_CONDITION_Block |
                                                BREAK_CONDITION_Site |
                                                BREAK_CONDITION_NoScopeBlock |
                                                BREAK_CONDITION_Boundary |
                                                BREAK_CONDITION_NoLayoutSpan,
                                                & dwBreakCondition );

                            if ( ! endPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ))
                            {
                                endPointer.Scan( LEFT,
                                                    BREAK_CONDITION_Block |
                                                    BREAK_CONDITION_Site |
                                                    BREAK_CONDITION_NoScopeBlock |
                                                    BREAK_CONDITION_Boundary |
                                                    BREAK_CONDITION_NoLayoutSpan,
                                                    & dwBreakCondition );
                            }

                            hr = THR( MoveEndToMarkupPointer(endPointer, NULL, TRUE) );
                        }
                        else
                        {
                            Assert( ! fHitBlock ); // I know this looks funny. The debugger gets confused on the above so looks like it steps into here.

                            hr = THR( MoveEndToMarkupPointer(pTest, NULL, TRUE) );
                        }
                    }
                }
                else
                {
                    //
                    // We know the End went into another layout. If we go right  we will find that
                    // layout boundary - we position ourselves at the start of the layout boundary.
                    //

                    DWORD dwBreak = 0;
                    ED_PTR( scanPointer);
                    _pDispTestPointer->PositionMarkupPointer(scanPointer);
                    scanPointer.Scan( RIGHT,
                                      BREAK_CONDITION_Site,
                                      &dwBreak);

                    Assert( scanPointer.CheckFlag( dwBreak, BREAK_CONDITION_Site ));

                    IFC( scanPointer->Left( TRUE, NULL, NULL, NULL, NULL ));
                    IFC( MoveEndToMarkupPointer(scanPointer, NULL, TRUE) );
                }
            }
        }
    }
    else
    {
        IFC( spStartPointer->MoveAdjacentToElement( pIFlowElement, ELEM_ADJ_BeforeBegin ));
        IFC( _pDispStartPointer->MoveToMarkupPointer(spStartPointer, NULL) );

        IFC( spEndPointer->MoveAdjacentToElement( pIFlowElement, ELEM_ADJ_AfterEnd));
        IFC( _pDispEndPointer->MoveToMarkupPointer(spEndPointer, NULL) );
    }

    if ( hr )
        goto Cleanup;

    IFC( ConstrainSelection( TRUE, & pt));
    IFC( AdjustSelection( NULL ));
    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );
    }

    if ( !fWasPassword && !fDisabled && !_fStartIsAtomic )
    {
        _fDoubleClickWord = TRUE;

        //
        // If we got here by double-click - we're in word sel mode.
        //
        _fInWordSel = TRUE;
        IFC( _pDispWordPointer->MoveToPointer( _pDispEndPointer ));
        _fWordPointerSet = TRUE;

    }

    SetMadeSelection( TRUE);
Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    SysFreeString( bstrType );
    ReleaseInterface( pIElement );
    ReleaseInterface( pIInputElement );
    ReleaseInterface( pIFlowElement );
    ReleaseInterface( pTest );
    RRETURN( hr );
}


//+====================================================================================
//
// Method: DoSelectParagraph
//
// Synopsis: Select a paragraph at the given point.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::DoSelectParagraph( CEditEvent* pEvent, BOOL* pfDidSelection /*=NULL*/ )
{
    HRESULT hr = S_OK;
    CSpringLoader   *psl = GetSpringLoader();
    SP_IHTMLElement spBlockElement = NULL;
    CBlockPointer copyBlock( _pManager->GetEditor() );
    CBlockPointer bpLeft( _pManager->GetEditor() );
    SP_IMarkupPointer spPointer;
    SP_IDisplayPointer  spDispPointer;
    POINT pt;
    BOOL fEmpty = FALSE;

    CBlockPointer blockPointer( _pManager->GetEditor() );
    IFC( pEvent->GetPoint( & pt ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

    if (psl)
        psl->Reset();
    //
    // Find left edge
    //
    if ( _fStartIsAtomic )
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope( _pDispStartPointer, &spElement) );
        IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE, & pt, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
        IFC( AdjustForAtomic( _pDispEndPointer, spElement, FALSE , & pt, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }
    else
    {
        BOOL                fSameMarkup = TRUE;

        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) );

        IFC( bpLeft.MoveTo(spPointer, RIGHT) );

        IFC( bpLeft.IsEmpty(&fEmpty) );
        if (!fEmpty)
        {
            IFC( bpLeft.MoveToFirstNodeInBlock() );
        }

        IFC( bpLeft.MovePointerTo(spPointer, ELEM_ADJ_AfterBegin) );

        IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispStartPointer, spDispPointer, &fSameMarkup) );
        if (!fSameMarkup)
            goto Cleanup;

        IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );

        //
        // Find right edge of current block.  For our purposes, the right
        // edge of the block should include any siblings in the parent block.
        // This will cause a triple click in a paragraph that contains controls
        // to have the controls selected.  We move past all siblings by calling
        // MoveToLastNodeInBlock().  This will position the block pointer at the
        // last node in the parent block, or it will break on layout in the block.
        //

        IFC( blockPointer.MoveTo(&bpLeft) );

        if (!fEmpty)
            IFC( blockPointer.MoveToLastNodeInBlock());

        IFC( copyBlock.MoveTo( & blockPointer ));

        if ( blockPointer.MoveToSibling(RIGHT) == S_FALSE )
        {
            //
            // If we positioned our blockPointer at the last block in our parent
            // block, we may have to move our end of selection past our parent block
            // so that select past the end of block.
            //
            if ( copyBlock.IsLeafNode() )
            {
                //
                // Move to our parent block.  If we have a parent block
                // with type BLOCK, then we can adjust our pointers to
                // encompass the end of this block.
                //
                IFC( copyBlock.MoveToParent());

                if( copyBlock.GetType() != NT_Block )
                {
                    copyBlock.MoveTo( &blockPointer );
                }
            }

            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
            IFC( copyBlock.MovePointerTo( spPointer, ELEM_ADJ_AfterEnd ));

            IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
            IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spDispPointer, &fSameMarkup) );
            if (!fSameMarkup)
                goto Cleanup;

            IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
        else
        {
            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
            IFC( copyBlock.MovePointerTo( spPointer, ELEM_ADJ_BeforeEnd ));

            IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
            IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spDispPointer, &fSameMarkup) );
            if (!fSameMarkup)
                goto Cleanup;

            IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
    }

    IFC( ConstrainSelection( TRUE, & pt ));
    IFC( AdjustSelection( NULL ));
    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );
        IFC( FireOnSelect() );
    }

    //
    // Not scrolling into view here is correct.
    //
    SetMadeSelection( FALSE );

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: ConstrainSelection
//
// Synopsis: Constrain a Selection between the editable context
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::ConstrainSelection( BOOL fMoveStart /*=fALSE*/, POINT* pptGlobal /*=NULL*/, BOOL fStartAdjustedForAtomic /*=FALSE*/, BOOL fEndAdjustedForAtomic /*=FALSE*/ )
{
    HRESULT hr = S_OK;
    BOOL fDirection = GetMoveDirection();
    ELEMENT_ADJACENCY eAdj = ELEMENT_ADJACENCY_Max;

    if ( fMoveStart )
    {
        hr = ConstrainPointer( _pDispStartPointer, fDirection );
        if (hr == CTL_E_INVALIDLINE && fStartAdjustedForAtomic)
            hr = S_OK;
    }

    if ( !pptGlobal ||
         !_pManager->IsEditContextPositioned() )
    {
        hr = THR( ConstrainPointer( _pDispEndPointer, fDirection ));
        if (hr == CTL_E_INVALIDLINE && fEndAdjustedForAtomic)
            hr = S_OK;
    }
    else if ( ! _pManager->IsInEditContext( _pDispEndPointer ))
    {
        //
        // We do this for positioned elements only. Why ? Because where the pointer is in the stream
        // may not necessarily match where it "looks like" it should be.
        //
        // Most of the time we don't get here. MoveMarkupPointer should have adjusted us perfectly already.
        //
        long midX, lLeft, lRight;
        RECT rect;
        SP_IHTMLElement2 spElement2;
        SP_IHTMLElement spElement = _pManager->GetEditableElement();
        SP_IMarkupPointer spEndPointer;

        if (!spElement)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        IFC(spElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
        // Editable Element always has a flowlayout, so no need to check here.
        IFC(GetEditor()->GetBoundingClientRect(spElement2, &rect));

        lLeft = rect.left;
        lRight = rect.right;

        midX = ( lRight + lLeft) / 2;

        if ( pptGlobal->x <= midX )
            eAdj = ELEM_ADJ_AfterBegin;
        else
            eAdj = ELEM_ADJ_BeforeEnd;

        IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
        IFC( spEndPointer->MoveAdjacentToElement( spElement, eAdj ));
        
        WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spEndPointer) );
        IFC( _pDispEndPointer->MoveToMarkupPointer(spEndPointer, NULL) );
    }

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );

    RRETURN( hr );
}

//+====================================================================================
//
// Method: DoWordSelection
//
// Synopsis: Do the word selection behavior. Select on word boundaries when in Word Selection
//           mode.
//
//------------------------------------------------------------------------------------

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used
#endif

HRESULT
CSelectTracker::DoWordSelection(
                        CEditEvent* pEvent ,
                        BOOL* pfAdjustedSel,
                        BOOL fFurtherInStory )
{
    HRESULT hr = S_OK;
    BOOL fStartWordSel = FALSE;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;

    Assert( pfAdjustedSel );
#if DBG == 1
    int endCp = 0;
    int oldEndCp = GetCp( _pDispEndPointer );
    int oldStartCp = GetCp( _pDispStartPointer );
    int startCp = oldStartCp;
#endif

    if ( _fInWordSel )
    {
        if ( !!_fWordSelDirection != fFurtherInStory ) // only look at changes in direction that are not in Y
        {
            SP_IMarkupPointer spTestPointer;

            // We only pay attention to changes in direction in the scope of the previous
            // word. Hence moves up or down by a line - that are changes in direction won't
            // snap us out of word select mode.
            //
            ED_PTR( prevWordPointer );
            ED_PTR( nextWordPointer );
            IFC( _pDispPrevTestPointer->PositionMarkupPointer(prevWordPointer) );
            IFC( _pDispPrevTestPointer->PositionMarkupPointer(nextWordPointer) );
            IFC( MoveWord( prevWordPointer, MOVEUNIT_PREVWORDBEGIN ));
            IFC( MoveWord( nextWordPointer, MOVEUNIT_NEXTWORDBEGIN ));
            BOOL fBetween = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
            IFC( spTestPointer->IsRightOfOrEqualTo( prevWordPointer, & fBetween ));
            if ( fBetween )
            {
                IFC( spTestPointer->IsLeftOfOrEqualTo( nextWordPointer, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok
            }

            if ( fBetween )
            {
                _fInWordSel = FALSE;
                WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer));
                IFC( _pDispWordPointer->MoveToPointer( _pDispSelectionAnchorPointer ) );
                IFC( MoveEndToPointer ( _pDispTestPointer, TRUE ));
                _fWordPointerSet = FALSE;
                *pfAdjustedSel = TRUE;
            }
        }

        if ( _fInWordSel ) // if we're still in word sel
        {
            //
            // We're in the same direction, we can move words.
            //

            IFC( AdjustEndForWordSelection(fFurtherInStory) );
            *pfAdjustedSel = TRUE;
        }
    }
    else
    {
        SP_IMarkupPointer spWordPointer;
        BOOL fWordPointerSet = FALSE;
        IFC( GetEditor()->CreateMarkupPointer(&spWordPointer) );
        IFC( _pDispWordPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( _pDispWordPointer->PositionMarkupPointer(spWordPointer) );

        IFC( SetWordPointer( spWordPointer, fFurtherInStory, FALSE , & fStartWordSel , &fWordPointerSet) );
        IFC( _pDispWordPointer->MoveToMarkupPointer(spWordPointer, NULL) );

        _fWordPointerSet = fWordPointerSet;

        if ( _fWordPointerSet )
        {
            if ( ! fStartWordSel )
            {
                int iWherePointer = SAME;

                WHEN_DBG( ValidateWordPointer(_pDispWordPointer));
                IFC( _pManager->GetEditor()->OldDispCompare( _pDispWordPointer, _pDispTestPointer, & iWherePointer ));

                switch( iWherePointer )
                {
                    case LEFT:
                        fStartWordSel = !fFurtherInStory ;
                        break;

                    case RIGHT:
                        fStartWordSel = fFurtherInStory;
                        break;
                }
            }

            if ( fStartWordSel )
            {
                SP_IDisplayPointer spDispEndPointer;

                _fInWordSel = TRUE;

                WHEN_DBG( ValidateWordPointer( _pDispWordPointer ));

                //
                // The first time we jump into word sel mode, we set the word pointer off of StartPointer.
                // This is valid for the purposes of determining if we went past the boundary - and for
                // determining where to set the Start Pointer to.
                // It is also valid to set the end off of this if you moved over this pointer
                //
                // However there are some cases (like starting a selection in the empty space of tables)
                // Where this causes us to move the end to the start - when it should be moved to test
                // So what we do here is always set the end off of test.
                //

                ED_PTR( tempPointer );
                IFC( _pDispTestPointer->PositionMarkupPointer(tempPointer) );
                IFC( SetWordPointer( tempPointer, fFurtherInStory , TRUE ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndPointer) );
                IFC( spDispEndPointer->MoveToMarkupPointer(tempPointer, NULL) );
                IFC( spDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( MoveEndToPointer( spDispEndPointer, TRUE ));

                WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer ));

                _fWordPointerSet = FALSE;


                if ( ! ENSURE_BOOL(_fStartAdjusted) )
                {
                    SP_IMarkupPointer spStartPointer;

                    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );

                    //
                    // Check to see if the Start is already at a word boundary
                    // we don't make the adjustment if the context to the left/right of start
                    // is not text !
                    //

                    IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );
                    if ( fFurtherInStory )
                    {
                        IFC( spStartPointer->Left( FALSE, & eContext, NULL, NULL, NULL ));
                    }
                    else
                    {
                        IFC( spStartPointer->Right( FALSE, & eContext, NULL, NULL, NULL ));
                    }

                    if ( eContext == CONTEXT_TYPE_Text )
                    {
                        SP_IMarkupPointer   spMarkup;
                        SP_IMarkupPointer2  spMarkup2;
                        BOOL fAlreadyAtStartOfWord = FALSE;

                        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
                        IFC( _pDispStartPointer->PositionMarkupPointer(spMarkup) );

                        IFC( spMarkup->QueryInterface(IID_IMarkupPointer2, (void **) &spMarkup2));
                        IFC( spMarkup2->IsAtWordBreak(&fAlreadyAtStartOfWord));

                        if ( ! fAlreadyAtStartOfWord && !_fExitedWordSelectionOnce )
                        {
                            IFC( MoveWord( _pDispStartPointer, fFurtherInStory ?
                                                          MOVEUNIT_PREVWORDBEGIN  :
                                                          MOVEUNIT_NEXTWORDBEGIN ));

                            ConstrainPointer( _pDispStartPointer, fFurtherInStory );
                            IFC( MoveStartToPointer(_pDispStartPointer, TRUE) );
                        }
                    }

                    _fStartAdjusted = TRUE;

                    WHEN_DBG( _ctStartAdjusted++);
#ifndef _PREFIX_
                    Assert( _ctStartAdjusted == 1);
#endif
                }
                _fStartAdjusted = TRUE;
                _fWordSelDirection = fFurtherInStory;

                *pfAdjustedSel = TRUE;
            }
            else
            {
                IFC( MoveEndToPointer( _pDispTestPointer ));
                *pfAdjustedSel = TRUE;
            }
            WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer));
        }
    }

    //  If we are no longer in word selection and the start pointer was adjusted for word selection
    //  we need to reset it to the anchor point if the anchor and word adjusted start pointers
    //  are in the same word.

    if ( !_fInWordSel && _fStartAdjusted )
    {
        BOOL                fBetween = FALSE;
        SP_IMarkupPointer   spTestPointer;
        ED_PTR( prevWordPointer );
        ED_PTR( nextWordPointer );

        _fExitedWordSelectionOnce = TRUE;

        IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(prevWordPointer) );
        IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(nextWordPointer) );
        IFC( MoveWord( prevWordPointer, MOVEUNIT_PREVWORDBEGIN ));
        IFC( MoveWord( nextWordPointer, MOVEUNIT_NEXTWORDBEGIN ));

        IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
        IFC( spTestPointer->IsRightOfOrEqualTo( prevWordPointer, & fBetween ));
        if ( fBetween )
        {
            IFC( spTestPointer->IsLeftOfOrEqualTo( nextWordPointer, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok
        }

        if ( fBetween )
        {
            IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );
            _fStartAdjusted = FALSE;
            WHEN_DBG( _ctStartAdjusted = 0 );
            *pfAdjustedSel = TRUE;
        }
    }

    IFC( AdjustStartForAtomic(fFurtherInStory) );

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

HRESULT
CSelectTracker::AdjustEndForWordSelection(BOOL fFurtherInStory)
{
    HRESULT hr = S_OK;
    BOOL    fNeedsAdjust;

    if ( fFurtherInStory )
    {
        IFC( _pDispWordPointer->IsLeftOf(_pDispTestPointer, &fNeedsAdjust) );
    }
    else
    {
        IFC( _pDispWordPointer->IsRightOf(_pDispTestPointer, &fNeedsAdjust) );
    }

    if ( fNeedsAdjust )
    {
        SP_IMarkupPointer   spMarkup;
        SP_IMarkupPointer2  spMarkup2;
        BOOL                fAlreadyAtWord = FALSE;

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spMarkup) );

        IFC( spMarkup->QueryInterface(IID_IMarkupPointer2, (void **) &spMarkup2));
        IFC( spMarkup2->IsAtWordBreak(&fAlreadyAtWord));

        IFC( _pDispWordPointer->MoveToPointer( _pDispTestPointer ));
        if ( ! fAlreadyAtWord )
        {
            //
            // Use GetMoveDirection() instead of fFurtherInStory here.
            //
            IFC( MoveWord( _pDispWordPointer, GetMoveDirection() ?
                                          MOVEUNIT_NEXTWORDBEGIN :
                                          MOVEUNIT_PREVWORDBEGIN   ));
            IFC( ConstrainPointer( _pDispWordPointer, fFurtherInStory ));
        }

        WHEN_DBG( ValidateWordPointer(_pDispWordPointer) );
        IFC( MoveEndToPointer( _pDispWordPointer, TRUE ));
    }
    WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer ));

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispWordPointer, _pDispStartPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN(hr);
}

//+====================================================================================
//
// Method: SetWordPointer
//
// Synopsis: Set the Word Pointer if it's not set already.
//
// Parameters:
//      fSetFromGivenPOinter - if false - we use either _pDispStartPointer, or _pDispPrevTestPointer to determine
//                                what to set the WOrd Pointer off of.
//                                if true we use where the Pointer given already is - to set the word pointer
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::SetWordPointer(
                                IMarkupPointer* pPointerToSet,
                                BOOL fFurtherInStory,
                                BOOL fSetFromGivenPointer, /* = FALSE*/
                                BOOL* pfStartWordSel, /* = NULL*/
                                BOOL* pfWordPointerSet /*= NULL*/ )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spTestPointer;
    BOOL fStartWordSel = FALSE;
    BOOL fAtWord = FALSE;
    BOOL fBlockBetween = FALSE;
    BOOL fWordPointerSet = FALSE;
    BOOL fPointersAreEqual = FALSE;

    //
    // The first time we drop into word selection mode - we use the start pointer
    // from then on - we go off of the _testPointer
    // We know if this is the first time if we haven't reversed yet
    //
    BOOL fAtStart = FALSE;
    BOOL fAtEnd = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
    IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );

    if ( ! fSetFromGivenPointer )
    {
        //
        // You may be at a word boundary. But it may not be the "right" word boundary.
        // Hence if you start a selection at the beginning of a word and select right
        // the "right" word boundary is the end of the word - not where you started !
        //

        fAtWord = IsAtWordBoundary( _pDispTestPointer/*_pDispStartPointer*/, &fAtStart, &fAtEnd, TRUE  );
        if (fAtWord)
        {
            //  Okay, we are at some word boundary.  Check to make sure we are not
            //  at the same position as the given pointer.  If we are, we need
            //  to reposition it.

            IFC( spTestPointer->IsEqualTo(pPointerToSet, &fPointersAreEqual) );
        }
        IFC( _pDispStartPointer->PositionMarkupPointer(pPointerToSet) );
    }
    else
    {
#if DBG == 1
        BOOL fPositioned;
        IGNORE_HR( pPointerToSet->IsPositioned( & fPositioned));
        Assert( fPositioned );
#endif
        fAtWord = IsAtWordBoundary( pPointerToSet, & fAtStart, &fAtEnd );
    }



    //
    // We move the word pointer, if start was not already at a word.
    //
    if ( !fAtWord || fPointersAreEqual )
    {
        IFC( MoveWord( pPointerToSet,
                       fFurtherInStory ? MOVEUNIT_NEXTWORDBEGIN : MOVEUNIT_PREVWORDBEGIN ));

        IFC( ConstrainPointer( pPointerToSet, fFurtherInStory ));

        //
        // Compensate for moving past the end of a line.
        //
        // We look for this by seeing if the Test is to the left of a block (for the fFurtherInStory case)
        // and the word is to the right of a block.
        //

        fBlockBetween = IsAdjacentToBlock( pPointerToSet, fFurtherInStory ? LEFT: RIGHT ) &&
                        IsAdjacentToBlock( spTestPointer, fFurtherInStory ? RIGHT : LEFT );

        if ( fBlockBetween )
        {
            //
            // We moved past line end. Compensate.
            //

            IFC( _pDispTestPointer->PositionMarkupPointer(pPointerToSet) );
            fStartWordSel = TRUE;
            fWordPointerSet = TRUE;
        }
        else
        {
            fWordPointerSet = IsAtWordBoundary( pPointerToSet );
        }
    }
    else
    {
        //
        // We know we're at a word boundary.
        //
        fWordPointerSet = TRUE;
    }

    if ( pfStartWordSel )
        *pfStartWordSel = fStartWordSel;

    if ( pfWordPointerSet )
        *pfWordPointerSet = fWordPointerSet;

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispWordPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN( hr );
}

#if DBG == 1

//+====================================================================================
//
// Method: ValidateWordPointer
//
// Synopsis: Do some checks to see the Word Pointer is at a valid place
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::ValidateWordPointer(IDisplayPointer* pDispPointer)
{
#if 0
    if ( IsTagEnabled ( tagSelectionValidateWordPointer ))
    {
        SP_IMarkupPointer spPointer;

        ELEMENT_TAG_ID eTag = TAGID_NULL;
        IHTMLElement* pIElement = NULL;
        BOOL fAtWord = FALSE;
        //
        // Check to see we're not in the root or other garbage
        //
        IGNORE_HR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IGNORE_HR( pDispPointer->PositionMarkupPointer(spPointer) );
        IGNORE_HR( GetEditor()->CurrentScopeOrMaster( pDispPointer, &pIElement, spPointer ) );
        IGNORE_HR( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
        Assert( eTag != TAGID_NULL );

        fAtWord = IsAtWordBoundary( spPointer );
        AssertSz( fAtWord, "Pointer is not at a word");
        ReleaseInterface( pIElement );
    }
#endif
}

#endif

//
//
// Adjustment Code.
//
//
//+====================================================================================
//
// Method: AdjustPointersForLayout - used by Adjust Selection
//
// Synopsis: AdjustPointers for not being in the same flow layout.
//
//      Check to see if start and end aren't in the same flow layout.
//
//      If they aren't try and move them inwards - so they end up in the same layout.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustPointersForLayout( IMarkupPointer* pStart,
                                         IMarkupPointer* pEnd,
                                         BOOL* pfStartAdjusted /* = NULL*/ ,
                                         BOOL* pfEndAdjusted /*= NULL*/ )
{
    HRESULT hr = S_OK;
    ED_PTR( edScanStart );
    ED_PTR( edScanEnd );
    BOOL fFoundEndLayout= FALSE;
    BOOL fFoundStartLayout = FALSE;

    SP_IHTMLElement spEndLayout;
    SP_IHTMLElement spStartLayout;
    SP_IHTMLElement spAdjustStart;
    SP_IHTMLElement spAdjustEnd;


    //
    // See if the pointers are in the same flow layout
    //

    if ( !GetEditor()->PointersInSameFlowLayout( pStart, pEnd, NULL))
    {
        IFC( edScanStart.MoveToPointer( pStart ));
        IFC( edScanEnd.MoveToPointer( pEnd ));

        IFC( GetEditor()->GetFlowElement( pEnd, &spEndLayout));

        IFC( ScanForLayout( RIGHT,
                            edScanStart,
                            spEndLayout,
                            & fFoundEndLayout,
                            & spAdjustStart ));

        if ( ! fFoundEndLayout )
        {
            //
            // Move out of the layout - until you're in the same layout
            // as the StartPointer
            //
            IFC( GetEditor()->GetFlowElement( pStart, & spStartLayout));
            IFC( ScanForLayout( LEFT,
                                edScanEnd,
                                spStartLayout,
                                & fFoundStartLayout,
                                & spAdjustEnd ));
        }

        //
        // We didn't find the end or the start - but when we adjusted both of them
        // we ended up in the same layout
        // an example would be adjusting across TD's
        //
        // so we had:
        //  <td>  start-> </td><td>   </td><td> <- end </td>
        //
        // and end up  with:
        //  <td>  </td> <td> start->  <- end </td><td>  </td>
        //

        if ( ! fFoundEndLayout && ! fFoundStartLayout
             && GetEditor()->PointersInSameFlowLayout( edScanStart, edScanEnd, NULL ))
        {
            fFoundEndLayout = TRUE;
            fFoundStartLayout = TRUE;
        }
    }

    if ( fFoundEndLayout )
    {
        IFC( pStart->MoveToPointer( edScanStart ));
    }

    if ( fFoundStartLayout)
    {
        IFC( pEnd->MoveToPointer( edScanEnd ));
    }

    if ( pfStartAdjusted )
        *pfStartAdjusted = fFoundEndLayout;

    if ( pfEndAdjusted )
        *pfEndAdjusted = fFoundStartLayout;

Cleanup:

    RRETURN( hr );

}

//+====================================================================================
//
// Method: AdjustPointersBetweenBlocks - used by AdjustSelection
//
// Synopsis: Will try to adjust a given pointer to the "magic place" between blocks.
//
//          So if your pointer was inside the enter block of a <p> like this
//
//              <p> ... </p><p> <- Ptr
//
//
//          This routine will try and place the ptr between the 2 blocks like this:
//
//
//              <p>....</p> <-Ptr <p>
//
// We do this by :
//
//      Looking left to see if there is an ExitBlock. If there is - we Scan for the FirstEnterBlock
//      Then we go right for last exit block
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustEndPointerBetweenBlocks(
                            IMarkupPointer* pStartPointer,
                            IMarkupPointer* pEndPointer,
                            DWORD dwAdjustOptions,
                            BOOL* pfAdjusted )
{
    HRESULT hr = S_OK;
    ED_PTR( epScan);
    ED_PTR( epAdjust);
    SP_IHTMLElement spElement;
    BOOL fAdjustedIn = FALSE;
    BOOL fAdjustedOut = FALSE;
    DWORD dwBreakCondition = 0;

    IFC( epScan.MoveToPointer( pEndPointer ));
    IFC( epAdjust.MoveToPointer( pEndPointer ));
    IFC( epScan.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));
    IFC( epAdjust.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));

    //
    // Look Left - to see if you hit an exit block.
    // If you did - then we need to Scan Left - until we hit an EnterBlock
    //
    IFC( epScan.Scan( LEFT,
                     BREAK_CONDITION_Content ,
                     & dwBreakCondition,
                     & spElement,
                     NULL,
                     NULL,
                     SCAN_OPTION_TablesNotBlocks ));


	if ( epScan.CheckFlag( dwBreakCondition,
                              BREAK_CONDITION_ExitBlock )
         && spElement ) // possible to be null for a return in a PRE ( NoScopeBlock breaks on hard returns).
    {
            BOOL fEqualFuzzy = FALSE;

            IFC( epScan.IsEqualTo( pStartPointer ,
                                 BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor,
                                 & fEqualFuzzy ));
            if ( ! fEqualFuzzy )
            {
                //
                // If we found an exit block - continue looking to the left to see if
                // you enter a block. Only if you do find an Enter Block and nothing else
                // do you have to move to the special place.
                //
                IFC( epScan.Scan( LEFT,
                                  BREAK_CONDITION_Content - BREAK_CONDITION_ExitBlock ,
                                  & dwBreakCondition ));


                if( epScan.CheckFlag( dwBreakCondition,
                                      BREAK_CONDITION_EnterBlock | BREAK_CONDITION_NoScopeBlock ))
                {
                    fAdjustedIn = TRUE;

                    IFC( epScan.Scan( RIGHT ,
                                      BREAK_CONDITION_Content  ,
                                      & dwBreakCondition ));

                }
            }
    }

    if ( fAdjustedIn )
    {
        IFC( epAdjust.MoveToPointer( epScan ));
    }
    //
    //
    // Now go right - looking for last Exit Block
    // This handles the Nested Block case
    //
    // eg.
    //    if we had : </div> <- End Ptr </span> </font> </div>
    //
    // we want to have
    //                </div> </span> </font> </div> <- End Ptr
    //

    if ( dwAdjustOptions & ADJ_END_SelectBlockRight )
    {
        IFC( epScan.MoveToPointer( epAdjust ));

        IFC( epScan.Scan(   RIGHT,
                            BREAK_CONDITION_Content ,
                            & dwBreakCondition,
                            NULL,
                            NULL,
                            NULL,
                            SCAN_OPTION_TablesNotBlocks ));

        if ( epScan.CheckFlag(  dwBreakCondition,
                                BREAK_CONDITION_ExitBlock |
                                BREAK_CONDITION_NoScopeBlock |
                                BREAK_CONDITION_Boundary ))
        {
            fAdjustedOut = TRUE;

            //
            // If we found an exit block - continue looking to the right to see if
            // you enter a block. Only if you do find an Enter Block and nothing else
            // do you have to move to the special place.
            //
            if( !epScan.CheckFlag( dwBreakCondition, BREAK_CONDITION_NoScopeBlock ) )
            {
                IFC( ScanForLastExitBlock( RIGHT , epScan ));
            }

            IFC( epAdjust.MoveToPointer( epScan ));

        }
    }

    if ( fAdjustedIn || fAdjustedOut )
    {
        IFC( pEndPointer->MoveToPointer( epAdjust ));
    }

Cleanup:
    if ( pfAdjusted )
        *pfAdjusted = fAdjustedIn || fAdjustedOut ;

    RRETURN( hr );
}

//+====================================================================================
//
// Method: AdjustSelection
//
// Synopsis: Adjust the Selection to wholly encompass blocks. We do this if the End point is
//           outside a block, or we started from the shift key.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustSelection(BOOL* pfAdjustedSel )
{
    HRESULT hr = S_OK;
    ED_PTR( epEnd );
    ED_PTR( epStart ) ;
    SP_IDisplayPointer spDispPointer;
    SP_IDisplayPointer spDispStart;
    SP_IDisplayPointer spDispEnd;

    BOOL fSwap = FALSE;
    BOOL fEqualFuzzy = FALSE;
    BOOL fBOL = FALSE;
    DWORD dwAdjustOptions = 0;
    BOOL fAdjustShiftPtr = FALSE;
    BOOL fRightOf;

#if DBG == 1
    BOOL fPointersInSameBefore;
    BOOL fPointersInSameAfter ;
#endif

    //
    // Find the "True" Start & End
    //
    IFC( MovePointersToTrueStartAndEnd( epStart, epEnd, & fSwap ));

    //
    // See if you're in the same place as the start pointer. If you are - there's no need
    // to adjust (happens in selection at start of a block )
    // eg.
    //              <p> <--Start <-- End
    //

    IFC( epStart.IsEqualTo( epEnd,
                            BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor,
                            & fEqualFuzzy ));

    //
    // If the pointers are equal, check to see if they are also at the
    // beginning of a line.  We still want to adjust the end pointer
    // if it falls at the end of a line
    //
    if( fEqualFuzzy )
    {
        IFC( _pDispStartPointer->IsAtBOL(&fBOL) );
    }

    if ( !fEqualFuzzy || !fBOL )
    {
#if DBG == 1
        fPointersInSameBefore = GetEditor()->PointersInSameFlowLayout( epStart, epEnd, NULL );
#endif

        //
        // Adjust the end to enclose the last block.  Don't do the adjust if
        // we are moving the selection by a word forward or back.. we need to
        // be able to adjust past block boundaries when doing word select
        //
        if( !( _fShift && ( _lastCaretMove == CARET_MOVE_WORDFORWARD ||
                            _lastCaretMove == CARET_MOVE_WORDBACKWARD ) ) )
        {
            if( _lastCaretMove == CARET_MOVE_LINEEND || _lastCaretMove == CARET_MOVE_LINESTART )
            {
                //
                // Adjust the REAL end pointer
                //
                IFC( AdjustEndPointerBetweenBlocks( fSwap ? epEnd : epStart,
                                                    fSwap ? epStart : epEnd,
                                                    ADJ_END_SelectBlockRight,
                                                    &fAdjustShiftPtr) );
            }
            else
            {
                dwAdjustOptions = _fState == ST_SELECTEDPARA ? ADJ_END_SelectBlockRight : 0;
                IFC( AdjustEndPointerBetweenBlocks( epStart, epEnd, dwAdjustOptions) );
            }            
        }

        //
        // Tweak for "incorrect" layouts.
        //
        IFC( AdjustPointersForLayout( epStart, epEnd ));

        //
        // Adjust the Start  pointer for insert to move into text.
        //
        //
        // We can't use the _fAtBOL flag here - it's only meaningful for the
        // end point of selection
        //

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->MoveToMarkupPointer(epStart, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

        IFC( AdjustPointerForInsert( spDispPointer, RIGHT, RIGHT ));

        IFC( spDispPointer->PositionMarkupPointer(epStart) );

        //
        // AdjustPointerForInsert could have moved epStart beyond epEnd
        //
        IFC( epEnd->IsRightOfOrEqualTo(epStart, &fRightOf) );
        if (!fRightOf)
        {
            //
            // Collapse into caret
            //
            epEnd->MoveToPointer(epStart);
        }
        
        if ( _fShift && ( _lastCaretMove == CARET_MOVE_PREVIOUSLINE || _lastCaretMove == CARET_MOVE_NEXTLINE ) )
        {
            IFC( spDispPointer->MoveToMarkupPointer(epEnd, NULL) );
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        }

#if DBG == 1
        fPointersInSameAfter = GetEditor()->PointersInSameFlowLayout( epStart, epEnd, NULL );

        AssertSz( (fPointersInSameBefore && fPointersInSameAfter) ||
                !fPointersInSameBefore, "Pointers have been adjusted out of Layout");
#endif

        //
        // Now adjust the context to the adjusted start and end
        //

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
        
        if (!fRightOf)
        {
            IFC( spDispStart->MoveToMarkupPointer(epStart, spDispPointer) );
            IFC( spDispEnd->MoveToMarkupPointer(epEnd, spDispPointer) );
        }
        else
        {
            IFC( spDispStart->MoveToMarkupPointer(epStart, _pDispStartPointer) );
            IFC( spDispEnd->MoveToMarkupPointer(epEnd, _pDispEndPointer) );
        }

        if ( ! fSwap )
        {
            IFC( MoveStartToPointer( spDispStart ));
            IFC( MoveEndToPointer( spDispEnd ));
        }
        else
        {
            IFC( MoveEndToPointer( spDispStart ));
            IFC( MoveStartToPointer( spDispEnd ));
        }

        //
        // marka - explicitly set the pointer gravity - based on the direction of the selection
        //
        if ( ! fSwap )
        {
            IFC( _pDispStartPointer->SetPointerGravity( POINTER_GRAVITY_Right ));

            IFC( _pDispEndPointer->SetPointerGravity( POINTER_GRAVITY_Left ));
        }
        else
        {
            IFC( _pDispEndPointer->SetPointerGravity( POINTER_GRAVITY_Right ));

            IFC( _pDispStartPointer->SetPointerGravity( POINTER_GRAVITY_Left ));
        }
        
        IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );
        IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

        if( fAdjustShiftPtr )
        {
            IFC( _pDispShiftPointer->MoveToPointer( _pDispEndPointer ) );
        }            
    }    

    if ( pfAdjustedSel )
        *pfAdjustedSel = TRUE ;
Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectTracker::AdjustPointersForChar()
{
    HRESULT         hr;
    DWORD           dwBreak;
    ED_PTR( epStart );
    ED_PTR( epEnd );

    DWORD           eBreakCondition = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor;
    CSpringLoader * psl = _pManager->GetEditor()->GetPrimarySpringLoader();
    SP_IDisplayPointer  spDispPointer;

    IFC( epStart.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext() ));
    IFC( epEnd.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext() ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

    IFC( MovePointersToTrueStartAndEnd(epStart, epEnd, NULL) );

    IFC( epStart.Scan(RIGHT, eBreakCondition, & dwBreak ) ); // skip phrase elements
    if ( ! epStart.CheckFlag( dwBreak, BREAK_CONDITION_Boundary ))
    {
        IFC( epStart.Scan(LEFT, eBreakCondition, NULL) ); // move back
    }

    IFC( epEnd.Scan(RIGHT, eBreakCondition, & dwBreak ) ); // skip phrase elements
    if ( ! epEnd.CheckFlag( dwBreak, BREAK_CONDITION_Boundary ))
    {
        IFC( epEnd.Scan(LEFT, eBreakCondition, NULL) ); // move back
    }

    IFC( spDispPointer->MoveToMarkupPointer(epStart, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( MoveStartToPointer( spDispPointer ));

    IFC( spDispPointer->MoveToMarkupPointer(epEnd, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( _pDispEndPointer->MoveToPointer(spDispPointer) );

    IFC( UpdateSelectionSegments( FALSE ) ); // dont' fire OM - selection is going away

    //
    // Spring load in the right place
    //

    if (psl)
    {
        BOOL fFurtherInStory = GetMoveDirection();

        if (fFurtherInStory)
        {
            if (SUCCEEDED(_pDispStartPointer->PositionMarkupPointer(epStart)))
            {
                IGNORE_HR( psl->SpringLoad(epStart, SL_TRY_COMPOSE_SETTINGS) );
            }
        }
        else
        {
            if (SUCCEEDED(_pDispEndPointer->PositionMarkupPointer(epEnd)))
            {
                IGNORE_HR( psl->SpringLoad(epEnd, SL_TRY_COMPOSE_SETTINGS) );
            }
        }
    }

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: AdjustForSiteSelectable.
//
// Synopsis: We just moved the end point into a different flow layout. Check to see if
//           the thing we moved into is Site Selectable. If it is - Jump Over it, using the
//           direction in which we are moving.
//
//           Return - TRUE - if we adjusted the selection
//                    FALSE if we didn't make any adjustments. Normal selection processing
//                          should occur.
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::AdjustForSiteSelectable()
{
    HRESULT             hr = S_OK;
    BOOL                fAdjustedSelection = FALSE;     // Did we adjust selection?
    SP_IHTMLElement     spStartElement;                 // Element where selection started
    SP_IHTMLElement     spStartSiteSelectElement;       // Site selectable element where selection started
    SP_IHTMLElement     spInThisElement;                // Element over candidate end of selection
    SP_IHTMLElement     spFlowElement;
    SP_IMarkupPointer   spTestPointer;                  // Where the candidate end of selection is at
    SP_IHTMLElement     spSiteSelectThis;
    SP_IMarkupPointer   spStartPointer;                 // Markup pointer for start of selection
    BOOL                fSameMarkup = FALSE;            // Are the candidate and the start in the same markup?
    ELEMENT_ADJACENCY   eAdj;
    SP_IHTMLElement     spOldSiteSelect;                // Guarantee for loop termination

    // Figure out our adjacency based on movedirection
    eAdj = GetMoveDirection() ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin;

    //
    // Position a pointer at start of selection
    //
    IFC( GetEditor()->CreateMarkupPointer( & spStartPointer ));
    IFC( _pDispStartPointer->PositionMarkupPointer( spStartPointer ));

    //
    // Create a markup pointer, and position it at the test pointer
    //
    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );

    IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
    IFC( GetEditor()->CurrentScopeOrMaster(_pDispTestPointer, &spInThisElement, spTestPointer ));

    if ( _pManager->GetSiteSelectableElementFromElement(spInThisElement, &spSiteSelectThis ) == S_OK )
    {
        //
        // spSiteSelectThis now points to the element which would be siteselected had a mouse
        // down occurred at our candidate end of selection
        //
        Assert( _pManager->IsInEditContext(_pDispTestPointer ) );

        IFC( spTestPointer->MoveAdjacentToElement( spSiteSelectThis, eAdj ));

        //
        // The following figures out dragging across multiple nested markups.
        // We just keep walking up the master chain until we are in the same markup
        //
        IFC( ArePointersInSameMarkup( spStartPointer, spTestPointer, &fSameMarkup ) )

        while( !fSameMarkup )
        {
            SP_IHTMLElement spMaster;

            //
            // Get the master element, and position our test pointer after or
            // before this element
            //
            IFC( GetEditor()->GetViewLinkMaster( spSiteSelectThis, &spMaster ) );

            if( !spMaster )
                goto Cleanup;

            IFC( spTestPointer->MoveAdjacentToElement( spMaster, eAdj ));

            IFC( ArePointersInSameMarkup( spStartPointer, spTestPointer, &fSameMarkup ) );
            spSiteSelectThis = spMaster;
        }

        //
        // We can't arbitrarily position the end pointer to the test pointer.
        // Consider the following case (input inside a positioned div)
        //
        //   |============|
        //   |            |
        //   |  ________  |
        //   | |________| |
        //   |            |
        //   |            |
        //   |============|
        //
        // We start selecting outside the positioned div, and we successfully text
        // select the div.  Now we move the mouse over the input.  The candidate
        // end of selection is over the input, but we cannot move the end of selection
        // to that point, as that would de text-select the div, which is not the behavior
        // we want.
        //
        // We want to make sure we don't position the end pointer across any elements
        // that are site-selectable.
        //

        IFC( GetCurrentScope(_pDispStartPointer, &spStartElement) );
        IFC( _pManager->GetSiteSelectableElementFromElement(spStartElement, &spStartSiteSelectElement ) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
        IFC( GetEditor()->CurrentScopeOrMaster(spTestPointer, &spInThisElement ));

        //
        // Keep moving the test pointer until we come to an element which is not
        // site selectable
        //
        while( (_pManager->GetSiteSelectableElementFromElement(spInThisElement, &spSiteSelectThis ) == S_OK)
                && !(SameElements( spSiteSelectThis, spOldSiteSelect ) )
                && !(SameElements( spSiteSelectThis, spStartSiteSelectElement ) ) )
        {
            IFC( spTestPointer->MoveAdjacentToElement( spSiteSelectThis, eAdj ) );
            IFC( GetEditor()->CurrentScopeOrMaster( spTestPointer, &spInThisElement ) );

            spOldSiteSelect = spSiteSelectThis;
        }

        IFC( _pDispEndPointer->MoveToMarkupPointer(spTestPointer, NULL) );
        fAdjustedSelection = TRUE;
    }

Cleanup:
    return ( fAdjustedSelection );
}

//
//
// Privates / Utils
//
//

void
CSelectTracker::ResetSpringLoader( CSelectionManager* pManager, IMarkupPointer* pStart, IMarkupPointer* pEnd )
{
    CHTMLEditor   * ped = pManager ? pManager->GetEditor() : NULL;
    CSpringLoader * psl = ped ? ped->GetPrimarySpringLoader() : NULL;
    BOOL            fResetSpringLoader = FALSE;

    // Not using a BOOLEAN OR because it bugs PCLint, which thinks
    // that they're evaluated right to left.
    if (!psl)
        goto Cleanup;
    if (!psl->IsSpringLoaded())
        goto Cleanup;

    // Hack for Outlook: Are the pointers only separated by an &nbsp on an empty line.
    fResetSpringLoader = S_OK != psl->CanSpringLoadComposeSettings(pStart, NULL, FALSE, TRUE);
    if (fResetSpringLoader)
        goto Cleanup;

    {
        SP_IMarkupPointer   spmpStartCopy;
        BOOL                fEqual = FALSE;
        MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
        long                cch = 1;
        TCHAR               ch;
        HRESULT             hr;

        fResetSpringLoader = TRUE;

        hr = THR(CopyMarkupPointer(pManager->GetEditor(), pStart, &spmpStartCopy));
        if (hr)
            goto Cleanup;

        hr = THR(spmpStartCopy->Right(TRUE, &eContext, NULL, &cch, &ch));
        if (hr)
            goto Cleanup;

        hr = THR(spmpStartCopy->IsEqualTo(pEnd, &fEqual));
        if (hr)
            goto Cleanup;

        if (   eContext == CONTEXT_TYPE_Text
            && cch == 1
            && ch == WCH_NBSP
            && fEqual )
        {
            fResetSpringLoader = FALSE;
        }
    }

Cleanup:

    if (fResetSpringLoader)
        psl->Reset();
}

//+====================================================================================
//
// Method: SetState
//
// Synopsis: Set the State of the tracker. Don't set state if we're in the passive state
//           unless we're explicitly told to do so.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::SetState(
                    SELECT_STATES inState,
                    BOOL fIgnorePassive /*=FALSE*/)
{
    if ( _fState != ST_PASSIVE || fIgnorePassive )
    {
        _fState = inState;
    }
}


//+====================================================================================
//
// Method: DoTimerDrag
//
// Synopsis: Do a drag from a EVT_TIMER message
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DoTimerDrag()
{
    HRESULT             hr = S_OK;
    CEdUndoHelper       undoDrag(GetEditor());
    SP_IHTMLElement3    spElement3;
    VARIANT_BOOL        fRet;
    SP_IDisplayPointer  spDispStart;
    SP_IDisplayPointer  spDispEnd;
    SP_IMarkupPointer   spStartSel,spEndSel ;
#if DBG == 1
    SP_IMarkupPointer   spTestPointer;
#endif
       
    Assert( _pIDragElement );        

    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispStart ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispEnd ));

    IFC( GetEditor()->CreateMarkupPointer( & spStartSel ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndSel ));
#if DBG == 1
    IFC( GetEditor()->CreateMarkupPointer( & spTestPointer ));
#endif
    IFC( _pISegment->GetPointers(spStartSel, spEndSel ) );

    IFC( spDispStart->MoveToMarkupPointer( spStartSel , NULL ));
    IFC( spDispEnd->MoveToMarkupPointer( spEndSel, NULL ));

    //
    // We would like to create a 'fake selection' when the edit context is editable.
    // For instance, when we drag from inside trident to another location inside Trident,
    // CDoc::DragEnter() destroys selection if the doc is in edit mode (so that document.selection
    // returns type CARET and the user gets visual feedback (in the form of a caret) of where
    // the drop would occur.  With the new IHighlightRenderingServices interface, we can
    // still render the original selection as selected to give feedback about what is being dropped
    //
    if( GetEditor()->IsContextEditable() )
    {
        IFC( _pManager->CreateFakeSelection( _pIDragElement, spDispStart, spDispEnd ));
    }

    //
    // Begin the drag
    //
    IFC( undoDrag.Begin(IDS_EDUNDOMOVE) );

    IGNORE_HR( GetSelectionManager()->FirePreDrag() );

    IFC( _pManager->BeginDrag(_pIDragElement));

    IFC(_pIDragElement->QueryInterface(IID_IHTMLElement3, (void**)&spElement3));

#if DBG == 1
    hr = THR( spTestPointer->MoveAdjacentToElement( _pIDragElement, ELEM_ADJ_BeforeBegin ) );
    Assert(hr == S_OK);
#endif

    IFC(spElement3->dragDrop(&fRet));

    hr = fRet ? S_OK : S_FALSE;

    if ( _pManager->HasFakeSelection() )
    {
        //  The drag may cause us to remove spElement3 from the tree, in which case ondragend will
        //  not be fired.  So we can't assume that if we still have a fake selection the drag
        //  failed.  If we do have a fake selection we'll check to make sure that the element
        //  is no longer positioned.
#if DBG == 1
        if( fRet )
        {
            hr = THR( spTestPointer->MoveAdjacentToElement( _pIDragElement, ELEM_ADJ_BeforeBegin ) );
            AssertSz(hr == CTL_E_UNPOSITIONEDELEMENT, "An error occurred during the drag");
        }
#endif
        IFC( _pManager->DestroyFakeSelection());
    }

    if (!fRet)
    {
        //  Drag failed.  Scroll selection back into view.
        IFC( spDispStart->ScrollIntoView() );
    }

    IFC( _pManager->EndDrag()); // ensure this happens

Cleanup:
    if ( FAILED(hr) )
    {
        // It is possible that we exited prematurely.  If this is the case we need to ensure
        // that we cleanup after ourself to make sure that we don't leak here.  We need to
        // ensure that we destroyed our fake selection and detached our drag listeners.
        
        TraceTag((tagError, "CSelectTracker::DoTimerDrag(): An error occurred during the drag.  hr=0x%x", hr));
        
        if ( _pManager->HasFakeSelection() )
        {
            IFC( _pManager->DestroyFakeSelection());
        }
        if (_pManager->_pIDropListener)
        {
            IFC( _pManager->EndDrag()); // ensure this happens
        }
    }

    Assert(!_pManager->HasFakeSelection());
    Assert(_pManager->_pIDragListener == NULL);
    Assert(_pManager->_pIDropListener == NULL);

    RRETURN ( hr );
}


VOID
CSelectTracker::SetMadeSelection( BOOL fMadeSelection )
{
    if ( ! _fMadeSelection )
    {
        _pManager->HideCaret();
    }
    _fMadeSelection = fMadeSelection;
}

//+====================================================================================
//
// Method: GetCaretStartPoint
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::GetCaretStartPoint(
                        CARET_MOVE_UNIT inCaretMove,
                        IDisplayPointer* pDispCopyStart )
{
    HRESULT     hr = S_OK;
    int         iWherePointer;
    SP_IMarkupPointer   spMarkup;
    SP_IHTMLElement     spAtomicElement;
    POINT               ptLoc;

    Assert( pDispCopyStart);

    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
    switch (inCaretMove)
    {
    case    CARET_MOVE_BACKWARD:
    case    CARET_MOVE_FORWARD:
    case    CARET_MOVE_WORDBACKWARD:
    case    CARET_MOVE_WORDFORWARD:
            {
                //
                // We really only care about PointerDirection when it is inline movement
                //
                Direction   dir;

                dir = GetPointerDirection(inCaretMove);
                if ( (RIGHT == iWherePointer && LEFT  == dir )||
                     (LEFT  == iWherePointer && RIGHT == dir )   )
                {
                    IFC( pDispCopyStart->MoveToPointer( _pDispStartPointer ) );
                }
                else
                {
                    IFC( pDispCopyStart->MoveToPointer( _pDispEndPointer ) );
                }
                break;
            }

     case CARET_MOVE_PREVIOUSLINE:
     case CARET_MOVE_NEXTLINE:
            {
                if (RIGHT == iWherePointer)
                {
                    IFC( pDispCopyStart->MoveToPointer(
                            (CARET_MOVE_PREVIOUSLINE == inCaretMove) ? _pDispStartPointer : _pDispEndPointer
                                )
                       );
                }
                else
                {
                    IFC( pDispCopyStart->MoveToPointer(
                            (CARET_MOVE_NEXTLINE == inCaretMove) ? _pDispStartPointer : _pDispEndPointer
                                )
                       );
                }
                IFC( GetLocationForDisplayPointer( pDispCopyStart, &_ptCurMouseXY, TRUE) );
                break;
            }

     default:
            {
                IFC( pDispCopyStart->MoveToPointer( _pDispEndPointer ) );
                _ptCurMouseXY.x = CARET_XPOS_UNDEFINED;
                _ptCurMouseXY.y = CARET_YPOS_UNDEFINED;
            }
     }

    //
    // Adjust the pointer
    //
    switch( inCaretMove )
    {
        case CARET_MOVE_BACKWARD:
            IFC( pDispCopyStart->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
            goto Cleanup;

        case CARET_MOVE_FORWARD:
            IFC( pDispCopyStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            goto Cleanup; // we're done

        case CARET_MOVE_WORDBACKWARD:
        case CARET_MOVE_WORDFORWARD:
            if (IsAtWordBoundary(pDispCopyStart))
            {
                IFC( pDispCopyStart->SetDisplayGravity(
                        (inCaretMove == CARET_MOVE_WORDFORWARD) ? DISPLAY_GRAVITY_NextLine : DISPLAY_GRAVITY_PreviousLine) );
                goto Cleanup; // we're done
            }
            break;

        case CARET_MOVE_NEXTLINE:
            {
                //
                // Adjust pointer if it is located at the end of scope position
                //
                ED_PTR( epScan );
                DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor; // anchors are just phrase elements to me here
                DWORD dwFound  = BREAK_CONDITION_None;

                IFC( pDispCopyStart->PositionMarkupPointer(epScan) );
                IFC( epScan.Scan(LEFT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {
                    //
                    // Try to position the caret inside the closing scope
                    // If it fails, leave the caret positioned at the end of selection
                    //

                    hr = THR( pDispCopyStart->MoveToMarkupPointer(epScan, NULL) );

                    if( hr == CTL_E_INVALIDLINE )
                    {
                        hr = S_OK;
                    }

                }
            }

            break;

        default:
            //
            // boundary cases are excepted to return failure codes but don't move the pointer
            //
            break;
    }

    ptLoc = _ptCurMouseXY;
    if (inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE)
    {
        //
        // For up/down movement, we always want to use
        // either the virtual caret position saved for 
        // due to tracker transition from caret to 
        // selection if we have one. 
        //
        // Otherwise we want the "end of selection" position,
        // which is implied by MovePointer (it calls GetLocation
        // on select tracker which uses _pDispEndSelection)
        // so in this case we want to flush out ptLoc, pass in 
        // _undefined_ value to MovePointer. 
        // 
        // [zhenbinx]
        //
        SP_IHTMLCaret   spCaret;

        IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );
        IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
    }

    IGNORE_HR(MovePointer(inCaretMove, pDispCopyStart, &ptLoc));

    //
    // To be used by caret tracker
    //
    if (inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE)
    {
        IFC( pDispCopyStart->PositionMarkupPointer(spMarkup) );
        IFC( _ptVirtualCaret.UpdatePosition(spMarkup, ptLoc) );
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MovePointersToTrueStartAndEnd(
    IMarkupPointer* pTrueStart,
    IMarkupPointer* pTrueEnd,
    BOOL *pfSwap ,
    BOOL *pfEqual /*= NULL*/ )
{
    HRESULT hr = S_OK;
    int iWherePointer = SAME;
    BOOL fSwap = FALSE;

    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
    if ( iWherePointer == LEFT )
    {
        IFC( _pDispEndPointer->PositionMarkupPointer(pTrueStart) );
        IFC( _pDispStartPointer->PositionMarkupPointer(pTrueEnd) );
        fSwap = TRUE;
    }
    else
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(pTrueStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(pTrueEnd) );
    }
Cleanup:
    if ( pfSwap )
        *pfSwap = fSwap;
    if ( pfEqual )
        *pfEqual = ( iWherePointer == 0);

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsBetweenBlocks
//
// Synopsis: Look for the Selection being in the "magic place" at the end of a block.
//
//------------------------------------------------------------------------------------

//
// Ignore BR's !
//
BOOL
CSelectTracker::IsBetweenBlocks( IDisplayPointer* pDispPointer )
{
    HRESULT hr;
    BOOL    fBetween = FALSE;
    DWORD   dwBreakCondition = BREAK_CONDITION_Content;
    DWORD   dwFoundLeft;
    DWORD   dwFoundRight;

    ED_PTR( scanPointer );

    IFC( pDispPointer->PositionMarkupPointer(scanPointer) );
    IFC( scanPointer.Scan( LEFT, dwBreakCondition, &dwFoundLeft ));

    IFC( pDispPointer->PositionMarkupPointer(scanPointer) );
    IFC( scanPointer.Scan( RIGHT, dwBreakCondition, &dwFoundRight ) );

    if( (scanPointer.CheckFlag( dwFoundLeft, BREAK_CONDITION_EnterBlock ) &&
         scanPointer.CheckFlag( dwFoundRight, BREAK_CONDITION_EnterBlock ) ) )
    {
        fBetween = TRUE;
    }

Cleanup:
    return fBetween;
}


//+====================================================================================
//
// Method: IsAtEdgeOfTable
//
// Synopsis: Are we at the edge of the table ( ie. by scanning left/right do we hit a TD ?)
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAtEdgeOfTable( Direction iDirection, IMarkupPointer* pPointer )
{
    HRESULT hr;
    BOOL fAtEdge = FALSE;
    DWORD dwBreakCondition = 0;
    IHTMLElement* pIElement = NULL;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    ED_PTR( scanPointer );
    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.Scan( iDirection,
                           BREAK_CONDITION_Content - BREAK_CONDITION_Block ,
                           & dwBreakCondition,
                           & pIElement));

    if ( scanPointer.CheckFlag( dwBreakCondition,
                                BREAK_CONDITION_Site ) )
    {
        IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));

        if ( IsTablePart( eTag ) || eTag == TAGID_TABLE  )
        {
            fAtEdge = TRUE;
        }
    }

Cleanup:
    ReleaseInterface( pIElement );

    return fAtEdge;
}

//+====================================================================================
//
// Method: MoveSelection
//
// Synopsis: Adjust a Selection's start/end points based on the CaretMoveUnit ( used
//           for keyboard navigation in shift selection).
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::MoveSelection(  CARET_MOVE_UNIT inCaretMove )
{
    HRESULT             hr = S_OK;
    POINT               ptLoc;
    BOOL                fBetweenBlocks = FALSE;     // Was the shift ptr in between blocks before the move?
    BOOL                fBlockEmpty = FALSE;        // Is the block where shift ptr is at empty?
    SP_IMarkupPointer   spEndPointer;               // IMarkupPointer based shift ptr
    SP_ILineInfo        spLineInfo;
    CPoint              ptMouse;
    CBlockPointer       ptrBlock( GetEditor() );    // Block where shift ptr ended up


    //
    // Move end of selection
    //
    GetLocation(&ptLoc, TRUE);

    fBetweenBlocks = IsBetweenBlocks( _pDispShiftPointer );

    if ( FAILED( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc)) &&
        ( ! fBetweenBlocks  || inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE ) )
    {
        //
        // Ignore HR code here - we still want to constrain, adjust and update.
        //
        if (GetPointerDirection(inCaretMove) == RIGHT)
        {
            IGNORE_HR(MovePointer(CARET_MOVE_LINEEND, _pDispShiftPointer, &ptLoc));
        }
        else
        {
            IGNORE_HR(MovePointer(CARET_MOVE_LINESTART, _pDispShiftPointer, &ptLoc));
        }
    }

    //
    // Before we call AdjustSelection, we should try and do major adjustments here.
    //
    // A major adjustment includes selecting additional words or characters during
    // a single selection move.
    //
    // For example, If we were between blocks and we tried to move forward, then
    // we need to call MovePointer() again to select the first character in the next block.
    //
    // Likewise, if we were moving forwards or backwards by one character or
    // on word, and we ended up on a table boundary with content in that
    // boundary, we need to select the content.  This fixes VID issues like
    // bug 71907.
    //
    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
    IFC( _pDispShiftPointer->PositionMarkupPointer(spEndPointer) );

    if( inCaretMove == CARET_MOVE_FORWARD     || inCaretMove == CARET_MOVE_BACKWARD ||
        inCaretMove == CARET_MOVE_WORDFORWARD || inCaretMove == CARET_MOVE_WORDBACKWARD )
    {
        IFC( ptrBlock.MoveTo( spEndPointer, GetPointerDirection(inCaretMove) ) );
        IFC( ptrBlock.IsEmpty( &fBlockEmpty ) );

        if( ( IsAtEdgeOfTable( Reverse( GetPointerDirection(inCaretMove)), spEndPointer) &&
              !fBlockEmpty ) )
        {
            IFC( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc));
        }
    }

    //
    // Constrain and scroll
    //
    IFC( _pDispEndPointer->MoveToPointer( _pDispShiftPointer ) );
    IFC( ConstrainSelection() );
    SetLastCaretMove( inCaretMove );
    IFC( AdjustSelection(NULL));
    IFC( _pDispEndPointer->ScrollIntoView() );

    //
    // Update _curMouseX/Y
    //
    if (CARET_XPOS_UNDEFINED == ptLoc.x || CARET_XPOS_UNDEFINED == ptLoc.y)
    {
        //
        //  ??? I don't know why it needs to be FALSE
        //  but it is the only way for the program to
        //  pass DRT  (Zhenbinx)
        //
        GetLocation(&_ptCurMouseXY, FALSE);
    }

    //
    // Update segment list
    //
    IFC( UpdateSelectionSegments() );

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: MoveEndToPointer
//
// Synopsis: Wrapper To MoveToPointer. Allowing better debugging validation.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::MoveEndToPointer( IDisplayPointer* pDispPointer, BOOL fInSelection /*=FALSE*/ )
{
    HRESULT hr = S_OK;

#if DBG == 1
    int oldEndCp = 0;
    int startCp = 0;
    int endCp = 0;

    if ( IsTagEnabled( tagSelectionValidate ))
    {
        oldEndCp = GetCp( _pDispEndPointer );
        startCp = GetCp( _pDispStartPointer );
    }
    endCp = GetCp( pDispPointer );

#endif

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, pDispPointer) );

    hr = THR ( _pDispEndPointer->MoveToPointer( pDispPointer ));

    if (fInSelection)
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope(_pDispEndPointer, &spElement) );
        if (_pManager->CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spPointer;
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtStartOfElement = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );

            IFC( spTestPointer->MoveAdjacentToElement( spElement,
                                                GetMoveDirection() ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd) );

            IFC( spTestPointer->IsEqualTo(spPointer, &fAtStartOfElement) );

            if (!fAtStartOfElement)
            {
                IFC( spPointer->MoveAdjacentToElement( spElement,
                                                    GetMoveDirection() ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
            }
        }
    }

#if DBG == 1
    if ( IsTagEnabled( tagSelectionValidate))
    {
        endCp = GetCp( _pDispEndPointer );
        if ( endCp != 0 &&
             oldEndCp != -1 &&
            ( endCp - startCp == 0 ) &&
            ( oldEndCp - startCp != 0 ) )
        {
            DumpTree(_pDispEndPointer);
            AssertSz(0,"Selection jumpted to zero");
        }
    }
#endif

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::MoveEndToMarkupPointer( IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext, BOOL fInSelection /*=FALSE*/)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pPointer, pDispLineContext) );
    IFC( MoveEndToPointer(spDispPointer, fInSelection) );

Cleanup:
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: MoveEndToPointer
//
// Synopsis: Wrapper To MoveToPointer. Allowing better debugging validation.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::MoveStartToPointer( IDisplayPointer* pDispPointer, BOOL fInSelection /*=FALSE*/ )
{
    HRESULT hr = S_OK;

#if DBG==1
    int oldStartCp = 0;
    int startCp = 0;

    oldStartCp = GetCp( _pDispStartPointer );
    startCp = GetCp( pDispPointer );
#endif

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, pDispPointer) );

    hr = THR ( _pDispStartPointer->MoveToPointer( pDispPointer ));

    if (fInSelection)
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope(_pDispStartPointer, &spElement) );
        if (_pManager->CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spPointer;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( spPointer->MoveAdjacentToElement( spElement,
                                                GetMoveDirection() ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
            IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
    }

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::MoveStartToMarkupPointer( IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext, BOOL fInSelection /*=FALSE*/)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pPointer, pDispLineContext) );
    IFC( MoveStartToPointer(spDispPointer, fInSelection) );

Cleanup:
    RRETURN ( hr );
}


VOID
CSelectTracker::BecomePassive(BOOL fPositionCaret )
{
    SetState( ST_PASSIVE );

    if ( _pManager->IsInTimer() )
        StopTimer();
    if (  _pManager->IsInCapture()  )
        ReleaseCapture();

    if ( _fInSelTimer )
    {
        StopSelTimer();
        Assert( ! _fInSelTimer );
    }

    if ( ! _pManager->IsInFireOnSelectStart() && !CheckSelectionWasReallyMade() )
    {
        if ( fPositionCaret )
        {
            _pManager->PositionCaret( _pDispStartPointer );
        }
    }
}


//+====================================================================================
//
// Method: ScrollMessageIntoView.
//
// Synopsis: Wrapper to ScrollPointIntoView
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScrollMessageIntoView(
            CEditEvent* pEvent,
            BOOL fScrollSelectAnchorElement /*=FALSE*/)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    WHEN_DBG( _ctScrollMessageIntoView++);
    POINT pt;
    IFC( pEvent->GetPoint( & pt ));
    RECT rect;

    rect.left = pt.x - scrollSize;
    rect.right = pt.x + scrollSize;
    rect.top = pt.y - scrollSize;
    rect.bottom = pt.y + scrollSize;

    spElement = (fScrollSelectAnchorElement && _pIScrollingAnchorElement) ? _pIScrollingAnchorElement : _pManager->GetEditableElement();

    // Can't pass a null element to ScrollRectIntoView, so make sure we have one first.
    if (spElement)
    {
        IFC( GetDisplayServices()->ScrollRectIntoView(spElement , rect) );
    }

Cleanup:
    RRETURN ( hr );

}

//+====================================================================================
//
// Method: GetStartSelectionForSpringLoader
//
// Synopsis: Seek out Font Tags to fall into for the spring loader.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::GetStartSelectionForSpringLoader( IMarkupPointer* pPointerStart)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE eRightContext = CONTEXT_TYPE_None;
    BOOL fHitText = FALSE;
    SP_IMarkupPointer spBoundary;
    BOOL fFurtherInStory = GetMoveDirection();

    IFC( GetEditor()->CreateMarkupPointer(&spBoundary) );

    if ( fFurtherInStory )
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(pPointerStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(spBoundary) );
    }
    else
    {
        IFC( _pDispEndPointer->PositionMarkupPointer(pPointerStart) );
        IFC( _pDispStartPointer->PositionMarkupPointer(spBoundary) );
    }
    IFC( pPointerStart->Right( FALSE, & eRightContext, NULL, NULL, NULL));

    //
    // Don't do anything if we're already in Text
    //
    if ( eRightContext != CONTEXT_TYPE_Text )
    {
        IFC( MovePointerToText(
                    GetEditor(),
                    pPointerStart,
                    RIGHT,
                    spBoundary,
                    &fHitText,
                    FALSE ) );
    }
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsAdjacentToBlock
//
// Synopsis: Scan in a given direction - looking for a block.
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAdjacentToBlock(
                    IMarkupPointer* pPointer,
                    Direction iDirection,
                    DWORD* pdwBreakCondition)
{
    BOOL fHasBlock = FALSE ;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    HRESULT hr;
    ED_PTR( pEditPointer );
    DWORD dwBreakCondition = 0;

    Assert( iDirection == LEFT || iDirection == RIGHT );

    if ( iDirection == LEFT )
    {
        IFC( pPointer->Left( FALSE, &eContext, NULL, NULL, NULL ));
    }
    else
    {
        IFC( pPointer->Right( FALSE, &eContext, NULL, NULL, NULL ));
    }
    if ( eContext == CONTEXT_TYPE_Text )
        goto Cleanup;

    IFC( pEditPointer.MoveToPointer( pPointer ));
    if ( iDirection == LEFT )
    {
        IFC( pEditPointer.SetBoundary( _pManager->GetStartEditContext() , pPointer  ));
    }
    else
    {
        IFC( pEditPointer.SetBoundary( pPointer, _pManager->GetEndEditContext() ));
    }

    //
    // Scan for the End of the Boundary
    //
    IGNORE_HR( pEditPointer.Scan(
                                 iDirection ,
                                 BREAK_CONDITION_Text           |
                                 BREAK_CONDITION_NoScopeSite    |
                                 BREAK_CONDITION_NoScopeBlock   |
                                 BREAK_CONDITION_Site           |
                                 BREAK_CONDITION_Block          |
                                 BREAK_CONDITION_BlockPhrase    |
                                 BREAK_CONDITION_Phrase         |
                                 BREAK_CONDITION_Anchor         |
                                 BREAK_CONDITION_Control ,
                                 & dwBreakCondition,
                                 NULL,
                                 NULL,
                                 NULL ));

    if ( pEditPointer.CheckFlag( dwBreakCondition,  BREAK_CONDITION_Block |
                                                    BREAK_CONDITION_Site |
                                                    BREAK_CONDITION_Control |
                                                    BREAK_CONDITION_NoScopeBlock ) )
    {
        fHasBlock = TRUE;
    }

Cleanup:
    if ( pdwBreakCondition )
        *pdwBreakCondition = dwBreakCondition;

    return fHasBlock;
}




//+====================================================================================
//
// Method: IsAtWordBoundary
//
// Synopsis: Check to see if we're already at the start of a word boundary
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAtWordBoundary(
                IMarkupPointer* pPointer,
                BOOL * pfAtStart, /*= NULL */
                BOOL *pfAtEnd /*= NULL */,
                BOOL fAlwaysTestIfAtEnd /* = FALSE*/ )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartTest;
    SP_IMarkupPointer2  spPointer2;   
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                fAtStart = FALSE;
    BOOL                fAtEnd = FALSE;
    BOOL                fAtWordBreak;
    BOOL                fAtEditWordBreak = FALSE;
    MARKUP_CONTEXT_TYPE pContext;
    //
    // Quick word boundary test (perf optimization)
    // If pointer is in an Anchor, do not call is at word break
    // because we consider Anchors word breaks.
    //

    IFC( pPointer->CurrentScope( &spElement ) );
    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
    if ( tagId != TAGID_A )
    {
        //
        // IE Bug #28647 (mharper) need to also test for the case
        // where the pointer is immediately before the anchor.
        //
        // IE Bug #28830 (mharper) added check to see if we are entering scope
        // on a <SELECT> as well due to a problem where ClassifyNodePos() believes
        // that a select is NODECLASS_NONE.  It would be better to fix that, but
        // that would be too fundamental a change this late (RC1)
        //
        
        IFC( pPointer->Right(FALSE, &pContext, &spElement, NULL, NULL) );
        if ( pContext == CONTEXT_TYPE_EnterScope )
        {
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if( tagId == TAGID_A || tagId == TAGID_SELECT )
            {
                fAtEditWordBreak = TRUE;
            }
        }

        if( !fAtEditWordBreak )
        {
            IFC( pPointer->Left(FALSE, &pContext, &spElement, NULL, NULL) );
            if ( pContext == CONTEXT_TYPE_EnterScope )
            {
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId));
                if( tagId == TAGID_SELECT )
                {
                    fAtEditWordBreak = TRUE;
                }
            }
        }

        if ( !fAtEditWordBreak )
        {

            IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
        
            IFC( spPointer2->IsAtWordBreak(&fAtWordBreak) );
            if (!fAtWordBreak)
                goto Cleanup;

        }

    }
    
    //
    // Check to see if we're at a word boundary
    //
    
    IFC( GetEditor()->CreateMarkupPointer(& spStartTest ));
    IFC( spStartTest->MoveToPointer( pPointer ));


    //
    // Start of Word Case
    //

    //
    // We don't call MoveWord here - as we really want to go to NextWordEnd.
    //

    IFC( MoveWord( spStartTest, MOVEUNIT_NEXTWORDBEGIN ));
    IFC( MoveWord( spStartTest, MOVEUNIT_PREVWORDBEGIN ));
    IFC( spStartTest->IsEqualTo( pPointer, & fAtStart ));

    //
    // End of Word case
    //
    if ( !fAtStart || fAlwaysTestIfAtEnd )
    {
        IFC( spStartTest->MoveToPointer( pPointer ));
        IFC( MoveWord( spStartTest, MOVEUNIT_PREVWORDBEGIN ));
        IFC( MoveWord( spStartTest, MOVEUNIT_NEXTWORDBEGIN ));
        IFC( spStartTest->IsEqualTo( pPointer, & fAtEnd ));
    }


Cleanup:
    AssertSz(!FAILED(hr), "Failure in IsAtWordBoundary");

    if ( pfAtStart )
        *pfAtStart = fAtStart;
    if ( pfAtEnd )
        *pfAtEnd = fAtEnd;

    return ( fAtStart || fAtEnd );
}



HRESULT
CSelectTracker::ScanForLastExitBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            BOOL *pfFoundBlock /* = NULL */  )
{
    RRETURN( ScanForLastEnterOrExitBlock( iDirection,
                                          pPointer,
                                          BREAK_CONDITION_ExitBlock | BREAK_CONDITION_NoScopeBlock,
                                          pfFoundBlock ));
}

//+====================================================================================
//
// Method: IsAtWordBoundary
//
// Synopsis: Check to see if we're already at the start of a word boundary
//
//------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsAtWordBoundary( IDisplayPointer* pDispPointer, BOOL * pfAtStart, BOOL* pfAtEnd, BOOL fAlwaysTestIfAtEnd)
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    return IsAtWordBoundary(spPointer, pfAtStart, pfAtEnd, fAlwaysTestIfAtEnd);

Cleanup:
    return FALSE;
}

HRESULT
CSelectTracker::ScanForLastEnterBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            BOOL* pfFoundBlock  )
{
    RRETURN( ScanForLastEnterOrExitBlock( iDirection,
                                          pPointer,
                                          BREAK_CONDITION_EnterBlock | BREAK_CONDITION_NoScopeBlock,
                                          pfFoundBlock ));
}

//+====================================================================================
//
// Method: ScanForLastEnterOrExitBlock
//
// Synopsis: While you have ExitBlock - keep scanning. Return the markup pointer after the last
//           exit block.
//
//           Although this routine has a very big similarity to ScanForEnterBlock - I have
//           split it into two routines as it's less error prone.
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScanForLastEnterOrExitBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            DWORD dwTerminateCondition ,
            BOOL *pfFoundBlock /*=NULL*/ )
{
    HRESULT hr = S_OK;
    BOOL fFoundBlock = FALSE;
    ED_PTR( scanPointer);
    ED_PTR( beforeScanPointer );

    DWORD dwBreakCondition = 0;

    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));
    IFC( beforeScanPointer.MoveToPointer( scanPointer ));

    IFC( scanPointer.Scan( iDirection,
                      BREAK_CONDITION_Content ,
                      & dwBreakCondition ));

    while ( scanPointer.CheckFlag( dwBreakCondition, dwTerminateCondition ))
    {
        fFoundBlock = TRUE;

        IFC( beforeScanPointer.MoveToPointer( scanPointer ));

        IFC( scanPointer.Scan( iDirection,
                          BREAK_CONDITION_Content ,
                          & dwBreakCondition ));
    }

    if ( ! scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary)  )
    {
        //
        // Go back to where you were.
        //
        IFC( scanPointer.MoveToPointer( beforeScanPointer ));
    }

    IFC( pPointer->MoveToPointer( scanPointer ));

Cleanup:
    if ( pfFoundBlock )
        *pfFoundBlock = fFoundBlock ;

    RRETURN( hr );
}


//+====================================================================================
//
// Method: ScanForLayout
//
// Synopsis: Scan in the given direction - for a given layout
//
//           We try to scan until we are inside a given layout.
//           We break on BlockEnter or Text (anything that's not BLOCK_Enter or ExitSite).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScanForLayout(
                    Direction iDirection,
                    IMarkupPointer* pPointer,
                    IHTMLElement* pILayoutElement,
                    BOOL* pfFoundLayout /*=NULL*/,
                    IHTMLElement** ppILayoutElementEnd /* = NULL */ )
{
    HRESULT         hr = S_OK;
    BOOL            fFoundLayout = FALSE;
    SP_IHTMLElement spCurElement;
    DWORD           dwBreakCondition = 0;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

    ED_PTR( scanPointer);

    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));

    //
    // Scan for layout sites.  We don't want to treat tables as layouts in this scan if we
    // are doing a ScanForLayout() as a result of a shift selection.
    //
    IFC( scanPointer.Scan(  iDirection,
                            BREAK_CONDITION_Content - BREAK_CONDITION_ExitSite - BREAK_CONDITION_ExitBlock,
                            &dwBreakCondition,
                            &spCurElement ) );

    if( spCurElement )
    {
        IFC( GetMarkupServices()->GetElementTagId( spCurElement, &eTag ) );
    }

    if ( scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_EnterSite ) &&
         spCurElement &&
         SameElements( spCurElement, pILayoutElement ) &&
         (!IsTablePart( eTag ) || !_fShift) )
    {
        fFoundLayout = TRUE;
    }

    if( ( fFoundLayout ||  scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_EnterSite ) ) &&
        (!IsTablePart(eTag) || !_fShift) )
    {
        IFC( pPointer->MoveToPointer( scanPointer ));
    }

Cleanup:
    if ( fFoundLayout )
    {
        ReplaceInterface( ppILayoutElementEnd, (IHTMLElement *)spCurElement );
    }

    *pfFoundLayout= fFoundLayout ;

    RRETURN( hr );
}




//+====================================================================================
//
// Method: GetMoveDirection
//
// Synopsis: Get the direction in which selection is occuring.
//
//  Return True - if we're selecting further in the story (From L to R in a LTR layout).
//         False - if we're selecting earlier in the story ( From R to L in a LTR layout).
//
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::GetMoveDirection()
{
    BOOL fFurtherInStory = FALSE;
    int wherePointer = SAME;
    HRESULT hr = S_OK;

    hr = THR ( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & wherePointer));
    if (( wherePointer == SAME ) || ( hr == E_INVALIDARG ))
    {
        //
        // TODO does this break under RTL ?
        //
        POINT ptGuess;
        ptGuess.x = _ptCurMouseXY.x;
        ptGuess.y = _ptCurMouseXY.y;
        fFurtherInStory = GuessDirection( & ptGuess );
    }
    else
        fFurtherInStory = ( wherePointer == RIGHT ) ? TRUE : FALSE;

    return fFurtherInStory;
}



//+====================================================================================
//
// Method: GetDirection
//
// Synopsis: our _pDispTestPointer is equal to our previous test. So we use the Point
//           to guess the direction. The "guess" is actually ok once there is some delta
//           from _anchorMouseX and _anchorMouseY
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::GuessDirection(POINT* ppt)
{
    if ( ppt && ppt->x != _anchorMouseX )
    {
        return ppt->x >= _anchorMouseX ;    // did we go past _anchorMouseX ?
    }
    else if ( ppt && ppt->y != _anchorMouseX)
    {
        return ppt->y >= _anchorMouseY;  // did we go past _anchorMouseY ?
    }
    else if (_lastCaretMove != CARET_MOVE_NONE)
    {
        return (GetPointerDirection(_lastCaretMove) == RIGHT);
    }

    return TRUE ; // we're really and truly in the same place. Default to TRUE.

}




//+==========================================================================================
//
//  Method: IsValidMove
//
// Synopsis: Check the Mouse has moved by at least _sizeDragMin - to be considered a "valid move"
//
//----------------------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsValidMove ( const POINT*  ppt )
{
    return ((abs(ppt->x - _anchorMouseX ) > GetMinDragSizeX() ) ||
        (abs( ppt->y - _anchorMouseY) > GetMinDragSizeY() )) ;

}


//+====================================================================================
//
// Method: VeriyOkToStartSelection
//
// Synopsis: Verify that it is ok to start the selection now. If not we will Assert
//
//          The Selection manager should have inially called ShouldBeginSelection
//          before starting a given tracker. This method checks that this is so.
//
//------------------------------------------------------------------------------------

#if DBG == 1

VOID
CSelectTracker::VerifyOkToStartSelection( CEditEvent* pEvent )
{

    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    IHTMLElement* pElement = NULL;
    SST_RESULT eResult = SST_NO_CHANGE;

    if ( _fState == ST_WAIT2 ) // it is always ok to start a selection in the middle of a selection
    {
        //
        // Examine the Context of the thing we started dragging in.
        //


        IFC( pEvent->GetElementAndTagId( & pElement, & eTag ));

        ShouldStartTracker( pEvent, eTag , pElement, &eResult);
        Assert( eResult == SST_NO_CHANGE || eResult == SST_CHANGE || eResult == SST_NO_BUBBLE );
    }
Cleanup:

    ReleaseInterface( pElement );

}

#endif

//+====================================================================================
//
// Method: ClearSelection
//
// Synopsis: Clear the current IHighlightRenderingServices
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ClearSelection()
{
    HRESULT         hr = S_OK;

    if ( _pManager && _pISegment )
    {
        IFC( GetSelectionServices()->RemoveSegment( _pISegment ) );
        ClearInterface( & _pISegment );
    }
    if( _pIRenderSegment && GetHighlightServices() )
    {
        IFC( GetHighlightServices()->RemoveSegment( _pIRenderSegment ) );
        ClearInterface( &_pIRenderSegment );
    }


Cleanup:

    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: CheckSelectionWasReallyMade
//
// Synopsis: Verify that a Selection Was really made, ie start and End aren't in same point
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::CheckSelectionWasReallyMade()
{
    BOOL fEqual = TRUE;

    IGNORE_HR( _pDispStartPointer->IsEqualTo(_pDispEndPointer, &fEqual) );

    return !fEqual;
}

//+====================================================================================
//
// Method:  Is Jumpover AtBrowse
// Synopsis: If we start a selection outside one of these
//              Do we want to Jump Over this tag at browse time ?
//
//
// Note that this is almost the same as IsSiteSelectable EXCEPT for Marquee
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::IsJumpOverAtBrowse( IHTMLElement* pIElement, ELEMENT_TAG_ID eTag )
{
    switch ( eTag )
    {

        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_OBJECT:
        case TAGID_TEXTAREA:
        case TAGID_IMG:
        case TAGID_APPLET:
        case TAGID_SELECT:
        case TAGID_HR:
        case TAGID_OPTION:
        case TAGID_IFRAME:
        case TAGID_LEGEND:

            return TRUE;

        default:
            return FALSE;
    }
}

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

void
CSelectTracker::StateToString(TCHAR* pAryMsg, SELECT_STATES inState )
{
    switch ( inState )
    {
    case ST_START:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_START"));
        break;

    case ST_WAIT1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT1"));
        break;

    case ST_DRAGOP:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DRAGOP"));
        break;

    case ST_MAYDRAG:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYDRAG"));
        break;

    case ST_WAITBTNDOWN1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITBTNDOWN1"));
        break;

    case ST_WAIT2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT2"));
        break;

    case ST_DOSELECTION:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DOSELECTION"));
        break;

    case ST_WAITBTNDOWN2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITBTNDOWN2"));
        break;

    case ST_WAITCLICK:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITCLICK"));
        break;

    case ST_SELECTEDWORD:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_SELECTEDWORD"));
        break;

    case ST_SELECTEDPARA:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_SELECTEDPARA"));
        break;

    case ST_WAIT3RDBTNDOWN:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT3RDBTNDOWN"));
        break;

    case ST_MAYSELECT1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYSELECT1"));
        break;

    case ST_MAYSELECT2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYSELECT2"));
        break;

    case ST_STOP :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_STOP"));
        break;

    case ST_PASSIVE :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_PASSIVE"));
        break;

    case ST_DORMANT :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DORMANT"));
        break;

    default:
        AssertSz(0,"Unknown State");
    }
}


void
CSelectTracker::ActionToString(TCHAR* pAryMsg, ACTIONS inState )
{
    switch ( inState )
    {

    case A_UNK:
        edWsprintf( pAryMsg , _T("%s"), _T("A_UNK"));
        break;

    case A_ERR:
        edWsprintf( pAryMsg , _T("%s"), _T("A_ERR"));
        break;

    case A_DIS:
        edWsprintf( pAryMsg , _T("%s"), _T("A_DIS"));
        break;

    case A_IGN:
        edWsprintf( pAryMsg , _T("%s"), _T("A_IGN"));
        break;

    case A_1_2:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_2"));
        break;

    case A_1_4:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_4"));
        break;

    case A_1_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_14"));
        break;

    case A_2_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_2_14"));
        break;

    case A_2_14r:
        edWsprintf( pAryMsg , _T("%s"), _T("A_2_14r"));
        break;

    case A_3_2:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_2"));
        break;

    case A_3_2m:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_2m"));
        break;

    case A_3_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_14"));
        break;

    case A_4_8:
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_8"));
        break;

    case A_4_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_14"));
        break;

    case A_4_14m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_14m"));
        break;

    case A_5_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_6"));
        break;
    case A_6_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_6"));
        break;
    case A_6_6m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_6m"));
        break;
    case A_6_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_14"));
        break;

    case A_7_7 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_7"));
        break;

    case A_7_8 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_8"));
        break;

    case A_16_8 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_8"));
        break;

    case A_7_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_14"));
        break;

    case A_8_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_6"));
        break;
    case A_8_10 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_10"));
        break;
    case A_9_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_6"));
        break;
    case A_9_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_14"));
        break;
    case A_10_9 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_9"));
        break;
    case A_10_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_14"));
        break;
    case A_10_14m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_14m"));
        break;
    case A_11_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_11_6"));
        break;
    case A_11_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_11_14"));
        break;
    case A_12_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_6"));
        break;
    case A_12_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_14"));
        break;

    case A_1_15:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_15"));
        break;
    case A_4_15:
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_15"));
        break;

    case A_3_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_15"));
        break;

    case A_5_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_15"));
        break;

    case A_7_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_15"));
        break;

    case A_8_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_15"));
        break;

    case A_9_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_15"));
        break;

    case A_10_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_15"));
        break;

    case A_12_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_15"));
        break;

    case A_5_16 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_16"));
        break;

    case A_16_7 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_7"));
        break;

    case A_16_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_15"));
        break;

    default:
        AssertSz(0,"Unknown State");
    }
}

void
CSelectTracker::DumpSelectState(
                        CEditEvent* pEvent ,
                        ACTIONS inAction,
                        BOOL fInTimer /*=FALSE*/ )
{
    TCHAR sSelectState[20];
    CHAR sMessageType[50];
    TCHAR sAction[20];
    CHAR        achBuf[4096];

    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //

    StateToString( sSelectState, _fState );
    if ( pEvent )
    {
        pEvent->toString( sMessageType );
    }

    if ( ! fInTimer )
        ActionToString( sAction, inAction);

    if ( ! fInTimer )
    {
        wsprintfA(
            achBuf,
            "Tracker State: %ls Action:%ls Event:%s ",
            sSelectState,sAction, sMessageType);
    }
    else
    {
        wsprintfA(
            achBuf,
            "\n. Tracker State: %ls ",
            sSelectState,sAction );
    }

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");
}

#endif


HRESULT
CSelectTracker::StartTimer()
{
    HRESULT hr = S_OK;
    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pManager->GetActiveTracker() == this )
    {
        Assert( ! _pManager->IsInTimer() );
        TraceTag(( tagSelectionTrackerState, "Starting Timer"));
        hr = THR(GetEditor()->StartDblClickTimer());
#if DBG==1  /* Keeps PREfix happy */
        if ( hr )
            AssertSz(0, "Error starting timer");
#endif
        if (!hr)
        {
            _pManager->SetInTimer( TRUE);
        }
    }
    
    RRETURN( hr );
}

HRESULT
CSelectTracker::StopTimer()
{
    HRESULT hr = S_OK;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pManager->GetActiveTracker() == this )
    {
        Assert( _pManager->IsInTimer() );

        TraceTag(( tagSelectionTrackerState, "Stopping Timer"));

        IFC(GetEditor()->StopDblClickTimer());

        //
        // If a Fire On Select Start failed - it is valid for the timer to fail
        // the Doc may have unloaded.
        //
#if DBG == 1
        if ( ! _pManager->IsFailFireOnSelectStart() )
        {
            AssertSz( hr == S_OK || hr == S_FALSE  , "Error stopping timer");
        }
#endif
        _pManager->SetInTimer( FALSE );
    }

Cleanup:
    RRETURN( hr );
}

BOOL
CSelectTracker::EndPointsInSameFlowLayout()
{
    return GetEditor()->PointersInSameFlowLayout( _pDispStartPointer, _pDispEndPointer, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   An element is leaving the tree.  We may have to nix our selection
//              if the element encompasses the entire selection.
//
//-------------------------------------------------------------------- --------
HRESULT
CSelectTracker::OnExitTree(
                            IMarkupPointer* pIStart,
                            IMarkupPointer* pIEnd ,
                            IMarkupPointer* pIContentStart,
                            IMarkupPointer* pIContentEnd )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    CEditPointer            startPointer( GetEditor() );
    CEditPointer            endPointer( GetEditor())  ;
    SP_IDisplayPointer      spDispPointer;
    BOOL fPositioned, fPositionedEnd;

    // Retrieve the segment list

    if( _pISegment != NULL )
    {
        //
        // We only get called - if our segment contained the element leaving the tree
        //
        //
        // A layout is leaving the tree. Does this completely contain selection ?
        //
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer2 ));

        hr = _pISegment->GetPointers(startPointer, endPointer );
        if (hr == E_INVALIDARG)
        {
           //
           // Review-2000/07/26-zhenbinx: we should fix this in Blackcomb. 
           //
           // TODO:  (chandras): possible case is pointers are wacked from tree. 
           //                    gracefully exit as the code below makes no sense 
           //                    when the pointers are not valid. Code in Segment.cxx 
           //                    needs to be well-written to handle these cases
           hr = S_OK;
           goto Cleanup;
        }
        
        IFC( pIContentStart->IsPositioned( & fPositioned ));
        IFC( pIContentEnd->IsPositioned( & fPositionedEnd ));

        if ( fPositioned && fPositionedEnd )
        {
            IFC( spPointer->MoveToPointer( pIContentStart ));
            IFC( spPointer2->MoveToPointer( pIContentEnd ));
        }
        else
        {
            IFC( spPointer->MoveToPointer( pIStart ));
            IFC( spPointer2->MoveToPointer( pIEnd ));
        }

        if ( startPointer.Between( spPointer, spPointer2) &&
             endPointer.Between( spPointer, spPointer2))
        {
            SP_IDisplayPointer spDispPointer;
            SP_IHTMLElement spElement;
            SP_IHTMLElement spNewElement;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

            hr = THR( spDispPointer->MoveToMarkupPointer( pIEnd , NULL) );
            if (hr != CTL_E_INVALIDLINE)
            {
                IFC(hr);
            }
            else
            {
                IFC( pIEnd->CurrentScope( & spElement ));

                while ( spElement != NULL)
                {
                    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                    if (hr != CTL_E_INVALIDLINE)
                    {
                        IFC(hr);
                        break;
                    }

                    IFC( GetEditor()->GetParentElement(spElement, &spNewElement) );
                    spElement = spNewElement;
                }
            }

            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            hr = THR( _pManager->SetCurrentTracker( TRACKER_TYPE_Caret, spDispPointer, spDispPointer ) );
            Assert( IsDormant());
        }
    }

Cleanup:

    RRETURN ( hr );
}

HRESULT
CSelectTracker::EmptySelection( BOOL fChangeTrackerAndSetRange /*=TRUE*/)
{
    HRESULT         hr = S_OK;

    if( _pISegment )
    {
        IFC( GetSelectionServices()->RemoveSegment( _pISegment) );
        IFC( GetHighlightServices()->RemoveSegment( _pIRenderSegment ));

        ClearInterface( & _pISegment );
        ClearInterface( & _pIRenderSegment );
    }

    if ( ! fChangeTrackerAndSetRange )
    {
        IFC( _pManager->EnsureDefaultTrackerPassive());
    }

Cleanup:
    RRETURN ( hr );

}

//+====================================================================================
//
// Method:  DeleteSelection
//
// Synopsis: Do the deletion of the Selection by firing IDM_DELETE
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DeleteSelection(BOOL fAdjustPointersBeforeDeletion )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    CEdUndoHelper       undoUnit(GetEditor());

    //
    // Do the prep work.  Check to see if we have a segment.  It is possible
    // for an external host to get into DeleteSelection() without there
    // actually being a selection on the screen, yet the select tracker
    // is active.  See IE bug 98881 for more details.
    //
    if( _pISegment )
    {
        IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
        IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

        IFC( undoUnit.Begin( IDS_EDUNDOTEXTDELETE) );

        //
        // Delete our segment
        //
        IFC( _pISegment->GetPointers( spStart, spEnd) );

        //
        // Cannot delete or cut unless the range is in the same flow layout
        //
        if ( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            IFC( GetEditor()->Delete( spStart, spEnd, fAdjustPointersBeforeDeletion ));
        }


        IFC( _pManager->EmptySelection());
    }

Cleanup:

    RRETURN( hr );
}

//+===================================================================================
// Method:  IsMessageInSelection
//
// Synopsis: Check to see if the given message is in the current selection segment
//
//------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsMessageInSelection( CEditEvent* pEvent )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointerMsg;               // Display pointer where event occured
    SP_IMarkupPointer   spPointerStartSel;              // Start of selection
    SP_IMarkupPointer   spPointerEndSel;                // End of selection
    POINT               ptContent;                      // Point transformed to content coords
    POINT               pt;                             // Point where event occured
    BOOL                fIsInSelection = FALSE;
    int                 wherePointer = SAME;            // For comparing pointers
    BOOL                fEqual = FALSE;
    SP_IMarkupContainer spIContainer1;                  // Container of event
    SP_IMarkupContainer spIContainer2;                  // Container of start of selection
    SP_IMarkupPointer   spPointerMsg;                   // Markup pointer where event occured
    LONG                lXPosition;                     // Width of element where event occured
    SP_ILineInfo        spLineInfo;
    SP_IHTMLElement     spEventElement;                 // Event element

    //
    // Get the point, and the element where the event occured
    //
    IFC( pEvent->GetPoint( & pt ));
    IFC( pEvent->GetElement( &spEventElement ) );

    if ( _pISegment )
    {
        //
        // Create the pointers we need, and position them around selection
        //
        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointerMsg ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerStartSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerEndSel));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerMsg) );

        IFC( _pISegment->GetPointers(spPointerStartSel, spPointerEndSel ) );
        IFC( spPointerStartSel->IsEqualTo( spPointerEndSel, &fEqual ));

        if ( ! fEqual )
        {
            IFC( pEvent->MoveDisplayPointerToEvent( spDispPointerMsg ,
                                                    _pManager->IsInEditableClientRect( pt) == S_OK ?
                                                                        NULL :
                                                                        GetEditableElement() ) );

            //
            // See if we're in different containers. If we are - we adjust.
            //
            IFC( GetEditor()->CreateMarkupPointer(&spPointerMsg) );
            IFC( spDispPointerMsg->PositionMarkupPointer(spPointerMsg) );
            IFC( spPointerMsg->GetContainer( &spIContainer1 ));
            IFC( spPointerStartSel->GetContainer( &spIContainer2 ));
            if ( !EqualContainers( spIContainer1, spIContainer2))
            {
                //
                // IFC is ok - if we can't be adjusted into the same containers , we will
                // return S_FALSE - and we will bail.
                //
                IFC( GetEditor()->MovePointersToEqualContainers( spPointerMsg, spPointerStartSel ));
            }

            IFC( spDispPointerMsg->PositionMarkupPointer(spPointerMsg) );
            IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );

            IFC( OldCompare( spPointerStartSel, spPointerMsg, & wherePointer));

            if ( wherePointer == LEFT )
                goto Cleanup;

            else if ( wherePointer == SAME )
            {
                //
                // Verify we are truly to the left of the point. As at EOL/BOL the fRightOfCp
                // test above may be insufficient
                //
                IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_x(&lXPosition) );
                IFC( pEvent->GetPoint( & ptContent ));
                IFC( GetDisplayServices()->TransformPoint(  &ptContent,
                                                            COORD_SYSTEM_GLOBAL,
                                                            COORD_SYSTEM_CONTENT,
                                                            spEventElement) );
                if ( lXPosition > ptContent.x )
                    goto Cleanup;

            }

            IFC( OldCompare( spPointerEndSel, spPointerMsg, & wherePointer ));

            if ( wherePointer == RIGHT )
                goto Cleanup;

            else if ( wherePointer == SAME )
            {
                //
                // Verify we are truly to the right of the point. As at EOL/BOL the fRightOfCp
                // test above may be insufficient
                //

                IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_x(&lXPosition) );

                IFC( pEvent->GetPoint( & ptContent ));
                IFC( GetDisplayServices()->TransformPoint( & ptContent,
                                                        COORD_SYSTEM_GLOBAL,
                                                        COORD_SYSTEM_CONTENT,
                                                        spEventElement ));

                if ( lXPosition < ptContent.x )
                    goto Cleanup;
            }


            //
            //  We're between the start and end - ergo we're inside
            //
            fIsInSelection = TRUE;
        }
    }

Cleanup:

    return fIsInSelection;
}

//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on selection
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spLeft;
    SP_IMarkupPointer   spRight;
    SP_IHTMLElement     spElementCaret;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

    Assert( pfFindNext );
    Assert( pElement );

    //
    // Do the prep work.  Check to see if we have a segment.  It is possible
    // for an external host to get into DeleteSelection() without there
    // actually being a selection on the screen, yet the select tracker
    // is active.  See IE bug 98881 for more details.
    //
    if( _pISegment )
    {
        IFC( GetEditor()->CreateMarkupPointer( &spLeft ));
        IFC( GetEditor()->CreateMarkupPointer( &spRight ));

        // Currently we only have one selection, so fForward does not matter.  For multiple selection,
        // we would have to select the appropriate selection (first or last)
        IFC( _pISegment->GetPointers(spLeft, spRight ) );

        // First find the element where selection would contains caret
        IFC( spRight->CurrentScope( &spElementCaret ));
        if (!spElementCaret)
            goto Cleanup;

        // Now, scan upto the first scope boundary
        for(;;)
        {
            if (fForward)
            {
                IFC( spRight->Right(TRUE, &context, pElement, NULL, NULL));
            }
            else
            {
                IFC( spRight->Left(TRUE, &context, pElement, NULL, NULL));
            }

            Assert( context != CONTEXT_TYPE_None );

            if(     (context == CONTEXT_TYPE_EnterScope)    ||
                    (context == CONTEXT_TYPE_ExitScope)     ||
                    (context == CONTEXT_TYPE_NoScope) )
            {
                break;
            }

            ClearInterface(pElement);
        }

        if( pElement != &spElementCaret)
        {
            *pfFindNext = FALSE;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::MoveWord(IDisplayPointer* pDispPointer, MOVEUNIT_ACTION muAction)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( MoveWord(spPointer, muAction) );

    IFC( pDispPointer->MoveToMarkupPointer(spPointer, pDispPointer) );

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::UpdateSelectionSegments(BOOL fFireOM /*=TRUE*/)
{
    HRESULT hr = S_OK;
    BOOL    fEqual;

    //
    // Fire the message to notify other instances of trident that we are
    // doing selection
    //
    if( !_fFiredNotify )
    {
        IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, &fEqual ) );
        if( !fEqual )
        {
            IFC( _pManager->NotifyBeginSelection( START_TEXT_SELECTION ) );
            _fFiredNotify = TRUE;
        }
    }
    
    //
    // Update highlight rendering if it changed
    //
    if ( !_pIRenderSegment || SelectionSegmentDidntChange(_pIRenderSegment, _pDispStartPointer, _pDispEndPointer) !=  S_OK)
    {
        IFC( GetHighlightServices()->MoveSegmentToPointers(_pIRenderSegment, _pDispStartPointer, _pDispEndPointer ));

        
        //
        // Update markup pointers for selection rendering services
        //

        IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
        IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

        IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
        IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

         // fire the selectionchange event
        {
            CSelectionChangeCounter selCounter(_pManager);
            selCounter.SelectionChanged();
        }

        if ( IsDormant() ) // happens if OnSelectionChange tore us down.
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if ( fFireOM )
        {
            IFC( FireOnSelect());
        }

        if ( IsDormant() ) // happens if OnSelect tore us down.
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::SelectionSegmentDidntChange(IHighlightSegment *pISegment, IDisplayPointer *pDispStart, IDisplayPointer *pDispEnd)
{
    HRESULT             hr = S_FALSE;
    SP_IMarkupPointer   spOldStart;
    SP_IMarkupPointer   spOldEnd;
    SP_IMarkupPointer   spNewStart;
    SP_IMarkupPointer   spNewEnd;
    BOOL                fResult;

    Assert(pISegment && pDispStart && pDispEnd);

    IFC( GetEditor()->CreateMarkupPointer(&spOldStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spOldEnd) );
    IFC( GetEditor()->CreateMarkupPointer(&spNewStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spNewEnd) );

    IFC( pISegment->GetPointers(spOldStart, spOldEnd) );

    IFC( pDispStart->PositionMarkupPointer(spNewStart) );
    IFC( pDispEnd->PositionMarkupPointer(spNewEnd) );

    hr = THR_NOTRACE( spOldStart->IsEqualTo( spNewStart, &fResult ) );
    if (fResult)
    {
        hr = THR_NOTRACE( spOldEnd->IsEqualTo( spNewEnd, &fResult ) );
    }
    else
    {
        //  Pointers may be swapped.  GetPointers always returns us start
        //  and end as left to right.  We should not have swapped these
        //  since we can't really determine whether the segment changed
        //  due to a swap in start/end pointers.  Visually the segment
        //  hasn't changed, but internally it has.

        hr = THR_NOTRACE( spOldStart->IsEqualTo( spNewEnd, &fResult ) );
        if (fResult)
        {
            hr = THR_NOTRACE( spOldEnd->IsEqualTo( spNewStart, &fResult ) );
        }
    }

    hr = fResult ? S_OK : S_FALSE;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectTracker::FireOnSelect()
{
    HRESULT hr;
    SP_IHTMLElement spLayoutElement;
    SP_IHTMLElement spScopeElement;
    ELEMENT_TAG_ID eTag;

    IFC( _pSelServEnd->CurrentScope( & spScopeElement ));
    IFC( GetLayoutElement( GetMarkupServices(), spScopeElement, & spLayoutElement ));

    IFC( GetMarkupServices()->GetElementTagId( spLayoutElement, & eTag ));

    //
    // IE4 semantics are just to fire this on body, input & textarea.
    //
    switch ( eTag )
    {
        case TAGID_BODY:
        case TAGID_TEXTAREA:
        case TAGID_INPUT:
            IFC( _pManager->FireOnSelect( spLayoutElement ));

        default:
            break;
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::CreateSelectionSegments()
{
    HRESULT hr;
    BOOL    fEqual;

    //
    // Determine if the pointers have content between them.  If there is actual content, notify 
    // other trident instances that selection has begun
    //
    IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, &fEqual ) );

    Assert( !_fFiredNotify );
    
    if( !fEqual )
    {
        IFC( _pManager->NotifyBeginSelection(START_TEXT_SELECTION) );
        _fFiredNotify = TRUE;
    }
    
    //
    // Create selection services pointers and pass to selection services
    //
    _fAddedSegment = FALSE;

    IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
    IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

    IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
    IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

    IFC( GetSelectionServices()->AddSegment(_pSelServStart, _pSelServEnd, &_pISegment ));

    //
    // Add to highlight rendering services
    //
    IFC( GetHighlightServices()->AddSegment( _pDispStartPointer, _pDispEndPointer, GetSelectionManager()->GetSelRenderStyle(), &_pIRenderSegment ));
    _fAddedSegment = TRUE;

     // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(_pManager);
        selCounter.SelectionChanged();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::StartSelTimer()
{
    HRESULT hr = S_OK;
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;

    Assert( !_fInSelTimer && ! _pITimerWindow );

    IFC( _pManager->GetDoc()->get_parentWindow(&_pITimerWindow));
    IFC(_pITimerWindow->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)_pSelectionTimer;

    IFC(spWindow3->setInterval(&varCallBack,
                               SEL_TIMER_INTERVAL ,
                               &varLang, &_lTimerID));

    _fInSelTimer = TRUE;

Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectTracker::StopSelTimer()
{
    HRESULT hr = S_OK ;

    Assert( _fInSelTimer && _pITimerWindow );

    IFC( _pITimerWindow->clearInterval(_lTimerID));

    // Release the cached'd window
    ReleaseInterface( _pITimerWindow );
    _pITimerWindow = NULL;

    _fInSelTimer = FALSE;
Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectionTimer::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    POINT pt;

    if ( !_pSelTrack )
        goto Cleanup;

    //  We may get a timer event after becoming dormant if we failed to stop the timer for
    //  any reason before becoming dormant.  I've seen this occur when we switch docs while
    //  a timer is set.  This is because the doc maintains the timer event ids (_TimerEvents)
    //  and so attempting to kill a timer after switching docs will fail since the current doc
    //  won't have the timer id.  We will think we killed the timer, but in fact we didn't.
    //  So, we need to keep this check here to make sure that the seltracker are not dormant.

    if ( !_pSelTrack->IsDormant() )
    {
        CSynthEditEvent evt( _pSelTrack->GetEditor() );
        _pSelTrack->GetMousePoint( & pt, TRUE );
        IFC( evt.Init( & pt, EVT_TIMER ));

        TraceTag( ( tagSelectionTrackerState, "CSelectTimer::Invoke"));

        IGNORE_HR( _pSelTrack->HandleEvent( & evt ));
    }

 Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: MoveWord
//
// Synopsis: Provide IE 4 level word moving.
//             MoveWord() is a wrapper for MoveUnit(). It stops at IE4 word breaks
//              that MoveUnit() ignores such as:
//              <BR>, Block Break, TSB, TSE, and Intrinsics
//              The only muActions supported are MOVEUNIT_PREVWORDBEGIN and
//              MOVEUNIT_NEXTWORDBEGIN
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::MoveWord(
    IMarkupPointer * pPointerToMove,
    MOVEUNIT_ACTION  muAction)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    DWORD               dwBreaks;
    BOOL                fResult;
    BOOL                fPassedText;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointerSource;
    SP_IMarkupPointer   spPointerDestination;
    IMarkupPointer      *pLeftBoundary;
    IMarkupPointer      *pRightBoundary;
    ELEMENT_TAG_ID      tagId;

    Assert ( muAction == MOVEUNIT_PREVWORDBEGIN ||
             muAction == MOVEUNIT_NEXTWORDBEGIN );

    if (  muAction != MOVEUNIT_PREVWORDBEGIN &&
          muAction != MOVEUNIT_NEXTWORDBEGIN )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( GetEditor()->CreateMarkupPointer(&spPointerSource) );
    IFC( GetEditor()->CreateMarkupPointer(&spPointerDestination) );

    pLeftBoundary = _pManager->GetStartEditContext();
    pRightBoundary = _pManager->GetEndEditContext();

    //
    // pPointerDestination is where MoveUnit() would have positioned us, however,
    // since MoveUnit() does not account for IE4 word breaks like intrinsics,
    // Block Breaks, text site begin/ends, and Line breaks, we use another pointer
    // called pPointerSource. This pointer walks towards pPointerDestination
    // to detect IE4 word breaking characters that MoveUnit() does not catch.
    //


    IFC( spPointerSource->MoveToPointer(pPointerToMove) );
    IFC( spPointerDestination->MoveToPointer(pPointerToMove) );

    IFC( spPointerDestination->MoveUnit(muAction) );

    //
    // MoveUnit() may place the destination outside the range boundary.
    // First make sure that the destination is within range boundaries.
    //
    if ( pLeftBoundary && muAction == MOVEUNIT_PREVWORDBEGIN )
    {
        IFC( spPointerDestination->IsLeftOf(pLeftBoundary, &fResult) );

        if ( fResult )
        {
            IFC( spPointerDestination->MoveToPointer(pLeftBoundary) );
        }
    }
    else if( pRightBoundary && muAction == MOVEUNIT_NEXTWORDBEGIN )
    {
        IFC( spPointerDestination->IsRightOf(pRightBoundary, &fResult) );

        if ( fResult )
        {
            IFC( spPointerDestination->MoveToPointer(pRightBoundary) );
        }
    }

    //
    // Walk pointerSource towards pointerDestination, looking
    // for word breaks that MoveUnit() might have missed.
    //

    fPassedText = FALSE;

    for ( ; ; )
    {
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            IFC( spPointerSource->Left( TRUE, &context, &spElement, NULL, NULL ));
        }
        else
        {
            IFC( spPointerSource->Right( TRUE, &context, &spElement, NULL, NULL ));
        }

        switch( context )
        {
        case CONTEXT_TYPE_Text:
            fPassedText = TRUE;
            break;

        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if ( !spElement )
                break;

            if ( IsIntrinsic( GetMarkupServices(), spElement ) )
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've travelled over text before.

                if ( muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( spElement,
                                fPassedText ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( spElement,
                                fPassedText ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                }
                //
                // We're done
                //
                goto Cleanup;
            }

            //
            // Special case Anchors - treat them as word breaks.
            //
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if ( tagId == TAGID_A )
            {
                if ( fPassedText && muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    // If we're travelling right and have passed some text, backup
                    // before the last BR, we've gone too far.
                    hr = THR( spPointerSource->Left(TRUE, NULL, NULL, NULL, NULL));
                    goto Done;
                }
                else if ( fPassedText && muAction == MOVEUNIT_PREVWORDBEGIN )
                {
                    // Travelling left we are at the right place: we're at the beginning of <BR>
                    // which is a valid word break.
                    goto Done;
                }
            }

            if (context == CONTEXT_TYPE_NoScope)
            {
                fPassedText = TRUE;
            }
            else
            {
                BOOL fBlock, fLayout;

                IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );

                fPassedText = (fBlock || fLayout);
            }
            break;

        }

        //
        // If we are at or beyond the destination point where MoveUnit() took us,
        // set the passed in pointer to the destination and we're outta here
        //
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            BOOL fLeftOrEqual;

            IFC( spPointerSource->IsLeftOfOrEqualTo(spPointerDestination, &fLeftOrEqual) );
            if (fLeftOrEqual)
            {
                hr = THR(
                        pPointerToMove->MoveToPointer( spPointerDestination ) );
                goto Cleanup;
            }
        }
        else
        {
            BOOL fRightOrEqual;

            IFC( spPointerSource->IsRightOfOrEqualTo(spPointerDestination, &fRightOrEqual) );
            if (fRightOrEqual)
            {
                hr = THR(
                        pPointerToMove->MoveToPointer( spPointerDestination ) );
                goto Cleanup;
            }
        }

        //
        // Detect Block break, Text site begin or text site end
        //
        {
            SP_IDisplayPointer spDispPointer;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            hr = THR( spDispPointer->MoveToMarkupPointer(spPointerSource, NULL) );
            if (hr == CTL_E_INVALIDLINE)
            {
                dwBreaks = 0;
            }
            else
            {
                IFC( hr );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( spDispPointer->QueryBreaks(&dwBreaks) );
            }
        }

        // We hit a break before reaching our destination, time to stop...
        if (dwBreaks)
        {
            if ( fPassedText )
            {
                goto Done;
            }
            else
            {
                fPassedText = TRUE;
            }
        }
    }

Done:
    IFC( pPointerToMove->MoveToPointer(spPointerSource) );

Cleanup:
    RRETURN( hr );
}

BOOL
CSelectTracker::SameLayoutForJumpOver( IHTMLElement* pIFlowElement,
                                       IHTMLElement* pIElement )
{
    HRESULT             hr;
    SP_IObjectIdentity  spIdent;
    BOOL                fSameFlow = FALSE;
    ELEMENT_TAG_ID      eTag;
    SP_IHTMLElement     spTableElement;
    SP_IHTMLElement     spParent;
    SP_IHTMLElement     spLayoutElement;

    Assert( pIFlowElement && pIElement );

    IFC( GetMarkupServices()->GetElementTagId( pIFlowElement , & eTag ));

    //
    // Tables are special - we don't jump over them, except in certain cases.
    // If a table is completed contained within selection, it is basically text
    // selected, and in this case, we want to adjust for site selection based on
    // the table's different layout, so we return FALSE.
    //
    // If the table has have atomic selection, we also return FALSE
    //
    if( IsTablePart( eTag ) )
    {
        //
        // Retrieve the layout above the table, and see if it is text selected
        //
        IFC( GetEditor()->GetTableFromTablePart( pIFlowElement, &spTableElement ) );
        IFC( GetEditor()->GetParentElement( spTableElement, &spParent ) );
        IFC( EdUtil::GetLayoutElement( GetMarkupServices(), spParent, &spLayoutElement ) );

        if( !IsInOrContainsSelection( spParent ) &&
            _pManager->CheckAtomic( pIFlowElement ) == S_FALSE )
        {
            fSameFlow = TRUE;
        }
    }
    else
    {
        IFC( pIFlowElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
        fSameFlow = (spIdent->IsEqualObject(pIElement) == S_OK);
    }

Cleanup:
    Assert( SUCCEEDED(hr));
    return fSameFlow;
}


HRESULT
CSelectTracker::AttachPropertyChangeHandler(IHTMLElement* pIElement )
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( ! _pISelectStartElement );

    ReplaceInterface( & _pISelectStartElement , pIElement );

    IFC( _pPropChangeListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pISelectStartElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );

Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectTracker::DetachPropertyChangeHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pISelectStartElement );

    IFC( _pPropChangeListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pISelectStartElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));

    ClearInterface( & _pISelectStartElement );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::OnPropertyChange( CEditEvent * pEvt )
{
    HRESULT hr = S_OK;
    BSTR bstrPropChange;

    IFC( DYNCAST( CHTMLEditEvent, pEvt)->GetPropertyChange( & bstrPropChange ));
    if( !StrCmpICW (bstrPropChange, L"atomicSelection") )
    {
        Assert( _pISelectStartElement );
        if ( ! _fStartIsAtomic  && _pManager->CheckAtomic( _pISelectStartElement ) == S_OK )
        {
            _fStartIsAtomic = TRUE;
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CPropertyChangeListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if (!_pSelTrack)
        goto Cleanup;

    if ( _pSelTrack->IsDormant() )
        goto Cleanup;
    
    if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH)
    {
        IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
        if ( spObj )
        {
            CHTMLEditEvent evt( _pSelTrack->GetEditor());
            IFC( evt.Init(  spObj , dispidMember));
            Assert( evt.GetType() == EVT_PROPERTYCHANGE );
            if( evt.GetType() == EVT_PROPERTYCHANGE )
            {
                IFC( _pSelTrack->OnPropertyChange( & evt ));
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionAnchor( IMarkupPointer* pAnchor )
{
    HRESULT hr;

    Assert( _pDispStartPointer );

    IFC( _pDispStartPointer->PositionMarkupPointer( pAnchor ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionEnd( IMarkupPointer* pEnd )
{
    HRESULT hr;

    Assert( _pDispEndPointer );

    IFC( _pDispEndPointer->PositionMarkupPointer( pEnd ));

Cleanup:
    RRETURN( hr );

}

HRESULT
CSelectTracker::MoveToSelectionAnchor( IDisplayPointer* pAnchor )
{
    HRESULT hr;

    Assert( _pDispStartPointer );

    IFC( pAnchor->MoveToPointer( _pDispStartPointer ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionEnd( IDisplayPointer* pEnd )
{
    HRESULT hr;

    Assert( _pDispEndPointer );

    IFC( pEnd ->MoveToPointer(_pDispEndPointer));

Cleanup:
    RRETURN( hr );

}

HRESULT
CSelectTracker::DoSelectGlyph( CEditEvent* pEvent )
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointer;

    //
    // Get the glyph element
    //

    IFC( pEvent->GetElement(&spElement) );

    //
    // Position the selection
    //

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
    IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );

    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
    IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );

    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );

        IFC( FireOnSelect() );
    }

    SetMadeSelection( TRUE );

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::AdjustForAtomic(
                IDisplayPointer* pDisp,
                IHTMLElement* pElement,
                BOOL fStartOfSelection,
                POINT* ppt,
                BOOL* pfDidSelection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartPointer;
    SP_IMarkupPointer   spEndPointer;
    int                 iWherePointer = 0;
    BOOL                fDirection = TRUE;

    //  Which direction is the selection going?

    //  NOTE: _pDispPrevTestPointer and _pDispTestPointer may be NULL here
    //  when called from CSelectTracker::Position.
    if (_pDispPrevTestPointer && _pDispTestPointer)
    {
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
    }
    fDirection = (iWherePointer == SAME ) ?
                        ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( ppt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                        ( iWherePointer == RIGHT ) ;

    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
    IFC( CEditTracker::AdjustForAtomic(pDisp, pElement, fStartOfSelection, ppt, pfDidSelection,
            fDirection, SELECTION_TYPE_Text, &spStartPointer, &spEndPointer) );

    if (*pfDidSelection)
    {
        //  We are now in passive mode.  We need to go active now.
        if ( _fState == ST_DOSELECTION && *pfDidSelection )
        {
            IFC( GoActiveFromPassive(spStartPointer, spEndPointer) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::GoActiveFromPassive(IMarkupPointer* pSelStartPointer, IMarkupPointer* pSelEndPointer)
{
    HRESULT     hr = S_OK;

    //  Set our markup pointers.
    IFC ( _pDispPrevTestPointer->MoveToMarkupPointer( pSelStartPointer, NULL ));
    IFC ( _pDispTestPointer->MoveToMarkupPointer( pSelEndPointer, NULL ));
    IFC ( _pDispWordPointer->MoveToMarkupPointer( pSelEndPointer, NULL ));

    //  Set our current state.
    SetState( ST_DOSELECTION, TRUE );
    if ( !_fTookCapture )
    {
        TakeCapture();
        _fTookCapture = TRUE;
    }

    //  Reset our timers.
    // StartTimer();
    StartSelTimer();

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::UpdateShiftPointer(IDisplayPointer *pIDispPtr)
{
    HRESULT hr;

    if( pIDispPtr )
    {
        //
        // Update markup pointers for shift selection
        //
        IFC( _pDispShiftPointer->MoveToPointer( pIDispPtr ) );
        IFC( CopyPointerGravity( pIDispPtr, _pDispShiftPointer) );
    }
    else
    {
        IFC( _pDispShiftPointer->Unposition() );
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CSelectTracker::HasShiftPointer()
{
    BOOL    fPositioned = FALSE;
    HRESULT hr;

    Assert( _pDispShiftPointer );

    IFC( _pDispShiftPointer->IsPositioned(&fPositioned) );

Cleanup:

    return fPositioned;
}
BOOL
CSelectTracker::IsInOrContainsSelection(   IHTMLElement    *pIElement )
{
    HRESULT             hr = S_OK;
    BOOL                fWithin = FALSE;                // Within selection?
    BOOL                fIsLeft;                        // Comparison
    BOOL                fIsRight;
    BOOL                fSwap;
    SP_IMarkupPointer   spElemStart;                    // Positioned before element start
    SP_IMarkupPointer   spElemEnd;                      // Positioned after element end
    SP_IMarkupPointer   spSelStart;                     // True start of selection
    SP_IMarkupPointer   spSelEnd;                       // True end of selection

    // Check if selection is even active
    if ( _fState == ST_WAIT2 )
    {
        goto Cleanup;
    }

    //
    // Create some markup pointers, and position them around the
    // element.
    //
    IFC( GetEditor()->CreateMarkupPointer(&spElemStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spElemEnd) );
    IFC( GetEditor()->CreateMarkupPointer(&spSelStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spSelEnd) );

    IFC( spElemStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ) );
    IFC( spElemEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ) );

    //
    // Get our true start and end selection pointers
    //
    IFC( MovePointersToTrueStartAndEnd( spSelStart, spSelEnd, &fSwap ) );

    //
    // Compare
    //
    IFC( spElemEnd->IsLeftOfOrEqualTo( spSelEnd, &fIsLeft ) );
    IFC( spElemStart->IsRightOfOrEqualTo( spSelStart, &fIsRight ) );

    fWithin = (fIsLeft && fIsRight);

Cleanup:

    return ( fWithin );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectTracker::AdjustLineSelection
//
//  Synopsis:   Adjusts the shift pointer of selection before we call
//              MovePointer to adjust the end of selection.  This is
//              useful for situations when shift-selection
//              differs from regular caret navigation.  An example is bug
//              91420.
//
//  Arguments:  pIDispPointer = Pointer to IDisplayPointer to adjust
//              inCaretMove = How the selection is supposed to move
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectTracker::AdjustLineSelection(CARET_MOVE_UNIT inCaretMove)
{
    HRESULT         hr = S_OK;
    BOOL            fBOL;       // Is the end pointer at the BOL?
    BOOL            fBetween;
    DISPLAY_GRAVITY eGravity;

    //
    // Always make sure that when we do a SHIFT-HOME or SHIFT-END that
    // we select the previous or next line.  Otherwise, selection would
    // get stuck when we did a SHIFT-HOME or SHIFT-END.
    //
    if( inCaretMove == CARET_MOVE_LINEEND || inCaretMove == CARET_MOVE_LINESTART )
    {
        IFC( _pDispShiftPointer->MoveToPointer( _pDispEndPointer ) );
        IFC( _pDispShiftPointer->IsAtBOL(&fBOL) );

        fBetween = IsBetweenBlocks( _pDispShiftPointer );

        IFC( _pDispShiftPointer->GetDisplayGravity( &eGravity ) );

        if( fBOL )
        {
            if( inCaretMove == CARET_MOVE_LINEEND )
                eGravity = DISPLAY_GRAVITY_NextLine;
            else
                eGravity = DISPLAY_GRAVITY_PreviousLine;
        }
        else if( fBetween )
        {
            if( inCaretMove == CARET_MOVE_LINEEND )
                eGravity = DISPLAY_GRAVITY_NextLine;
            else
                eGravity = DISPLAY_GRAVITY_PreviousLine;
        }

        IFC( _pDispShiftPointer->SetDisplayGravity(eGravity) );
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::AdjustStartForAtomic( BOOL fFurtherInStory )
{
    //  Bug 102482, 103785: If we positioned the end pointer such that our initial selection
    //  hit point is outside of the current selection, readjust the start so that it
    //  will contain the selection hit point.

    HRESULT     hr = S_OK;

    if (_fStartIsAtomic)
    {
        BOOL        fBetween = FALSE;

        if (fFurtherInStory)
        {
            IFC( _pDispEndPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
            if (fBetween)
            {
                IFC( _pDispStartPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
            }
        }
        else
        {
            IFC( _pDispEndPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
            if (fBetween)
            {
                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
            }
        }

        if (!fBetween)
        {
            //  Okay, we need to readjust our start pointer
            IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::AdjustEndForAtomic(IHTMLElement *spAtomicElement,
                                   POINT pt,
                                   BOOL  fDirection,
                                   BOOL *pfDidSelection,
                                   BOOL *pfAdjustedSel)
{
    HRESULT             hr;
    SP_IDisplayPointer  spDispPointer;
    BOOL                fBetween = FALSE;

    // We adjust the end pointer for atomic selection.  We must make sure that
    // if the cursor is within the selection, we don't position the end pointer
    // such that the cursor is no longer in the selection.

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToPointer(_pDispEndPointer) );
    IFC( AdjustForAtomic( spDispPointer, spAtomicElement, FALSE , & pt, pfDidSelection));

    if (fDirection)
    {
        _pDispStartPointer->IsLeftOf(_pDispTestPointer, &fBetween);
        if (fBetween)
        {
            spDispPointer->IsRightOf(_pDispTestPointer, &fBetween);
        }
    }
    else
    {
        _pDispStartPointer->IsRightOf(_pDispTestPointer, &fBetween);
        if (fBetween)
        {
            spDispPointer->IsLeftOf(_pDispTestPointer, &fBetween);
        }
    }

    if (fBetween)
    {
        IFC( _pDispEndPointer->MoveToPointer(spDispPointer) );
        if (*pfDidSelection)
            goto Cleanup;
    }

    *pfAdjustedSel = TRUE;

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN( hr );
}

HRESULT
CSelectTracker::RetrieveDragElement(CEditEvent *pEvent)
{
    HRESULT hr;

    Assert( pEvent != NULL );

    IFC( pEvent->GetElement( &_pIDragElement ) );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::EnsureAtomicSelection(CEditEvent *pEvent)
{
    HRESULT     hr = S_OK;

    if ( IsSelectionEmpty() )
    {
        SP_IHTMLElement     spElement;
        SP_IHTMLElement     spAtomicElement;
        SP_IDisplayPointer  spEventPtr;
        
        IFC( GetDisplayServices()->CreateDisplayPointer( &spEventPtr ) );
        IFC( pEvent->MoveDisplayPointerToEvent ( spEventPtr, NULL ));
        IFC( GetCurrentScope( spEventPtr, &spElement ) );
        if ( _pManager->FindAtomicElement(spElement, &spAtomicElement) == S_OK )
        {
            IFC( _pDispStartPointer->MoveToPointer(spEventPtr) );
            IFC( _pDispEndPointer->MoveToPointer(spEventPtr) );

            IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispStartPointer, spAtomicElement, TRUE, RIGHT) );
            IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispEndPointer, spAtomicElement, FALSE, RIGHT) );

            _fAddedSegment = FALSE;

            IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
            IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

            IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
            IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

            IFC( GetSelectionServices()->AddSegment(_pSelServStart, _pSelServEnd, &_pISegment ));
            IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );
            IFC( GetHighlightServices()->AddSegment( _pDispStartPointer, _pDispEndPointer, GetSelectionManager()->GetSelRenderStyle(), &_pIRenderSegment ));

            _fAddedSegment = TRUE;

            IFC( UpdateShiftPointer(NULL) );
            IFC( _pDispPrevTestPointer->Unposition() );
            IFC( _pDispTestPointer->MoveToPointer(spEventPtr) );

            _fDragDrop = FALSE;
            _fShift = FALSE;

            if (_fState == ST_WAITBTNDOWN1 && pEvent->GetType() == EVT_LMOUSEUP)
                _fMouseClickedInAtomicSelection = TRUE;
        }
    }
    else
    {
        IFC( EnsureStartAndEndPointersAreAtomicallyCorrect() );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::EnsureStartAndEndPointersAreAtomicallyCorrect()
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spStartElement;
    SP_IHTMLElement     spStartAtomicElement;
    SP_IHTMLElement     spEndElement;
    SP_IHTMLElement     spEndAtomicElement;
    int                 iDirection;
    BOOL                fUpdate = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( _pDispStartPointer->PositionMarkupPointer(spStart) );
    IFC( _pDispEndPointer->PositionMarkupPointer(spEnd) );

    IFC( OldCompare(spStart, spEnd, &iDirection) );

    IFC( GetCurrentScope(_pDispStartPointer, &spStartElement) );
    if ( _pManager->FindAtomicElement(spStartElement, &spStartAtomicElement) == S_OK )
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispStartPointer, spStartAtomicElement, TRUE, iDirection) );
        fUpdate = TRUE;
    }

    IFC( GetCurrentScope(_pDispEndPointer, &spEndElement) );
    if ( _pManager->FindAtomicElement(spEndElement, &spEndAtomicElement) == S_OK )
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispEndPointer, spEndAtomicElement, FALSE, iDirection) );
        fUpdate = TRUE;
    }

    if (fUpdate)
    {
        IFC( UpdateSelectionSegments() );
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\editres\makefile.inc ===
# Run the HTML dialogs though the preprocessor to remove comments
# then through a sed script to reomave extra whitespace.

$O\forchar.dls : forchar.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP forchar.dlg > $@

$O\forchar.dlx : $O\forchar.dls dlg.pl
    perl dlg.pl < $O\forchar.dls > $@

$O\insimage.dls : insimage.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP insimage.dlg > $@

$O\insimage.dlx : $O\insimage.dls dlg.pl
    perl dlg.pl < $O\insimage.dls > $@

$O\edlink.dls : edlink.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP edlink.dlg > $@

$O\edlink.dlx : $O\edlink.dls dlg.pl
    perl dlg.pl < $O\edlink.dls > $@

$O\edbook.dls : edbook.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP edlink.dlg > $@

$O\edbook.dlx : $O\edbook.dls dlg.pl
    perl dlg.pl < $O\edbook.dls > $@

# Run the HTML property pages through a sed
# script to remove extra whitespaces.

MSHTMLER_DEP = \
    $O\forchar.dlx \
    $O\insimage.dlx \
    $O\edlink.dlx

mshtmler.rc : $(MSHTMLER_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\edcom.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_FLATPTR_HXX_
#define X_FLATPTR_HXX_
#include "flatptr.hxx"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

MtDefine(CEditXform, Utilities, "CEditXform")

using namespace EdUtil;

HRESULT
OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi )
{
    HRESULT hr = S_OK;
    BOOL    fResult;
    
    hr = THR_NOTRACE( p1->IsEqualTo( p2, & fResult ) );
    if ( FAILED( hr ) )
        goto Cleanup;
        
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }

    hr = THR_NOTRACE( p1->IsLeftOf( p2, & fResult ) );
    if ( FAILED( hr ) )
        goto Cleanup;
        
    *pi = fResult ? -1 : 1;

Cleanup:

    RRETURN( hr );
}

HRESULT
EdUtil::CopyMarkupPointer(CEditorDoc      *pEditorDoc,
                          IMarkupPointer  *pSource,
                          IMarkupPointer  **ppDest )
{
    HRESULT hr;

    hr = THR(CreateMarkupPointer2(pEditorDoc, ppDest));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR((*ppDest)->MoveToPointer(pSource));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareColor, local helper
//  Synopsis:   compares color
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareColor(VARIANT * pvarColor1, VARIANT * pvarColor2)
{
    BOOL        fResult;
    CVariant    var;
    COLORREF    color1;
    COLORREF    color2;

    if (   V_VT(pvarColor1) == VT_NULL
        || V_VT(pvarColor2) == VT_NULL
       )
    {
        fResult = V_VT(pvarColor1) == V_VT(pvarColor2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&var, pvarColor1,  VT_I4))
        goto Error;

    color1 = (COLORREF)V_I4(&var);

    if (VariantChangeTypeSpecial(&var, pvarColor2, VT_I4))
        goto Error;

    color2 = (COLORREF)V_I4(&var);

    fResult = color1 == color2;

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareBSTRS, local helper
//  Synopsis:   compares 2 btrs
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareBSTRS(VARIANT * pvar1, VARIANT * pvar2)
{
    BOOL    fResult;
    TCHAR  *pStr1;
    TCHAR  *pStr2;
    TCHAR  ach[1] = {0};

    if (V_VT(pvar1) == VT_BSTR && V_VT(pvar2) == VT_BSTR)
    {
        pStr1 = V_BSTR(pvar1) ? V_BSTR(pvar1) : ach;
        pStr2 = V_BSTR(pvar2) ? V_BSTR(pvar2) : ach;

        fResult = StrCmpC(pStr1, pStr2) == 0;
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
EdUtil::FormsAllocStringW(LPCWSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

#if defined(_MAC) || defined(WIN16)
HRESULT
EdUtil::FormsAllocStringA(LPCSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

#ifndef WIN16
HRESULT
EdUtil::FormsAllocStringA(LPCWSTR pwch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pwch || !*pwch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    CStr str;
    str.Set(pwch);
    *pBSTR = SysAllocString(str.GetAltStr());

    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}
#endif // !WIN16
#endif //_MAC

//+----------------------------------------------------------------------------
//  Method:     VariantCompareFontName, local helper
//  Synopsis:   compares font names
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareFontName(VARIANT * pvarName1, VARIANT * pvarName2)
{
    return VariantCompareBSTRS(pvarName1, pvarName2);
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareFontSize, local helper
//  Synopsis:   compares font size
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareFontSize(VARIANT * pvarSize1, VARIANT * pvarSize2)
{
    CVariant    convVar1;
    CVariant    convVar2;
    BOOL        fResult;

    Assert(pvarSize1);
    Assert(pvarSize2);

    if (   V_VT(pvarSize1) == VT_NULL
        || V_VT(pvarSize2) == VT_NULL
       )
    {
        fResult = V_VT(pvarSize1) == V_VT(pvarSize2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&convVar1, pvarSize1, VT_I4))
        goto Error;

    if (VariantChangeTypeSpecial(&convVar2, pvarSize2, VT_I4))
        goto Error;

    fResult = V_I4(&convVar1) == V_I4(&convVar2);

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


DWORD 
EdUtil::ConvertRGBColorToOleColor(DWORD dwColor)
{
    return ((dwColor & 0xff) << 16) | (dwColor & 0xff00) | ((dwColor & 0xff0000) >> 16);
}

HRESULT
EdUtil::ConvertOLEColorToRGB(VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;
    DWORD   dwColor;

    if (V_VT(pvarargIn) != VT_BSTR)
    {
        hr = THR(VariantChangeTypeSpecial(pvarargIn, pvarargIn, VT_I4));

        if (!hr && V_VT(pvarargIn) == VT_I4)
        {
            //
            // Note SujalP and TerryLu:
            //
            // If the color coming in is not a string type, then it is assumed
            // to be in a numeric format which is BBGGRR. However, FormatRange
            // (actually put_color()) expects a RRGGBB. For this reason, whenever
            // we get a VT_I4, we convert it to a RRGGBB. To do this we use
            // then helper on CColorValue, SetFromRGB() wto which we pass an
            // ****BBGGRR**** value. It just flips the bytes around and ends
            // up with a RRGGBB value, which we retrieve from GetColorRef().
            //
            V_VT(pvarargIn) = VT_I4;
            dwColor = V_I4(pvarargIn);

            V_I4(pvarargIn) = ((dwColor & 0xff) << 16)
                             | (dwColor & 0xff00)
                             | ((dwColor & 0xff0000) >> 16);

        }
    }

    RRETURN(hr);
}

HRESULT
EdUtil::ConvertRGBToOLEColor(VARIANT *pvarargIn)
{
    //
    // It just flips the byte order so this is a valid implementation
    //
    return ConvertOLEColorToRGB(pvarargIn);
}

BOOL
EdUtil::IsListContainer(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
    case TAGID_OL:
    case TAGID_UL:
    case TAGID_MENU:
    case TAGID_DIR:
    case TAGID_DL:
        return TRUE;

    default:
        return FALSE;
    }
}

BOOL
EdUtil::IsListItem(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
    case TAGID_LI:
    case TAGID_DD:
    case TAGID_DT:
        return TRUE;

    default:
        return FALSE;
    }
}

// Font height conversion data.  Valid HTML font sizes ares [1..7]
// NB (cthrash) These are in twips, and are in the 'smallest' font
// size.  The scaling takes place in CFontCache::GetCcs().

// TODO (IE6 track bug 20)
// TODO (cthrash) We will need to get these values from the registry
// when we internationalize this product, so as to get sizing appropriate
// for the target locale.
// NOTE (johnv): Where did these old numbers come from?  The new ones now correspond to
// TwipsFromHtmlSize[2] defined above.
// static const int aiSizesInTwips[7] = { 100, 130, 160, 200, 240, 320, 480 };

// scale fonts up for TV
#ifdef NTSC
static const int aiSizesInTwips[7] = { 200, 240, 280, 320, 400, 560, 840 };
#else
static const int aiSizesInTwips[7] = { 151, 200, 240, 271, 360, 480, 720 };
#endif

int
EdUtil::ConvertHtmlSizeToTwips(int nHtmlSize)
{
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [1..7]
    nHtmlSize = max( 1, min( 7, nHtmlSize ) );

    return aiSizesInTwips[ nHtmlSize - 1 ];
}

int
EdUtil::ConvertTwipsToHtmlSize(int nFontSize)
{
    int nNumElem = ARRAY_SIZE(aiSizesInTwips);

    // Now convert the point size to size units used by HTML
    // Valid HTML font sizes ares [1..7]
    for(int i = 0; i < nNumElem; i++)
    {
        if(nFontSize <= aiSizesInTwips[i])
            break;
    }

    return i + 1;
}

#define LF          10
#define CR          13
#define FF          TEXT('\f')
#define TAB         TEXT('\t')
#define VT          TEXT('\v')
#define PS          0x2029

BOOL
EdUtil::IsWhiteSpace(TCHAR ch)
{
    return (    ch == L' '
             || InRange( ch, TAB, CR ));
}

//+---------------------------------------------------------------------------
//
//  Method:       CopyAttributes.
//
//  Synopsis:     Wrapper to IHTMLDocument2::mergeAttributes
//
//----------------------------------------------------------------------------
HRESULT
EdUtil::CopyAttributes(IHTMLElement * pSrcElement, IHTMLElement * pDestElement, BOOL fCopyId)
{
    HRESULT hr = E_POINTER;
    VARIANT var;
    SP_IHTMLElement3 spElement3;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fCopyId ? VARIANT_FALSE : VARIANT_TRUE; // if CopyID == TRUE, then don't preserve id!
    
    IFC(pDestElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->mergeAttributes(pSrcElement, &var));

Cleanup:
    RRETURN( hr );
}

HRESULT EdUtil::ReplaceElement( CEditorDoc      *pEditorDoc,
                                IHTMLElement    *pOldElement,
                                IHTMLElement    *pNewElement,
                                IMarkupPointer  *pUserStart,
                                IMarkupPointer  *pUserEnd)
{
    HRESULT        hr;
    IMarkupPointer *pStart = NULL;
    IMarkupPointer *pEnd = NULL;
    //
    // Set up markup pointers
    //

    if (pUserStart)
    {
        pStart = pUserStart;
        pStart->AddRef();
    }
    else
    {
        hr = THR(CreateMarkupPointer2(pEditorDoc, &pStart));
        if (FAILED(hr))
            goto Cleanup;
    }

    if (pUserEnd)
    {
        pEnd = pUserEnd;
        pEnd->AddRef();
    }
    else
    {
        hr = THR(CreateMarkupPointer2(pEditorDoc, &pEnd));
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Replace the element
    //

    hr = THR(pEnd->MoveAdjacentToElement(pOldElement, ELEM_ADJ_AfterEnd));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pStart->MoveAdjacentToElement(pOldElement, ELEM_ADJ_BeforeBegin));
    if (FAILED(hr))
        goto Cleanup;
    
    hr = THR(CopyAttributes(pOldElement, pNewElement, TRUE));
    if (FAILED(hr))
        goto Cleanup;
        
    hr = THR(InsertElement(pEditorDoc->GetMarkupServices(), pNewElement, 
pStart, pEnd));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pEditorDoc->GetMarkupServices()->RemoveElement(pOldElement));
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    RRETURN(hr);
}
//+====================================================================================
//
// Method: IsElementPositioned
//
// Synopsis: Does this element have a Relative/Absolute Position.
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::IsElementPositioned(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;

    IHTMLElement2 * pElement2 = NULL;
    IHTMLCurrentStyle * pCurStyle = NULL;
    BSTR bsPosition = NULL;
    
    BOOL fIsPosition = FALSE;

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pElement->QueryInterface( IID_IHTMLElement2, ( void** ) & pElement2 ));
    if ( hr )
        goto Cleanup;

    hr = THR( pElement2->get_currentStyle( & pCurStyle ));
    if ( hr || pCurStyle == NULL )
        goto Cleanup;

    hr = THR( pCurStyle->get_position( & bsPosition));
    if ( hr ) 
        goto Cleanup;

    if ( StrCmpIW(_T("absolute"), bsPosition ) == 0)
    {
        fIsPosition = TRUE;
    }
    else if ( StrCmpIW(_T("relative"), bsPosition ) == 0)
    {
        fIsPosition = TRUE;
    }

    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pElement2 );
    ReleaseInterface( pCurStyle );
    
    return ( fIsPosition );
}

BOOL
EdUtil::IsElementVisible(IHTMLElement *pElement)
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLCurrentStyle    spCurStyle;
    BSTR                    bsVisible = NULL;   
    BOOL                    fVisible = TRUE;

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pElement->QueryInterface( IID_IHTMLElement2, (void **)&spElement2 ));

    IFC( spElement2->get_currentStyle( &spCurStyle ) );
    if( spCurStyle == NULL )
        goto Cleanup;

    IFC( spCurStyle->get_visibility( &bsVisible ));

    if ( StrCmpIW(_T("hidden"), bsVisible ) == 0)
    {
        fVisible = FALSE;
    }
    
Cleanup:
    SysFreeString( bsVisible );
    
    return ( fVisible );
}

//+====================================================================================
//
// Method: IsElementSized
//
// Synopsis: Does this element have a width/height style.
//
//------------------------------------------------------------------------------------


HRESULT
EdUtil::IsElementSized(IHTMLElement* pElement, BOOL *pfSized)
{

    HRESULT hr;
    BSTR bstrSize = NULL;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    VARIANT varSize;
    BOOL fWidth = FALSE;
    BOOL fHeight = FALSE;
    VariantInit(&varSize);

    Assert(pfSized);
    Assert(pElement);

    *pfSized = FALSE;
    

    IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;

    IFC(spCurrStyle->get_width(&varSize));
    bstrSize = V_BSTR(&varSize);
    // (sramani) Temporary hack to compare the string for "auto" which is what will be returned by 
    // the OM for width and height of 0. This will go away when enums are exposed on a new CurrentStyle
    // object on the display pointer.
    fWidth = (V_VT(&varSize) == VT_BSTR) && bstrSize && *bstrSize && _tcscmp(bstrSize, _T("auto"));
    
    VariantClear(&varSize);
    IFC(spCurrStyle->get_height(&varSize));    
    bstrSize = V_BSTR(&varSize);
    // (sramani) Temporary hack to compare the string for "auto" which is what will be returned by 
    // the OM for width and height of 0. This will go away when enums are exposed on a new CurrentStyle
    // object on the display pointer.
    fHeight = (V_VT(&varSize) == VT_BSTR) && bstrSize && *bstrSize && _tcscmp(bstrSize, _T("auto"));
    
    *pfSized = fWidth || fHeight;

Cleanup:
    VariantClear(&varSize);
    return hr;
}

//+====================================================================================
//
// Method: Is1DElement
//
// Synopsis: Does this element a 1D Element.
//
//------------------------------------------------------------------------------------

HRESULT 
EdUtil::Is1DElement(IHTMLElement* pElement, BOOL* pf1D)
{
    BOOL b2D ;
    HRESULT hr = Is2DElement(pElement , &b2D ) ;
    if (!hr)
        *pf1D = !b2D ;
    return ( hr);
}

//+====================================================================================
//
// Method: Is2DElement
//
// Synopsis: Does this element a 2D Element.
// Return:
//       *pf2D = TRUE if the element is 2D positioned.
//       *pf2D = FALSE if the element is not 2D positioned.
//------------------------------------------------------------------------------------

HRESULT
EdUtil::Is2DElement(IHTMLElement* pElement, BOOL* pf2D)
{
    HRESULT hr = S_OK;

    IHTMLElement2 * pElement2 = NULL;
    IHTMLCurrentStyle * pCurStyle = NULL;
    BSTR bsPosition = NULL;
    
    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC(pElement->QueryInterface( IID_IHTMLElement2, ( void** ) & pElement2 ));
    IFC (pElement2->get_currentStyle( & pCurStyle ));
    if ( pCurStyle == NULL )
        goto Cleanup;

    IFC ( pCurStyle->get_position( & bsPosition));

    *pf2D = (StrCmpIW(_T("absolute"), bsPosition ) == 0);
    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pElement2 );
    ReleaseInterface( pCurStyle );
    
    return ( hr);
}

///////////////////////////////////////////////////////////////////////////////
//
// EdUtil::Make1DElement
//
// Set the given HTML element to layout in the flow.  Return S_OK if all goes
// well; .
//

HRESULT 
EdUtil::Make1DElement(IHTMLElement* pElement)
{
    SP_IHTMLStyle pStyle ;
    HRESULT hr = S_OK;
    VARIANT var_zIndex;
    
    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pElement->get_style(&pStyle);
    if (pStyle == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }


    VariantInit(&var_zIndex);
    var_zIndex.vt = VT_I4;
    var_zIndex.lVal = 0; 
    IFC (pStyle->put_zIndex(var_zIndex));
    IFC (pStyle->removeAttribute(L"position", 0, NULL));

Cleanup :
    VariantClear( & var_zIndex );
    return (hr);
}

///////////////////////////////////////////////////////////////////////////////
//
// EdUtil::Make2DElement
//
// Set the given HTML element to absolute position .  Return S_OK if all goes well; .
////////////////////////////////////////////////////////////////////////////////

HRESULT 
EdUtil::Make2DElement(IHTMLElement* pElement)
{
    SP_IHTMLStyle   pStyle ;
    IHTMLStyle2* pStyle2 = NULL;
    HRESULT hr = S_OK;

    BSTR bsPosition = SysAllocString( _T("absolute"));
    if (bsPosition == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
 
    IFC(pElement->get_style(&pStyle ));

    if (pStyle == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pStyle->QueryInterface( IID_IHTMLStyle2, (void**) & pStyle2));
    
    if ( pStyle2 == NULL )
    {
        hr = S_FALSE ;
        goto Cleanup;
    }
    IFC ( pStyle2->put_position(bsPosition));   
    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pStyle2 );
    RRETURN (hr);
}


//+====================================================================================
//
// Method: MakeAbsolutePosition
// Synopsis: Make this Absolute Positioned Element.
//
//------------------------------------------------------------------------------------

HRESULT 
EdUtil::MakeAbsolutePosition(IHTMLElement* pElement, BOOL bTrue)
{
    HRESULT hr = S_OK;
    
    hr = ( bTrue ?  Make2DElement(pElement) : Make1DElement(pElement) ); 
     
    RRETURN (hr);
}

BOOL 
EdUtil::IsShiftKeyDown()
{
    return (GetKeyState(VK_SHIFT) & 0x8000) ;
}

BOOL 
EdUtil::IsControlKeyDown()
{
    return (GetKeyState(VK_CONTROL) & 0x8000) ;
}


HRESULT EdUtil::MoveAdjacentToElementHelper(IMarkupPointer *pMarkupPointer, IHTMLElement *pElement, ELEMENT_ADJACENCY elemAdj)
{
    HRESULT hr;
    
    hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, elemAdj));
    if (hr)
    {
        if (elemAdj == ELEM_ADJ_AfterBegin)
            hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin));
        else if (elemAdj == ELEM_ADJ_BeforeEnd)
            hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd));
    }
    RRETURN(hr);
}

HRESULT
EdUtil::FindBlockLimit(
    CEditorDoc          *pEditorDoc, 
    Direction           direction, 
    IMarkupPointer      *pPointer, 
    IHTMLElement        **ppElement, 
    MARKUP_CONTEXT_TYPE *pContext,
    BOOL                fExpanded,
    BOOL                fLeaveInside,
    BOOL                fCanCrossLayout)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                fFoundExitScope = FALSE;
    BOOL                bLayout = FALSE;

    if (ppElement)
        *ppElement = NULL; 

    // Find the block
    for (;;)
    {
        // Move to next scope change (note we only get enter/exit scope for blocks)
        IFR( BlockMove( pEditorDoc, pPointer, direction, TRUE, &context, &spElement) );

        switch (context)
        {
            case CONTEXT_TYPE_ExitScope:
                if (!spElement || !fExpanded)
                    goto FoundBlockLimit; // went too far
                
                // Make sure we didn't exit the body
                IFR( pEditorDoc->GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_BODY)
                {
                    fLeaveInside = FALSE; // force adjustment
                    goto FoundBlockLimit;
                }

                // Check for flow layout
                IFR(IsBlockOrLayoutOrScrollable(spElement, NULL, &bLayout));
                if (bLayout)
                    goto FoundBlockLimit;
                
                fFoundExitScope = TRUE;                
                break;

            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                if (fFoundExitScope)
                    goto FoundBlockLimit;
                break;

            case CONTEXT_TYPE_EnterScope:
                Assert(IsBlockCommandLimit( pEditorDoc->GetMarkupServices(), spElement, context)); 
                IFR(IsBlockOrLayoutOrScrollable(spElement, NULL, &bLayout));
                goto FoundBlockLimit;
        }
    }
    
FoundBlockLimit:
    
    if (fLeaveInside || (bLayout && !fCanCrossLayout))
        IFR( BlockMoveBack( pEditorDoc, pPointer, direction, TRUE, pContext, ppElement) );    

    RRETURN(hr);
}

BOOL 
EdUtil::IsBlockCommandLimit( IMarkupServices* pMarkupServices, 
                             IHTMLElement *pElement, 
                             MARKUP_CONTEXT_TYPE context) 
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BOOL            fBlock, fLayout;

    switch (context)
    {
        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_Text:
            return FALSE;
    }

    //
    // Check exceptions
    //
    
    IFR( pMarkupServices->GetElementTagId(pElement, &tagId) );
    switch (tagId)     
    {
        case TAGID_BUTTON:
        case TAGID_COL:
        case TAGID_COLGROUP:
        case TAGID_TBODY:
        case TAGID_TFOOT:
        case TAGID_TH:
        case TAGID_THEAD:
        case TAGID_TR:
            return FALSE;            
    }

    //
    // Otherwise, return IsBlockElement || IsLayoutElement
    //
    
    IFR(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    return (fBlock || fLayout);    
}

HRESULT 
EdUtil::BlockMove(
    CEditorDoc              *pEditorDoc,
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    HRESULT                 hr;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;
    SP_IMarkupPointer       spPointer;

    Assert(direction == LEFT || direction == RIGHT);

    if (!fMove)
    {
        IFR( CreateMarkupPointer2(pEditorDoc, &spPointer) );
        IFR( spPointer->MoveToPointer(pMarkupPointer) );
        
        pMarkupPointer = spPointer; // weak ref 
    }
    
    for (;;)
    {
        if (direction == LEFT)
            IFC( pMarkupPointer->Left( TRUE, &context, &spElement, NULL, NULL) )
        else
            IFC( pMarkupPointer->Right( TRUE, &context, &spElement, NULL, NULL) );

        switch (context)
        {
            case CONTEXT_TYPE_Text:
                goto Cleanup; // done

            case CONTEXT_TYPE_EnterScope:
                if (IsIntrinsic(pEditorDoc->GetMarkupServices(), spElement))
                {
                    if (direction == LEFT)
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement
, ELEM_ADJ_BeforeBegin ) )
                    else
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement
, ELEM_ADJ_AfterEnd ) ); 

                    continue;    
                }
                // fall through
                
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_NoScope:
                        if (!spElement || IsBlockCommandLimit( pEditorDoc->GetMarkupServices(), spElement, context))
                    goto Cleanup; // done;
                break;  

            default:
                hr = E_FAIL; // CONTEXT_TYPE_None
                goto Cleanup;
        }
    }
    
Cleanup:
    if (ppElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppElement = spElement;
            if (*ppElement)
                (*ppElement)->AddRef();
        }
        else
        {
            *ppElement = NULL;
        }
    }
        
    if (pContext)
    {
        *pContext = (SUCCEEDED(hr)) ? context : CONTEXT_TYPE_None;
    }    

    RRETURN(hr);
}

HRESULT 
EdUtil::BlockMoveBack(
    CEditorDoc              *pEditorDoc,
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    if (direction == RIGHT)
    {
        RRETURN(BlockMove( pEditorDoc, pMarkupPointer, LEFT, fMove, pContext, ppElement));
    }
    else
    {
        Assert(direction == LEFT);
        RRETURN(BlockMove(pEditorDoc, pMarkupPointer, RIGHT, fMove, pContext, ppElement));
    }
}

BOOL
EdUtil::IsIntrinsic( IMarkupServices* pMarkupServices,
                     IHTMLElement* pIHTMLElement )
{                     
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fIntrinsic = FALSE;
    
    IFC( pMarkupServices->GetElementTagId( pIHTMLElement, &eTag ));

    switch( eTag )
    {
        case TAGID_BUTTON:
        case TAGID_TEXTAREA:
        case TAGID_INPUT:
//        case TAGID_HTMLAREA:
        case TAGID_FIELDSET:
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_SELECT:
            fIntrinsic = TRUE;
            break;

        default:
            fIntrinsic = IsMasterElement( pMarkupServices, pIHTMLElement) == S_OK ;            
    }
    
Cleanup:
    return fIntrinsic;
}   

//+==============================================================================
//
//  Method:     MovePointerToText
//
//  Synopsis:   This routine moves the passed in markup pointer until in the 
//              specified direction until it hits either text or a layout 
//              boundary.
//
//+==============================================================================

HRESULT
EdUtil::MovePointerToText( 
    CEditorDoc *        pEditorDoc,
    IMarkupPointer *    pOrigin, 
    Direction           eDir,
    IMarkupPointer *    pBoundary,
    BOOL *              pfHitText,
    BOOL fStopAtBlock ) 
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fDone = FALSE;
    INT                 iResult = 0;
    ELEMENT_TAG_ID      eTag;
    LONG                cch = 1;
    
    // Interface Pointers
    IHTMLElement      * pHTMLElement = NULL;
    IMarkupPointer    * pTemp = NULL;

    *pfHitText = FALSE;

    hr = THR( CreateMarkupPointer2( pEditorDoc, & pTemp ) );
    if (! hr)   hr = THR( pTemp->MoveToPointer( pOrigin ) );
    if (hr)
        goto Cleanup;
    
    // Rule #2 - walk in the appropriate direction looking for text or a noscope.
    // If we happen to enter the scope of another element, fine. If we try to leave
    // the scope of an element, bail.
    
    while ( ! fDone )
    {
        ClearInterface( & pHTMLElement );

        //
        // Check to see if we hit the boundary of our search
        //
        // If the pointer is beyond the boundary, fall out
        // boundary left of pointer =  -1
        // boundary equals pointer =    0
        // boundary right of pointer =  1
        //
        
        IGNORE_HR( OldCompare( pBoundary, pTemp , &iResult ));

        if((     eDir == LEFT && iResult > -1 ) 
            || ( eDir == RIGHT && iResult < 1 ))
        {
            goto Cleanup;    // this is okay since CR_Boundary does not move the pointer
        }
        
        //    
        // Move in the appropriate direction...
        //
        
        if( eDir == LEFT )
            hr = THR( pTemp->Left( TRUE, & ct, & pHTMLElement, &cch, NULL ) );
        else
            hr = THR( pTemp->Right(TRUE, & ct, & pHTMLElement, &cch, NULL ) );
        if( hr )
            goto Cleanup;
            
        switch( ct )
        {
            case CONTEXT_TYPE_Text:

                //
                // Hit text - done
                //
                
                *pfHitText = TRUE;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_NoScope:

                //
                // Only stop if we hit a renderable (layout-ness) noscope
                // TODO : figure out if this is a glyph boundary
                //
                
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;
                    BOOL fIsBlock = FALSE;
                    
                    IFC( pEditorDoc->GetMarkupServices()->GetElementTagId( pHTMLElement, &eTag ));
                    IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, &fIsBlock, &fHasLayout));

                    if( fHasLayout || 
                        ( fIsBlock && fStopAtBlock ) || 
                        eTag == TAGID_BR )
                    {
                        *pfHitText = TRUE;
                        fDone = TRUE;
                    }
                }
                
                break;
            
            case CONTEXT_TYPE_EnterScope:
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;

                    //
                    // Only stop for intrinsics, otherwise pass on through
                    // TODO: Figure out if this is a glyph boundary
                    //
                    //  Also, it seems wrong to not stop for layout boundaries
                    //
                    BOOL fIntrinsic  = IsIntrinsic( pEditorDoc->
GetMarkupServices(), pHTMLElement);
                    if ( fIntrinsic )
                    {
                        *pfHitText = fDone;
                        fDone = TRUE;
                    }
                    else
                    {
                        IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, NULL, &fHasLayout));
                        if (fHasLayout)
                        {
                            *pfHitText = fDone;
                            fDone = TRUE;
                        }
                    }

                }

                break;

            // TODO : Figure out if the range needs this or if we don't need this

            case CONTEXT_TYPE_ExitScope:
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;
                    BOOL fIsBlock = FALSE;
                    
                    IFC( pEditorDoc->GetMarkupServices()->GetElementTagId( pHTMLElement, &eTag ));
                    IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, &fIsBlock, &
fHasLayout));

                    if( fHasLayout || 
                      ( fIsBlock && fStopAtBlock ) || 
                      eTag == TAGID_BR )
                    {
                        fDone = TRUE;
                    }
                }
                
                break;                 

            case CONTEXT_TYPE_None:
                fDone = TRUE;
                break;
        }        
    }

    //
    // If we found text, move our pointer
    //
    
    if( *pfHitText )
    {
        //
        // We have inevitably gone one move too far, back up one move
        //
    
        if( eDir == LEFT )
            hr = THR( pTemp->Right(TRUE, & ct, NULL, &cch, NULL ) );
        else
            hr = THR( pTemp->Left( TRUE, & ct, NULL, &cch, NULL ) );
        if( hr )
            goto Cleanup;
            
        hr = THR( pOrigin->MoveToPointer( pTemp ));
    }
    
Cleanup:
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pTemp );
    RRETURN( hr );
}


HRESULT 
EdUtil::FindListContainer( IMarkupServices *pMarkupServices,
                           IHTMLElement    *pElement,
                           IHTMLElement    **ppListContainer )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;    
    BOOL                            bLayout;

    *ppListContainer = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (IsListContainer(tagId)) // found container
        {
            *ppListContainer = spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            

        IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &bLayout));
        if (bLayout)
            return S_OK; // done - don't cross layout
            
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
}

BOOL
EdUtil::HasNonBodyContainer( IMarkupServices *pMarkupServices,
                             IHTMLElement    *pElement )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;    

    spCurrentElement = pElement;
    do
    {
        IFC( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (TAGID_INPUT == tagId ||
            TAGID_TEXTAREA == tagId ||
            TAGID_BUTTON == tagId ||
            TAGID_LEGEND == tagId ||
            TAGID_MARQUEE == tagId)
        {
            return TRUE;
        }            

        IFC( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

Cleanup:
    return FALSE;        
}

HRESULT 
EdUtil::FindListItem( IMarkupServices *pMarkupServices,
                      IHTMLElement    *pElement,
                      IHTMLElement    **ppListContainer )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;
    BOOL                            bLayout;

    *ppListContainer = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (IsListItem(tagId)) // found container
        {
            *ppListContainer = spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            
            
        IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &bLayout));
        if (bLayout)
            return S_OK; // done - don't cross layout
            
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
}

HRESULT 
EdUtil::InsertBlockElement(
    IMarkupServices *pMarkupServices, 
    IHTMLElement    *pElement, 
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd, 
    IMarkupPointer  *pCaret)
{
    HRESULT             hr;
    BOOL                bAdjustStart = FALSE;
    BOOL                bAdjustEnd = FALSE;
    

    //
    // Do we need to adjust the pointer after insiertion?
    //

    IFR( pCaret->IsEqualTo(pStart, &bAdjustStart) );    
    if (!bAdjustStart)
    {
        IFR( pCaret->IsEqualTo(pEnd, &bAdjustEnd) );    
    }

    //
    // Insert the element
    //
    
    IFR( InsertElement(pMarkupServices, pElement, pStart, pEnd) );

    //
    // Fixup the pointer
    //
    
    if (bAdjustStart)
    {
        IFR( pCaret->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterBegin) );
    }
    else if (bAdjustEnd)
    {
        IFR( pCaret->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeEnd) );
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NextEventTime
//
//  Synopsis:   Returns a value which can be use to determine when a given
//              number of milliseconds has passed.
//
//  Arguments:  [ulDelta] -- Number of milliseconds after which IsTimePassed
//                           will return TRUE.
//
//  Returns:    A timer value.  Guaranteed not to be zero.
//
//  Notes:      Due to the algorithm used in IsTimePassed, [ulDelta] cannot
//              be greater than ULONG_MAX/2.
//
//----------------------------------------------------------------------------

ULONG
EdUtil::NextEventTime(ULONG ulDelta)
{
    ULONG ulCur;
    ULONG ulRet;

    Assert(ulDelta < ULONG_MAX/2);

    ulCur = GetTickCount();

    if ((ULONG_MAX - ulCur) < ulDelta)
        ulRet = ulDelta - (ULONG_MAX - ulCur);
    else
        ulRet = ulCur + ulDelta;

    if (ulRet == 0)
        ulRet = 1;

    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsTimePassed
//
//  Synopsis:   Returns TRUE if the current time is later than the given time.
//
//  Arguments:  [ulTime] -- Timer value returned from NextEventTime().
//
//  Returns:    TRUE if the current time is later than the given time.
//
//----------------------------------------------------------------------------

BOOL
EdUtil::IsTimePassed(ULONG ulTime)
{
    ULONG ulCur = GetTickCount();

    if ((ulCur > ulTime) && (ulCur - ulTime < ULONG_MAX/2))
        return TRUE;

    return FALSE;
}


            
BOOL
EdUtil::SameElements(
    IHTMLElement *      pElement1,
    IHTMLElement *      pElement2 )
{
    HRESULT hr = S_OK;
    BOOL fEqual = FALSE;

    IObjectIdentity * pId1 = NULL;

    if( pElement1 == NULL || pElement2 == NULL )
        goto Cleanup;
        
    IFC( pElement1->QueryInterface( IID_IObjectIdentity , (LPVOID *) & pId1 ));
    hr = pId1->IsEqualObject( pElement2 );
    fEqual = ( hr == S_OK );
    
Cleanup:
    ReleaseInterface( pId1 );
    return fEqual;
}


//+====================================================================================
//
// Method: EquivalentElements
//
// Synopsis: Test elements for 'equivalency' - ie if they are the same element type,
//           and have the same class, id , and style.
//
//------------------------------------------------------------------------------------

BOOL 
EdUtil::EquivalentElements( 
            IMarkupServices* pMarkupServices, IHTMLElement* pIElement1, IHTMLElement* pIElement2 )
{
    ELEMENT_TAG_ID eTag1 = TAGID_NULL;
    ELEMENT_TAG_ID eTag2 = TAGID_NULL;
    BOOL fEquivalent = FALSE;
    HRESULT hr = S_OK;
    IHTMLStyle * pIStyle1 = NULL;
    IHTMLStyle * pIStyle2 = NULL;
    BSTR id1 = NULL;
    BSTR id2 = NULL;
    BSTR class1 = NULL;
    BSTR class2 = NULL;
    BSTR style1 = NULL;
    BSTR style2 = NULL;
    
    IFC( pMarkupServices->GetElementTagId( pIElement1, & eTag1 ));
    IFC( pMarkupServices->GetElementTagId( pIElement2, & eTag2 ));

    //
    // Compare Tag Id's
    //
    if ( eTag1 != eTag2 )
        goto Cleanup;

    //
    // Compare Id's
    //
    IFC( pIElement1->get_id( & id1 ));
    IFC( pIElement2->get_id( & id2 ));

    if ((( id1 != NULL ) || ( id2 != NULL )) && 
        ( StrCmpIW( id1, id2) != 0))
        goto Cleanup;

    //
    // Compare Class
    //
    IFC( pIElement1->get_className( & class1 ));
    IFC( pIElement2->get_className( & class2 ));

        
    if ((( class1 != NULL ) || ( class2 != NULL )) &&
        ( StrCmpIW( class1, class2) != 0 ) )
        goto Cleanup;

    //
    // Compare Style's
    //        
    IFC( pIElement1->get_style( & pIStyle1 ));
    IFC( pIElement2->get_style( & pIStyle2 ));
    IFC( pIStyle1->toString( & style1 ));
    IFC( pIStyle2->toString( & style2 ));
       
    if ((( style1 != NULL ) || ( style2 != NULL )) &&
        ( StrCmpIW( style1, style2) != 0 ))
        goto Cleanup;

    fEquivalent = TRUE;        
Cleanup:
    SysFreeString( id1 );
    SysFreeString( id2 );
    SysFreeString( class1 );
    SysFreeString( class2 );
    SysFreeString( style1 );
    SysFreeString( style2 );
    ReleaseInterface( pIStyle1 );
    ReleaseInterface( pIStyle2 );
    
    AssertSz(!FAILED(hr), "Unexpected failure in Equivalent Elements");

    return ( fEquivalent );
}

HRESULT 
EdUtil::InsertElement(IMarkupServices *pMarkupServices, IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT                         hr;
    BOOL                            bBlock, bLayout;
    ELEMENT_TAG_ID                  tagId;
    
    IFR( pMarkupServices->InsertElement(pElement, pStart, pEnd) );

    //
    // Set additional attributes
    //

    IFR(IsBlockOrLayoutOrScrollable(pElement, &bBlock, &bLayout));

    if (bBlock && !bLayout)
    {
        IFR( pMarkupServices->GetElementTagId(pElement, &tagId) );
        if (!IsListContainer(tagId) && tagId != TAGID_LI)
        {
            SP_IHTMLElement3 spElement3;
            IFR( pElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
            IFR( spElement3->put_inflateBlock( VARIANT_TRUE ) );
        }
    }

    return S_OK;
}

HRESULT 
EdUtil::FindTagAbove( IMarkupServices *pMarkupServices,
                      IHTMLElement    *pElement,
                      ELEMENT_TAG_ID  tagIdGoal,
                      IHTMLElement    **ppElement,
                      BOOL            fStopAtLayout)
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;
    BOOL                            fSite;
    
    *ppElement = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (tagId == tagIdGoal) // found container
        {
            *ppElement= spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            

        if (fStopAtLayout)
        {
            IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &fSite));
            if (fSite)
                break;                
        }
        
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
    
}


//
// Review-2000/07/25-zhenbinx: 
//      We should make sure this func is always in sync with Trident!!!
//
#define lcidKashmiri 0x0860
#define lcidUrduIndia     0x0820
BOOL
EdUtil::IsBidiEnabled(VOID)
{
    HKL aHKL[32];
    UINT uKeyboards = GetKeyboardLayoutList(32, aHKL);
    // check all keyboard layouts for existance of a RTL language.
    // bounce out when the first one is encountered.
    for(UINT i = 0; i < uKeyboards; i++)
    {
        LCID lcid = LOWORD(aHKL[i]);
        switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
        {
            case LANG_ARABIC:
            case LANG_FARSI:
            case LANG_HEBREW:
            case LANG_KASHMIRI:
                if (lcid == lcidKashmiri)
                    return FALSE;
            case LANG_PASHTO:
            case LANG_SINDHI:
            case LANG_SYRIAC:
            case LANG_URDU:
                if (lcid == lcidUrduIndia)
                    return FALSE;
            case LANG_YIDDISH:
                return TRUE;
        }
    }

    /*
    //
    // We don't want this as of now. 
    //
    {
        //
        // If there is no Bidi keyboard present. Check to see
        // if Bidi is enabled (Mirroring API enabled)
        // Should we check for existence of Bidi language pack
        // instead???
        //
        OSVERSIONINFOA osvi;
        osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);

        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion >= 5)
        {
            // NT 5
            s_fEnabled = TRUE;
        }
        else if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId &&
                 (osvi.dwMajorVersion > 4 || osvi.dwMajorVersion == 4 && osvi.dwMinorVersion >= 10)
                )
        {
            if (::GetSystemMertics(SM_MIDEASTENABLED))
            {
                s_fEnabled = TRUE;
            }
        }
    }
    */
    return FALSE;
}



BOOL 
EdUtil::IsRtfConverterEnabled(IDocHostUIHandler *pDocHostUIHandler)
{
    BOOL   fConvf = FALSE;
#ifndef NO_RTF
    static TCHAR pchKeyPath[] = _T("Software\\Microsoft\\Internet Explorer");

    CPINFO cpinfo;
    LONG   lRet;
    HKEY   hKeyRoot = NULL;
    HKEY   hKeySub  = NULL;
    DWORD  dwConvf = RTFCONVF_ENABLED;
    DWORD  dwType;
    DWORD  dwData;
    DWORD  dwSize = sizeof(DWORD);
    TCHAR *pstr = NULL;

    if (pDocHostUIHandler)
        pDocHostUIHandler->GetOptionKeyPath(&pstr, 0);

    if (!pstr)
        pstr = pchKeyPath;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, pstr, 0, KEY_READ, &hKeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Cleanup;

    lRet = RegOpenKeyEx(hKeyRoot, NULL, 0, KEY_READ, &hKeySub);
    if (lRet != ERROR_SUCCESS)
        goto Cleanup;

    Assert(hKeySub != hKeyRoot);
    
    lRet = RegQueryValueEx(hKeySub, _T("RtfConverterFlags"), 0, &dwType, (BYTE*)&dwData, &dwSize);
    if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
        dwConvf = dwData;
    //
    // Rtf conversions can be disabled on an sbcs-dbcs basis, or even
    // completely.  See the RTFCONVF flags in formkrnl.hxx.
    //
    fConvf = (dwConvf & RTFCONVF_ENABLED) &&
             ((dwConvf & RTFCONVF_DBCSENABLED) ||
              (GetCPInfo(GetACP(), &cpinfo) && cpinfo.MaxCharSize == 1));

Cleanup:
    if (pstr != pchKeyPath)
        CoTaskMemFree(pstr);

    if (hKeySub)
        RegCloseKey(hKeySub);

    if (hKeyRoot)
        RegCloseKey(hKeyRoot);
#endif

    return fConvf;
}

HRESULT 
EdUtil::IsBlockOrLayoutOrScrollable(IHTMLElement* pIElement, BOOL *pfBlock, BOOL *pfLayout, BOOL *pfScrollable)
{
    HRESULT hr;
    VARIANT_BOOL fBlock = VB_FALSE;
    VARIANT_BOOL fLayout = VB_FALSE;
    BOOL fScrollable = FALSE;
    BSTR bstrDisplay = NULL;
    BSTR bstrOverflow = NULL;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    SP_IHTMLCurrentStyle2 spCurrStyle2;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;

    IFC( spCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&spCurrStyle2) );

    if (pfBlock)
    {
        IFC( spCurrStyle2->get_isBlock(&fBlock) );
    }

    if (pfLayout || pfScrollable)
    {
        IFC(spCurrStyle2->get_hasLayout(&fLayout));
    }

    if (pfScrollable)
    {
        IFC( spCurrStyle->get_overflow(&bstrOverflow) );
        if (_tcscmp(bstrOverflow, _T("scroll")) == 0)
        {
            fScrollable = TRUE;
        }
        else if (fLayout && _tcscmp(bstrOverflow, _T("auto")) == 0)
        {
            LONG lClientHeight;
            LONG lScrollHeight;

            IFC( spElement2->get_clientHeight(&lClientHeight) );
            IFC( spElement2->get_scrollHeight(&lScrollHeight) );

            fScrollable = (lClientHeight < lScrollHeight);
        }
    }
    
Cleanup:
    if (pfBlock)
        *pfBlock = fBlock ? TRUE : FALSE;

    if (pfScrollable)
        *pfScrollable = fScrollable;

    if (pfLayout)
        *pfLayout = fLayout ? TRUE : FALSE;
    
    SysFreeString(bstrDisplay);
    SysFreeString(bstrOverflow);
    RRETURN(hr);
}

HRESULT
EdUtil::GetScrollingElement(IMarkupServices *pMarkupServices, IMarkupPointer *pPosition, IHTMLElement *pIBoundary, IHTMLElement **ppElement, BOOL fTreatInputsAsScrollable /*=FALSE*/)
{
    HRESULT hr;
    BOOL fScrollable = FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spParent;
    SP_IObjectIdentity spIdent;

    *ppElement = NULL;

    if (pIBoundary)
        IFC(pIBoundary->QueryInterface(IID_IObjectIdentity, (void **)&spIdent));
    IFC(pPosition->CurrentScope(&spElement));

    if (fTreatInputsAsScrollable)
    {
        ELEMENT_TAG_ID  eTag;

        IFC( pMarkupServices->GetElementTagId( spElement, &eTag ) );
        if (eTag == TAGID_INPUT)
        {
            *ppElement = spElement;
            spElement->AddRef();
            goto Cleanup;
        }
    }

    while( spElement )
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, NULL, &fScrollable));
        if (fScrollable)
        {
            *ppElement = spElement;
            spElement->AddRef();
            break;
        }

        //  Make sure we do not go beyond our boundary, if we are given one.
        if ( spIdent )
        {
            hr = THR(spIdent->IsEqualObject(spElement));
            if (hr == S_OK)
                break;
        }

        IFC(GetParentElement(pMarkupServices, spElement, &spParent));
        spElement = spParent;
    }

Cleanup:
    RRETURN(hr);
}




BOOL 
EdUtil::IsTablePart( ELEMENT_TAG_ID eTag )
{
    return ( ( eTag == TAGID_TD ) ||
       ( eTag == TAGID_TR ) ||
       ( eTag == TAGID_TBODY ) || 
       ( eTag == TAGID_TFOOT ) || 
       ( eTag == TAGID_TH ) ||
       ( eTag == TAGID_THEAD ) ||
       ( eTag == TAGID_CAPTION ) ||
       ( eTag == TAGID_TC )  ||        
       ( eTag == TAGID_COL ) || 
       ( eTag == TAGID_COLGROUP )); 
}

//+----------------------------------------------------------------------------
//
//  Functions:  ParentElement
//
//  Synopsis:   Gets parent element using param as in/out.
//
//-----------------------------------------------------------------------------
HRESULT
EdUtil::ParentElement(IMarkupServices *pMarkupServices, IHTMLElement **ppElement)
{
    HRESULT         hr;
    IHTMLElement    *pOldElement;
    
    Assert(ppElement && *ppElement);

    pOldElement = *ppElement;
    hr = THR( GetParentElement(pMarkupServices, pOldElement, ppElement) );
    pOldElement->Release();

    RRETURN(hr);
}


HRESULT 
EdUtil::CopyPointerGravity(IDisplayPointer *pDispPointerSource, IMarkupPointer *pPointerTarget)
{
    HRESULT hr;
    POINTER_GRAVITY eGravity;

    IFC( pDispPointerSource->GetPointerGravity(&eGravity) );
    IFC( pPointerTarget->SetGravity(eGravity) );

Cleanup:
    RRETURN(hr);
}    

HRESULT 
EdUtil::CopyPointerGravity(IDisplayPointer *pDispPointerSource, IDisplayPointer *pDispPointerTarget)
{
    HRESULT hr;
    POINTER_GRAVITY eGravity;

    IFC( pDispPointerSource->GetPointerGravity(&eGravity) );
    IFC( pDispPointerTarget->SetPointerGravity(eGravity) );

Cleanup:
    RRETURN(hr);
}    

HRESULT
EdUtil::IsLayout( IHTMLElement* pIElement )
{

    HRESULT hr ;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    SP_IHTMLCurrentStyle2 spCurrStyle2;
    VARIANT_BOOL fLayout = VB_FALSE;
    
    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;    

    IFC(spCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&spCurrStyle2));
    IFC(spCurrStyle2->get_hasLayout(&fLayout));

    hr = fLayout ? S_OK : S_FALSE ; 

Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT
EdUtil::GetLayoutElement(IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement)
{
    HRESULT hr = S_OK ;
    SP_IHTMLElement spCurElement ;
    SP_IHTMLElement spNextElement;
    BOOL fLayout = FALSE;
    
    Assert( pIElement && ppILayoutElement );
    
    ReplaceInterface( & spCurElement,(IHTMLElement*) pIElement);

    fLayout = IsLayout( spCurElement) == S_OK ;
    
    while( ! fLayout )
    {
        IFC( GetParentElement(pMarkupServices, spCurElement, &spNextElement) );
        if ( ! spNextElement.IsNull() )
        {
            spCurElement = (IHTMLElement*) spNextElement ;
            fLayout = IsLayout( spCurElement) == S_OK ;
        }   
        else
            break;
    }

    if ( fLayout )
    {
        *ppILayoutElement = spCurElement;
        (*ppILayoutElement)->AddRef();
    }
    else
    {
        hr = S_FALSE;
    }
    
Cleanup:
    RRETURN1( hr , S_FALSE );
}


HRESULT
EdUtil::GetParentLayoutElement(IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement)
{
    HRESULT hr;
    SP_IHTMLElement spCurLayout;
    SP_IHTMLElement spParentLayout;
    
    Assert( pIElement && ppILayoutElement );
    
    IFHRC( GetLayoutElement( pMarkupServices, pIElement, &spCurLayout)); 
    IFC( GetParentElement(pMarkupServices, spCurLayout, &spParentLayout) );
    if ( ! spParentLayout.IsNull() ) 
    {
        spCurLayout = (IHTMLElement*) spParentLayout ;
        IFHRC( GetLayoutElement( pMarkupServices, spCurLayout, & spParentLayout ));    

        Assert( ! spParentLayout.IsNull() && IsLayout( spParentLayout) == S_OK );    
        *ppILayoutElement = spParentLayout;
        (*ppILayoutElement)->AddRef();
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr , S_FALSE);
}

HRESULT
EdUtil::BecomeCurrent( IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement3 spElement3;
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: fire Events
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnEvent(wchar_t *pStrEvent, IHTMLElement* pIElement, BOOL fIsContextEditable)
{
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL fRet = VB_TRUE;
   
    if ( pIElement && fIsContextEditable )
    {
        IGNORE_HR(pIElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IGNORE_HR(spElement3->fireEvent(pStrEvent, NULL, &fRet));
    }
    return !!fRet;
}



//+====================================================================================
//
// Method: fire Events
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireEvent(wchar_t *pStrEvent, IHTMLElement* pIElement )
{
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL fRet = VB_TRUE;
   
    if ( pIElement  )
    {
        IGNORE_HR(pIElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IGNORE_HR(spElement3->fireEvent(pStrEvent, NULL, &fRet));
    }
    return !!fRet;
}

//+====================================================================================
//
// Method: fire On Before Copy
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnBeforeCopy(IHTMLElement* pIElement)
{
     return FireEvent(_T("onbeforecopy"), pIElement);
}

//+====================================================================================
//
// Method: fire On Before Cut
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnBeforeCut(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onbeforecut"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before Cut
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnCut(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("oncut"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before EditFocus
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL
EdUtil::FireOnBeforeEditFocus( IHTMLElement* pIElement , BOOL fIsParentContextEditable )
{
   return FireOnEvent(_T("onbeforeeditfocus"), pIElement, fIsParentContextEditable);
}    

//+====================================================================================
//
// Method: fire On SelectStart
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnSelectStart(IHTMLElement* pIElement)
{
    return FireEvent(_T("onselectstart"), pIElement );
}

//+====================================================================================
//
// Method: fire On Control Selection 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
    EdUtil::FireOnControlSelect(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireEvent(_T("oncontrolselect"), pIElement );
}

//+====================================================================================
//
// Method: fire On Resize
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResize(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresize"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire while its moving
//
// Synopsis:
//
//------------------------------------------------------------------------------------

BOOL 
EdUtil::FireOnMove(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmove"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before Resizing starts 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResizeStart(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresizestart"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On after resizing is done
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResizeEnd(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresizeend"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On move starting 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnMoveStart(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmovestart"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On move ending
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnMoveEnd(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmoveend"), pIElement, fIsContextEditable);
}

HRESULT
EdUtil::IsEditable( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbEditable ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_isContentEditable( & vbEditable ));

    hr = vbEditable == VB_TRUE ? S_OK : S_FALSE;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsParentEditable(IMarkupServices *pMarkupServices,  IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spParentElement = pIElement;

    IFC( GetParentElement(pMarkupServices, pIElement, &spParentElement ));
    if( spParentElement )
    {
        hr = THR( IsEditable( spParentElement ));
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsMasterParentEditable(IMarkupServices *pMarkupServices,  IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spParentElement = pIElement;

    IFC( GetParentElement(pMarkupServices, pIElement, &spParentElement ));
    if( spParentElement )
    {
        if (IsMasterElement( pMarkupServices, spParentElement ) == S_OK)
        {
            hr = THR( IsMasterParentEditable(pMarkupServices, spParentElement) );
        }
        else
        {
            hr = THR( IsEditable( spParentElement ));
        }
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );
}

//
// Check to see if jsut a given element is editable
//
HRESULT
EdUtil::IsContentEditable( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    BSTR bstrContentEditable = NULL;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_contentEditable( & bstrContentEditable ));

    if( ! StrCmpICW ( bstrContentEditable, L"true"))
        hr = S_OK;
    else
        hr = S_FALSE; 
    
Cleanup:
    ::SysFreeString( bstrContentEditable);
    RRETURN1( hr , S_FALSE );
}


HRESULT
EdUtil::IsNoScopeElement(IHTMLElement* pIElement, ELEMENT_TAG_ID eTag)
{
    HRESULT hr;
    VARIANT_BOOL vbCanHaveChildren;
    SP_IHTMLElement2 spElement2;
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));
    IFC( spElement2->get_canHaveChildren( & vbCanHaveChildren));

    //
    // Select elements cannot have TEXT children.. only OPTION children
    // the editor needs to treat them as no-scopes
    //
    hr = ( vbCanHaveChildren == VB_TRUE && eTag != TAGID_SELECT ) ? S_FALSE : S_OK;

Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
EdUtil::GetOutermostLayout( IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    HRESULT hr;
    SP_IHTMLElement spCurLayout;
    SP_IHTMLElement spNextElement;
    Assert( pIElement && ppILayoutElement );

    IFHRC( GetLayoutElement( pMarkupServices, pIElement, & spCurLayout ));
    
    while( ! spCurLayout.IsNull() )
    {
        if ( GetParentLayoutElement( pMarkupServices, spCurLayout, & spNextElement) == S_OK )
        {
            spCurLayout = spNextElement;
        }
        else
            break;
    }

    if ( ! spCurLayout.IsNull() &&
         IsLayout( spCurLayout ) == S_OK )
    {
        hr = S_OK;
        *ppILayoutElement = spCurLayout;
        (*ppILayoutElement)->AddRef();
    }
    else
    {
        hr = S_FALSE;
    }
Cleanup:   
    RRETURN1( hr, S_FALSE );
}   


HRESULT
EdUtil::IsEnabled(IHTMLElement* pIElement)
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbDisabled ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_disabled( & vbDisabled ));

    hr = vbDisabled == VB_TRUE ? S_FALSE : S_OK;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
EdUtil::BecomeCurrent( IHTMLDocument2 * pIDoc, IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement spActiveElement;
    SP_IObjectIdentity spIdent;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;            
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());

    //
    // workaround until bug 100033 is fixed - we want setActive to return a result code
    // indicating success or failure
    // 
    IFC( pIElement->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
    IFC( spElemDoc->get_activeElement( & spActiveElement ));

    if( spActiveElement )
    {
        IFC( spActiveElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        hr = THR( spIdent->IsEqualObject( pIElement ));        
    }
    else
        hr = S_FALSE;
    
 
Cleanup:
    RRETURN1( hr, S_FALSE );
}




//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::IsContentElement
//
//  Synopsis:   See's if this elmenet is a 'content element' - ie a slave
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------

HRESULT
EdUtil::IsContentElement( IMarkupServices *pMS, IHTMLElement * pIElement )
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;
    SP_IHTMLElement spElement;
    
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spPointer ));
    IFC( spPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));        
    IFC( spPointer->CurrentScope( & spElement ));    

    hr =  spElement.IsNull() ? S_OK : S_FALSE; // the element responsible for laying me out isn't me.

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::IsMasterElement
//
//  Synopsis:   See's if this elmeent is a master
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------
HRESULT
EdUtil::IsMasterElement( IMarkupServices* pMS, IHTMLElement* pIElement )
{   
    HRESULT hr ;
    ELEMENT_TAG_ID eTag;
    SP_IMarkupPointer spPointer;
    SP_IMarkupPointer2 spPointer2;
    SP_IMarkupPointer spElemPointer;
    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer spContainer2;
    IUnknown* pUnk1 = NULL ;
    IUnknown* pUnk2 = NULL ;
        
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spPointer ));
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spElemPointer ));
    
    IFC( spPointer->QueryInterface( IID_IMarkupPointer2, (void**) & spPointer2));
    hr = THR( spPointer2->MoveToContent( pIElement, TRUE ));

    if ( hr == E_INVALIDARG )
    {
        IFC( pMS->GetElementTagId( pIElement, &eTag ) );
        
        if ( IsNoScopeElement( pIElement, eTag ) == S_OK  )
        {
            hr = S_FALSE; // No scopes are assumed not to be master elements if MoveToContent fails.           
        }
        goto Cleanup;
    }
    
    IFC( spElemPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin));

    IFC( spPointer->GetContainer( & spContainer ));
    IFC( spElemPointer->GetContainer( & spContainer2 ));

    IFC( spContainer->QueryInterface( IID_IUnknown, (void**) & pUnk1 ));
    IFC( spContainer2->QueryInterface( IID_IUnknown, (void**) & pUnk2 ));

    hr = ( pUnk1 != pUnk2 ) ? S_OK : S_FALSE ; // is a master if content is in different markup than myself

Cleanup:
    ReleaseInterface( pUnk1 );
    ReleaseInterface( pUnk2 );

    RRETURN1( hr , S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::GetMasterElement
//
//  Synopsis:   Gets the Master Element
//
//----------------------------------------------------------------------------
HRESULT 
EdUtil::GetMasterElement( IMarkupServices *pMS, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPtr;          // Pointer to be positioned at content
    SP_IMarkupPointer2      spPtr2;         // IMarkupPointer2 interface
    SP_IMarkupContainer     spContainer;    // Container of pointer
    SP_IMarkupContainer2    spContainer2;
    
    Assert( ppILayoutElement && pIElement && pMS );
    
    IFC( MarkupServices_CreateMarkupPointer( pMS, &spPtr));
    IFC( spPtr->QueryInterface( IID_IMarkupPointer2, (void**) & spPtr2));

    hr = THR( spPtr2->MoveToContent( pIElement, TRUE ));
    if( FAILED(hr) )
    {
        // possible for images, and other noscopes.
        hr = THR( spPtr->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    }

    IFC( spPtr2->GetContainer( &spContainer ));
    IFC( spContainer->QueryInterface (IID_IMarkupContainer2, (void **)&spContainer2 ));
    IFC( spContainer2->GetMasterElement( ppILayoutElement ));

    if( !*ppILayoutElement )
    {
        hr = S_FALSE;
    }
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsPointerInMasterElementShadow( CEditorDoc *pEditor, IMarkupPointer* pPointer )
{
    HRESULT             hr = S_FALSE;
    BOOL                fInMasterShadow = FALSE;
    SP_IDisplayPointer     spDispPointer;
    SP_IHTMLElement      spStartElement;
    SP_IHTMLElement      spScopeElement;
    BOOL                 fPositioned = FALSE;
    if (pPointer == NULL)
    {
        Assert(pPointer);
        goto Cleanup;
    }

    IFC (pPointer->IsPositioned(&fPositioned));
    if (fPositioned)
    {
        IFC( pPointer->CurrentScope(&spScopeElement) );
        if (spScopeElement != NULL)
        {
            IFC( GetLayoutElement(pEditor->GetMarkupServices(), spScopeElement, &spStartElement) );
            if ( spStartElement && ( IsMasterElement(pEditor->GetMarkupServices(), spStartElement) == S_OK ) )
            {
                SP_IMarkupPointer       spMasterStartPointer;
                SP_IMarkupContainer     spMasterContainer;
                SP_IMarkupContainer     spStartContainer;

                //  If the markup container of the master element is the same as the markup container of
                //  pStart, then pStart is not in the master element's slave markup.  So, pStart is not
                //  in a position to be selected.  We bail.

                IFC( pEditor->CreateMarkupPointer( &spMasterStartPointer ));
                IFC( spMasterStartPointer->MoveAdjacentToElement( spStartElement, ELEM_ADJ_BeforeBegin ) );

                IFC( spMasterStartPointer->GetContainer( &spMasterContainer ) );
                IFC( pPointer->GetContainer( &spStartContainer ) );

                if ( IsEqual(spMasterContainer, spStartContainer) )
                {
                    fInMasterShadow = TRUE;
                }
            }
        }
    }

Cleanup:

    if ( SUCCEEDED(hr) )
        hr = (fInMasterShadow) ? S_OK : S_FALSE;
        
    RRETURN1(hr, S_FALSE);
}


//+====================================================================================
//
// Method: Between
//
// Synopsis: Am I in - between the 2 given pointers ?
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::Between( 
    IMarkupPointer* pTest,
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( pTest->IsRightOfOrEqualTo( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( pTest->IsLeftOfOrEqualTo( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}

//
// Same as between, but equality with endpoints returns false.
//
BOOL
EdUtil::BetweenExclusive( 
    IMarkupPointer* pTest,
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( pTest->IsRightOf( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( pTest->IsLeftOf( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}

//+---------------------------------------------------------------------
//
// Method: SegmentContainsElement
//
// Synopsis: Does this segment in anyway intersect a given element ?
//
//+---------------------------------------------------------------------

HRESULT
EdUtil::SegmentIntersectsElement(
                    CEditorDoc   *pEditor,
                    ISegmentList *pISegmentList, 
                    IHTMLElement *pIElement )
{
    HRESULT  hr;
    SP_ISegmentListIterator spIter;
    SP_ISegment       spSegment;
    SP_IMarkupPointer spStart, spEnd;               // segment boundaries
    SP_IMarkupPointer spStartElem, spEndElem;       // element boundaries
    BOOL fDoesNotIntersect = FALSE ;
    
    IFC( pEditor->CreateMarkupPointer( & spStart ));
    IFC( pEditor->CreateMarkupPointer( & spEnd ));
    IFC( pEditor->CreateMarkupPointer( & spStartElem ));
    IFC( pEditor->CreateMarkupPointer( & spEndElem ));

    IFC( spStartElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEndElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
    
    IFC( pISegmentList->CreateIterator( & spIter ));

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( spStart, spEnd ));

        IFC( spStartElem->IsRightOf( spEnd , & fDoesNotIntersect ));

        if ( ! fDoesNotIntersect )
        {
            IFC( spEndElem->IsLeftOf( spStart , & fDoesNotIntersect ));
        }

        if ( ! fDoesNotIntersect )
            break;
            
        IFC( spIter->Advance() );
    }

Cleanup:
    if ( ! FAILED(hr ))
    {
        hr = ! fDoesNotIntersect ? S_OK : S_FALSE;
    }
    
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     ArePointersInSameMarkup
//
//  Synopsis:   Determines the if the two markup pointers are in the same
//              container.
//
//  Arguments:  pIFirst = First markup pointer
//              pISecond = Second markup pointer
//              pfInSame = OUTPUT - Same container
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
EdUtil::ArePointersInSameMarkup( IMarkupPointer* pIFirst, IMarkupPointer * pISecond , BOOL* pfInSame)
{
    HRESULT hr = S_OK;
    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer spContainer2;
    IUnknown *pUnk1 = NULL;
    IUnknown *pUnk2 = NULL;

    Assert(pIFirst && pISecond);
    Assert(pfInSame);

    if (pfInSame)
        *pfInSame = FALSE;
    
    if (pIFirst && pISecond)
    {
        IFC( pIFirst->GetContainer(& spContainer ));
        IFC( pISecond->GetContainer( & spContainer2 ));

        if ( spContainer && spContainer2 )
        {
            IFC( spContainer->QueryInterface( IID_IUnknown, (void**) & pUnk1 ));
            IFC( spContainer2->QueryInterface( IID_IUnknown, (void**) & pUnk2 ));

            *pfInSame = ( pUnk1 == pUnk2 );
        }
    }

Cleanup: 
    ReleaseInterface( pUnk1 );
    ReleaseInterface( pUnk2 );
    RRETURN( hr );
}

HRESULT
EdUtil::ArePointersInSameMarkup(CEditorDoc      *pEd,
                                IDisplayPointer *pIFirst, 
                                IDisplayPointer *pISecond, 
                                BOOL            *pfInSame)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spFirst;
    SP_IMarkupPointer   spSecond;

    Assert( pEd && pIFirst && pISecond && pfInSame );

    if (pfInSame)
        *pfInSame = FALSE;

    if (pIFirst && pISecond)
    {
        IFC( pEd->CreateMarkupPointer( &spFirst ) );
        IFC( pEd->CreateMarkupPointer( &spSecond ) );

        IFC( pIFirst->PositionMarkupPointer( spFirst ) );
        IFC( pISecond->PositionMarkupPointer( spSecond ) );

        IFC( EdUtil::ArePointersInSameMarkup( spFirst, spSecond, pfInSame ) );
    }

Cleanup:

    RRETURN(hr);
}

#if DBG == 1
HRESULT
EdUtil::AssertSameMarkup(CEditorDoc     *pEd,
                        IDisplayPointer *pDispPointer1,
                        IDisplayPointer *pDispPointer2)
{
    HRESULT             hr = S_OK;
    BOOL                fSameMarkup = TRUE;

    if (pDispPointer1 && pDispPointer2)
    {
        hr = THR( ArePointersInSameMarkup(pEd, pDispPointer1, pDispPointer2, &fSameMarkup) );

        if (!fSameMarkup)
        {
            BOOL                fPositioned1;
            BOOL                fPositioned2;

            IGNORE_HR( pDispPointer1->IsPositioned(&fPositioned1) );
            IGNORE_HR( pDispPointer2->IsPositioned(&fPositioned2) );

            if (fPositioned1 && fPositioned2)
            {
                AssertSz(false, "Display pointers are in different markups");
            }
        }
    }

    RRETURN( hr );
}

HRESULT
EdUtil::AssertSameMarkup(CEditorDoc     *pEd,
                        IDisplayPointer *pDispPointer1,
                        IMarkupPointer  *pPointer2)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer2;
    
    if (pDispPointer1 && pPointer2)
    {
        IFC( pEd->GetDisplayServices()->CreateDisplayPointer(&spDispPointer2) );
        IFC( spDispPointer2->MoveToMarkupPointer(pPointer2, NULL) );
        hr = THR( AssertSameMarkup(pEd, pDispPointer1, spDispPointer2) );
    }

Cleanup:
    RRETURN( hr );
}
#endif

// We don't want to include the CRuntime so we've built the routine here.

// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              of legacy browser compatibility).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, VARIANT *pvarg, VARTYPE vt,IServiceProvider *pSrvProvider, DWORD dwFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = THR(pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType));
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
        hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);

        //Assert(!hr && "IVariantChangeType::ChangeType failure");
        if (!hr)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
        // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( _T("null") );           
        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( _T("undefined") );
        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = ( V_BSTR(pvarg) && SysStringLen( V_BSTR(pvarg) ) ) ? VB_TRUE : VB_FALSE ;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( V_BOOL(pvarg) == VB_TRUE ? _T("true") : _T("false") );     
        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                V_BSTR(pVArgDest) = SysAllocString(_T("NaN") );
            }
            else
            {
                // Infinity
                V_BSTR(pVArgDest) = SysAllocString((dblValue < 0) ? _T("-Infinity") : _T("Infinity"));
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = THR(VariantChangeTypeEx(pVArgDest, pvarg, LCID_SCRIPTING, dwFlags|VARIANT_NOUSEROVERRIDE, vt));

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_I4(pVArgDest)=0;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            V_BSTR(pVArgDest) = SysAllocString ( (V_DISPATCH(pvarg)) ? _T("[object]") : _T("null"));
        }
        else if ( V_VT(pvarg) == VT_BSTR && V_BSTRREF(pvarg)  &&
            ( (V_BSTR(pvarg))[0] == _T('\0')) && (  vt == VT_I4 || vt == VT_I2 || vt == VT_UI2 || vt == VT_UI4 || vt == VT_I8 ||
                vt == VT_UI8 || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

    // To match Navigator change any scientific notation E to e.
    if (!hr && (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4)))
    {
        TCHAR *pENotation;

        pENotation = _tcschr(V_BSTR(pVArgDest), _T('E'));
        if (pENotation)
            *pENotation = _T('e');
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::ComputeParentChain, private
//
//  Synopsis:   Compute the markup parent chain using pPointer as a helper
//
//----------------------------------------------------------------------------

//
// Make sure and release all pointers in the array you're passed in in this function.
//
HRESULT
EdUtil::ComputeParentChain(
    IMarkupPointer *pPointer, 
    CPtrAry<IMarkupContainer *> &aryParentChain)
{
    HRESULT                 hr;
    //
    // Don't change the below to a smart pointer - should be released by the caller of this function
    //
    IMarkupContainer        *pContainer=NULL;
    SP_IMarkupContainer2    spContainer2;
    SP_IHTMLElement         spElement;

    for (;;)
    {
        IFC( pPointer->GetContainer(&pContainer) );
        IFC( aryParentChain.Append( pContainer) );

        IFC( pContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(&spElement) );

        if (spElement == NULL)
            break;

        hr = THR( pPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );

        if( FAILED(hr) )
        {
            aryParentChain.Append( NULL );
            hr = S_OK;
            break;
        }                   
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsEqual, private
//
//  Synopsis:   Compare markup containers
//
//----------------------------------------------------------------------------
BOOL
EdUtil::IsEqual(IMarkupContainer *pContainer1, IMarkupContainer *pContainer2)
{
    HRESULT     hr;
    SP_IUnknown spUnk1, spUnk2;

    if( pContainer1 == NULL )
        return pContainer2 == NULL;
    else if( pContainer2 == NULL )
        return FALSE;
        
    IFC( pContainer1->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk1) );
    IFC( pContainer2->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk2) );

    return (spUnk1 == spUnk2);

Cleanup:
    return FALSE;
}

HRESULT 
EdUtil::ClipToElement( CEditorDoc* pDoc, 
                        IHTMLElement* pIElementActive,
                        IHTMLElement* pIElement,
                        IHTMLElement** ppIClippedElement )
{
    HRESULT hr;
    SP_IMarkupPointer spActPointer;
    SP_IMarkupPointer spElemPointer;
    BOOL fSame;
    ELEMENT_TAG_ID eTag;
    int i;
    CPtrAry<IMarkupContainer *>  aryParentChain1(Mt(Mem));
    CPtrAry<IMarkupContainer *>  aryParentChain2(Mt(Mem));    
    Assert( pIElementActive && pIElement && ppIClippedElement );
    
    IFC( pDoc->CreateMarkupPointer( & spActPointer ));
    IFC( pDoc->CreateMarkupPointer( & spElemPointer ));

    //
    // Find a good place to be for Master/Slave specialness.
    //

    //
    // special case input. It is a master element - but we don't want to drill in.
    // otherwise we'll start handing out the txtslave as the element.
    //
    IFC( pDoc->GetMarkupServices()->GetElementTagId( pIElementActive, & eTag ));    
    if ( IsMasterElement( pDoc->GetMarkupServices(), pIElementActive ) == S_OK &&
         eTag != TAGID_INPUT )
    {
        IFC( PositionPointersInMaster( pIElementActive, spActPointer, NULL ));
    }
    else
    {
        IFC( spActPointer->MoveAdjacentToElement( pIElementActive, ELEM_ADJ_BeforeBegin ));
    }
    
    IFC( spElemPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));

    IFC( ArePointersInSameMarkup ( spActPointer, spElemPointer, & fSame ));

    if( fSame )
    {
        *ppIClippedElement = pIElement;
        (*ppIClippedElement)->AddRef();
    }
    else
    {
        SP_IMarkupPointer            spPointer1;
        SP_IMarkupPointer            spPointer2;
        INT                          iChain1, iChain2;
        SP_IMarkupContainer2         spContainer2;
        
        IFC( MarkupServices_CreateMarkupPointer( pDoc->GetMarkupServices(), &spPointer1) );
        IFC( MarkupServices_CreateMarkupPointer( pDoc->GetMarkupServices(), &spPointer2) );

        //
        // Compute the markup parent chain for each pointer
        //

        IFC( spPointer1->MoveToPointer( spActPointer ) );
        IFC( ComputeParentChain(spPointer1, aryParentChain1) );
        
        IFC( spPointer2->MoveToPointer(spElemPointer) );
        IFC( ComputeParentChain(spPointer2, aryParentChain2) );

        iChain1 = aryParentChain1.Size()-1;
        iChain2 = aryParentChain2.Size()-1;

        Assert(iChain1 >= 0 && iChain2 >= 0);

        //
        // Make sure the top markups are the same
        //

        if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
        {
            //
            // possible if clicking in a different frame - with a current elem in another frame.
            //
            hr = E_FAIL ;
            goto Cleanup;
        }

        for (;;)
        {
            iChain1--;
            iChain2--;

            //
            // Check if one markup is contained within another
            //
            if (iChain1 < 0 || iChain2 < 0)
            {
                // (iChain1 < 0 && iChain2 < 0) implies same markup.  This function should not be
                // called in this case
                Assert(iChain1 >= 0 || iChain2 >= 0);

                if (iChain1 < 0)
                {
                    //
                    // pIElement's markup is deeper than active. ClipElement is 
                    // master of pIElement's markup
                    //
                    if( aryParentChain2[iChain2] )
                    {
                        IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                        IFC( spContainer2->GetMasterElement( ppIClippedElement) );
                    }
                }
                else
                {
                    //
                    // ActiveEleemnt's markup is deeper. No need to clip.
                    //
                    *ppIClippedElement = pIElement;
                    (*ppIClippedElement)->AddRef();
                }                
                break;
            }

            //
            // Check if we've found the first different markup in the chain
            //
                    
            if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
            {
                if( aryParentChain2[iChain2] )
                {
                    IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement( ppIClippedElement) );
                }

                break;
            }
        }            
    }
    
Cleanup:
    for (i = 0; i < aryParentChain1.Size(); i++)
        ReleaseInterface(aryParentChain1[i]);

    for (i = 0; i < aryParentChain2.Size(); i++)
        ReleaseInterface(aryParentChain2[i]);
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: PositionPointersInMaster
//
// Synopsis: Move to content in master + some clinging to find an element with layout
//
//+---------------------------------------------------------------------

HRESULT
EdUtil::PositionPointersInMaster( IHTMLElement* pIElement, IMarkupPointer* pIStart, IMarkupPointer* pIEnd )
{
    HRESULT hr;
    
    SP_IMarkupPointer2 spStart2;
    SP_IMarkupPointer2 spEnd2;
    
    SP_IMarkupContainer spContainer;
    SP_IHTMLDocument2 spDoc;
    SP_IHTMLElement spBody;

    if ( pIStart )
    {
        IFC( pIStart->QueryInterface( IID_IMarkupPointer2, (void**) &  spStart2 ));
        IFC( spStart2->MoveToContent( pIElement, TRUE ));
    }    

    if ( pIEnd )
    {
        IFC( pIEnd->QueryInterface( IID_IMarkupPointer2, (void**) &  spEnd2 ));
        IFC( spEnd2->MoveToContent( pIElement, FALSE ));
    }

    IFC( pIStart->GetContainer( & spContainer ));
    if ( spContainer->QueryInterface( IID_IHTMLDocument2, (void**) & spDoc ) == S_OK )
    {
        IFC( spDoc->get_body( & spBody ));
        if ( spBody )
        {
            if ( pIStart )
            {
                IFC( pIStart->MoveAdjacentToElement( spBody, ELEM_ADJ_AfterBegin ));
            }

            if ( pIEnd )
            {
                IFC( pIEnd->MoveAdjacentToElement( spBody, ELEM_ADJ_BeforeEnd ));
            }                
        }
    }
    
Cleanup:
    RRETURN( hr );

}

HRESULT 
EdUtil::CheckAttribute(IHTMLElement* pElement,BOOL *pfSet, BSTR bStrAtribute, BSTR bStrAtributeVal )
{
    HRESULT hr = S_OK;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var)   = VT_BSTR ;
    V_BSTR(&var) =  NULL ;

    *pfSet = FALSE;

    //  Bug 102306: Make sure the var was a BSTR before checking value.  If the var was a BOOL
    //  just get the BOOL value.

    IFC( pElement->getAttribute(bStrAtribute, 0, &var) );
    if (V_VT(&var) == VT_BSTR)
    {
        *pfSet = !!(_tcsicmp(var.bstrVal, bStrAtributeVal) == 0);
    }
    else if (V_VT(&var) == VT_BOOL)
    {
        *pfSet = !!(V_BOOL(&var));
    }

Cleanup:
    VariantClear(&var);
    RRETURN (hr);
}

//+====================================================================================
//
// Method:      EqualDocuments
//
// Synopsis:    Check for equality on 2 IHTMLDocument
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::EqualDocuments( IHTMLDocument2 *pIDoc1, IHTMLDocument2 *pIDoc2 )
{
    HRESULT     hr = S_OK;
    SP_IUnknown spIObj1;
    SP_IUnknown spIObj2;
    BOOL        fSame = FALSE;
    
    IFC( pIDoc1->QueryInterface( IID_IUnknown, (void**)&spIObj1));
    IFC( pIDoc2->QueryInterface( IID_IUnknown, (void**)&spIObj2));

    fSame = (spIObj1.p == spIObj2.p);
    
Cleanup:
    return fSame;
}


//+====================================================================================
//
// Method: EqualContainers
//
// Synopsis: Check for equality on 2 MarkupContainers
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::EqualContainers( IMarkupContainer* pIMarkup1, IMarkupContainer* pIMarkup2 )
{
    HRESULT             hr = S_OK;
    SP_IUnknown         spUnk1;
    SP_IUnknown         spUnk2;
    BOOL                fSame = FALSE;

    Assert( pIMarkup1 && pIMarkup2 );

    if(!pIMarkup1 || !pIMarkup2) 
        return (pIMarkup1 == pIMarkup2);
    
    IFC( pIMarkup1->QueryInterface( IID_IUnknown, (void **)&spUnk1));
    IFC( pIMarkup2->QueryInterface( IID_IUnknown, (void **)&spUnk2))

    fSame = ( spUnk1.p == spUnk2.p );
    
Cleanup:

    return fSame;
}

#if DBG==1

#undef CreateMarkupPointer

HRESULT 
MarkupServices_CreateMarkupPointer(IMarkupServices *pMarkupServices, IMarkupPointer **ppPointer)
{
    return pMarkupServices->CreateMarkupPointer(ppPointer);
}

#endif

VOID 
CEditXform::TransformPoint( POINT* pPt )
{
    Assert( pPt );

    if ( _pXform )
    {
        LONG inX = pPt->x ;

        //  chandras : rotation, zooming and displacement applying thru transformation matrix
        //  matrix multiplication 1x2 * 2x2  = 1x2
        //  (x y) * (a11 a12)   = (x * a11 + y * a21   x*a12 + y * a22)
        //          (a21 a22)  
        //  where (x y) is initial point
        //        transformation matrix - (a11 a12)
        //                                (a21 a22)
        //        the product - (x * a11 + y * a21   x*a12 + y * a22)
        //
        pPt->x =  inX * _pXform->eM11 + pPt->y * _pXform->eM21 + _pXform->eDx;
        pPt->y =  inX * _pXform->eM12 + pPt->y * _pXform->eM22 + _pXform->eDy;
    }
}

VOID
CEditXform::TransformRect( RECT* pRect )
{
    POINT ptTopLeft;
    POINT ptBottomRight;

    Assert( pRect );

    if ( _pXform )
    {
        ptTopLeft.x = pRect->left;
        ptTopLeft.y = pRect->top;

        ptBottomRight.x = pRect->right;
        ptBottomRight.y = pRect->bottom;

        TransformPoint( & ptTopLeft );
        TransformPoint( & ptBottomRight );

        //  chandras : rotation, zooming and displacement applying
        //  high possibility of the rectangle is roatated (Vetical layout case)
        //  so get the corners normalized.
        if (ptTopLeft.x >= ptBottomRight.x)
        {
            pRect->left  = ptBottomRight.x;
            pRect->right = ptTopLeft.x;
        }
        else
        {
            pRect->left  = ptTopLeft.x;
            pRect->right = ptBottomRight.x;
        }
        
        if (ptTopLeft.y >= ptBottomRight.y)
        {        
            pRect->top    = ptBottomRight.y;
            pRect->bottom = ptTopLeft.y;
        }
        else
        {
            pRect->top    = ptTopLeft.y;
            pRect->bottom = ptBottomRight.y;
        }         
    }    
}

HRESULT 
EdUtil::GetOffsetTopLeft(IHTMLElement* pIElement, POINT* ptTopLeft)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElemNext;

    IFC (pIElement->get_offsetLeft(&(ptTopLeft->x)));
    IFC (pIElement->get_offsetTop(&(ptTopLeft->y)));

    IFC (pIElement->get_offsetParent(&spElemNext));

    while (SUCCEEDED(hr) && spElemNext)
    {
        SP_IHTMLElement spElem;

        POINT pt;

        IFC (spElemNext->get_offsetLeft(&pt.x));
        IFC (spElemNext->get_offsetTop(&pt.y));

        ptTopLeft->x += pt.x;
        ptTopLeft->y += pt.y;

        spElem = spElemNext;
        hr = spElem->get_offsetParent(&spElemNext);
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
EdUtil::GetElementRect(IHTMLElement* pIElement, LPRECT prc)
{
    POINT   ptExtent;
    HRESULT hr = S_OK;
    POINT   ptLeftTop ;

    IFC(GetOffsetTopLeft(pIElement, &ptLeftTop));
    prc->left = ptLeftTop.x;
    prc->top  = ptLeftTop.y;

    IFC(GetPixelWidth (pIElement, &ptExtent.x));
    IFC(GetPixelHeight(pIElement, &ptExtent.y));

    prc->right  = prc->left + ptExtent.x;
    prc->bottom = prc->top  + ptExtent.y;

Cleanup:
    RRETURN(hr);
}

HRESULT 
EdUtil::GetPixelWidth(IHTMLElement* pIElement, long* lWidth)
{
   RRETURN(pIElement->get_offsetWidth(lWidth));
}

HRESULT
EdUtil::GetPixelHeight(IHTMLElement* pIElement, long* lHeight)
{
   RRETURN(pIElement->get_offsetHeight(lHeight));
}

LONG
EdUtil::GetCaptionHeight(IHTMLElement* pIElement)
{
    LONG               lHeightCaption = 0;
    IHTMLTableCaption *pICaption = NULL;
    IHTMLElement      *pICaptionElement = NULL;
    IHTMLTable        *pITable = NULL  ;

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable , (void**)&pITable)))
    {
        if (SUCCEEDED(pITable->get_caption(&pICaption)))
        {
            if (pICaption != NULL)
            {   
                if (SUCCEEDED(pICaption->QueryInterface(IID_IHTMLElement, (void**)&pICaptionElement)))
                {
                    pICaptionElement->get_offsetHeight(&lHeightCaption);
                }
                ReleaseInterface(pICaptionElement);
            }
        }            
        ReleaseInterface(pICaption);
    }          
    ReleaseInterface(pITable);
    
    return (lHeightCaption);
}

HRESULT
EdUtil::GetClientOrigin(CEditorDoc *pEd, IHTMLElement *pElement, POINT * ppt)
{
    HRESULT hr;
    
    Assert( pElement && ppt && pEd );
    
    ppt->x = 0;
    ppt->y = 0;

    //
    // Transform our point from Frame to Global coordinate systems
    //
    IFC( pEd->GetDisplayServices()->TransformPoint( ppt,
                                                    COORD_SYSTEM_FRAME,
                                                    COORD_SYSTEM_GLOBAL,
                                                    pElement ) );
                                                    
Cleanup:
    RRETURN( hr );
}


HRESULT
EdUtil::GetFrameOrIFrame(CEditorDoc *pEd, IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT             hr = S_OK;
    SP_IDispatch        spDispDoc;
    SP_IHTMLDocument2   spDoc; 
    SP_IHTMLWindow2     spWindow2;
    SP_IHTMLWindow4     spWindow4;
    SP_IHTMLFrameBase   spFrameBase;
    SP_IUnknown         spUnkDoc;
    SP_IUnknown         spUnkTopDoc;
    ELEMENT_TAG_ID      tagId;

    Assert(pIElement && ppIElement && pEd);

    *ppIElement = NULL;

    //
    // Check for frame
    //

    IFC( pEd->GetMarkupServices()->GetElementTagId(pIElement, &tagId) );
    if (tagId == TAGID_FRAME || tagId == TAGID_IFRAME)
    {
        *ppIElement = pIElement;
        pIElement->AddRef();
        goto Cleanup;
    }

    //
    // Makes sure we don't go past the top document
    //

    IFC( pIElement->get_document(&spDispDoc) );
    Assert(spDispDoc != NULL);

    IFC( spDispDoc->QueryInterface(IID_IUnknown, (LPVOID *)&spUnkDoc) );
    IFC( pEd->GetTopDoc()->QueryInterface(IID_IUnknown, (LPVOID *)&spUnkTopDoc) );

    if (spUnkDoc == spUnkTopDoc)
    {
        hr = S_FALSE; // don't go past the top doc
        goto Cleanup;
    }

    //
    // Check for parent frame
    //


    IFC( spDispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&spDoc) );
    IFC( spDoc->get_parentWindow(&spWindow2) );

    IFC( spWindow2->QueryInterface(IID_IHTMLWindow4, (LPVOID *)&spWindow4) );    
    if (SUCCEEDED(spWindow4->get_frameElement(&spFrameBase)) && spFrameBase)
    {
        IFC( spFrameBase->QueryInterface(IID_IHTMLElement, (LPVOID *)ppIElement) );
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT 
EdUtil::GetActiveElement( 
                            CEditorDoc *pEd, 
                            IHTMLElement* pIElement, 
                            IHTMLElement** ppIActive, 
                            BOOL fSeeCurrentInIframe /*=FALSE*/ )
{
    HRESULT hr;

    Assert( ppIActive );
    if ( ! ppIActive )
    {
        return E_FAIL;
    }
    SP_IHTMLElement spFrameElement;
    BOOL fValidFrame = FALSE;

    //
    // Get the "real" active element - catering for frameset pages.
    //
    
    if ( EdUtil::GetFrameOrIFrame( pEd , pIElement, & spFrameElement ) == S_OK )
    {
        ELEMENT_TAG_ID eTag;
        
        IFC( pEd->GetMarkupServices()->GetElementTagId(spFrameElement, & eTag));
        fValidFrame = (eTag != TAGID_IFRAME) || fSeeCurrentInIframe ;
        Assert( eTag == TAGID_FRAME || eTag == TAGID_IFRAME );
    }
        
    if ( fValidFrame )
    {
        SP_IDispatch spElemDocDisp;
        SP_IHTMLDocument2 spElemDoc;            

        IFC( pIElement->get_document(& spElemDocDisp ));
        IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
        IFC( spElemDoc->get_activeElement( ppIActive ));
    }
    else
    {
        IFC( pEd->GetDoc()->get_activeElement ( ppIActive ));
    }
    
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     IsDropDownList
//
//  Synopsis:   Determines if the specified element is a drop down list
//
//  Arguments:  pIElement = Element to determine if it is a drop down
//
//  Returns:    BOOLEAN indicating whether it is a dropdown
//
//--------------------------------------------------------------------------
BOOL
EdUtil::IsDropDownList( IHTMLElement *pIElement )
{
    SP_IHTMLSelectElement   spSelectElement;
    BOOL                    fIsDropDown = FALSE;
    HRESULT                 hr = S_OK;
    long                    lSize;
    VARIANT_BOOL            vbMultiple;
    
    if( !pIElement )
        goto Cleanup;

    //
    // A drop down list is defined as a select element, with MULTIPLE set to FALSE
    // and SIZE set to 1
    //
    IFC( pIElement->QueryInterface( IID_IHTMLSelectElement, (void **)&spSelectElement ) );   
    IFC( spSelectElement->get_size(&lSize) );
    IFC( spSelectElement->get_multiple( &vbMultiple ) );

    fIsDropDown = (lSize <= 1) && (vbMultiple == VB_FALSE);

Cleanup:
    return fIsDropDown;
}

//+-------------------------------------------------------------------------
//
//  Method:     GetSegmentCount
//
//  Synopsis:   Retrieves the length of the segment list
//
//  Arguments:  pISegmentList = Pointer to segment list
//              piCount = OUTPUT - Length of list
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
EdUtil::GetSegmentCount(ISegmentList *pISegmentList, int *piCount )
{
    HRESULT                 hr;
    SP_ISegmentListIterator spIter;
    int                     nSize = 0;
    
    Assert( pISegmentList && piCount );

    IFC( pISegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        nSize++;
        IFC( spIter->Advance() );
    }

    *piCount = nSize;

Cleanup:
    RRETURN(hr);
}

BOOL
EdUtil::IsVMLElement(IHTMLElement* pIElement)
{
    BSTR bstrUrn ;
    SP_IHTMLElement2 spElement2;

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2, (void**)&spElement2)) &&
        SUCCEEDED(spElement2->get_tagUrn(&bstrUrn)))
    {
         if ((bstrUrn != NULL) &&
             (StrCmpIW(bstrUrn, L"urn:schemas-microsoft-com:vml") == 0))
         {
            return TRUE;
         }
    }

    return FALSE;
}

//+====================================================================================
//
// Method: IsTridentHWND
//
// Synopsis: Helper to check to see if a given HWND belongs to a trident window
//
//------------------------------------------------------------------------------------
BOOL
EdUtil::IsTridentHwnd( HWND hwnd )
{
    TCHAR strClassName[100] ;

    ::GetClassName( hwnd, strClassName, 100 );

    if ( StrCmpIW( strClassName, _T("Internet Explorer_Server") ) == 0 )
    {
        return TRUE;
    }
    else
        return FALSE;
}






//+====================================================================================
//
// Method: EqualPointers 
//
// Synopsis: Check to see if there is no text in between pMarkup1 and pMarkup2
//           If fIgnoreBlock is FALSE, text between two block element are not considered
//           equal.
//
//------------------------------------------------------------------------------------
HRESULT 
EdUtil::EqualPointers(  IMarkupServices *pMarkupServices, 
                        IMarkupPointer *pMarkup1, 
                        IMarkupPointer *pMarkup2, 
                        BOOL *pfEqual,
                        BOOL fIgnoreBlock
                        )
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE ctx;
    BOOL                fResult;    
    long                lcchTemp;
    IMarkupPointer      *pMarkupScan = NULL;
    SP_IHTMLElement     spElement;
    BOOL                fDone;

    Assert (pMarkupServices);
    Assert (pMarkup1);
    Assert (pMarkup2);
    
    IFC( pMarkup1->IsEqualTo(pMarkup2, pfEqual) );
    if(*pfEqual)
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( pMarkup1->IsLeftOf(pMarkup2, &fResult));
    if (!fResult)
    {
        //
        // pMarkupScan is not ref-counted here
        //
        pMarkupScan = pMarkup1;
        pMarkup1    = pMarkup2;
        pMarkup2    = pMarkupScan;
        pMarkupScan = NULL; 
    }

    IFC( pMarkupServices->CreateMarkupPointer(&pMarkupScan) );
    IFC( pMarkupScan->MoveToPointer(pMarkup1) );
    *pfEqual = TRUE;
    fDone    = FALSE;
    while (!fDone)
    {
        lcchTemp = -1;

        // Move the temp pointer ahead
        IFC(pMarkupScan->Right(TRUE, &ctx, &spElement, &lcchTemp, NULL));

        // If the temp pointer movement went over text,
        // then there is some text between pPtr1 and pPtr2 and so
        // they are not equal
        switch (ctx)
        {
        case CONTEXT_TYPE_Text:
            *pfEqual = FALSE;
            fDone    = TRUE;
            break;
            
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
        case CONTEXT_TYPE_NoScope:
            if (!fIgnoreBlock)
            {
                BOOL  fBlock, fLayout;
                Assert(!(spElement == NULL));
                IFC( EdUtil::IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );
                if (fBlock || fLayout)  
                {
                    *pfEqual = FALSE;
                    fDone    = TRUE;
                }
                else
                {
                    ELEMENT_TAG_ID eTag = TAGID_NULL;
                    IFC( pMarkupServices->GetElementTagId(spElement, &eTag) );
                    if (eTag == TAGID_BR)
                    {
                        *pfEqual = FALSE;
                        fDone    = TRUE;
                    }
                }
            }
            //
            // Skip phrase elements /and block elements if fIgnoreBlock
            //
            break;
            

        case CONTEXT_TYPE_None:
            fDone = TRUE;
            break;
        }
        
        
        IFC( pMarkupScan->IsLeftOf(pMarkup2, &fResult));
        if (!fResult)
        {   
            // Done
            break;
        }
    }

Cleanup:
    ReleaseInterface(pMarkupScan);
    RRETURN (hr);
}



HRESULT
EdUtil::GetDisplayLocation(
            CEditorDoc      *pEd,
            IDisplayPointer *pDispPointer,
            POINT           *pPoint,
            BOOL            fTranslate
            )
{
    HRESULT             hr;
    SP_ILineInfo        spLineInfo;
    SP_IMarkupPointer   spPointer;
    IHTMLElement        *pIFlowElement = NULL;

    Assert( pEd );
    Assert( pDispPointer );
    Assert( pPoint );

    IFR( pDispPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if( fTranslate )
    {
        IFC( pEd->GetMarkupServices()->CreateMarkupPointer(&spPointer) );
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( pDispPointer->GetFlowElement(&pIFlowElement) );
        IFC( pEd->GetDisplayServices()->TransformPoint(pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, pIFlowElement) );
    }

Cleanup:
    ReleaseInterface(pIFlowElement);
    return S_OK;
}



//
// Check to see if pIContainer1 contains pIContainer2
//
HRESULT 
EdUtil::CheckContainment(IMarkupServices *pMarkupServices, 
                         IMarkupContainer *pIContainer1, 
                         IMarkupContainer *pIContainer2, 
                         BOOL *pfContained
                         )
{
    HRESULT  hr = S_OK;
    SP_IMarkupPointer    spPointer;
    SP_IMarkupContainer  spContainer;

    Assert( pMarkupServices );
    Assert( pIContainer1 );
    Assert( pIContainer2 );
    Assert( pfContained );
    *pfContained = FALSE;

    if ( IsEqual(pIContainer1, pIContainer2) )
    {
        *pfContained = TRUE;
        goto Cleanup;
    }

    IFC( pMarkupServices->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveToContainer(pIContainer2, TRUE) );
    spContainer = pIContainer2; 
    for (; ;)
    {
        SP_IMarkupContainer2 spContainer2;
        SP_IHTMLElement      spElement;
        
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (void **)&spContainer2) );
        IFC( spContainer2->GetMasterElement(&spElement) );

        if (spElement == NULL)
            break;

        hr = THR( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
        if (FAILED(hr))
        {
            hr = S_OK;
            break;
        }

        IFC( spPointer->GetContainer(&spContainer) );
        if (IsEqual(pIContainer1, spContainer))
        {
            *pfContained = TRUE;
            break;
        }
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT
EdUtil::AdjustForAtomic(CEditorDoc      *pEd,
                        IDisplayPointer *pDispPointer,
                        IHTMLElement    *pAtomicElement,
                        BOOL            fStartOfSelection,
                        int             iDirection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spElemPointer;

    Assert(pEd);
    Assert(pDispPointer);
    Assert(pAtomicElement);

    IFC( pEd->GetMarkupServices()->CreateMarkupPointer(&spElemPointer) );
    if (fStartOfSelection)
    {
        IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
    }
    else
    {
        IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
    }

    hr = THR( pDispPointer->MoveToMarkupPointer(spElemPointer, NULL) );
    if (hr == CTL_E_INVALIDLINE)
    {
        ELEMENT_TAG_ID eTag = TAGID_NULL;
        
        IFC( pEd->GetMarkupServices()->GetElementTagId( pAtomicElement, &eTag ));
        if (eTag == TAGID_TD)
        {
            if (fStartOfSelection)
            {
                IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                        ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterBegin ) );
            }
            else
            {
                IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                        ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );
            }
            IFC( pDispPointer->MoveToMarkupPointer(spElemPointer, NULL) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
EdUtil::GetBlockContainerAlignment( IMarkupServices *pMarkupServices, IHTMLElement *pElement, BSTR *pbstrAlign )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement         spBlockContainer;
    SP_IHTMLElement         spCurrentElement;
    SP_IHTMLElement         spNewElement;
    ELEMENT_TAG_ID          eTag = TAGID_NULL;

    Assert(pMarkupServices);
    if (!pMarkupServices)
        goto Cleanup;

    Assert(pElement);
    if (!pElement)
        goto Cleanup;

    Assert(pbstrAlign);
    if (!pbstrAlign)
        goto Cleanup;

    *pbstrAlign = NULL;

    IFR( GetParentElement(pMarkupServices, pElement, &spCurrentElement) );
    while (spCurrentElement != NULL)
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &eTag) ); 

        if (eTag == TAGID_P ||
            eTag == TAGID_DIV)
        {
            spBlockContainer= spCurrentElement;
            break;
        }            
    
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }

    if (spBlockContainer)
    {
        SP_IHTMLParaElement     spParaElement;
        SP_IHTMLDivElement      spDivElement;

        if ( spBlockContainer->QueryInterface(IID_IHTMLParaElement, (void **)&spParaElement) == S_OK )
        {
             if ( spParaElement )
             {
                 spParaElement->get_align(pbstrAlign);
             }
        }
        else if ( spBlockContainer->QueryInterface(IID_IHTMLDivElement, (void **)&spDivElement) == S_OK )
        {
             if ( spDivElement )
             {
                 spDivElement->get_align(pbstrAlign);
             }
        }
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\edevent.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

using namespace EdUtil;

#if DBG==1
#define CreateMarkupPointer(ppPointer)                      CreateMarkupPointer(ppPointer, L#ppPointer)
#define CreateMarkupPointer2(pMarkupServices, ppPointer)    CreateMarkupPointer2(pMarkupServices, ppPointer, L#ppPointer)
#endif

extern HRESULT 
GetParentElement(IMarkupServices *pMarkupServices, IHTMLElement *pSrcElement, IHTMLElement **ppParentElement);

const int GRAB_SIZE = 7 ;

MtDefine(CEditEvent, Utilities, "CEditEvent")
MtDefine(CHTMLEditEvent, Utilities, "CEditEvent")
MtDefine(CSynthEditEvent, Utilities, "CEditEvent")

CEditEvent::CEditEvent(CEditorDoc* pEditor) :
    _pEditor( pEditor ),
    _eType( EVT_UNKNOWN )
{
    _pEditor->AddRef();
    _fCancel = FALSE;
    _fCancelReturn = FALSE;     
    _fTransformedPoint = FALSE;
    _dwHitTestResult = 0;
    _fDoneHitTest = FALSE;

    _pDispCache = NULL;
    _dwCacheCounter = 0;
}

CEditEvent::CEditEvent( const CEditEvent* pEvent )
{
    if ( pEvent )
    {
        memcpy( this, pEvent, sizeof( *this ));
        _pEditor->AddRef();
    }

   _pDispCache = NULL;
   _fDoneHitTest = FALSE;
    
}

CEditEvent::~CEditEvent()
{
    Assert( _pEditor );
    _pEditor->Release();
    ReleaseInterface( _pDispCache );
    _pDispCache = NULL;
}

HRESULT 
CEditEvent::MoveDisplayPointerToEvent( 
                        IDisplayPointer* pDispPointer,
                        IHTMLElement* pIElement /*=NULL*/, 
                        BOOL fHitTestEndOfLine /*= FALSE */)                        
{
    HRESULT             hr;
    DWORD               dwOptions = 0;
    SP_IHTMLElement     spLayoutElement;
    POINT               pt;

    if ( pDispPointer == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if( _fDoneHitTest                   && 
        _fCacheEOL == fHitTestEndOfLine && 
        _dwCacheCounter == _pEditor->GetEventCacheCounter() )
    {
        Assert( _pDispCache );
        IFC( pDispPointer->MoveToPointer( _pDispCache ) );
    }
    else
    {       
        IFC( GetPoint( & pt ));
        if (fHitTestEndOfLine)
        {
            dwOptions |= HT_OPT_AllowAfterEOL;
        }

        //
        // Hit test, and cache the results of the hit test in a locally stored pointer
        //
        if( !_pDispCache )
            IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer( &_pDispCache ) );
        
        IFC( pDispPointer->MoveToPoint( pt, COORD_SYSTEM_GLOBAL, pIElement, dwOptions, &_dwHitTestResult) );
        IFC( _pDispCache->MoveToPointer( pDispPointer ) );

        _dwCacheCounter = _pEditor->GetEventCacheCounter();
        _fDoneHitTest = TRUE;
        _fCacheEOL = fHitTestEndOfLine;
    }

Cleanup:
    RRETURN(hr);
}


HRESULT 
CEditEvent::GetElementAndTagId( IHTMLElement** ppIElement, ELEMENT_TAG_ID *peTag )
{
    HRESULT hr = S_OK;

    Assert( ppIElement && peTag );

    IFC( GetElement( ppIElement ));
    if ( *ppIElement )
    {
        IFC( _pEditor->GetMarkupServices()->GetElementTagId( *ppIElement, peTag ));
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CEditEvent::GetTagId( ELEMENT_TAG_ID *peTag )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    Assert(  peTag );

    IFC( GetElement( & spElement  ));
    if ( spElement )
    {
        IFC( _pEditor->GetMarkupServices()->GetElementTagId( spElement, peTag ));
    }
    
Cleanup:
    RRETURN( hr );
}

IHTMLDocument2*
CEditEvent::GetDoc()
{
    Assert( _pEditor);
    
    return _pEditor->GetDoc();
}



#if DBG == 1

#define PRINT(Y) case EVT_##Y: wsprintfA(paryChar, "Type: EVT_%ls pt:%d,%d", _T(#Y) , pt.x, pt.y  );break;


VOID
CEditEvent::toString( char* paryChar )
{
    POINT pt;
    GetPoint( & pt );
    
    switch( GetType())
    {
        PRINT( MOUSEOVER );
        PRINT( LMOUSEDOWN );
        PRINT( LMOUSEUP );
        PRINT( RMOUSEDOWN );
        PRINT( RMOUSEUP );
        PRINT( MMOUSEDOWN );
        PRINT( MMOUSEUP );
        PRINT( INTDBLCLK );
        
        PRINT( MOUSEMOVE );
        PRINT( MOUSEOUT );
        PRINT( KEYUP );
        PRINT( KEYDOWN );
        PRINT( KEYPRESS );
        PRINT( DBLCLICK ); 
        PRINT( CONTEXTMENU );
        PRINT( TIMER );
        PRINT( CLICK );
        PRINT( LOSECAPTURE);
        
        default:
            AssertSz(0,"Unknown event");

            wsprintfA(
                paryChar,
                "UNKNOWN EVENT");        
    }
        
}

#undef PRINT 

#endif

//----------------------------------------------------------------------------------------
//
//              CHTMLEditEvent
//
//
//
//----------------------------------------------------------------------------------------

//
// ctors, and dtor
//
//

CHTMLEditEvent::CHTMLEditEvent( CEditorDoc* pEditor  )
    : CEditEvent( pEditor )
{
    _pEvent = NULL;
}

CHTMLEditEvent::~CHTMLEditEvent()
{
    ReleaseInterface( _pEvent );
}

CHTMLEditEvent::CHTMLEditEvent( const CHTMLEditEvent* pHTMLEditEvent )
    : CEditEvent( pHTMLEditEvent )
{
    if ( pHTMLEditEvent && pHTMLEditEvent->_pEvent )
    {
        _pEvent = pHTMLEditEvent->_pEvent ; 
        _pEvent->AddRef();
    }
    else
    {
        _pEvent = NULL;
    }
}

//
// Init
//

HRESULT
CHTMLEditEvent::Init( IHTMLEventObj * pObj , DISPID inDispId /*=0*/)
{
    HRESULT hr = S_OK ;

    ReplaceInterface( &_pEvent, pObj );

    if ( inDispId == 0 )
    {
        hr = THR( SetType());
    }
    else
        SetType( inDispId );

    RRETURN(hr);
}


//
// Virtuals
//
//

HRESULT 
CHTMLEditEvent::GetElement( IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;

    Assert(ppIElement);
    
    switch( _eType )
    {
        case EVT_MOUSEOVER:
        case EVT_MOUSEOUT:
            IFC( _pEvent->get_toElement( ppIElement ));
            
            break;
        case EVT_KILLFOCUS:
        case EVT_SETFOCUS:
            AssertSz(0,"GetElement invalid on killfocus/setfocus");
            hr = E_FAIL;
            break;
            
        default:
            SP_IHTMLElement spSrcElement;
            SP_IHTMLElement spActiveElement;
            IFC( _pEvent->get_srcElement( & spSrcElement ));            
            if ( spSrcElement.IsNull() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }        
            //
            //
            // Special case area's on top of img tags - as the OM chooses to return Area's here.
            //
            //
            ELEMENT_TAG_ID eTag ;
            IFC( _pEditor->GetMarkupServices()->GetElementTagId( spSrcElement, & eTag ));
            if ( eTag == TAGID_AREA )
            {
                SP_IHTMLElement spNewElement;
                if( GetImgElementForArea( spSrcElement, & spNewElement ) == S_OK )
                {
                    spSrcElement = spNewElement;
                }                    
            }

            //
            // Get the ActiveElement for the frame the doc is in.
            //

            IGNORE_HR( _pEditor->GetDoc()->get_activeElement ( & spActiveElement ));
            if ( spActiveElement )
            {
                IFC( ClipToElement( _pEditor, spActiveElement, spSrcElement, ppIElement ));
            }   
            else
            {   
                *ppIElement = spSrcElement;
                (*ppIElement)->AddRef();
            }

    }
    
Cleanup:
    if ( hr == S_OK && ( ! *ppIElement ))
    {
        hr = E_FAIL;
        AssertSz(0, "GetElement Failed");
    }
    RRETURN( hr );
}

//
// OM chooses to give us an AREA tag for an IMG element
// We prefer the IMG tag.
// Find it by BRUTE force
//

//
//
// A potential future work item - is to 
// expose getting an element collection from a rect.
//
// but brute force works ok. 
//

HRESULT
CHTMLEditEvent::GetImgElementForArea(IHTMLElement* pIElement, IHTMLElement** ppISrcElement )
{
    HRESULT hr;
    POINT pt;
    BOOL fFound = FALSE ;
    SP_IHTMLElement spSrcElement;    
    SP_IHTMLElementCollection spCollect;   
    long ctImages;
    VARIANT varIndex, varDummy;
    SP_IDispatch spDisp;
    SP_IHTMLElement spElement;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLRect    spRect;
    SP_ISelectionServices spSelServ;
    SP_ISegmentList spSegList;
    int i;
    IFC( _pEditor->GetDoc()->get_images( & spCollect ));
    IFC( spCollect->get_length( & ctImages ));
    
    ::VariantInit( & varIndex );
    ::VariantInit( & varDummy );
    V_VT( &varDummy ) = VT_EMPTY;                
    V_VT( &varIndex) = VT_I4;
    IFC( GetPointInternal( pIElement, & pt )); // dont call getpoint - or you'll die a recursive death.                
    IFC( _pEditor->GetSelectionServices(&spSelServ) );
    IFC( spSelServ->QueryInterface( IID_ISegmentList, (void**)  & spSegList ));
    SELECTION_TYPE eType;
    IFC( spSegList->GetType(& eType ));
    
    for ( i = 0; i < ctImages; i ++ )
    {   
        V_I4( &varIndex) = i;                   
        IFC( spCollect->item( varIndex, varIndex  , & spDisp));
        IFC( spDisp->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
        IFC( spDisp->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));

        RECT rect; 
        IFC( spElement2->getBoundingClientRect(&spRect) );

        IFC( spRect->get_top(& rect.top ) );
        IFC( spRect->get_bottom(&rect.bottom) );
        IFC( spRect->get_left(&rect.left) );
        IFC( spRect->get_right(&rect.right) );
        if ( ::PtInRect(& rect, pt ))
        {
            spSrcElement = spElement;
            fFound = TRUE;
            break;
        }

        //
        // TODO this is heinous. we're going to guess what the size of the rect is
        // by using adorner size
        // we should either expose a GetElementReally on dispserv
        // or have a way in the OM to deduce the adorner size.
        //
        else if ( eType == SELECTION_TYPE_Control )
        {
            SP_ISegment spSegment;
            SP_IElementSegment spElementSegment;
            SP_IHTMLElement spCurElement;
            SP_IObjectIdentity spIdent;
            SP_ISegmentListIterator spIter;
            
            IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));                        
            IFC( spSegList->CreateIterator( & spIter ));

            while( spIter->IsDone() == S_FALSE )
            {
                IFC( spIter->Current( & spSegment ));
                IFC( spSegment->QueryInterface( IID_IElementSegment, (void**) & spElementSegment));
                IFC( spElementSegment->GetElement( & spCurElement));

                if ( spIdent->IsEqualObject( spCurElement ) == S_OK )
                {
                    InflateRect( & rect, GRAB_SIZE, GRAB_SIZE );

                    if ( ::PtInRect(& rect, pt ))
                    {
                        spSrcElement = spElement;
                        fFound = TRUE;
                        break;
                    }
                }
                IFC( spIter->Advance());
            }
        }                        
    }

Cleanup:

    if ( fFound )
    {
        *ppISrcElement = spElement;
        (*ppISrcElement)->AddRef();
    }

    if ( SUCCEEDED( hr ))
    {
        hr = fFound ? S_OK : S_FALSE;
    }
    
    RRETURN1( hr , S_FALSE );
}


HRESULT
CHTMLEditEvent::GetPoint( POINT * ppt)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;

    Assert( ppt );
        
    IFC( _pEvent->get_srcElement(&spElement) );
    Assert(spElement != NULL);

    IFC( GetPointInternal( spElement, ppt ));
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetPointInternal( IHTMLElement* pIElement, POINT * ppt )
{
    HRESULT hr;
    POINT           ptOrigin;
    Assert( ppt );
    IFC( EdUtil::GetClientOrigin( _pEditor, pIElement, &ptOrigin) );

    IFC( _pEvent->get_clientX( &_ptGlobal.x));
    IFC( _pEvent->get_clientY( &_ptGlobal.y));

    _ptGlobal.x += ptOrigin.x;
    _ptGlobal.y += ptOrigin.y;

    _fTransformedPoint = TRUE;

    *ppt = _ptGlobal;
    
Cleanup:
    RRETURN( hr );
}

BOOL
CHTMLEditEvent::IsShiftKeyDown()
{
    HRESULT hr;
    VARIANT_BOOL vbool;
    hr = THR( _pEvent->get_shiftKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}

BOOL
CHTMLEditEvent::IsControlKeyDown()
{
    VARIANT_BOOL vbool;
    HRESULT hr ;
    
    hr = THR( _pEvent->get_ctrlKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}


BOOL
CHTMLEditEvent::IsAltKeyDown()
{
    VARIANT_BOOL vbool;
    HRESULT hr ;
    
    hr = THR( _pEvent->get_altKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}

HRESULT 
CHTMLEditEvent::GetKeyCode(LONG* pkeyCode)
{
    HRESULT hr ;
    IFC( _pEvent->get_keyCode( pkeyCode ));
    Assert( SUCCEEDED( hr ));
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::SetType()
{
    HRESULT hr;
    BSTR bstrEvent=NULL;

    IFC( _pEvent->get_type(&bstrEvent));
    _eType = TypeFromString( bstrEvent );
    ::SysFreeString( bstrEvent );
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Cancel
//
// Synopsis: Cancel this OM Event.
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditEvent::Cancel()
{
    HRESULT hr = S_OK;

    VARIANT vboolCancel;
    vboolCancel.vt = VT_BOOL;
    vboolCancel.boolVal = FALSE;
    hr = THR( _pEvent->put_returnValue(vboolCancel));

    _fCancel = TRUE ;
    
    RRETURN( hr );

}
//+====================================================================================
//
// Method: CancelBubble
//
// Synopsis: Cancel the bubbling of this OM event.
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditEvent::CancelBubble()
{
    HRESULT hr ;
    VARIANT_BOOL varCancel = VB_TRUE;

    IFC( _pEvent->put_cancelBubble( varCancel ));

Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditEvent::SetType( DISPID inDispId )
{
    HRESULT hr = S_OK;

    _eType = TypeFromDispId( inDispId );
    
    RRETURN( hr );
}

#define MAP_EVENT(Y ) case DISPID_HTMLELEMENTEVENTS_ON##Y: eType = EVT_##Y; break;

EDIT_EVENT 
CHTMLEditEvent::TypeFromDispId( DISPID inDispId )
{
    EDIT_EVENT eType = EVT_UNKNOWN;

    switch( inDispId )
    {
        //
        // convert mouse down/ mouse up to a single event
        //

        //
        // TODO - what happens if they press both buttons at once - two OM events fired ?
        //
        case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN:
        {
            if ( IsLeftButton() )
                eType = EVT_LMOUSEDOWN;
            else if ( IsRightButton() )
                eType = EVT_RMOUSEDOWN;
            else
            {
                Assert( IsMiddleButton() );
                eType = EVT_MMOUSEDOWN;            
            }
        }
        break;

        case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP:
        {
            if ( IsLeftButton() )
                eType = EVT_LMOUSEUP;
            else if ( IsRightButton() )
                eType = EVT_RMOUSEUP;
            else
            {
                Assert( IsMiddleButton() );
                eType = EVT_MMOUSEUP;      
            }                
        }
        break;

        MAP_EVENT( MOUSEOVER );
        MAP_EVENT( MOUSEMOVE );
        MAP_EVENT( MOUSEOUT );
        MAP_EVENT( KEYUP );
        MAP_EVENT( KEYDOWN );
        MAP_EVENT( KEYPRESS );
        MAP_EVENT( DBLCLICK ); 
        MAP_EVENT( CONTEXTMENU );         
        MAP_EVENT( PROPERTYCHANGE);    
        MAP_EVENT( CLICK );
        MAP_EVENT( LOSECAPTURE);
        default:
            eType = EVT_UNKNOWN;
    }
    
    return eType;
}

EDIT_EVENT 
CHTMLEditEvent::TypeFromString( BSTR bstrEvent )
{
    EDIT_EVENT eType = EVT_UNKNOWN;

    if (! StrCmpICW (bstrEvent, L"mousemove"))
    {
        eType = EVT_MOUSEMOVE;
    }
    else if (! StrCmpICW ( bstrEvent, L"mouseover"))
    {
        eType = EVT_MOUSEOVER;
    }
    else if (! StrCmpICW (bstrEvent, L"mousedown"))
    {
        if ( IsLeftButton() )
            eType = EVT_LMOUSEDOWN;
        else if ( IsRightButton() )
            eType = EVT_RMOUSEDOWN;
        else
            eType = EVT_MMOUSEDOWN;            
    }
    else if (! StrCmpICW (bstrEvent, L"mouseup"))
    {
        if ( IsLeftButton() )
            eType = EVT_LMOUSEUP;
        else if ( IsRightButton() )
            eType = EVT_RMOUSEUP;
        else
            eType = EVT_MMOUSEUP; 
    }
    else if (! StrCmpICW (bstrEvent, L"intrnlDblClick"))
    {
        eType = EVT_INTDBLCLK;
    }
    else if (! StrCmpICW (bstrEvent, L"propertychange"))
    {
        eType = EVT_PROPERTYCHANGE;
    }         
    else if (! StrCmpICW (bstrEvent, L"focus"))
    {
        eType = EVT_SETFOCUS;
    }
    else if (! StrCmpICW (bstrEvent, L"blur"))
    {
        eType = EVT_KILLFOCUS ;
    }    
    else if (! StrCmpICW (bstrEvent, L"startComposition"))
    {
        eType = EVT_IME_STARTCOMPOSITION ;
    } 
    else if (! StrCmpICW (bstrEvent, L"endComposition"))
    {
        eType = EVT_IME_ENDCOMPOSITION ;
    } 
    else if (! StrCmpICW (bstrEvent, L"compositionFull"))
    {
        eType = EVT_IME_COMPOSITIONFULL;
    } 
    else if (! StrCmpICW (bstrEvent, L"char"))
    {
        eType = EVT_IME_CHAR;
    } 
    else if (! StrCmpICW (bstrEvent, L"composition"))
    {
        eType = EVT_IME_COMPOSITION;
    } 
    else if (! StrCmpICW (bstrEvent, L"notify"))
    {
        eType = EVT_IME_NOTIFY;
    } 
    else if (! StrCmpICW (bstrEvent, L"inputLangChange"))
    {
        eType = EVT_INPUTLANGCHANGE;
    } 
    else if (! StrCmpICW (bstrEvent, L"imeRequest"))
    {
        eType = EVT_IME_REQUEST;
    } 
    else if (! StrCmpICW (bstrEvent, L"click"))
    {
        eType = EVT_CLICK;
    } 
    else if (! StrCmpICW (bstrEvent, L"losecapture"))
    {
        eType = EVT_LOSECAPTURE;
    }
    else if (! StrCmpICW (bstrEvent, L"imeReconversion"))
    {
        Assert( FALSE );    // this has not been implemented yet
        eType = EVT_IME_RECONVERSION;
    }
    return eType;
}


BOOL 
CHTMLEditEvent::IsLeftButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( (b & 1) != 0 );
}

BOOL 
CHTMLEditEvent::IsRightButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( (b & 2) != 0 );

}

BOOL 
CHTMLEditEvent::IsMiddleButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( ( b & 4 ) != 0 );

}

HRESULT
CHTMLEditEvent::GetShiftLeft(BOOL* pfShiftLeft)
{
    VARIANT_BOOL vbShift;
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    Assert( pfShiftLeft );
    
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));
    
    hr = THR( spObj3->get_shiftLeft ( & vbShift));
    Assert( SUCCEEDED( hr ));

    *pfShiftLeft =  vbShift == VB_TRUE ;
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetCompositionChange( LONG_PTR * plParam )
{
    Assert( GetType() == EVT_IME_COMPOSITION );
    Assert( plParam );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeCompositionChange( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetNotifyCommand( LONG_PTR* pLong)
{
    Assert( GetType() == EVT_IME_NOTIFY );
    HRESULT hr;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));
    
    hr = THR( spObj3->get_imeNotifyCommand( pLong ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetNotifyData(LONG_PTR* plParam)
{
    Assert( GetType() == EVT_IME_NOTIFY );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeNotifyData( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetIMERequest(LONG_PTR *pwParam)
{
    Assert( GetType() == EVT_IME_REQUEST );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeRequest( pwParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetIMERequestData(LONG_PTR *plParam)
{
    Assert( GetType() == EVT_IME_REQUEST );
    HRESULT hr;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeRequestData( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetKeyboardLayout(LONG_PTR *plParam)
{
    Assert( GetType() == EVT_INPUTLANGCHANGE);
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_keyboardLayout( plParam ));

Cleanup:
    RRETURN( hr );
}    

HRESULT
CHTMLEditEvent::GetFlowElement(IHTMLElement** ppIElement)
{
    HRESULT hr ;
    SP_IDisplayPointer spDisplayPointer;

    if( _fDoneHitTest )
    {
        IFC( _pDispCache->GetFlowElement( ppIElement ) );
    }
    else
    {
        IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer( & spDisplayPointer ));
        IFC( MoveDisplayPointerToEvent( spDisplayPointer));
        IFC( spDisplayPointer->GetFlowElement( ppIElement));
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::IsInScrollbar()
{
    HRESULT hr = S_FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spParent;
    SP_IHTMLElement2 spElement2;
    BSTR bstrScroller = NULL;
    POINT pt;
    BOOL fScrollable;

    //  Need to bubble this up.  The scrolling element may be a parent of the
    //  element where the event occurred.

    IFC( GetFlowElement( & spElement ));
    while (spElement)
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, NULL, &fScrollable));

        if (fScrollable)
        {
            IFC( spElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
            IFC( GetPoint( & pt ));
            
            IFC( spElement2->componentFromPoint( pt.x, pt.y, & bstrScroller ));

            if (IsScrollerPart(bstrScroller))
            {
                hr = S_OK;
                break;
            }
        }

        IFC(GetParentElement(_pEditor->GetMarkupServices(), spElement, &spParent));
        spElement = spParent;
    }

    hr = (spElement != NULL) ? S_OK : S_FALSE;
    
Cleanup:

    ::SysFreeString( bstrScroller );
    RRETURN1( hr, S_FALSE );
}

HRESULT
CHTMLEditEvent::GetPropertyChange( BSTR* pBstr )
{
    HRESULT hr ;
    SP_IHTMLEventObj2 spObj2;

    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj2, ( void**) & spObj2 ));
    IFC( spObj2->get_propertyName( pBstr ));
Cleanup:
    RRETURN( hr );
}

BOOL
CHTMLEditEvent::IsScrollerPart(BSTR inBstrPart )
{
    BOOL fScroller = FALSE;
    BSTR bstrPart = ::SysAllocStringLen( inBstrPart, 9 );

    if (!bstrPart)
        goto Cleanup;

    if (!StrCmpICW (bstrPart, L"scrollbar"))
    {
        fScroller = TRUE;
    }
    ::SysFreeString( bstrPart );

Cleanup:
    return fScroller;
}

HRESULT 
CHTMLEditEvent::GetMasterElement(IHTMLElement *pSrcElement, IHTMLElement **ppMasterElement)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;    
    SP_IMarkupPointer   spPointer;    
    SP_IDisplayPointer  spDispPointer;

    Assert(ppMasterElement);
    *ppMasterElement = NULL;

    IFC( pSrcElement->get_parentElement(&spElement) );

    // If we have a parent, we are not a txt slave or root element, so return
    // the current element

    if (spElement != NULL)
    {
        *ppMasterElement = pSrcElement;
        pSrcElement->AddRef();
        goto Cleanup;
    }

    //
    // Otherwise, return the flow element
    //

    IFC( _pEditor->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pSrcElement, ELEM_ADJ_AfterBegin) );

    IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
    IFC( spDispPointer->GetFlowElement(ppMasterElement) );

Cleanup:
    RRETURN(hr);    
}

//----------------------------------------------------------------------------------------
//
//              CHTMLEditEvent
//
//
//
//----------------------------------------------------------------------------------------

//
// ctors, and dtor
//
//

CSynthEditEvent::CSynthEditEvent( CEditorDoc* pEditor  )
                    : CEditEvent( pEditor )
{
    _pt.x = -1;
    _pt.y = -1;
}

CSynthEditEvent::~CSynthEditEvent()
{

}

CSynthEditEvent::CSynthEditEvent( const CSynthEditEvent* pEvent )
                    : CEditEvent( pEvent )
{
    if ( pEvent)
    {
        _pt.x = pEvent->_pt.x;
        _pt.y = pEvent->_pt.y;
    }
    else
    {
        _pt.x = -1;
        _pt.y = -1;
    }
}
    
HRESULT 
CSynthEditEvent::Init( const POINT* pt, EDIT_EVENT eType )
{    
    _pt = *pt;
    _eType = eType;

    return S_OK;
}

HRESULT 
CSynthEditEvent::GetElement( IHTMLElement** ppIElement ) 
{
    AssertSz( 0, "Invalid call to CSynthEditEvent::GetElement()" );
    return E_NOTIMPL;
}



HRESULT 
CSynthEditEvent::GetPoint( POINT * ppt )  
{
    Assert( ppt );
    ppt->x = _pt.x;
    ppt->y = _pt.y;

    return S_OK;
}

BOOL 
CSynthEditEvent::IsShiftKeyDown()  
{
    return ( GetKeyState(VK_SHIFT) & 0x8000) ;
}

BOOL 
CSynthEditEvent::IsControlKeyDown()  
{
    return (GetKeyState(VK_CONTROL) & 0x8000) ;
}

BOOL 
CSynthEditEvent::IsAltKeyDown()  
{
   // return (GetKeyState(VK_ALT) & 0x8000) ;
   return FALSE;
}

HRESULT 
CSynthEditEvent::GetKeyCode(LONG * pkeyCode)  
{
    return E_FAIL;
}

HRESULT 
CSynthEditEvent::Cancel()
{
    return E_FAIL; // cancelling won't do anything let the person who called this know
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\flatptr.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       flatptr.cxx
//
//  Contents:   Implementation of CFlatMarkupPointer
//
//  Classes:    CFlatMarkupPointer
//
//  History:    09-14-98 - ashrafm - created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

using namespace EdUtil;

DeclareTag(tagEditShowMarkupPointerNames, "Edit","Show MarkupPointer names")

#define WCH_GLYPH WCHAR(0xfffe)

HRESULT
ConvertPointerToInternal( CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal);

HRESULT
CreateMarkupPointer2( 
    CEditorDoc* pDoc, 
    IMarkupPointer** ppPointer 
#if DBG == 1
    , LPCTSTR szDebugName
#endif
);

#if DBG==1
#define CreateMarkupPointer(ppPointer)                      CreateMarkupPointer(ppPointer, L#ppPointer)
#define CreateMarkupPointer2(pEditor, ppPointer)            CreateMarkupPointer2(pEditor, ppPointer, L#ppPointer)
#endif

//+---------------------------------------------------------------------------
//
//  Class:      CFlatMarkupPointer 
//
//  Purpose:    Provide a flat view of the document tree
//
//----------------------------------------------------------------------------

class CFlatMarkupPointer : public IMarkupPointer2
{
public:
    CFlatMarkupPointer(CEditorDoc *pEditorDoc, IMarkupPointer2 *pPointer);
    ~CFlatMarkupPointer();

    //
    // IUnknown methods
    //
    
    STDMETHOD(QueryInterface) (REFIID, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    //
    // IMarkupPointer methods
    //
    
    STDMETHODIMP OwningDoc ( IHTMLDocument2 **ppDoc );
    STDMETHODIMP Gravity ( POINTER_GRAVITY *peGravity );
    STDMETHODIMP SetGravity ( POINTER_GRAVITY eGravity );
    STDMETHODIMP Cling ( BOOL *pfCling );
    STDMETHODIMP SetCling ( BOOL fCling );
    STDMETHODIMP MoveAdjacentToElement ( IHTMLElement *pElement, ELEMENT_ADJACENCY eAdj );
    STDMETHODIMP MoveToPointer ( IMarkupPointer *pPointer );
    STDMETHODIMP MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart );
    STDMETHODIMP Unposition ( );
    STDMETHODIMP IsPositioned ( BOOL * );
    STDMETHODIMP GetContainer ( IMarkupContainer * * );

    STDMETHODIMP Left (
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );
                       
    STDMETHODIMP Right (
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );

    STDMETHODIMP MoveUnit (
        MOVEUNIT_ACTION muAction );
                       
    STDMETHODIMP CurrentScope ( IHTMLElement * * ppElemCurrent );
    
    STDMETHODIMP FindText( 
        OLECHAR *        pchFindText, 
        DWORD            dwFlags,
        IMarkupPointer * pIEndMatch = NULL,
        IMarkupPointer * pIEndSearch = NULL
    );
    
    STDMETHODIMP IsLeftOf           ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsLeftOfOrEqualTo  ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsRightOf          ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsRightOfOrEqualTo ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsEqualTo          ( IMarkupPointer * pPointerThat, BOOL * pfAreEqual );

    ///////////////////////////////////////////////
    // IMarkupPointer2 methods

    STDMETHODIMP IsAtWordBreak( BOOL * pfAtBreak );
    STDMETHODIMP GetMarkupPosition( long * plMP );
    STDMETHODIMP MoveToMarkupPosition( IMarkupContainer * pContainer, long lMP );
    STDMETHODIMP MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound );
    STDMETHODIMP IsInsideURL ( IMarkupPointer *pRight, BOOL *pfResult );
    STDMETHODIMP MoveToContent( IHTMLElement* pIElement, BOOL fAtStart);

private:
    IMarkupServices *GetMarkupServices() {return _pEditorDoc->GetMarkupServices();}

    STDMETHODIMP There(
        Direction             dir,
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );
    
    STDMETHODIMP IsMarkupLeftOf(
        IMarkupPointer  *pPointer1, 
        IMarkupPointer  *pPointer2, 
        BOOL            *pfResult);    

    STDMETHODIMP SnapToGlyph(
        MOVEUNIT_ACTION muAction,
        IMarkupPointer *pStart,
        IMarkupPointer *pEnd);

private:    
    CEditorDoc       *_pEditorDoc;
    IMarkupPointer2  *_pPointer;
    LONG             _cRefs;
};

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CFlatMarkupPointer, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CFlatMarkupPointer::CFlatMarkupPointer(CEditorDoc *pEditorDoc, IMarkupPointer2 *pPointer)
{
    Assert(pPointer && pEditorDoc);
    _pPointer = pPointer;
    _pPointer->AddRef();
    _pEditorDoc = pEditorDoc;
    _cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CFlatMarkupPointer, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CFlatMarkupPointer::~CFlatMarkupPointer()
{
    Assert(_pPointer);
    _pPointer->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CFlatMarkupPointer::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CFlatMarkupPointer::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CFlatMarkupPointer::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown 
        || iid == IID_IMarkupPointer 
        || iid == IID_IMarkupPointer2)
    {
        *ppvObj = (IMarkupPointer2 *)this;
        AddRef();    
        return S_OK;
    }

    RRETURN( _pPointer->QueryInterface(iid, ppvObj) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::OwningDoc, public
//
//  Synopsis:   IMarkupPointer::OwningDoc implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::OwningDoc ( IHTMLDocument2 ** ppDoc )
{
    RRETURN( _pPointer->OwningDoc(ppDoc) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Gravity, public
//
//  Synopsis:   IMarkupPointer::Gravity implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Gravity ( POINTER_GRAVITY *peGravity )
{
    RRETURN( _pPointer->Gravity(peGravity) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::SetGravity, public
//
//  Synopsis:   IMarkupPointer::SetGravity implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::SetGravity ( POINTER_GRAVITY eGravity )
{
    RRETURN( _pPointer->SetGravity(eGravity) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Cling, public
//
//  Synopsis:   IMarkupPointer::Cling implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Cling ( BOOL * pfCling )
{
    RRETURN( _pPointer->Cling(pfCling) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::SetCling, public
//
//  Synopsis:   IMarkupPointer::SetCling implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::SetCling ( BOOL fCling )
{
    RRETURN( _pPointer->SetCling(fCling) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveAdjacentToElement, public
//
//  Synopsis:   IMarkupPointer::MoveAdjacentToElement.  
//
//              If pElement is a noscope element, then move to the containing 
//              markup if one exists.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveAdjacentToElement ( IHTMLElement *pElement, ELEMENT_ADJACENCY eAdj )
{
    HRESULT hr;

    //
    // Do a move to content if AfterBegin/BeforeEnd
    //

    switch (eAdj)
    {
        case ELEM_ADJ_AfterBegin:
        case ELEM_ADJ_BeforeEnd:
        {
            hr = THR( _pPointer->MoveToContent(pElement, (eAdj == ELEM_ADJ_AfterBegin) /* fStart */) );
            break;
        }

	default:
        {
            //
            // Do the normal move
            //
    
            hr = THR( _pPointer->MoveAdjacentToElement(pElement, eAdj) );
            break;
        }
    }
    
#if DBG==1
    //
    // We should never get the root element in the editor
    //
    
    ELEMENT_TAG_ID tagId;

    IGNORE_HR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    Assert(tagId != TAGID_NULL);
#endif
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToPointer, public
//
//  Synopsis:   IMarkupPointer::MoveToPointer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveToPointer ( IMarkupPointer * pIPointer )
{
    RRETURN( _pPointer->MoveToPointer(pIPointer) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToContainer, public
//
//  Synopsis:   IMarkupPointer::MoveToContainer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart )
{
    RRETURN( _pPointer->MoveToContainer(pContainer, fAtStart) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsPositioned, public
//
//  Synopsis:   IMarkupPointer::IsPositioned implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::IsPositioned ( BOOL * pfPositioned )
{
    RRETURN( _pPointer->IsPositioned(pfPositioned) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::GetContainer, public
//
//  Synopsis:   IMarkupPointer::GetContainer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::GetContainer ( IMarkupContainer * * ppContainer )
{
    RRETURN( _pPointer->GetContainer(ppContainer) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Unposition, public
//
//  Synopsis:   IMarkupPointer::Unposition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Unposition ( )
{
    RRETURN( _pPointer->Unposition() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Left, public
//
//  Synopsis:   IMarkupPointer::Left implementation that will hide
//              markup boundaries.  See CFlatMarkupPointer::There.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Left (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchtext )
{
    RRETURN( There(LEFT, fMove, pContext, ppElement, pcch, pchtext) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Right, public
//
//  Synopsis:   IMarkupPointer::Right implementation that will hide
//              markup boundaries.  See CFlatMarkupPointer::There.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Right (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText )
{
    RRETURN( There(RIGHT, fMove, pContext, ppElement, pcch, pchText) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveUnit, public
//
//  Synopsis:   IMarkupPointer::MoveUnit implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CFlatMarkupPointer::MoveUnit( MOVEUNIT_ACTION muAction )
{
    HRESULT     hr;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTEREND:
        {
            SP_IMarkupPointer   spStart;

            IFC( CreateMarkupPointer2(_pEditorDoc, &spStart) );
            IFC( spStart->MoveToPointer(_pPointer) );    
            IFC( _pPointer->MoveUnit(muAction) );
            
            IFC( SnapToGlyph(muAction, spStart, _pPointer) );
            break;
        }

        default:
            IFC( _pPointer->MoveUnit(muAction) );
    }

Cleanup:        
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CurrentScope, public
//
//  Synopsis:   IMarkupPointer::CurrentScope implementation 
//
//              If current scope is NULL, we get the master element
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::CurrentScope ( IHTMLElement ** ppElemCurrent )
{
    HRESULT hr;

    IFC( _pPointer->CurrentScope(ppElemCurrent) );
    if ((*ppElemCurrent) == NULL)
    {
        SP_IMarkupContainer  spContainer;
        SP_IMarkupContainer2 spContainer2;
        
        //
        // Get the master element
        //

        IFC( _pPointer->GetContainer(&spContainer) );
        if (spContainer == NULL)
            goto Cleanup; // same behavior as CurrentScope
        
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(ppElemCurrent) );
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::FindText, public
//
//  Synopsis:   IMarkupPointer::FindText implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::FindText (
    OLECHAR *        pchFindText, 
    DWORD            dwFlags,
    IMarkupPointer * pIEndMatch, /* =NULL */
    IMarkupPointer * pIEndSearch /* =NULL */)
{
    RRETURN( _pPointer->FindText(pchFindText, dwFlags, pIEndMatch, pIEndSearch) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToContent, public
//
//  Synopsis:   IMarkupPointer::MoveToContent implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
HRESULT
CFlatMarkupPointer::MoveToContent( IHTMLElement* pIElement, BOOL fAtStart )
{
    RRETURN( _pPointer->MoveToContent(pIElement, fAtStart) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveUnitBounded, public
//
//  Synopsis:   IMarkupPointer::MoveUnitBounded implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound )
{
    HRESULT             hr;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
        case MOVEUNIT_NEXTCLUSTEREND:
        {
            SP_IMarkupPointer   spStart;

            IFC( CreateMarkupPointer2(_pEditorDoc, &spStart) );
            IFC( spStart->MoveToPointer(_pPointer) );    
            IFC( _pPointer->MoveUnitBounded(muAction, pmpBound) );
            
            IFC( SnapToGlyph(muAction, spStart, _pPointer) );
            break;
        }

        default:
            IFC( _pPointer->MoveUnitBounded(muAction, pmpBound) );
    }

Cleanup:        
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsAtWordBreak, public
//
//  Synopsis:   IMarkupPointer::IsAtWordBreak implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsAtWordBreak( BOOL * pfAtBreak )
{
    RRETURN( _pPointer->IsAtWordBreak(pfAtBreak) );
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::GetMarkupPosition, public
//
//  Synopsis:   IMarkupPointer::GetMarkupPosition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::GetMarkupPosition( long * plMP )
{
    RRETURN( _pPointer->GetMarkupPosition(plMP) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToMarkupPosition, public
//
//  Synopsis:   IMarkupPointer::MoveToMarkupPosition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::MoveToMarkupPosition(IMarkupContainer * pContainer, long lMP)
{
    RRETURN( _pPointer->MoveToMarkupPosition(pContainer, lMP) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsInsideURL, public
//
//  Synopsis:   IMarkupPointer::IsInsideURL implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsInsideURL(IMarkupPointer *pRight, BOOL *pfResult)
{
    RRETURN( _pPointer->IsInsideURL(pRight, pfResult) );
}
  

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsLeftOf, public
//
//  Synopsis:   IMarkupPointer::IsLeftOf.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsLeftOf( IMarkupPointer * pPointer, BOOL * pfResult )
{
    HRESULT hr;

    hr = _pPointer->IsLeftOf(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
        IFC( IsMarkupLeftOf(_pPointer, pPointer, pfResult) );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsRightOf, public
//
//  Synopsis:   IMarkupPointer::IsRightOf.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsRightOf( IMarkupPointer * pPointer, BOOL * pfResult )
{
    HRESULT hr;

    hr = _pPointer->IsRightOf(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
        IFC( IsMarkupLeftOf(pPointer, _pPointer, pfResult) );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsEqualTo implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsEqualTo( IMarkupPointer * pPointerThat, BOOL * pfAreEqual )
{
    HRESULT hr;

    hr = _pPointer->IsEqualTo(pPointerThat, pfAreEqual);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	*pfAreEqual = FALSE;
	hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsLeftOfOrEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsLeftOfOrEqualTo.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsLeftOfOrEqualTo  (IMarkupPointer *pPointer, BOOL * pfResult)
{
    HRESULT hr;

    hr = _pPointer->IsLeftOfOrEqualTo(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	// If they are equal, we won't get CTL_E_INCOMPATIBLEPOINTERS
        IFC( IsMarkupLeftOf(_pPointer, pPointer, pfResult) );        
    }
    
Cleanup:    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsRightOfOrEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsRightOfOrEqualTo.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsRightOfOrEqualTo  (IMarkupPointer *pPointer, BOOL * pfResult)
{
    HRESULT hr;

    hr = THR( _pPointer->IsRightOfOrEqualTo(pPointer, pfResult) );

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	// If they are equal, we won't get CTL_E_INCOMPATIBLEPOINTERS
        IFC( IsMarkupLeftOf(pPointer, _pPointer, pfResult) );        
    }
    
Cleanup:    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsMarkupLeftOf, private
//
//  Synopsis:   IMarkupPointer::IsMarkupLeftOf.
//
//              Do markup aware IsLeftOf comparison.
//
//----------------------------------------------------------------------------
HRESULT
CFlatMarkupPointer::IsMarkupLeftOf(
    IMarkupPointer  *pPointer1, 
    IMarkupPointer  *pPointer2, 
    BOOL            *pfResult)
{
    HRESULT                      hr;
    CPtrAry<IMarkupContainer *>  aryParentChain1(Mt(Mem));
    CPtrAry<IMarkupContainer *>  aryParentChain2(Mt(Mem));
    SP_IMarkupPointer            spPointer1;
    SP_IMarkupPointer            spPointer2;
    INT                          iChain1, iChain2;
    SP_IHTMLElement              spElement;
    SP_IMarkupContainer2         spContainer2;
    BOOL                         fPointer2MovedMarkups = FALSE;
    INT                          i;

    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer1) );
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer2) );

    //
    // Compute the markup parent chain for each pointer
    //

    IFC( spPointer1->MoveToPointer(pPointer1) );
    IFC( ComputeParentChain(spPointer1, aryParentChain1) );
    IFC( spPointer1->MoveToPointer(pPointer1) );
    
    IFC( spPointer2->MoveToPointer(pPointer2) );
    IFC( ComputeParentChain(spPointer2, aryParentChain2) );
    IFC( spPointer2->MoveToPointer(pPointer2) );

    iChain1 = aryParentChain1.Size()-1;
    iChain2 = aryParentChain2.Size()-1;

    //
    // Must have positioned pointers because we call the markup services
    // compare first before IsMarkupLeftOf.  If the pointers are unpositioned,
    // we'll fail before we get here
    //

    Assert(iChain1 >= 0 && iChain2 >= 0);

    //
    // Make sure the top markups are the same
    //

    if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    for (;;)
    {
        iChain1--;
        iChain2--;

        //
        // Check if one markup is contained within another
        //
        if (iChain1 < 0 || iChain2 < 0)
        {
            // (iChain1 < 0 && iChain2 < 0) implies same markup.  This function should not be
            // called in this case
            Assert(iChain1 >= 0 || iChain2 >= 0);

            if (iChain1 < 0)
            {
                Assert( aryParentChain2[iChain2] );
                if( aryParentChain2[iChain2] )
                {
                    IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement(&spElement) );
                    IFC( spPointer2->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    fPointer2MovedMarkups = TRUE;
                }
            }
            else
            {
                Assert( aryParentChain1[iChain1] );
                if( aryParentChain1[iChain1] )
                {
                    IFC( aryParentChain1[iChain1]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement(&spElement) );
                    IFC( spPointer1->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                }
            }
            break;
        }

        //
        // Check if we've found the first different markup in the chain
        //
                
        if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
        {
            Assert( aryParentChain1[iChain1] && aryParentChain2[iChain2] );
            
            if( aryParentChain1[iChain1] && aryParentChain2[iChain2] )
            {
                IFC( aryParentChain1[iChain1]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );
                IFC( spPointer1->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );

                IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );
                IFC( spPointer2->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                fPointer2MovedMarkups = TRUE;
            }
            break;
        }
    }

    if (fPointer2MovedMarkups)
        IFC( spPointer1->IsLeftOfOrEqualTo(spPointer2, pfResult) )
    else
        IFC( spPointer1->IsLeftOf(spPointer2, pfResult) );
    
Cleanup:
    for (i = 0; i < aryParentChain1.Size(); i++)
        ReleaseInterface(aryParentChain1[i]);

    for (i = 0; i < aryParentChain2.Size(); i++)
        ReleaseInterface(aryParentChain2[i]);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::There, private
//
//  Synopsis:   Do markup aware IsLeftOf comparison.
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::There(
        Direction             dir,
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText )
{
    HRESULT                 hr = S_OK;
    MARKUP_CONTEXT_TYPE     context;
    IHTMLElement            *pElementInternal = NULL;
    BOOL                    fCheckGlyphs = !_pEditorDoc->ShouldIgnoreGlyphs() && (pContext != NULL);

    if (!pContext)
        pContext = &context;

    if (!ppElement)
        ppElement= &pElementInternal;

    *ppElement = NULL;       

    //
    // Try to move
    //

    switch (dir)
    {
        case LEFT:
            IFC( _pPointer->Left(fMove, pContext, ppElement, pcch, pchText) );
            break;

        case RIGHT:
            IFC( _pPointer->Right(fMove, pContext, ppElement, pcch, pchText) );
            break;

        default:
            AssertSz(0, "CFlatMarkupPointer::There - Unhandled move direction");
    }

    switch (*pContext)
    {
        case CONTEXT_TYPE_NoScope:
        {
            //
            // Flatten noscope elements
            //

            if (SUCCEEDED( _pPointer->MoveToContent(*ppElement, (dir == RIGHT) /* fStart */) ))
            {
                *pContext = CONTEXT_TYPE_EnterScope;
            }
            else if (fMove)
            {
                IFC( _pPointer->MoveAdjacentToElement(*ppElement, (dir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
            }

            if (!fMove)
            {
                IFC( _pPointer->MoveAdjacentToElement(*ppElement, (dir == LEFT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
            }
            break;
        }

        case CONTEXT_TYPE_EnterScope:
        {
            //
            // Check for entering an element that is view-linked
            //
            
            if (fMove)
            {
                IFC( _pPointer->MoveToContent(*ppElement, (dir == RIGHT) /* fStart */) );
            }
                
            break;
        }
        
        case CONTEXT_TYPE_None:
        {
            SP_IMarkupContainer     spContainer;
            SP_IMarkupContainer2    spContainer2;
            SP_IHTMLElement         spElement;

            //
            // Check for master element.  If found, flatten
            //

            IFC( _pPointer->GetContainer(&spContainer) );

            if (spContainer != NULL)
            {
                IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );

                if (spElement != NULL)
                {
                    if (fMove)
                    {
                        IFC( _pPointer->MoveAdjacentToElement(spElement, (dir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                    }   
                    if (ppElement)
                    {
                        ReplaceInterface(ppElement, spElement.p);                
                    }
                    *pContext = CONTEXT_TYPE_ExitScope;
                }
            }
            break;
        }
    }

    if (fCheckGlyphs && (*ppElement))
    {
        switch (*pContext)
        {
            case CONTEXT_TYPE_NoScope:
            {
                SP_IHTMLElement3    spElement3;
                LONG                lGlyphMode;

                IFC( (*ppElement)->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                IFC( spElement3->get_glyphMode(&lGlyphMode) );

                if (lGlyphMode)
                {
                    if (pcch)
                        *pcch = 1;

                    if (pchText)
                        *pchText = WCH_GLYPH;

                    *pContext = CONTEXT_TYPE_Text;
                }
                break;
            }

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            {
                SP_IHTMLElement3    spElement3;
                LONG                lGlyphMode;

                IFC( (*ppElement)->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                IFC( spElement3->get_glyphMode(&lGlyphMode) );

                if (lGlyphMode)
                {
                    BOOL fHasGlyph = FALSE;
                    
                    switch (*pContext)
                    {
                        case CONTEXT_TYPE_EnterScope:
                            fHasGlyph = (lGlyphMode & ((dir == RIGHT) ? htmlGlyphModeBegin : htmlGlyphModeEnd));
                            break;

                        case CONTEXT_TYPE_ExitScope:
                            fHasGlyph = (lGlyphMode & ((dir == RIGHT) ? htmlGlyphModeEnd : htmlGlyphModeBegin));
                            break;                        
                    }

                    if (fHasGlyph)
                    {
                        ELEMENT_TAG_ID tagId;
                        
                        IFC( GetMarkupServices()->GetElementTagId(*ppElement, &tagId) );

                        if (!EdUtil::IsListItem(tagId) 
                            && !EdUtil::IsListContainer(tagId) 
                            && EdUtil::IsLayout(*ppElement) == S_FALSE)
                        {    
                            if (pcch)
                                *pcch = 1;

                            if (pchText)
                                *pchText = WCH_GLYPH;

                            *pContext = CONTEXT_TYPE_Text;
                        }
                    }

                }
                break;
            }
        }
    }
    
Cleanup:    
    ReleaseInterface(pElementInternal);
    
    RRETURN(hr);    
}



//+---------------------------------------------------------------------------
//
//  Member:     GetParentElement, public
//
//  Synopsis:   Get the parent element.  If it is NULL, then get the 
//              master element
//
//----------------------------------------------------------------------------
HRESULT 
GetParentElement(IMarkupServices *pMarkupServices, IHTMLElement *pSrcElement, IHTMLElement **ppParentElement)
{
    HRESULT hr;

    Assert(ppParentElement && pSrcElement);

    IFC( pSrcElement->get_parentElement(ppParentElement) );

    if ((*ppParentElement) == NULL)
    {
        SP_IMarkupPointer       spPointer;
        SP_IMarkupContainer     spContainer;
        SP_IMarkupContainer2    spContainer2;

        IFC( MarkupServices_CreateMarkupPointer(pMarkupServices, &spPointer) );
        
        hr = THR( spPointer->MoveAdjacentToElement(pSrcElement, ELEM_ADJ_BeforeBegin) );
        Assert(hr == S_OK);
        IFC(hr);

        IFC( spPointer->GetContainer(&spContainer) );
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(ppParentElement) );
    }

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CFlatMarkupPointer::SnapToGlyph(MOVEUNIT_ACTION muAction, IMarkupPointer *
pStart, IMarkupPointer *pAdjust)
{
    HRESULT                 hr;
    Direction               dir = RIGHT;
    WCHAR                   ch;
    MARKUP_CONTEXT_TYPE     context;
    LONG                    cch;
    BOOL                    fDone;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
            dir = LEFT;
            break;

        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTEREND:
            dir = RIGHT;
            break;

        default:
            AssertSz(0, "Unsupported muAction in SnapToGlyph ");
    }            

    for (;;)
    {
        cch = 1;
        if (dir == RIGHT)
        {
            IFC( pStart->Right(TRUE, &context, NULL, &cch, &ch) );
            IFC( pStart->IsRightOfOrEqualTo(pAdjust, &fDone) );
        }
        else
        {
            IFC( pStart->Left(TRUE, &context, NULL, &cch, &ch) );
            IFC( pStart->IsLeftOfOrEqualTo(pAdjust, &fDone) );
        }

        if (fDone)
            break;

        if (context == CONTEXT_TYPE_Text && ch == WCH_GLYPH)
        {
            IFC( pAdjust->MoveToPointer(pStart) );
            break;
        }                    
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::ConvertPointerToInternal, public
//
//  Synopsis:   Convert an external markup pointer to a flat markup pointer
//
//----------------------------------------------------------------------------
HRESULT
ConvertPointerToInternal( CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal)
{
    HRESULT                 hr;
    CFlatMarkupPointer      *pPointerInternal = NULL;
    SP_IMarkupPointer2      spPointer2;

    if (ppInternal == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pPointer == NULL)
    {
        hr = S_OK;
        *ppInternal = NULL;
        goto Cleanup;
    }

    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) ) ;

    pPointerInternal = new CFlatMarkupPointer(pDoc, spPointer2);
    if (!pPointerInternal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( pPointerInternal->QueryInterface(IID_IMarkupPointer, (LPVOID *)ppInternal) );

Cleanup:
    ReleaseInterface(pPointerInternal);
    RRETURN(hr);
}


#undef CreateMarkupPointer
#undef CreateMarkupPointer2

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::CreateMarkupPointer, public
//
//  Synopsis:   Create a flat markup pointer
//
//----------------------------------------------------------------------------

HRESULT 
CEditorDoc::CreateMarkupPointer(
    IMarkupPointer **ppPointer
#if DBG==1
    ,LPCTSTR szDebugName
#endif    
    )
{
#if DBG==1
    RRETURN(CreateMarkupPointer2(this, ppPointer, szDebugName));
#else
    RRETURN(CreateMarkupPointer2(this, ppPointer));
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CreateMarkupPointer2
//
//  Synopsis:   Create a flat markup pointer
//
//----------------------------------------------------------------------------
HRESULT
CreateMarkupPointer2(
    CEditorDoc      *pEditorDoc,
    IMarkupPointer  **ppPointer
#if DBG==1
    ,LPCTSTR szDebugName
#endif    
)
{
    HRESULT                 hr;
    CFlatMarkupPointer      *pPointerInternal = NULL;
    SP_IMarkupPointer       spMarkupPointer;
    SP_IMarkupPointer2      spMarkupPointer2;

    if (ppPointer == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pEditorDoc->GetMarkupServices()->CreateMarkupPointer(&spMarkupPointer) );
    IFC( spMarkupPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spMarkupPointer2) );

    pPointerInternal = new CFlatMarkupPointer(pEditorDoc, spMarkupPointer2);
    if (!pPointerInternal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    IFC( pPointerInternal->QueryInterface(IID_IMarkupPointer, (LPVOID *)ppPointer) );

#if DBG==1
    //
    // Set the debug name so that all pointers have some default name    
    //

    if (IsTagEnabled(tagEditShowMarkupPointerNames))
    {
        Assert(szDebugName);

        IEditDebugServices *pEditDebugServices;
        
        if (SUCCEEDED(pEditorDoc->GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(spMarkupPointer2, szDebugName) );
        ReleaseInterface(pEditDebugServices);
        }
    }
#endif
    
Cleanup:
    ReleaseInterface(pPointerInternal);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\edunhlpr.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

//+====================================================================================
//
// Method: CreateAndSubmit
//
// Synopsis: Calls create to create an Undo Unit and add it to the UndoManager.
//
//------------------------------------------------------------------------------------


HRESULT 
CUndoHelper::CreateAndSubmit( )
{
    HRESULT         hr = S_OK;
    IOleUndoUnit *  pUU = NULL;
    SP_IOleUndoManager spUndoMgr;
    
    IFC( CreateUnit(& pUU));
    if( !pUU )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( _pEd->GetUndoManager( & spUndoMgr ));
    IFC( spUndoMgr->Add( pUU ) ) ;

Cleanup:
    if( pUU )
        pUU->Release();

    RRETURN( hr );
}


//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CUndoBase::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CUndoUnitBase::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this , IUnknown )
        QI_INHERITS( this , IOleUndoUnit )
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

HRESULT 
CUndoUnitBase::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr;

    //
    // marka - the units in trident set the state
    // as our selection undo units are added underneath another parent unit
    // the state should be set for us. 
    //
    
    hr = PrivateDo( pUndoManager );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\edunits.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MALLOC_H_
#define X_MALLOC_H_
#include "malloc.h"
#endif

#ifndef X_EDUNITS_HXX_
#define X_EDUNITS_HXX_
#include "edunits.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

using namespace EdUtil;

extern BOOL g_fInVizAct2000  ;

/////////////////////////////////////////////////////////////////////////////
static const WCHAR* s_pwszPixUnits = L"px";
#define EDU_THOUSANDTHS_OF_PIXEL 1000
/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetLeft
// Sets new Left of the positioned element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetLeft(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT hr = S_OK;

    IFC(GetPixelLeft(pIElement));

    AdjustLeftDimensions(pIElement, &lNewValue);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtLeft;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtLeft );
        V_VT( & vtLeft ) = VT_I4;
        V_I4( & vtLeft ) = lNewValue ;
        hr = spStyle->put_left( vtLeft );
        VariantClear (&vtLeft);

        goto Cleanup;
    }

    IFC (ExtractCurrentLeft(pIElement));

    IFC (SetLeftValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetTop
// Sets new Top of the positioned element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetTop(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT hr = S_OK;

    IFC(GetPixelTop(pIElement));

    AdjustTopDimensions(pIElement, &lNewValue);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtTop;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtTop );

        V_VT( & vtTop ) = VT_I4;
        V_I4( & vtTop ) = lNewValue ;

        hr = spStyle->put_top( vtTop );
        VariantClear (&vtTop);

        goto Cleanup;
    }
    
    IFC (ExtractCurrentTop(pIElement));

    IFC (SetTopValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetHeight
// Sets new height of the element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetHeight(IHTMLElement* pIElement, long lNewValue, ELEMENT_TAG_ID eTag)
{
    HRESULT hr = S_OK;

    if (lNewValue <= 0)
        goto Cleanup; // just ignore it. Negative values may come from mouse movements

    if (_lPixValue <= 0)
    {
        IFC(GetPixelHeight(pIElement));
    }
    
    AdjustHeightDimensions(pIElement, &lNewValue,eTag);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtHeight;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtHeight );
        V_VT( & vtHeight ) = VT_I4;
        V_I4( & vtHeight ) = lNewValue ;
        hr = spStyle->put_height( vtHeight );
        VariantClear (&vtHeight);

        goto Cleanup;
    }

    IFC (ExtractCurrentHeight(pIElement));

    IFC (SetHeightValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetWidth
// Sets new width of the element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetWidth(IHTMLElement* pIElement, long lNewValue, ELEMENT_TAG_ID eTag)
{
    HRESULT hr = S_OK;

    if (lNewValue <= 0)
        goto Cleanup; // just ignore it. Negative values may come from mouse movements

    if (_lPixValue <= 0)
    {
       IFC (GetPixelWidth(pIElement));
    }
    AdjustWidthDimensions(pIElement, &lNewValue,eTag);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)    
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtWidth;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtWidth );

        V_VT( & vtWidth ) = VT_I4;
        V_I4( & vtWidth ) = lNewValue ;

        hr = spStyle->put_width( vtWidth );

        VariantClear( &vtWidth );

        goto Cleanup;
    }


    IFC (ExtractCurrentWidth(pIElement));

    IFC (SetWidthValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}   

////////////////////////////////////////////////////////////////////
//
// CEdUnits::ExtractValueFromVariant
//
// Extracts value in units and the unit designator from a VARIANT (V_BSTR)
// The string looks like Xu where X is a floating point number
// and u is a unit designator ("px", "mm", etc).
//
HRESULT CEdUnits::ExtractValueFromVariant(VARIANT v)
{
    // VARIANT must be V_BSTR, otherwise there is no information on units
    if (V_VT(&v) == VT_BSTR)
    {
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {    
            return ExtractUnitValueFromString(V_BSTR(&v));
        }
        // if the string is empty, the fall down to default units
    }
    else 
    { 
        Assert(V_VT(&v) == VT_EMPTY);    
    } // if the VARIANT is not string, then it must be VT_EMPTY

     _rUnitValue = (double)_lPixValue;
     
    if(_bstrUnits)
        ::SysFreeString(_bstrUnits);

    _bstrUnits = ::SysAllocString(s_pwszPixUnits);
    return NULL != _bstrUnits ? S_OK : E_OUTOFMEMORY;
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::ExtractUnitValueFromString
//
// Extracts value in units and the unit designator from a string
// The string looks like Xu where X is a floating point number
// and u is a unit designator ("px", "mm", etc).
//
// NOTE: The method does no accept scientific notation like .5E+6
// Also I don't attempt to handle something like "width=A08@#$%"
// This will end up as width = 0 units A08@#$% 
//
HRESULT CEdUnits::ExtractUnitValueFromString(WCHAR* pwszValue)
{
    HRESULT hr = E_FAIL;
    WCHAR*  pwsz = NULL;
    WCHAR*  pwszUnits = NULL;
    int iSign = 0;
    
    pwszUnits = pwszValue;

    // skip spaces if any
    while(*pwszUnits && ::iswspace(*pwszUnits))
        pwszUnits++;

    if (_tcslen(pwszUnits) > 0)
    {
        if ( pwszUnits[0] == _T('+') || pwszUnits[0] == _T('-') )
        {
            iSign = (pwszUnits[0] == _T('+')) ? +1 : -1 ;
            pwszUnits++;
        }

        // First get the integer part of the value in units     
        _rUnitValue = (double)::_wtoi(pwszUnits);
    
        // skip up to the decimal point, if any 
        pwsz = pwszValue;
        while(*pwsz && '.' != *pwsz)
            pwsz++;

        // if the dot is found then there is a fractional part
        if(0 != *pwsz)
        {    
            double div = 10;
            int count = 0;

            pwsz++;    // skip the decimal point
            // Convert fractional part (up to 4 digits)
            while(*pwsz && *pwsz >= L'0' && *pwsz <= L'9' && count < 4)
            {    // convert fractional part
                _rUnitValue += ((double) (*pwsz - L'0'))/div;

                div *= 10;
                count++;
                pwsz++;
            }
        }
        else // if there is no decimal point, then units follow (possibly prepended by tab and/or spaces)
            pwsz = pwszUnits;

        // skip numerical part (either the value when it is like "809px" or the remaining 
        // part of the fraction if value looks like "70.123456 mm"
        while(*pwsz && *pwsz >= L'0' && *pwsz <= L'9')
            pwsz++;

        // now skip spaces...
        while(*pwsz && ::iswspace(*pwsz))
            pwsz++;

        if (iSign != 0)
            _rUnitValue *= iSign ;
  
        // and what remains is the unit designator
        if (_tcsicmp(pwsz, s_pwszPixUnits) == 0)
        {
            _rUnitValue = (double)_lPixValue ;
        }
    }
    else
    {
        _rUnitValue = (double)_lPixValue ;
    }
    if (_bstrUnits)
        ::SysFreeString(_bstrUnits);

    _bstrUnits = ::SysAllocString(*pwsz ? pwsz : s_pwszPixUnits); 
    hr = NULL != _bstrUnits ? S_OK : E_OUTOFMEMORY; 

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// CEdUnits::MakeVariant
//
// Constructs VARIANT (VT_BSTR) from pixel value.
// The pixel value gets converted into value in units.
//
HRESULT CEdUnits::MakeVariant(long lNewPixValue, VARIANT* pv, BOOL fOverrideAuto /*=TRUE*/)
{
    double rNewValue;
    WCHAR* pwsz;
    int    iValue = 0;
    BOOL   fNeedToCalculateValue=TRUE;
    
    Assert(_bstrUnits);
    Assert(V_VT(pv) == VT_EMPTY);

    pwsz = (WCHAR*)::_alloca(sizeof(WCHAR)*::wcslen(_bstrUnits) + 64); // should be sufficient to print out double value

    if ( StrCmpIW(_T("auto"), _bstrUnits ) == 0)
    {
        if (fOverrideAuto)
        {
            _tcscpy(_bstrUnits, s_pwszPixUnits);
            _rUnitValue = (double)_lPixValue;
        }
        else
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%ls",_bstrUnits);
            fNeedToCalculateValue = FALSE;
        }
    }

    if (fNeedToCalculateValue)
    {
        // Simple proportion to calculate new value in units
        if (_rUnitValue == 0)
            _rUnitValue = 0.01;

        if (_lPixValue != 0)
        {
            rNewValue = (double)lNewPixValue/(double)_lPixValue * _rUnitValue;
        }
        else
        {
            rNewValue = (double)lNewPixValue;
        }

        if (rNewValue >= 0)
            iValue = (int)(rNewValue + 0.5);
        else
            iValue = (int)(rNewValue - 0.5);

        // If the value has fractional part, round it to 3 digits after period
        // If it does no have fractional part, print it out as an integer
        // The append units designator
        if (((rNewValue - (double)iValue) < 0.001 && (rNewValue - (double)iValue) > -0.001)  ||
             0 == ::_wcsicmp(_bstrUnits, s_pwszPixUnits))
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%2d%ls",iValue, _bstrUnits);
        }
        else if (rNewValue < 0)
        {
            //  rNewValue could be between 0 and -1, in which case the fractional part
            //  calculations will give a negative number.  We need to make rNewValue
            //  positive and then do our calculations and generate a negative output.

            rNewValue *= -1;
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"-%d.%03d%ls", (int)rNewValue, (int)(1000*rNewValue) - 1000*((int)rNewValue), _bstrUnits);
            rNewValue *= -1;
        }
        else
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%3d.%03d%ls", (int)rNewValue, (int)(1000*rNewValue) - 1000*((int)rNewValue), _bstrUnits);
        }
    }
            
    
    V_VT(pv)   = VT_BSTR;
    V_BSTR(pv) = ::SysAllocString(pwsz) ;
    
    if (NULL == V_BSTR(pv))
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT 
CEdUnits::ExtractLeftFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_left(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
        else
        {
            IFC(GetCurrentStyleLeft(pIElement));
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractTopFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_top(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
        else
        {
            IFC (GetCurrentStyleTop(pIElement));
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractHeightFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_height(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractWidthFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT        hr = S_OK ;
    VARIANT        v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_width(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}


HRESULT
CEdUnits::ExtractCurrentLeft(IHTMLElement* pIElement)
{
    HRESULT         hr = S_OK ;
    SP_IHTMLStyle   spStyle;

    // First try to extract value from element's style first. 
    // This method will NOT set default (pixel) units, if the style is not present
    hr = ExtractLeftFromElementStyle(pIElement);
    if (S_FALSE == hr) // the style is not present
    {
        // The style is not present.
        // Try to get left or top from the element tag. This valid only for certain elements:
        // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea
        _fChangeStyle = TRUE;
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
    }
    RRETURN (S_OK); 
}

HRESULT
CEdUnits::ExtractCurrentTop(IHTMLElement* pIElement)
{
    HRESULT         hr = S_OK ;
    SP_IHTMLStyle   spStyle;

    // First try to extract value from element's style first. 
    // This method will NOT set default (pixel) units, if the style is not present
    hr = ExtractTopFromElementStyle(pIElement);
    if (S_FALSE == hr) // the style is not present
    {
        // The style is not present.
        // Try to get left or top from the element tag. This valid only for certain elements:
        // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea
        _fChangeStyle = TRUE;
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
    }

    RRETURN (S_OK); 
}

HRESULT
CEdUnits::ExtractCurrentHeight(IHTMLElement* pIElement)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtOldHeight ;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    SP_IHTMLSelectElement   spSelectElement;
    LONG                    lDimension = 0 ;

    VariantInit( &vtOldHeight);

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
    {
        if (SUCCEEDED(spTextAreaElement->get_rows(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue) /lDimension ;   // for rows of text area
            }
        }
    }
    //
    // IE #13629 : Adding the case for the Size of the Select Element ( for the select element, the 
    // size signifies the number of rows) 
    //
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLSelectElement, (void**)&spSelectElement)) )
    {
        if ( SUCCEEDED(spSelectElement->get_size(&lDimension)) )
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension; 
            }
        }
    }


    //
    // IE #13629 : If the CSS Editing Level is 0 then we shouldn't care about
    // either the style or the currentStyle, so if the CSS level is 0, we
    // skip these.
    //

    if ( GetCSSEditingLevel() )
    {
        // First try to extract value from element's style first. 
        // This method will NOT set default (pixel) units, if the style is not present
        hr = ExtractHeightFromElementStyle(pIElement);

        if (S_FALSE == hr) // the inline style is not present
        {
            // try to get the style from style sheet rules, look for currentstyle documentation 
            // see whether the stylesheet rules values 
            hr = GetCurrentStyleHeight(pIElement);
        }        
    }

    _fChangeHTMLAttribute = FALSE;

    // Try to get width or height from the element tag. This valid only for certain elements:
    // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea

    //
    //  check to see whether the element attribute needs an update
    //
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
    {
        if (SUCCEEDED(spTable->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
    {
        if (SUCCEEDED(spTableCell->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        if (SUCCEEDED(spImageElement->get_height(&_lPixValue)))
        {
            _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
    {
        if ( (SUCCEEDED(spHRElement->get_size(&vtOldHeight))) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0)
            || !_fChangeStyle)
        {
            _fChangeHTMLAttribute = TRUE;
 
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
    {
        if (SUCCEEDED(spEmbedElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
    {
        if (SUCCEEDED(spMarqueeElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
    {
        if (SUCCEEDED(spObjectElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }

    //
	// If we have no indication so var as to whether we will be changing the 
	// style or the attribute, we would apply this value to the the style
	// *if and only if* the CSS editing level is not 0
	//
		
    if (!_fChangeHTMLAttribute && !_fChangeStyle && GetCSSEditingLevel())
    {
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
        _fChangeStyle    = TRUE ;
        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;    // don't care, if you come here, means you will live long 
    }    

Cleanup :
    VariantClear(&vtOldHeight);
    RRETURN (hr); 
}

HRESULT
CEdUnits::SetLeftValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT        hr = S_OK ;
    VARIANT        vtLeft; 
    SP_IHTMLStyle  spStyle;

    // Create a VARIANT (BSTR with value in units) out of the value in pixels
    VariantInit(&vtLeft);
    IFC (MakeVariant(lNewValue, &vtLeft));

    // If the original value was in a style, apply new to the style
    if (_fChangeStyle && GetCSSEditingLevel())
    {
        // Check if style is present. It is always present in IE4 and IE5, but can be empty
        IFC(pIElement->get_style(&spStyle));
        IFC (spStyle->put_left(vtLeft));
    }

 Cleanup :
    VariantClear (&vtLeft);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::SetTopValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT        hr = S_OK ;
    VARIANT        vtTop ; 
    SP_IHTMLStyle  spStyle;

    // Create a VARIANT (BSTR with value in units) out of the value in pixels
    VariantInit(&vtTop);
    IFC (MakeVariant(lNewValue, &vtTop));

    // If the original value was in a style, apply new to the style
    if (_fChangeStyle && GetCSSEditingLevel())
    {
        // Check if style is present. It is always present in IE4 and IE5, but can be empty
        IFC(pIElement->get_style(&spStyle));
        IFC (spStyle->put_top(vtTop));
    }

 Cleanup :
    VariantClear (&vtTop);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::SetHeightValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtHeight ; 
    VARIANT                 vtNull;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    SP_IHTMLSelectElement   spSelectElement;
    LONG                    lDimension = 0 ;

    VariantInit(&vtHeight);
    
    // IE# 18704 If CSSEditingLevel is Zero, then we need to make sure that there are no in-line 
    // styles that will mess us up
    if ( !GetCSSEditingLevel() )
    {

        VariantInit(&vtNull);
        V_VT(&vtNull) = VT_BSTR;
        V_BSTR(&vtNull) = NULL;
        IFC (pIElement->get_style(&spStyle) );
        IFC (spStyle->put_height(vtNull) );

    }

    if (!_fChangeStyle && SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        hr = spImageElement->put_height(lNewValue);
        goto Cleanup;
    }

    if (_lCharDimension > 0 )
    {
        if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;   // for rows of textarea
            hr = spTextAreaElement->put_rows(lDimension);
        }
        else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLSelectElement, (void**)&spSelectElement)))
        {
            if (GetCSSEditingLevel() == 0)
            {
                lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;
                hr = spSelectElement->put_size(lDimension);
            }
        }
    } // fall through to set the default height
    

    //
    // Because of the change in the default case in ExtractCurrentXXXX for 
    // CSS Editing Level 0, there is the possibility that this MakeVariant is not
    // necessary
    //

    if(_fChangeStyle || _fChangeHTMLAttribute)
    {
        // Create a VARIANT (BSTR with value in units) out of the value in pixels
        IFC (MakeVariant(lNewValue, &vtHeight));

        // If the original value was in a style, apply new to the style
        if (_fChangeStyle && GetCSSEditingLevel())
        {

            // Check if style is present. It is always present in IE4 and IE5, but can be empty
            IFC(pIElement->get_style(&spStyle));
            IFC (spStyle->put_height(vtHeight));
        } 

        // Not in a style - apply value depending on the element type
        if (_fChangeHTMLAttribute || GetCSSEditingLevel() == 0)
        {
            if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
            {
                hr = spTable->put_height(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
            {
                hr = spTableCell->put_height(vtHeight);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
            {
                hr = spHRElement->put_size(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
            {
                hr = spEmbedElement->put_height(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
            {
                hr = spMarqueeElement->put_height(vtHeight);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
            {
                hr = spObjectElement->put_height(vtHeight);
            }

    // IE #13629 - No reason why we should be blindly adding an expando here
#if 0
            else
            {
                pIElement->setAttribute(_T("HEIGHT"), vtHeight, 0);
            }
#endif 
        }
    }

 Cleanup :
    VariantClear (&vtHeight);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::ExtractCurrentWidth(IHTMLElement* pIElement)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtOldWidth ;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    LONG                    lDimension = 0 ;
  
    VariantInit( &vtOldWidth );
    
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLInputElement, (void**)&spInputElement)))
    {
        if (SUCCEEDED(spInputElement->get_size(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension ;   // for size of input element
            }
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
    {
        if (SUCCEEDED(spTextAreaElement->get_cols(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension ;   // for cols of textarea
            }
        }
    }

    //
    // IE #13629 : If the CSS Editing Level is 0 then we shouldn't care about
    // either the style or the currentStyle, so if the CSS level is 0, we
    // skip these.
    //

    if ( GetCSSEditingLevel() )
    {
        // First try to extract value from element's style first. 
        // This method will NOT set default (pixel) units, if the style is not present
        hr = ExtractWidthFromElementStyle(pIElement);
        if (S_FALSE == hr) // the inline style is not present
        {
            // get the width from CSS style value if any.
            hr = GetCurrentStyleWidth(pIElement);
        }
    }
        
    // Try to get width or height from the element tag. This valid only for certain elements:
    // table, table cell, control (<OBJECT>)

    _fChangeHTMLAttribute = FALSE;
   
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
    {
        if (SUCCEEDED(spTable->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetWidth(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }
        }                           
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
    {
        if (SUCCEEDED(spTableCell->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetWidth(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        if (SUCCEEDED(spImageElement->get_width(&_lPixValue)))
        {
            _fChangeHTMLAttribute = TRUE;
        }
    }   
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
    {
        if (SUCCEEDED(spHRElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
    {
        if (SUCCEEDED(spEmbedElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
    {
        if (SUCCEEDED(spMarqueeElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
    {
        if (SUCCEEDED(spObjectElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }

    //
	// If we have no indication so var as to whether we will be changing the 
	// style or the attribute, we would apply this value to the the style
	// *if and only if* the CSS editing level is not 0
	//
		
    if (!_fChangeHTMLAttribute && !_fChangeStyle && GetCSSEditingLevel())
    {
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
        _fChangeStyle    = TRUE ;
        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;    // don't care, if you come here, means you will live long 
    }

Cleanup :
    VariantClear(&vtOldWidth);
    RRETURN (hr); 
}

HRESULT
CEdUnits::SetWidthValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtWidth ; 
    VARIANT                 vtNull;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    LONG                    lDimension = 0; 

    VariantInit(&vtWidth);

    // IE# 18704 If CSSEditingLevel is Zero, then we need to make sure that there are no in-line 
    // styles that will mess us up
    if ( !GetCSSEditingLevel() )
    {

        VariantInit(&vtNull);
        V_VT(&vtNull) = VT_BSTR;
        V_BSTR(&vtNull) = NULL;
        IFC (pIElement->get_style(&spStyle) );
        IFC (spStyle->put_width(vtNull) );

    }
    if (!_fChangeStyle && SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        hr = spImageElement->put_width(lNewValue);
        goto Cleanup;
    }
    
    if (_lCharDimension > 0 )
    {
        if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLInputElement, (void**)&spInputElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension ;   // for size of input element
            hr = spInputElement->put_size(lDimension);
        }
        else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;   // for cols of textarea
            hr = spTextAreaElement->put_cols(lDimension);
        }
    } // fall through to set the default width
    
    // Create a VARIANT (BSTR with value in units) out of the value in pixels

    //
    // Because of the change in the default case in ExtractCurrentXXXX for 
    // CSS Editing Level 0, there is the possibility that this MakeVariant is not
    // necessary
    //

    if(_fChangeStyle || _fChangeHTMLAttribute)
    {
        IFC (MakeVariant(lNewValue, &vtWidth));

        // If the original value was in a style, apply new to the style
        if (_fChangeStyle && GetCSSEditingLevel())
        {

            // Check if style is present. It is always present in IE4 and IE5, but can be empty
            IFC(pIElement->get_style(&spStyle));
            IFC (spStyle->put_width(vtWidth));

        } 


        if (_fChangeHTMLAttribute )
        {
            // Not in a style - apply value depending on the element type
            if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
            {
                IFC (spTable->put_width(vtWidth));
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
            {
                IFC (spTableCell->put_width(vtWidth));
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
            {
                hr = spHRElement->put_width(vtWidth);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
            {
                hr = spEmbedElement->put_width(vtWidth);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
            {
                hr = spMarqueeElement->put_width(vtWidth);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
            {
                hr = spObjectElement->put_width(vtWidth);
            }   

            //
            // IE #13629 - No reason why we should be blindly adding an expando here
            // 
#if 0
            else
            {
                pIElement->setAttribute(_T("WIDTH"), vtWidth, 0);
            }
#endif 
       }
    }

 Cleanup :
    VariantClear (&vtWidth);
    RRETURN (hr) ;
}

HRESULT CEdUnits::GetPixelLeft(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetLeft(&_lPixValue));
}

HRESULT CEdUnits::GetPixelTop(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetTop(&_lPixValue));
}

HRESULT CEdUnits::GetPixelWidth(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetWidth(&_lPixValue));
}

HRESULT CEdUnits::GetPixelHeight(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetHeight(&_lPixValue));
}

VOID
CEdUnits::AdjustLeftDimensions(IHTMLElement* pIElement, LONG* lNewValue)
{
    POINT ptOldPosition ;
    
    if (SUCCEEDED(EdUtil::GetOffsetTopLeft(pIElement, &ptOldPosition)))
    {
        // apply only the change : chandras : 02/15/2000
        *lNewValue = _lPixValue + (*lNewValue - ptOldPosition.x) ;
    }    
}

VOID
CEdUnits::AdjustTopDimensions(IHTMLElement* pIElement, LONG* lNewValue)
{
    POINT ptOldPosition;
    
    if (SUCCEEDED(EdUtil::GetOffsetTopLeft(pIElement, &ptOldPosition)))
    {
        // apply only the change : chandras : 02/15/2000
        *lNewValue = _lPixValue + (*lNewValue - ptOldPosition.y) ;
    }    
}

VOID
CEdUnits::AdjustHeightDimensions(IHTMLElement* pIElement, LONG* lNewHeight,ELEMENT_TAG_ID eTag)
{
    // table caption handling after resizing 
    // Caption gets adjusted(wrap, if any) after width setting, so calculate the height now
    switch (eTag)
    {
        case TAGID_TABLE :
        {
            *lNewHeight -= EdUtil::GetCaptionHeight(pIElement) ;
        }
        break;

        case TAGID_IMG:
        {    
            // calculating the width and height without borders to set on style
            LONG cyOldHeight=0 , cyHeight=0 ;

            if (SUCCEEDED(pIElement->get_offsetHeight(&cyOldHeight)))
            {
                SP_IHTMLElement2 spElement2;
                if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2 , (void **)& spElement2 )))
                {
                    if (SUCCEEDED(spElement2->get_clientHeight(&cyHeight)))
                    {
                        *lNewHeight = cyHeight + (*lNewHeight - cyOldHeight) ;
                    }
                }
            }
         }
         break;
    }
}

VOID
CEdUnits::AdjustWidthDimensions(IHTMLElement* pIElement, LONG* lNewWidth,ELEMENT_TAG_ID eTag)
{
    if (eTag == TAGID_IMG)
    {   // calculating the width and height without borders to set on style
        LONG cxOldWidth=0, cxWidth=0;

        if (SUCCEEDED(pIElement->get_offsetWidth(&cxOldWidth)))
        {
           SP_IHTMLElement2 spElement2;

           if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2 , (void **)& spElement2 )))
           {
                if (SUCCEEDED(spElement2->get_clientWidth(&cxWidth)))
                {
                    *lNewWidth  = cxWidth  + (*lNewWidth  - cxOldWidth) ;
                }
           }
        }
    }
}

HRESULT
CEdUnits::GetCurrentStyleHeight(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleHeight;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;

    VariantInit(&vtCurStyleHeight);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_height(&vtCurStyleHeight);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleHeight) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleHeight) && ::wcslen(V_BSTR(&vtCurStyleHeight)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleHeight)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleHeight)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleHeight);
    return _fChangeStyle ? S_OK : S_FALSE ;
}

HRESULT
CEdUnits::GetCurrentStyleWidth(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleWidth;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleWidth);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_width(&vtCurStyleWidth);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleWidth) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleWidth) && ::wcslen(V_BSTR(&vtCurStyleWidth)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleWidth)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleWidth)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleWidth);
    return _fChangeStyle ? S_OK : S_FALSE ;
}

HRESULT
CEdUnits::GetCurrentStyleTop(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleTop;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleTop);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_top(&vtCurStyleTop);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleTop) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleTop) && ::wcslen(V_BSTR(&vtCurStyleTop)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleTop)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleTop)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleTop);
    return _fChangeStyle ? S_OK : S_FALSE ;
}


HRESULT
CEdUnits::GetCurrentStyleLeft(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleLeft;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleLeft);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_left(&vtCurStyleLeft);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleLeft) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleLeft) && ::wcslen(V_BSTR(&vtCurStyleLeft)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleLeft)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleLeft)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleLeft);
    return _fChangeStyle ? S_OK : S_FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\edptr.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDPTR.CXX
//
//  Contents:   CEditPointer implementation
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif 

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif 

#ifndef X_EDPTR_HXX_
#define X_EDPTR_HXX_
#include "edptr.hxx"
#endif 

#ifndef X_FLATPTR_HXX_
#define X_FLATPTR_HXX_
#include "flatptr.hxx"
#endif 

using namespace EdUtil;

extern HRESULT OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi );

//////////////////////////////////////////////////////////////////////////
//
//  CEditPointer's Constructor/Destructor Implementation
//
//////////////////////////////////////////////////////////////////////////

CEditPointer::CEditPointer(
    CEditorDoc *        pEd,
    IMarkupPointer *    pPointer /* = NULL */
#if DBG == 1 
    , LPCTSTR strDebugName /*=NULL*/
#endif 
)
{
    _pEd = pEd;
    _pPointer = NULL;
    _pLeftBoundary = NULL;
    _pRightBoundary = NULL;
    _fBound = FALSE;
    

    if( pPointer != NULL )
    {
        _pPointer = pPointer;
        _pPointer->AddRef();
    }
    else
    {
        IGNORE_HR( CreateMarkupPointer2( _pEd, & _pPointer ));
    }


#if DBG ==1 
    if ( strDebugName != NULL )
    {
        IEditDebugServices *pEditDebugServices = NULL;
        
        if (SUCCEEDED( _pEd->GetDoc()->QueryInterface( IID_IEditDebugServices, (LPVOID *) &pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(_pPointer, strDebugName) );
            
            pEditDebugServices->Release();            
        }
    }
#endif    
}
    

CEditPointer::CEditPointer(
    const CEditPointer& lp )
{
    _pEd = lp._pEd;
    
    if ((_pPointer = lp._pPointer) != NULL)
        _pPointer->AddRef();

    if ((_pLeftBoundary = lp._pLeftBoundary) != NULL)
        _pLeftBoundary->AddRef();

    if ((_pRightBoundary = lp._pRightBoundary) != NULL)
        _pRightBoundary->AddRef();

    _fBound = lp._fBound;
}


CEditPointer::~CEditPointer()
{
    ReleaseInterface( _pPointer );
    ReleaseInterface( _pLeftBoundary );
    ReleaseInterface( _pRightBoundary );
}



//////////////////////////////////////////////////////////////////////////
//
//  CEditPointer's Method Implementations
//
//////////////////////////////////////////////////////////////////////////



HRESULT
CEditPointer::SetBoundary(
    IMarkupPointer *    pLeftBoundary,
    IMarkupPointer *    pRightBoundary )
{
    HRESULT hr = S_OK;
#if DBG == 1
    BOOL fPositioned = FALSE;

    if( pLeftBoundary )
    {
        IGNORE_HR( pLeftBoundary->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer::SetBoundary passed unpositioned left boundary" );
    }

    if( pRightBoundary )
    {
        IGNORE_HR( pRightBoundary->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer::SetBoundary passed unpositioned right boundary" );
    }
#endif

    ReplaceInterface( & _pLeftBoundary , pLeftBoundary );
    ReplaceInterface( & _pRightBoundary , pRightBoundary );
    _fBound = TRUE;
    
    RRETURN( hr );
}

HRESULT
CEditPointer::SetBoundaryForDirection(
    Direction       eDir,
    IMarkupPointer* pBoundary )
{
    HRESULT hr = S_OK;

    if( eDir == LEFT )
        hr = THR( SetBoundary( pBoundary, NULL ));
    else
        hr = THR( SetBoundary( NULL, pBoundary ));

    RRETURN( hr );
}


HRESULT
CEditPointer::ClearBoundary()
{
    HRESULT hr = S_OK;
    ClearInterface( & _pRightBoundary );
    ClearInterface( & _pLeftBoundary );
    _fBound = FALSE;
    RRETURN( hr );
}


BOOL
CEditPointer::IsPointerInLeftBoundary()
{
    BOOL fWithin = TRUE;

    if( _fBound && _pLeftBoundary )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif
        IGNORE_HR( IsRightOfOrEqualTo( _pLeftBoundary, & fWithin )); // we are within if we are to the right or equal to the left boundary
    }
    
    return fWithin;
}


BOOL
CEditPointer::IsPointerInRightBoundary()
{
    BOOL fWithin = TRUE;

    if( _fBound && _pRightBoundary )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif
        IGNORE_HR( IsLeftOfOrEqualTo( _pRightBoundary, & fWithin )); // we are within if we are to the left or equal to the left boundary
    }
    
    return fWithin;
}


BOOL 
CEditPointer::IsWithinBoundary()
{  
    BOOL fWithin = TRUE;

    if( _fBound )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif

        if( _pLeftBoundary )    
        {
            IGNORE_HR( IsRightOfOrEqualTo( _pLeftBoundary, & fWithin ));
        }

        if( fWithin && _pRightBoundary )
        {
            IGNORE_HR( IsLeftOfOrEqualTo( _pRightBoundary, & fWithin ));
        }
    }
    
    return fWithin;
}


BOOL
CEditPointer::IsWithinBoundary( 
    Direction               inDir )
{
    if( ! _fBound )
        return TRUE;
        
    if( inDir == LEFT )
    {
        return( IsPointerInRightBoundary() );       
    }
    else
    {
        return( IsPointerInLeftBoundary() );
    }
}


HRESULT
CEditPointer::Constrain()
{
    HRESULT hr = S_OK;

    if( _fBound )
    {
        if( ! IsPointerInLeftBoundary() )
        {
            Assert( _pLeftBoundary );
            IFC( _pPointer->MoveToPointer( _pLeftBoundary ));
        }

        if( ! IsPointerInRightBoundary() )
        {
            Assert( _pRightBoundary );
            IFC( _pPointer->MoveToPointer( _pRightBoundary ));
        }
    }
    
Cleanup:
    RRETURN( hr );
}



HRESULT
CEditPointer::Scan(
    Direction               eDir,
    DWORD                   eBreakCondition,
    DWORD *                 peBreakConditionFound,
    IHTMLElement **         ppElement,
    ELEMENT_TAG_ID *        peTagId,
    TCHAR *                 pChar,
    DWORD                   eScanOptions)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    BOOL fBlock = FALSE, fLayout = FALSE, fLayoutCalled;
    LONG lChars;
    TCHAR tChar = 0;
    DWORD dwContextAdjustment;
    MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;
    DWORD eBreakFound = BREAK_CONDITION_None;
    DWORD dwTest = BREAK_CONDITION_None;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID eTagId = TAGID_NULL;
    BOOL fIgnoreGlyphs = FALSE;
        
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
    AssertSz( fPositioned , "CEditPointer has unpositioned pointer in Scan" );
    AssertSz( eDir == LEFT || eDir == RIGHT , "CEditPointer is confused. The developer told it to scan in no particular direction." );
#endif


    // NOTE: (krisma) Despite how backwards this seems, 
    // we want to ignore glyphs if BREAK_CONDITION_Glyph is set,
    // otherwise we get the glyph's "text" instead of its
    // element
    if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph))
    {
        fIgnoreGlyphs = _pEd->IgnoreGlyphs(TRUE);
    }

    IFC( Constrain() );
    
    while( ! fDone )
    {
        lChars = 1;
        tChar = 0;
        dwContextAdjustment = 1;
        fLayoutCalled = FALSE;

        if(    ( eBreakCondition & BREAK_CONDITION_Text && ( ! CheckFlag( eScanOptions , SCAN_OPTION_ChunkifyText )))
            || ( eBreakCondition & BREAK_CONDITION_NoScopeBlock ))
        {
            hr = Move( eDir, TRUE, & eCtxt, & spElement, & lChars, &tChar );
        }
        else
        {
            hr = Move( eDir, TRUE, & eCtxt, & spElement, NULL, NULL) ;
        }
        
        if( hr == E_HITBOUNDARY )
        {
            fDone = TRUE;
            eBreakFound = BREAK_CONDITION_Boundary;
            hr = S_OK;
            break;
        }
        
        switch( eCtxt )
        {
            case CONTEXT_TYPE_ExitScope:
                dwContextAdjustment = 2;
                // FALL THROUGH
            case CONTEXT_TYPE_EnterScope:
            {
                IFC( _pEd->GetMarkupServices()->GetElementTagId( spElement, &eTagId ));
            
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Site ))
                {
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                    fLayoutCalled = TRUE;
                    if( fLayout )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterSite;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_TextSite ))
                {
                    BOOL fText = FALSE;
                    
                    if (!fLayoutCalled)
                    {
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                        fLayoutCalled = TRUE;
                    }

                    IFC(_pEd->GetDisplayServices()->HasFlowLayout(spElement, &fText));
                    
                    if( fLayout && fText )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterTextSite;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Block ))
                {
                    if (!fLayoutCalled)
                    {
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock));
                        fLayoutCalled = TRUE;
                    }

                    if ( fBlock && CheckFlag( eScanOptions, SCAN_OPTION_TablesNotBlocks ))
                    {
                        ELEMENT_TAG_ID eTag = TAGID_NULL; 
                        IFC( _pEd->GetMarkupServices()->GetElementTagId(spElement, & eTag));
                        if ( eTag == TAGID_TD || eTag == TAGID_TR || eTag == TAGID_TABLE )
                        {
                            fBlock = FALSE;
                        }
                    }
                    
                    if( fBlock )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterBlock;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_BlockPhrase ))
                {
                    if( eTagId == TAGID_RT || eTagId == TAGID_RP )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterBlockPhrase;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Control ) )
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ))
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterControl;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                else if (eScanOptions & SCAN_OPTION_SkipControls)
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ) )
                    {
                        IFC( _pPointer->MoveAdjacentToElement(spElement, (eDir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                        continue;
                    }                    
                }
                
                            
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Anchor ))
                {
                    if( eBreakFound == BREAK_CONDITION_None && eTagId == TAGID_A ) // we didn't hit layout, block, intrinsic or no-scope
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterAnchor;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Phrase ))
                {
                    if( eBreakFound == BREAK_CONDITION_None ) // we didn't hit layout, block, intrinsic, no-scope or anchor
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterPhrase;

                        //
                        // AppHack:IE6 31832 (mharper) VS does drag-drop for Element Behaviors for which there is no IMPORT in the 
                        // Source document, nor a peerfactory in the target.  This causes us to treat them as phrase
                        // elements in FixupPhraseElements.  So we will break anyway if this is the case.
                        //
                        if( CheckFlag( eBreakCondition, dwTest ) || 
                            (eTagId == TAGID_GENERIC && eScanOptions & SCAN_OPTION_BreakOnGenericPhrase) ) 
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph) )
                {
                    SP_IHTMLElement3    spElement3;
                    LONG                lGlyphMode;

                    IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                    IFC( spElement3->get_glyphMode(&lGlyphMode) );

                    if (lGlyphMode)
                    {
                        BOOL fHasGlyph = FALSE;
                        
                        switch (eCtxt)
                        {
                            case CONTEXT_TYPE_EnterScope:
                                fHasGlyph = (lGlyphMode & ((eDir == RIGHT) ? htmlGlyphModeBegin : htmlGlyphModeEnd));
                                break;
                                
                            case CONTEXT_TYPE_ExitScope:
                                fHasGlyph = (lGlyphMode & ((eDir == RIGHT) ? htmlGlyphModeEnd : htmlGlyphModeBegin));
                                break;
                        }
                        
                        if (fHasGlyph)
                        {
                            eBreakFound |= BREAK_CONDITION_Glyph;
                            fDone = TRUE;
                        }
                    }
                    
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoLayoutSpan ))
                {
                    if( eBreakFound == BREAK_CONDITION_None ) // we didn't hit layout, block, intrinsic, no-scope or anchor
                    {
                        if ( eTagId == TAGID_SPAN )
                        {
                            dwTest = dwContextAdjustment * BREAK_CONDITION_EnterNoLayoutSpan;
                            if( CheckFlag( eBreakCondition, dwTest ))
                            {
                                eBreakFound |= dwTest;
                                fDone = TRUE;
                            }
                        }
                    }
                }
                
                break;
            }

            case CONTEXT_TYPE_NoScope:
            {
                IFC( _pEd->GetMarkupServices()->GetElementTagId( spElement, &eTagId ));
            
                
                // this only looks a bit strange because there is no begin/end NoScope
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScope ))
                {
                    if( eCtxt == CONTEXT_TYPE_NoScope )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScope;
                        fDone = TRUE;
                    }
                }

                // Could be a noscope with layout. For example, an image.
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScopeSite ))
                {
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                    fLayoutCalled = TRUE;

                    if( fLayout )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScopeSite;
                        fDone = TRUE;
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScopeBlock ))
                {
                    if (!fLayoutCalled)
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock));

                    if( fBlock || eTagId == TAGID_BR )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScopeBlock;
                        fDone = TRUE;
                    }
                }                

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Control ))
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ))
                    {
                        eBreakFound |= BREAK_CONDITION_Control;
                        fDone = TRUE;
                    }
                }

                if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph) )
                {
                    SP_IHTMLElement3    spElement3;
                    LONG                lGlyphMode;

                    IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                    IFC( spElement3->get_glyphMode(&lGlyphMode) );

                    if (lGlyphMode)
                    {
                        eBreakFound |= BREAK_CONDITION_Glyph;
                        fDone = TRUE;
                    }
                    
                }

                break;                            
            }
            
            case CONTEXT_TYPE_Text:
            {
                if (CheckFlag( eBreakCondition , BREAK_CONDITION_Text )
                    && (   (   (eScanOptions & SCAN_OPTION_SkipWhitespace) 
                            && IsWhiteSpace(tChar))
                        || (   (eScanOptions & SCAN_OPTION_SkipNBSP) 
                            && tChar == WCH_NBSP)))
                {
                    continue; 
                }
                else if( CheckFlag( eBreakCondition , BREAK_CONDITION_Text ) && tChar != _T('\r') )
                {
                    eBreakFound |= BREAK_CONDITION_Text;
                    fDone = TRUE;
                }
                else if( CheckFlag( eBreakCondition, BREAK_CONDITION_NoScopeBlock ) && tChar == _T('\r'))
                {
                    eBreakFound |= BREAK_CONDITION_NoScopeBlock;
                    fDone = TRUE;
                }

                break;
            }

            case CONTEXT_TYPE_None:
            {
                // An error has occured
                eBreakFound |= BREAK_CONDITION_Error;
                fDone = TRUE;
                break;
            }
        }
    }
    
Cleanup:

    if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph))
    {
        _pEd->IgnoreGlyphs(fIgnoreGlyphs);
    }
    
    if( peBreakConditionFound )
        *peBreakConditionFound = eBreakFound;
        
    if( ppElement )
    {
        ReplaceInterface( ppElement, spElement.p );
    }

    if( peTagId )
        *peTagId = eTagId;

    if( pChar )
        *pChar = tChar;
    
    RRETURN( hr );
}


HRESULT 
CEditPointer::Move(                                     // Directional Wrapper for Left or Right
    Direction               inDir,                      //      [in]     Direction of travel
    BOOL                    fMove,                      //      [in]     Should we actually move the pointer
    MARKUP_CONTEXT_TYPE*    pContext,                   //      [out]    Context change
    IHTMLElement**          ppElement,                  //      [out]    Element we pass over
    long*                   pcch,                       //      [in,out] number of characters to read back
    OLECHAR*                pchText )                   //      [out]    characters
{
    HRESULT hr = E_FAIL;
    
    Assert( _pPointer );
    
    if( inDir == LEFT )
    {
        IFC( _pPointer->Left( fMove, pContext, ppElement, pcch, pchText ));
    }
    else
    {
        IFC( _pPointer->Right( fMove, pContext, ppElement, pcch, pchText ));
    }

    if( ! IsWithinBoundary() )
    {
        Constrain();
        hr = E_HITBOUNDARY;
    }

Cleanup:
    RRETURN( hr );
}



//+====================================================================================
//
// Method: IsEqualTo
//
// Synopsis: Am I in the same place as the passed in pointer if I ignore dwIgnoreBreaks?
//
//------------------------------------------------------------------------------------

HRESULT 
CEditPointer::IsEqualTo( 
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    HRESULT hr = S_OK;
    BOOL fEqual = FALSE;
    Assert( pPointer );
    Assert( pfEqual );
    Direction dwWhichWayToPointer = SAME;

    IFC( OldCompare( this, pPointer, &dwWhichWayToPointer ));

    if( dwWhichWayToPointer == SAME )
    {
        // quick out - same exact place
        fEqual = TRUE;
    }
    else
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;
        dwSearch = ClearFlag( dwSearch , dwIgnore );

        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( dwWhichWayToPointer, pPointer ));
        IFC( ep.Scan( dwWhichWayToPointer, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;
        
    RRETURN( hr );
}


HRESULT
CEditPointer::IsLeftOfOrEqualTo(
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    BOOL fEqual;
    HRESULT hr = S_OK;

    IFC( this->IsLeftOfOrEqualTo( pPointer, &fEqual ));

    if( ! fEqual )
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;

        dwSearch = ClearFlag( dwSearch , dwIgnore );
        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( LEFT, pPointer ));
        IFC( ep.Scan( LEFT, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;

    RRETURN( hr );
}



HRESULT
CEditPointer::IsRightOfOrEqualTo(
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    BOOL fEqual;
    HRESULT hr = S_OK;

    IFC( this->IsRightOfOrEqualTo( pPointer, &fEqual ));

    if( ! fEqual )
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;
        
        dwSearch = ClearFlag( dwSearch , dwIgnore );
        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( RIGHT, pPointer ));
        IFC( ep.Scan( RIGHT, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;

    RRETURN( hr );
}



//+====================================================================================
//
// Method: Between
//
// Synopsis: Am I in - between the 2 given pointers ?
//
//------------------------------------------------------------------------------------

BOOL
CEditPointer::Between( 
    IMarkupPointer* pStart, 
    IMarkupPointer * pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( IsRightOfOrEqualTo( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( IsLeftOfOrEqualTo( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edutil\stdafx.h ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.H
//
//  Contents:   Include file for standard ATL include files
//
//-------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_)
#define AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_MIN_CRT
//#define _ATL_MIN_CRT
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

//
// NOTE: ATL depends on the *presence* of _DEBUG to switch into DEBUG mode.
// Trident *always* sets _DEBUG to some value. This causes a problem when
// building a retail build in the Trident tree. 
// undef'ing _DEBUG when _DEBUG is zero solves the problem.
//
#if _DEBUG == 0
# undef _DEBUG
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void  ATL_free(void *);
void *ATL_malloc(size_t);
void *ATL_realloc(void *, size_t);

#define lstrlenW _tcslen
#define lstrcmpiW StrCmpIW
#define lstrcpynW StrCpyNW
#define lstrcpyW StrCpyW
#define lstrcatW StrCatW

#undef HIMETRIC_PER_INCH

#undef SubclassWindow
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

typedef INT Direction;

#pragma warning( disable : 4510 4610 )  

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#undef malloc
#undef free
#undef realloc

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\dllreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllreg.cxx
//
//  Contents:   DllRegisterServer, DllUnRegisterServer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_IIMGCTX_H_
#define X_IIMGCTX_H_
#include "iimgctx.h"
#endif

#ifndef X_ADVPUB_H_
#define X_ADVPUB_H_
#include <advpub.h>     // for RegInstall
#endif

//+------------------------------------------------------------------------
//
//  Prototypes
//
//+------------------------------------------------------------------------

HRESULT UnregisterServer(TCHAR *);

#ifndef WIN16
static DYNLIB s_dynlibADVPACK = { 0, 0, "ADVPACK.DLL" };
static DYNPROC s_dynprocREGINSTALL = { 0, &s_dynlibADVPACK, achREGINSTALL };
char g_achIEPath[MAX_PATH];     // path to iexplore.exe
#endif // ndef WIN16


//+------------------------------------------------------------------------
//
//  Function:   RegisterTypeLibraries
//
//  Synopsis:   Register the forms type libraries.
//
//-------------------------------------------------------------------------

static HRESULT
RegisterTypeLibraries()
{
    HRESULT     hr = E_FAIL;
    ITypeLib *  pTL = NULL;
    TCHAR       ach[MAX_PATH];
    TCHAR *     pchName;

    // register the msdatsrc.tlb (databinding)
    int iLen = GetSystemDirectory(ach, MAX_PATH);
    if (iLen > 0 && 
    	iLen+ _tcslen(_T("\\msdatsrc.tlb")) < MAX_PATH-1) // make sure there will be enough space in ach to strcat
    {
        _tcscat(ach, _T("\\msdatsrc.tlb"));
        hr = THR(LoadTypeLib(ach, &pTL));
        if (!hr && pTL)
        {
            hr = THR(RegisterTypeLib(pTL, ach, 0));
            pTL->Release();
        }
    }

    GetFormsTypeLibPath(ach);
    pchName = _tcsrchr(ach, '.');
    Assert(pchName);

    if (pchName+1+_tcslen(_T("tlb")) < ach+MAX_PATH-1) // proceed only if there space left in ach for  _tcscpy 
    {
	_tcscpy(pchName + 1, _T("tlb"));

	hr = THR(LoadTypeLib(ach, &pTL));
	if (!hr && pTL)
	{
	    hr = THR(RegisterTypeLib(pTL, ach, 0));
	    pTL->Release();
	}
    }
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   UnregisterTypeLibraries
//
//  Synopsis:   Unregister the registered type libraries.
//
//-------------------------------------------------------------------------
static void
UnregisterTypeLibraries( )
{
    ITypeLib *  pTL;
    TLIBATTR *  ptla;

    if (!THR(GetFormsTypeLib(&pTL, TRUE)))
    {
        if (!THR(pTL->GetLibAttr(&ptla)))
        {
            UnRegisterTypeLib(ptla->guid,
                    ptla->wMajorVerNum,
                    ptla->wMinorVerNum,
                    ptla->lcid,
                    ptla->syskind);
            pTL->ReleaseTLibAttr(ptla);
        }
        pTL->Release();
    }
}

#ifndef WIN16
const CHAR  c_szIexploreKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

//+------------------------------------------------------------------------
//
// Function:    GetIEPath
//
// Synopsis:    Queries the registry for the location of the path
//              of Internet Explorer and returns it in pszBuf.
//
// Returns:     TRUE on success
//              FALSE if path cannot be determined
//-------------------------------------------------------------------------

void
GetIEPath()
{
    BOOL fSuccess = FALSE;
    HKEY hkey;

    if (lstrlenA(g_achIEPath))
        return;

    g_achIEPath[0] = '\0';

    // Get the path of Internet Explorer
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))
    {
        TraceTag((tagError, "InstallRegSet(): RegOpenKey( %s ) Failed", c_szIexploreKey)) ;
    }
    else
    {
        DWORD cbData = MAX_PATH-1;
        DWORD dwType;

        if (NO_ERROR !=RegQueryValueExA(
                hkey,
                "",
                NULL,
                &dwType,
                (LPBYTE)g_achIEPath,
                &cbData))
        {
            TraceTag((tagError, "InstallRegSet(): RegQueryValueEx() for Iexplore path failed"));
        }
        else
        {
            g_achIEPath[cbData] = '\0'; // ensure path is a null terminated string
            fSuccess = TRUE;
        }

        RegCloseKey(hkey);
    }

    if (!fSuccess)
    {
        // Failed, just say "iexplore"
       lstrcpyA(g_achIEPath, "iexplore.exe");
    }
}

//+------------------------------------------------------------------------
//
// Function:    CallRegInstall
//
// Synopsis:    Calls the ADVPACK entry-point which executes an inf
//              file section.
//
//-------------------------------------------------------------------------

HRESULT
CallRegInstall(LPSTR szSection)
{
    HRESULT     hr = S_OK;
    STRENTRY    seReg[] = {{ "IEXPLORE", g_achIEPath} };
    STRTABLE    stReg = { 1, seReg };

    hr = THR(LoadProcedure(&s_dynprocREGINSTALL));
    if (hr)
        goto Cleanup;

    // Get the location of iexplore from the registry
    GetIEPath();

    hr = THR( ((REGINSTALL)s_dynprocREGINSTALL.pfn)(g_hInstCore, szSection, &stReg));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    UnregisterServer
//
// Synopsis:    Delete everything from the registry that looks like ours.
//
//-------------------------------------------------------------------------

HRESULT
UnregisterServer(TCHAR *pstrDLL)
{
    RRETURN(CallRegInstall("Unreg"));
}
#endif // ndef WIN16


//+------------------------------------------------------------------------
//
// Function:    TestVersion
//
// Synopsis:    Check whether the  InprocServer32 points to a existing file
//              if not return true, otherwise check the version, if the
//              version is greater than current want to register , return
//              false, else return true
// Arguments:   [clsaaID] - specifies the class ID to register
//              [pstrExpectedVersion] - the expected version value.
//
//-------------------------------------------------------------------------
#if 0
BOOL
TestVersion(CLSID classID , TCHAR *pstrExpectedVersion)
{
    TCHAR strKey[128];
    TCHAR strValue[MAX_PATH];
    long cb;

    TCHAR *pstrFmtServer =
#ifndef _MAC
        TEXT("CLSID\\<0g>\\InprocServer32");
#else
        TEXT("CLSID\\<0g>\\InprocServer");
#endif

    TCHAR *pstrFmtVersion = TEXT("CLSID\\<0g>\\Version");

    Verify(Format(0, strKey, ARRAY_SIZE(strKey),
            pstrFmtServer, &classID) == S_OK);

    cb = sizeof(strValue);

    // If Can not Find InprocServer32 We should do register so return true
    if (#_#_RegQueryValue(HKEY_CLASSES_ROOT, strKey, strValue, &cb)
            != ERROR_SUCCESS)
        return TRUE;

    // Otherwise the server exists, Check whether it really exists

    TCHAR achPath[MAX_PATH];
    LPTSTR  lpszFilename;

    //Since the strValue includes full path, it ok to use searchpath here
    if (!#_#_SearchPath(NULL, strValue, NULL, MAX_PATH, achPath, &lpszFilename ))
        return TRUE;

    //otherwise check version
    Verify(Format(0, strKey, ARRAY_SIZE(strKey),
            pstrFmtVersion, &classID) == S_OK);

    cb = sizeof(strValue);

    // No Version Stamp also Return Success
    if (#_#_RegQueryValue(HKEY_CLASSES_ROOT, strKey, strValue, &cb)
        != ERROR_SUCCESS)
        return TRUE;

    //Otherwise compare the version
    if ( _tcsicmp(strValue, pstrExpectedVersion) <= 0)
        return TRUE;
    else
        return FALSE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegister
//
//  Synopsis:   Determine whether would should register a particular pic format
//
//  Returns:    TRUE - yes
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegister(TCHAR *szFormat, TCHAR *szFileExt)
{
    TCHAR   aBuffer[MAX_PATH];
    LONG    lRet;
    HKEY    hkey = NULL;
    DWORD   cb=MAX_PATH -sizeof(TCHAR);
    TCHAR   *lptszCmdName;

    lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                        szFileExt,
                        0,
                        KEY_READ,
                        &hkey);
    if( lRet == ERROR_SUCCESS )
    {
	memset(aBuffer,0,MAX_PATH);
        lRet = RegQueryValueEx(hkey, NULL, 0, NULL, (LPBYTE)aBuffer, &cb);
        RegCloseKey(hkey);
        if (    lRet == ERROR_SUCCESS
            &&  cb != 0
            &&  lstrlen(aBuffer) != 0
            &&  _tcsicmp(aBuffer, szFormat) != 0)
        {
            return(FALSE);
        }
    }

    // note: by desing aBuffer will have enough space to accomodate szFormat and \\shell\\open... added bellow
    Assert ( _tcslen(szFormat)+_tcslen(_T("\\shell\\open\\command")) < MAX_PATH);
    _tcscpy(aBuffer, szFormat); 
    _tcscat(aBuffer, _T("\\shell\\open\\command"));
    lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                        aBuffer,
                        0,
                        KEY_READ,
                        &hkey);
    if( lRet != ERROR_SUCCESS )
        return(TRUE);

    // check if the key value is empty or has IEXplore already
    cb = MAX_PATH;
    lRet = RegQueryValueEx(hkey, NULL, 0, NULL, (LPBYTE)aBuffer, &cb);

    RegCloseKey(hkey);
    if (cb == 0 || lstrlen(aBuffer) == 0 || lRet != ERROR_SUCCESS)
        return(TRUE);

    PathRemoveArgs(aBuffer);
    lptszCmdName = PathFindFileName(aBuffer);
    if ( _tcsnicmp(lptszCmdName, 12, _T("iexplore.exe"), 12) == 0)
        return(TRUE);
    return( FALSE );
}


//+------------------------------------------------------------------------
//
// Function:    DllRegisterServer
//
// Synopsis:    Register objects and type libraries for this server
//              as described in the OLE Controls specification.
//
//-------------------------------------------------------------------------

extern BOOL ShouldWeRegisterCompatibilityTable();
extern BOOL ShouldWeRegisterUrlCompatibilityTable();

typedef struct
{
    TCHAR *tszName;
    LPSTR szSection;
    TCHAR *tszExt;
} PICFORMATREG;

static const PICFORMATREG aImgReg[] =
            {
                {_T("jpegfile"), "RegJPEG"  ,_T(".jpeg")},
                {_T("jpegfile"), "RegJPE"   ,_T(".jpe")},
                {_T("jpegfile"), "RegJPG"   ,_T(".jpg")},
                {_T("pngfile"),  "RegPNG"   ,_T(".png")},
                {_T("pjpegfile"),"RegPJPG"  ,_T(".jfif")},
                {_T("xbmfile"),  "RegXBM"   ,_T(".xbm")},
                {_T("giffile"),  "RegGIF"   ,_T(".gif")}
            };

STDAPI
DllRegisterServer()
{
    HRESULT hr;

    Assert(0 != _tcslen(g_achDLLCore));

    CEnsureThreadState ets;
    hr = ets._hr;
#ifndef UNIX  // CallRegInstall("Reg") has to be excuted
    if (FAILED(hr))
        return hr;
#endif

    hr = RegisterTypeLibraries();
#ifndef UNIX  // CallRegInstall("Reg") has to be excuted
    if (hr)
        goto Cleanup;
#endif

#ifndef WIN16
    hr = THR(CallRegInstall("Reg"));
    if (FAILED(hr))
        goto Cleanup;

    // The test to determine if we should register our compatibility table
    // is non trivial, so we allow clstab.cxx to implement the test since it
    // is the expert on the issue.
    if( ShouldWeRegisterCompatibilityTable() )
    {
        hr = THR(CallRegInstall("RegCompatTable"));
    }

    if (ShouldWeRegisterUrlCompatibilityTable())
    {
        hr = THR(CallRegInstall("RegUrlCompatTable"));
    }
#endif // ndef WIN16

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    DllUnregisterServer
//
// Synopsis:    Undo the actions of DllRegisterServer.
//
//-------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    HRESULT hr;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        return hr;

    UnregisterTypeLibraries();

#ifdef WIN16
    return hr;
#else
    Assert(_tcslen(g_achDLLCore));
    return UnregisterServer(g_achDLLCore);
#endif
}


#ifndef WIN16
//+------------------------------------------------------------------------
//
// Function:    DllInstall
//
// Synopsis:    Install/uninstall user settings
//
//-------------------------------------------------------------------------

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT     hr = S_OK;
    BOOL        fPerUser = (pszCmdLine &&
                            (*pszCmdLine == L'u' || *pszCmdLine == L'U'));
    int     i;
    int     l = ARRAY_SIZE(aImgReg);

    if (fPerUser)
    {
        return S_FALSE;
    }

    if (bInstall)
    {
        hr = THR(CallRegInstall("Install"));

        for (i = 0; i < l; i ++)
        {
            if (ShouldWeRegister(aImgReg[i].tszName, aImgReg[i].tszExt))
            {
                HRESULT hr2;

                hr2 = THR(CallRegInstall(aImgReg[i].szSection));
                if (FAILED(hr2))
                {
                    hr = hr2;
                }
            }
        }
    }
    else
    {
        hr = THR(CallRegInstall("Uninstall"));
    }

    RRETURN(hr);
}
#endif // ndef WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed

#ifndef DLOAD1
#error dllmap.c should not be used when DLOAD1 is not defined
#endif

// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
DECLARE_ORDINAL_MAP(comctl32)
DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
DECLARE_ORDINAL_MAP(hlink)
DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
DECLARE_PROCNAME_MAP(msjava)
DECLARE_PROCNAME_MAP(msrating)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
DECLARE_PROCNAME_MAP(usp10)
// DECLARE_PROCNAME_MAP(utildll)
DECLARE_PROCNAME_MAP(uxtheme)
DECLARE_PROCNAME_MAP(version)
DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
    DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
    DLDENTRYO(hlink)
    DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
    DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
    DLDENTRYP(msjava)
    DLDENTRYP(msrating)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
    DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
    DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
    DLDENTRYP(usp10)
//     DLDENTRYP(utildll)
    DLDENTRYP(uxtheme)
    DLDENTRYP(version)
    DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#else
#pragma warning( disable : 4206 )
#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\makefile.inc ===
$(O)\forms3.def: forms3.def
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\forms3p.def: forms3.def
    $(C_PREPROCESSOR_NAME) -DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $*.dfp
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $*.dfp > $@

$(O)\mshtmlp.lib: $(O)\forms3p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\forms3p.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\factory.cxx ===
//+------------------------------------------------------------------------
//
//  File:       factory.cxx
//
//  Contents:   Class factories.
//
//  History:    20-Dec-94   GaryBu Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include <ocmm.h>
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifdef WIN16
#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h>
#endif

#define NO_DEBUG_HOOK
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_IIMGCTX_H_
#define X_IIMGCTX_H_
#include "iimgctx.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include <htmldlg.hxx>
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include <htmlpop.hxx>
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_CLSFAC3_HXX_
#define X_CLSFAC3_HXX_
#include "clsfac3.hxx"
#endif

#ifndef X_OPTARY_H_
#define X_OPTARY_H_
#include <optary.h>
#endif

#ifndef X_SHLGUIDP_H_
#define X_SHLGUIDP_H_
#include <shlguidp.h>
#endif

#ifdef UNIX
EXTERN_C const CLSID CLSID_CRowPosition;
extern CBaseCF::FNCREATE CreateRowPosition;
#endif

#pragma warning(disable: 4041)

EXTERN_C const GUID CLSID_DataObject;
EXTERN_C const GUID CLSID_HTMLWindowProxy;
EXTERN_C const GUID CLSID_HTMLServerDoc;
EXTERN_C const GUID CLSID_Scriptlet;
EXTERN_C const GUID CLSID_MHTMLDocument;
EXTERN_C const GUID CLSID_HTMLPluginDocument;
EXTERN_C const GUID CLSID_HTADoc;
EXTERN_C const GUID CLSID_HTMLPopupDoc;

//+------------------------------------------------------------------------
//
//  Create instance functions
//
//-------------------------------------------------------------------------

extern CBaseCF::FNCREATE CreateDoc;
extern CBaseCF::FNCREATE CreateScriptlet;
extern CBaseCF::FNCREATE CreateMhtmlDoc;
extern CBaseCF::FNINITCLASS InitDocClass;
extern CBaseCF::FNCREATE CreateDocFullWindowEmbed;  // ref to plugin handle file mechanism.
extern CBaseCF::FNCREATE CreateHTADoc;
extern CBaseCF::FNCREATE CreatePopupDoc;
extern CBaseCF::FNCREATE CreatePropertyFrame;

#ifndef NO_PROPERTY_PAGE
extern CStaticCF::FNCREATE CreateGenericPropertyPage;
extern CStaticCF::FNCREATE CreateInlineStylePropertyPage;
#endif // NO_PROPERTY_PAGE
extern CStaticCF::FNCREATE CreateDwnBindInfo;
extern CStaticCF::FNCREATE CreateIImgCtx;
extern CStaticCF::FNCREATE CreateIImageDecodeFilter;
extern CStaticCF::FNCREATE CreateIIntDitherer;
extern CStaticCF::FNCREATE CreateSecurityProxy;
extern CStaticCF::FNCREATE CreateHtmlLoadOptions;
extern CStaticCF::FNCREATE CreateRecalcEngine;
extern CStaticCF::FNCREATE CreateTridentAPI;
extern CStaticCF::FNCREATE CreateExternalFrameworkSite;

#ifndef NO_DEBUG_HOOK
class CHook;

extern CHook * CreateHook();
#endif

//+------------------------------------------------------------------------
//
//  Class factories
//
//-------------------------------------------------------------------------

// Use CBaseLockCF for documents so that clients can addref thread state
// without holding on to an instance of the document.
CBaseLockCF g_cfDoc                     (CreateDoc, InitDocClass);
CBaseLockCF g_cfHTADoc                  (CreateHTADoc, InitDocClass);
CBaseLockCF g_cfHTMLPopupDoc            (CreatePopupDoc, InitDocClass);
CBaseLockCF g_cfScriptlet               (CreateScriptlet, InitDocClass);

CBaseCF     g_cfMhtmlDoc                (CreateMhtmlDoc, InitDocClass);
CBaseCF     g_cfDocFullWindowEmbed      (CreateDocFullWindowEmbed, InitDocClass);

#if !defined(NO_PROPERTY_PAGE) && (DBG==1)
CStaticCF   g_cfGenericPropertyPage     (CreateGenericPropertyPage);
CStaticCF   g_cfInlineStylePropertyPage (CreateInlineStylePropertyPage);
#endif // NO_PROPERTY_PAGE

CStaticCF   g_cfCDwnBindInfo            (CreateDwnBindInfo);
CStaticCF   g_cfIImgCtx                 (CreateIImgCtx);
CStaticCF   g_cfIImageDecodeFilter      (CreateIImageDecodeFilter);
CStaticCF   g_cfIIntDitherer            (CreateIIntDitherer);
CStaticCF   g_cfSecurityProxy           (CreateSecurityProxy);
CStaticCF   g_cfHtmlLoadOptions         (CreateHtmlLoadOptions);
CStaticCF   g_cfRecalcEngine            (CreateRecalcEngine);
CStaticCF   g_cfTridentAPI              (CreateTridentAPI);

  
  


#ifdef UNIX
CBaseCF     g_cfRowPosition             (CreateRowPosition);
#endif

extern class CResProtocolCF g_cfResProtocol;
extern class CJSProtocolCF  g_cfJSProtocol;
extern class CSysimageProtocolCF  g_cfSysimageProtocol;
extern class CHTMLPopupFactory g_cfHTMLPopup;
#ifndef WIN16
extern class CMailtoFactory g_cfMailtoProtocol;
#endif

// HTC Constructor Constructor - see comments in peerfact.cxx
extern const CLSID CLSID_CHtmlComponentConstructorFactory;

class CHtmlComponentConstructorFactory;
extern CHtmlComponentConstructorFactory g_cfHtmlComponentConstructorFactory;

extern class CAboutProtocolCF g_cfAboutProtocol;
//+------------------------------------------------------------------------
//
//  Class factory cache
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};

const CLSCACHE g_aclscache[] =
{
    &CLSID_HTMLDocument,                        &g_cfDoc,
    &CLSID_Scriptlet,                           &g_cfScriptlet,
    &CLSID_MHTMLDocument,                       &g_cfMhtmlDoc,
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,              &g_cfGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,            &g_cfInlineStylePropertyPage,
#endif //  DBG==1
    &CLSID_CDwnBindInfo,                        &g_cfCDwnBindInfo,
    &CLSID_IImgCtx,                             &g_cfIImgCtx,
    &CLSID_IImageDecodeFilter,                  &g_cfIImageDecodeFilter,
    &CLSID_IntDitherer,                         &g_cfIIntDitherer,
    &CLSID_JSProtocol,                          (IClassFactory *)(void *)&g_cfJSProtocol,
    &CLSID_ResProtocol,                         (IClassFactory *)(void *)&g_cfResProtocol,
    &CLSID_SysimageProtocol,                    (IClassFactory *)(void *)&g_cfSysimageProtocol,
    &CLSID_HTMLPopup,                          (IClassFactory *)(void *)&g_cfHTMLPopup,
#ifndef WIN16
    &CLSID_MailtoProtocol,                      (IClassFactory *)(void *)&g_cfMailtoProtocol,
#endif // ndef WIN16
    &CLSID_AboutProtocol,                       (IClassFactory *)(void *)&g_cfAboutProtocol,
    &CLSID_HTMLWindowProxy,                     &g_cfSecurityProxy,

    // Special way to create a CDoc based on this alternative magic clsid:
    &CLSID_HTMLPluginDocument,                  &g_cfDocFullWindowEmbed,
    &CLSID_HTMLLoadOptions,                     &g_cfHtmlLoadOptions,
    &CLSID_CRecalcEngine,                       &g_cfRecalcEngine,
    &CLSID_HTADoc,                              &g_cfHTADoc,
    &CLSID_HTMLPopupDoc,                        &g_cfHTMLPopupDoc,

    &CLSID_HostDialogHelper,                    &g_cfTridentAPI,
    &CLSID_CHtmlComponentConstructorFactory,    (CStaticCF*)&g_cfHtmlComponentConstructorFactory,

  

#ifdef UNIX
    &CLSID_CRowPosition,                        &g_cfRowPosition,
#endif
};

//+---------------------------------------------------------------
//
//  Function:   LocalGetClassObject
//
//  Synopsis:   Local function for locating class factories
//
//----------------------------------------------------------------

HRESULT
LocalGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    int             i;
    const CLSCACHE * pcc;    

    //
    // First try the class cache.
    //

    for (i = ARRAY_SIZE(g_aclscache) - 1, pcc = g_aclscache;
         i >= 0;
         i--, pcc++)
    {
        Assert(pcc->pclsid && pcc->pCF);
        if (IsEqualCLSID(clsid, *pcc->pclsid))
        {
            hr = pcc->pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    //
    // Second, check of it is a Property Page CLSID shdocvw understands, if so
    // we create a CPropPageCF specific to the resource moniker identified
    // by the CLSID
    //

#ifndef NO_HTML_DIALOG         
    IOleCommandTarget * pCommandTarget = NULL;
    IMoniker          * pmk = NULL;
    CHTMLPropPageCF   * pHTMLPropPageCF = NULL;
    VARIANT             varIn;
    VARIANT             varOut;
    BOOL                fIsPropPageClsid = FALSE;
    
    VariantInit(&varOut);

    // co-create shdocvw
    hr = THR(CoCreateInstance(
            CLSID_DocHostUIHandler,                              
            NULL,            
            CLSCTX_INPROC_SERVER,            
            IID_IOleCommandTarget,            
            (void**)&pCommandTarget));
    if (hr)
        goto PropPageCleanup;
    
    // check if the clsid is a property page supported by shdocvw

    V_VT(&varIn) = VT_UINT_PTR;
    V_BYREF(&varIn) = (void *)&clsid;
    hr = pCommandTarget->Exec(
            &CGID_DocHostCommandHandler, 
            SHDVID_CLSIDTOMONIKER, 
            0, 
            &varIn, 
            &varOut);       
    fIsPropPageClsid = !hr;
    if (hr)
        goto PropPageCleanup;   

    // extract the IMoniker *
    if (V_VT(&varOut) == VT_UNKNOWN)
        hr = V_UNKNOWN(&varOut)->QueryInterface(IID_IMoniker, (void**)&pmk);
    else
        hr = E_FAIL;
    if (hr)
        goto PropPageCleanup;

    // create a class factory specific to the moniker
    pHTMLPropPageCF = new CHTMLPropPageCF(pmk);
    hr = pHTMLPropPageCF->QueryInterface(iid, ppv);
    if (hr)
        goto PropPageCleanup;

PropPageCleanup:
    ReleaseInterface(pHTMLPropPageCF);
    ReleaseInterface(pmk);
    ReleaseInterface(pCommandTarget);
    VariantClear(&varOut);

    // stop if the clsid was a prop page's clsid
    if (fIsPropPageClsid)
        RRETURN(hr);

#endif // NO_HTML_DIALOG


#ifndef NO_DEBUG_HOOK
    //
    // Maybe its a debug hook request
    //
    if (IsEqualCLSID(clsid, CLSID_CHook))
    {
        *ppv = CreateHook();

        RRETURN(*ppv ? S_OK : E_OUTOFMEMORY);
    }
#endif // NO_DEBUG_HOOK

    *ppv = NULL;
    RRETURN(CLASS_E_CLASSNOTAVAILABLE);
}


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    RRETURN_NOTRACE(LocalGetClassObject(clsid, iid, ppv));
}


//+---------------------------------------------------------------
//
//  Function:   DllEnumClassObjects
//
//  Synopsis:   
//
//----------------------------------------------------------------

STDAPI
DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if ((UINT)i >= ARRAY_SIZE(g_aclscache))
        return S_FALSE;

    *pclsid = *g_aclscache[i].pclsid;
    *ppUnk = g_aclscache[i].pCF;
    (*ppUnk)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\comdlg32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <commdlg.h>

static
SHORT
APIENTRY
GetFileTitleW (
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL 
APIENTRY
ChooseColorA(
    LPCHOOSECOLORA lpcc
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
ChooseColorW(
    LPCHOOSECOLORW pccw
    )
{
    return FALSE;
}

static
BOOL APIENTRY
ChooseFontW(LPCHOOSEFONTW lpcf)
{
    return FALSE;
}

static
BOOL APIENTRY
ChooseFontA(LPCHOOSEFONTA lpcf)
{
    return FALSE;
}

static
DWORD APIENTRY
CommDlgExtendedError()
{
    return CDERR_INITIALIZATION;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comdlg32)
{
    DLPENTRY(ChooseColorA)
    DLPENTRY(ChooseColorW)
    DLPENTRY(ChooseFontA)
    DLPENTRY(ChooseFontW)
    DLPENTRY(CommDlgExtendedError)
    DLPENTRY(GetFileTitleW)
    DLPENTRY(GetOpenFileNameW)
    DLPENTRY(GetSaveFileNameW)
};

DEFINE_PROCNAME_MAP(comdlg32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\hook.cxx ===
//+------------------------------------------------------------------------
//
//  File:       hook.cxx
//
//  Contents:   Hook interfaces used for debugging
//
//  History:    09-Jul-97   JohnV Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HOOK_HXX_
#define X_HOOK_HXX_
#include "hook.hxx"
#endif

#ifndef NO_DEBUG_HOOK

MtDefine(CHook, Utilities, "CHook")

CHook *
CreateHook()
{
    return new CHook;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\hlink.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <hlink.h>

static 
STDMETHODIMP HlinkCreateFromMoniker(
             IMoniker * pimkTrgt,
             LPCWSTR pwzLocation,
             LPCWSTR pwzFriendlyName,
             IHlinkSite * pihlsite,
             DWORD dwSiteData,
             IUnknown * piunkOuter,
             REFIID riid,
             void ** ppvObj)
               
{
    *ppvObj = NULL;
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(hlink)
{
    DLOENTRY(3, HlinkCreateFromMoniker)
};

DEFINE_ORDINAL_MAP(hlink)


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\comctl32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _COMCTL32_
#include <commctrl.h>
#include <comctrlp.h>

static
WINCOMMCTRLAPI
HPROPSHEETPAGE
WINAPI
CreatePropertySheetPageW (
    LPCPROPSHEETPAGEW psp
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HWND
WINAPI
CreateUpDownControl (
    DWORD dwStyle, int x, int y, int cx, int cy,
    HWND hParent, int nID, HINSTANCE hInst,
    HWND hBuddy,
    int nUpper, int nLower, int nPos
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DestroyPropertySheetPage (
    HPROPSHEETPAGE hpage
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI DoReaderMode(PREADERMODEINFO prmi)
{
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_Add (
    HIMAGELIST himl,
    HBITMAP hbmImage,
    HBITMAP hbmMask
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Create (
    int cx, int cy, UINT flags, int cInitial, int cGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Destroy (
    HIMAGELIST himl
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Draw (
    HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Duplicate (
    HIMAGELIST himl
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HICON
WINAPI
ImageList_GetIcon (
    HIMAGELIST himl, int i, UINT flags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_GetIconSize (
    HIMAGELIST himl, int FAR *cx, int FAR *cy
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageW (
    HINSTANCE hi,
    LPCWSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_ReplaceIcon (
    HIMAGELIST himl, int i, HICON hicon
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
COLORREF
WINAPI
ImageList_SetBkColor (
    HIMAGELIST himl,
    COLORREF clrBk
    )
{
    return CLR_NONE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_SetOverlayImage (
    HIMAGELIST himl,
    int iImage,
    int iOverlay
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI InitCommonControls (
    void
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
InitCommonControlsEx (
    LPINITCOMMONCONTROLSEX icce
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetW (
    LPCPROPSHEETHEADERW psh
    )
{
    return -1;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(comctl32)
{
//     DLOENTRY(16, CreateUpDownControl)
    DLOENTRY(17, InitCommonControls)
    DLOENTRY(383, DoReaderMode)
};

DEFINE_ORDINAL_MAP(comctl32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comctl32)
{
//     DLPENTRY(CreatePropertySheetPageW)
//     DLPENTRY(DestroyPropertySheetPage)
//     DLPENTRY(ImageList_Add)
//     DLPENTRY(ImageList_Create)
//     DLPENTRY(ImageList_Destroy)
//     DLPENTRY(ImageList_Draw)
//     DLPENTRY(ImageList_Duplicate)
    DLPENTRY(ImageList_GetIcon)
//     DLPENTRY(ImageList_GetIconSize)
//     DLPENTRY(ImageList_LoadImageW)
//     DLPENTRY(ImageList_ReplaceIcon)
//     DLPENTRY(ImageList_SetBkColor)
//     DLPENTRY(ImageList_SetOverlayImage)
//     DLPENTRY(InitCommonControlsEx)
//     DLPENTRY(PropertySheetW)
};

DEFINE_PROCNAME_MAP(comctl32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\dload.h ===
#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;


#if DBG

//
// DelayLoadAssertFailed/MYASSERT used instead of RtlAssert/ASSERT
// as dload is also compiled to run on Win95
//

VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    );

VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    );

#define MYASSERT(x)     if(!(x)) { DelayLoadAssertFailed(#x,__FILE__,__LINE__,NULL); }

#else

#define MYASSERT(x)

#endif

FARPROC
LookupHandler (
    PDelayLoadInfo  pDelayInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dll\libmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   DllMain for Forms3
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#include <inetreg.h>

extern HRESULT  InitializeDownloadGlobals();

#if DBG == 1
// used for assert to fool the compiler
DWORD g_dwFALSE = 0;
#endif

//  WARNING -- Do not put any global objects with constructors or destructors
//  in this file due to the presence of the init_seg directive below.
//

//+------------------------------------------------------------------------
//
//  External intialization functions
//
//-------------------------------------------------------------------------

// Process attach/detach routines
#ifdef WIN16
// InitUnicodeWrappers initializes this, so when that
// gets fixed get rid of this line.
DWORD g_dwPlatformID = VER_PLATFORM_WIN16;
void InitHeap();
void DeinitHeap();
#else
extern void     InitUnicodeWrappers();
#endif // !WIN16

#ifdef PRODUCT_96
extern HRESULT  InitDynamicVtable();
extern void     DeinitDynamicVtable();
#endif
extern void     DeinitTearOffCache();
extern void     DeinitWindowClasses();
extern void     InitFormClipFormats();
extern void     DeinitForm();
extern void     InitColorTranslation();
extern void     ClearFaceCache();
extern void     InitDefaultControlSizes();
extern HRESULT  InitPalette();
extern BOOL     InitImageUtil();
extern HRESULT  InitICM();
extern HRESULT  InitUrlCompatTable();
extern void     DeinitPalette();
extern void     DeinitSurface();
extern void     DeinitTheme();

#ifdef _MAC
extern void     InitMacDrawing();
extern void     DeinitMacDrawing();
extern "C" pascal void TermRoutine(void);
#endif

extern HRESULT  InitFontCache();
extern void     DeinitTextSubSystem();
extern void     DeinitDownload();
extern void     KillDwnTaskExec();
extern void     KillImgTaskExec();
extern void     DeinitDynamicLibraries();
extern void     DeinitImageSizeCache();

// Thread attach/passivate/detach routines
typedef HRESULT (*PFN_HRESULT_INIT)(THREADSTATE * pts);
typedef void    (*PFN_VOID_DEINIT)(THREADSTATE * pts);

extern HRESULT InitScrollbar(THREADSTATE * pts);
extern void    DeinitScrollbar(THREADSTATE * pts);
extern void    LSDeinitUnderlinePens(THREADSTATE * pts);
extern HRESULT InitBrushCache(THREADSTATE * pts);
extern void    DeinitBrushCache(THREADSTATE * pts);
extern HRESULT InitBmpBrushCache(THREADSTATE * pts);
extern void    DeinitBmpBrushCache(THREADSTATE * pts);
extern HRESULT InitGlobalWindow(THREADSTATE * pts);
extern void    DeinitGlobalWindow(THREADSTATE * pts);
extern HRESULT InitSystemMetricValues(THREADSTATE * pts);
extern void    DeinitSystemMetricValues(THREADSTATE * pts);
extern void    DeinitTimerCtx(THREADSTATE * pts);
extern void    DeinitTooltip(THREADSTATE * pts);
extern void    DeinitTypeLibCache(THREADSTATE * pts);
extern void    DeinitCommitHolder(THREADSTATE *pts);
extern HRESULT InitTaskManager(THREADSTATE * pts);
extern void    DeinitTaskManager(THREADSTATE * pts);
extern void    DeinitFormatCache(THREADSTATE * pts);
//extern void    DeinitSpooler(THREADSTATE * pts);
extern void    DeinitPostMan(THREADSTATE * pts);
extern void    DeinitMultiLanguage();
extern void    DeinitUniscribe();
extern void    DeinitFontLinking();

#ifndef WIN16
extern void    DeinitScriptDebugging();
#endif //!WIN16
extern void    DeinitOptionSettings(THREADSTATE *pts);
extern void    DeinitUserAgentString(THREADSTATE *pts);
extern void    OnSettingsChangeAllDocs(BOOL fNeedLayout);
extern void    DeinitWindowInfo(THREADSTATE *pts);
extern void    DeinitUserStyleSheets(THREADSTATE *pts);
extern void    DeinitImgAnim(THREADSTATE *pts);
extern void    DeinitCategoryInfo(THREADSTATE *pts);
#ifndef NO_IME
extern void    DeinitDIMM();
#endif // ndef NO_IME

extern void    DeinitMLangFontLinking(THREADSTATE * pts);
extern class   CResProtocolCF g_cfResProtocol;
extern class   CAboutProtocolCF g_cfAboutProtocol;
extern class   CViewSourceProtocolCF g_cfViewSourceProtocol;
extern void    DeinitHTMLDialogs();
extern HRESULT InitClassTable();

extern void    DeinitGlobalVersions();

extern HRESULT InitLSCache(THREADSTATE * pts);
extern void    DeinitLSCache(THREADSTATE * pts);

extern void    DeinitVTblDescDispIDCaches(THREADSTATE * pts);

#if DBG == 1
HINSTANCE g_hinstF3Debug = NULL;
#endif

#if defined(DEBUG_TEAROFFS) && !defined(WIN16)
void DebugCheckAllTearoffTables();
#endif

BOOL  SetDLLName(  void  );


//+---------------------------------------------------------------------------
//
//  Class:      CUnloadLibraries
//
//  Purpose:    Special class with a destructor that will be called after
//              all other static destructors are called. This ensures that
//              we don't free any of the libraries we loaded until we're
//              completely cleaned up. Win95 apparently likes to clean up
//              DLLs a little too aggressively when you call FreeLibrary
//              inside DLL_PROCESS_DETACH handlers.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4073) // warning about the following init_seg statement
#pragma init_seg(lib)
class CUnloadLibraries
{
public:
    ~CUnloadLibraries();
};

#ifndef WIN16
// put into WEP for win16 (it doesn't get called otherwise for some reason.)
CUnloadLibraries g_CUnloadLibs;
#endif // ndef WIN16

//+---------------------------------------------------------------------------
//
//  Member:     CUnloadLibraries::~CUnloadLibraries, public
//
//  Synopsis:   class dtor
//
//  Notes:      The init_seg pragma ensures this dtor is called after all
//              others.
//
//----------------------------------------------------------------------------
CUnloadLibraries::~CUnloadLibraries()
{
    DeinitDynamicLibraries();

#if DBG == 1
    if (g_hinstF3Debug)
        FreeLibrary(g_hinstF3Debug);
#endif

}
#pragma warning(default:4073)


#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

//+------------------------------------------------------------------------
//
//  Misc globals
//
//  WARNING -- Do not put any global objects with constructors or destructors
//  in this file due to the presence of the init_seg directive above.
//
//-------------------------------------------------------------------------

static const DWORD  TLS_NULL = ((DWORD)-1);                 // NULL TLS value (defined as 0xFFFFFFFF)

LONG g_lSecondaryObjCount = 0;

#if DBG==1
int g_lSecondaryObjCountCallers[15] = { 0 };
#endif

EXTERN_C HANDLE     g_hProcessHeap = NULL;
HINSTANCE           g_hInstCore = NULL;
HINSTANCE           g_hInstResource = NULL;
TCHAR               g_achDLLCore[MAX_PATH];                 //  Review: Could this be unified
#ifndef WIN16
TCHAR               g_achDLLResource[MAX_PATH];             //          with g_szCodeFragName of the Mac build?
#endif
TCHAR               g_achHelpFileName[MAX_PATH];            // Help file name
DWORD               g_dwTls = TLS_NULL;                     // TLS index associated with THREADSTATEs
THREADSTATE *       g_pts = NULL;                           // Head of THREADSTATE chain
DWORD               g_cThreadStates = 0;                    // Number of THREADSTATEs on the chain

ULONG               g_ulLcl;

#if !defined(WIN16)
CRITICAL_SECTION    CGlobalLock::g_cs;                      // Critical section to protect globals
BOOL                CGlobalLock::g_fInit = FALSE;           // Init flag to protect Critical Section
#if DBG==1
DWORD               CGlobalLock::g_dwThreadID = 0;          // Thread ID which owns the critical section
LONG                CGlobalLock::g_cNesting = 0;            // Enter/LeaveCriticalSection nesting level (DEBUG only)
#endif
#endif

HANDLE              g_hMapHtmPerfCtl = NULL;                // Perf control block memory map handle
HTMPERFCTL *        g_pHtmPerfCtl = NULL;                   // Perf control block (typically NULL)

HRESULT DllThreadAttach();
void    DllThreadDetach(THREADSTATE * pts);
void    DllThreadPassivate(THREADSTATE * pts);
BOOL    DllProcessAttach();
void    DllProcessDetach();


#ifdef WIN16
//+---------------------------------------------------------------------------
//
//  Function:   (De)InitWin16TaskGlobals
//
//  Synopsis:   (De)Inits the pTaskGlobals member of the thread state.
//              Called at threadattach time.
//              Some variables are stored for each HTASK; we should
//              create separate threads for each HTASK; we'll store the
//              HTASK information in the threadstate.
//
//              These functions could be moved to another file.
//
//----------------------------------------------------------------------------

HRESULT InitWin16TaskGlobals(THREADSTATE * pts)
{
    THREADSTATE * pts2;
    HTASK hTask = GetCurrentTask();
    LOCK_GLOBALS;

    // search every pts for an appropriate task global.
    // Expensive but happens infrequently.
    for (pts2 = g_pts;
         pts2 && (!pts2->pTaskGlobals || pts2->pTaskGlobals->hTask != hTask);
         pts2 = pts2->ptsNext);
    if (pts2)
    {
        pts->pTaskGlobals = pts2->pTaskGlobals;
    }
    else
    {
        // create a new set of task globals.
        pts->pTaskGlobals = (WIN16_TASK_GLOBALS *) MemAllocClear(sizeof(WIN16_TASK_GLOBALS));
        if (!pts->pTaskGlobals)
        {
            return E_OUTOFMEMORY;
        }
        pts->pTaskGlobals->hTask = hTask;
    }
    pts->pTaskGlobals->cAttachedThreads++;

    return S_OK;
}

void    DeinitWin16TaskGlobals(THREADSTATE * pts)
{
    if (pts->pTaskGlobals)
    {
        pts->pTaskGlobals->cAttachedThreads--;
        if (!pts->pTaskGlobals->cAttachedThreads)
        {
            MemFree(pts->pTaskGlobals);
        }
    }
}

#endif




//+---------------------------------------------------------------------------
//
//  Function:   DllUpdateSettings
//
//  Synopsis:   Updated cached system settings.  Called when the DLL is
//              attached and in response to WM_WININICHANGE, WM_DEVMODECHANGE,
//              and so on.
//
//----------------------------------------------------------------------------
#ifdef _MAC
    //ISSUE:  ReinitStdTypes should be called regardless of fulldebug or not.
    //        The ReinitStdTypes needs to be in oa and always called.
#  ifdef _MAC_FULLDEBUG
void ReinitStdTypes(void);
#  endif
#endif

extern BOOL g_fSystemFontsNeedRefreshing;

void
DllUpdateSettings(UINT msg)
{
    g_fSystemFontsNeedRefreshing = TRUE;

    if (msg == WM_SYSCOLORCHANGE || msg == WM_DISPLAYCHANGE)
    {
        // On syscolor change, we need to update color table
        InitColorTranslation();
        InitPalette();
        InitImageUtil();
    }

    if (msg == WM_THEMECHANGED)
    {
        //
        // On theme change, we clear our internal theme table
        //

        DeinitTheme();
    }

    // When the fonts available have changed, we need to
    // recheck the system for font faces.
    else if (msg == WM_FONTCHANGE)
    {
        ClearFaceCache();
    }

#ifdef _MAC
    //ISSUE:  ReinitStdTypes should be called regardless of fulldebug or not.
    //        The ReinitStdTypes needs to be in oa and always called.

    //      We need to recreate the hdcDesktop on a WM_SYSCOLORCHANGE
    //      Should this call be in direct response to that message or a general
    //      response to any display setting change?
#  ifdef _MAC_FULLDEBUG
    ReinitStdTypes();
#  endif
    DeinitSystemMetricValues(GetThreadState());
#endif
    InitSystemMetricValues(GetThreadState());

    OnSettingsChangeAllDocs(WM_SYSCOLORCHANGE == msg ||
                            WM_THEMECHANGED == msg ||
                            WM_FONTCHANGE == msg ||
                            (WM_USER + 338) == msg);

}


//+---------------------------------------------------------------------------
//
//  Function:   DllThreadPassivate
//
//  Synopsis:   This function is called when the per-thread object count,
//              dll.lObjCount, transitions to zero.  Deinit things here that
//              cannot be handled at process detach time.
//
//              This function can be called zero, one, or more times during
//              the time the DLL is loaded. Every function called from here
//              here should be prepared to handle this.
//
//----------------------------------------------------------------------------
void
DllThreadPassivate(
    THREADSTATE *   pts)
{
    // Passivate per-thread objects
    // These include:
    //  a) Per-thread OLE error object (held by OLE automation)
    //  b) OLE clipboard object (only one thread should have anything on the clipboard)
    //  c) Per-thread ITypeInfo caches
    //  d) Per-thread picture helper
    //  e) Per-thread default IFont objects
    //
    // NOTE: This code contains one possible race condition: It is possible for
    //       the contents of the clipboard to be changed between the call to
    //       OleIsCurrentClipboard and OleFlushClipboard. If that occurs, this
    //       will flush the wrong object.
    //       GaryBu and I (BrendanD) discussed this case and felt it was not
    //       sufficiently important to warrent implementing a more complete
    //       (and costly) solution.
    Assert(pts);
    TraceTag((tagThread, "DllThreadPassivate called - TID 0x%08x", GetCurrentThreadId()));

    //
    // Tell ole to clear its error info object if one exists.  If we
    // did not load OLEAUT32 then one could not exist.
    //

#ifdef DLOAD1
    if (GetModuleHandleA("OLEAUT32"))
#else
    extern DYNLIB g_dynlibOLEAUT32;

    if (g_dynlibOLEAUT32.hinst)
#endif
    {
        Verify(OK(SetErrorInfo(NULL, NULL)));
    }

    // We actually do this when the last CDoc on the thread goes from running to loaded, 
    // but we also do it here to be safe.  If there actually is something here, we might
    // want to just let it leak instead of calling into COM at this point.
    FormClearClipboard(pts);

    DeinitTypeLibCache(pts);
//    DeinitSpooler(pts);
    if (pts->pInetSess)
    {
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfViewSourceProtocol, _T("view-source"));
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfResProtocol, _T("res"));
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfAboutProtocol, _T("about"));

    }
    ClearInterface(&pts->pInetSess);
}

#ifndef WIN16
//+----------------------------------------------------------------------------
//
//  Function:   DllAllThreadsDetach
//
//  Synopsis:   Cleanup when all Trident threads go away.
//
//-----------------------------------------------------------------------------
void
DllAllThreadsDetach()
{
#ifndef NO_SCRIPT_DEBUGGER  //IEUNIX: UNIX macro.
    IF_NOT_WIN16(DeinitScriptDebugging());
#endif
    DeinitHTMLDialogs();
    DeinitSurface();
    KillDwnTaskExec();
    KillImgTaskExec();
#ifndef NO_IME
    DeinitDIMM();
#endif
    DeinitMultiLanguage();
    DeinitUniscribe();
    DeinitFontLinking();
    DeinitGlobalVersions();

    DeinitTheme();

    if (g_hInstResource)
    {
        MLFreeLibrary(g_hInstResource);
        g_hInstResource = NULL;
    }

    DeinitWindowClasses();
}

#endif // ndef WIN16

//+----------------------------------------------------------------------------
//
//  Function:   DllThreadDetach
//
//  Synopsis:   Release/clean-up per-thread variables
//
//  NOTE:   Since DllThreadDetach is called when DllThreadAttach fails
//          all Deinitxxxx routines must be robust. They must work correctly
//          even if the corresponding Initxxxx routine was not first called.
//
//-----------------------------------------------------------------------------
void
DllThreadDetach(
    THREADSTATE *   pts)
{
    //  Deinitialization routines (called in order)
    static const PFN_VOID_DEINIT s_apfnDeinit[] =
                    {
                    DeinitOptionSettings,
                    DeinitUserAgentString,
                    DeinitPostMan,
                    DeinitTaskManager,
                    DeinitCommitHolder,
                    DeinitWindowInfo,
                    DeinitCategoryInfo,
                    DeinitTooltip,
                    LSDeinitUnderlinePens,
                    DeinitBrushCache,
                    DeinitBmpBrushCache,
                    DeinitScrollbar,
                    DeinitTimerCtx,
                    DeinitSystemMetricValues,
                    DeinitFormatCache,
                    DeinitUserStyleSheets,
                    DeinitImgAnim,
                    DeinitMLangFontLinking,
#ifdef WIN16
                    DeinitWin16TaskGlobals,
#endif
                    DeinitLSCache,
                    DeinitVTblDescDispIDCaches,
                    DeinitGlobalWindow  // Must occur last
                    };
    THREADSTATE **  ppts;
    int             cDeinit;

    if (!pts)
        return;

    Assert(pts->dll.idThread == GetCurrentThreadId());

#ifdef OBJCNTCHK
#if DBG==1
    AssertSz(pts->dll.cLockServer == 0, "DllThreadDetach called with cLockServer count non-zero");
#else
    if (pts->dll.cLockServer != 0)
        F3DebugBreak();
#endif
#endif

#if DBG==1
    TraceTag((tagThread, "DllThreadDetach called - TID 0x%08x", GetCurrentThreadId()));
    if (pts->dll.lObjCount)
    {
        TraceTag((tagError,
                "Thread (TID=0x%08x) terminated with primary object count=%d",
                GetCurrentThreadId(), pts->dll.lObjCount));
    }
#endif

#ifdef _MAC
    // The MAC has only one thread, so no THREADSTATE is explicitly passed
    DeinitMacDrawing();
#endif

    // Deinitialize the per-thread variables
    for (cDeinit = 0; cDeinit < ARRAY_SIZE(s_apfnDeinit); cDeinit++)
    {
        (*s_apfnDeinit[cDeinit])(pts);
    }

    ClearErrorInfo(pts);

    // Remove the per-thread structure from the global list
    LOCK_GLOBALS;
    for (ppts = &g_pts; *ppts && *ppts != pts; ppts = &((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;

        // NOTE: (jbeda) It is important to decrement this after we fix up the global chain
        // because setting this to 1 kicks in the global TS access trick in
        // GetThreadState
        g_cThreadStates--;
    }
#if DBG==1
    else
    {
        TraceTag((tagThread,
                "THREADSTATE not on global chain - TID=0x%08x",
                GetCurrentThreadId()));
    }
#endif

    // Disconnect the memory from the thread and delete it
    TlsSetValue(g_dwTls, NULL);
    delete pts;

    return;
}

void
DllThreadEmergencyDetach()
{
    // This gets called by DLL_THREAD_DETACH.  We need to be careful to only do the
    // absolute minimum here to make sure we don't crash in the future.

    THREADSTATE * pts = (THREADSTATE *)TlsGetValue(g_dwTls);

    if (    pts
        &&  pts->dll.idThread == GetCurrentThreadId()
        &&  pts->gwnd.hwndGlobalWindow)
    {
        EnterCriticalSection(&pts->gwnd.cs);
        DestroyWindow(pts->gwnd.hwndGlobalWindow);
        pts->gwnd.hwndGlobalWindow = NULL;
        LeaveCriticalSection(&pts->gwnd.cs);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   _AddRefThreadState
//
//  Synopsis:   Prepare per-thread variables
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
#ifdef OBJCNTCHK
_AddRefThreadState(DWORD * pdwObjCnt)
#else
_AddRefThreadState()
#endif
{
#ifdef OBJCNTCHK
    if (pdwObjCnt)
    {
        *pdwObjCnt = 0;
    }
#endif

    extern HRESULT DllThreadAttach();
    extern DWORD g_dwTls;
    HRESULT hr;
    if (TlsGetValue(g_dwTls) == 0)
    {
        hr = DllThreadAttach();
        if (hr)
            RRETURN(hr);
    }

    IncrementObjectCount(pdwObjCnt);

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllThreadAttach
//
//  Synopsis:   Prepare per-thread variables
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
DllThreadAttach()
{
    // Note: We need to LOCK_GLOBALS for this entire function as we don't want
    //       to init anything while we are in the middle of DllAllThreadsDetach
    LOCK_GLOBALS;

    //  Initialization routines (called in order)
    static const PFN_HRESULT_INIT s_apfnInit[] =
                    {
                    InitGlobalWindow,       // Must occur first
                    InitSystemMetricValues,
                    InitBrushCache,
                    InitBmpBrushCache,
                    InitScrollbar,
                    InitTaskManager,
#ifdef WIN16
                    InitWin16TaskGlobals,
#endif
                    InitLSCache,
                    };
    THREADSTATE *   pts;
    int             cInit;
    HRESULT         hr = S_OK;

    TraceTag((tagThread, "DllThreadAttach called - TID 0x%08x", GetCurrentThreadId()));

    // Allocate per-thread variables
    Assert(!TlsGetValue(g_dwTls));
    pts = new THREADSTATE;
    if (!pts || !TlsSetValue(g_dwTls, pts))
    {
        if (pts)
        {
            delete pts;
            pts = NULL;
        }
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    MemSetName((pts, "THREADSTATE %08x", GetCurrentThreadId()));

    // Initialize the structure
    pts->dll.idThread = GetCurrentThreadId();

    // Run thread initialization routines
    for (cInit = 0; cInit < ARRAY_SIZE(s_apfnInit); cInit++)
    {
        hr = THR((*s_apfnInit[cInit])(pts));
        if (FAILED(hr))
            goto Error;
    }

#ifdef _MAC
    // The MAC has only one thread, so no THREADSTATE is explicitly passed
    InitMacDrawing();
#endif

Cleanup:
    // If successful, insert the per-thread state structure into the global chain
    if (!hr)
    {
        Assert(pts);

        // NOTE: (jbeda) Insert us into the chain, but leave the first one 
        // intact so we don't have a race condition with the global access trick
        // in GetThreadState
        if (g_pts)
        {
            pts->ptsNext = g_pts->ptsNext;
            g_pts->ptsNext = pts;
        }
        else
        {
            pts->ptsNext = g_pts;
            g_pts = pts;
        }

        g_cThreadStates++;
    }

    if (g_fThemedPlatform)
    {
        SHFusionInitialize();
    }

#if DBG==1
    if( FAILED(hr) )
    {
        TraceTag((tagError, "Thread initialization failed - HRESULT = %hr", hr));
    }
#endif
    return hr;

Error:
    DllThreadDetach(pts);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllProcessDetach
//
//  Synopsis:   Deinitialize the DLL.
//
//              This function can be called on partial initialization
//              of the DLL.  Every function called from here must be
//              capable being called without a corresponding call to
//              an initialization function.
//
//----------------------------------------------------------------------------
extern TCHAR       *g_tszModuleFileName;
void
DllProcessDetach()
{
#if DBG==1
    char szModule[MAX_PATH];
    GetModuleFileNameA(NULL, szModule, MAX_PATH);
#endif

#if DBG==1
    for (int i = 0; i < sizeof(g_Zero); i++)
    {
        if (((BYTE *)&g_Zero)[i] != 0)
        {
            TraceTag((tagError, "g_Zero is non-zero at offset %d", i));
            Assert(0 && "g_Zero is not zero!");
            break;
        }
    }
#endif

	if (g_pts)
	{	
		// Our last, best hope for avoiding a crash it to try to take down the global
		// window on this thread and pray it was the last one.

		DllThreadEmergencyDetach();
	}

    delete [] g_tszModuleFileName;
    DeinitTextSubSystem();
    DeinitDownload();
    DeinitPalette();    
    CRtfToHtmlConverter::Deinit();
#ifndef WIN16
    DeinitImageSizeCache();
#endif // ndef WIN16

#if defined(PRODUCT_PROF) && defined(_MAC)
    _FDisableMeas();
//    _UnHookGlue();
#endif // define(PRODUCT_PROF) && !defined(_MAC)

    DeinitTearOffCache();

#if DBG==1
    if (g_lSecondaryObjCount)
    {
        TraceTag((tagError, "Secondary object count=%d on DLL unload.", g_lSecondaryObjCount));
    }

    if (g_pts != NULL)
    {
        TraceTag((tagError, "One or more THREADSTATE's exist on DLL unload."));
    }
#endif

#ifndef WIN16
    // Delete global variable's critical section
    CGlobalLock::Deinit();
#endif // !WIN16

    // Free per-thread storage index
    if (g_dwTls != TLS_NULL)
    {
        TlsFree(g_dwTls);
    }
#ifdef WIN16
#if DBG==1
    if (g_hinstF3Debug > HINSTANCE_ERROR)
    {
        FreeLibrary(g_hinstF3Debug);
        g_hinstF3Debug = NULL;
    }
#endif
    DeinitHeap();
#endif

    if (g_pHtmPerfCtl)
        Verify(UnmapViewOfFile(g_pHtmPerfCtl));
    if (g_hMapHtmPerfCtl)
        Verify(CloseHandle(g_hMapHtmPerfCtl));
}

BOOL bCallCoInternetCombineUrl = FALSE;

void CheckOutllib()
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    HKEY        hKey;
    TCHAR szOutllibPath[MAX_PATH];
    DWORD cbData = sizeof(szOutllibPath)-sizeof(TCHAR);
        
    //Get App path of outlook.exe
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\OUTLOOK.EXE"), 
            0, KEY_QUERY_VALUE, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("Path"), NULL, NULL, (LPBYTE)szOutllibPath, &cbData))
        {
            szOutllibPath[cbData/sizeof(TCHAR)] = _T('\0');

            if ( MAX_PATH > _tcslen(szOutllibPath)+_tcslen(TEXT("outllib.dll")))
            {
                _tcscat(szOutllibPath, TEXT("outllib.dll"));
    
                dwVerInfoSize = GetFileVersionInfoSize(szOutllibPath, &dwHandle);
                if (dwVerInfoSize)
                {
                    // Alloc the memory for the version stamping
                    lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
                    if (lpBuffer)
                    {
                        // Read version stamping info
                        if (GetFileVersionInfo(szOutllibPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            // Get the value for Translation
                            if (VerQueryValue(lpBuffer, TEXT("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
                            {
                                DWORD dwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                                DWORD dwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                                //Needs version 9.0.0.5205 or higher
                                if (dwMSVer > 0x90000 || (dwMSVer == 0x90000 && dwLSVer >= 5205))
                                    bCallCoInternetCombineUrl = TRUE;
                            }
                        }
                        LocalFree(lpBuffer);
                    }
               }
            }
        }
        RegCloseKey(hKey);
    }
}

DWORD g_dwAppCompat;
void CheckForBrowser()
{
    HKEY hKey;
    HMODULE hMod;
    TCHAR szPathName[MAX_PATH];
    TCHAR *pFileName;
    DWORD cbData;
    
    #define TSZKNOWNBROWSERS TSZIEPATH TEXT("\\Application Compatibility")
    

    g_dwAppCompat = 0;

    hMod = GetModuleHandle(NULL);

    if(hMod && GetModuleFileName(hMod, szPathName, sizeof(szPathName)/sizeof(szPathName[0])))
    {
        pFileName = PathFindFileName(szPathName);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TSZKNOWNBROWSERS, 0, KEY_QUERY_VALUE, &hKey))
        {
            cbData = sizeof(g_dwAppCompat);
            RegQueryValueEx(hKey, pFileName, NULL, NULL, (LPBYTE)&g_dwAppCompat, &cbData);
            RegCloseKey(hKey);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DllProcessAttach
//
//  Synopsis:   Initialize the DLL.
//
//  NOTE:       Even though DllMain is *not* called with DLL_THREAD_ATTACH
//              for the primary thread (since it is assumed during
//              DLL_PROCESS_ATTACH processing), this routines does not call
//              DllThreadAttach. Instead, all entry points are protected by a
//              call to EnsureThreadState which will, if necessary, call
//              DllThreadAttach. To call DllThreadAttach from here, might create
//              an unnecessary instance of the per-thread state structure.
//
//----------------------------------------------------------------------------

BOOL
DllProcessAttach()
{
    TCHAR *     pch = NULL;

#if DBG==1
    char szModule[MAX_PATH];
    GetModuleFileNameA(NULL, szModule, MAX_PATH);
#endif

#ifdef WIN16
    InitHeap();
#endif

    // Allocate per-thread storage index
    g_dwTls = TlsAlloc();
    if (g_dwTls == TLS_NULL)
        goto Error;

#ifndef WIN16
    // Prepare global variable's critical section
    if (CGlobalLock::Init() != S_OK)
        goto Error;
#endif // !WIN16

    if (CGlobalCriticalSection::InitializeAll() != S_OK)
        goto Error;
    else if (InitializeDownloadGlobals() != S_OK)
        goto Error;
    else if (CRtfToHtmlConverter::Init() != S_OK)
        goto Error;
        
    // TODO: Move initialization to C-runtime dll0crt.c
    //g_hProcessHeap = GetProcessHeap();

#if DBG==1

    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif // DBG==1

#if defined(DEBUG_TEAROFFS) && !defined(WIN16)
    DebugCheckAllTearoffTables();
#endif

    InitUnicodeWrappers();

    if (!SetDLLName())
    {
        TraceTag((tagError, "Could not SetDLLName! (%d)", GetLastError()));
        goto Error;
    }

    // Register common clipboard formats used in Forms^3.  These are
    // available in the g_acfCommon array.

    RegisterClipFormats();

    // Now that the g_acfCommon are registered, we can initialize
    // the clip format array for the form and all the controls.

#ifndef WIN16
    InitFormClipFormats();
#endif // ndef WIN16

    // Initialize the global halftone palette
    if (FAILED(InitPalette()))
        goto Error;


    // Build help file name

    _tcscpy(g_achHelpFileName, g_achDLLCore);

#ifndef _MAC
    pch = _tcsrchr(g_achHelpFileName, _T('.'));

    Assert(pch);
    Assert(pch+_tcslen(TEXT(".hlp")) < g_achHelpFileName+sizeof(g_achHelpFileName) / sizeof(g_achHelpFileName[0]) ); // assert there is space to add ".hlp"
    _tcscpy(pch, TEXT(".hlp"));
#endif

    IGNORE_HR(InitUrlCompatTable());

    IGNORE_HR(InitClassTable());

#ifdef SWITCHES_ENABLED
    InitRuntimeSwitches();
#endif

    // Initialize the font cache. We do this here instead
    // of in the InitTextSubSystem() function because that
    // is very slow and we don't want to do it until
    // we know we're loading text. We need to do this here
    // because the registry loading code will initialize
    // the font face atom table.
    if (InitFontCache() != S_OK)
        goto Error;

    // Hook into the htmperfctl block created by our host, if any

    char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
    wsprintfA(achName, "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

#ifndef UNIX // A hack to prevent Unix printing crash.
    g_hMapHtmPerfCtl = OpenFileMappingA(FILE_MAP_WRITE, FALSE, achName);
#else
    g_hMapHtmPerfCtl = NULL;
#endif

    if (g_hMapHtmPerfCtl)
    {
        // If MapViewOfFile fails then g_pHtmPerfCtl will be NULL, which is fine.  We just won't
        // have control of perf for this process.

        g_pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);

        Assert(g_pHtmPerfCtl);
    }
   
    //Haitaoli: 20736 [WinSERaid] Test if the version of outllib.dll >= 9.0.0.5205
    CheckOutllib();
    CheckForBrowser();

    return TRUE;

Error:
    DllProcessDetach();
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//----------------------------------------------------------------------------
#ifndef WIN16

#if defined(UNIX) || defined(_MAC)
extern "C"
#endif
BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore = (HINSTANCE)hDll;
#ifdef DLOAD1
    BaseDllHandle = (HINSTANCE)hDll;    // for DelayLoadFailureHook
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fOk = DllProcessAttach();
        break;
    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        break;
    case DLL_THREAD_DETACH:
        DllThreadEmergencyDetach();
        break;
    }

    AssertThreadDisable(FALSE);

    return fOk;
}


#else // win16
BOOL FAR PASCAL __loadds
LibMain(
    HINSTANCE hDll,
    WORD wDataSeg,
    WORD cbHeapSize,
    LPSTR lpszCmdLine )
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore = hDll;

    fOk = DllProcessAttach();

    AssertThreadDisable(FALSE);

    return fOk;
}

extern "C" int CALLBACK _WEP(int nExitType)
//int __export WINAPI WEP(int nExitType)
{
    DllProcessDetach();

    // this isn't being called properly, so do it here.
    CUnloadLibraries CUnloadLibs;

    return 1;
}
#endif // !win16 else win16

#ifndef WIN16
//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//              (Only the secondary object count need be checked since it
//               contains the total secondary object count and the sum of
//               primary object counts maintained by each thread.)
//
//---------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
    if (g_lSecondaryObjCount == 0 && g_pts == NULL)
        return(S_OK);

    return(S_FALSE);
}
#endif // ndef WIN16

//+---------------------------------------------------------------------------
//
//  Function:   _IncrementObjectCount
//
//  Synopsis:   Increment the per-thread object count
//
//----------------------------------------------------------------------------

void
_IncrementObjectCount()
{
    TLS(dll.lObjCount)++;
    IncrementSecondaryObjectCount( 9 );
}

//+---------------------------------------------------------------------------
//
//  Function:   IncrementObjectCountChk
//
//  Synopsis:   Increment the per-thread object count, and remember the thread
//              id of the thread which did it.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
IncrementObjectCountChk(DWORD * pdwObjCnt)
{
    _IncrementObjectCount();

    if (pdwObjCnt)
    {
        *pdwObjCnt = GetCurrentThreadId();
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   _DecrementObjectCount
//
//  Synopsis:   Decrement the per-thread object count and passivate the
//              thread when it transitions to zero.
//
//----------------------------------------------------------------------------
void
_DecrementObjectCount()
{
    THREADSTATE * pts = GetThreadState();

    Assert(pts->dll.lObjCount > 0);

    if (--pts->dll.lObjCount == 0)
    {
        pts->dll.lObjCount += ULREF_IN_DESTRUCTOR;
        DllThreadPassivate(pts);
        pts->dll.lObjCount -= ULREF_IN_DESTRUCTOR;
        Assert(pts->dll.lObjCount == 0);
        DllThreadDetach(pts);
        LOCK_GLOBALS;
#ifndef WIN16
        if (g_pts == NULL)
        {
            DllAllThreadsDetach();
        }
#endif // ndef WIN16
    }
    DecrementSecondaryObjectCount( 9 );
}

//+---------------------------------------------------------------------------
//
//  Function:   DecrementObjectCountChk
//
//  Synopsis:   Verify that the thread which incremented the object count is
//              the same as the current thread, then decrement the object count.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
DecrementObjectCountChk(DWORD * pdwObjCnt)
{
    if (pdwObjCnt && *pdwObjCnt != GetCurrentThreadId())
    {
        char ach[512];
        wsprintfA(ach, "Attempt to DecrementObjectCount on the wrong thread.  The matching "
                 "IncrementObjectCount call happened on thread 0x%08lX; attemping release "
                 "on thread 0x%08lX.", *pdwObjCnt, GetCurrentThreadId());
#if DBG==1
        AssertSz(0, ach);
#else
        F3DebugBreak();
#endif
    }
    else
    {
        _DecrementObjectCount();
    }

    if (pdwObjCnt)
    {
        *pdwObjCnt = 0;
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   SetDLLName ()
//
//  Synopsis:   Get the fm20.dll
//
//----------------------------------------------------------------------------

#ifdef _MAC
TCHAR g_szMacBase[32];
#endif

BOOL  SetDLLName(  void )
{



    //  ISSUE:  Win95 has a known bug: If you specify the
    //          LOAD_LIBRARY_AS_DATAFILE flag, all subsequent Load<Resource>
    //          calls could fail. That's why we use a straight LoadLibrary to
    //          load the resource DLL. This is due to the differences between
    //          instance handles and module handles in Windows.
    //  Fix:    When a fix for Win95 is issued be sure to insert the flag here.
    //          When the change happens, the following Windows calls need to
    //          be reviewed:
    //          CreateDialog, CreateDialogParam, DialogBox, DialogBoxParam,
    //          MessageBox, MessageBoxIndirect.
    //  Note:   DONT_RESOLVE_DLL_REFERENCES is specified as "NT only"
#ifndef _MAC
    if ((GetModuleFileName(g_hInstCore,
                           g_achDLLCore,
                           ARRAY_SIZE(g_achDLLCore)) == 0)
                           || (_tcslen(g_achDLLCore) == 0))
        return( FALSE );
#else
    TCHAR    achAppLoc[MAX_PATH];

    if (GetModuleFileName(g_hInstCore, achAppLoc, MAX_PATH) == 0)

    if (GetFileTitle(achAppLoc,g_szMacBase,MAX_PATH))
            return( FALSE );

    if (_tcslen(g_szMacBase) == 0)
            return( FALSE );

    _tcscpy(g_achDLLCore,_T("MSHTM"));

#endif

    return (TRUE);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\imgutil.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <ddraw.h>
#include <imgutil.h>

static
HRESULT
WINAPI
CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
    return E_FAIL;
}

static
HRESULT
WINAPI
DecodeImage(
    IStream* pStream,
    IMapMIMEToCLSID* pMap,
    IUnknown* pEventSink
    )
{
    return E_FAIL;
}

static
HRESULT
WINAPI
IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, UINT* pnFormat )
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imgutil)
{
    DLPENTRY(CreateDDrawSurfaceOnDIB)
    DLPENTRY(DecodeImage)
    DLPENTRY(IdentifyMIMEType)
};

DEFINE_PROCNAME_MAP(imgutil)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\imm32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <imm.h>

static 
UINT WINAPI ImmGetVirtualKey(IN HWND a)
{
    return 0;
}

static
BOOL WINAPI ImmSetOpenStatusDIMM(HIMC hIMC, BOOL fOpen)
{
    return FALSE;
}

static
BOOL WINAPI ImmSetConversionStatus(IN HIMC hIMC, IN DWORD dw1, IN DWORD dw2)
{
    return FALSE;
}

static
HIMC WINAPI ImmGetContext(IN HWND hwnd)
{
    return 0;
}

static
HIMC WINAPI ImmAssociateContext(IN HWND hwnd, IN HIMC hIMC)
{
    return 0;
}

static
BOOL WINAPI ImmGetConversionStatus(IN HIMC hIMC, OUT LPDWORD lpdw1, OUT LPDWORD lpdw2)
{
    return FALSE;
}

static
LONG  WINAPI ImmGetCompositionStringW(IN HIMC hIMC, IN DWORD dw1, OUT LPVOID pv, IN DWORD dw2)
{
    return 0;
}

static
BOOL  WINAPI ImmSetCompositionStringA(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dw1, IN LPVOID lpRead, IN DWORD dw2)
{
    return FALSE;
}

static
LRESULT WINAPI ImmEscapeW(IN HKL hkl, IN HIMC hIMC, IN UINT ui, IN LPVOID pv)
{
    return 0;
}

static
LRESULT WINAPI ImmEscapeA(IN HKL hkl, IN HIMC hIMC, IN UINT ui, IN LPVOID pv)
{
    return 0;
}

static
BOOL WINAPI ImmSetCandidateWindow(IN HIMC hIMC, IN LPCANDIDATEFORM lpcf)
{
    return FALSE;
}

static
BOOL WINAPI ImmReleaseContext(IN HWND hwnd, IN HIMC hIMC)
{
    return FALSE;
}

static
DWORD WINAPI ImmGetProperty(IN HKL hkl, IN DWORD dw)
{
    return 0;
}

static
BOOL WINAPI ImmSetCompositionWindow(IN HIMC hIMC, IN LPCOMPOSITIONFORM lpcf)
{
    return FALSE;
}

static
LONG  WINAPI ImmGetCompositionStringA(IN HIMC hIMC, IN DWORD dw1, OUT LPVOID lpv, IN DWORD dw2)
{
    return 0;
}

static
BOOL WINAPI ImmGetCandidateWindow(IN HIMC hIMC, IN DWORD dw, OUT LPCANDIDATEFORM lpcf)
{
    return FALSE;
}

static
BOOL    WINAPI ImmNotifyIME(IN HIMC hIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue)
{
    return FALSE;
}

static
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dw1, IN LPVOID lpRead, IN DWORD dw2)
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imm32)
{
    DLPENTRY(ImmAssociateContext)
    DLPENTRY(ImmEscapeA)
    DLPENTRY(ImmEscapeW)
    DLPENTRY(ImmGetCandidateWindow)
    DLPENTRY(ImmGetCompositionStringA)
    DLPENTRY(ImmGetCompositionStringW)
    DLPENTRY(ImmGetContext)
    DLPENTRY(ImmGetConversionStatus)
    DLPENTRY(ImmGetProperty)
    DLPENTRY(ImmGetVirtualKey)
    DLPENTRY(ImmNotifyIME)
    DLPENTRY(ImmReleaseContext)
    DLPENTRY(ImmSetCandidateWindow)
    DLPENTRY(ImmSetCompositionStringA)
    DLPENTRY(ImmSetCompositionStringW)
    DLPENTRY(ImmSetCompositionWindow)
    DLPENTRY(ImmSetConversionStatus)
    DLPENTRY(ImmSetOpenStatus)
};

DEFINE_PROCNAME_MAP(imm32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\mpr.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <winnetwk.h>

static
DWORD
APIENTRY
WNetAddConnection2W(
     IN LPNETRESOURCEW lpNetResource,
     IN LPCWSTR       lpPassword,
     IN LPCWSTR       lpUserName,
     IN DWORD          dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
WNetAddConnection3W(
    IN HWND             hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR          lpPassword,
    IN LPCWSTR          lpUserName,
    IN DWORD            dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCancelConnection2W(
    IN LPCWSTR  lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCloseEnum(
    IN HANDLE   hEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetEnumResourceW(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUniversalNameW(
     IN LPCWSTR lpLocalPath,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpBufferSize
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationW(
    IN LPNETRESOURCEW   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPWSTR         *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumA(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumW(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}


DEFINE_PROCNAME_ENTRIES(mpr)
{
//     DLPENTRY(WNetAddConnection2W)
//     DLPENTRY(WNetAddConnection3W)
//     DLPENTRY(WNetCancelConnection2W)
    DLPENTRY(WNetCloseEnum)
//     DLPENTRY(WNetEnumResourceW)
//     DLPENTRY(WNetGetResourceInformationW)
//     DLPENTRY(WNetGetUniversalNameW)
    DLPENTRY(WNetOpenEnumA)
    DLPENTRY(WNetOpenEnumW)
};

DEFINE_PROCNAME_MAP(mpr)


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\msjava.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define JAVAVMAPI
#include <native.h>

static
JAVAVMAPI
long
__cdecl
execute_java_dynamic_method(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...                             
    )
{
    return 0;
}

static
JAVAVMAPI
int64_t
__cdecl
execute_java_dynamic_method64(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...
    )
{
    return 0;
}

static
JAVAVMAPI
void
__cdecl
GCFramePush(
    PVOID pGCFrame,
    PVOID pObjects,
    DWORD cbObjectStructSize
    )
{
}

static
JAVAVMAPI
BOOL
__cdecl
is_instance_of(
    HObject    *phObj,
    ClassClass *pClass,
    ExecEnv    *Unused
    )
{
    return FALSE;
}

static
JAVAVMAPI
void
__cdecl
GCFramePop(
    PVOID pGCFrame
    )
{
}

static
JAVAVMAPI
HObject*
__cdecl
execute_java_constructor(
    ExecEnv *Unused,
    PCUTF8 putfClassName,
    ClassClass *pClass,
    PCUTF8 putfSignature,
    ...
    )
{
    return NULL;
}

static
JAVAVMAPI
HString *
__cdecl
makeJavaStringW(
    LPCWSTR pcwsz,
    int cch
    )
{
    return NULL;
}

static
JAVAVMAPI
HObject *
__cdecl
convert_IUnknown_to_Java_Object(
    IUnknown *punk,
    HObject *phJavaClass,
    int fAssumeThreadSafe
    )
{
    return NULL;
}

static
JAVAVMAPI
ClassClass*
__cdecl
FindClass(
    ExecEnv *Unused,
    PCUTF8   putfClassName,
    bool_t   fResolve
    )
{
    return NULL;
}

static
JAVAVMAPI
void*
__cdecl
jcdwGetData(
    HObject *phJCDW
    )
{
    return NULL;
}

static
JAVAVMAPI
IUnknown *
__cdecl
convert_Java_Object_to_IUnknown(
    HObject *phJavaObject,
    const IID *pIID
    )
{
    return NULL;
}

static
JAVAVMAPI
LPWSTR
__cdecl
javaStringStart(
    HString *phString
    )
{
    return NULL;
}

static
JAVAVMAPI
int
__cdecl
javaStringLength(
    HString *phString
    )
{
    return 0;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msjava)
{
    DLPENTRY(FindClass)
    DLPENTRY(GCFramePop)
    DLPENTRY(GCFramePush)
    DLPENTRY(convert_IUnknown_to_Java_Object)
    DLPENTRY(convert_Java_Object_to_IUnknown)
    DLPENTRY(execute_java_constructor)
    DLPENTRY(execute_java_dynamic_method)
    DLPENTRY(execute_java_dynamic_method64)
    DLPENTRY(is_instance_of)
    DLPENTRY(javaStringLength)    
    DLPENTRY(javaStringStart)
    DLPENTRY(jcdwGetData)
    DLPENTRY(makeJavaStringW)
};

DEFINE_PROCNAME_MAP(msjava)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\msrating.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <ratings.h>

static 
STDMETHODIMP RatingEnabledQuery()
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msrating)
{
    DLPENTRY(RatingEnabledQuery)
};

DEFINE_PROCNAME_MAP(msrating)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\oleaut32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _OLEAUT32_
#include <oleauto.h>
#include <ocidl.h>
#include <olectl.h>

#define NOTIMPV(func)       { OutputDebugStringA("OLEAUT32: Delayload stub called: " #func "\r\n"); }
#define NOTIMP_(ret, func)  { OutputDebugStringA("OLEAUT32: Delayload stub called: " #func "\r\n"); return(ret); }
#define NOTIMP(func)        NOTIMP_(E_NOTIMPL, func)

static STDMETHODIMP_(BSTR) SysAllocString(const OLECHAR * sz)
{
    NOTIMP_(NULL, SysAllocString);
}

static STDMETHODIMP_(INT) SysReAllocString(BSTR * pbstr, const OLECHAR * sz)
{
    NOTIMP_(FALSE, SysReAllocString);
}

static STDMETHODIMP_(BSTR) SysAllocStringLen(const OLECHAR * szIn, UINT cch)
{
    NOTIMP_(NULL, SysAllocStringLen);
}

static STDMETHODIMP_(INT) SysReAllocStringLen(BSTR * pbstr, const OLECHAR * sz, UINT cch)
{
    NOTIMP_(FALSE, SysReAllocStringLen);
}

static STDMETHODIMP_(void) SysFreeString(BSTR bstr)
{
    NOTIMPV(SysFreeString);
}

static STDMETHODIMP_(UINT) SysStringLen(BSTR bstr)
{
    NOTIMP_(0, SysStringLen);
}

static STDMETHODIMP_(UINT) SysStringByteLen(BSTR bstr)
{
    NOTIMP_(0, SysStringByteLen);
}

static STDMETHODIMP_(BSTR) SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    NOTIMP_(NULL, SysAllocStringByteLen);
}

static STDMETHODIMP_(INT) DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime)
{
    NOTIMP_(0, DosDateTimeToVariantTime);
}

static STDMETHODIMP_(INT) VariantTimeToDosDateTime(DOUBLE vtime, USHORT * pwDosDate, USHORT * pwDosTime)
{
    NOTIMP_(0, VariantTimeToDosDateTime);
}

static STDMETHODIMP_(INT) SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, DOUBLE *pvtime)
{
    NOTIMP_(0, SystemTimeToVariantTime);
}

static STDMETHODIMP_(INT) VariantTimeToSystemTime(DOUBLE vtime, LPSYSTEMTIME lpSystemTime)
{
    NOTIMP_(0, VariantTimeToSystemTime);
}

static STDMETHODIMP SafeArrayAllocDescriptor(UINT cDims, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayAllocDescriptor);
}

static STDMETHODIMP SafeArrayAllocDescriptorEx(VARTYPE vt, UINT cDims, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayAllocDescriptorEx);
}

static STDMETHODIMP SafeArrayAllocData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayAllocData);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreate(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound)
{
    NOTIMP_(NULL, SafeArrayCreate);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateEx(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra)
{
    NOTIMP_(NULL, SafeArrayCreateEx);
}

static STDMETHODIMP SafeArrayCopyData(SAFEARRAY *psaSource, SAFEARRAY *psaTarget)
{
    NOTIMP(SafeArrayCopyData);
}

static STDMETHODIMP SafeArrayDestroyDescriptor(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroyDescriptor);
}

static STDMETHODIMP SafeArrayDestroyData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroyData);
}

static STDMETHODIMP SafeArrayDestroy(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroy);
}

static STDMETHODIMP SafeArrayRedim(SAFEARRAY * psa, SAFEARRAYBOUND * psaboundNew)
{
    NOTIMP(SafeArrayRedim);
}

static STDMETHODIMP_(UINT) SafeArrayGetDim(SAFEARRAY * psa)
{
    NOTIMP_(0, SafeArrayGetDim);
}

static STDMETHODIMP_(UINT) SafeArrayGetElemsize(SAFEARRAY * psa)
{
    NOTIMP_(0, SafeArrayGetElemsize);
}

static STDMETHODIMP SafeArrayGetUBound(SAFEARRAY * psa, UINT nDim, LONG * plUbound)
{
    NOTIMP(SafeArrayGetUBound);
}

static STDMETHODIMP SafeArrayGetLBound(SAFEARRAY * psa, UINT nDim, LONG * plLbound)
{
    NOTIMP(SafeArrayGetLBound);
}

static STDMETHODIMP SafeArrayLock(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayLock);
}

static STDMETHODIMP SafeArrayUnlock(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayUnlock);
}

static STDMETHODIMP SafeArrayAccessData(SAFEARRAY * psa, void HUGEP** ppvData)
{
    NOTIMP(SafeArrayAccessData);
}

static STDMETHODIMP SafeArrayUnaccessData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayUnaccessData);
}

static STDMETHODIMP SafeArrayGetElement(SAFEARRAY * psa, LONG * rgIndices, void * pv)
{
    NOTIMP(SafeArrayGetElement);
}

static STDMETHODIMP SafeArrayPutElement(SAFEARRAY * psa, LONG * rgIndices, void * pv)
{
    NOTIMP(SafeArrayPutElement);
}

static STDMETHODIMP SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayCopy);
}

static STDMETHODIMP SafeArrayPtrOfIndex(SAFEARRAY * psa, LONG * rgIndices, void ** ppvData)
{
    NOTIMP(SafeArrayPtrOfIndex);
}

static STDMETHODIMP SafeArraySetRecordInfo(SAFEARRAY * psa, IRecordInfo * prinfo)
{
    NOTIMP(SafeArraySetRecordInfo);
}

static STDMETHODIMP SafeArrayGetRecordInfo(SAFEARRAY * psa, IRecordInfo ** prinfo)
{
    NOTIMP(SafeArrayGetRecordInfo);
}

static STDMETHODIMP SafeArraySetIID(SAFEARRAY * psa, REFGUID guid)
{
    NOTIMP(SafeArraySetIID);
}

static STDMETHODIMP SafeArrayGetIID(SAFEARRAY * psa, GUID * pguid)
{
    NOTIMP(SafeArrayGetIID);
}

static STDMETHODIMP SafeArrayGetVartype(SAFEARRAY * psa, VARTYPE * pvt)
{
    NOTIMP(SafeArrayGetVartype);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateVector(VARTYPE vt, LONG lLbound, ULONG cElements)
{
    NOTIMP_(NULL, SafeArrayCreateVector);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateVectorEx(VARTYPE vt, LONG lLbound, ULONG cElements, PVOID pvExtra)
{
    NOTIMP_(NULL, SafeArrayCreateVectorEx);
}

static STDMETHODIMP_(void) VariantInit(VARIANTARG * pvarg)
{
    pvarg->vt = VT_EMPTY;
}

static STDMETHODIMP VariantClear(VARIANTARG * pvarg)
{
    pvarg->vt = VT_EMPTY;
    return E_NOTIMPL;
}

static STDMETHODIMP VariantCopy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    NOTIMP(VariantCopy);
}

static STDMETHODIMP VariantCopyInd(VARIANT * pvarDest, VARIANTARG * pvargSrc)
{
    NOTIMP(VariantCopyInd);
}

static STDMETHODIMP VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt)
{
    NOTIMP(VariantChangeType);
}

static STDMETHODIMP VariantChangeTypeEx(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt)
{
    NOTIMP(VariantChangeTypeEx);
}

static STDMETHODIMP VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    NOTIMP(VectorFromBstr);
}

static STDMETHODIMP BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    NOTIMP(BstrFromVector);
}

static STDMETHODIMP VarUI1FromI2(SHORT sIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromI2);
}

static STDMETHODIMP VarUI1FromI4(LONG lIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromI4);
}

static STDMETHODIMP VarUI1FromR4(FLOAT fltIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromR4);
}

static STDMETHODIMP VarUI1FromR8(DOUBLE dblIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromR8);
}

static STDMETHODIMP VarUI1FromCy(CY cyIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromCy);
}

static STDMETHODIMP VarUI1FromDate(DATE dateIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromDate);
}

static STDMETHODIMP VarUI1FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, BYTE * pbOut)
{
    NOTIMP(VarUI1FromStr);
}

static STDMETHODIMP VarUI1FromDisp(IDispatch * pdispIn, LCID lcid, BYTE * pbOut)
{
    NOTIMP(VarUI1FromDisp);
}

static STDMETHODIMP VarUI1FromBool(VARIANT_BOOL boolIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromBool);
}

static STDMETHODIMP VarUI1FromI1(CHAR cIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromI1);
}

static STDMETHODIMP VarUI1FromUI2(USHORT uiIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromUI2);
}

static STDMETHODIMP VarUI1FromUI4(ULONG ulIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromUI4);
}

static STDMETHODIMP VarUI1FromDec(DECIMAL *pdecIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromDec);
}

static STDMETHODIMP VarI2FromUI1(BYTE bIn, SHORT * psOut)
{
    NOTIMP(VarI2FromUI1);
}

static STDMETHODIMP VarI2FromI4(LONG lIn, SHORT * psOut)
{
    NOTIMP(VarI2FromI4);
}

static STDMETHODIMP VarI2FromR4(FLOAT fltIn, SHORT * psOut)
{
    NOTIMP(VarI2FromR4);
}

static STDMETHODIMP VarI2FromR8(DOUBLE dblIn, SHORT * psOut)
{
    NOTIMP(VarI2FromR8);
}

static STDMETHODIMP VarI2FromCy(CY cyIn, SHORT * psOut)
{
    NOTIMP(VarI2FromCy);
}

static STDMETHODIMP VarI2FromDate(DATE dateIn, SHORT * psOut)
{
    NOTIMP(VarI2FromDate);
}

static STDMETHODIMP VarI2FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, SHORT * psOut)
{
    NOTIMP(VarI2FromStr);
}

static STDMETHODIMP VarI2FromDisp(IDispatch * pdispIn, LCID lcid, SHORT * psOut)
{
    NOTIMP(VarI2FromDisp);
}

static STDMETHODIMP VarI2FromBool(VARIANT_BOOL boolIn, SHORT * psOut)
{
    NOTIMP(VarI2FromBool);
}

static STDMETHODIMP VarI2FromI1(CHAR cIn, SHORT *psOut)
{
    NOTIMP(VarI2FromI1);
}

static STDMETHODIMP VarI2FromUI2(USHORT uiIn, SHORT *psOut)
{
    NOTIMP(VarI2FromUI2);
}

static STDMETHODIMP VarI2FromUI4(ULONG ulIn, SHORT *psOut)
{
    NOTIMP(VarI2FromUI4);
}

static STDMETHODIMP VarI2FromDec(DECIMAL *pdecIn, SHORT *psOut)
{
    NOTIMP(VarI2FromDec);
}

static STDMETHODIMP VarI4FromUI1(BYTE bIn, LONG * plOut)
{
    NOTIMP(VarI4FromUI1);
}

static STDMETHODIMP VarI4FromI2(SHORT sIn, LONG * plOut)
{
    NOTIMP(VarI4FromI2);
}

static STDMETHODIMP VarI4FromR4(FLOAT fltIn, LONG * plOut)
{
    NOTIMP(VarI4FromR4);
}

static STDMETHODIMP VarI4FromR8(DOUBLE dblIn, LONG * plOut)
{
    NOTIMP(VarI4FromR8);
}

static STDMETHODIMP VarI4FromCy(CY cyIn, LONG * plOut)
{
    NOTIMP(VarI4FromCy);
}

static STDMETHODIMP VarI4FromDate(DATE dateIn, LONG * plOut)
{
    NOTIMP(VarI4FromDate);
}

static STDMETHODIMP VarI4FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, LONG * plOut)
{
    NOTIMP(VarI4FromStr);
}

static STDMETHODIMP VarI4FromDisp(IDispatch * pdispIn, LCID lcid, LONG * plOut)
{
    NOTIMP(VarI4FromDisp);
}

static STDMETHODIMP VarI4FromBool(VARIANT_BOOL boolIn, LONG * plOut)
{
    NOTIMP(VarI4FromBool);
}

static STDMETHODIMP VarI4FromI1(CHAR cIn, LONG *plOut)
{
    NOTIMP(VarI4FromI1);
}

static STDMETHODIMP VarI4FromUI2(USHORT uiIn, LONG *plOut)
{
    NOTIMP(VarI4FromUI2);
}

static STDMETHODIMP VarI4FromUI4(ULONG ulIn, LONG *plOut)
{
    NOTIMP(VarI4FromUI4);
}

static STDMETHODIMP VarI4FromDec(DECIMAL *pdecIn, LONG *plOut)
{
    NOTIMP(VarI4FromDec);
}

static STDMETHODIMP VarR4FromUI1(BYTE bIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromUI1);
}

static STDMETHODIMP VarR4FromI2(SHORT sIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromI2);
}

static STDMETHODIMP VarR4FromI4(LONG lIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromI4);
}

static STDMETHODIMP VarR4FromR8(DOUBLE dblIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromR8);
}

static STDMETHODIMP VarR4FromCy(CY cyIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromCy);
}

static STDMETHODIMP VarR4FromDate(DATE dateIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromDate);
}

static STDMETHODIMP VarR4FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromStr);
}

static STDMETHODIMP VarR4FromDisp(IDispatch * pdispIn, LCID lcid, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromDisp);
}

static STDMETHODIMP VarR4FromBool(VARIANT_BOOL boolIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromBool);
}

static STDMETHODIMP VarR4FromI1(CHAR cIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromI1);
}

static STDMETHODIMP VarR4FromUI2(USHORT uiIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromUI2);
}

static STDMETHODIMP VarR4FromUI4(ULONG ulIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromUI4);
}

static STDMETHODIMP VarR4FromDec(DECIMAL *pdecIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromDec);
}

static STDMETHODIMP VarR8FromUI1(BYTE bIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromUI1);
}

static STDMETHODIMP VarR8FromI2(SHORT sIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromI2);
}

static STDMETHODIMP VarR8FromI4(LONG lIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromI4);
}

static STDMETHODIMP VarR8FromR4(FLOAT fltIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromR4);
}

static STDMETHODIMP VarR8FromCy(CY cyIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromCy);
}

static STDMETHODIMP VarR8FromDate(DATE dateIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromDate);
}

static STDMETHODIMP VarR8FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromStr);
}

static STDMETHODIMP VarR8FromDisp(IDispatch * pdispIn, LCID lcid, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromDisp);
}

static STDMETHODIMP VarR8FromBool(VARIANT_BOOL boolIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromBool);
}

static STDMETHODIMP VarR8FromI1(CHAR cIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromI1);
}

static STDMETHODIMP VarR8FromUI2(USHORT uiIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromUI2);
}

static STDMETHODIMP VarR8FromUI4(ULONG ulIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromUI4);
}

static STDMETHODIMP VarR8FromDec(DECIMAL *pdecIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromDec);
}

static STDMETHODIMP VarDateFromUI1(BYTE bIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromUI1);
}

static STDMETHODIMP VarDateFromI2(SHORT sIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromI2);
}

static STDMETHODIMP VarDateFromI4(LONG lIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromI4);
}

static STDMETHODIMP VarDateFromR4(FLOAT fltIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromR4);
}

static STDMETHODIMP VarDateFromR8(DOUBLE dblIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromR8);
}

static STDMETHODIMP VarDateFromCy(CY cyIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromCy);
}

static STDMETHODIMP VarDateFromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromStr);
}

static STDMETHODIMP VarDateFromDisp(IDispatch * pdispIn, LCID lcid, DATE * pdateOut)
{
    NOTIMP(VarDateFromDisp);
}

static STDMETHODIMP VarDateFromBool(VARIANT_BOOL boolIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromBool);
}

static STDMETHODIMP VarDateFromI1(CHAR cIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromI1);
}

static STDMETHODIMP VarDateFromUI2(USHORT uiIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromUI2);
}

static STDMETHODIMP VarDateFromUI4(ULONG ulIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromUI4);
}

static STDMETHODIMP VarDateFromDec(DECIMAL *pdecIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromDec);
}

static STDMETHODIMP VarCyFromUI1(BYTE bIn, CY * pcyOut)
{
    NOTIMP(VarCyFromUI1);
}

static STDMETHODIMP VarCyFromI2(SHORT sIn, CY * pcyOut)
{
    NOTIMP(VarCyFromI2);
}

static STDMETHODIMP VarCyFromI4(LONG lIn, CY * pcyOut)
{
    NOTIMP(VarCyFromI4);
}

static STDMETHODIMP VarCyFromR4(FLOAT fltIn, CY * pcyOut)
{
    NOTIMP(VarCyFromR4);
}

static STDMETHODIMP VarCyFromR8(DOUBLE dblIn, CY * pcyOut)
{
    NOTIMP(VarCyFromR8);
}

static STDMETHODIMP VarCyFromDate(DATE dateIn, CY * pcyOut)
{
    NOTIMP(VarCyFromDate);
}

static STDMETHODIMP VarCyFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, CY * pcyOut)
{
    NOTIMP(VarCyFromStr);
}

static STDMETHODIMP VarCyFromDisp(IDispatch * pdispIn, LCID lcid, CY * pcyOut)
{
    NOTIMP(VarCyFromDisp);
}

static STDMETHODIMP VarCyFromBool(VARIANT_BOOL boolIn, CY * pcyOut)
{
    NOTIMP(VarCyFromBool);
}

static STDMETHODIMP VarCyFromI1(CHAR cIn, CY *pcyOut)
{
    NOTIMP(VarCyFromI1);
}

static STDMETHODIMP VarCyFromUI2(USHORT uiIn, CY *pcyOut)
{
    NOTIMP(VarCyFromUI2);
}

static STDMETHODIMP VarCyFromUI4(ULONG ulIn, CY *pcyOut)
{
    NOTIMP(VarCyFromUI4);
}

static STDMETHODIMP VarCyFromDec(DECIMAL *pdecIn, CY *pcyOut)
{
    NOTIMP(VarCyFromDec);
}

static STDMETHODIMP VarBstrFromUI1(BYTE bVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromUI1);
}

static STDMETHODIMP VarBstrFromI2(SHORT iVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromI2);
}

static STDMETHODIMP VarBstrFromI4(LONG lIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromI4);
}

static STDMETHODIMP VarBstrFromR4(FLOAT fltIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromR4);
}

static STDMETHODIMP VarBstrFromR8(DOUBLE dblIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromR8);
}

static STDMETHODIMP VarBstrFromCy(CY cyIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromCy);
}

static STDMETHODIMP VarBstrFromDate(DATE dateIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromDate);
}

static STDMETHODIMP VarBstrFromDisp(IDispatch * pdispIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromDisp);
}

static STDMETHODIMP VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromBool);
}

static STDMETHODIMP VarBstrFromI1(CHAR cIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromI1);
}

static STDMETHODIMP VarBstrFromUI2(USHORT uiIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromUI2);
}

static STDMETHODIMP VarBstrFromUI4(ULONG ulIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromUI4);
}

static STDMETHODIMP VarBstrFromDec(DECIMAL *pdecIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromDec);
}

static STDMETHODIMP VarBoolFromUI1(BYTE bIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromUI1);
}

static STDMETHODIMP VarBoolFromI2(SHORT sIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromI2);
}

static STDMETHODIMP VarBoolFromI4(LONG lIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromI4);
}

static STDMETHODIMP VarBoolFromR4(FLOAT fltIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromR4);
}

static STDMETHODIMP VarBoolFromR8(DOUBLE dblIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromR8);
}

static STDMETHODIMP VarBoolFromDate(DATE dateIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromDate);
}

static STDMETHODIMP VarBoolFromCy(CY cyIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromCy);
}

static STDMETHODIMP VarBoolFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromStr);
}

static STDMETHODIMP VarBoolFromDisp(IDispatch * pdispIn, LCID lcid, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromDisp);
}

static STDMETHODIMP VarBoolFromI1(CHAR cIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromI1);
}

static STDMETHODIMP VarBoolFromUI2(USHORT uiIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromUI2);
}

static STDMETHODIMP VarBoolFromUI4(ULONG ulIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromUI4);
}

static STDMETHODIMP VarBoolFromDec(DECIMAL *pdecIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromDec);
}

static STDMETHODIMP VarI1FromUI1(BYTE bIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI1);
}

static STDMETHODIMP VarI1FromI2(SHORT uiIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromI2);
}

static STDMETHODIMP VarI1FromI4(LONG lIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromI4);
}

static STDMETHODIMP VarI1FromR4(FLOAT fltIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromR4);
}

static STDMETHODIMP VarI1FromR8(DOUBLE dblIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromR8);
}

static STDMETHODIMP VarI1FromDate(DATE dateIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromDate);
}

static STDMETHODIMP VarI1FromCy(CY cyIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromCy);
}

static STDMETHODIMP VarI1FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, CHAR *pcOut)
{
    NOTIMP(VarI1FromStr);
}

static STDMETHODIMP VarI1FromDisp(IDispatch *pdispIn, LCID lcid, CHAR *pcOut)
{
    NOTIMP(VarI1FromDisp);
}

static STDMETHODIMP VarI1FromBool(VARIANT_BOOL boolIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromBool);
}

static STDMETHODIMP VarI1FromUI2(USHORT uiIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI2);
}

static STDMETHODIMP VarI1FromUI4(ULONG ulIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI4);
}

static STDMETHODIMP VarI1FromDec(DECIMAL *pdecIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromDec);
}

static STDMETHODIMP VarUI2FromUI1(BYTE bIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromUI1);
}

static STDMETHODIMP VarUI2FromI2(SHORT uiIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI2);
}

static STDMETHODIMP VarUI2FromI4(LONG lIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI4);
}

static STDMETHODIMP VarUI2FromR4(FLOAT fltIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromR4);
}

static STDMETHODIMP VarUI2FromR8(DOUBLE dblIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromR8);
}

static STDMETHODIMP VarUI2FromDate(DATE dateIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDate);
}

static STDMETHODIMP VarUI2FromCy(CY cyIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromCy);
}

static STDMETHODIMP VarUI2FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, USHORT *puiOut)
{
    NOTIMP(VarUI2FromStr);
}

static STDMETHODIMP VarUI2FromDisp(IDispatch *pdispIn, LCID lcid, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDisp);
}

static STDMETHODIMP VarUI2FromBool(VARIANT_BOOL boolIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromBool);
}

static STDMETHODIMP VarUI2FromI1(CHAR cIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI1);
}

static STDMETHODIMP VarUI2FromUI4(ULONG ulIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromUI4);
}

static STDMETHODIMP VarUI2FromDec(DECIMAL *pdecIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDec);
}

static STDMETHODIMP VarUI4FromUI1(BYTE bIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromUI1);
}

static STDMETHODIMP VarUI4FromI2(SHORT uiIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI2);
}

static STDMETHODIMP VarUI4FromI4(LONG lIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI4);
}

static STDMETHODIMP VarUI4FromR4(FLOAT fltIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromR4);
}

static STDMETHODIMP VarUI4FromR8(DOUBLE dblIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromR8);
}

static STDMETHODIMP VarUI4FromDate(DATE dateIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDate);
}

static STDMETHODIMP VarUI4FromCy(CY cyIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromCy);
}

static STDMETHODIMP VarUI4FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, ULONG *pulOut)
{
    NOTIMP(VarUI4FromStr);
}

static STDMETHODIMP VarUI4FromDisp(IDispatch *pdispIn, LCID lcid, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDisp);
}

static STDMETHODIMP VarUI4FromBool(VARIANT_BOOL boolIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromBool);
}

static STDMETHODIMP VarUI4FromI1(CHAR cIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI1);
}

static STDMETHODIMP VarUI4FromUI2(USHORT uiIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromUI2);
}

static STDMETHODIMP VarUI4FromDec(DECIMAL *pdecIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDec);
}

static STDMETHODIMP VarDecFromUI1(BYTE bIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI1);
}

static STDMETHODIMP VarDecFromI2(SHORT uiIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI2);
}

static STDMETHODIMP VarDecFromI4(LONG lIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI4);
}

static STDMETHODIMP VarDecFromR4(FLOAT fltIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromR4);
}

static STDMETHODIMP VarDecFromR8(DOUBLE dblIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromR8);
}

static STDMETHODIMP VarDecFromDate(DATE dateIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromDate);
}

static STDMETHODIMP VarDecFromCy(CY cyIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromCy);
}

static STDMETHODIMP VarDecFromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromStr);
}

static STDMETHODIMP VarDecFromDisp(IDispatch *pdispIn, LCID lcid, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromDisp);
}

static STDMETHODIMP VarDecFromBool(VARIANT_BOOL boolIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromBool);
}

static STDMETHODIMP VarDecFromI1(CHAR cIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI1);
}

static STDMETHODIMP VarDecFromUI2(USHORT uiIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI2);
}

static STDMETHODIMP VarDecFromUI4(ULONG ulIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI4);
}

static STDMETHODIMP VarParseNumFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, NUMPARSE * pnumprs, BYTE * rgbDig)
{
    NOTIMP(VarParseNumFromStr);
}

static STDMETHODIMP VarNumFromParseNum(NUMPARSE * pnumprs, BYTE * rgbDig, ULONG dwVtBits, VARIANT * pvar)
{
    NOTIMP(VarNumFromParseNum);
}

static STDMETHODIMP VarDateFromUdate(UDATE *pudateIn, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromUdate);
}

static STDMETHODIMP VarDateFromUdateEx(UDATE *pudateIn, LCID lcid, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromUdateEx);
}

static STDMETHODIMP VarUdateFromDate(DATE dateIn, ULONG dwFlags, UDATE *pudateOut)
{
    NOTIMP(VarUdateFromDate);
}

static STDMETHODIMP GetAltMonthNames(LCID lcid, LPOLESTR * * prgp)
{
    NOTIMP(GetAltMonthNames);
}

static STDMETHODIMP VarFormat(LPVARIANT pvarIn, LPOLESTR pstrFormat, int iFirstDay, int iFirstWeek, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormat);
}

static STDMETHODIMP VarFormatDateTime(LPVARIANT pvarIn, int iNamedFormat, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatDateTime);
}

static STDMETHODIMP VarFormatNumber(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatNumber);
}

static STDMETHODIMP VarFormatPercent(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatPercent);
}

static STDMETHODIMP VarFormatCurrency(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatCurrency);
}

static STDMETHODIMP VarWeekdayName(int iWeekday, int fAbbrev, int iFirstDay, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarWeekdayName);
}

static STDMETHODIMP VarMonthName(int iMonth, int fAbbrev, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarMonthName);
}

static STDMETHODIMP VarFormatFromTokens(LPVARIANT pvarIn, LPOLESTR pstrFormat, LPBYTE pbTokCur, ULONG dwFlags, BSTR *pbstrOut, LCID lcid)
{
    NOTIMP(VarFormatFromTokens);
}

static STDMETHODIMP VarTokenizeFormatString(LPOLESTR pstrFormat, LPBYTE rgbTok, int cbTok, int iFirstDay, int iFirstWeek, LCID lcid, int *pcbActual)
{
    NOTIMP(VarTokenizeFormatString);
}

static STDMETHODIMP_(ULONG) LHashValOfNameSysA(SYSKIND syskind, LCID lcid, LPCSTR szName)
{
    NOTIMP_(0, LHashValOfNameSysA);
}

static STDMETHODIMP_(ULONG) LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR * szName)
{
    NOTIMP_(0, LHashValOfNameSys);
}

static STDMETHODIMP LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib)
{
    NOTIMP(LoadTypeLib);
}

static STDMETHODIMP LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib)
{
    NOTIMP(LoadTypeLibEx);
}

static STDMETHODIMP LoadRegTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib ** pptlib)
{
    NOTIMP(LoadRegTypeLib);
}

static STDMETHODIMP QueryPathOfRegTypeLib(REFGUID guid, USHORT wMaj, USHORT wMin, LCID lcid, LPBSTR lpbstrPathName)
{
    NOTIMP(QueryPathOfRegTypeLib);
}

static STDMETHODIMP RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir)
{
    NOTIMP(RegisterTypeLib);
}

static STDMETHODIMP UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind)
{
    NOTIMP(UnRegisterTypeLib);
}

static STDMETHODIMP CreateTypeLib(SYSKIND syskind, const OLECHAR  *szFile, ICreateTypeLib ** ppctlib)
{
    NOTIMP(CreateTypeLib);
}

static STDMETHODIMP CreateTypeLib2(SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib2 **ppctlib)
{
    NOTIMP(CreateTypeLib2);
}

static STDMETHODIMP DispGetParam(DISPPARAMS * pdispparams, UINT position, VARTYPE vtTarg, VARIANT * pvarResult, UINT * puArgErr)
{
    NOTIMP(DispGetParam);
}

static STDMETHODIMP DispGetIDsOfNames(ITypeInfo * ptinfo, OLECHAR ** rgszNames, UINT cNames, DISPID * rgdispid)
{
    NOTIMP(DispGetIDsOfNames);
}

static STDMETHODIMP DispInvoke(void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags,
                        DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    NOTIMP(DispInvoke);
}

static STDMETHODIMP CreateDispTypeInfo(INTERFACEDATA * pidata, LCID lcid, ITypeInfo ** pptinfo)
{
    NOTIMP(CreateDispTypeInfo);
}

static STDMETHODIMP CreateStdDispatch(IUnknown * punkOuter, void * pvThis, ITypeInfo * ptinfo, IUnknown ** ppunkStdDisp)
{
    NOTIMP(CreateStdDispatch);
}

static STDMETHODIMP DispCallFunc(void * pvInstance, ULONG oVft, CALLCONV cc, VARTYPE vtReturn, UINT  cActuals,
                          VARTYPE * prgvt, VARIANTARG ** prgpvarg, VARIANT * pvargResult)
{
    NOTIMP(DispCallFunc);
}

static STDMETHODIMP RegisterActiveObject(IUnknown * punk, REFCLSID rclsid, DWORD dwFlags, DWORD * pdwRegister)
{
    NOTIMP(RegisterActiveObject);
}

static STDMETHODIMP RevokeActiveObject(DWORD dwRegister, void * pvReserved)
{
    NOTIMP(RevokeActiveObject);
}

static STDMETHODIMP GetActiveObject(REFCLSID rclsid, void * pvReserved, IUnknown ** ppunk)
{
    NOTIMP(GetActiveObject);
}

static STDMETHODIMP SetErrorInfo(ULONG dwReserved, IErrorInfo * perrinfo)
{
    NOTIMP(SetErrorInfo);
}

static STDMETHODIMP GetErrorInfo(ULONG dwReserved, IErrorInfo ** pperrinfo)
{
    NOTIMP(GetErrorInfo);
}

static STDMETHODIMP CreateErrorInfo(ICreateErrorInfo ** pperrinfo)
{
    NOTIMP(CreateErrorInfo);
}

static STDMETHODIMP GetRecordInfoFromTypeInfo(ITypeInfo * pTypeInfo, IRecordInfo ** ppRecInfo)
{
    NOTIMP(GetRecordInfoFromTypeInfo);
}

static STDMETHODIMP GetRecordInfoFromGuids(REFGUID rGuidTypeLib, ULONG uVerMajor, ULONG uVerMinor, LCID lcid,
                                    REFGUID rGuidTypeInfo, IRecordInfo ** ppRecInfo)
{
    NOTIMP(GetRecordInfoFromGuids);
}

static STDMETHODIMP_(ULONG) OaBuildVersion(void)
{
    NOTIMP_(0, OaBuildVersion);
}

static STDMETHODIMP_(void) ClearCustData(LPCUSTDATA pCustData)
{
    NOTIMPV(ClearCustData);
}

unsigned long __stdcall BSTR_UserSize(unsigned long  *a, unsigned long b, BSTR  *c )
{
    NOTIMP_(0, BSTR_UserSize);
}

unsigned char * __stdcall BSTR_UserMarshal(unsigned long *a, unsigned char *b, BSTR *c )
{
    NOTIMP_(NULL, BSTR_UserMarshal);
}

unsigned char * __stdcall BSTR_UserUnmarshal(unsigned long *a, unsigned char *b, BSTR *c )
{
    NOTIMP_(NULL, BSTR_UserUnmarshal);
}

void __stdcall BSTR_UserFree(unsigned long *a, BSTR *b )
{
    NOTIMPV(BSTR_UserFree);
}

unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long *a, unsigned long b, LPSAFEARRAY *c)
{
    NOTIMP_(0, LPSAFEARRAY_UserSize);
}

unsigned long __stdcall LPSAFEARRAY_Size(unsigned long *a, unsigned long b, LPSAFEARRAY *c)
{
    NOTIMP_(0, LPSAFEARRAY_Size);
}

unsigned char * __stdcall LPSAFEARRAY_UserMarshal(unsigned long *a, unsigned char *b, LPSAFEARRAY *c)
{
    NOTIMP_(NULL, LPSAFEARRAY_UserMarshal);
}

unsigned char * __stdcall LPSAFEARRAY_Marshal(unsigned long *a, unsigned char *b, LPSAFEARRAY *c)
{
    NOTIMP_(NULL, LPSAFEARRAY_Marshal);
}

unsigned char * __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long *q, unsigned char *w, LPSAFEARRAY *e)
{
    NOTIMP_(NULL, LPSAFEARRAY_UserUnmarshal);
}

unsigned char * __stdcall LPSAFEARRAY_Unmarshal(unsigned long *a, unsigned char *s, LPSAFEARRAY *d)
{
    NOTIMP_(NULL, LPSAFEARRAY_Unmarshal);
}

void __stdcall LPSAFEARRAY_UserFree(unsigned long *a, LPSAFEARRAY *x)
{
    NOTIMPV(LPSAFEARRAY_UserFree);
}

unsigned long __stdcall VARIANT_UserSize(unsigned long *a, unsigned long b, VARIANT *x)
{
    NOTIMP_(0, VARIANT_UserSize);
}

unsigned char * __stdcall VARIANT_UserMarshal(unsigned long *a, unsigned char *b, VARIANT *x)
{
    NOTIMP_(NULL, VARIANT_UserMarshal);
}

unsigned char * __stdcall VARIANT_UserUnmarshal(unsigned long *a, unsigned char *b, VARIANT *x)
{
    NOTIMP_(NULL, VARIANT_UserUnmarshal);
}

void __stdcall VARIANT_UserFree(unsigned long *a, VARIANT *x)
{
    NOTIMPV(VARIANT_UserFree);
}

static STDMETHODIMP OleTranslateColor(OLE_COLOR clr, HPALETTE hpal, COLORREF* lpcolorref)
{
    NOTIMP(OleTranslateColor);
}


static STDMETHODIMP OleCreateFontIndirect(LPFONTDESC lpFontDesc, REFIID riid, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleCreateFontIndirect);
}

static STDMETHODIMP OleCreatePictureIndirect(LPPICTDESC lpPictDesc, REFIID riid, BOOL fOwn, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleCreatePictureIndirect);
}

static STDMETHODIMP OleLoadPicture(LPSTREAM lpstream, LONG lSize, BOOL fRunmode, REFIID riid, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleLoadPicture);
}

static STDMETHODIMP_(HCURSOR) OleIconToCursor(HINSTANCE hinstExe, HICON hIcon)
{
    NOTIMP_(NULL, OleIconToCursor);
}

static STDMETHODIMP OleCreatePropertyFrame(HWND hwndOwner, UINT x, UINT y,
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages,
    LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved)
{
    NOTIMP(OleCreatePropertyFrame);
}

static STDMETHODIMP OleCreatePropertyFrameIndirect(LPOCPFIPARAMS lpParams)
{
    NOTIMP(OleCreatePropertyFrameIndirect);
}

DEFINE_ORDINAL_ENTRIES(oleaut32)
{
    DLOENTRY(  2	, SysAllocString)
    DLOENTRY(  3	, SysReAllocString)
    DLOENTRY(  4	, SysAllocStringLen)
    DLOENTRY(  5	, SysReAllocStringLen)
    DLOENTRY(  6	, SysFreeString)
    DLOENTRY(  7	, SysStringLen)
    DLOENTRY(  8	, VariantInit)
    DLOENTRY(  9	, VariantClear)
    DLOENTRY(  10	, VariantCopy)
    DLOENTRY(  11	, VariantCopyInd)
    DLOENTRY(  12	, VariantChangeType)
    DLOENTRY(  13	, VariantTimeToDosDateTime)
    DLOENTRY(  14	, DosDateTimeToVariantTime)
    DLOENTRY(  15	, SafeArrayCreate)
    DLOENTRY(  16	, SafeArrayDestroy)
    DLOENTRY(  17	, SafeArrayGetDim)
    DLOENTRY(  18	, SafeArrayGetElemsize)
    DLOENTRY(  19	, SafeArrayGetUBound)
    DLOENTRY(  20	, SafeArrayGetLBound)
    DLOENTRY(  21	, SafeArrayLock)
    DLOENTRY(  22	, SafeArrayUnlock)
    DLOENTRY(  23	, SafeArrayAccessData)
    DLOENTRY(  24	, SafeArrayUnaccessData)
    DLOENTRY(  25	, SafeArrayGetElement)
    DLOENTRY(  26	, SafeArrayPutElement)
    DLOENTRY(  27	, SafeArrayCopy)
    DLOENTRY(  28	, DispGetParam)
    DLOENTRY(  29	, DispGetIDsOfNames)
    DLOENTRY(  30	, DispInvoke)
    DLOENTRY(  31	, CreateDispTypeInfo)
    DLOENTRY(  32	, CreateStdDispatch)
    DLOENTRY(  33	, RegisterActiveObject)
    DLOENTRY(  34	, RevokeActiveObject)
    DLOENTRY(  35	, GetActiveObject)
    DLOENTRY(  36	, SafeArrayAllocDescriptor)
    DLOENTRY(  37	, SafeArrayAllocData)
    DLOENTRY(  38	, SafeArrayDestroyDescriptor)
    DLOENTRY(  39	, SafeArrayDestroyData)
    DLOENTRY(  40	, SafeArrayRedim)
    DLOENTRY(  41	, SafeArrayAllocDescriptorEx)
    DLOENTRY(  42	, SafeArrayCreateEx)
    DLOENTRY(  43	, SafeArrayCreateVectorEx)
    DLOENTRY(  44	, SafeArraySetRecordInfo)
    DLOENTRY(  45	, SafeArrayGetRecordInfo)
    DLOENTRY(  46	, VarParseNumFromStr)
    DLOENTRY(  47	, VarNumFromParseNum)
    DLOENTRY(  48	, VarI2FromUI1)
    DLOENTRY(  49	, VarI2FromI4)
    DLOENTRY(  50	, VarI2FromR4)
    DLOENTRY(  51	, VarI2FromR8)
    DLOENTRY(  52	, VarI2FromCy)
    DLOENTRY(  53	, VarI2FromDate)
    DLOENTRY(  54	, VarI2FromStr)
    DLOENTRY(  55	, VarI2FromDisp)
    DLOENTRY(  56	, VarI2FromBool)
    DLOENTRY(  57	, SafeArraySetIID)
    DLOENTRY(  58	, VarI4FromUI1)
    DLOENTRY(  59	, VarI4FromI2)
    DLOENTRY(  60	, VarI4FromR4)
    DLOENTRY(  61	, VarI4FromR8)
    DLOENTRY(  62	, VarI4FromCy)
    DLOENTRY(  63	, VarI4FromDate)
    DLOENTRY(  64	, VarI4FromStr)
    DLOENTRY(  65	, VarI4FromDisp)
    DLOENTRY(  66	, VarI4FromBool)
    DLOENTRY(  67	, SafeArrayGetIID)
    DLOENTRY(  68	, VarR4FromUI1)
    DLOENTRY(  69	, VarR4FromI2)
    DLOENTRY(  70	, VarR4FromI4)
    DLOENTRY(  71	, VarR4FromR8)
    DLOENTRY(  72	, VarR4FromCy)
    DLOENTRY(  73	, VarR4FromDate)
    DLOENTRY(  74	, VarR4FromStr)
    DLOENTRY(  75	, VarR4FromDisp)
    DLOENTRY(  76	, VarR4FromBool)
    DLOENTRY(  77	, SafeArrayGetVartype)
    DLOENTRY(  78	, VarR8FromUI1)
    DLOENTRY(  79	, VarR8FromI2)
    DLOENTRY(  80	, VarR8FromI4)
    DLOENTRY(  81	, VarR8FromR4)
    DLOENTRY(  82	, VarR8FromCy)
    DLOENTRY(  83	, VarR8FromDate)
    DLOENTRY(  84	, VarR8FromStr)
    DLOENTRY(  85	, VarR8FromDisp)
    DLOENTRY(  86	, VarR8FromBool)
    DLOENTRY(  87	, VarFormat)
    DLOENTRY(  88	, VarDateFromUI1)
    DLOENTRY(  89	, VarDateFromI2)
    DLOENTRY(  90	, VarDateFromI4)
    DLOENTRY(  91	, VarDateFromR4)
    DLOENTRY(  92	, VarDateFromR8)
    DLOENTRY(  93	, VarDateFromCy)
    DLOENTRY(  94	, VarDateFromStr)
    DLOENTRY(  95	, VarDateFromDisp)
    DLOENTRY(  96	, VarDateFromBool)
    DLOENTRY(  97	, VarFormatDateTime)
    DLOENTRY(  98	, VarCyFromUI1)
    DLOENTRY(  99	, VarCyFromI2)
    DLOENTRY(  100	, VarCyFromI4)
    DLOENTRY(  101	, VarCyFromR4)
    DLOENTRY(  102	, VarCyFromR8)
    DLOENTRY(  103	, VarCyFromDate)
    DLOENTRY(  104	, VarCyFromStr)
    DLOENTRY(  105	, VarCyFromDisp)
    DLOENTRY(  106	, VarCyFromBool)
    DLOENTRY(  107	, VarFormatNumber)
    DLOENTRY(  108	, VarBstrFromUI1)
    DLOENTRY(  109	, VarBstrFromI2)
    DLOENTRY(  110	, VarBstrFromI4)
    DLOENTRY(  111	, VarBstrFromR4)
    DLOENTRY(  112	, VarBstrFromR8)
    DLOENTRY(  113	, VarBstrFromCy)
    DLOENTRY(  114	, VarBstrFromDate)
    DLOENTRY(  115	, VarBstrFromDisp)
    DLOENTRY(  116	, VarBstrFromBool)
    DLOENTRY(  117	, VarFormatPercent)
    DLOENTRY(  118	, VarBoolFromUI1)
    DLOENTRY(  119	, VarBoolFromI2)
    DLOENTRY(  120	, VarBoolFromI4)
    DLOENTRY(  121	, VarBoolFromR4)
    DLOENTRY(  122	, VarBoolFromR8)
    DLOENTRY(  123	, VarBoolFromDate)
    DLOENTRY(  124	, VarBoolFromCy)
    DLOENTRY(  125	, VarBoolFromStr)
    DLOENTRY(  126	, VarBoolFromDisp)
    DLOENTRY(  127	, VarFormatCurrency)
    DLOENTRY(  128	, VarWeekdayName)
    DLOENTRY(  129	, VarMonthName)
    DLOENTRY(  130	, VarUI1FromI2)
    DLOENTRY(  131	, VarUI1FromI4)
    DLOENTRY(  132	, VarUI1FromR4)
    DLOENTRY(  133	, VarUI1FromR8)
    DLOENTRY(  134	, VarUI1FromCy)
    DLOENTRY(  135	, VarUI1FromDate)
    DLOENTRY(  136	, VarUI1FromStr)
    DLOENTRY(  137	, VarUI1FromDisp)
    DLOENTRY(  138	, VarUI1FromBool)
    DLOENTRY(  139	, VarFormatFromTokens)
    DLOENTRY(  140	, VarTokenizeFormatString)
    DLOENTRY(  141	, VarAdd)
    DLOENTRY(  142	, VarAnd)
    DLOENTRY(  143	, VarDiv)
    DLOENTRY(  146	, DispCallFunc)
    DLOENTRY(  147	, VariantChangeTypeEx)
    DLOENTRY(  148	, SafeArrayPtrOfIndex)
    DLOENTRY(  149	, SysStringByteLen)
    DLOENTRY(  150	, SysAllocStringByteLen)
    DLOENTRY(  152	, VarEqv)
    DLOENTRY(  153	, VarIdiv)
    DLOENTRY(  154	, VarImp)
    DLOENTRY(  155	, VarMod)
    DLOENTRY(  156	, VarMul)
    DLOENTRY(  157	, VarOr)
    DLOENTRY(  158	, VarPow)
    DLOENTRY(  159	, VarSub)
    DLOENTRY(  160	, CreateTypeLib)
    DLOENTRY(  161	, LoadTypeLib)
    DLOENTRY(  162	, LoadRegTypeLib)
    DLOENTRY(  163	, RegisterTypeLib)
    DLOENTRY(  164	, QueryPathOfRegTypeLib)
    DLOENTRY(  165	, LHashValOfNameSys)
    DLOENTRY(  166	, LHashValOfNameSysA)
    DLOENTRY(  167	, VarXor)
    DLOENTRY(  168	, VarAbs)
    DLOENTRY(  169	, VarFix)
    DLOENTRY(  170	, OaBuildVersion)
    DLOENTRY(  171	, ClearCustData)
    DLOENTRY(  172	, VarInt)
    DLOENTRY(  173	, VarNeg)
    DLOENTRY(  174	, VarNot)
    DLOENTRY(  175	, VarRound)
    DLOENTRY(  176	, VarCmp)
    DLOENTRY(  177	, VarDecAdd)
    DLOENTRY(  178	, VarDecDiv)
    DLOENTRY(  179	, VarDecMul)
    DLOENTRY(  180	, CreateTypeLib2)
    DLOENTRY(  181	, VarDecSub)
    DLOENTRY(  182	, VarDecAbs)
    DLOENTRY(  183	, LoadTypeLibEx)
    DLOENTRY(  184	, SystemTimeToVariantTime)
    DLOENTRY(  185	, VariantTimeToSystemTime)
    DLOENTRY(  186	, UnRegisterTypeLib)
    DLOENTRY(  187	, VarDecFix)
    DLOENTRY(  188	, VarDecInt)
    DLOENTRY(  189	, VarDecNeg)
    DLOENTRY(  190	, VarDecFromUI1)
    DLOENTRY(  191	, VarDecFromI2)
    DLOENTRY(  192	, VarDecFromI4)
    DLOENTRY(  193	, VarDecFromR4)
    DLOENTRY(  194	, VarDecFromR8)
    DLOENTRY(  195	, VarDecFromDate)
    DLOENTRY(  196	, VarDecFromCy)
    DLOENTRY(  197	, VarDecFromStr)
    DLOENTRY(  198	, VarDecFromDisp)
    DLOENTRY(  199	, VarDecFromBool)
    DLOENTRY(  200	, GetErrorInfo)
    DLOENTRY(  201	, SetErrorInfo)
    DLOENTRY(  202	, CreateErrorInfo)
    DLOENTRY(  203	, VarDecRound)
    DLOENTRY(  204	, VarDecCmp)
    DLOENTRY(  205	, VarI2FromI1)
    DLOENTRY(  206	, VarI2FromUI2)
    DLOENTRY(  207	, VarI2FromUI4)
    DLOENTRY(  208	, VarI2FromDec)
    DLOENTRY(  209	, VarI4FromI1)
    DLOENTRY(  210	, VarI4FromUI2)
    DLOENTRY(  211	, VarI4FromUI4)
    DLOENTRY(  212	, VarI4FromDec)
    DLOENTRY(  213	, VarR4FromI1)
    DLOENTRY(  214	, VarR4FromUI2)
    DLOENTRY(  215	, VarR4FromUI4)
    DLOENTRY(  216	, VarR4FromDec)
    DLOENTRY(  217	, VarR8FromI1)
    DLOENTRY(  218	, VarR8FromUI2)
    DLOENTRY(  219	, VarR8FromUI4)
    DLOENTRY(  220	, VarR8FromDec)
    DLOENTRY(  221	, VarDateFromI1)
    DLOENTRY(  222	, VarDateFromUI2)
    DLOENTRY(  223	, VarDateFromUI4)
    DLOENTRY(  224	, VarDateFromDec)
    DLOENTRY(  225	, VarCyFromI1)
    DLOENTRY(  226	, VarCyFromUI2)
    DLOENTRY(  227	, VarCyFromUI4)
    DLOENTRY(  228	, VarCyFromDec)
    DLOENTRY(  229	, VarBstrFromI1)
    DLOENTRY(  230	, VarBstrFromUI2)
    DLOENTRY(  231	, VarBstrFromUI4)
    DLOENTRY(  232	, VarBstrFromDec)
    DLOENTRY(  233	, VarBoolFromI1)
    DLOENTRY(  234	, VarBoolFromUI2)
    DLOENTRY(  235	, VarBoolFromUI4)
    DLOENTRY(  236	, VarBoolFromDec)
    DLOENTRY(  237	, VarUI1FromI1)
    DLOENTRY(  238	, VarUI1FromUI2)
    DLOENTRY(  239	, VarUI1FromUI4)
    DLOENTRY(  240	, VarUI1FromDec)
    DLOENTRY(  241	, VarDecFromI1)
    DLOENTRY(  242	, VarDecFromUI2)
    DLOENTRY(  243	, VarDecFromUI4)
    DLOENTRY(  244	, VarI1FromUI1)
    DLOENTRY(  245	, VarI1FromI2)
    DLOENTRY(  246	, VarI1FromI4)
    DLOENTRY(  247	, VarI1FromR4)
    DLOENTRY(  248	, VarI1FromR8)
    DLOENTRY(  249	, VarI1FromDate)
    DLOENTRY(  250	, VarI1FromCy)
    DLOENTRY(  251	, VarI1FromStr)
    DLOENTRY(  252	, VarI1FromDisp)
    DLOENTRY(  253	, VarI1FromBool)
    DLOENTRY(  254	, VarI1FromUI2)
    DLOENTRY(  255	, VarI1FromUI4)
    DLOENTRY(  256	, VarI1FromDec)
    DLOENTRY(  257	, VarUI2FromUI1)
    DLOENTRY(  258	, VarUI2FromI2)
    DLOENTRY(  259	, VarUI2FromI4)
    DLOENTRY(  260	, VarUI2FromR4)
    DLOENTRY(  261	, VarUI2FromR8)
    DLOENTRY(  262	, VarUI2FromDate)
    DLOENTRY(  263	, VarUI2FromCy)
    DLOENTRY(  264	, VarUI2FromStr)
    DLOENTRY(  265	, VarUI2FromDisp)
    DLOENTRY(  266	, VarUI2FromBool)
    DLOENTRY(  267	, VarUI2FromI1)
    DLOENTRY(  268	, VarUI2FromUI4)
    DLOENTRY(  269	, VarUI2FromDec)
    DLOENTRY(  270	, VarUI4FromUI1)
    DLOENTRY(  271	, VarUI4FromI2)
    DLOENTRY(  272	, VarUI4FromI4)
    DLOENTRY(  273	, VarUI4FromR4)
    DLOENTRY(  274	, VarUI4FromR8)
    DLOENTRY(  275	, VarUI4FromDate)
    DLOENTRY(  276	, VarUI4FromCy)
    DLOENTRY(  277	, VarUI4FromStr)
    DLOENTRY(  278	, VarUI4FromDisp)
    DLOENTRY(  279	, VarUI4FromBool)
    DLOENTRY(  280	, VarUI4FromI1)
    DLOENTRY(  281	, VarUI4FromUI2)
    DLOENTRY(  282	, VarUI4FromDec)
    DLOENTRY(  298	, VarDecCmpR8)
    DLOENTRY(  299	, VarCyAdd)
    DLOENTRY(  303	, VarCyMul)
    DLOENTRY(  304	, VarCyMulI4)
    DLOENTRY(  305	, VarCySub)
    DLOENTRY(  306	, VarCyAbs)
    DLOENTRY(  307	, VarCyFix)
    DLOENTRY(  308	, VarCyInt)
    DLOENTRY(  309	, VarCyNeg)
    DLOENTRY(  310	, VarCyRound)
    DLOENTRY(  311	, VarCyCmp)
    DLOENTRY(  312	, VarCyCmpR8)
    DLOENTRY(  313	, VarBstrCat)
    DLOENTRY(  314	, VarBstrCmp)
    DLOENTRY(  315	, VarR8Pow)
    DLOENTRY(  316	, VarR4CmpR8)
    DLOENTRY(  317	, VarR8Round)
    DLOENTRY(  318	, VarCat)
    DLOENTRY(  319	, VarDateFromUdateEx)
    DLOENTRY(  322	, GetRecordInfoFromGuids)
    DLOENTRY(  323	, GetRecordInfoFromTypeInfo)
    DLOENTRY(  329	, VarCyMulI8)
    DLOENTRY(  330	, VarDateFromUdate)
    DLOENTRY(  331	, VarUdateFromDate)
    DLOENTRY(  332	, GetAltMonthNames)
    DLOENTRY(  333	, VarI8FromUI1)
    DLOENTRY(  334	, VarI8FromI2)
    DLOENTRY(  335	, VarI8FromR4)
    DLOENTRY(  336	, VarI8FromR8)
    DLOENTRY(  337	, VarI8FromCy)
    DLOENTRY(  338	, VarI8FromDate)
    DLOENTRY(  339	, VarI8FromStr)
    DLOENTRY(  340	, VarI8FromDisp)
    DLOENTRY(  341	, VarI8FromBool)
    DLOENTRY(  342	, VarI8FromI1)
    DLOENTRY(  343	, VarI8FromUI2)
    DLOENTRY(  344	, VarI8FromUI4)
    DLOENTRY(  345	, VarI8FromDec)
    DLOENTRY(  346	, VarI2FromI8)
    DLOENTRY(  347	, VarI2FromUI8)
    DLOENTRY(  348	, VarI4FromI8)
    DLOENTRY(  349	, VarI4FromUI8)
    DLOENTRY(  360	, VarR4FromI8)
    DLOENTRY(  361	, VarR4FromUI8)
    DLOENTRY(  362	, VarR8FromI8)
    DLOENTRY(  363	, VarR8FromUI8)
    DLOENTRY(  364	, VarDateFromI8)
    DLOENTRY(  365	, VarDateFromUI8)
    DLOENTRY(  366	, VarCyFromI8)
    DLOENTRY(  367	, VarCyFromUI8)
    DLOENTRY(  368	, VarBstrFromI8)
    DLOENTRY(  369	, VarBstrFromUI8)
    DLOENTRY(  370	, VarBoolFromI8)
    DLOENTRY(  371	, VarBoolFromUI8)
    DLOENTRY(  372	, VarUI1FromI8)
    DLOENTRY(  373	, VarUI1FromUI8)
    DLOENTRY(  374	, VarDecFromI8)
    DLOENTRY(  375	, VarDecFromUI8)
    DLOENTRY(  376	, VarI1FromI8)
    DLOENTRY(  377	, VarI1FromUI8)
    DLOENTRY(  378	, VarUI2FromI8)
    DLOENTRY(  379	, VarUI2FromUI8)
    DLOENTRY(  401	, OleLoadPictureEx)
    DLOENTRY(  402	, OleLoadPictureFileEx)
    DLOENTRY(  411	, SafeArrayCreateVector)
    DLOENTRY(  412	, SafeArrayCopyData)
    DLOENTRY(  413	, VectorFromBstr)
    DLOENTRY(  414	, BstrFromVector)
    DLOENTRY(  415	, OleIconToCursor)
    DLOENTRY(  416	, OleCreatePropertyFrameIndirect)
    DLOENTRY(  417	, OleCreatePropertyFrame)
    DLOENTRY(  418	, OleLoadPicture)
    DLOENTRY(  419	, OleCreatePictureIndirect)
    DLOENTRY(  420	, OleCreateFontIndirect)
    DLOENTRY(  421	, OleTranslateColor)
    DLOENTRY(  422	, OleLoadPictureFile)
    DLOENTRY(  423	, OleSavePictureFile)
    DLOENTRY(  424	, OleLoadPicturePath)
    DLOENTRY(  425	, VarUI4FromI8)
    DLOENTRY(  426	, VarUI4FromUI8)
    DLOENTRY(  427	, VarI8FromUI8)
    DLOENTRY(  428	, VarUI8FromI8)
    DLOENTRY(  429	, VarUI8FromUI1)
    DLOENTRY(  430	, VarUI8FromI2)
    DLOENTRY(  431	, VarUI8FromR4)
    DLOENTRY(  432	, VarUI8FromR8)
    DLOENTRY(  433	, VarUI8FromCy)
    DLOENTRY(  434	, VarUI8FromDate)
    DLOENTRY(  435	, VarUI8FromStr)
    DLOENTRY(  436	, VarUI8FromDisp)
    DLOENTRY(  437	, VarUI8FromBool)
    DLOENTRY(  438	, VarUI8FromI1)
    DLOENTRY(  439	, VarUI8FromUI2)
    DLOENTRY(  441	, VarUI8FromDec)

};

DEFINE_ORDINAL_MAP(oleaut32);

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\shell32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _SHELL32_
#include <shellapi.h>
#include <shlobj.h>

static
WINSHELLAPI
HICON
WINAPI
ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	return 0;
}

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExW (
    LPCWSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
int
WINAPI
RestartDialog (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn
    )
{
    return IDNO;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderW (
    LPBROWSEINFOW lpbi
    )
{
    return NULL;
}

static
void
STDAPICALLTYPE
SHChangeNotify(
    LONG wEventId,
    UINT uFlags,
    LPCVOID dwItem1,
    LPCVOID dwItem2)
{
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathA (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathW (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetMalloc (
    LPMALLOC * ppMalloc
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListW (
    LPCITEMIDLIST   pidl,
    LPWSTR          pszPath
    )
{
    return FALSE;
}

static
HRESULT
STDAPICALLTYPE
SHGetSpecialFolderLocation (
    HWND hwnd,
    int csidl,
    LPITEMIDLIST *ppidl
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetSpecialFolderPathW(
    HWND hwnd,
    LPWSTR pszPath,
    int csidl,
    BOOL fCreate)
{
    return FALSE;
}

static
LPITEMIDLIST 
SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    return NULL;
}

static
WINSHELLAPI
INT
WINAPI
ShellAboutW(
    HWND hwnd,
    LPCWSTR szApp,
    LPCWSTR szOtherStuff,
    HICON hIcon
    )
{
    return FALSE;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteA (
    HWND hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteW (
    HWND hwnd,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shell32)
{
//     DLOENTRY(59, RestartDialog)
    DLOENTRY(162, SHSimpleIDListFromPath)
};

DEFINE_ORDINAL_MAP(shell32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shell32)
{
    DLPENTRY(ExtractAssociatedIconW)
//     DLPENTRY(ExtractIconExW)
//     DLPENTRY(SHBrowseForFolderW)
//     DLPENTRY(SHChangeNotify)
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
//     DLPENTRY(SHGetMalloc)
//     DLPENTRY(SHGetPathFromIDListW)
//     DLPENTRY(SHGetSpecialFolderLocation)
//     DLPENTRY(SHGetSpecialFolderPathW)
//     DLPENTRY(ShellAboutW)
//     DLPENTRY(ShellExecuteExW)
    DLPENTRY(ShellExecuteA)
    DLPENTRY(ShellExecuteW)
};

DEFINE_PROCNAME_MAP(shell32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\pch.h ===
#pragma once

#ifdef DLOAD1

// to avoid import declarations
#define _COMCTL32_ 
#define _SHELL32_
#define _OLEAUT32_

#include <dloadexcept.h>
#include "dload.h"

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\urlmon.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <urlmon.h>

static
HRESULT WINAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv)
{
    return E_FAIL;
}
            
static 
HRESULT WINAPI CoInternetCombineUrl(             
    LPCWSTR     pwzBaseUrl,              
    LPCWSTR     pwzRelativeUrl,          
    DWORD       dwCombineFlags,          
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    )
{
    return E_FAIL;
}
    
static 
HRESULT WINAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved)
{
    return E_FAIL;
}

static 
HRESULT WINAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI CoInternetGetSession(DWORD dwSessionMode,
                                    IInternetSession **ppIInternetSession,
                                    DWORD dwReserved)
{
    *ppIInternetSession = NULL;
    return E_OUTOFMEMORY;
}

static HRESULT WINAPI CoInternetParseUrl(               
    LPCWSTR     pwzUrl,                  
    PARSEACTION ParseAction,             
    DWORD       dwFlags,                 
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    )
{
    return E_FAIL;
}
    
static HRESULT WINAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    LPVOID      pvBuffer,                
    DWORD       cbBuffer,                
    DWORD      *pcbBuffer,               
    DWORD       dwReserved               
    )                                  
{
    return E_FAIL;
}

static HRESULT WINAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC)
{
    return E_FAIL;
}

static HRESULT WINAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI CreateURLMoniker(LPMONIKER pMkCtx,
                                LPCWSTR szURL,
                                LPMONIKER FAR * ppmk)
{
    *ppmk = NULL;
    return E_OUTOFMEMORY;
}

static 
HRESULT WINAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags)
{
    return E_FAIL;
}

static HRESULT WINAPI FaultInIEFeature( HWND hWnd,
            uCLSSPEC *pClassSpec,
            QUERYCONTEXT *pQuery, DWORD dwFlags)
{
    return E_FAIL;
}

static HRESULT WINAPI FindMimeFromData(                                       
                        LPBC pBC,                              
                        LPCWSTR pwzUrl,                        
                        LPVOID pBuffer,                       
                        DWORD cbSize,                          
                        LPCWSTR pwzMimeProposed,               
                        DWORD dwMimeFlags,                     
                        LPWSTR *ppwzMimeOut,                   
                        DWORD dwReserved)                      
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid)
{
    return E_FAIL;
}


static
HRESULT WINAPI HlinkNavigateString(IUnknown *pUnk,
                                   LPCWSTR szTarget)
{
    return E_FAIL;
}

static 
HRESULT WINAPI IsAsyncMoniker(IMoniker* pmk)
{
    return E_FAIL;
}

static 
HRESULT WINAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk)
{
    return E_FAIL;
}

static 
HRESULT WINAPI ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize)
{
    return E_FAIL;
}


static
HRESULT WINAPI RegisterBindStatusCallback(LPBC pBC,
                                          IBindStatusCallback *pBSCb,
                                          IBindStatusCallback** ppBSCBPrev,
                                          DWORD dwReserved)
{
    return E_OUTOFMEMORY;
}

static 
void WINAPI ReleaseBindInfo( BINDINFO * pbindinfo )
{
}


static
HRESULT WINAPI RevokeBindStatusCallback(LPBC pBC,
                                        IBindStatusCallback *pBSCb)
{
    return E_FAIL;
}

static 
HRESULT WINAPI URLOpenBlockingStreamW(LPUNKNOWN a,LPCWSTR b,LPSTREAM* c,DWORD d,LPBINDSTATUSCALLBACK e)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(urlmon)
{
    DLPENTRY(CoGetClassObjectFromURL)
    DLPENTRY(CoInternetCombineUrl)
    DLPENTRY(CoInternetCreateSecurityManager)
    DLPENTRY(CoInternetCreateZoneManager)
    DLPENTRY(CoInternetGetSession)
    DLPENTRY(CoInternetParseUrl)
    DLPENTRY(CoInternetQueryInfo)
    DLPENTRY(CreateAsyncBindCtx)
    DLPENTRY(CreateAsyncBindCtxEx)
    DLPENTRY(CreateURLMoniker)
    DLPENTRY(CreateURLMonikerEx)
    DLPENTRY(FaultInIEFeature)
    DLPENTRY(FindMimeFromData)
    DLPENTRY(GetClassFileOrMime)
    DLPENTRY(HlinkNavigateString)
    DLPENTRY(IsAsyncMoniker)
    DLPENTRY(MkParseDisplayNameEx)
    DLPENTRY(ObtainUserAgentString)
    DLPENTRY(RegisterBindStatusCallback)
    DLPENTRY(ReleaseBindInfo)
    DLPENTRY(RevokeBindStatusCallback)
    DLPENTRY(URLOpenBlockingStreamW)
};

DEFINE_PROCNAME_MAP(urlmon)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\wininet.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _WINX32_
#include <wininet.h>

static
BOOLAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )
{
    return FALSE;
}


static
BOOLAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    return FALSE;
}


static
BOOLAPI
CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    return FALSE;
}

static
BOOLAPI
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetAlgIdToStringW(
    IN ALG_ID                         ai,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    return FALSE;
}


static
BOOLAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    return FALSE;
}

static
INTERNETAPI
DWORD
WINAPI
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    return E_FAIL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetCrackUrlW(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )
{
    return FALSE;
}

static
INTERNETAPI
DWORD
WINAPI
InternetErrorDlg(IN HWND hWnd,
                 IN OUT HINTERNET hRequest,
                 IN DWORD dwError,
                 IN DWORD dwFlags,
                 IN OUT LPVOID *lppvData
                 )
{
    return E_FAIL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetGetCertByURL(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved)
{
    return FALSE;
}

static
INTERNETAPI 
BOOL 
WINAPI
InternetGetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPWSTR   lpszCookieData,
    LPDWORD lpdwSize
    )
{
    return FALSE;
}

static
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    return FALSE;
}

static
BOOLAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    *lpdwNumberOfBytesRead = 0;
    return FALSE;
}

static
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}


static
INTERNETAPI
BOOL
WINAPI
InternetSecurityProtocolToStringW(
    IN DWORD                          dwProtocol,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetShowSecurityInfoByURLW(
    IN       LPWSTR    lpszURL,
    IN       HWND     hwndParent
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetUnlockRequestFile(
    IN HANDLE hLockHandle
    )
{
    return FALSE;
}

static
BOOLAPI
IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    return FALSE;
}

static
BOOLAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    return FALSE;
}

static
BOOLAPI
UnlockUrlCacheEntryFileA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wininet)
{
    DLPENTRY(CommitUrlCacheEntryA)
    DLPENTRY(CommitUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheEntryA)
    DLPENTRY(CreateUrlCacheEntryW)
    DLPENTRY(DeleteUrlCacheEntryA)
    DLPENTRY(HttpQueryInfoW)
    DLPENTRY(InternetAlgIdToStringW)
    DLPENTRY(InternetCanonicalizeUrlW)
    DLPENTRY(InternetCloseHandle)
    DLPENTRY(InternetConfirmZoneCrossingW)
    DLPENTRY(InternetCrackUrlW)
    DLPENTRY(InternetErrorDlg)
    DLPENTRY(InternetGetCertByURL)
    DLPENTRY(InternetGetConnectedState)
    DLPENTRY(InternetGetCookieW)
    DLPENTRY(InternetOpenUrlW)
    DLPENTRY(InternetOpenW)
    DLPENTRY(InternetQueryOptionA)
    DLPENTRY(InternetReadFile)
    DLPENTRY(InternetSecurityProtocolToStringW)
    DLPENTRY(InternetSetCookieW)
    DLPENTRY(InternetSetOptionW)
    DLPENTRY(InternetShowSecurityInfoByURLW)
    DLPENTRY(InternetTimeToSystemTimeW)
    DLPENTRY(InternetUnlockRequestFile)
    DLPENTRY(IsUrlCacheEntryExpiredW)
    DLPENTRY(RetrieveUrlCacheEntryFileA)
    DLPENTRY(SetUrlCacheEntryInfoA)
    DLPENTRY(UnlockUrlCacheEntryFileA)

};

DEFINE_PROCNAME_MAP(wininet)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\afxres.h ===
#include <windows.h>
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\usp10.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <usp10.h>


static
HRESULT WINAPI ScriptStringAnalyse(
    HDC                      hdc,       
    const void              *pString,   
    int                      cString,   
    int                      cGlyphs,   
    int                      iCharset,  
    DWORD                    dwFlags,   
    int                      iReqWidth, 
    SCRIPT_CONTROL          *psControl, 
    SCRIPT_STATE            *psState,   
    const int               *piDx,      
    SCRIPT_TABDEF           *pTabdef,   
    const BYTE              *pbInClass, 

    SCRIPT_STRING_ANALYSIS  *pssa)
{
    return E_FAIL;
}

static
HRESULT WINAPI ScriptTextOut(
    const HDC               hdc,        
    SCRIPT_CACHE           *psc,        
    int                     x,          
    int                     y,          
    UINT                    fuOptions,  
    const RECT             *lprc,       
    const SCRIPT_ANALYSIS  *psa,        
    const WCHAR            *pwcReserved,
    int                     iReserved,  
    const WORD             *pwGlyphs,   
    int                     cGlyphs,    
    const int              *piAdvance,  
    const int              *piJustify,  
    const GOFFSET          *pGoffset)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptFreeCache(
    SCRIPT_CACHE   *psc)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptStringOut(
    SCRIPT_STRING_ANALYSIS ssa,         
    int              iX,                
    int              iY,                
    UINT             uOptions,          
    const RECT      *prc,               
    int              iMinSel,           
    int              iMaxSel,           
    BOOL             fDisabled)
{
    return E_FAIL;
}


static
const SIZE* WINAPI ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptStringFree(
    SCRIPT_STRING_ANALYSIS *pssa)
{
    return E_FAIL;
}


static
const int* WINAPI ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptBreak(
    const WCHAR            *pwcChars,  
    int                     cChars,    
    const SCRIPT_ANALYSIS  *psa,       
    SCRIPT_LOGATTR         *psla)
{
    return E_FAIL;
}


static
const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptItemize(
    const WCHAR           *pwcInChars,  
    int                    cInChars,    
    int                    cMaxItems,   
    const SCRIPT_CONTROL  *psControl,   
    const SCRIPT_STATE    *psState,     
    SCRIPT_ITEM           *pItems,      
    int                   *pcItems)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptGetProperties(
    const SCRIPT_PROPERTIES ***ppSp,             
    int                       *piNumScripts)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptShape(
    HDC                 hdc,            
    SCRIPT_CACHE       *psc,            
    const WCHAR        *pwcChars,       
    int                 cChars,         
    int                 cMaxGlyphs,     
    SCRIPT_ANALYSIS    *psa,            
    WORD               *pwOutGlyphs,    
    WORD               *pwLogClust,     
    SCRIPT_VISATTR     *psva,           
    int                *pcGlyphs)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptPlace(
    HDC                     hdc,        
    SCRIPT_CACHE           *psc,        
    const WORD             *pwGlyphs,   
    int                     cGlyphs,    
    const SCRIPT_VISATTR   *psva,       
    SCRIPT_ANALYSIS        *psa,        
    int                    *piAdvance,  
    GOFFSET                *pGoffset,   
    ABC                    *pABC)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptGetFontProperties(
    HDC                     hdc,    
    SCRIPT_CACHE           *psc,    
    SCRIPT_FONTPROPERTIES  *sfp)
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(usp10)
{
    DLPENTRY(ScriptBreak)
    DLPENTRY(ScriptFreeCache)
    DLPENTRY(ScriptGetFontProperties)
    DLPENTRY(ScriptGetProperties)
    DLPENTRY(ScriptItemize)
    DLPENTRY(ScriptPlace)
    DLPENTRY(ScriptShape)
    DLPENTRY(ScriptStringAnalyse)
    DLPENTRY(ScriptStringFree)
    DLPENTRY(ScriptStringOut)
    DLPENTRY(ScriptString_pLogAttr)
    DLPENTRY(ScriptString_pSize)
    DLPENTRY(ScriptString_pcOutChars)
    DLPENTRY(ScriptTextOut)
};

DEFINE_PROCNAME_MAP(usp10)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from forms directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include <padhead.hxx>

MtDefine(CEnumGenericPad, Pad, "CEnumGeneric")
MtDefine(CEnumVARIANTPad, Pad, "CEnumVARIANT")

//  TODO: reconcile with CEnumXX in stdenum.cxx


// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(paryCopy->Copy(_cb, *pary, _fAddRef));
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    IncrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    IncrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    IUnknown ** ppUnk;
    int         i;

    if (_pary && _fDelete)
    {
        if (_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < _pary->Size();
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DecrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//----------------------------------------------------------------------------

class CEnumGeneric : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumGenericPad))
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    //  CEnumGeneric methods
    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            REFIID          iid,
            BOOL            fAddRef,
            BOOL            fCopy,
            BOOL            fDelete,
            CEnumGeneric ** ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CImplAry *      pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    Assert(pary);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef));
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    Assert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **) ppv);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

class CEnumVARIANT : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumVARIANTPad))
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            VARTYPE         vt,
            BOOL            fCopy,
            BOOL            fDelete,
            IEnumVARIANT ** ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     _vt;                    // type of element enumerated
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CImplAry *      pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    Assert(pary);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!ppenum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == _cb);
            hr = THR((*(IUnknown **) pb)->QueryInterface(
                    IID_IDispatch, (void **) &V_DISPATCH(pvar)));
            if (hr)
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ((IDispatch **) reelt)[j]->Release();
                }

                RRETURN(hr);
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum));
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    Assert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\dload\uxtheme.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _UXTHEME_
#include <uxtheme.h>

static 
HRESULT WINAPI CloseThemeData(HTHEME hTheme)
{
    return E_FAIL;
}

static 
HRESULT WINAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect)
{
    return E_FAIL;
}

static
HRESULT WINAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, 
    OUT RECT *pExtentRect)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemeColor(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT COLORREF *pColor)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemeFont(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LOGFONT *pFont)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemePartSize(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, enum THEMESIZE eSize, OUT SIZE *psz)
{
    return E_FAIL;
}

static 
HRESULT WINAPI HitTestThemeBackground(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, DWORD dwOptions, const RECT *pRect, OPTIONAL HRGN hrgn, 
    POINT ptTest, OUT WORD *pwHitTestCode)
{
    return E_FAIL;
}

static 
BOOL WINAPI IsAppThemed()
{
    return E_FAIL;
}

static 
HTHEME WINAPI OpenThemeData(HWND hwnd, LPCWSTR pszClassList)
{
    return E_FAIL;
}

static 
HRESULT WINAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList)
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(uxtheme)
{
    DLPENTRY(CloseThemeData)
    DLPENTRY(DrawThemeBackground)
    DLPENTRY(GetThemeBackgroundExtent)
    DLPENTRY(GetThemeColor)
    DLPENTRY(GetThemeFont)
    DLPENTRY(GetThemePartSize)
    DLPENTRY(HitTestThemeBackground)
    DLPENTRY(IsAppThemed)
    DLPENTRY(OpenThemeData)
    DLPENTRY(SetWindowTheme)
};

DEFINE_PROCNAME_MAP(uxtheme)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\chsfld.cpp ===
////////////////////////////////////////////////////////////////////////////
//
//      CHSFLD.CPP
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
///////////////////////////////////////////////////////////////////////


#include <padhead.hxx>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>
#endif

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_TVDLG_H_
#define X_TVDLG_H_
#include "tvdlg.h"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

#ifndef X_TVSTACK_H_
#define X_TVSTACK_H_
#include "tvstack.h"
#endif

#define cImageHeight    16
#define cImageWidth     16
#define cImages         4

//globals
LPSTR g_szAllStoresA = "All Message Stores";
LPTSTR g_szModuleName = TEXT("Choose Folder Dialog");

//functions used only in this file
INT_PTR CALLBACK
ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPTSTR * pszNewName);

INT_PTR CALLBACK
NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


//
//  HrPickFolder
//
//  
STDAPI
HrPickFolder(HINSTANCE hInst, HWND hWnd, LPMAPISESSION pses, LPMAPIFOLDER * ppfld,
                LPMDB *ppmdb, ULONG * pcb, LPBYTE * ppb)
{
    HRESULT hr;
    
    Assert(hInst);
    
    if((hWnd && !IsWindow(hWnd)) || (!pses) || (!ppfld) || (!ppmdb))
    { 
        //DebugTraceResult(HrPickFolder, E_INVALIDARG);
        return E_INVALIDARG;
    }

    if(pcb && IsBadWritePtr(pcb, sizeof(ULONG)))
    {
        //DebugTraceArg(HrPickFolder, "pcb not writable");
        return E_INVALIDARG;
    }

    if(pcb && (*pcb & 0x3))
    {
        //DebugTraceArg(HrPickFolder, "pcb not multiple of 4");
        return E_INVALIDARG;
    }
    
    if(ppb && IsBadWritePtr(ppb, sizeof(LPBYTE)))
    {
        //DebugTraceArg(HrPickFolder, "ppb not writable");
        return E_INVALIDARG;
    }

    if(ppb && pcb && IsBadWritePtr(*ppb, *pcb))
    {
        //DebugTraceArg(HrPickFolder, "*pcb or *ppb");
        return E_INVALIDARG;
    }

    //////////////////////////////////////////////////////////////////////
    // if you incorporate this code into you app, remove this and pass in
    // the right hInst
    // Start remove
    //hInst = GetModuleHandle("chsfld32.dll");
    //if(!hInst)
    // {
    //    DebugTrace("GetModuleHandel failed\n");
    //    DebugTraceResult(HrPickFolder, E_FAIL);
    //    return E_FAIL;
    //}
    // End remove
    ///////////////////////////////////////////////////////////////////////

    //ULONG cb = 0;
    //LPBYTE pb = NULL;
    
    CChsFldDlg PickDlg(pses, hInst, pcb, ppb);

    InitCommonControls();

    hr = PickDlg.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd,
                        ChsFldDlgProc, ppfld, ppmdb);

/*  if(SUCCEEDED(hr))
    {
        (*ppfld)->Release();
        (*ppmdb)->Release();
    }
    
    CChsFldDlg PickDlg1(pses, hInst, pcb, ppb);

    hr = PickDlg1.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd,
                        ChsFldDlgProc, ppfld, ppmdb);*/

//  if(!hr)
    //  MAPIFreeBuffer(pb);
        
    //DebugTraceResult(HrPickFolder, hr);
    return hr;
}


//
//  CChsFldDlg::CChsFldDlg
//
inline
CChsFldDlg::CChsFldDlg(LPMAPISESSION pses, HINSTANCE hInst, ULONG * pcb,
                        LPBYTE * ppb)
{
    Assert(pses);
    Assert(hInst);
    
    _pses = pses;
    pses->AddRef();

    _hr = hrSuccess;
    _pfld = NULL;
    _pmdb = NULL;
    _hiRoot = NULL;
    _hInst = hInst;
    _hIml = NULL;
    _hDlg = NULL;
    _hwTreeCtl = NULL;
    _pcbState = pcb;
    _ppbState = ppb;
}       

//
//  CChsFldDlg::~CChsFldDlg
//
CChsFldDlg::~CChsFldDlg()
{
    ReleaseInterface(_pses);
    ReleaseInterface(_pfld);
    ReleaseInterface(_pmdb);

    if(_hIml)
        ImageList_Destroy(_hIml);
}


//
//  CChsFldDlg::SetFolder
//
//  Store the folder chosen by the user
//
inline void CChsFldDlg::SetFolder(LPMAPIFOLDER pfld, LPMDB pmdb)
{
    ReleaseInterface(_pfld);

    _pfld = pfld;
    
    if(pfld)
        pfld->AddRef();

    ReleaseInterface(_pmdb);

    _pmdb = pmdb;
    if(pmdb)
        pmdb->AddRef();
}


//
//  CChsFldDlg::HrPick
//
// The outmost method.
//
HRESULT CChsFldDlg::HrPick(LPCTSTR lpTemplateName, HWND hWnd,
                DLGPROC pfnDlgProc, LPMAPIFOLDER * ppfld, LPMDB *ppmdb)
{
    if(-1 == DialogBoxParam(_hInst, lpTemplateName, hWnd, pfnDlgProc, (LPARAM) this))
    {
        //DebugTraceSc(CChsDldDlg::HrPick, MAPI_E_NOT_ENOUGH_MEMORY);
        return MAPI_E_NOT_ENOUGH_MEMORY;
    }

    //_hr is set inside the dialog
    if(HR_SUCCEEDED(_hr))
    {
        Assert(_pfld);
        _pfld->AddRef();
        *ppfld = _pfld;

        Assert(_pmdb);
        _pmdb->AddRef();
        *ppmdb = _pmdb;
    }

    return _hr;
}

//
//  CChsFldDlg::HrInitTree
//
// Called from WM_INITDIALOG. Opens all message stores in the profile and
// puts the IPM subtrees in the tree control
//
HRESULT CChsFldDlg::HrInitTree(HWND hDlg, HWND hwTreeCtl)
{
    HRESULT     hr;
    LPSPropValue pval = NULL;
    LPTVNODE    pNode = NULL;
    HTREEITEM   hiRoot = NULL;
    HICON       hIcon = NULL;
    
    Assert(hDlg);
    Assert(hwTreeCtl);

    _hwTreeCtl = hwTreeCtl;
    _hDlg      = hDlg;
    

    //
    // Set up the image list
    //
    _hIml = ImageList_Create(cImageWidth, cImageHeight, ILC_MASK, 
                            cImages, 0);
    if(!_hIml)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }

    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_ALLSTORES));
    _iIconAllStores = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_ROOTFLD));
    _iIconRootFld = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_OPENFLD));
    _iIconOpenFld = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_CLSDFLD));
    _iIconClsdFld = ImageList_AddIcon(_hIml, hIcon);

    if(ImageList_GetImageCount(_hIml) < cImages)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }


    TreeView_SetImageList(hwTreeCtl, _hIml, TVSIL_NORMAL);
    
    //
    // create the root tree node
    // (fake a GetProps)
    //
    hr = MAPIAllocateBuffer(nhtProps * sizeof(SPropValue),
                        (LPVOID *)&pval);
    if(hr)
    {
        g_LastError.SetLastError(hr);
        g_LastError.ShowError(hDlg);
            
        goto err;
    }
    

    ZeroMemory(pval, nhtProps * sizeof(SPropValue));

    //Set  proptags to make CNode constructor happy
    pval[iEID].ulPropTag = PR_ENTRYID;
    pval[iDispName].ulPropTag = PR_DISPLAY_NAME_A;
    pval[iDispName].Value.lpszA = g_szAllStoresA;
    pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;

    hr = HrCreateNode(pval, nhtProps, NULL, &pNode);
    if(hr)
        goto err;

    Assert(pNode);
    
    pval = NULL; //will be freed in ~CTVNode

    hiRoot = AddOneItem(NULL, TVI_ROOT, _iIconAllStores, _iIconAllStores,
                            hwTreeCtl, pNode, 1);
    if(!hiRoot)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }
    
    pNode->SetKidsLoaded(TRUE);
    
    _hiRoot = hiRoot;
    
    //
    //  Put the IPM subtrees of all the message stores in
    //
    hr = HrLoadRoots();
    if(HR_FAILED(hr))
        goto err;

    (void)HrRestoreTreeState();
        
err:
    MAPIFreeBuffer(pval);

    //DebugTraceResult(CChsFldDlg::HrInitTree, hr);
    return hr;
}


//
//  CChsFldDlg::HrLoadRoots
//
HRESULT CChsFldDlg::HrLoadRoots(void)
{
    HRESULT hr;
    LPMAPITABLE ptblMStrs = NULL;
    UINT ind;
    LPSRowSet pRows = NULL;
    static SSortOrderSet sosName;

    sosName.cSorts = 1;
    sosName.cCategories = 0;
    sosName.cExpanded = 0;
    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME_A;
    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND;

        
    //Get Message Store Table
    hr = _pses->GetMsgStoresTable(0, &ptblMStrs);
    if(hr)
    {
        g_LastError.SetLastError(hr, _pses);
        g_LastError.ShowError(_hDlg);

        goto err;
    }

    //For each msg store insert a node corresponding to PR_IPM_SUBTREE

    hr = HrQueryAllRows(ptblMStrs, (LPSPropTagArray) &spthtProps, NULL,
                        &sosName, 0, &pRows);
                        
    if(HR_FAILED(hr))
        goto err;

    if(0 ==  pRows->cRows)  //$ No stores
    {
        MessageBox(_hDlg,
                    TEXT("No message stores in the profile"),
                    g_szModuleName,
                    MB_OK);
        hr = E_FAIL;
    }
    
    for(ind = 0; ind < pRows->cRows; ++ind)
    {
        LPSPropValue pval = pRows->aRow[ind].lpProps;
        Assert(pRows->aRow[ind].cValues == nhtProps);
        Assert(pval[iEID].ulPropTag == PR_ENTRYID);

        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;
        pval[iSubfldrs].Value.b = TRUE;

        //pval is consumed by this function
        hr = HrInsertRoot(pval);
        pRows->aRow[ind].cValues = 0;
        pRows->aRow[ind].lpProps = NULL;
        if(FAILED(hr))
            goto err;
        
    }

    
        
err:
    FreeProws(pRows);
    ReleaseInterface(ptblMStrs);

    //DebugTraceResult(CChsFldDlg::HrLoadRoots, hr);
    return hr;
}

//
//  CChsFldDlg::HrInsertRoot
//
// Put the IPM subtree of the msg store in the tree control
//  pval is consumed
//
HRESULT CChsFldDlg::HrInsertRoot(LPSPropValue pval)
{
    HRESULT hr;
    HTREEITEM hItem;


    Assert(_hiRoot);
    
    
    LPTVNODE pNode = NULL;
    hr = HrCreateNode(pval, nhtProps, NULL, &pNode);
    if(hr)
    {
        MAPIFreeBuffer(pval);
        goto err;
    }

    Assert(pNode);
    pval = NULL;

        
    hItem = AddOneItem(_hiRoot, TVI_LAST, _iIconRootFld, _iIconRootFld,
                            _hwTreeCtl, pNode, 1);
    if(!hItem)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }
            
        
err:

    //DebugTraceResult(CChsFldDlg::HrInsertRoots, hr);
    return hr;
}


//
//  CChsFldDlg::HrSaveTreeState
//
// Save expand - collapse state of the tree control
//
HRESULT CChsFldDlg::HrSaveTreeState(void)
{
    HRESULT hr;

    if(!_pcbState || !_ppbState)
        return hrSuccess;

    MAPIFreeBuffer(*_ppbState);
    *_ppbState = NULL;
    *_pcbState = 0;
    
    hr = HrSaveTreeStateEx(FALSE, _pcbState, NULL);
    if(hr)
        goto err;

    //DebugTrace("ChsFld: size of state data: %ld\n", *_pcbState);
    
    hr = HrSaveTreeStateEx(TRUE, _pcbState, _ppbState);
    
err:
    //DebugTraceResult(CChsFldDlg::HrSaveTreeState, hr);
    return hr;
}

//
//  CChsFldDlg::HrSaveTreeStateEx
//
// Save expand - collapse state of the tree control
//
HRESULT CChsFldDlg::HrSaveTreeStateEx(BOOL fWrite, ULONG * pcb, LPBYTE * ppb)
{
    HRESULT hr = hrSuccess;
    CTIStack tiStack;
    HTREEITEM hti;
    LPBYTE pb = NULL;
    LPBYTE pBuffer = NULL;
    LONG iLevel;

    if(fWrite)
    {
        if(*pcb == 0)
        {
            *ppb = NULL;
            return hrSuccess;
        }
        else
        {
            hr = MAPIAllocateBuffer(*pcb, (LPVOID *) &pBuffer);
            if (hr)
            {
                *pcb = 0;
                return hr;
            }
            pb = pBuffer;
        }
    }

    hti = TreeView_GetRoot(_hwTreeCtl);
    iLevel = 0;
    tiStack.Push(NULL);

    while(hti)
    {
        Assert(iLevel >= 0);
        
        while(hti)
        {
            TV_ITEM tvi;
            
            tvi.hItem = hti;
            tvi.mask = TVIF_STATE | TVIF_PARAM;
            tvi.lParam = 0;
            tvi.state = 0;
            tvi.stateMask = TVIS_EXPANDED;

            if(!TreeView_GetItem(_hwTreeCtl, &tvi))
            {
                hr = E_FAIL;
                goto err;
            }

            if(tvi.state & TVIS_EXPANDED)
            {
                HTREEITEM htiChild = TreeView_GetChild(_hwTreeCtl, hti);

                if(htiChild)
                {
                    LPTVNODE pNode = (LPTVNODE) tvi.lParam;
                    Assert(pNode);

                    pNode->Write(fWrite, iLevel, &pb);

                    HTREEITEM htiNextSibl = TreeView_GetNextSibling(_hwTreeCtl, hti);

                    tiStack.Push(htiNextSibl);

                    hti = htiChild;
                    ++iLevel;

                    continue;
                }

            }

            hti = TreeView_GetNextSibling(_hwTreeCtl, hti);
        }

        do
        {
            hti = tiStack.Pop();
            --iLevel;
            
        }while(!tiStack.IsEmpty() && hti == NULL);
    }

    Assert(iLevel == -1);

    *pcb = pb - pBuffer;
    if(pBuffer)
        *ppb = pBuffer;
    
err:
    //DebugTraceResult(CChsFldDlg::HrSaveTreeStateEx, hr);
    return hr;
}

inline LONG GetLevel(LPBYTE * ppb)
{
    LONG level = *((LONG *) *ppb);

    *ppb += sizeof(LONG);

    return level;
}

inline ULONG GetCb(LPBYTE * ppb)
{
    ULONG cb = *((ULONG *) *ppb);

    *ppb += sizeof(ULONG);

    return cb;
}

HTREEITEM HtiFindChild(HWND hwTreeCtl, HTREEITEM hti, ULONG cb,
                    LPENTRYID pbEID, CChsFldDlg *pCFDlg, LPTVNODE *ppNode)
{
    HRESULT hr;
    HTREEITEM htiChild;

    htiChild = TreeView_GetChild(hwTreeCtl, hti);
    
    while(htiChild)
    {
        TV_ITEM tvi;
        
        tvi.hItem = htiChild;
        tvi.mask = TVIF_PARAM;
        tvi.lParam = 0;

        if(!TreeView_GetItem(hwTreeCtl, &tvi))
            return NULL;

        LPTVNODE pNode = (LPTVNODE) tvi.lParam;
        Assert(pNode);

        ULONG ulMatch = 0;
        hr = pCFDlg->Session()->CompareEntryIDs(cb, pbEID,
                            pNode->_pval[iEID].Value.bin.cb,
                            (LPENTRYID)pNode->_pval[iEID].Value.bin.lpb,
                            0, &ulMatch);
        if(SUCCEEDED(hr))
        {
            if(ulMatch)
            {
                *ppNode = pNode;
                return htiChild;
            }
        }

        htiChild = TreeView_GetNextSibling(hwTreeCtl, htiChild);
    }

    return htiChild;
}

//
//  CChsFldDlg::HrRestoreTreeState
//
HRESULT CChsFldDlg::HrRestoreTreeState(void)
{
    HRESULT hr = hrSuccess;
    LPBYTE pb;
    LPBYTE pbMax;
    CTIStack tiStack;
    HTREEITEM hti;
    LONG iLevel = 0;
    BOOL fNodeMissing = FALSE;

    if(!_pcbState  || *_pcbState == 0)
        return hrSuccess;

    //try //protect ourself from callers who mess with the state data
    //{
    Assert(_hwTreeCtl);

    Assert(_ppbState);
    pb = *_ppbState;

    pbMax = pb + *_pcbState;
    
    hti = TreeView_GetRoot(_hwTreeCtl);

    iLevel = GetLevel(&pb);
    Assert(iLevel == 0);

    TreeView_Expand(_hwTreeCtl, hti, TVE_EXPAND);
    
    while(hti)
    {
        if(pb >= pbMax)
            break; //done
            
        LONG iNewLevel = GetLevel(&pb);

        if(iNewLevel <= iLevel)
        {
            do
            {
                hti = tiStack.Pop();
                --iLevel;
            }while(iLevel >= iNewLevel);

            Assert(hti);
        }

        if(iNewLevel > iLevel)
        {
            if(!fNodeMissing)
                Assert(iNewLevel == iLevel + 1);

            ULONG cbEID = GetCb(&pb);
            LPENTRYID pbEID = (LPENTRYID)pb;
            pb += Align4(cbEID);

            if(iNewLevel != iLevel +1)
                continue;
                
            LPTVNODE pNodeChild = NULL;
            HTREEITEM htiChild = HtiFindChild(_hwTreeCtl, hti, cbEID, pbEID,
                                            this, &pNodeChild);
            if(htiChild)
            {
                fNodeMissing = FALSE;
                
                hr = pNodeChild->HrExpand(this);
                if(FAILED(hr))
                    goto err;

                TreeView_Expand(_hwTreeCtl, htiChild, TVE_EXPAND);
                
                tiStack.Push(hti);

                hti = htiChild;
                ++iLevel;

                continue;
            }
            else
            {
                //Assert(FALSE); //$ handle
                fNodeMissing = TRUE;
            }

        }
        /*else
        {
            do
            {
                hti = tiStack.Pop();
                --iLevel;
            }while(iLevel >= iNewLevel);
        }*/
    }
    //}

    //catch(...)
    //{
        //DebugTrace("chsfld: Exception caught in HrRestoreTreeState\n");
    //    hr = E_FAIL;
    //}
    
err:

    /*MAPIFreeBuffer(*_ppbState);
    *_ppbState = NULL;
    *_pcbState = 0;*/
    
    
    //DebugTraceResult(CChsFldDlg::HrRestoreTreeState, hr);
    return hr;
}


//////////////////////////////////////////////////////////////////////////
// CTVNodeFactory

//
//  CTVNodeFactory::CTVNodeFactory
//
inline CTVNodeFactory::CTVNodeFactory()
{
    _pHead = NULL;
}

//
//  CTVNodeFactory::~CTVNodeFactory
//
//  Destroy all created CTVNode s
CTVNodeFactory::~CTVNodeFactory()
{
    while(_pHead)
    {
        LPTVNODE ptemp = _pHead;

        _pHead = _pHead->_pNext;

        delete ptemp;
    }
}


//
//  CTVNodeFactory::HrCreateNode
//
// All instances of CTVNode are created through this method
//
HRESULT CTVNodeFactory::HrCreateNode(LPSPropValue pval, ULONG cVals, LPMDB pmdb,
                                        LPTVNODE * pptvNode)
{
    HRESULT hr = hrSuccess;

    LPTVNODE pNode = new CTVNode(pval, cVals, pmdb);
    
    if(!pNode)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }

    Insert(pNode);

    *pptvNode = pNode;
            
err:

    //DebugTraceResult(CTVNodeFactory::HrCreateNode, hr);
    return hr;
}


//
//  CTVNodeFactory::Insert
//
// Store all created CTVNode s so that we can destroy them when we are done
//
void CTVNodeFactory::Insert(LPTVNODE pNode)
{
    pNode->_pNext = _pHead;
    _pHead = pNode;
}


//
//  ChsFldDlgProc
//
// Dialog proc for the choose folder dialog
//
//  Controls:
//          IDOK        "OK"
//          IDCANCEL    "Cancel"
//          IDC_NEWFLD  "New Folder"
//
INT_PTR CALLBACK
ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    CChsFldDlg * pCDlg = NULL;
    HWND hwTreeCtl = NULL;
    int wmId;
    int wmEvent;
    HTREEITEM hti = NULL;
    TV_ITEM tvi;
        
    switch(msg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        pCDlg = (CChsFldDlg *)lParam;

        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW);
        Assert(hwTreeCtl);

        hr = pCDlg->HrInitTree(hDlg, hwTreeCtl);
        if(HR_FAILED(hr))
        {
            pCDlg->SetError(hr);
            EndDialog(hDlg, 1);
            break;
        }

        SetWindowLong(hDlg, DWL_USER, (LONG)pCDlg);

        break;

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);  
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW);
        Assert(hwTreeCtl);

        pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
        Assert(pCDlg);


        switch(wmId)
        {
        case IDOK:
            switch (wmEvent)
            {
            case BN_CLICKED:
                        
                hti = TreeView_GetSelection(hwTreeCtl);
                AssertSz(hti, "No Selection?");

                tvi.hItem = hti;
                tvi.mask = TVIF_PARAM;

                if(TreeView_GetItem(hwTreeCtl, &tvi))
                {
                    LPTVNODE pNode = (LPTVNODE)tvi.lParam;
                    Assert(pNode);

                    LPMAPIFOLDER pfld = NULL;
                    LPMDB pmdb = NULL;

                    hr = pNode->HrGetFolder(pCDlg, &pfld, &pmdb);
                    if(HR_SUCCEEDED(hr))
                    {
                        pCDlg->SetFolder(pfld, pmdb);
                        pfld->Release();
                        pmdb->Release();

                        hr = pCDlg->HrSaveTreeState();                  
                    }
                    else
                    {
                        pCDlg->SetError(hr);
                    }
                }
                else
                {
                    pCDlg->SetError(E_FAIL);
                }

                EndDialog(hDlg, TRUE);

                break;

            default:
                return FALSE;
            }
            break;

        case IDC_NEWFLD:
            switch(wmEvent)
            {
            case BN_CLICKED:
                
                hti = TreeView_GetSelection(hwTreeCtl);
                AssertSz(hti, "No Selection?");

                tvi.hItem = hti;
                tvi.mask = TVIF_PARAM;

                if(TreeView_GetItem(hwTreeCtl, &tvi))
                {
                    LPTVNODE pNode = (LPTVNODE)tvi.lParam;
                    Assert(pNode);
                    LPTSTR szName = NULL;
                    
                    do
                    {
                        hr = HrGetNewName(pCDlg->hInst(), hDlg, &szName);
                        if(HR_SUCCEEDED(hr))
                        {
                            hr = pNode->HrNewFolder(pCDlg, szName);
                        }
                    }while(hr == MAPI_E_COLLISION);

                    MAPIFreeBuffer(szName);
                    szName = NULL;

                }

                SetFocus(hwTreeCtl);

                break;

            default:
                return FALSE;
            }
            break;
    
        case IDCANCEL:
            switch(wmEvent)
            {
            case BN_CLICKED:

                pCDlg->SetError(MAPI_E_USER_CANCEL);

                EndDialog(hDlg, TRUE);
                break;

            default:
                return FALSE;
            }
            break;
        }
        break;
        
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code)
        {
        case TVN_ITEMEXPANDINGW:
        case TVN_ITEMEXPANDINGA:
            {
            Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            NM_TREEVIEW * ptntv = (NM_TREEVIEW *)lParam;

            if(ptntv->action != TVE_EXPAND)
                return FALSE;

            //
            // If the kids of this node are not loaded, load'em 
            LPTVNODE pNode = (LPTVNODE)ptntv->itemNew.lParam;
            Assert(pNode);

            hwTreeCtl = ((LPNMHDR)lParam)->hwndFrom;
            
            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
            //Assert(pCDlg);

            hr = pNode->HrExpand(pCDlg);  
            if(HR_FAILED(hr))
            {
                return TRUE;
            }
                return FALSE;
            }   
            break;
        case TVN_GETDISPINFOW:
        case TVN_GETDISPINFOA:
            {
            Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            //
            // we don't give folder names to the tree control (to save space)
            // when it wants to display an item, it asks us for the name
            //
            TV_DISPINFO * pdi = (TV_DISPINFO *)lParam;

            if(pdi->item.mask & TVIF_TEXT)
            {
                if (((LPNMHDR)lParam)->code == TVN_GETDISPINFOA)
                {
                    WideCharToMultiByte(CP_ACP, 0, ((LPTVNODE)pdi->item.lParam)->GetName(), -1, 
                                            (char*)pdi->item.pszText, pdi->item.cchTextMax, NULL, NULL);
                }
                else
                {
                    pdi->item.pszText = ((LPTVNODE)pdi->item.lParam)->GetName();
                }
                    
                return TRUE;
            }
            else
            {
                return FALSE;
            }
            }

            break;
            
        case TVN_SELCHANGEDW:
        case TVN_SELCHANGEDA:
            //
            //Enable "OK" and "New Folder" buttons only if it is not the 
            //root node
            //
            {Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            NM_TREEVIEW *ptntv = (NM_TREEVIEW *)lParam;

            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
            Assert(pCDlg);
    
            EnableWindow(GetDlgItem(hDlg, IDOK),
                        !pCDlg->IsTreeRoot(ptntv->itemNew.hItem));
            EnableWindow(GetDlgItem(hDlg, IDC_NEWFLD),
                        !pCDlg->IsTreeRoot(ptntv->itemNew.hItem));
            break;
            }
            
            break;
        }
        
        break;
        
    default:
        return FALSE;   
    }
    return TRUE;
}

//
//  AddOneItem
//
// Add a node to the tree control
//
HTREEITEM AddOneItem( HTREEITEM hParent, HTREEITEM hInsAfter, 
    int iImage, int iImageSel, HWND hwndTree, LPTVNODE pNode, int cKids)
{
    HTREEITEM hItem;
    TV_INSERTSTRUCT tvIns;

    tvIns.item.mask             = TVIF_CHILDREN | TVIF_PARAM |TVIF_TEXT |
                                    TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvIns.item.pszText          = LPSTR_TEXTCALLBACK;
    tvIns.item.cchTextMax       = 0;
    tvIns.item.lParam           = (LPARAM)pNode;
    tvIns.item.cChildren        = cKids;
    tvIns.item.iImage           = iImage;
    tvIns.item.iSelectedImage   = iImageSel;

    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;
    
    // Insert the item into the tree.
    hItem = TreeView_InsertItem(hwndTree, &tvIns);

    pNode->SetHandle(hItem);

    return (hItem);
}


//
//  HrGetNewName
//
//  Display dialog asking the user for a new folder name 
//
//  If *pszNewName is not NULL, it has to be a string allocated with
//  MAPIAllocateBuffer. It will be displayed in the dialog.
//  The returned string has to be freed with MAPIFreeBuffer.
//
HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPTSTR * pszNewName)
{
    Assert(pszNewName);
    
    int nRes = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_NEWNAME), hwParent,
                        NewNameDlgProc, (LPARAM)pszNewName);
    if(nRes == 1)
    {
        return hrSuccess;
    }
    else
    {
        //DebugTraceSc(HrGetNewName, E_FAIL);
        return E_FAIL;
    }
}


//
// NewNameDlgProc
//
// Dlg proc for the "New Name" dialog;
// If user chooses OK, return 1 from EndDialog.
//
BOOL CALLBACK
NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int wmId;
    int wmEvent;

    switch(msg)
    {
    case WM_INITDIALOG:
        {
        Assert(lParam);

        LPTSTR * pszName = (LPTSTR *)lParam;

        if(*pszName)
        {
            SetWindowText(GetDlgItem(hDlg, IDC_NAME), *pszName);
            MAPIFreeBuffer(*pszName);
            *pszName = NULL;

        }
        
        SetWindowLong(hDlg, DWL_USER, (LONG)lParam);
        SetFocus(GetDlgItem(hDlg, IDC_NAME));
        return FALSE;
        }

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);  
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch(wmId)
        {
        case IDOK:
            switch (wmEvent)
            {
            case BN_CLICKED:
                {
                HWND hwName = GetDlgItem(hDlg, IDC_NAME);
                
                int cb = Edit_GetTextLength(hwName);
                Assert(cb); //OK is disabled when edit control is empty

                LPTSTR szName = NULL;
                if(!MAPIAllocateBuffer(cb + 1, (LPVOID *)&szName))
                {
                    GetWindowText(hwName, szName, cb+1);

                    LPTSTR * pszName = (LPTSTR *)GetWindowLong(hDlg, DWL_USER);

                    *pszName = szName;

                    EndDialog(hDlg, 1);
                }
                else
                {
                    EndDialog(hDlg, FALSE);
                    break;
                }
                }
                break;

            default:
                return FALSE;
            }
            
            break;

        case IDCANCEL:
            switch (wmEvent)
            {
            case BN_CLICKED:
                EndDialog(hDlg, FALSE);
                break;

            default:
                return FALSE;
            }
            
            break;

        case IDC_NAME:
            switch(wmEvent)
            {
            case EN_CHANGE:
                Assert((HWND)lParam == GetDlgItem(hDlg, IDC_NAME));

                EnableWindow(GetDlgItem(hDlg, IDOK),
                            Edit_GetTextLength((HWND)lParam));

                break;

            default:
                return FALSE;
            }
                
            break;
        }
        break;
    
    default:
        return FALSE;
    }   
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\chsfld.h ===
////////////////////////////////////////////////////////////////////////////
//
//      CHSFLD.H
//
//      Prototype for HrPickFolder.
//      Displays a dialog box allowing user to choose a folder from message
//      stores in the current profile.
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

#ifndef _CHSFLD_H_
#define _CHSFLD_H_

// Parameters:
// 
// required:
//
// hInst    - [in] instance of the module containing resources for the dialog
//
// hWnd     - [in] handle of the parent window for the dialog 
//
// pses     - [in] pointer to MAPI session object
//
// ppfld    - [out] on success points to the variable where a pointer to the
//                  selected folder is stored
//
// ppmdb    - [out] on success points to the variable where a pointer to a
//                  message store object containing the selected folder is stored
//
// optional:
//
// pcb      - [in/out] size of the buffer pointed to by *ppb
//
// ppb      - [in/out] *ppb is a pointer to the buffer where expand/collapse
//                      state of the dialog is stored. (don't mess with it).
//                      The state is valid only within the same MAPI session.
//
// Return Values:
//
// S_OK     - The call succeeded and has returned the expected values
//
// E_INVALIDARG - One or more of the parameters passed into the function
//                  were not valid
//
// MAPI_E_USER_CANCEL   - User canceled the dialog

STDAPI HrPickFolder(HINSTANCE hInst, HWND hWnd, LPMAPISESSION pses,
                    LPMAPIFOLDER * ppfld, LPMDB * ppmdb,
                    ULONG *pcb, LPBYTE *ppb);
                        
typedef   HRESULT (STDAPICALLTYPE * HRPICKFOLDER)(HINSTANCE hInst, HWND hWnd,
                    LPMAPISESSION pses, LPMAPIFOLDER * ppfld, LPMDB * ppmdb,
                    ULONG *pcb, LPBYTE *ppb);

#endif /* _CHSFLD_H_ */
#endif /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed


// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
// DECLARE_ORDINAL_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
// DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
// DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
// DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
// DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
// DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
// DECLARE_PROCNAME_MAP(utildll)
// DECLARE_PROCNAME_MAP(uxtheme)
// DECLARE_PROCNAME_MAP(version)
DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
//     DLDENTRYB(comctl32)
//     DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
//     DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
//     DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
//     DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
//     DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
//     DLDENTRYP(utildll)
//     DLDENTRYP(uxtheme)
//     DLDENTRYP(version)
    DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -  Definitions for controlling GUID initialization               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#error initguid: must include objbase.h first.
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef _WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\mapi.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       mapi.cxx
//
//  Contents:   Dynamic wrappers for URL monikers.
//
//----------------------------------------------------------------------------

#define _INTERNAL_WRAPPER_BYPASS
#include <padhead.hxx>

DYNLIB g_dynlibMAPI = { NULL, NULL, "MAPI32.DLL" };

#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAPIT_VOID(fn, a1, a2)\
VOID WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return;\
    (*(VOID (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        Assert(FALSE);\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_FASTCALL(fn, cbarg, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAPIT_FASTCALL_VOID(fn, cbarg, a1, a2)\
VOID WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return;\
    (*(VOID (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_FASTCALL_(type, fn, cbarg, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        Assert(FALSE);\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}




WRAPIT(MAPIInitialize,
    (LPVOID lpMapiInit),
    (lpMapiInit))

WRAPIT_VOID(MAPIUninitialize,
    (),
    ())

WRAPIT(MAPIAllocateBuffer,
    (ULONG cbSize, LPVOID FAR * lppBuffer),
    (cbSize, lppBuffer))

WRAPIT(MAPIAllocateMore,
    (ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer),
    (cbSize, lpObject, lppBuffer))

WRAPIT(MAPIOpenLocalFormContainer,
    (LPMAPIFORMCONTAINER FAR * ppfcnt),
    (ppfcnt))
   
WRAPIT_(ULONG,
    MAPIFreeBuffer,
    (LPVOID lpBuffer),
    (lpBuffer))

WRAPIT_VOID(FreeProws,
    (LPSRowSet prows),
    (prows))

WRAPIT_FASTCALL(HrQueryAllRows,
    24,
    (LPMAPITABLE ptable, LPSPropTagArray ptaga, LPSRestriction pres, 
     LPSSortOrderSet psos, LONG crowsMax, LPSRowSet FAR * pprows),
    (ptable, ptaga, pres, psos, crowsMax, pprows))

WRAPIT_FASTCALL(HrGetOneProp,
    12,
    (LPMAPIPROP pmp, ULONG ulPropTag, LPSPropValue FAR * ppprop),
    (pmp, ulPropTag, ppprop))

WRAPIT_FASTCALL_VOID(FreePadrlist,
     4,
    (LPADRLIST padrlist),
    (padrlist))

WRAPIT_FASTCALL_(FILETIME,
    FtAddFt,
    16,
    (FILETIME Addend1, FILETIME Addend2),
    (Addend1, Addend2))

WRAPIT_FASTCALL_(FILETIME, 
    FtSubFt,
    16,
    (FILETIME Addend1, FILETIME Addend2),
    (Addend1, Addend2))

WRAPIT(WrapCompressedRTFStream,
    (LPSTREAM lpCRTFS, ULONG ulFlags, LPSTREAM FAR * lpUncomp),
    (lpCRTFS, ulFlags, lpUncomp))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgcidx.cxx ===
/*
 *  MSGCIDX.CXX
 *  
 *  Create and extend PR_CONVERSATION_INDEX
 */

#include <padhead.hxx>

#define cbConvIndexHdr          22
#define cbConvIndexComponent    5
#define bConvIndexRes           (BYTE)1

/*
 *  ExtractLastFileTime()
 *  
 *  Purpose:
 *  
 *      Parses an existing covnersation index and extracts the last
 *      FILETIME value contained in the index.
 */
VOID
ExtractLastFileTime (LPBYTE lpb, ULONG cb, FILETIME FAR * lpft)
{
    FILETIME ft;
    FILETIME ftCur;
    LPBYTE lpbEnd;

    //  Lets do some verification on the key
    //
    Assert (!IsBadReadPtr (lpb, (UINT)cb));
    Assert (!IsBadWritePtr (lpft, sizeof(FILETIME)));
    Assert (*lpb == bConvIndexRes);
    Assert (cb >= cbConvIndexHdr);
    Assert (!((cb - cbConvIndexHdr) % cbConvIndexComponent));

    //  Rebuild the header time\date into FILETIME format
    //
    ft.dwHighDateTime = (((DWORD)(lpb[1])) << 16) |
                        (((DWORD)(lpb[2])) << 8) |
                        ((DWORD)(lpb[3]));

    ft.dwLowDateTime = (((DWORD)(lpb[4])) << 24) |
                       (((DWORD)(lpb[5])) << 16);

    //  See where the last child chunk ends
    //
    lpbEnd = lpb + cb;
    lpb += cbConvIndexHdr;

    //  Now go through the child chunks to compute
    //  for the last FILETIME using the delta
    //
    while (lpb < lpbEnd)
    {
        //  Convert the delta of the current child
        //  chunk into the FILETIME format.  Use the
        //  delta code in the first bit to get the
        //  real delta.
        //
        //  Delta code : 1 = mask 10000000 = 0x80
        //
        if ((*lpb & 0x80) == 0x80)
        {
            //  Mask out the first bit used for the delta code
            //  *lpb | 0x7F;
            //
            ftCur.dwHighDateTime = (((DWORD)(lpb[0] & 0x7F)) << 15) |
                                   (((DWORD)(lpb[1])) << 7) |
                                   (((DWORD)(lpb[2])) >> 1);

            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) << 31) |
                                  (((DWORD)(lpb[3])) << 23);

            ft = FtAddFt (ft, ftCur);
        }
        else
        {
            ftCur.dwHighDateTime = (((DWORD)(lpb[0] & 0x7F)) << 10) |
                                   (((DWORD)(lpb[1])) << 2) |
                                   (((DWORD)(lpb[2])) >> 6);

            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) << 26) |
                                  (((DWORD)(lpb[3])) << 18);

            ft = FtAddFt (ft, ftCur);
        }

        // Advance to next child
        //
        lpb += cbConvIndexComponent;
    }

    //  If all went well, we sould have ended up at
    //  lpbEnd
    //
    Assert (lpb == lpbEnd);
    *lpft = ft;
    return;
}

/*
 *  ScFillConvHeader()
 *  
 *  Purpose:
 *  
 *      Fills in the header of a conversation index.  This function is
 *      called when a new conversation index is created.
 *  
 *  Assumptions:
 *  
 *      The buffer passed in should be big enough to hold cbConvIndexHdr
 *      bytes (22 bytes).
 */
SCODE
ScFillConvHeader (LPBYTE rgb, ULONG cb)
{
    SCODE sc = S_OK;
    SYSTEMTIME st;
    FILETIME ft;
    GUID guid;

    Assert (cb >= cbConvIndexHdr);
    Assert (!IsBadWritePtr (rgb, cbConvIndexHdr));

    //  (Ha). Put the reserved byte
    //
    rgb[0] = bConvIndexRes;
        
    //  (Hb). Put the current time
    //
    GetSystemTime (&st);
    SystemTimeToFileTime (&st, &ft);

    //  Construct the date\time one byte at a time
    //
    rgb[1] = (BYTE) ((ft.dwHighDateTime & 0x00FF0000) >> 16);
    rgb[2] = (BYTE) ((ft.dwHighDateTime & 0x0000FF00) >> 8);
    rgb[3] = (BYTE) (ft.dwHighDateTime & 0x000000FF);

    //  Drop the rightmost least significant 2 bytes
    //
    rgb[4] = (BYTE) ((ft.dwLowDateTime & 0xFF000000) >> 24);
    rgb[5] = (BYTE) ((ft.dwLowDateTime & 0x00FF0000) >> 16);

    //  (Hc). Now put the GUID
    //      {
    //          DWORD Data1;
    //          WORD  Data2;
    //          WORD  Data3;
    //          BYTE  Data4[8];
    //      } GUID;
    //
    sc = GetScode (CoCreateGuid (&guid));
    if (!FAILED (sc))
    {       
        //  Again, lets do it one byte at a time
        //
        rgb[6] = (BYTE) ((guid.Data1 & 0xFF000000) >> 24);
        rgb[7] = (BYTE) ((guid.Data1 & 0x00FF0000) >> 16);
        rgb[8] = (BYTE) ((guid.Data1 & 0x0000FF00) >> 8);
        rgb[9] = (BYTE) ((guid.Data1 & 0x000000FF));
        rgb[10] = (BYTE) ((guid.Data2 & 0xFF00) >> 8);
        rgb[11] = (BYTE) ((guid.Data2 & 0x00FF));
        rgb[12] = (BYTE) ((guid.Data3 & 0xFF00) >> 8);
        rgb[13] = (BYTE) ((guid.Data3 & 0x00FF));
    }

    //  Slurp the rest across
    //
    CopyMemory (&rgb[14], &guid.Data4, 8);
    //DebugTraceSc (ScFillConvHeader(), sc);
    return sc;
}

/*
 *  ScAddConversationIndex()
 *  
 *  Purpose:
 *  
 *      Given the conversation index to a message, this function will
 *      create the conversation of a child message to the original.  If
 *      the no original is suplied, then an index is created that would
 *      signify the start of a new thread.
 */
SCODE
ScAddConversationIndex (ULONG cbParent,
    LPBYTE lpbParent,
    ULONG FAR * lpcb,
    LPBYTE FAR * lppb)
{
    SCODE sc;
    DWORD dwTemp;
    SYSTEMTIME st;
    FILETIME ft;
    FILETIME ftLast;
    FILETIME ftDelta;
    HMODULE hMAPIDll = NULL;
    typedef SCODE (STDAPICALLTYPE FAR *MAPICONVIDX)(ULONG, LPBYTE, ULONG FAR *, LPBYTE FAR *);
    MAPICONVIDX lpfnMAPIConvIdx = NULL;

#ifdef _WIN32
    #define szMAPIDll "mapi32.dll"
#else
    #define szMAPIDll "mapi.dll"
#endif

    /*
     * MAPI is going to export a function that is doing the same thing as this one.
     * So if the function is present we'll use it.
     */
    hMAPIDll = GetModuleHandleA(szMAPIDll);
    if(hMAPIDll)
    {
        lpfnMAPIConvIdx = (MAPICONVIDX)GetProcAddress(hMAPIDll,
                                            szScCreateConversationIndex);
        if(lpfnMAPIConvIdx)
        {
            return (*lpfnMAPIConvIdx)(cbParent, lpbParent, lpcb, lppb);
        }
    }
    //  Ensure that the parent is what we think
    //  it should be
    //
    if ((cbParent < cbConvIndexHdr) ||
        ((cbParent - cbConvIndexHdr) % cbConvIndexComponent) ||
        (lpbParent[0] != bConvIndexRes))
    {
        cbParent = 0;
        *lpcb = cbConvIndexHdr;
    }
    else
        *lpcb = cbParent + cbConvIndexComponent;

    sc = MAPIAllocateBuffer (*lpcb, (LPVOID FAR *)lppb);
    if (!FAILED (sc))
    {
        if (cbParent == 0)
        {
            //  This is a new key, so all it ever contains
            //  is a header.  Fill it in and we are done
            //
            sc = ScFillConvHeader (*lppb, *lpcb);
            if (FAILED (sc))
            {
                MAPIFreeBuffer (*lppb);
                *lppb = NULL;
            }
        }
        else
        {
            //  First copy the old key across
            //
            CopyMemory (*lppb, lpbParent, (UINT)cbParent);

            //  (Cb).  First get the current time (we'll then get
            //  the absolute distance between the current time and
            //  the time in the last chunk)
            //
            GetSystemTime (&st);
            SystemTimeToFileTime (&st, &ft);

            //  Now get the time of the last chunk
            //  
            ExtractLastFileTime (lpbParent, cbParent, &ftLast);

            //  Now mask out the bits we don't want from the
            //  current time
            //
            ft.dwHighDateTime &= 0x00FFFFFF;
            ft.dwLowDateTime &= 0xFFFF0000;

            //  This assert is here to catch how often the
            //  5-byte time can collide and under what scenario,
            //  to see if 5 bytes + the next byte suffices to
            //  make this child chunk unique.
            //  
            Assert (!((ftLast.dwHighDateTime == ft.dwHighDateTime) &&
                (ftLast.dwLowDateTime == ft.dwLowDateTime)));

            //  Get the change in time
            //
            if ((ft.dwHighDateTime > ftLast.dwHighDateTime) ||
                ((ft.dwHighDateTime == ftLast.dwHighDateTime) &&
                 (ft.dwLowDateTime > ftLast.dwLowDateTime)))
            {
                ftDelta = FtSubFt (ft, ftLast);
            }
            else
                ftDelta = FtSubFt (ftLast, ft);

            //  If the delta is less than 1.7 yrs, use 0
            //
            if (!(ftDelta.dwHighDateTime & 0x00FE0000))
            {
                //  Just mask out the 31 bits that we
                //  want from the ftDelta
                //
                dwTemp = ((DWORD)(ftDelta.dwHighDateTime & 0x0001FFFF)) << 14 |
                         ((DWORD)(ftDelta.dwLowDateTime & 0xFFFC0000)) >> 18;

                //  Only the first byte is different
                //
                (*lppb)[cbParent] = (BYTE)((dwTemp & 0xFF000000) >> 24 );
            }
            else
            {
                //  Just mask out the 31 bits that we
                //  want from the ftDelta
                //
                dwTemp = ((DWORD)(ftDelta.dwHighDateTime & 0x003FFFFF)) << 9 |
                         ((DWORD)(ftDelta.dwLowDateTime & 0xFF800000)) >> 23;

                // Only the first byte is different
                //
                (*lppb)[cbParent] = (BYTE)(HIBYTE(HIWORD(dwTemp)) | 0x080);
            }

            //  The remaining delta bytes are the same
            //
            (*lppb)[cbParent + 1] = (BYTE) ((dwTemp & 0x00FF0000) >> 16);
            (*lppb)[cbParent + 2] = (BYTE) ((dwTemp & 0x0000FF00) >> 8);
            (*lppb)[cbParent + 3] = (BYTE) ((dwTemp & 0x000000FF) );

            //  (Cc). Next get the random number
            //  (Cd). Next get the sequence count
            //  -- we are going to use part of the tick count
            //
            (*lppb)[cbParent + 4] = (BYTE) (GetTickCount() & 0x000000FF);
        }
    }

    //DebugTraceSc (ScAddConversationIndex(), sc);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgcidx.h ===
/*
 * MSGCIDX.H
 *
 * Prototype for ScAddConversationIndex
 *
 *  Copyright (c) 1995, Microsoft Corporation.
 *  All rights reserved.
 */

//#ifdef __cplusplus
//extern "C" {
//#endif

SCODE ScAddConversationIndex (ULONG cbParent, 
                              LPBYTE lpbParent,
                              ULONG FAR * lpcb,
                              LPBYTE FAR * lppb);

//#ifdef __cplusplus
//}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgaddr.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgaddr.cxx
//
//  Contents:   Address list manipulation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#define		cchUnresolvedMax	256

typedef struct _editstreamcookie
{
	HRESULT         hr;
	LPADRLIST *		ppal;
	ULONG			cRecipTypes;
	ULONG			iRecipType;
	ULONG *			rgulDestComps;
	HWND *			rghwndEdit;
	LONG *			piae;
	char			rgch[cchUnresolvedMax];
	ULONG			cchBuf;
	BOOL			fTruncated;
	INT				nBrackets;
} EDITSTREAMCOOKIE;


static HRESULT AddUnresolvedName(EDITSTREAMCOOKIE * pesc);

static HRESULT SpecialAdrlistScan(LPADRLIST * ppal, LONG * piae,
				ULONG cRecipTypes, ULONG * rgulDestComps, BOOL fAboutToAdd);

static HRESULT GrowAdrlist(LPADRLIST * ppal, UINT caeToAdd);

static DWORD CALLBACK UnresolvedStream(DWORD dwCookie, LPBYTE pbBuff,
				LONG cb, LONG *pcb);



/*
 *	CPadMessage::DoCheckNames
 *
 *	Purpose:
 *		Implement Check Names command
 */
void CPadMessage::DoCheckNames()
{
    HRESULT hr;

    hr = THR_NOTRACE(GetAndCheckRecipients(TRUE));

    if (hr && hr != MAPI_E_USER_CANCEL)
        ShowError();
}


/*
 *	CPadMessage::GetAndCheckRecipients
 *
 *	Purpose:
 *		Resolves names for the message and get them into the _padrlist
 *
 *	Arguments:
 *		BOOL		Update the recipient wells?
 *
 *	Returns:
 *      hr          MAPI_E_USER_CANCEL if user cancelled operation
 */
HRESULT CPadMessage::GetAndCheckRecipients(BOOL fUpdateWells)
{
	HRESULT hr = S_OK;
	LPSPropValue pval;
	BOOL    fFoundFrom = FALSE;
	ULONG   iae;

	// Capone 4545
	// Name from resend note From well wiped out on Check Names
	if(_rghwndEdit[0])
		SendMessage(_rghwndEdit[0], EM_SETMODIFY, TRUE, 0);

	// Get the names out of the controls and into the adrlist structure
	hr = THR(ParseRecipients(TRUE));
	if (hr || !_padrlist)
		goto Cleanup;

	// Check if there is more than one name in the From well
	for (iae = 0; iae < _padrlist->cEntries; iae++)
	{
		// Ignore empty ADRENTRY's
		if (!_padrlist->aEntries[iae].rgPropVals)
			continue;

		pval = PvalFind((LPSRow) &_padrlist->aEntries[iae], PR_RECIPIENT_TYPE);
		AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
		if (pval)
		{
			if (pval->Value.ul == MAPI_ORIG)
			{
				if (fFoundFrom)
				{
					break;	// Already one found so there is more than one!
				}
				else
				{
					fFoundFrom = TRUE;
				}
			}
		}
	}

	// Early exit from loop indicates more than one name in From well
	if (iae < _padrlist->cEntries)
	{
		hr = g_LastError.SetLastError(E_FAIL);
		goto Cleanup;
	}

    // Open address book (_pab)
    hr = OpenAddrBook();
    if (hr)
    {
        ShowError();
        if (FAILED(hr))
            goto Cleanup;
    }

    // Ignore warnings 
    if (hr == MAPI_W_ERRORS_RETURNED)
        hr = S_OK;

    // Resolve recipient names
	hr = THR(_pab->ResolveName((ULONG)_hwnd, MAPI_DIALOG, NULL, _padrlist));
	if (FAILED(hr) && hr != MAPI_E_USER_CANCEL)
	{
		hr = g_LastError.SetLastError(hr, _pab);
		goto Cleanup;
	}

	// Get the names out of the adrlist structure and into the controls
	if (hr == MAPI_E_USER_CANCEL || fUpdateWells)
    {
		IGNORE_HR(DisplayRecipients(TRUE));
    }

Cleanup:

	// Remove From well type from _rghwndEdit and _rgulRecipTypes arrays

	// Capone 4311
	// Remove the From well entry from the _padrlist

	// Capone 10812
	// No resolve on send optimization (fUpdateWells == FALSE) would leave
	// MAPI_ORIG in the DIAL(_padrlist) so it can be used in ScNoteWriteMessage.

	if (fFoundFrom && (fUpdateWells || hr))
	{
		for (iae = 0; iae < _padrlist->cEntries; iae++)
		{
			// Ignore empty ADRENTRY's

			if (!_padrlist->aEntries[iae].rgPropVals)
				continue;

			pval = PvalFind((LPSRow) &_padrlist->aEntries[iae], PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval && (pval->Value.ul == MAPI_ORIG))
			{
				_padrlist->aEntries[iae].cValues = 0;
				// Exchange 30065 Memory leak
				MAPIFreeBuffer(_padrlist->aEntries[iae].rgPropVals);
				_padrlist->aEntries[iae].rgPropVals = NULL;
			}
		}
	}

    RRETURN1(hr, MAPI_E_USER_CANCEL);
}

/*
 *	ParseRecipients
 *	
 *	Purpose:
 *		Parse wells and build list of recipients
 *	
 *	Parameters:
 *		ppal		    returns pointer to list of recipients
 *      fIncludeFrom    include from well or not
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::ParseRecipients(BOOL fIncludeFrom)
{
	int diRecipTypes = fIncludeFrom ? 0 : 1;

	RRETURN(THR(AddNamesToAdrlist(&_padrlist)));
}

/*
 *	DisplayRecipients
 *	
 *	Purpose:
 *		Display recipient list in the wells
 *	
 *	Parameters:
 *		pal				pointer to list of recipients
 *      fIncludeFrom    include from well or not
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::DisplayRecipients(BOOL fIncludeFrom)
{
	HRESULT hr = S_OK;
	int i;
	int diRecipTypes = fIncludeFrom ? 0 : 1;
	HCURSOR hcursor;

	if (_padrlist)
	{
		hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

		for (i = (INT)_cRecipTypes - 1; i >= diRecipTypes; --i)
		{
			if(_rghwndEdit[i])
				SetWindowTextA(_rghwndEdit[i], "");
		}

		hr = THR(AddRecipientsToWells(_padrlist));

		SetCursor(hcursor);
	}

    RRETURN(hr);
}

/*
 *	AddRecipientsToWells
 *	
 *	Purpose:
 *		This function adds all the recipients in an ADRLIST
 *		to the recipient wells.
 *	
 *	Parameters:
 *		pal				pointer to list of recipients
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddRecipientsToWells(LPADRLIST pal)
{
	HRESULT     	hr = S_OK;
	ULONG			iae;
	ULONG			i;
	LPSPropValue	pval;

	Assert(pal);
	Assert(_cRecipTypes > 0);

	for (iae = 0; iae < pal->cEntries; iae++)
	{
		// Ignore empty ADRENTRY's

		if (!pal->aEntries[iae].rgPropVals)
			continue;

		pval = PvalFind((LPSRow) &pal->aEntries[iae], PR_RECIPIENT_TYPE);
		AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
		if (pval)
		{
			for (i = 0; i < _cRecipTypes; ++i)
			{
				if (_rgulRecipTypes[i] == pval->Value.ul)
				{
					hr = THR(AddRecipientToWell(_rghwndEdit[i],
						 			&pal->aEntries[iae], TRUE, TRUE));
					if (hr != S_OK)
					{
						goto Cleanup;
					}

					break;
				}
			}
		}
	}

Cleanup:
	RRETURN(hr);
}


/*
 *	AddRecipientToWell
 *	
 *	Purpose:
 *		This function adds a recipient to a recipient well.
 *	
 *	Parameters:
 *		hwndEdit		hwnd of the recipient well to add the
 *						recipient to
 *		pae				pointer to an ADRENTRY
 *		fAddSemi		whether to add a semicolon between entries
 *		fCopyEntry		whether to copy the ADRENTRY or just use it
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddRecipientToWell(HWND hwndEdit, LPADRENTRY pae,
									BOOL fAddSemi, BOOL fCopyEntry)
{
	HRESULT			hr = S_OK;
	LPSPropValue	pval;
	BOOL			fResolved	= FALSE;
	LPRICHEDITOLE	preole		= NULL;
	CTriple *		ptriple     = NULL;
	INT				cch;
	SRow			rwCopy;
	REOBJECT		reobj		= { 0 };

	// Check if this is a resolved or unresolved name

	pval = PvalFind((LPSRow) pae, PR_ENTRYID);
	if (pval && pval->Value.bin.cb != 0)
	{
		// Its a resolved name
		fResolved = TRUE;

		// Initialize the object information structure
		reobj.cbStruct = sizeof(REOBJECT);
		reobj.cp = REO_CP_SELECTION;
		reobj.clsid = CLSID_CTriple;
		reobj.dwFlags = REO_BELOWBASELINE | REO_INVERTEDSELECT |
						REO_DYNAMICSIZE | REO_DONTNEEDPALETTE;
		reobj.dvaspect = DVASPECT_CONTENT;

		Verify(SendMessage(hwndEdit, EM_GETOLEINTERFACE, 
								  	(WPARAM) NULL, (LPARAM) &preole));

		hr = THR(preole->GetClientSite(&reobj.polesite));
		if (hr != S_OK)
		{
			if (!fCopyEntry)
			{
				MAPIFreeBuffer(pae->rgPropVals);
				pae->rgPropVals = NULL;
			}
			goto MemoryError;
		}

		if (fCopyEntry)
		{
			hr = THR(CopyRow(NULL, (LPSRow) pae, &rwCopy));
			pae = (LPADRENTRY) &rwCopy;
			if (hr != S_OK)
				goto MemoryError;
		}

		ptriple = new CTriple(this, (LPSRow) pae);
		if (!ptriple)
		{
			MAPIFreeBuffer(pae->rgPropVals);
			pae->rgPropVals = NULL;
			goto MemoryError;
		}

		// from this point on, the triple owns the properties
		pae->rgPropVals = NULL;
	}

	if (fAddSemi && (cch = GetWindowTextLength(hwndEdit)) != 0)
	{
		SendMessageA(hwndEdit, EM_SETSEL, cch, cch);
		SendMessageA(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM)"; ");
	}

	if (!fResolved)
	{
		// Its an unresolved name

		pval = PvalFind((LPSRow) pae, PR_DISPLAY_NAME_A);
		AssertSz(pval, "Recipient must have a Display Name");
		SendMessageA(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM)pval->Value.lpszA);
	}
	else
	{
		// Its a resolved name

		hr = THR(ptriple->QueryInterface(IID_IOleObject, (void**)&reobj.poleobj));
		ptriple->Release();
		if (hr)
			goto MemoryError;

		if (reobj.poleobj->SetClientSite(reobj.polesite))
			goto MemoryError;

		// Report errors if Richedit fails
		hr = THR(preole->InsertObject(&reobj));
		if (FAILED(hr))
		{
			hr = g_LastError.SetLastError(E_FAIL);
			goto Error;
		}
	}

	goto Cleanup;

MemoryError:
	hr = g_LastError.SetLastError(E_OUTOFMEMORY);

Error:
	//TraceError("ScAddRecipientToWell", hr);

Cleanup:
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(reobj.polesite);
	ReleaseInterface(preole);

	RRETURN(hr);
}

/*
 *	SpecialAdrlistScan
 *	
 *	Purpose:
 *		This function scans through the ADRLIST beginning at *piae.
 *		When this function finds an empty ADRENTRY, it returns.
 *	
 *		When an ADRENTRY is found with a recipient type contained
 *		in rgulDestComps, the data (if any) is removed and we have our
 *		empty ADRENTRY.
 *	
 *		If no empty ADRENTRY is found, the function allocates a new
 *		ADRLIST with room for some more ADRENTRY's.
 *	
 *		If fAboutToAdd is false, this function continues through
 *		the entire ADRLIST, emptying the remaining ADRENTRY's.
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST
 *		piae			pointer to ADRENTRY index
 *		cREcipTypes		count of recipients types in rgulDestComps
 *		rgulDestComps	recipient types to mark for removal
 *		fAboutToAdd		TRUE if a recipient is about to be added.
 *						FALSE when we're just finishing off the
 *						scan.
 *	
 *	Returns:
 *		sc
 */
static HRESULT SpecialAdrlistScan(LPADRLIST * ppal, LONG * piae,
				ULONG cRecipTypes, ULONG * rgulDestComps, BOOL fAboutToAdd)
{
	HRESULT			hr		= S_OK;
	ULONG			i;
	LPSPropValue	pval;
	LPADRLIST		pal		= *ppal;
	LPADRENTRY		pae;

	if (pal)
	{
		while (++(*piae) < (LONG) pal->cEntries)
		{
			pae = &pal->aEntries[*piae];

			if (!pae->rgPropVals)
			{
				if (!fAboutToAdd)
					continue;

				// found an empty ADRENTRY and ready to add to it
				goto Cleanup;
			}

			pval = PvalFind((LPSRow) pae, PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval)
			{
				// Check to see if this ADRENTRY corresponds to one of our
				// recipient wells (by checking for a match in rgulDestComps.

				for (i = 0; i < cRecipTypes; ++i)
				{
					if (pval->Value.ul == rgulDestComps[i])
					{
						MAPIFreeBuffer(pae->rgPropVals);
						pae->rgPropVals = NULL;
						pae->cValues = 0;

						if (!fAboutToAdd)
							break;

						// created an empty ADRENTRY and ready to add to it
						goto Cleanup;
					}
				}
			}
		}
	}
	else
		*piae = 0;

	if (fAboutToAdd)
	{
		// We couldn't find (or create) an empty ADRENTRY so we'll
		// have to grow the ADRLIST (or create one) so we will
		// be able to add to pal->aEntries[*piae] on exit.

		//$ REVIEW - I'm adding 5 at a time. Sound reasonable?

		hr = THR(GrowAdrlist(ppal, 5));
	}

Cleanup:
	RRETURN(hr);
}

/*
 *	AddNamesToAdrlist
 *	
 *	Purpose:
 *		This function will add all the resolved and unresolved
 *		names from the edit controls to the ADRLIST
 *	
 *	Parameters:
 *		ppal			pointer to pointer to ADRLIST
 *		cRecipTypes		number of recipients types (which corresponds
 *						to the number of hwndEdit's and ulDestComps'
 *		rghwndEdit		hwnd's of the recipient wells
 *		rgulDestComps	recipient types for each recipient well
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddNamesToAdrlist(LPADRLIST * ppal)
{
	ULONG				i;
	ULONG				iOb;
	ULONG				cOb;
	LPSPropValue		pval;
	LONG				iae		= -1;
	LPRICHEDITOLE		preole	= NULL;
	REOBJECT			reobj	= { 0 };
	EDITSTREAMCOOKIE	esc;
	const EDITSTREAM	es		= {(DWORD) &esc, 0, UnresolvedStream};

	reobj.cbStruct = sizeof(REOBJECT);

	esc.hr = S_OK;
	esc.ppal = ppal;
	esc.piae = &iae;
	esc.fTruncated = FALSE;
	esc.nBrackets = 0;

	// I only want to operate on the dirty edit controls

	esc.cRecipTypes = 0;
	esc.rgulDestComps = new ULONG[_cRecipTypes];
	esc.rghwndEdit = new HWND[_cRecipTypes];
	if (!esc.rgulDestComps || !esc.rghwndEdit)
		goto MemoryError;

	for (i = 0; i < _cRecipTypes; ++i)
	{
		if (_rghwndEdit[i] && SendMessage(_rghwndEdit[i], EM_GETMODIFY, 0, 0))
		{
			esc.rgulDestComps[esc.cRecipTypes] = _rgulRecipTypes[i];
			esc.rghwndEdit[esc.cRecipTypes++] = _rghwndEdit[i];
		}
	}

	for (i = 0; i < esc.cRecipTypes; ++i)
	{
        _fRecipientsDirty = TRUE;

		esc.iRecipType = i;

		// Add all the resolved names (stored as OLE objects) from
		// esc.rghwndEdit[i] to the ADRLIST

		Verify(SendMessage(esc.rghwndEdit[i], EM_GETOLEINTERFACE, 
										(WPARAM) NULL, (LPARAM) &preole));

		cOb = preole->GetObjectCount();

		for (iOb = 0; iOb < cOb; iOb++)
		{
			LPPERSIST	ppersist = NULL;

			if (preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ) != S_OK)
				goto MemoryError;

			esc.hr = SpecialAdrlistScan(ppal, &iae, esc.cRecipTypes,
											esc.rgulDestComps, TRUE);
			if (esc.hr != S_OK)
				goto Cleanup;

			// ISSUE: chirsf - Giant hack to get the ADRENTRY !!!
            esc.hr = CopyRow(NULL, &((CTriple*)reobj.poleobj)->_rw,
									(LPSRow) &(*ppal)->aEntries[iae]);
			if (esc.hr != S_OK)
				goto Cleanup;
			
            pval = PvalFind((LPSRow) &(*ppal)->aEntries[iae], PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval)
				pval->Value.l = esc.rgulDestComps[i];

			ClearInterface(&reobj.poleobj);
		}

		ClearInterface(&preole);

		// Add all the unresolved names to the ADRLIST

		esc.cchBuf = 0;

		SendMessage(esc.rghwndEdit[i], EM_STREAMOUT, SF_TEXT, (LPARAM) &es);
		if (esc.hr == S_OK)
		{
			// Add whatever is left after the last semicolon

			// I can ignore the return value since it is als , m, m,m, m                                                                                             o
			// stuffed in esc.sc

			AddUnresolvedName(&esc);
		}

        Edit_SetModify(esc.rghwndEdit[i], FALSE);
	}

	SpecialAdrlistScan(ppal, &iae, esc.cRecipTypes, esc.rgulDestComps, FALSE);

Cleanup:
	if (esc.fTruncated)
		MessageBeep(MB_OK);

	delete esc.rgulDestComps;
	delete esc.rghwndEdit;
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(preole);
	RRETURN(esc.hr);

MemoryError:
	esc.hr = g_LastError.SetLastError(E_OUTOFMEMORY);
	goto Cleanup;
}



/*
 *	UnresolvedStream
 *	
 *	Purpose:
 *		this is the callback function handed to the edit control
 *		for outputing a stream of text.
 *	
 *	Parameters:
 *		dwCookie		cookie which contains a pointer to a
 *						EDITSTREAMCOOKIE structure
 *		pbBuff			a bunch of characters
 *		cb				count of bytes in pbBuff
 *		pcb				exit: count of bytes read (regardless of error)
 *	
 *	Returns:
 *		hr
 */
DWORD FAR CALLBACK UnresolvedStream(DWORD dwCookie, LPBYTE pbBuff, LONG cb,
						LONG *pcb)
{
	HRESULT hr = S_OK;
	EDITSTREAMCOOKIE *	pesc = (EDITSTREAMCOOKIE *) dwCookie;

	*pcb = cb;

	//$ BUG - broken for Unicode

	// The algorithm below will strip spaces off of the
	// beginning and end of each name

	while (cb)
	{
		cb--;

		if (*pbBuff == '[')
			++pesc->nBrackets;
		else if (*pbBuff == ']')
			pesc->nBrackets = max(0, pesc->nBrackets - 1);
		else if (*pbBuff == '\t')
			*pbBuff = ' ';

		if (!pesc->nBrackets && (*pbBuff == ';' || *pbBuff == '\r'))
		{
			hr = THR(AddUnresolvedName(pesc));
			if (hr != S_OK)
				goto err;
		}
		else if ((*pbBuff != ' ' && *pbBuff != '\n' && *pbBuff != '\r')
					|| pesc->cchBuf > 0)
		{
			if (pesc->cchBuf < cchUnresolvedMax - 1)
			{
				pesc->rgch[pesc->cchBuf++] = *pbBuff;
			}
			else
			{
				// Truncation has occurred so I want to beep
				pesc->fTruncated = TRUE;
			}
		}
		++pbBuff;
	}

err:
	*pcb -= cb;

	return (DWORD) hr;
}

/*
 *	AddUnresolvedName
 *	
 *	Purpose:
 *		This function adds an entry to the ADRLIST in pesc as a
 *		entry with only a PR_DISPLAY_NAME_A
 *	
 *	Parameters:
 *		pesc		ponter to EDITSTREAMCOOKIE data
 *	
 *	Returns:
 *		hr
 */
static HRESULT AddUnresolvedName(EDITSTREAMCOOKIE * pesc)
{
	HRESULT		hr;
	ADRENTRY	ae;

 	while (pesc->cchBuf > 0 && (pesc->rgch[pesc->cchBuf - 1] == ' '
								|| pesc->rgch[pesc->cchBuf - 1] == '\t'))
 		--pesc->cchBuf;

	if (pesc->cchBuf)
	{
		pesc->rgch[pesc->cchBuf] = '\0';
		ae.cValues = 2;
		hr = MAPIAllocateBuffer(2 * sizeof(SPropValue)
					+ pesc->cchBuf + 1, (void**)&ae.rgPropVals);
		if (hr != S_OK)
			goto Error;

		ae.rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
		ae.rgPropVals[0].Value.lpszA = (LPSTR) &ae.rgPropVals[2];
		ae.rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
		ae.rgPropVals[1].Value.l = pesc->rgulDestComps[pesc->iRecipType];

		lstrcpyA(ae.rgPropVals[0].Value.lpszA, pesc->rgch);

		hr = SpecialAdrlistScan(pesc->ppal, pesc->piae,
					pesc->cRecipTypes, pesc->rgulDestComps, TRUE);
		if (hr != S_OK)
			goto Error;

		(*pesc->ppal)->aEntries[*pesc->piae] = ae;

		pesc->cchBuf = 0;
	}

	return S_OK;

Error:
	pesc->hr = hr;
	RRETURN(hr);
}


/*
 *	GrowAdrlist
 *	
 *	Purpose:
 *		This function will grow an existing ADRLIST or create a new
 *		one. caeToAdd empty ADRENTRY's is our goal.
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST (could be pointer to
 *						NULL)
 *		caeToAdd		count of ADRENTRY's to add
 *	
 *	Returns:
 *		sc
 */
static HRESULT GrowAdrlist(LPADRLIST * ppal, UINT caeToAdd)
{
	HRESULT         hr = S_OK;
	ULONG			i;
	UINT			cb;
	LPADRLIST		pal		= *ppal;
	LPADRENTRY		pae;

	cb = sizeof(ADRLIST) + caeToAdd * sizeof(ADRENTRY);
	if (pal)
		cb += (UINT) pal->cEntries * sizeof(ADRENTRY);

	hr = THR(MAPIAllocateBuffer(cb, (void**)&pal));
	if (hr)
	{
        hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	if (*ppal)
	{
		CopyMemory(pal, *ppal,
			sizeof(ADRLIST) + (UINT) (*ppal)->cEntries * sizeof(ADRENTRY));
		MAPIFreeBuffer(*ppal);
	}
	else
		pal->cEntries = 0;

	*ppal = pal;

	// Mark new ADRENTRY's as empty

	for (i = 0; i < caeToAdd; i++)
	{
		pae = &pal->aEntries[pal->cEntries++];

		pae->cValues = 0;
		pae->rgPropVals = NULL;
	}

Cleanup:
	RRETURN(hr);
}

/*
 *	AddRecipientToAdrlist
 *	
 *	Purpose:
 *		This functions add a recipient to a (possibly NULL) adrlist
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST
 *		pae				pointer to ADRENTRY
 *		pulIndex		pointer where index of recipient in adrlist will be returned
 *						- can be null if caller not interested
 *	
 *	Returns:
 *		sc
 */
HRESULT AddRecipientToAdrlist(LPADRLIST * ppal, LPADRENTRY pae, ULONG *pulIndex)
{
	HRESULT	        hr = S_OK;
	ULONG			iae		= 0;
	LPADRLIST		pal		= *ppal;

	if (pal)
	{
		while (iae < pal->cEntries)
		{
			if (!pal->aEntries[iae++].rgPropVals)
			{
				pal->aEntries[iae - 1] = *pae;
				if (pulIndex)
					*pulIndex = iae - 1;
				return S_OK;
			}
		}
	}

	// We couldn't find an empty ADRENTRY so we'll
	// have to grow the ADRLIST (or create one)

	hr = THR(GrowAdrlist(ppal, 1));
	if (hr)
		goto Cleanup;

	(*ppal)->aEntries[(*ppal)->cEntries - 1] = *pae;
	if (pulIndex)
		*pulIndex = (*ppal)->cEntries - 1;

Cleanup:
	RRETURN(hr);
}

/*
 *	ScBuildSelectionAdrlist
 *	
 *	Purpose:
 *		This function will add all the resolved and unresolved
 *		names from the selection in an edit control to an ADRLIST
 *	
 *	Parameters:
 *		ppal			pointer to pointer to ADRLIST
 *		hwndEdit		hwnd of the edit control
 *		pchrg			CHARRANGE of the selection
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::BuildSelectionAdrlist(LPADRLIST * ppal, HWND hwndEdit,
								CHARRANGE * pchrg)
{
	HRESULT	        hr          = S_OK;
	ULONG			iOb;
	ULONG			cOb;
	ADRENTRY		ae;
	ULONG			iae			= 0;
	LPRICHEDITOLE	preole		= NULL;
	REOBJECT		reobj		= { 0 };
	ULONG			cb;
	char			rgch[cchUnresolvedMax];
	LPBYTE			pbStart;
	LPBYTE			pbSel;
	ULONG			cchBuf		= 0;
	INT				nBrackets	= 0;
	BOOL			fTruncated	= FALSE;
	const ULONG		cchSel = pchrg->cpMax - pchrg->cpMin;
	TEXTRANGEA		txtrg;

	reobj.cbStruct = sizeof(REOBJECT);
	pbStart = pbSel = new BYTE[cchSel + 1];
	if (!pbSel)
		goto MemoryError;

    memset(pbSel, 0, cchSel + 1);

	// Add all the resolved names (stored as OLE objects) from
	// hwndEdit to the ADRLIST

	Verify(SendMessage(hwndEdit, EM_GETOLEINTERFACE, 
									(WPARAM) NULL, (LPARAM) &preole));

	cOb = preole->GetObjectCount();
	hr = THR(GrowAdrlist(ppal, (UINT) min(cOb, cchSel)));
	if (hr != S_OK)
		goto Cleanup;

	for (iOb = 0; iOb < cOb; iOb++)
	{
		hr = THR(preole->GetObject(iOb, &reobj,	REO_GETOBJ_POLEOBJ));
		if (hr != S_OK)
			goto MemoryError;

		if (reobj.cp >= pchrg->cpMax)
			break;

		if (reobj.cp >= pchrg->cpMin)
		{
			hr = THR(CopyRow(NULL, &((CTriple*)reobj.poleobj)->_rw,
									(LPSRow) &(*ppal)->aEntries[iae++]));
			if (hr != S_OK)
				goto Cleanup;
		}

		ClearInterface(&reobj.poleobj);
	}

	// Add all the unresolved names to the ADRLIST

	// Exchange 4369: Need to use the actual CHARRANGE passed in. Don't assume
	//				  the current selection is correct.
	txtrg.chrg = *pchrg;
	txtrg.lpstrText = (char*)pbSel;
	cb = SendMessageA(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM) &txtrg) + 1;

	//$ BUG - broken for Unicode

	// The algorithm below will strip spaces off of the
	// beginning and end of each name

	while (cb--)
	{
		if (*pbSel == '[')
			++nBrackets;
		else if (*pbSel == ']')
			nBrackets = max(0, nBrackets - 1);
		else if (*pbSel == '\t')
			*pbSel = ' ';

		if (*pbSel == '\0' ||
			(!nBrackets && (*pbSel == ';' || *pbSel == '\r')))
		{
 			while (cchBuf > 0 && (rgch[cchBuf - 1] == ' '
										|| rgch[cchBuf - 1] == '\t'))
 				--cchBuf;

			if (cchBuf)
			{
				rgch[cchBuf] = '\0';
				ae.cValues = 2;
				hr = THR(MAPIAllocateBuffer(2 * sizeof(SPropValue)
								+ cchBuf + 1, (void**)&ae.rgPropVals));
				if (hr != S_OK)
					goto MemoryError;

				ae.rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
				ae.rgPropVals[0].Value.lpszA = (LPSTR) &ae.rgPropVals[2];
				ae.rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
				ae.rgPropVals[1].Value.l = -1;

				lstrcpyA(ae.rgPropVals[0].Value.lpszA, rgch);

				if (iae == (*ppal)->cEntries)
				{
					hr = THR(GrowAdrlist(ppal, 5));
					if (hr != S_OK)
						goto Cleanup;
				}

				(*ppal)->aEntries[iae++] = ae;

				cchBuf = 0;
			}
		}
		else if (((*pbSel != ' ' && *pbSel != '\n' && *pbSel != '\r')
					|| cchBuf > 0) && !fTruncated)
		{
			if (cchBuf < cchUnresolvedMax - 1)
				rgch[cchBuf++] = *pbSel;
			else
				fTruncated = TRUE;
		}
		++pbSel;
	}

Cleanup:
	if (fTruncated)
		MessageBeep(MB_OK);

	if (*ppal)
		(*ppal)->cEntries = iae;

	delete pbStart;
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(preole);
	RRETURN(hr);

MemoryError:
	hr = g_LastError.SetLastError(hr);
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgdoc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgdoc.cxx
//
//  Contents:   CPadMessage implementation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

__declspec(thread)  static BOOL      s_fModalUp = FALSE;
__declspec(thread)  static BOOL      s_fMBoxUp = FALSE;
__declspec(thread)  static HWND      s_hwndUp = NULL;

// ISSUE: chrisf - should this really be thread local ?
__declspec(thread)  static HINSTANCE s_hInstRichEd32 = NULL;

// ISSUE: the following should be thread local when we use different threads
// for each mail message
static BOOL         s_fMapiInitialized = FALSE;
CLastError *        g_pLastError = NULL;

TCHAR g_achFormName[] = SZ_APPLICATION_NAME TEXT(" Exchange Form");
TCHAR g_achWindowCaption[] = TEXT("Microsoft Trident Form");
char  g_achFormClassName[] = "IPM.Note.Trident";
char  g_achPlainTextHeader[] = "[This is an HTML message written with "
                         "Microsoft Trident " VER_PRODUCTVERSION_STR ". You are "
                         "reading a plain text version of the original HTML.]";

static HRESULT
CreateMessage(IUnknown **ppUnk)
{
    HRESULT hr = S_OK;

    // ISSUE -
    // Currently, messages are created on the main thread only.  If messages are
    // created on multiple threads then s_fMapiInitialized must b moved to thread
    // local storage and mapi must be initialized for each thread.

    if (!s_fMapiInitialized)
    {
        hr = THR(MAPIInitialize(NULL));
        if (hr)
            RRETURN(hr);

        s_fMapiInitialized = TRUE;

        Assert(!g_pLastError);

        g_pLastError = new CLastError();
        if (!g_pLastError)
        {
            hr= E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = g_pLastError->Init(g_achFormName);
        if (hr)
            goto Cleanup;
    }

    Assert(g_pLastError);
    
    if(!s_hInstRichEd32)
    {
        s_hInstRichEd32 = LoadLibraryEx(TEXT("RICHED32.DLL"), NULL, 0);
    }

    *ppUnk = (IMAPIForm *)new CPadMessage();

    if (!*ppUnk)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

void RevokeMsgFact()
{
    if (s_fMapiInitialized)
        MAPIUninitialize();

    if (g_pLastError)
        delete g_pLastError;
}


CPadFactory Factory(CLSID_CPadMessage, CreateMessage, RevokeMsgFact);

BOOL CALLBACK FormDlgProcSend(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FormDlgProcRead(HWND, UINT, WPARAM, LPARAM);

SizedSPropTagArray(cPropReadMsg, tagaRead) = {cPropReadMsg, {MESSAGE_TAGS}};

CPadMessage::CPadMessage()
{
    // FormBase
    _state = stateUninit;
}

CPadMessage::~CPadMessage()
{

    //formBase Release ()

    MAPIFreeBuffer(_pval);

    FreePadrlist(_padrlist);

    MAPIFreeBuffer(_lpbConvIdx);

    if (_hChsFldDll)
        FreeLibrary(_hChsFldDll);

    MAPIFreeBuffer(_pbCFDState);
}   

HRESULT
CPadMessage::QueryInterface(REFIID iid, void **ppvObj)
{
    if (CPadDoc::QueryInterface(iid, ppvObj) == E_NOINTERFACE)
    {
        if (iid == IID_IMAPIForm)
        {
            *ppvObj = (LPVOID) (IMAPIForm *) this;
        }
        else if (iid == IID_IPersistMessage)
        {
            *ppvObj = (LPVOID) (IPersistMessage *) this;
        }
        else if (iid == IID_IMAPIFormAdviseSink)
        {
            *ppvObj = (LPVOID) (IMAPIFormAdviseSink *) this;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }

        ((IUnknown *)*ppvObj)->AddRef();
    }

    return S_OK;
}

void
CPadMessage::Passivate()
{

    //
    //  Release the view context
    //

    if (_pviewctx != NULL)
    {
        _pviewctx->SetAdviseSink(NULL);
        _pviewctx->Release();
        _pviewctx = NULL;
    }

    //
    //  Release message objects if we have them
    //

    if (s_fModalUp)
        _pviewctxOverride = NULL;

    ReleaseInterface(_pmsg);
    _pmsg = NULL;

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    ReleaseInterface(_pab);
    _pab = NULL;

    ReleaseInterface(_pses);
    _pses = NULL;

    //
    //  Tell all objects to be closed and de-initialized, only IUnknown
    //          calls are legal after this.
    //

    Assert(_pmsg == NULL);
    Assert(_pmsgsite == NULL);
    Assert(_pviewctx == NULL);
    Assert(_pviewctxOverride == NULL);
    Assert(_pab == NULL);
    Assert(_pses == NULL);

    _state = stateDead;

    //
    //  Now deinit paddoc
    //

    CPadDoc::Passivate();

}

///////////////////////////////////////////////////////////////////////////////
//
//  IMAPIForm interface
//
///////////////////////////////////////////////////////////////////////////////


////    IMAPIForm::SetViewContext
//
//

STDMETHODIMP CPadMessage::SetViewContext(IN IMAPIViewContext * pvc)
{

    //
    //  If we currently have a view context, then release it
    //

    if (_pviewctx != NULL)
    {
        _pviewctx->SetAdviseSink(NULL);
        _pviewctx->Release();
    }

    //
    // Accept the new view context.
    //

    _pviewctx = pvc;

    //
    //  If the new view context is non-null, then save it away, setup
    //  the advise sink back to check for things and get the current set
    //  of status flags
    //

    _ulViewStatus = 0;
    if (pvc != NULL)
    {
        _pviewctx->AddRef ();
        _pviewctx->SetAdviseSink (this);
        _pviewctx->GetViewStatus(&_ulViewStatus);
    }

    ConfigWinMenu();

    return S_OK;
}


////    IMAPIForm::GetViewContext
//

STDMETHODIMP CPadMessage::GetViewContext(OUT IMAPIViewContext * FAR * ppvc)
{
    Assert(ppvc);

    *ppvc = _pviewctx;

    if (_pviewctx != NULL)
    {
        _pviewctx->AddRef();
        return S_OK;
    }
    else
        return ResultFromScode(S_FALSE);
}


////    IMAPIForm::ShutdownForm
//
//  Description:
//      This routine is called to shut down the form and if necessary
//      to cause save changes to the form.
//

STDMETHODIMP CPadMessage::ShutdownForm(DWORD dwSaveOptions)
{
    HRESULT hr;

    //
    //  Check for valid state to make the call
    //

    switch( _state )
    {
        default:
        case stateDead:
            _viewnotify.OnShutdown ();
            return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));

        case stateUninit:
        case stateNormal:
        case stateNoScribble:
        case stateHandsOffFromSave:
        case stateHandsOffFromNormal:
            break;
    }

    hr = THR(QuerySave(dwSaveOptions));

    if (hr == S_FALSE)
        return MAPI_E_USER_CANCEL;

    // Notify viewer that we are going down
    _viewnotify.OnShutdown ();

    // Hide the document to remove the user's reference count.
    this->ShowWindow(SW_HIDE);

    RRETURN(hr);
}


////    IMAPIForm::DoVerb
//

STDMETHODIMP CPadMessage::DoVerb(LONG iVerb, LPMAPIVIEWCONTEXT pviewctx,
                               ULONG hwndParent, LPCRECT lprcPosRect)
{
    HRESULT             hr;

    //
    //  If a view context was passed in, then we need to get the
    //  status bits from this view context.  Also we are going to save
    //  the current view context and use this view context for the
    //  duration of the verb execution.
    //

    if (pviewctx != NULL)
    {
        _pviewctxOverride = pviewctx;
        pviewctx->GetViewStatus(&_ulViewStatus);
    }

    //
    //   Execute the requested verb.  If we do not understand the verb
    //  or we do not support the verb then we return NO SUPPORT and let
    //  the viewer deal with this.
    //

    switch (iVerb)
    {

    case EXCHIVERB_OPEN:
        hr = THR(OpenForm((HWND) hwndParent, lprcPosRect, _ulViewStatus));
        break;

    case EXCHIVERB_REPLYTOSENDER:
        hr = THR(Reply(eREPLY, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_REPLYTOALL:
        hr = THR(Reply(eREPLY_ALL, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_FORWARD:
        hr = THR(Reply(eFORWARD, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_PRINT:
    case EXCHIVERB_SAVEAS:
    case EXCHIVERB_REPLYTOFOLDER:
        //the viewer should not call us here
        //(see Value in extensions section of smpfrm.cfg)
        Assert(FALSE);

    default:
        hr = THR(g_LastError.SetLastError(ResultFromScode(MAPI_E_NO_SUPPORT)));
        break;
    }

    //
    //  If we moved to a different view context, then switch back to
    //  the one we started with.
    //

    _pviewctxOverride = NULL;

    if (_pviewctx != NULL)
    {
        _ulViewStatus =0;
        _pviewctx->GetViewStatus(&_ulViewStatus);
        ConfigWinMenu();
    }

    RRETURN(hr);
}


////    IMAPIForm::Advise
//

STDMETHODIMP CPadMessage::Advise (IN IMAPIViewAdviseSink * pViewAdvise,
                                OUT ULONG FAR * pulConnection)
{
    HRESULT     hr;

    hr = THR(_viewnotify.Advise (pViewAdvise, pulConnection));
    if (FAILED(hr))
    {
        hr = THR(g_LastError.SetLastError(hr));
    }
    RRETURN(hr);
}


////    IMAPIForm::Unadvise
//

STDMETHODIMP CPadMessage::Unadvise(ULONG ulConnection)
{
    HRESULT     hr;

    hr = THR(_viewnotify.Unadvise(ulConnection));
    if (FAILED(hr))
    {
        hr = THR(g_LastError.SetLastError(hr));
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////////////////////
//
//  IPersistMessage interface
//
///////////////////////////////////////////////////////////////////////////////

////    IPersistMessage::GetClassID

STDMETHODIMP CPadMessage::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CPadMessage;
    return S_OK;
}


////  IPersistMessage::GetLastError
//
//  Description:  This routine is used to get back a string giving more
//              information about the last error in the form.
//

STDMETHODIMP CPadMessage::GetLastError(HRESULT hr, ULONG ulFlags,
                                     LPMAPIERROR FAR * lppMAPIError)
{
    return g_LastError.GetLastError(hr, ulFlags, lppMAPIError);
}


////    IPersistMessage::IsDirty
//

STDMETHODIMP CPadMessage::IsDirty ()
{
    IPersistFile *pPF = NULL;

    if (_fDirty)
        return ResultFromScode(S_OK);

    _fDirty = GetDirtyState();

    return ResultFromScode ((_fDirty ? S_OK : S_FALSE));
}

BOOL
CPadMessage::GetDirtyState()
{
    BOOL fDirty = FALSE;

    fDirty = CPadDoc::GetDirtyState();

    if (_hwndDialog && _eFormType == eformSend)
    {
        fDirty = fDirty ||
                 _fRecipientsDirty ||
                 Edit_GetModify(GetDlgItem(_hwndDialog, ID_SUBJECT)) ||
                 AreWellsDirty();
    }

    return fDirty;
}

BOOL 
CPadMessage::AreWellsDirty()
{
    BOOL fDirty = FALSE;

    if (_hwndDialog && _eFormType == eformSend)
    {
        fDirty = Edit_GetModify(GetDlgItem(_hwndDialog, ID_TO)) ||
                 Edit_GetModify(GetDlgItem(_hwndDialog, ID_CC));
    }

    return fDirty;
}


////  IPersistMessage::InitNew
//
//  Description: This function is called in the case of composing a new
//      message.  There is a small set of properties which are set by
//      the constructor of the message, however in general it can be
//      assumed the message is clean.
//

STDMETHODIMP CPadMessage::InitNew(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg)
{
    HRESULT hr = S_OK;

    //
    //  Ensure we are in a state where we can accept this call
    //

    switch(_state)
    {
    case stateUninit:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    //
    //  If we currently have a message site, then release it as we
    //  will no longer be using it.
    //

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    //
    //  Save away the pointers to the message and message site
    //

    _pmsgsite = pmsgsite;
    pmsgsite->AddRef();

    _ulSiteStatus = 0;
    _pmsgsite->GetSiteStatus(&_ulSiteStatus);

    _pmsg = pmsg;
    pmsg->AddRef();

    //
    //  Make an assumption on the message flags and status
    //

    _ulMsgStatus = 0;
    _ulMsgFlags = MSGFLAG_UNSENT;

    if (_hwnd)
    {
        hr = THR(DisplayMessage());
        if (hr)
            goto Cleanup;
    }

    //
    //  We succeeded in doing the InitNew so move to the normal state
    //

    _state = stateNormal;

    //
    //  Tell everybody who cares that we just loaded a new message
    //

    _viewnotify.OnNewMessage();

    _fNewMessage = TRUE;

Cleanup:
    RRETURN(hr);
}

//// IPersistMessage::Load
//
//  Description:  This routine is called as part of loading an existing
//      message into the form.
//

STDMETHODIMP CPadMessage::Load(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg,
                             ULONG ulMsgStatus, ULONG ulMsgFlags)
{
    HRESULT hr = S_OK;

    //
    //  Ensure we are in a state where we can accept this call
    //

    switch(_state)
    {
    case stateUninit:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    //
    //  If we currently have a message site, then release it as we
    //  will no longer be using it.
    //

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    ReleaseInterface(_pmsg);
    _pmsg = NULL;


    hr = THR(GetMsgDataFromMsg(pmsg, ulMsgFlags));
    if (FAILED(hr))
        goto err;

    //
    //  Save away the message and message site which are passed in.
    //

    _pmsg = pmsg;
    pmsg->AddRef();

    _pmsgsite = pmsgsite;
    pmsgsite->AddRef();

    //
    //  Get the site status flags for disabling buttons & menus
    //
    _ulSiteStatus = 0;
    _pmsgsite->GetSiteStatus(&_ulSiteStatus);

    //
    //  Save away these properties
    //

    _ulMsgStatus = ulMsgStatus;
    _ulMsgFlags = ulMsgFlags;

    //
    //  Put us into the normal state
    //

    _state = stateNormal;


    //
    //  if our form is up, display the message
    //
    if (_hwnd)
    {
        hr = THR(DisplayMessage());
        if (hr)
            goto err;
    }

    //
    //  Tell everybody who cares that we just loaded a new message
    //

    _viewnotify.OnNewMessage();

    _fNewMessage = FALSE;

err:
    RRETURN(hr);
}

////    IPersistMessage::Save
//
//  Description:
//      This function will be called whenever a save operation of the
//      information into the form should be done.  We should only make
//      modifications to the message in this function.
//

STDMETHODIMP CPadMessage::Save(IN LPMESSAGE pmsg, IN ULONG fSameAsLoad)
{
    HRESULT             hr;

    //
    //  Check that we are in a state where we are willing to accept
    //  this call.  Must have a message.
    //

    switch( _state )
    {
    default:
        Assert(FALSE);
    case stateDead:
    case stateUninit:
    case stateNoScribble:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));

    case stateNormal:
        break;
    }

    if (fSameAsLoad)
    {
        //
        //  Its the same message interface as was loaded into us.  We can
        //      assume that the pmsg passed in is either NULL or an interface
        //      on the same object as the message we already have loaded
        //

        hr = THR(SaveInto(_pmsg));
    }
    else
    {
        //
        //  We need to copy everything into the new message as we are going
        //      to clone ourselves into it.
        //

        hr = THR(_pmsg->CopyTo(0, NULL, NULL, 0, NULL, &IID_IMessage, pmsg, 0, NULL));
        if (FAILED(hr))
        {
            g_LastError.SetLastError(hr, _pmsg);
            RRETURN(hr);
        }

        //
        //  Now make all of the incremental changes
        //

        hr = THR(SaveInto(pmsg));
    }

    if (hr)
        goto Cleanup;

    _state = stateNoScribble;
    _fSameAsLoaded = fSameAsLoad;
    _fNewMessage = FALSE;

Cleanup:
    RRETURN(hr);
}


////    IPersistMessage::SaveCompleted
//
//


STDMETHODIMP CPadMessage::SaveCompleted(IN LPMESSAGE pmsg)
{

    switch( _state )
    {
    case stateHandsOffFromNormal:
    case stateHandsOffFromSave:
    case stateNoScribble:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    if ((stateHandsOffFromNormal == _state ||
        stateHandsOffFromSave == _state)  && NULL == pmsg)
    {
        //DebugTrace("smpfrm: SaveCompleted called in handsOff state with pmsg==NULL\r\n");
        return  g_LastError.SetLastError(ResultFromScode(E_INVALIDARG));
    }

    ULONG ulOldState = _state;
    _state = stateNormal;

    //state == NoScribble , pmsg == NULL
    if (NULL == pmsg)
    {
        if (_fSameAsLoaded)
        {
            ClearDirty();
            _viewnotify.OnSaved();
        }

        return S_OK;
    }


    //state == handsOffFromNormal, pmsg != NULL
    if (stateHandsOffFromNormal == ulOldState)
    {
        ReleaseInterface(_pmsg);
        _pmsg = pmsg;
        pmsg->AddRef();

        return S_OK;
    }

    //state == handsOffFromSave || NoScribble, pmsg != NULL
    if (stateNoScribble == ulOldState ||
        stateHandsOffFromSave == ulOldState)
    {
        ReleaseInterface(_pmsg);
        _pmsg = pmsg;
        pmsg->AddRef();
    }

    _viewnotify.OnSaved();
    ClearDirty();

   return S_OK;
}


////  IPersistMessage::HandsOffMessage
//
//  Description: store, folder and message objects has to be released
//              in this method.
//
//

STDMETHODIMP CPadMessage::HandsOffMessage ()
{

    switch( _state )
    {
    case stateNormal:
    case stateNoScribble:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    if (stateNormal == _state)
        _state = stateHandsOffFromNormal;
    else
        _state = stateHandsOffFromSave;

    //
    //  We must have a message
    //

    Assert(_pmsg != NULL);
    _pmsg->Release();
    _pmsg = NULL;


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
//  IMAPIFormAdviseSink interfaces
//
///////////////////////////////////////////////////////////////////////////////



////    IMAPIFormAdviseSink::OnChange
//
//  Description: called to notify about changes in viewctx status

STDMETHODIMP CPadMessage::OnChange(ULONG ulflag)
{
    if (_pviewctxOverride == NULL)
    {
        _ulViewStatus = ulflag;
        ConfigWinMenu();
    }

    return S_OK;
}

////    CPadMessage::OnActivateNext
//
//  Description:  We only say that we will handle the next message if
//              it is the exact same message class as the current message.
//              If the next message has the same "unsentness" will reuse the
//              current object, otherwise ask our ClassFactory for a new one.
//

STDMETHODIMP CPadMessage::OnActivateNext(LPCSTR lpszMessageClass, ULONG ulMessageStatus,
                                        ULONG ulMessageFlags,
                                       LPPERSISTMESSAGE FAR * ppPersistMessage)
{
    HRESULT hr;
    //TCHAR pwchMessageClass[128];

    *ppPersistMessage = NULL;

    Assert(_pval);

    //MultiByteToWideChar(CP_ACP, 0, lpszMessageClass, -1, pwchMessageClass, sizeof(pwchMessageClass));

    if (PR_MESSAGE_CLASS_A == _pval[irtClass].ulPropTag)
    {
        //the message class comparison has to be case insensitive
        if ((lstrcmpiA(_pval[irtClass].Value.lpszA, lpszMessageClass) != 0) &&
            lstrcmpiA(g_achFormClassName, lpszMessageClass) != 0)
        {
            return ResultFromScode(S_FALSE);
        }
    }
    else
    {
        if (lstrcmpiA(g_achFormClassName, lpszMessageClass) != 0)
        {
            return ResultFromScode(S_FALSE);
        }
    }


    if ((_ulMsgFlags & MSGFLAG_UNSENT) == (ulMessageFlags & MSGFLAG_UNSENT))
        //tell the viewer to reuse our object
        return ResultFromScode(S_OK);


    //Get a new object from our class factory
    hr = THR(Factory.CreateInstance(NULL, IID_IPersistMessage, (LPVOID FAR *)ppPersistMessage));
    if (hr)
        return ResultFromScode (S_FALSE);
    else
        return ResultFromScode(S_OK);
}


///////////////////////////////////////////////////////////////////////////////
//
//  Non-IMAPIinterface functions
//
///////////////////////////////////////////////////////////////////////////////


///     CPadMessage::GetMsgDataFromMsg
//
//      fills in _pval (for unsent msgs only)
//      with the info from pmsg
HRESULT CPadMessage::GetMsgDataFromMsg(LPMESSAGE pmsg, ULONG ulMsgFlags)
{
    Assert(pmsg);

    ULONG   cValues = 0;
    MAPIFreeBuffer(_pval);
    _pval = NULL;

    MAPIFreeBuffer(_lpbConvIdx);
    _lpbConvIdx = NULL;

    // Get properties from message

    HRESULT hr = THR(pmsg->GetProps((LPSPropTagArray) &tagaRead, 0,
                                    &cValues, &_pval));
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    Assert(cValues ==  cPropReadMsg);

    // Ignore errors on individual properties

    if (hr == MAPI_W_ERRORS_RETURNED)
    {
        hr = S_OK;
    }

    // Cache conversation index

    if (PR_CONVERSATION_INDEX == _pval[irtConvIdx].ulPropTag)
    {
        LPSPropValue pval = &_pval[irtConvIdx];

        _cbConvIdx = pval->Value.bin.cb;
        if (MAPIAllocateBuffer(_cbConvIdx, (LPVOID *)&_lpbConvIdx))
        {
            _lpbConvIdx = NULL;
            _cbConvIdx = 0;
        }
        else
        {
            CopyMemory(_lpbConvIdx, pval->Value.bin.lpb, _cbConvIdx);
        }
    }
    else
    {
        _lpbConvIdx = NULL;
        _cbConvIdx = 0;
    }

    _fConvTopicSet = (PR_CONVERSATION_TOPIC_A == _pval[irtConvTopic].ulPropTag);

    // If message yet unsent, cache recipient list so that user
    // can add or remove recipients

    if (ulMsgFlags & MSGFLAG_UNSENT)
    {
        hr = THR(GetMsgAdrlist(pmsg, (LPSRowSet *)&_padrlist, &g_LastError));
        if (FAILED(hr))
        {
            goto err;
        }
    }

    RRETURN(hr);

err:
    MAPIFreeBuffer(_pval);
    _pval = NULL;

    FreePadrlist(_padrlist);
    _padrlist = NULL;

    RRETURN(hr);
}

///         CPadMessage::ClearDirty
//
//      Clears dirty state
void CPadMessage::ClearDirty(void)
{
    _fDirty = FALSE;
    _fRecipientsDirty = FALSE;

    if (_eFormType == eformSend)
    {
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_SUBJECT), FALSE);
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_TO), FALSE);
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_CC), FALSE);
    }
}


HRESULT CPadMessage::OpenAddrBook()
{
    HRESULT hr = S_OK;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            goto Cleanup;
        }
    }
    
    Assert(_pses != NULL);

    if (_pab == NULL)
    {
        hr = THR(_pses->OpenAddressBook((ULONG) _hwnd, NULL, 0, &_pab));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pses);
            if (FAILED(hr)) //if it's a real error (not a warning)
                goto Cleanup; 
        }
    }
    
    Assert(_pab != NULL);

Cleanup:
    RRETURN1(hr, MAPI_W_ERRORS_RETURNED);
}

////    CPadMessage::Address
//
//  Description:
//      This function is used to address the form.
//      The parameter determines which button in the address
//      dialog has the focus.
//

void CPadMessage::Address(int id)
{
    Assert( ID_TO_BUTTON == id || ID_CC_BUTTON == id);

    HRESULT hr;

    hr = THR(OpenAddrBook());
    if (hr)
    {
        ShowError();
        if (FAILED(hr))
            return;
    }

    // ISSUE: chrisf - total hack below casting char[] to LPSTR
    // Mapi seems to work only with Ansi though the header files
    // contain UNICODE declarations on UNICODE platform !!!
    ADRPARM adrparm = { 0, NULL, AB_RESOLVE | DIALOG_MODAL, NULL, 0L,
                        NULL, NULL, NULL, NULL, (LPTSTR)"Address Book", NULL,
                        (LPTSTR)"Send Note To", 2, (id == ID_TO_BUTTON ? 0:1),
                        NULL, NULL, NULL, NULL };

    ULONG   ulHwndAddr = (ULONG) _hwnd;

    hr = THR(_pab->Address(&ulHwndAddr, &adrparm, &_padrlist));
    if (!hr)
    {
        DisplayRecipients(TRUE);
    }
    else if (hr != MAPI_E_USER_CANCEL)
    {
        g_LastError.SetLastError(hr, _pab);
        ShowError();
    }

}

////  CPadMessage::OpenForm
//
//  Description:  This is the internal routine which is called from the
//      open/display verb.  It will cause UI to appear if there is none
//      and force the window to the foreground if there is already UI.
//

HRESULT CPadMessage::OpenForm(HWND hwndParent, LPCRECT lprcPosRect,
                              ULONG ulViewFlags)
{
    HRESULT hr = S_OK;

    if (lprcPosRect == NULL)
        return g_LastError.SetLastError(ResultFromScode(E_INVALIDARG));

    //
    //  If any modal forms are visible then do not do anything
    //

    Assert( s_fModalUp && s_hwndUp || !s_fModalUp && !s_hwndUp);
    if (s_fMBoxUp || (s_fModalUp && hwndParent != s_hwndUp))
        return g_LastError.SetLastError(
                               ResultFromScode(OLEOBJ_S_CANNOT_DOVERB_NOW));

   if (!(ulViewFlags & VCSTATUS_MODAL))
    {
        //  If we are not modal then don't do anything relative to the parent
        hwndParent = NULL;
    }

    //
    //  Check to see if we have a window up
    //

    if (_hwnd != 0)
    {
        ::MoveWindow(_hwnd, lprcPosRect->left, lprcPosRect->top,
                   lprcPosRect->right - lprcPosRect->left,
                   lprcPosRect->bottom - lprcPosRect->top,
                   TRUE);
    }
    else
    {

        hr = THR(RegisterPadWndClass());
        if (hr)
            return g_LastError.SetLastError(ResultFromScode(hr));

        _hwnd = CreateWindowEx(0,
                              SZ_PAD_WNDCLASS,
                              g_achWindowCaption,
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              lprcPosRect->left,
                              lprcPosRect->top,
                              lprcPosRect->right - lprcPosRect->left,
                              lprcPosRect->bottom - lprcPosRect->top,
                              hwndParent,
                              NULL,
                              g_hInstCore,
                              this);

        if (_hwnd == NULL)
        {
            return g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
        }

        //
        //  Create the dialog as a child of this window
        //

        if (_ulMsgFlags & MSGFLAG_UNSENT)
        {
            _eFormType = eformSend;
            _hwndDialog = CreateDialog(g_hInstCore, MAKEINTRESOURCE(IDR_SEND_FORM),
                                        _hwnd, &FormDlgProcSend);
            _HAccelTable = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_SEND_FORM));

            _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_SEND_FORM));

            _fUserMode = FALSE;
        }
        else
        {
            _eFormType = eformRead;

            InitReadToolbar();

            _hwndDialog = CreateDialog(g_hInstCore, MAKEINTRESOURCE(IDR_READ_FORM),
                                        _hwnd, &FormDlgProcRead);
            _HAccelTable = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_READ_FORM));

            _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_READ_FORM));

            _fUserMode = TRUE;
        }

        SetMenu(_hwnd, _hmenuMain);
    }

    //
    //  Stuff message into form
    //

    hr = THR(DisplayMessage());
    if (hr)
        goto Cleanup;

    //
    //  Position the window where it is supposed to be
    //

    this->ShowWindow(SW_SHOW);

    SetForegroundWindow(_hwnd);

    //
    //  If we are modal, then we loop until the form is closed
    //

    if (ulViewFlags & VCSTATUS_MODAL)
    {
        MSG         msg;

        BOOL fOldModalUp = s_fModalUp;
        HWND hwndOldUp = s_hwndUp;

        s_fModalUp = TRUE;
        s_hwndUp = _hwnd;

        while ((_hwnd != NULL) && (GetMessage(&msg, _hwnd, 0, 0)))
        {
            //first call our method and see if this message makes sense to us.
            //if not, let WIN API care about it.
            if (!_DocHost.TranslateAccelerator(&msg, &CGID_MSHTML, IDM_UNKNOWN))
            {
                ::TranslateMessage(&msg);
                ::DispatchMessage(&msg);
            }
        }

        s_fModalUp = fOldModalUp;
        s_hwndUp = hwndOldUp;
    }

Cleanup:
    RRETURN(hr);
}

////    CPadMessage::SaveInto
//
//  Description:
//    This routine gives one central location which save all modified
//      properties into a message.
//

HRESULT CPadMessage::SaveInto(LPMESSAGE pmsg)
{
    HRESULT             hr;
    ULONG               cval = 0;
    LONG                cb;
    LPSPropProblemArray pProblems = NULL;

    Assert(_eFormType == eformSend);

    if (_eFormType == eformRead)
        return S_OK;
    
    // Call IsDirty() to make sure  _fDirty is current

    if (!_fDirty)
        IsDirty();
    
    // If not dirty and we already have a cache, return

    if (!_fDirty && _pval != NULL) 
        return S_OK;

    // If wells have been touched, regenerate recipient list
    // but do not resolve names (user may save a message without 
    // resolving the names)

    if (AreWellsDirty())
    {
        hr = THR(ParseRecipients(TRUE));
        if (hr)
            goto Cleanup;                
    }

    //  Write out the recipient table to the message

    if (_padrlist && _fRecipientsDirty)
    {
        hr = THR(pmsg->ModifyRecipients(0, _padrlist));
        if (hr)
        {
            g_LastError.SetLastError(hr, pmsg);
            goto Cleanup;
        }
    }

    // Create new cache

    if (NULL != _pval)
    {
        MAPIFreeBuffer(_pval);
        _pval = NULL;
    }
    
    if (MAPIAllocateBuffer(sizeof(SPropValue) * cPropSendMsg, (LPVOID FAR *) &_pval))
    {
        hr = g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
        goto Cleanup;
    }
        
    ZeroMemory(_pval, sizeof(SPropValue) * cPropSendMsg);
        
    _pval[irtTime].ulPropTag = PR_NULL;
    _pval[irtSenderName].ulPropTag = PR_NULL;                     
    _pval[irtNormSubject].ulPropTag = PR_NULL;
    _pval[irtTo].ulPropTag = PR_NULL;
    _pval[irtCc].ulPropTag = PR_NULL;

    // Get subject into the cache

    cb = GetWindowTextLength(GetDlgItem(_hwndDialog, ID_SUBJECT));
    if (cb > 0)
    {
        if (MAPIAllocateBuffer(cb+1, (LPVOID FAR *)&_pval[irtSubject].Value.lpszA))
        {
            hr = g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
            goto Cleanup;
        }

        GetWindowTextA(GetDlgItem(_hwndDialog, ID_SUBJECT), _pval[irtSubject].Value.lpszA, cb+1);
        _pval[irtSubject].ulPropTag = PR_SUBJECT_A;
    }
    else
    { //no subject

        _pval[irtSubject].ulPropTag = PR_NULL;
    }

    // Set form class

    _pval[irtClass].ulPropTag = PR_MESSAGE_CLASS_A;
    _pval[irtClass].Value.lpszA = g_achFormClassName;

    // If the message didn't have PR_CONVERSATION_TOPIC when we loaded it, we'll
    // set it every time we save the message. Otherwise we don't touch it

    if (!_fConvTopicSet)
    {
        _pval[irtConvTopic].ulPropTag = PR_CONVERSATION_TOPIC_A;
        if (PR_SUBJECT_A == _pval[irtSubject].ulPropTag)
        {
            _pval[irtConvTopic].Value.lpszA = _pval[irtSubject].Value.lpszA;
        }
        else
        {
            _pval[irtConvTopic].Value.lpszA = "";
        }
    }
    else
    {
        _pval[irtConvTopic].ulPropTag = PR_NULL;
    }

    // If the message doesn't have a PR_CONVERSATION_INDEX, create and set it

    if (_cbConvIdx == 0)
    {
        if (!ScAddConversationIndex(0, NULL, &_cbConvIdx,   &_lpbConvIdx))
        {
            _pval[irtConvIdx].ulPropTag = PR_CONVERSATION_INDEX;
            _pval[irtConvIdx].Value.bin.lpb = _lpbConvIdx;
            _pval[irtConvIdx].Value.bin.cb = _cbConvIdx;
        }
        else
        {
            _pval[irtConvIdx].ulPropTag = PR_NULL;
        }
    }
    else
    {
        _pval[irtConvIdx].ulPropTag = PR_NULL;
    }

    // For an unsent form, set the delivery time so that it shows up
    // at the right place in the folder

        if (_ulMsgFlags & MSGFLAG_UNSENT)
        {
                SYSTEMTIME                      st;

                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &_pval[irtTime].Value.ft);
                _pval[irtTime].ulPropTag = PR_MESSAGE_DELIVERY_TIME;
    }

    // Now set the message properties

    hr = THR(pmsg->SetProps(cPropSendMsg, _pval, &pProblems));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

    Assert(!pProblems);

    // Stream the down level body (plain text or RTF) 
    // out of trident into the message

    hr = THR(StreamOutTextBody(pmsg));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

    // Stream the HTML body out of Trident into the message

    hr = THR(StreamOutHtmlBody(pmsg));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

BOOL CPadMessage::OnTranslateAccelerator(MSG * pMsg)
{
    //
    // Check for TAB between subject and body
    //

    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB)
    {
        if (GetKeyState(VK_SHIFT) & 0x80000000)
        {
            if (_pInPlaceActiveObject)
            {
               UIDeactivateDoc();
               SetFocus(GetDlgItem(_hwndDialog, ID_SUBJECT));
               return TRUE;
            }
        }
        else
        {
            if (GetFocus() == GetDlgItem(_hwndDialog, ID_SUBJECT))
            {
                UIActivateDoc(pMsg);
                return TRUE;
            }
        }
    }

    //
    //  We translate accelerators before the dialog message so that we
    //  can get our accelerators to override the dialog's.
    //

    if (::TranslateAccelerator(_hwnd, _HAccelTable, pMsg))
        return TRUE;

    //
    // Now let Trident process accelerators
    //

    if(CPadDoc::OnTranslateAccelerator(pMsg))
        return TRUE;

    //
    // Finally process dialog accelerators
    //

    if ((_hwndDialog != NULL) && ::IsDialogMessage(_hwndDialog, pMsg))
        return TRUE;

    return FALSE;
}


///  CPadMessage::DisplayMessage
//
//  display the info from _pval in the dialog
HRESULT CPadMessage::DisplayMessage(void)
{
    HRESULT  hr = S_OK;
    TCHAR    awch[256];
    char     ach[256];

    Assert(_hwnd);
    Assert(_hwndDialog);

    if (NULL != _pval)
    {
        if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
        {
            SetDlgItemTextA(_hwndDialog, ID_SUBJECT, _pval[irtSubject].Value.lpszA);
            MultiByteToWideChar(CP_ACP, 0, _pval[irtSubject].Value.lpszA, -1,
                                awch, sizeof(awch));
            lstrcat(awch, TEXT(" - "));
            lstrcat(awch, g_achWindowCaption);
            SetWindowText(_hwnd, awch);
        }
        else
        {
            SetWindowText(_hwnd, g_achWindowCaption);
        }

        if (_eFormType == eformRead)
        {
            if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
            SetDlgItemTextA(_hwndDialog, ID_FROM, _pval[irtSenderName].Value.lpszA);

            if (_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME) {
                FormatTime(&_pval[irtTime].Value.ft, ach, sizeof(ach));
                SetDlgItemTextA(_hwndDialog, ID_SENT, ach);
            }

            if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
                SetDlgItemTextA(_hwndDialog, ID_TO, _pval[irtTo].Value.lpszA);

            if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
                SetDlgItemTextA(_hwndDialog, ID_CC, _pval[irtCc].Value.lpszA);
        }
        else if (_eFormType == eformSend)
        {
            DisplayRecipients(TRUE);
        }
        else
        {
            Assert(FALSE);
        }

        ClearDirty();
    }

    if (_pval && _pval[irtHtmlBody].ulPropTag == PR_HTML_BODY)
    {
        hr = THR(StreamInHtmlBody(_pval[irtHtmlBody].Value.lpszA));
        if (hr)
            goto err;   
    }    
    else
    {
        hr = THR(StreamInHtmlBody(_pmsg));
        if (hr)
            goto err;
    }

err:
    RRETURN(hr);
}


/// CPadMessage::IsAddressed
//
// Does _padrlist contain a recipient?
BOOL CPadMessage::IsAddressed(void)
{
    Assert(_eFormType == eformSend) ;

    if (NULL == _padrlist || _padrlist->cEntries == 0)
        return FALSE;

    for(LPADRENTRY pae = _padrlist->aEntries;
        pae < _padrlist->aEntries + _padrlist->cEntries; ++pae)
    {
        if (pae->rgPropVals)
            return TRUE;
    }

    return FALSE;
}

///     CPadMessage::ConfigMenu
//Enable/disable menu commands based on the values of _ulSiteStatus
// and _ulViewStatus
void CPadMessage::ConfigMenu(HMENU hMenu)
{
    if (_eFormType == eformRead)
    {
        EnableMenuItem(hMenu, IDM_MESSAGE_SAVE,
            MF_BYCOMMAND|((_ulSiteStatus & VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_DELETE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_COPY,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_MOVE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_VIEW_ITEMABOVE,
            MF_BYCOMMAND|(_ulViewStatus & VCSTATUS_PREV ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_VIEW_ITEMBELOW,
            MF_BYCOMMAND|(_ulViewStatus & VCSTATUS_NEXT ? MF_ENABLED:MF_GRAYED));
    }

    else
    {
        EnableMenuItem(hMenu, IDM_MESSAGE_SUBMIT,
            MF_BYCOMMAND|((_ulSiteStatus &VCSTATUS_SUBMIT) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_SAVE,
            MF_BYCOMMAND|((_ulSiteStatus & VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_DELETE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_COPY,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_MOVE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED));

    }
}

HRESULT
CPadMessage::DoSave(BOOL fPrompt)
{
    HRESULT hr;

    if (fPrompt)
        return CPadDoc::DoSave(TRUE);

    hr = THR(_pmsgsite->SaveMessage());
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }

    RRETURN(hr);
}

///  CPadMessage::DoDelete
//
//  called only from our UI
void CPadMessage::DoDelete(void)
{
    HRESULT hr;
    RECT rect;

    GetWindowRect(_hwnd, &rect);

    hr = THR(_pmsgsite->DeleteMessage(_pviewctx, &rect));
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }
    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
}

///  CPadMessage::DoSubmit
//
//  called only from our UI
void CPadMessage::DoSubmit(void)
{
    HRESULT hr;

    // Get and check recipients from the UI

    hr = THR_NOTRACE(GetAndCheckRecipients(FALSE));
    
    if (hr == MAPI_E_USER_CANCEL)
        return;
    
    if (hr)
        goto Cleanup;

    // GeAndCheckRecipients is supposed to ensure that the addrlist
    // is in sync with the wells
    Assert (!AreWellsDirty());

    // Verify we have at least a recipient

    if (!IsAddressed())
    {
        ShowMessageBox(_hwndDialog, TEXT("No recipients"), g_achFormName, MB_OK);
        return;
    }

    hr = THR(_pmsgsite->SubmitMessage(0));

Cleanup:
    if (FAILED(hr))
    {
        Assert(hr != MAPI_E_USER_CANCEL);
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }
    else
    {
        _viewnotify.OnSubmitted();
    }
    if (_pmsg == NULL)
        ShutdownForm(SAVEOPTS_NOSAVE);
}

///  CPadMessage::DoNext
//
//  called only from our UI
void CPadMessage::DoNext(ULONG ulDir)
{
    Assert(VCDIR_NEXT == ulDir || VCDIR_PREV == ulDir);

    HRESULT hr;

    hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
    if (hr)
    {
        if (hr != S_FALSE)
            ShowError();
        return;
    }

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    hr = THR(ViewCtx()->ActivateNext(ulDir, &rect));
    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
}

///  CPadMessage::DoReply
//
//  called only from our UI
void CPadMessage::DoReply(eREPLYTYPE eType)
{
    HRESULT hr;

    hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
    if (hr)
    {
        if (hr != S_FALSE)
            ShowError();
        return;
    }

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    int iOffset = GetSystemMetrics(SM_CYCAPTION);
    OffsetRect(&rect, iOffset, iOffset);

    hr = THR(Reply(eType, _hwnd, &rect));
    if (!hr)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
    else
    {
        ShowError();
    }
}

///  CPadMessage::DoCopy
//
//  called only from our UI
void CPadMessage::DoCopy(void)
{
    HRESULT         hr;
    LPMAPIFOLDER    pfld = NULL;
    LPMDB           pmdb = NULL;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            ShowError();
            return;
        }
    }

    BOOL fOldModalUp = s_fModalUp;

    s_fModalUp = TRUE;

    hr = THR(HrPickFolder(g_hInstCore, _hwnd, _pses, &pfld, &pmdb,
                                &_cbCFDState, &_pbCFDState));


    s_fModalUp = fOldModalUp;

    if (hr)
    {
        if (hr != MAPI_E_USER_CANCEL)
            ShowMessageBox(_hwnd, TEXT("Can't copy"), g_achFormName, MB_OK | MB_ICONSTOP);

        return;
    }

    Assert(_pmsgsite);
    Assert(pfld);
    Assert(pmdb);

    hr = THR(_pmsgsite->CopyMessage(pfld));
    pfld->Release();
    pmdb->Release();
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
        return;
    }

}


///  CPadMessage::DoMove
//
//  called only from our UI
void CPadMessage::DoMove(void)
{
    HRESULT         hr;
    LPMAPIFOLDER    pfld = NULL;
    LPMDB           pmdb = NULL;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            ShowError();
            return;
        }
    }


    BOOL fOldModalUp = s_fModalUp;

    s_fModalUp = TRUE;

    hr = THR(HrPickFolder(g_hInstCore, _hwnd, _pses, &pfld, &pmdb,
                                //&_cbCFDState, &_pbCFDState);
                                NULL, NULL));

    s_fModalUp = fOldModalUp;

    if (hr)
    {
        if (hr != MAPI_E_USER_CANCEL)
            ShowMessageBox(_hwnd, TEXT("Can't move"), g_achFormName, MB_OK | MB_ICONSTOP);

        return;
    }

    Assert(_pmsgsite);
    Assert(pfld);
    Assert(pmdb);

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    hr = THR(_pmsgsite->MoveMessage(pfld, ViewCtx(), &rect));
    pfld->Release();
    pmdb->Release();
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
        return;
    }

    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }


}

//wraper for MessageBox()
int CPadMessage::ShowMessageBox(HWND hwnd, LPCTSTR lpszText, LPCTSTR lpszTitle, UINT uiStyle)
{
    int iret;
    BOOL fOldModalUp = s_fMBoxUp;

    s_fMBoxUp = TRUE;

    iret = MessageBox(hwnd, lpszText, lpszTitle, uiStyle);

    s_fMBoxUp = fOldModalUp;

    return iret;
}

//wraper for g_LastError.ShowError()
void CPadMessage::ShowError(void)
{
    int iret;
    BOOL fOldModalUp = s_fMBoxUp;

    s_fMBoxUp = TRUE;

    iret = g_LastError.ShowError(_hwnd);

    s_fMBoxUp = fOldModalUp;

}

HRESULT
CPadMessage::StreamInHtmlBody(LPMESSAGE pmsg)
{
    HRESULT hr;
    LPSTREAM pStm = NULL;

    if (!_fNewMessage)
    {
        hr = THR(pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                                STGM_READ, 0, (LPUNKNOWN FAR *) &pStm));
        if (hr)
            goto err;
    }

    hr = THR(Open(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamInHtmlBody(char * pch)
{
    HRESULT hr;
    LPSTREAM pStm = NULL;
    DWORD cb;
    DWORD cbWritten;
    LARGE_INTEGER i64Start = {0, 0};

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
    if (hr)
        goto err;

    cb = lstrlenA(pch);

    hr = THR(pStm->Write(pch, cb, &cbWritten));
    if (hr)
        goto err;

    hr = THR(pStm->Seek(i64Start, STREAM_SEEK_SET, NULL));
    if (hr)
        goto err;

    Assert (cbWritten == cb);

    hr = THR(Open(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamOutHtmlBody(LPMESSAGE pmsg)
{
    Assert(pmsg);

    HRESULT hr;
    LPSTREAM pStm = NULL;

    hr = THR(pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                            (LPUNKNOWN FAR *) &pStm));
    if (hr)
        goto err;

    hr = THR(CPadDoc::Save(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamOutTextBody(LPMESSAGE pmsg)
{
    Assert(pmsg);

    HRESULT                 hr;
    LPSTREAM                pStm;
    LPSTREAM                pStmIn;
    FORMATETC               formatetc;
    STGMEDIUM               medium;
    IDataObject *           pDO;

    pStmIn = NULL;
    pStm = NULL;
    pDO = NULL;

    formatetc.cfFormat = RegisterClipboardFormat(_T("CF_RTF"));
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_ISTREAM;

    hr = THR(_pObject->QueryInterface(IID_IDataObject, (void**)&pDO));
    if (hr)
        goto err;

    hr = THR(pmsg->OpenProperty(PR_RTF_COMPRESSED, &IID_IStream,
            0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *) &pStmIn));
    if (hr)
        goto err;

    hr = THR(WrapCompressedRTFStream(pStmIn, MAPI_MODIFY, &pStm));
    if (hr)
        goto err;

    medium.tymed = TYMED_ISTREAM;
    medium.pstm = pStm;
    medium.pUnkForRelease = NULL;

    hr = THR(pDO->GetDataHere(&formatetc, &medium));
    if (hr)
    {
        //
        // RTF failed, try plain text
        //

        ReleaseInterface(pStm);

        formatetc.cfFormat = CF_TEXT;
        hr = THR(pmsg->OpenProperty(PR_BODY_A, &IID_IStream,
                    STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                    (LPUNKNOWN *) &pStm));
        if (hr)
            goto err;

        medium.pstm = pStm;

        hr = THR(pDO->GetDataHere(&formatetc, &medium));
        if (hr)
            goto err;

        hr = THR(pStm->Write(g_achPlainTextHeader, strlen(g_achPlainTextHeader), NULL));
        if (hr)
            goto err;

    }
    else
    {
        hr = THR(pStm->Commit(STGC_OVERWRITE));
        if (hr)
            goto err;
    }

err:
    ReleaseInterface(pStm);
    ReleaseInterface(pStmIn);
    ReleaseInterface(pDO);
    RRETURN(hr);
}

/*
 *  Formats a Win32 file time as a MAPI date/time string.
 *  NOTE: converts from GMT to local time.
 */
void FormatTime(FILETIME *pft, LPSTR szTime, DWORD cchTime)
{
    FILETIME        ft;
    SYSTEMTIME      systime;
    DWORD           dwLen;

    FileTimeToLocalFileTime(pft, &ft);
    FileTimeToSystemTime(&ft, &systime);

    dwLen = GetDateFormatA(
        LOCALE_USER_DEFAULT,
        DATE_LONGDATE,
        &systime,
        NULL,
        szTime,
        cchTime);

    Assert(cchTime - dwLen > 0);

    *(szTime + dwLen - 1) = ' '; // Replace terminating NULL with space

    GetTimeFormatA(
        LOCALE_USER_DEFAULT,
        TIME_NOSECONDS,
        &systime,
        NULL,
        szTime + dwLen,
        cchTime - dwLen);
}


void
CPadMessage::GetViewRect(RECT *prc, BOOL fIncludeObjectAdornments)
{
    RECT    rcDialog;
    RECT    rcFormat;
    RECT    rcToolbar;
    RECT    rcStatus;

    GetClientRect(_hwnd, prc);

    if (_hwndToolbar)
    {
        GetWindowRect(_hwndToolbar, &rcToolbar);
        SetWindowPos(_hwndToolbar, 0, 0, prc->top, prc->right - prc->left, rcFormat.bottom - rcFormat.top, SWP_NOZORDER | SWP_NOACTIVATE);
        prc->top += rcToolbar.bottom - rcToolbar.top;
    }

    if (_hwndTBFormat)
    {
        GetWindowRect(_hwndTBFormat, &rcFormat);
        SetWindowPos(_hwndTBFormat, 0, 0, prc->top, prc->right - prc->left, rcFormat.bottom - rcFormat.top, SWP_NOZORDER | SWP_NOACTIVATE);
        prc->top += rcFormat.bottom - rcFormat.top;
    }

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    // Reduce rectangle to leave space for address controls

    if (fIncludeObjectAdornments)
    {
        GetWindowRect (_hwndDialog,&rcDialog);
        SetWindowPos(_hwndDialog, 0, 0, prc->top, prc->right - prc->left, rcDialog.bottom - rcDialog.top, SWP_NOZORDER | SWP_NOACTIVATE);

        prc->top += rcDialog.bottom - rcDialog.top;
        if (prc->top > prc->bottom)
        {
            prc->top = prc->bottom;
        }
    }

    if (prc->bottom < prc->top)
        prc->bottom = prc->top;

    if (prc->right < prc->left)
        prc->right = prc->left;
}


LRESULT
CPadMessage::OnSize(WORD fwSizeType, WORD nWidth, WORD nHeight)
{
    RECT rc;
    GetViewRect(&rc, FALSE);
    if (_pInPlaceActiveObject)
    {
        THR_NOTRACE(_pInPlaceActiveObject->ResizeBorder(
                &rc,
                &_Frame,
                TRUE));
    }

    Resize();
    return 0;
}


HRESULT
CPadMessage::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    if (_eFormType == eformRead)
    {
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 0),
                TEXT("&File"));
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 1),
                TEXT("&View"));
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 2),
                TEXT("Co&mpose"));

        pmgw->width[0] = 1;
        pmgw->width[2] = 1;
        pmgw->width[4] = 1;
    }
    else if (_eFormType == eformSend)
    {
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 0),
                TEXT("&File"));

        pmgw->width[0] = 1;
        pmgw->width[2] = 0;
        pmgw->width[4] = 0;
    }
    else
    {
        Assert(FALSE);
    }

    _hmenuHelp = LoadMenu(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_PADHELPMENU));

    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT) (_hmenuHelp),
            TEXT("&Help"));

    _cMenuHelpItems = GetMenuItemCount(_hmenuHelp);

    pmgw->width[5] = 2;

    return S_OK;
}

void
CPadMessage::SetDocTitle(TCHAR * pchTitle)
{
    // don't do anything here since we set our own title
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgguid.h ===
// {88FFF551-B8C5-11ce-8DE0-00AA0060D242}
//The same as CLSID in smpfrm.cfg
DEFINE_GUID(CLSID_IPM_NOTE_SAMPLE, 
0x88fff551, 0xb8c5, 0x11ce, 0x8d, 0xe0, 0x00, 0xaa, 0x00, 0x60, 0xd2, 0x42);

//ClsId for recipient objects embedded in addressing fields
// {F8FB5730-EA86-11cf-8058-00AA003F40D0}
DEFINE_GUID(CLSID_CTriple, 
0xf8fb5730, 0xea86, 0x11cf, 0x80, 0x58, 0x0, 0xaa, 0x0, 0x3f, 0x40, 0xd0);

//string representation of our class ID
#define  szGUID TEXT ("{88FFF551-B8C5-11CE-8DE0-00AA0060D242}")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgguid.cxx ===
//////////////////////////////////////////////////////////////////////////////
//
//  FILE:           MSGGUID.CXX
//
//  
//
//  Copyright (c) 1986-1996, Microsoft Corporation.
//  All rights reserved.
//
//--

#include <padhead.hxx>

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include <initguid.h>
#endif

#define         USES_IID_IMAPIForm
#define         USES_IID_IMAPIFormAdviseSink
#define         USES_IID_IPersistMessage

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#ifndef X_MAPIGUID_H_
#define X_MAPIGUID_H_
#include "mapiguid.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgform.h ===
#ifndef MSGFORM_H
#define MSGFORM_H


/*
 *  E X C H F O R M . H
 *
 *  Declarations of interfaces and constants for forms that work with
 *  the Microsoft Exchange client.
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */


/*
 *  V e r b s
 */


// Interpersonal messaging verbs
#define EXCHIVERB_OPEN              0
#define EXCHIVERB_RESERVED_COMPOSE  100
#define EXCHIVERB_RESERVED_OPEN     101
#define EXCHIVERB_REPLYTOSENDER     102
#define EXCHIVERB_REPLYTOALL        103
#define EXCHIVERB_FORWARD           104
#define EXCHIVERB_PRINT             105
#define EXCHIVERB_SAVEAS            106
#define EXCHIVERB_RESERVED_DELIVERY 107
#define EXCHIVERB_REPLYTOFOLDER     108


/*
 *  G U I D s
 */


#define DEFINE_EXCHFORMGUID(name, b) \
    DEFINE_GUID(name, 0x00020D00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

#ifndef NOEXCHFORMGUIDS
DEFINE_EXCHFORMGUID(PS_EXCHFORM, 0x0C);
#endif // NOEXCHFORMGUIDS


/*
 *  E x t e n d e d   P r o p e r t i e s
 */


// Operation map property
#define psOpMap                     PS_EXCHFORM
#define ulKindOpMap                 MNID_ID
#define lidOpMap                    1
#define ptOpMap                     PT_STRING8

// Operation map indices
#define ichOpMapReservedCompose     0
#define ichOpMapOpen                1
#define ichOpMapReplyToSender       2
#define ichOpMapReplyToAll          3
#define ichOpMapForward             4
#define ichOpMapPrint               5
#define ichOpMapSaveAs              6
#define ichOpMapReservedDelivery    7
#define ichOpMapReplyToFolder       8

// Operation map values
#define chOpMapByClient             '0'
#define chOpMapByForm               '1'
#define chOpMapDisable              '2'


#endif // MSGFORM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgerr.cxx ===
//
//  MSGERR.CPP
//
// implementation file for CLastError which implements the
// GetLastError helper
//
//  
//
// Copyright (C) 1995 Microsoft Corp.
//

//#define STRICT

#include "padhead.hxx"

#ifndef X_PAD_HXX_
#define X_PAD_HXX_
#include "pad.hxx"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

#ifndef X_MSGERR_HXX_
#define X_MSGERR_HXX_
#include "msgerr.hxx"
#endif

const int       CchMaxErrorMessage = 256;

extern const char  SzNull[] = "";
char szErrUnknown[] = "Error description is not available";

//
// some stuff to put a "Help" button on the error msgbox
//
#if defined(_WIN32)
char szHelpFile[_MAX_PATH];
VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo);
#endif //_WIN32

static int iFromHR(HRESULT hr)
{
    switch(GetScode(hr)) {
    case MAPI_E_NOT_ENOUGH_MEMORY:      return IDS_E_OUTOFMEMORY;
    case MAPI_E_INVALID_PARAMETER:      return IDS_INVALID_ARGUMENT;
    case MAPI_E_INVALID_OBJECT:         return IDS_INVALID_OBJECT;
    case MAPI_E_INTERFACE_NOT_SUPPORTED: return IDS_INTERFACE_NOT_SUPPORTED;
    case MAPI_E_NO_ACCESS:              return IDS_ACCESS_DENIED;
    case MAPI_E_NO_SUPPORT:             return IDS_NOT_SUPPORTED;
    case MAPI_E_BAD_CHARWIDTH:          return IDS_INVALID_CHARWIDTH;
    case MAPI_E_NOT_FOUND:              return IDS_NOT_FOUND;
    case MAPI_E_CALL_FAILED:            return IDS_CALL_FAILED;
    case MAPI_E_USER_CANCEL:            return IDS_USER_CANCEL;
    case MAPI_W_ERRORS_RETURNED:        return IDS_ERRORS_RETURNED;
    case MAPI_E_UNKNOWN_FLAGS:          return IDS_UNKNOWN_FLAGS;
    case E_UNEXPECTED:                  return IDS_UNEXPECTED;
    case OLEOBJ_S_CANNOT_DOVERB_NOW:    return IDS_CANTNOW;
    // if it's not in this list you need to add it.
    default:
        //DebugTrace(TEXT ("lasterr: bad arg to FORMScodeFromHR"));
        Assert(FALSE);
        return 0;
    }
}

HRESULT CLastError::Init(LPCTSTR szComponent)
{
    HRESULT hr;
    LONG cch;
    
    _eLastErr = eNoError;
    _hrLast = 0;
    _hrGLE = 0;
    _pmapierr = 0;
    _szComponent = NULL;

    cch = lstrlen(szComponent) + 1;

    hr = THR(MAPIAllocateBuffer(cch, (LPVOID *) &_szComponent));
    if(hr)
        goto Cleanup;

    WideCharToMultiByte(CP_ACP, 0, szComponent, cch, _szComponent, cch + 1, NULL, NULL);

Cleanup:
    RRETURN(hr);
}
    
CLastError::~CLastError()
{
    if (_pmapierr != NULL)
    {
        MAPIFreeBuffer(_pmapierr);
    }
    if(_szComponent != NULL)
    {
        MAPIFreeBuffer(_szComponent);
    }
}

HRESULT CLastError::SetLastError(HRESULT hr)
{
#if defined(DEBUG)
    //
    //  Ensure that the error string exists -- when we set it not when
    //  they ask for it.
    //

    (void) iFromHR(hr);
#endif

    //
    //  Release any previous error
    //

    if (_pmapierr != NULL) {
        MAPIFreeBuffer(_pmapierr);
        _pmapierr = NULL;
    }

    if (hr) {
        _eLastErr = eMAPI;
    }
    else {
        _eLastErr = eNoError;
    }

    return (_hrLast = hr);
}

HRESULT CLastError::SetLastError(HRESULT hr, IUnknown* punk)
{
    Assert(punk && hr);     // we have to have an object and an error.

    _eLastErr = eObject;
    _hrLast = hr;

    IMAPIProp* pmprp = (IMAPIProp*)punk;  // I hate this cast but c'est la vie.

    MAPIFreeBuffer(_pmapierr);     // clean up previous error.
    _pmapierr = NULL;

    _hrGLE = pmprp->GetLastError(hr, 0, &_pmapierr);
    if (_hrGLE == S_OK) {
        if (_pmapierr == NULL) {
            if (MAPIAllocateBuffer(sizeof(MAPIERROR), (void **) &_pmapierr)) {
                _hrGLE = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            }
            else {
                memset(_pmapierr, 0, sizeof(MAPIERROR));
                _pmapierr->ulVersion = MAPI_ERROR_VERSION;
                _pmapierr->lpszError = (LPTSTR)szErrUnknown;
                _pmapierr->lpszComponent =  (LPTSTR)SzNull;
            }
        }
        else if (_pmapierr->lpszError == NULL) {
            _pmapierr->lpszError = (LPTSTR)SzNull;
        }
        else if (_pmapierr->lpszComponent == NULL) {
            _pmapierr->lpszComponent = (LPTSTR)SzNull;
        }
    }
    else {
        if (_pmapierr != NULL) {
            MAPIFreeBuffer(_pmapierr);
            _pmapierr = NULL;
        }
    }
    return _hrLast;
}

HRESULT CLastError::GetLastError(HRESULT hr, DWORD dwFlags,
                                   LPMAPIERROR FAR * lppMAPIError)
{
    //
    //  Start with parameter validation
    //

    if (IsBadWritePtr(lppMAPIError, sizeof(LPMAPIERROR))) {
        return SetLastError(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (MAPI_UNICODE == (dwFlags & MAPI_UNICODE)) {
        return SetLastError(ResultFromScode(MAPI_E_BAD_CHARWIDTH));
    }

    //
    //  Is the error asked for the last error registered with us?
    //

    if (hr != _hrLast) {
        *lppMAPIError = NULL;
        return S_OK;
    }

    int         cch;
    int         cb;
    int         idsError;
    char*       szMessage = 0;
    char*       szComponent = 0;
    char        szErrorString[CchMaxErrorMessage];
    LPMAPIERROR pmapierr = NULL;

    //
    //  Based on the type of the last error, construct the appropriate
    //  return object
    //

    switch (_eLastErr) {
    case eMAPI:
        //
        //  The last error registered was a MAPI error code.  For mapi
        //      error codes we map the MAPI error code into a resource
        //      id and return the appropriate string.
        //
        // as to spec, we allocate a single buffer for message and
        //      component.  no one will notice that we aren't doing
        //      MAPIAllocateMore for component.
        //
        //   We make an assumption as to the maximum possible length
        //      of the two strings combined.
        //

        Assert(_pmapierr == NULL);
        if (MAPIAllocateBuffer(CchMaxErrorMessage + sizeof(MAPIERROR),
                               (void**)&pmapierr)) {
            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        }

        //
        //  Set the version number
        //

        pmapierr->ulVersion = MAPI_ERROR_VERSION;
        pmapierr->ulLowLevelError = 0;

        //
        //   do the maping from the MAPI error code into a FORM string
        //      value.  The FORM eror code code will be set as the low
        //      level error value.
        //

        idsError = iFromHR(_hrLast);
        pmapierr->ulContext = idsError;

        //
        //  Set the error string pointer to the appropriate location
        //      in the error buffer and load the error string.
        //

        pmapierr->lpszError = (LPTSTR) (sizeof(MAPIERROR) +
                                          (BYTE *) pmapierr);

        LoadStringA(g_hInstResource, idsError, szErrorString, 
                    CchMaxErrorMessage);
        
        lstrcpyA((LPSTR)pmapierr->lpszError, szErrorString);
        cch = lstrlenA(szErrorString);
       
        
        //
        // Set the componment string pointer to the appropriate location
        //      in the error buffer and load the component string.
        //

        pmapierr->lpszComponent = pmapierr->lpszError + cch + 1;
        cch = CchMaxErrorMessage - cch - 1;

        lstrcpyA((LPSTR)pmapierr->lpszComponent,
                        _szComponent ? _szComponent : SzNull);
        cch = lstrlen(pmapierr->lpszComponent);
        
        if (cch == 0) {
            *(pmapierr->lpszComponent) = 0;
        }

        break;


    case eObject:
        //
        //  The last regisered error message came from an object.  If we
        //      could not get the last error from the object, just return
        //      the error it returned and we are done.
        //

        if (_hrGLE != NOERROR) {
            Assert( _pmapierr == NULL );
            *lppMAPIError = NULL;
            return _hrGLE;
        }

    case eExtended:
        //
        //  The last error was an extended error.  The error is in the
        //      structure, we need to copy this structure and return
        //      it back to the user
        //

        Assert( _pmapierr != NULL );
        cb = (lstrlen(_pmapierr->lpszError) + lstrlen(_pmapierr->lpszComponent) + 2);

        if (MAPIAllocateBuffer(cb + sizeof(MAPIERROR),
                               (void **) &pmapierr)) {
            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        }

        *pmapierr = *_pmapierr;
        pmapierr->lpszError = (LPTSTR) (sizeof(MAPIERROR) + (BYTE *) pmapierr);
        lstrcpy(pmapierr->lpszError, _pmapierr->lpszError);
        pmapierr->lpszComponent = pmapierr->lpszError +
          lstrlen(pmapierr->lpszError) + 1;
        lstrcpy(pmapierr->lpszComponent, _pmapierr->lpszComponent);

        break;

    case eNoError:
        break;

    default:
        Assert(0);
        return NOERROR;
    }

    *lppMAPIError = pmapierr;
    return ResultFromScode(S_OK);
}



int CLastError::ShowError(HWND hWnd)
{
    char szMessage[512];
    char szbuf[256];

    if(_eLastErr != eObject || NULL == _pmapierr) return 0;

    wsprintfA(szMessage, "%s\n%s\nLowLevelError: 0x%08lx context: %ld ",
                        ((LPSTR)_pmapierr->lpszError ? (LPSTR)_pmapierr->lpszError : ""),
                        (LPSTR)_pmapierr->lpszComponent ? (LPSTR)_pmapierr->lpszComponent : "",
                        (LPSTR)_pmapierr->ulLowLevelError, (LPSTR)_pmapierr->ulContext);
   
    wsprintfA(szbuf, "\nReturn Code: 0x%08lx", SCODE(_hrLast));
    lstrcatA (szMessage, szbuf);
    
#if defined (_WIN32)
    *szHelpFile = '\0';

    int iret = 0;
    BOOL fCanHelp;

    if(_pmapierr->lpszError  &&  _pmapierr->ulContext)
        fCanHelp = TRUE;
    else
        fCanHelp = FALSE;
        
    if(fCanHelp)
    {
        DWORD dw = GetPrivateProfileStringA("Help File Mappings", (LPSTR)_pmapierr->lpszComponent,
                           "", szHelpFile, _MAX_PATH, "mapisvc.inf");
        if(0 == dw)
            fCanHelp = FALSE;

        if(fCanHelp)
        {
            MSGBOXPARAMSA mbp = {0};

            mbp.cbSize = sizeof(MSGBOXPARAMS);
            mbp.hwndOwner = hWnd;
            mbp.hInstance = NULL;
            mbp.lpszText = szMessage;
            mbp.lpszCaption = _szComponent ? _szComponent : "Error!";
            mbp.dwStyle = MB_ICONSTOP | MB_OK | MB_HELP;
            mbp.lpszIcon = NULL;
            mbp.dwContextHelpId = _pmapierr->ulContext;
            mbp.lpfnMsgBoxCallback = ErrorBoxCallBack;
            mbp.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

            iret = MessageBoxIndirectA(&mbp);
        }
        
    }

    
    if(!fCanHelp)
        iret = MessageBoxA (hWnd, szMessage,
                    _szComponent ? _szComponent : "Error!",
                        MB_ICONSTOP | MB_OK );

    *szHelpFile = '\0';

    return iret;

#else
    return MessageBox (hWnd, szMessage,
                     _szComponent ? _szComponent : "Error!",
                         MB_ICONSTOP | MB_OK );
#endif
}

#if defined(_WIN32)
VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo)
{
    Assert(*szHelpFile != '\0');

    WinHelpA(NULL, szHelpFile, HELP_CONTEXT,
            lpHelpInfo->dwContextId);
}
#endif //_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msghost.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       msghost.cxx
//
//  Contents:   CPadMessage's implementation of IDocHostUIHandler and
//              IDocHostShowUI
//
//------------------------------------------------------------------------


#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#include "commctrl.h"
#endif

#define         MAXLABELLEN 32
#define         MAX_COMBO_VISUAL_ITEMS 20

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadMessageDocHost, CPadMessage, PadMessage, _DocHost);

STDMETHODIMP
CPadMessageDocHost::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *) this;
    }
    else if (iid == IID_IDocHostShowUI)
    {
        *ppv = (IDocHostShowUI *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//      Implementation of IDocHostUIHandler
//
//+---------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetHostInfo
//
//  Synopsis:   Fetch information and flags from the host.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
        return E_INVALIDARG;

    pInfo->dwFlags = 0;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowUI
//
//  Synopsis:   This method allows the host replace object's menu
//              and toolbars. It returns S_OK if host display
//              menu and toolbar, otherwise, returns S_FALSE.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowUI(
        DWORD dwID,
        IOleInPlaceActiveObject * pActiveObject,
        IOleCommandTarget * pCommandTarget,
        IOleInPlaceFrame * pFrame,
        IOleInPlaceUIWindow * pDoc)
{
    CPadMessage *   pPad = PadMessage();

    if (!pPad->_hwndToolbar)
        pPad->CreateToolbarUI();

    pPad->_fShowUI = TRUE;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::HideUI
//
//  Synopsis:   Remove menus and toolbars cretaed during the call
//              to ShowUI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::HideUI(void)
{
    CPadMessage *   pPad = PadMessage();

    pPad->_fShowUI = FALSE;
    // Do not hide menu/toolbar, just update status
    pPad->UpdateToolbarUI();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::UpdateUI
//
//  Synopsis:   Update the state of toolbar buttons.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::UpdateUI(void)
{
    CPadMessage *   pPad = PadMessage();
    pPad->UpdateToolbarUI();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::EnableModeless
//
//  Synopsis:   Enable or disable modless UI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::EnableModeless(BOOL fEnable)
{
    // TODO : To be implemented
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::OnDocWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::OnDocWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::OnFrameWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::OnFrameWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ResizeBorder
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ResizeBorder(
        LPCRECT prc,
        IOleInPlaceUIWindow * pUIWindow,
        BOOL fFrameWindow)
{
    CPadMessage *   pPad = PadMessage();
    BORDERWIDTHS bw;

    ::SetRect((LPRECT)&bw, 0, 0, 0, 0);
    pPad->_Frame.SetBorderSpace(&bw);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowContextMenu
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display any UI.
//              DOCHOST_E_UNKNOWN -- The menu ID is unknown..
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowContextMenu(
            DWORD dwID,
            POINT * pptPosition,
            IUnknown * pcmdtReserved,
            IDispatch * pDispatchObjectHit)
{
    HRESULT                 hr = S_FALSE;
    HMENU                   hmenu;
    HCURSOR                 hcursor;
    HCURSOR                 hcursorOld;
    HWND                    hwnd;
    CPadMessage *           pPad = PadMessage();

    if (!pPad->_pInPlaceObject)
        goto Cleanup;

    hr = THR(pPad->_pInPlaceObject->GetWindow(&hwnd));
    if (hr)
        goto Cleanup;

    hr = THR(pPad->GetContextMenu(&hmenu, dwID));
    if (hr)
        goto Cleanup;

    hcursor = LoadCursorA(NULL, (char *)IDC_ARROW);
    hcursorOld = ::SetCursor(hcursor);

    TrackPopupMenu(
            hmenu,
#ifndef _MAC
            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
#else
            0,
#endif
            pptPosition->x,
            pptPosition->y,
            0,
            hwnd,
            NULL);

    ::SetCursor(hcursorOld);

Cleanup:
    return !hr? S_OK: S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::TranslateAccelerator
//
//  Returns:    S_OK -- The mesage was translated successfully.
//              S_FALSE -- The message was not translated.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::TranslateAccelerator(
            LPMSG lpmsg,
            const GUID * pguidCmdGroup,
            DWORD nCmdID)
{
    CPadMessage *   pPad = PadMessage();

    // If a control on the toolbar has the focus
    if ((::GetFocus() == lpmsg->hwnd) &&
            ((GetParent(lpmsg->hwnd) == pPad->_hwndToolbar) ||
             (GetParent(lpmsg->hwnd) == pPad->_hwndTBFormat)))
    {
        // if the key pressed is arrow keys and combo box is not dropped down,
        // drop down the combo box.
        //
        if ((lpmsg->message == WM_KEYDOWN) &&
                (((short) lpmsg->wParam == VK_UP) ||
                        ((short) lpmsg->wParam == VK_DOWN)))
        {
            if (!SendMessage(lpmsg->hwnd, CB_GETDROPPEDSTATE, 0, 0))
            {
                SendMessage(lpmsg->hwnd, CB_SHOWDROPDOWN, TRUE, 0);
            }
        }
        return S_OK;
    }
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetOptionKeyPath
//
//  Synopsis:   Get the registry key where host stores its default
//              options.
//
//  Returns:    S_OK          -- Success.
//              E_OUTOFMEMORY -- Fail.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    HRESULT hr = E_INVALIDARG;

    if (dw == 0)
    {
        if (ppchKey)
        {
            *ppchKey = (LPOLESTR)CoTaskMemAlloc((_tcslen(_T("Software\\Microsoft\\Microsoft HTML Pad"))+1)*sizeof(TCHAR));
            if (*ppchKey)
                _tcscpy(*ppchKey, _T("Software\\Microsoft\\Microsoft HTML Pad"));
            hr = (*ppchKey) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetDropTarget
//
//  Returns:    S_OK -- Host will return its droptarget to overwrite given one.
//              S_FALSE -- Host does not want to overwrite droptarget
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetDropTarget(
        IDropTarget * pDropTarget,
        IDropTarget ** ppDropTarget)
{
    return S_FALSE;
}


STDMETHODIMP
CPadMessageDocHost::GetExternal(IDispatch** ppDisp)
{
    HRESULT     hr;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppDisp = NULL;
        hr = S_OK;
    }
   
    return hr;
}


STDMETHODIMP
CPadMessageDocHost::TranslateUrl(DWORD dwTranslate,
                                 OLECHAR *pchURLIn,
                                 OLECHAR **ppchURLOut)
{
    HRESULT     hr;

    if (!ppchURLOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }
   
    return hr;
}


STDMETHODIMP
CPadMessageDocHost::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    HRESULT     hr;

    if (!ppDORet)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppDORet = NULL;
        hr = S_OK;
    }
   
    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//      Implementation of IDocHostShowUI
//
////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowMessage
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display its own UI.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowMessage(
        HWND hwnd,
        LPOLESTR lpstrText,
        LPOLESTR lpstrCaption,
        DWORD dwType,
        LPOLESTR lpstrHelpFile,
        DWORD dwHelpContext,
        LRESULT * plResult)
{
    LRESULT     lResult;

    lResult = MessageBoxEx(hwnd, lpstrText, lpstrCaption, dwType, 0);
    if (plResult)
        *plResult = lResult;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowHelp
//
//  Returns:    S_OK -- Host displayed its own help.
//              S_FALSE -- Host did not display its help.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowHelp(
        HWND hwnd,
        LPOLESTR pszHelpFile,
        UINT uCommand,
        DWORD dwData,
        POINT ptMouse,
        IDispatch * pDispatchObjectHit)
{
    // ISSUE: Temporary fix for beta1 to append window style.
    // Append ">LangRef"
    _tcscat(pszHelpFile, _T(">LangRef"));
    WinHelp(hwnd, pszHelpFile, uCommand, dwData);

    return S_OK;
}


HRESULT
CPadMessage::QueryService(REFGUID sid, REFIID iid, void ** ppv)
{
    *ppv = NULL;
    RRETURN(E_NOINTERFACE);
}

////////////////////////////////////////////////////////////////////////
//
//      Helper functions
//
////////////////////////////////////////////////////////////////////////

HRESULT
CPadMessage::CreateToolbarUI()
{
    HRESULT     hr = S_OK;

    HWND *      pHwndCombo = NULL;
    HWND        hwndToolbar = NULL;
    HFONT       hFont;
    DWORD       cTBCombos;
    TEXTMETRIC  tm;
    HDC         hdc;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };

    static const ComboInfo tbCombos[] =
    {
        { IDM_BLOCKFMT,  IDR_HTMLPAD_TBFORMAT,       5, 100, 16,
                CBS_DROPDOWNLIST},
        { IDM_FONTNAME,    IDR_HTMLPAD_TBFORMAT,   110, 150, 43,
                CBS_SORT | CBS_DROPDOWNLIST},
        { IDM_FONTSIZE,    IDR_HTMLPAD_TBFORMAT,   265,  40,  8,
                CBS_DROPDOWNLIST},
        { IDM_FORECOLOR,   IDR_HTMLPAD_TBFORMAT,   384,  55, 12,
                CBS_DROPDOWNLIST},
        { 0, 0, 0, 0, 0}
    };

    static const TBBUTTON tbStdButton[] =
    {
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_NEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_OPEN, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 2, IDM_SAVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 3, IDM_CUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 4, IDM_COPY, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_PASTE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 6, IDM_UNDO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 7, IDM_REDO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 8, IDM_BOOKMARK, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 9, IDM_HYPERLINK, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {10, IDM_HORIZONTALLINE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_IMAGE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {12, IDM_TABLE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {13, IDM_SHOWHIDE_CODE, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {60, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {14, IDM_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {15, IDM_PAGEINFO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {16, IDM_PAD_FONTINC, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {17, IDM_PAD_FONTDEC, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
   };

    static const TBBUTTON tbFmtButton[] =
    {
        // reserved space for HTML Markup Tag,FontName, and FontSize Comboboxes
        {110, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {155, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        { 45, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {0, IDM_BOLD,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {1, IDM_ITALIC,    TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {2, IDM_UNDERLINE, TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},

        // reserved space for BackGroundColor Combobox.
        { 65, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {3, IDM_JUSTIFYLEFT,   TBSTATE_CHECKED, TBSTYLE_CHECKGROUP, 0L, 0},
        {4, IDM_JUSTIFYCENTER, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {5, IDM_JUSTIFYRIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {6, IDM_ORDERLIST,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0L, 0},
        {7, IDM_UNORDERLIST, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {8, IDM_OUTDENT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {9, IDM_INDENT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
    };

    // Ensure that the common control DLL is loaded for status window.
    InitCommonControls();

    // Create toolbars.
    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_HTMLPAD_TBSTANDARD,
            18,
            g_hInstResource,
            IDB_HTMLPAD_TBSTANDARD,
            (LPCTBBUTTON) &tbStdButton,
            ARRAY_SIZE(tbStdButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!_hwndToolbar)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _hwndTBFormat = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_HTMLPAD_TBFORMAT,
            10,
            g_hInstResource,
            IDB_HTMLPAD_TBFORMAT,
            (LPCTBBUTTON) &tbFmtButton,
            ARRAY_SIZE(tbFmtButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!(_hwndTBFormat))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_BLOCKFMT:
            pHwndCombo = &_hwndComboTag;
            break;
        case IDM_FONTNAME:
            pHwndCombo = &_hwndComboFont;
            break;
        case IDM_FONTSIZE:
            pHwndCombo = &_hwndComboSize;
            break;
        case IDM_FORECOLOR:
            pHwndCombo = &_hwndComboColor;
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLPAD_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLPAD_TBFORMAT:
            hwndToolbar = _hwndTBFormat;
            break;
        }

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                _hwnd,
                (HMENU)tbCombos[cTBCombos].ComboIDM,
                g_hInstResource,
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(ANSI_VAR_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM) hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);

        EnableWindow(*pHwndCombo, TRUE);
        SetParent(*pHwndCombo, hwndToolbar);
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
    }

    LoadToolbarUI();
    ::ShowWindow(_hwndToolbar, SW_SHOW);
    ::ShowWindow(_hwndTBFormat, SW_SHOW);

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(LOGFONT FAR *    lplf,
             TEXTMETRIC FAR * lptm,
             int              iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const wchar_t *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);

    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}


//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------

struct ComboItem {
        TCHAR * pName;
        LONG   lData;
};

static const ComboItem ComboColorItems[] =
{
    {TEXT("Black"),      RGB(0, 0, 0)},
    {TEXT("Navy"),       RGB(0, 0, 128)},
    {TEXT("Blue"),       RGB(0, 0, 255)},
    {TEXT("Cyan"),       RGB(0, 255, 255)},
    {TEXT("Red"),        RGB(255, 0, 0)},
    {TEXT("Lime"),       RGB(0, 255, 0)},
    {TEXT("Gray"),       RGB(128, 128, 128)},
    {TEXT("Green"),      RGB(0, 128, 0)},
    {TEXT("Yellow"),     RGB(255, 255, 0)},
    {TEXT("Pink"),       RGB(255, 192, 203)},
    {TEXT("Violet"),     RGB(238, 130, 238)},
    {TEXT("White"),      RGB(255, 255, 255)},
    {NULL, 0L}
};


DWORD AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;

    while(pComboItems->pName)
    {
        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) pComboItems->pName);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}



void ConvColorrefToString(COLORREF crColor, LPTSTR szName)
{
    int     i;
    BOOL fFound = FALSE;

    for(i = 0; ComboColorItems[i].pName != NULL; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        _tcscpy(szName, ComboColorItems[i].pName);
    else
        szName[0] = 0;
}


//+-------------------------------------------------------------------
//
// Member:  CPadMessage::LoadToolbarUI
//
//--------------------------------------------------------------------

void
CPadMessage::LoadToolbarUI()
{
    HDC      hdc;
    HRESULT  hr;

    // load items into ComboTag, ComboZoom and ComboSize comboboxes
    static const UINT ComboLoad[] = {
            IDM_FONTSIZE,
            IDM_GETBLOCKFMTS,
            0
    };

    VARIANTARG varRange;
    LONG lLBound, lUBound, lIndex, lValue;
    BSTR  bstrBuf;
    TCHAR szBuf[64];
    SAFEARRAY * psa = NULL;
    HWND hwndCombobox = NULL;
    int i;
    IOleCommandTarget * pCommandTarget = NULL;

     if ( !_pInPlaceObject  ||
     _pInPlaceObject->QueryInterface(
        IID_IOleCommandTarget, (void **)&pCommandTarget) )
    {
        // FAIL
        return;
    }

    for (i = 0; ComboLoad[i]; i ++)
    {
        switch (ComboLoad[i])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            break;
        case IDM_GETBLOCKFMTS:
            hwndCombobox = _hwndComboTag;
            break;
        }
        varRange.vt = VT_ARRAY;
        varRange.parray = psa;

       hr = THR(pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                ComboLoad[i],
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &varRange));
        if (OK(hr))
        {
            psa = V_ARRAY(&varRange);
            SafeArrayGetLBound(psa, 1, &lLBound);
            SafeArrayGetUBound(psa, 1, &lUBound);
            for (lIndex = lLBound; lIndex <= lUBound; lIndex ++)
            {
                switch (ComboLoad[i])
                {
                case IDM_GETBLOCKFMTS:
                    SafeArrayGetElement(psa, &lIndex, &bstrBuf);
                    SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) bstrBuf);
                    SysFreeString(bstrBuf);
                    break;

                case IDM_FONTSIZE:
                    SafeArrayGetElement(psa, &lIndex, &lValue);
                    Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), lValue);
                    SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    break;
                }
            }
            SafeArrayDestroyData(psa);
            SafeArrayDestroy(psa);
        }
    }

    HWND hWndInPlace;

    if (_pInPlaceObject)
    {
        _pInPlaceObject->GetWindow(&hWndInPlace);
    }
    if (!hWndInPlace)
        hWndInPlace = _hwnd;

    // insert font facenames to Font combobox.
    hdc = ::GetDC(hWndInPlace);
    EnumFontFamilies(
            hdc,
            NULL,
            (FONTENUMPROC) FillFontProc,
            (LPARAM)_hwndComboFont);
    ::ReleaseDC(hWndInPlace, hdc);

    // load items into ComboColor combobox and set default selection.
    AddComboboxItems(_hwndComboColor, TRUE, ComboColorItems);
    SendMessage(_hwndComboColor, CB_SETCURSEL, 0, 0);

    ReleaseInterface(pCommandTarget);
}



LRESULT
CPadMessage::OnCommand(WORD wNotifyCode, WORD idm, HWND hwndCtl)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    VARIANTARG *        pvarIn  = NULL;
    VARIANTARG *        pvarOut = NULL;
    VARIANTARG          var;
    TCHAR               achBuffer[64];
    BOOL                fRestoreFocus = FALSE;
    DWORD               nCmdexecopt = MSOCMDEXECOPT_DONTPROMPTUSER;

    switch (idm)
    {
        case IDM_FONTSIZE:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboSize,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt   = VT_I4;
            var.lVal = _wtoi(achBuffer);
            pvarIn   = &var;
            break;

        case IDM_BLOCKFMT:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboTag,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt      = VT_BSTR;
            var.bstrVal = achBuffer;
            pvarIn      = &var;
            break;

        case IDM_FONTNAME:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboFont,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt      = VT_BSTR;
            var.bstrVal = achBuffer;
            pvarIn      = &var;
            break;

        case IDM_FORECOLOR:
            fRestoreFocus = TRUE;

            var.lVal = SendMessage(
                    _hwndComboColor,
                    CB_GETITEMDATA,
                    (WPARAM) SendMessage(_hwndComboColor, CB_GETCURSEL, 0, 0),
                    0);
            var.vt      = VT_I4;
            pvarIn      = &var;
            break;
    }

    switch(idm)
    {
        case IDM_MESSAGE_PRINT:
            idm = IDM_PRINT;
            // fall through

        case IDM_PRINTPREVIEW:
        case IDM_IMAGE:
        case IDM_HYPERLINK:
        case IDM_BOOKMARK:
        case IDM_FIND:
        case IDM_REPLACE:
        case IDM_PARAGRAPH:
        case IDM_GOTO:
        case IDM_FONT:
        case IDM_INSERTOBJECT:
            nCmdexecopt = 0;
            // fall through

        case IDM_CUT:
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_PASTEINSERT:
        case IDM_DELETE:
        case IDM_SELECTALL:

        case IDM_NEW:
        case IDM_OPEN:
        case IDM_SAVE:
        case IDM_PASTESPECIAL:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_HORIZONTALLINE:
        case IDM_SHOWHIDE_CODE:
        case IDM_PROPERTIES:
        case IDM_BOLD:
        case IDM_ITALIC:
        case IDM_UNDERLINE:
        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_ORDERLIST:
        case IDM_UNORDERLIST:
        case IDM_OUTDENT:
        case IDM_INDENT:
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
        case IDM_FONTSIZE:
        case IDM_FORECOLOR:

        case IDM_UNLINK:
        case IDM_UNBOOKMARK:
        case IDM_TOOLBARS:
        case IDM_STATUSBAR:
        case IDM_FORMATMARK:
        case IDM_TEXTONLY:
        case IDM_BASELINEFONT5:
        case IDM_BASELINEFONT4:
        case IDM_BASELINEFONT3:
        case IDM_BASELINEFONT2:
        case IDM_BASELINEFONT1:
        case IDM_PAD_REFRESH:
        case IDM_EDITSOURCE:
        case IDM_FOLLOWLINKC:
        case IDM_FOLLOWLINKN:
        case IDM_OPTIONS:
        case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_IFRAME:
        case IDM_1D:
        case IDM_TEXTBOX:
        case IDM_TEXTAREA:
#ifdef NEVER        
        case IDM_HTMLAREA:
#endif        
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:
        case IDM_FORM:
        case IDM_MARQUEE:
        case IDM_LIST:
        case IDM_PREFORMATTED:
        case IDM_ADDRESS:
        case IDM_BLINK:
        case IDM_DIV:
        case IDM_TABLEINSERT:
        case IDM_ROWINSERT:
        case IDM_COLUMNSELECT:
        case IDM_TABLESELECT:
        case IDM_CELLPROPERTIES:
        case IDM_TABLEPROPERTIES:
        case IDM_HELP_CONTENT:
        case IDM_HELP_ABOUT:

            if ( _pInPlaceObject &&
                 OK(_pInPlaceObject->QueryInterface(
                    IID_IOleCommandTarget, (void **)&pCommandTarget)) )
            {
                hr = pCommandTarget->Exec(
                        &CGID_MSHTML,
                        idm,
                        nCmdexecopt,
                        pvarIn,
                        pvarOut);
                // When the user selects a combo item, pop the focus pack into the document.
                if (fRestoreFocus)
                {

                    HWND    hWndInPlace;

                    _pInPlaceObject->GetWindow(&hWndInPlace);
                    if (hWndInPlace)
                    {
                        ::SetFocus (hWndInPlace);
                    }
                }
            }
            break;

        default:
            CPadDoc::OnCommand(wNotifyCode, idm, hwndCtl);
    }

    CheckError(_hwnd, hr);
    ReleaseInterface(pCommandTarget);
    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     CPadMessage::UpdateToolbarUI
//
//  Synopsis:
//
//--------------------------------------------------------------------

LRESULT
CPadMessage::UpdateToolbarUI()
{
    struct ButtonInfo {
        UINT ButtonIDM;
        UINT ToolbarIDR;
    };

    static const ButtonInfo tbButtons[] =
    {
        { IDM_NEW,              IDR_HTMLPAD_TBSTANDARD },
        { IDM_OPEN,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_SAVE,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_UNDO,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_REDO,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_TABLE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_BOOKMARK,         IDR_HTMLPAD_TBSTANDARD },
        { IDM_HYPERLINK,        IDR_HTMLPAD_TBSTANDARD },
        { IDM_HORIZONTALLINE,   IDR_HTMLPAD_TBSTANDARD },
        { IDM_IMAGE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_SHOWHIDE_CODE,    IDR_HTMLPAD_TBSTANDARD },
        { IDM_PROPERTIES,       IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAGEINFO,         IDR_HTMLPAD_TBSTANDARD },
        { IDM_CUT,              IDR_HTMLPAD_TBSTANDARD },
        { IDM_COPY,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_PASTE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAD_FONTINC,      IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAD_FONTDEC,      IDR_HTMLPAD_TBSTANDARD },

        { IDM_BOLD,             IDR_HTMLPAD_TBFORMAT },
        { IDM_ITALIC,           IDR_HTMLPAD_TBFORMAT },
        { IDM_UNDERLINE,        IDR_HTMLPAD_TBFORMAT },
        { IDM_ORDERLIST,        IDR_HTMLPAD_TBFORMAT },
        { IDM_UNORDERLIST,      IDR_HTMLPAD_TBFORMAT },
        { IDM_INDENT,           IDR_HTMLPAD_TBFORMAT },
        { IDM_OUTDENT,          IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYLEFT,      IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYCENTER,    IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYRIGHT,     IDR_HTMLPAD_TBFORMAT },
        { IDM_MULTIPLESELECTION,IDR_HTMLPAD_TBFORMAT },        
        { IDM_2D_POSITION,      IDR_HTMLPAD_TBFORMAT },
        { IDM_ABSOLUTE_POSITION,IDR_HTMLPAD_TBFORMAT },
        { IDM_LIVERESIZE,       IDR_HTMLPAD_TBFORMAT },
       { 0, 0}
    };

    UINT        cButtons;
    HWND        hwndToolbar = NULL;
    HRESULT     hr = S_OK;
    MSOCMD      msocmd;
    IOleCommandTarget * pCommandTarget = NULL;
    HWND  hwndCombobox = NULL;

    static const UINT ComboSet[] = {
            IDM_FONTNAME,
            IDM_FONTSIZE,
            IDM_BLOCKFMT,
            IDM_FORECOLOR,
            0 };

     if ( !_pInPlaceObject  ||
     _pInPlaceObject->QueryInterface(
        IID_IOleCommandTarget, (void **)&pCommandTarget) )
    {
        // FAIL
        goto Cleanup;
    }
    // update zoom combobox status

    VARIANTARG var;
    int j, iIndex, iCurrentIndex;
    TCHAR szBuf[128];

    for (j = 0; ComboSet[j]; j ++)
    {
        switch (ComboSet[j])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            var.vt   = VT_I4;
            var.lVal = 0;
            break;
        case IDM_BLOCKFMT:
            hwndCombobox = _hwndComboTag;
            var.vt      = VT_BSTR;
            var.bstrVal = NULL;
            break;
        case IDM_FONTNAME:
            hwndCombobox = _hwndComboFont;
            var.vt      = VT_BSTR;
            var.bstrVal = NULL;
            break;
        case IDM_FORECOLOR:
            hwndCombobox = _hwndComboColor;
            var.vt      = VT_I4;
            var.lVal = 0;
            break;
        }

        msocmd.cmdID = ComboSet[j];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fShowUI)
        {
            hr = THR(pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL));
        }
        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            EnableWindow(hwndCombobox, TRUE);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableWindow(hwndCombobox, FALSE);
            break;
        }

        // Only if object is active
        if (_fShowUI)
        {
            hr = THR_NOTRACE(pCommandTarget->Exec((GUID *)&CGID_MSHTML, ComboSet[j],
                    MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &var));
            if (FAILED(hr))
                continue;
        }

        switch (ComboSet[j])
        {
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            // It is legal for the returned bstr to be NULL.
            wcscpy(szBuf, var.bstrVal ? var.bstrVal : TEXT(""));
            break;

        case IDM_FORECOLOR:
            if(V_VT(&var) == VT_NULL)
                szBuf[0] = 0;
            else
                ConvColorrefToString(V_I4(&var), szBuf);
            break;

        case IDM_FONTSIZE:
            // If the font size is changing in the selection VT_NULL is returned
            if(V_VT(&var) == VT_NULL)
            {
                szBuf[0] = 0;
            }
            else
            {
                Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), var.lVal);
            }
            break;
        }

        iIndex = SendMessage(
                hwndCombobox,
                CB_FINDSTRINGEXACT,
                (WPARAM) -1,
                (LPARAM)(LPTSTR) szBuf);

        if (iIndex == CB_ERR)
        {
            // CB_FINDSTRINGEXACT cannot find the string in the combobox.
            //
            switch (ComboSet[j])
            {
            case IDM_BLOCKFMT:
                // GetBlockFormat returns something not in the BlockFormat
                // combobox, display empty string.
                //
                iIndex = -1;
                break;

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
                // Nothing is selected
                iIndex = -1;
                break;
            }
        }

        iCurrentIndex = SendMessage(hwndCombobox, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if ( iCurrentIndex != iIndex )
            SendMessage(hwndCombobox, CB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0);

        // If the return value was a string free it
        if(var.vt == VT_BSTR && var.bstrVal != NULL)
            SysFreeString(var.bstrVal);
    }

    // update buttons status
    BOOL fEnabled;
    BOOL fChecked;
    for (cButtons = 0; tbButtons[cButtons].ButtonIDM != 0; cButtons ++)
    {
        switch (tbButtons[cButtons].ToolbarIDR)
        {
        case IDR_HTMLPAD_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLPAD_TBFORMAT:
            hwndToolbar = _hwndTBFormat;
            break;
        }

        if (hwndToolbar)
        {
            msocmd.cmdID = tbButtons[cButtons].ButtonIDM;
            msocmd.cmdf  = 0;

            // Only if object is active
            if (_fActive)
            {
                hr = pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL);
            }

            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_DOWN:
            case MSOCMDSTATE_NINCHED:
                fEnabled = TRUE;
                fChecked = (msocmd.cmdf == MSOCMDSTATE_DOWN) ? TRUE : FALSE;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                fEnabled = FALSE;
                fChecked = FALSE;
                break;
            }
            SendMessage(
                    hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fEnabled, 0));
            SendMessage(
                    hwndToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fChecked, 0));
        }
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    return 0;
}


LRESULT
CPadMessage::OnInitMenuPopup(HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    HRESULT     hr = S_OK;
    int         cMenuItem;
    MSOCMD      msocmd;
    UINT        mf;
    IOleCommandTarget * pCommandTarget =NULL;

    UINT    MenuItem [] =  {
        IDM_UNDO,
        IDM_REDO,
        IDM_CUT,
        IDM_COPY,
        IDM_PASTE,
        IDM_PASTEINSERT,
        IDM_DELETE,
        IDM_SELECTALL,
        IDM_FIND,
        IDM_REPLACE,
        IDM_GOTO,
        IDM_BOOKMARK,
        IDM_HYPERLINK,
        IDM_UNLINK,
        IDM_UNBOOKMARK,
        IDM_TOOLBARS,
        IDM_STATUSBAR,
        IDM_FORMATMARK,
        IDM_TEXTONLY,
        IDM_BASELINEFONT5,
        IDM_BASELINEFONT4,
        IDM_BASELINEFONT3,
        IDM_BASELINEFONT2,
        IDM_BASELINEFONT1,
        IDM_PAD_REFRESH,
        IDM_EDITSOURCE,
        IDM_FOLLOWLINKC,
        IDM_FOLLOWLINKN,
        IDM_PROPERTIES,
        IDM_OPTIONS,
        IDM_HORIZONTALLINE,
        IDM_LINEBREAKNORMAL,
        IDM_LINEBREAKLEFT,
        IDM_LINEBREAKRIGHT,
        IDM_LINEBREAKBOTH,
        IDM_NONBREAK,
        IDM_SPECIALCHAR,
        IDM_HTMLSOURCE,
        IDM_IFRAME,
        IDM_1D,
        IDM_TEXTBOX,
        IDM_TEXTAREA,
        IDM_HTMLAREA,
        IDM_CHECKBOX,
        IDM_RADIOBUTTON,
        IDM_DROPDOWNBOX,
        IDM_LISTBOX,
        IDM_BUTTON,
        IDM_IMAGE,
        IDM_INSERTOBJECT,
        IDM_FONT,
        IDM_PARAGRAPH,
        IDM_FORM,
        IDM_MARQUEE,
        IDM_LIST,
        IDM_INDENT,
        IDM_OUTDENT,
        IDM_PREFORMATTED,
        IDM_ADDRESS,
        IDM_BLINK,
        IDM_DIV,
        IDM_TABLEINSERT,
        IDM_ROWINSERT,
        IDM_COLUMNINSERT,
        IDM_CELLINSERT,
        IDM_CAPTIONINSERT,
        IDM_CELLMERGE,
        IDM_CELLSPLIT,
        IDM_CELLSELECT,
        IDM_ROWSELECT,
        IDM_COLUMNSELECT,
        IDM_TABLESELECT,
        IDM_CELLPROPERTIES,
        IDM_TABLEPROPERTIES,
        IDM_HELP_CONTENT,
        IDM_HELP_ABOUT,
        0
    };

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    for (cMenuItem = 0; MenuItem[cMenuItem]; cMenuItem ++)
    {
        msocmd.cmdID = MenuItem[cMenuItem];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fActive)
        {
            hr = pCommandTarget->QueryStatus(
                    (GUID *)&CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
        }

        switch (msocmd.cmdf)
        {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
        }
        CheckMenuItem(hmenuPopup, msocmd.cmdID, mf);
        EnableMenuItem(hmenuPopup, msocmd.cmdID, mf);
    }

    CPadDoc::OnInitMenuPopup(hmenuPopup, uPos, fSystemMenu);

Cleanup:
    ReleaseInterface(pCommandTarget);
    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CPadMessage::GetContextMenu
//
//  Synopsis:   Returns the context menu based on the sub-menu id.
//
//-------------------------------------------------------------------------

HRESULT
CPadMessage::GetContextMenu(HMENU *phmenu, int id)
{
    if (!_hMenuCtx)
    {
        _hMenuCtx = LoadMenu(
                g_hInstResource,
                MAKEINTRESOURCE(IDR_HTMLPAD_CONTEXT_MENU));
        if (!_hMenuCtx)
            goto Error;
    }

    *phmenu = GetSubMenu(_hMenuCtx, id);
    if (!*phmenu)
        goto Error;

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgreply.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgreply.cxx
//
//  Contents:   Reply functionality for PadMessage.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

//szRE_PREFIX and szFW_PREFIX have to have the same length
char szRE_PREFIX[] = "RE: ";
char szFW_PREFIX[] = "FW: ";


#define EXCLUDED_PROPS_ON_REPLY     33

SizedSPropTagArray (EXCLUDED_PROPS_ON_REPLY, sptExcludedProps) =
{
    EXCLUDED_PROPS_ON_REPLY,
    {
        PR_SENDER_NAME,
        PR_SENDER_ENTRYID,
        PR_SENDER_SEARCH_KEY,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SENDER_ADDRTYPE,

        PR_RECEIVED_BY_NAME,
        PR_RECEIVED_BY_ENTRYID,
        PR_RECEIVED_BY_SEARCH_KEY,

        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_ENTRYID,
        PR_SENT_REPRESENTING_SEARCH_KEY,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,

        PR_RCVD_REPRESENTING_NAME,
        PR_RCVD_REPRESENTING_ENTRYID,
        PR_RCVD_REPRESENTING_SEARCH_KEY,

        PR_MESSAGE_FLAGS,
        PR_MESSAGE_RECIPIENTS,

        PR_READ_RECEIPT_ENTRYID,
        PR_REPORT_ENTRYID,

        PR_REPLY_RECIPIENT_ENTRIES,
        PR_REPLY_RECIPIENT_NAMES,

        PR_PARENT_KEY,

        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED,

        PR_READ_RECEIPT_REQUESTED,

        PR_CLIENT_SUBMIT_TIME,
        PR_MESSAGE_DELIVERY_TIME,
        PR_MESSAGE_DOWNLOAD_TIME,

        PR_BODY,
        PR_SUBJECT,
        PR_SUBJECT_PREFIX,
        PR_MESSAGE_ATTACHMENTS,

        PR_HTML_BODY,
    }
};


//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::Reply
//
//  Synopsis:   Create a reply message and open a form on it
//
//----------------------------------------------------------------------------

HRESULT CPadMessage::Reply(eREPLYTYPE eReplyType, HWND hwndParent, LPCRECT prect)
{
    HRESULT             hr;
    LONG                cb;
    char *              szSubject = NULL;
    SPropValue          val[2] = {0};
    LPSPropProblemArray pProblems = NULL;
    LPMAPIFORM          pfrmReply = NULL;
    LPPERSISTMESSAGE    ppermsg = NULL;
    LPMAPIMESSAGESITE   pmsgsite = NULL;
    LPMAPIVIEWCONTEXT   pviewctx = NULL;
    LPMESSAGE           pmsg = NULL;
    ULONG               cbNewConvIdx = 0;
    LPBYTE              lpbNewConvIdx = NULL;
    IStream *           pStm;

    Assert(_pmsg);

    // Create new form

    hr = Factory.CreateInstance(NULL, IID_IMAPIForm, (LPVOID FAR *) &pfrmReply);
    if (hr)
    {
        g_LastError.SetLastError(E_OUTOFMEMORY);
        goto err;
    }

    hr = pfrmReply->QueryInterface(IID_IPersistMessage, (LPVOID *) &ppermsg);
    if (hr)
    {
        g_LastError.SetLastError(hr, pfrmReply);
        goto err;
    }

    // Create new message for reply

    hr = _pmsgsite->NewMessage(FALSE, NULL, ppermsg, &pmsg, &pmsgsite, &pviewctx);
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        goto err;
    }

    // Copy message to reply to into the new message

    hr = _pmsg->CopyTo(0, NULL, (LPSPropTagArray)&sptExcludedProps,
                        0, NULL, &IID_IMessage, pmsg, 0, &pProblems);
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsg);
        goto err;
    }

    if (pProblems)
    {
        //DebugTraceProblems("SmplForm: CopyTo returned ...", pProblems);
        //  if any of the errors is other than MAPI_E_COMPUTED, fail
        for(UINT ind = 0; ind < pProblems->cProblem; ++ind)
        {
            if (MAPI_E_COMPUTED != pProblems->aProblem[ind].scode)
            {
                hr = g_LastError.SetLastError(pProblems->aProblem[ind].scode);
                MAPIFreeBuffer(pProblems);
                pProblems = NULL;
                goto err;

            }
        }
        MAPIFreeBuffer(pProblems);
        pProblems = NULL;
    }

    // Compose reply / forward subject

    if (_pval && _pval[irtNormSubject].ulPropTag == PR_NORMALIZED_SUBJECT_A)
        cb = lstrlenA(_pval[irtNormSubject].Value.lpszA);
    else
        cb = 0;

    hr = MAPIAllocateBuffer(cb+lstrlenA(szRE_PREFIX)+1, (LPVOID FAR *) &szSubject);
    if (hr)
    {
        g_LastError.SetLastError(E_OUTOFMEMORY);
        goto err;
    }

    *szSubject = '\0';

    if (eREPLY == eReplyType || eREPLY_ALL == eReplyType)
    {
        lstrcatA(szSubject, szRE_PREFIX);
    }
    else
    {
        lstrcatA(szSubject, szFW_PREFIX);
    }

    if (cb > 0)
    {
        lstrcatA(szSubject, _pval[irtNormSubject].Value.lpszA);
    }

    val[0].Value.lpszA = szSubject;
    val[0].ulPropTag = PR_SUBJECT_A;

    // Compose reply / forward HTML body

    hr = pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                            (LPUNKNOWN FAR *) &pStm);
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    hr = ComposeReply(pStm);
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    /*
     * Create a conversation index for the reply msg based on that of ours
     *
     */
    if (!ScAddConversationIndex(_cbConvIdx, _lpbConvIdx,
                                &cbNewConvIdx, &lpbNewConvIdx))
    {
        val[1].ulPropTag = PR_CONVERSATION_INDEX;
        val[1].Value.bin.cb = cbNewConvIdx;
        val[1].Value.bin.lpb = lpbNewConvIdx;
    }
    else
    {
        val[1].ulPropTag = PR_NULL;
    }

    hr = pmsg->SetProps(2, val, &pProblems);

    MAPIFreeBuffer(lpbNewConvIdx);
    lpbNewConvIdx = NULL;

    MAPIFreeBuffer(szSubject);
    szSubject = NULL;

    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    Assert(!pProblems);

#ifdef NEVER
    // if it's a reply, set the addressee
    if (eREPLY == eReplyType || eREPLY_ALL == eReplyType)
    {
        LPADRLIST pal = NULL;

        hr = MAPIAllocateBuffer(CbNewADRLIST(1), (LPVOID FAR *)&pal);
        if (hr)
        {
            _lsterr.SetLastError(E_OUTOFMEMORY);
            goto err;
        }
        hr = _pmsg->GetProps((LPSPropTagArray) &sptSender, 0, &cVal, &pval);
        if (hr) //treat warnings as an error, 'cause the props we ask for are required
        {
            _lsterr.SetLastError(hr, _pmsg);
            MAPIFreeBuffer(pal);
            goto err;
        }

        Assert(cVal == eDim);

        pval[eRecipType].ulPropTag = PR_RECIPIENT_TYPE;
        pval[eRecipType].Value.l = MAPI_TO;

        Assert(pval[eName].ulPropTag == PR_SENDER_NAME_A);
        pval[eName].ulPropTag = PR_DISPLAY_NAME_A;

        Assert(pval[eAddrType].ulPropTag == PR_SENDER_ADDRTYPE);
        pval[eAddrType].ulPropTag = PR_ADDRTYPE;

        Assert(pval[eEID].ulPropTag == PR_SENDER_ENTRYID);
        pval[eEID].ulPropTag = PR_ENTRYID;

        pal->aEntries[0].rgPropVals = pval;

        pal->cEntries = 1;
        pal->aEntries[0].cValues = eDim;

        hr = pmsg->ModifyRecipients(0, pal);
        FreePadrlist(pal); //this will also free pval
        pal = NULL;
        pval = NULL;
        if (hr)
        {
            _lsterr.SetLastError(hr, pmsg);
            goto err;
        }

        if (eReplyType == eREPLY_ALL)
        {
            hr = THR(MungeRecipients(pmsg, TRUE));
            if (hr)
            {
                _lsterr.SetLastError(hr, pmsg);
                goto err;
            }
        }
    }
#endif

    // Set list of recipients

    hr = THR(SetReplyForwardRecipients(pmsg, eReplyType));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    // Now load and open new message

    hr = ppermsg->Load(pmsgsite, pmsg, 0, MSGFLAG_UNSENT );
    if (hr)
    {
        g_LastError.SetLastError(hr, ppermsg);
        goto err;
    }

    hr = pfrmReply->DoVerb(EXCHIVERB_OPEN, pviewctx, (ULONG)hwndParent, prect);
    if (hr)
    {
        g_LastError.SetLastError(hr, pfrmReply);
        pfrmReply->ShutdownForm(SAVEOPTS_NOSAVE);
        goto err;
    }

err:
    ReleaseInterface(pfrmReply);
    ReleaseInterface(ppermsg);
    ReleaseInterface(pmsgsite);
    ReleaseInterface(pviewctx);
    ReleaseInterface(pmsg);
    ReleaseInterface(pStm);
    RRETURN(hr);
}


/*
 *  CPadMessage::ZapIfMatch
 *
 *  Purpose:
 *      Compare and optionally zap address entry
 *
 *  Arguments:
 *      pae             Address entry to be zapped
 *      fSearchKey      Whether to use search key to compare
 *      cbFrom          What to compare against
 *      pbFrom          What to compare against
 *      fZap            Whether to zap the entry if it matches
 *      pfMatch         If non-null, indicates if match found
 *
 *  Returns:
 *      SCODE           The status
 */
HRESULT
CPadMessage::ZapIfMatch(
    LPADRENTRY pae,
    BOOL fSearchKey,
    ULONG cbFrom,
    LPBYTE pbFrom,
    BOOL fZap,
    LPBOOL pfMatch)
{
    ULONG           ulResult = 0;
    LPSPropValue    pval;

    if (!pae->rgPropVals)
        return S_OK;

    if (fSearchKey)
    {
        // Get the search key from the address entry and check if this is From.
        // Handle MAPI providers that don't give us one....even though it's
        // a required property!
        pval = PvalFind((LPSRow) pae, PR_SEARCH_KEY);
        if (pval)
            ulResult = (cbFrom == pval->Value.bin.cb) &&
                       !memcmp(pbFrom, pval->Value.bin.lpb, (size_t) cbFrom);
    }
    else    // Entry id
    {
        // Get the entry ID from the address entry and check if this is From.
        // Handle MAPI providers that don't give us one....even though it's
        // a required property!
        pval = PvalFind((LPSRow) pae, PR_ENTRYID);
        if (pval)
            _pses->CompareEntryIDs(cbFrom, (LPENTRYID) pbFrom,
                pval->Value.bin.cb, (LPENTRYID) pval->Value.bin.lpb, 0, &ulResult);
    }

    // If this is the From:, don't add it if the caller so desires
    if (fZap && ulResult)
    {
        MAPIFreeBuffer(pae->rgPropVals);
        pae->cValues = 0;
        pae->rgPropVals = NULL;
    }

    if (pfMatch)
    {
        // Tell the caller if match was found
        *pfMatch = !!ulResult;
    }

    return S_OK;
}


/*
 *  CPadMessage::GetReplieeAdrEntry
 *
 *  Purpose:
 *      Gets the repliee's address entry.
 *
 *  Arguments:
 *      pae             The resulting address entry
 */
static INT  rgivalSender[] =
{
    irtSenderName,
    irtSenderAddrType,
    irtSenderEntryid,
    irtSenderEmailAddress,
    irtSenderSearchKey,
};

static ULONG rgulPropTagRepAdrEntry[] =
{
    PR_DISPLAY_NAME,
    PR_ADDRTYPE,
    PR_ENTRYID,
    PR_EMAIL_ADDRESS,
    PR_SEARCH_KEY
};

#define cvalReplieeAdrEntry (sizeof(rgulPropTagRepAdrEntry) / sizeof(rgulPropTagRepAdrEntry[0]))

HRESULT
CPadMessage::GetReplieeAdrEntry(LPADRENTRY pae)
{
    HRESULT     hr;
    INT         itaga;
    SPropValue  rgval[cvalReplieeAdrEntry + 1];
    ADRENTRY    ae;

    // Capone 11811 Forgot to include recipient type in cValues
    ae.cValues = cvalReplieeAdrEntry + 1;
    ae.rgPropVals = rgval;

    // Set the recipient type
    rgval[0].ulPropTag = PR_RECIPIENT_TYPE;
    rgval[0].Value.ul = MAPI_TO;

    // Copy the individual props to build an adrentry
    // Capone 11811 Skip the recipient type property
    for (itaga = 1; itaga < cvalReplieeAdrEntry + 1; ++itaga)
    {
        rgval[itaga] = _pval[rgivalSender[itaga - 1]];
        rgval[itaga].ulPropTag =
            PROP_TAG(PROP_TYPE(rgval[itaga].ulPropTag),
                        PROP_ID(rgulPropTagRepAdrEntry[itaga - 1]));
    }

    // Copy the adrentry to the real destination
    hr = CopyRow(NULL, (LPSRow) &ae, (LPSRow) pae);

    RRETURN(hr);
}


/*
 *  CPadMessage::SetReplieeEntryId
 *
 *  Purpose:
 *      Adds the address entry into the address list.
 *
 *  Arguments:
 *      pal             The address list
 *      cbEid           The entry id size
 *      peid            The entry id
 *      cch             The name size
 *      rgch            The name
 */
HRESULT
CPadMessage::SetReplieeEntryId(
    LPADRLIST * ppal,
    ULONG cbEid,
    LPENTRYID peid,
    LPSTR szName,
    ULONG * piRepliee)
{
    HRESULT         hr;
    ULONG           cchName;
    ULONG           cbRepliee;
    ADRENTRY        aeRepliee;
    LPSPropValue    rgval = NULL;
    LPBYTE          pbEid;
    char*           pbch;

    // Allocate memory for PropVal array of 3 and byte buffer
    // for the entry id and display name.
    cchName = lstrlenA(szName) + 1;
    cbRepliee = 3 * sizeof(SPropValue) + cbEid + cchName;
    hr = THR(MAPIAllocateBuffer(cbRepliee, (void**)&rgval));
    if (hr)
    {
        g_LastError.SetLastError(hr);
        goto Cleanup;
    }

    // Put entry id into address entry
    pbEid = (LPBYTE) &rgval[3];
    memcpy(pbEid, peid, (size_t) cbEid);
    rgval[0].ulPropTag = PR_ENTRYID;
    rgval[0].Value.bin.cb = cbEid;
    rgval[0].Value.bin.lpb = pbEid;

    // Put display name into address entry
    pbch = (char*)(pbEid + cbEid);
    lstrcpyA(pbch, szName);
    rgval[1].ulPropTag = PR_DISPLAY_NAME;
    rgval[1].Value.lpszA = pbch;

    // Put recipient type into address entry
    rgval[2].ulPropTag = PR_RECIPIENT_TYPE;
    rgval[2].Value.l = MAPI_TO;

    aeRepliee.cValues = 3;
    aeRepliee.rgPropVals = rgval;

    // Add the sender to the To: field
    hr = THR(AddRecipientToAdrlist(ppal, &aeRepliee, piRepliee));

    // I'm not supposed to free rgval here!

Cleanup:
    RRETURN(hr);
}


/*
 *  ScSetReplyForwardRecipients
 *
 *  Purpose:
 *      Sets up recipient list for a new message that is being replied to or
 *      forwarded.
 *
 *  Arguments:
 *      pmsgResend      reply message
 *
 *  Returns:
 *      SCODE           The status
 *
 *  Notes:
 *      Since the original recipient list was excluded when this reply
 *      message was created, we should only include things we want.
 *      Below, "Replier" means the user replying, and Replyee means the
 *      person to whom the reply is sent (normally From, but can be overrided).
 */
HRESULT
CPadMessage::SetReplyForwardRecipients(LPMESSAGE pmsgResend, eREPLYTYPE eReplyType)
{
    HRESULT         hr = S_OK;
    LPADRLIST       pal = NULL;
    LPSPropValue    pval = NULL;
    ULONG           iae = 0;
    LPADRENTRY      pae = NULL;
    LPSPropValue    pvalRepliee;
    LPSPropValue    pvalReplieeSearchKey = NULL;
    LPSPropValue    pvalReplier;

    LPFLATENTRYLIST pfel = NULL;
    LPFLATENTRY     pfe;
    LPBYTE          pbfe;
    ULONG           ife;

    INT             cRepliee = 0;
    ULONG *         rgiRepliee = NULL;
    INT             iRepliee;

    LPSPropValue    pvalRepRecNames;
    LPSTR           szRepRecNames = NULL;

    if (eReplyType == eREPLY_ALL)
    {
        // Reply all - Get recipient rows
        hr = THR(GetMsgAdrlist(_pmsg, (LPSRowSet*)&pal, &g_LastError));
        if (hr)
        {
            goto Cleanup;
        }

        Assert(pal);
    }

    // Get name(s) for To: field from PR_REPLY_RECIPIENT_ENTRIES (if present)

    // Find out who is (are) the repliee(s)
    pvalRepliee = &_pval[irtReplyRecipientEntries];
    if (pvalRepliee->ulPropTag != PR_REPLY_RECIPIENT_ENTRIES)
    {
        AssertSz(pvalRepliee->Value.err == MAPI_E_NOT_FOUND, "No reply_recipient_entries");

        // Use Sender_XXX

        if (_pval[irtSenderSearchKey].ulPropTag
                                            == PR_SENDER_SEARCH_KEY)
        {
            pvalReplieeSearchKey = &_pval[irtSenderSearchKey];
            cRepliee = 1;
        }
    }
    else
    {
        // We have Reply_Recipient_Entries

        pfel = (LPFLATENTRYLIST) pvalRepliee->Value.bin.lpb;
        Assert(pvalRepliee->Value.bin.cb == CbFLATENTRYLIST(pfel));
        cRepliee = (INT) pfel->cEntries;
    }

    // Exchange 29007
    // Expand fix for Exchange 10764 to Reply_Recipient_Entries.
    if (cRepliee)
    {
        rgiRepliee = (ULONG *) new ULONG[cRepliee];
        if (!rgiRepliee)
        {
            hr = _lsterr.SetLastError(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    pvalReplier = &_pval[irtReceivedBySearchKey];
    if (pvalReplier->ulPropTag != PR_RECEIVED_BY_SEARCH_KEY)
    {
        pvalReplier = NULL;
    }

    // Put the current Repliee (From) or the Reply_Recipient_Entries
    // into the To well for Reply and Reply All

    if (eReplyType != eFORWARD)
    {
        if (pfel)   // Reply_Recipient_Entries
        {
            char * pchName;     // Current name
            char * pchNext;     // Next name
#if DBG == 1
            char * pchFirst;    // First name
            ULONG cchTotal;     // Length of names string
#endif // DEBUG

            // Get the reply_recipient_names
            pvalRepRecNames = &_pval[irtReplyRecipientNames];
            if (pvalRepRecNames->ulPropTag != PR_REPLY_RECIPIENT_NAMES)
              //$ ISSUE -- Should this report an error?
                goto Cleanup;

            // Initialize vars
            szRepRecNames = new char(lstrlenA(pvalRepRecNames->Value.lpszA)+1);
            lstrcpyA(szRepRecNames, pvalRepRecNames->Value.lpszA);
            pchName = pchNext = szRepRecNames;
#if DBG == 1
            pchFirst = szRepRecNames;
            cchTotal = lstrlenA(szRepRecNames);
#endif // DEBUG

            // Loop through the reply_recipient_entries
            for (ife = 0, pbfe = pfel->abEntries;
                    ife < pfel->cEntries;
                    ife++,
                    pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
            {
                pfe = (LPFLATENTRY) pbfe;

                // Find the end of the current display name
                while (*pchNext != TEXT(';') && *pchNext != TEXT('\0'))
                {
#if DBG == 1
                    Assert((ULONG) (pchNext - pchFirst) < cchTotal);
#endif
                    pchNext++;
                }

                // Stringify the display name of the current entry id
                if (*pchNext == TEXT(';'))
                {
                    *pchNext = TEXT('\0');
                    pchNext++;
                }
#if DBG == 1
                else    // End of string; Last name for last entry
                {
                    Assert(ife + 1 == pfel->cEntries);
                }
#endif // DEBUG

                // Set the current entry id as a repliee
                hr = THR(SetReplieeEntryId(&pal, pfe->cb,
                        (LPENTRYID) pfe->abEntry, pchName, &rgiRepliee[ife]));
                if (hr)
                    goto Cleanup;

                // Start of next display name
                pchName = pchNext;
            }
        }
        else    // No Reply_Recipient_Entries
        {
            ADRENTRY        aeRepliee;

            // Pull out the values
            hr = THR(GetReplieeAdrEntry(&aeRepliee));
            if (hr)
                goto Cleanup;

            // Exchange 6756
            // Handle a reply or reply all message with an "empty" address
            // list because the original message did not have a sender.
            if (PvalFind((LPSRow) &aeRepliee, PR_ENTRYID) ||
                PvalFind((LPSRow) &aeRepliee, PR_DISPLAY_NAME))
            {
                hr = THR(AddRecipientToAdrlist(&pal, &aeRepliee, rgiRepliee));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                MAPIFreeBuffer(aeRepliee.rgPropVals);
            }
        }
    }

    // Remove Replier and Repliee from the wells. (Capone spec 1.12 8-42)

    if (eReplyType == eREPLY_ALL)
    {
        // Remove Replier (Me) from the To well.
        // Remove Replier (Me) and Repliee (From) from the Cc well.

        LPADRENTRY  paeMeInToList = NULL;
        ULONG       cEntriesInToList = 0;

        for (iae = 0, pae = pal->aEntries; iae < pal->cEntries; iae++, pae++)
        {
            // Can't let the store see a TRUE PR_RESPONSIBLITY here
            pval = PvalFind((LPSRow) pae, PR_RESPONSIBILITY);
            if (pval)
                pval->Value.b = FALSE;

            pval = PvalFind((LPSRow) pae, PR_RECIPIENT_TYPE);
            AssertSz(pval, "Address list entry w/o recipient type");
            // Capone 12398 Another missing required property!
            if (!pval)
            {
                // Kill and skip this entry
                MAPIFreeBuffer(pae->rgPropVals);
                pae->cValues = 0;
                pae->rgPropVals = NULL;
                continue;
            }

            switch (pval->Value.ul)
            {
            case MAPI_BCC:
                // Kill Bcc always
                MAPIFreeBuffer(pae->rgPropVals);
                pae->cValues = 0;
                pae->rgPropVals = NULL;
                break;

            case MAPI_CC:
                if (pfel)   // Reply_Recipient_Entries
                {
                    for (ife = 0, pbfe = pfel->abEntries;
                            ife < pfel->cEntries;
                            ife++,
                            pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
                    {
                        pfe = (LPFLATENTRY) pbfe;

                        // If this is the Repliee (From), have it removed
                        hr = THR(ZapIfMatch(pae, FALSE,
                                    pfe->cb, pfe->abEntry, TRUE, NULL));
                        if (hr)
                            goto Cleanup;
                    }
                }
                else if (pvalReplieeSearchKey)  // No Reply_Recipient_Entries
                {
                    // If this is the Repliee (From), have it removed
                    hr = THR(ZapIfMatch(pae, TRUE,
                            pvalReplieeSearchKey->Value.bin.cb,
                            pvalReplieeSearchKey->Value.bin.lpb, TRUE, NULL));
                    if (hr)
                        goto Cleanup;
                }

                // If this is the Replier (Me), have it removed
                if (pvalReplier)
                {
                    hr = THR(ZapIfMatch(pae, TRUE,
                        pvalReplier->Value.bin.cb, pvalReplier->Value.bin.lpb,
                        TRUE, NULL));
                    if (hr)
                        goto Cleanup;
                }
                break;

            case MAPI_TO:
                // If this is the Replier (Me), see if it needs to be
                // removed.
                // RAID 10764: Duplicate Repliees also need to be
                // removed from the To: list.
                // We know where the one we added is - we keep it

                // Exchange 29007
                // Expand fix for Exchange 10764 to Reply_Recipient_Entries.
                for (iRepliee = 0; iRepliee < cRepliee; iRepliee++)
                    if (iae == (ULONG) rgiRepliee[iRepliee])
                        break;

                if (cRepliee && (iRepliee == cRepliee))
                {
                    BOOL fMatch = FALSE;

                    if (pfel)   // Reply_Recipient_Entries
                    {
                        for (ife = 0, pbfe = pfel->abEntries;
                                ife < pfel->cEntries;
                                ife++,
                                pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
                        {
                            pfe = (LPFLATENTRY) pbfe;

                            // If this is the Repliee (From), have it removed
                            hr = THR(ZapIfMatch(pae, FALSE,
                                        pfe->cb, pfe->abEntry, TRUE, &fMatch));
                            if (hr)
                                goto Cleanup;
                        }
                    }
                    else if (pvalReplieeSearchKey)  // No Reply_Recipient_Entries
                    {
                        // If this is the Repliee (From), have it removed
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplieeSearchKey->Value.bin.cb,
                                pvalReplieeSearchKey->Value.bin.lpb, TRUE, &fMatch));
                        if (hr)
                            goto Cleanup;
                    }

                    // Current entry zapped so move on to the next one
                    if (fMatch)
                        break;
                }

                if (pvalReplier)
                {
                    BOOL fMatch;

                    if (paeMeInToList)
                    {
                        // We have found the replier in the To: well,
                        // if there are any more, they need to be zapped.
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplier->Value.bin.cb,
                                pvalReplier->Value.bin.lpb,
                                TRUE /*fZap*/, &fMatch));
                        if (hr)
                            goto Cleanup;

                        // If entry did not get zapped, bump the To: entry
                        // count.
                        if (!fMatch)
                            cEntriesInToList++;
                    }
                    else
                    {
                        // See if we have the replier here. If so,
                        // remember the entry, but don't zap it yet.
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplier->Value.bin.cb,
                                pvalReplier->Value.bin.lpb,
                                FALSE, &fMatch));
                        if (hr)
                            goto Cleanup;

                        if (fMatch)
                            paeMeInToList = pae;

                        // Match or no match, the entry is still in the
                        // To list, so bump our To list count.
                        cEntriesInToList++;
                    }
                }

                break;
            }
        }

        // If Replier (Me) is in TO well, and there are others too,
        // remove the Replier. The only case the Replier does not get
        // removed is when it's the only one in the list.

        if (paeMeInToList && cEntriesInToList > 1)
        {
            // Kill Replier's entry in the list
            MAPIFreeBuffer(paeMeInToList->rgPropVals);
            paeMeInToList->cValues = 0;
            paeMeInToList->rgPropVals = NULL;
        }
    }

    // Set new list of recipients

    if (pal && pal->cEntries)
    {
        // Record changes in recipient table
        hr = THR(pmsgResend->ModifyRecipients(MODRECIP_ADD, pal));
        if (hr)
		{
			g_LastError.SetLastError(hr, pmsgResend);
			goto Cleanup;
		}
	}

Cleanup:
    delete rgiRepliee;
    delete szRepRecNames;
    RRETURN(hr);
}

///     GetMsgAdrlist
//    retrieves recipients adrlist of a message
HRESULT GetMsgAdrlist (LPMESSAGE pmsg, LPSRowSet * ppRowSet, CLastError * plasterror)
{
    *ppRowSet = NULL;

    LPMAPITABLE pTable = NULL;
    HRESULT hr;

    hr = pmsg->GetRecipientTable (0, &pTable);
    if (!hr)
    {
        hr = HrQueryAllRows(pTable, NULL, NULL, NULL, 0, ppRowSet);
        if (hr)
        {
            plasterror->SetLastError(hr, pTable);
        }
    }
    else
    {
        plasterror->SetLastError(hr, pmsg);
    }

    pTable->Release();

    return hr;
}

HRESULT CPadMessage::ComposeReply(IStream * pStm)
{
    char *     pch;
    char *     pchStartBody;
    char *     pchReplyHeader = NULL;
    char       achTime[256];

    int        cbToWrite;
    int        cb;
    HRESULT    hr = S_OK;
    BOOL       fDeletePch = FALSE;

    if(_pObject && _pObject)
    {
        hr = THR(SaveAsString(&pch));
        if (hr)
            goto Cleanup;

        fDeletePch = TRUE;
    }
    else if (_pval && _pval[irtHtmlBody].ulPropTag == PR_HTML_BODY)
    {
        pch = _pval[irtHtmlBody].Value.lpszA;
    }
    else
    {
        hr = THR(GetHtmlBodyFromMsg(&pch));
        if (hr)
            goto Cleanup;

        fDeletePch = TRUE;
    }

    pchStartBody = strstr( pch, "<BODY");
    if(pchStartBody)
    {
        pchStartBody = strchr(pchStartBody,'>');
        if( pchStartBody == NULL )
        {
            pchStartBody = strstr( pch, "<body");
            pchStartBody = strchr(pchStartBody,'>');
            Assert(pchStartBody);
        }
        pchStartBody++;
    }
    else
    {
        pchStartBody = pch;
    }

    cbToWrite = pchStartBody - pch;

    if(cbToWrite)
    {
        hr = pStm->Write(pch,(ULONG) cbToWrite, NULL);
        if(hr)
            goto Cleanup;
    }

    // TODO: chrisf - should properly define the length below instead of using 500
    // Need to be large enough to accomodate all litteral HTML below
    cb = 500;

    if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
         cb += lstrlenA(_pval[irtSenderName].Value.lpszA);

    if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
         cb += lstrlenA(_pval[irtTo].Value.lpszA);

    if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
         cb += lstrlenA(_pval[irtCc].Value.lpszA);

    if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
         cb += lstrlenA(_pval[irtSubject].Value.lpszA);

    if (_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME)
    {
        FormatTime(&_pval[irtTime].Value.ft, achTime, sizeof(achTime));
        cb += lstrlenA(achTime);
    }
    else
    {
        achTime[0] = '\0';
    }

    pchReplyHeader = new char[cb];
    if(!pchReplyHeader)
        goto Cleanup;

    strcpy(pchReplyHeader,"<P>&nbsp<P><HR ALIGN=LEFT><ADDRESS><STRONG>From: </STRONG>");
    if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
        strcat(pchReplyHeader,_pval[irtSenderName].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Sent: </STRONG>");
    strcat(pchReplyHeader,achTime);

    strcat(pchReplyHeader,"<BR><STRONG>To: </STRONG>");
    if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
        strcat(pchReplyHeader,_pval[irtTo].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Cc: </STRONG>");
    if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
        strcat(pchReplyHeader,_pval[irtCc].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Subject: </STRONG>");
    if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
        strcat(pchReplyHeader,_pval[irtSubject].Value.lpszA);

    strcat(pchReplyHeader,"<BR>&nbsp</ADDRESS>");

    cb = strlen(pchReplyHeader);

    hr = pStm->Write(pchReplyHeader,(ULONG) cb, NULL);
    if(hr)
        goto Cleanup;

    cb = strlen(pch);
    cbToWrite = cb - cbToWrite;

    hr = pStm->Write(pchStartBody,(ULONG) cbToWrite, NULL);
    if(hr)
        goto Cleanup;

Cleanup:
    delete pchReplyHeader;
    if (fDeletePch)
        delete pch;
    RRETURN(hr);
}

HRESULT
CPadMessage::SaveAsString(char ** ppchBuffer)
{
    IStream *   pStm;
    STATSTG     StatStg;
    LONG        cStmLength;
    char *      pch = NULL;
    HRESULT     hr;
    LARGE_INTEGER i64Start = {0, 0};

    hr = CreateStreamOnHGlobal(NULL, NULL, &pStm);
    if (hr)
        goto err;

    hr = CPadDoc::Save(pStm);
    if (hr)
        goto err;

    Verify(pStm->Stat(&StatStg,NULL) == S_OK);

    cStmLength = StatStg.cbSize.LowPart;

    pch = new char[cStmLength+1];
    if(!pch)
        goto err;

    hr = pStm->Seek(i64Start, STREAM_SEEK_SET, NULL);
    if (hr)
        goto err;

    hr = pStm->Read(pch, cStmLength, NULL);
    if (hr)
        goto err;

    pch[cStmLength] = '\0';

    *ppchBuffer = pch;

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);

err:
    delete pch;
    goto Cleanup;
}

HRESULT
CPadMessage::GetHtmlBodyFromMsg(char ** ppchBuffer)
{
    HRESULT     hr;
    STATSTG     StatStg;
    IStream *   pStm;
    LONG        cStmLength;
    char *      pch = NULL;
    LARGE_INTEGER i64Start = {0, 0};

    Assert(_pmsg);

    hr = THR(_pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READ, 0, (LPUNKNOWN FAR *) &pStm));

    if (hr)
        goto Cleanup;

    Verify(pStm->Stat(&StatStg,NULL) == S_OK);

    cStmLength = StatStg.cbSize.LowPart;

    pch = new char[cStmLength+1];
    if(!pch)
        goto err;

    hr = pStm->Seek(i64Start, STREAM_SEEK_SET, NULL);
    if (hr)
        goto err;

    hr = pStm->Read(pch, cStmLength, NULL);
    if (hr)
        goto err;

    pch[cStmLength] = '\0';

    *ppchBuffer = pch;

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);

err:
    delete pch;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       msgreg.cxx
//
//  Contents:   Stuff to register pad as an Exchange custom form
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_PADRC2_H_
#define X_PADRC2_H_
#include "padrc2.h"
#endif

HRESULT
RegisterOneClass(HKEY hkeyCLSID, TCHAR *pchFile, REFCLSID clsid, TCHAR *pchProgID, TCHAR *pchFriendly);


//+------------------------------------------------------------------------
//
// Function:    WriteFileResource
//
// Synopsis:    Write out a resource as a file in temp directory
//
//-------------------------------------------------------------------------

static HRESULT
WriteFileResource(DWORD dwResId, TCHAR * pchFilePath)
{
    HRESULT hr = E_FAIL;
    HRSRC hrsrc = 0;
    HGLOBAL hglbl = 0;
    void* pvRes;
    DWORD cbRes;
    DWORD cbWritten;
    HANDLE hFile =  INVALID_HANDLE_VALUE;

    hrsrc = FindResource(g_hInstResource, MAKEINTRESOURCE(dwResId), MAKEINTRESOURCE(FILERESOURCE));
    if(!hrsrc)
        goto Cleanup;

    cbRes = SizeofResource(g_hInstResource, hrsrc);
    Assert(cbRes > 0);

    hglbl = LoadResource(g_hInstResource, hrsrc);
    if(!hglbl)
        goto Cleanup;

    pvRes = LockResource(hglbl);
    if(!pvRes)
        goto Cleanup;

    hFile = CreateFile(
                pchFilePath,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    if(!WriteFile(
                hFile,
                pvRes,
                cbRes,
                &cbWritten,
                NULL))
        goto Cleanup;

    Assert(cbWritten == cbRes);

    hr = S_OK;

Cleanup:
    CloseHandle(hFile);
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
// Function:    RegisterMsgServer
//
// Synopsis:    Register PadMessage for this server.
//
//-------------------------------------------------------------------------

static HRESULT
RegisterMsgServer()
{
    HRESULT hr;
    HKEY    hkeyCLSID = 0;
    TCHAR   achExe[MAX_PATH];

    GetModuleFileName(0, achExe, ARRAY_SIZE(achExe));

    hr = THR(RegDbOpenCLSIDKey(&hkeyCLSID));
    if (hr)
        RRETURN(hr);

    hr = THR(RegisterOneClass(
            hkeyCLSID,
            achExe,
            CLSID_CPadMessage,
            _T("IPM.Note.Trident"),
            _T("Trident Message")));
    if (hr)
        goto Cleanup;

Cleanup:
    RegCloseKey(hkeyCLSID);
    RegFlushKey(HKEY_CLASSES_ROOT);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
// Function:    RegisterMsg
//
// Synopsis:    Register PadMessage as an Exchange custom form
//
//-------------------------------------------------------------------------

HRESULT
RegisterMsg(BOOL fDialog)
{
    HRESULT hr;
    LPMAPIFORMCONTAINER pFormContainer;
    TCHAR achFilePath[MAX_PATH];
    TCHAR * pchFileName;
    DWORD cchTempPath;
    char achBuf[MAX_PATH];

    hr = THR(RegisterMsgServer());
    if (hr)
        goto Cleanup;

    cchTempPath = GetTempPath(MAX_PATH, achFilePath);
    if(!cchTempPath)
        goto Cleanup;

    pchFileName = achFilePath + cchTempPath;

    wcscpy(pchFileName, _T("padicon.ico"));

    hr = THR(WriteFileResource(IDF_LARGE_ICON, achFilePath));
    if (hr)
        goto Cleanup;

    wcscpy(pchFileName, _T("padsmall.ico"));

    hr = THR(WriteFileResource(IDF_SMALL_ICON, achFilePath));
    if (hr)
        goto Cleanup;

    wcscpy(pchFileName, _T("msg.cfg"));

    hr = THR(WriteFileResource(IDF_CFG_FILE, achFilePath));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIInitialize(NULL));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIOpenLocalFormContainer(&pFormContainer));
    if (hr)
        goto Cleanup;

    // Mapi needs ANSI
    WideCharToMultiByte(CP_ACP, 0, achFilePath, -1,
                achBuf, sizeof(achBuf), NULL, NULL);

    hr = THR(pFormContainer->InstallForm(
                NULL,
                MAPIFORM_INSTALL_OVERWRITEONCONFLICT,
                (LPCTSTR)achBuf));
    if (hr)
        goto Cleanup;


Cleanup:
    ReleaseInterface(pFormContainer);
    MAPIUninitialize();

    if (fDialog)
    {
        if (!hr)
        {
            MessageBox(NULL,
                       _T("Trident has been installed as an Exchange Form"),
                       _T("Trident Exchange Mail"),
                       MB_OK);
        }
        else
        {
            char ach[300];

            wsprintfA(ach,
                      "Unable to register Trident as an Exchange Form (error %08x).",
                      hr);

            MessageBoxA(NULL,
                        ach,
                        "Trident Exchange Mail",
                        MB_OK);
        }
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
// Function:    UnregisterMsg
//
// Synopsis:    Unregister PadMessage as an Exchange custom form
//
//-------------------------------------------------------------------------

HRESULT
UnregisterMsg()
{
    HRESULT hr;
    LPMAPIFORMCONTAINER pFormContainer;

    hr = THR(MAPIInitialize(NULL));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIOpenLocalFormContainer(&pFormContainer));
    if (hr)
        goto Cleanup;

    hr = THR(pFormContainer->RemoveForm(g_achFormClassName));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pFormContainer);
    MAPIUninitialize();
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgtripl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgtripl.cxx
//
//  Contents:   Recipient object (CTriple) implementation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

static HPEN hpenUnderline = 0;

#define	CTXCK_RecipOptions	1
#define CTXCK_AddToPAB		2

#ifdef DBCS
#define LangJpn	0x0411
#define LangKor	0x0412
#endif

#ifndef MAC
#ifdef WIN32
#define	RTEXPORT	WINAPI
#else
#define	RTEXPORT	_export __loadds
#endif
#else // MAC
#define RTEXPORT
#endif // MAC


// $MAC - Only supports 4 character format names
#ifndef MAC
#define CF_TRIPLE	TEXT("MsMail 4.0 Recipient")
#else
#define CF_TRIPLE	TEXT("XCGA")
#endif

TCHAR CTripData::s_szClipFormatTriple[] = CF_TRIPLE;

FORMATETC CTripData::s_rgformatetcTRIPOLE[] =
{
	{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
	{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
};

#define	iFormatTriple		0
#define	iFormatText			1

#define cformatetcTRIPOLE (sizeof(s_rgformatetcTRIPOLE) / sizeof(FORMATETC))


#ifdef WIN32
#define OleStdMalloc(_ul)			CoTaskMemAlloc(_ul)
#define OleStdFree(_pv)				CoTaskMemFree(_pv)
#define OleStdFreeString(_sz, _pm)	CoTaskMemFree(_sz)
#ifdef MAC
LPSTR OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
#endif
#else
LPVOID OleStdMalloc(ULONG ulSize);
void OleStdFree(LPVOID pmem);
ULONG OleStdGetSize(LPVOID pmem);
void OleStdFreeString(LPSTR lpsz, LPMALLOC lpMalloc);
LPSTR OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
#endif


#define	FreeAdrlist(_pal)		FreeSRowSet((LPSRowSet) _pal)


#if DBG == 1
	CTriple * g_pTripObject = NULL;
#endif


/*
 *	OpenPAB
 *	
 *	Purpose:
 *		This function opens up the default Personal Address Book.
 *		Note: it does an OpenEntry() w/ MAPI_DEFERRED_ERRORS for
 *		better performance.  Error handling code for the caller
 *		of this function needs to be correct.
 *	
 *	Parameters:
 *		pab			pointer to Address Book
 *		ppabc		pointer to pointer to AB container
 *	
 *	Returns:
 *		hr
 */
HRESULT OpenPAB(LPADRBOOK pab, LPABCONT * ppabc)
{
	HRESULT			hr;
	ULONG			cbEid;
	LPENTRYID		peid;
	ULONG			ul;

	hr = pab->GetPAB(&cbEid, &peid);
	if (hr != S_OK)
		goto Error;

	hr = pab->OpenEntry(cbEid, peid,
					NULL, MAPI_DEFERRED_ERRORS, &ul, (LPUNKNOWN *) ppabc);
	
    MAPIFreeBuffer(peid);
	if (hr != S_OK)
		goto Error;

	Assert(ul == MAPI_ABCONT);
	return S_OK;

Error:
	RRETURN(g_LastError.SetLastError(hr, pab));
}

/*
 *	CopyBufferToRow
 *	
 *	Purpose:
 *		This copies the properties from a flat buffer to a row.
 *
 *		NOTE - Multi Value propertis not supported right now
 *	
 *		NOTE - tripole.c relies on specific behaviour of this function
 *	
 *	Parameters:
 *		pb			pointer to the buffer
 *		prwDst		destination row (with lpProps already allocated)
 *	
 *	Returns:
 *		sc
 */
VOID CALLBACK CopyBufferToRow(LPBYTE pb, LPSRow prwDst)
{
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	LPBYTE			pbSrc;
	LPBYTE			pbDst;

	// Do the finicky copy of the items one-by-one.

	iCol = prwDst->cValues = *((ULONG *) pb);
	pvalSrc = (LPSPropValue) (pb + sizeof(ULONG));
	pvalDst = prwDst->lpProps;
	pbSrc = (LPBYTE) (pvalSrc + iCol);		// point past the rgSPropValue.
	pbDst = (LPBYTE) (pvalDst + iCol);		// point past the rgSPropValue.

	while (iCol--)
	{
		pbSrc = CopyPval(pvalSrc, pvalDst, pbSrc, &pbDst, imodeUnflatten);
		++pvalSrc;
		++pvalDst;
	}
}


// MLOLE: Reduced version used by TRIPCALL_GetNewStorage in mapidlg\tripole.c
//		  and by HrGetDataAttachFileContents in mapin\attole.c
/*
 *	StgCreateOnHglobal
 *
 *	Purpose:
 *		Smaller version of OleStdCreateStorageOnHGlobal for Capone use.
 *
 *	Arguments:
 *		None.
 *
 *	Returns:
 *		LPSTORAGE		Created storage, or NULL on error (E_OUTOFMEMORY).
 */
LPSTORAGE StgCreateOnHglobal(VOID)
{
	LPLOCKBYTES plb = NULL;
	LPSTORAGE pstg = NULL;

	// Create lockbytes on hglobal
	if (CreateILockBytesOnHGlobal(NULL, TRUE, &plb))
		return NULL;

	// Create storage on lockbytes
	StgCreateDocfileOnILockBytes(plb, STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE |
			STGM_CREATE | STGM_READWRITE, 0, &pstg);

	// Release our reference on the lockbytes and return the storage
	ReleaseInterface(plb);
	return pstg;
}


/*
 *	StuffRwsInHglobal
 *
 *	Purpose:
 *		Saves an LPSRowSet to a HGLOBAL
 *
 *	Parameters:
 *		prws			pointer to the row set
 *		pmedium			pmedium containing hglobal
 *
 *	Returns:
 *		hr
 */
HRESULT RTEXPORT StuffRwsInHglobal(LPSRowSet prws, LPSTGMEDIUM pmedium)
{
	ULONG			iRow;
	ULONG			cRows		= 0;
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	LPBYTE			pb;
	LPBYTE			pbOld;
	ULONG			cb = 0;

	//TraceTag(tagTripole, "ScStuffRwsInHglobal");

	for (iRow = 0; iRow < prws->cRows; ++iRow)
	{
		pvalSrc = prws->aRow[iRow].lpProps;
		if (pvalSrc == NULL)
			continue;				// skip empty rows

		++cRows;
		cb += 2 * sizeof(ULONG);	// to store the size of buffer required
									// for each row and the number of props
		for (iCol = prws->aRow[iRow].cValues; iCol > 0; ++pvalSrc, --iCol)
		{
			cb += PAD4(CbForPropValue(pvalSrc)) + sizeof(SPropValue);
		}
	}

	pmedium->hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cb);
	if (!pmedium->hGlobal)
		return E_OUTOFMEMORY;
	pb = (BYTE *) GlobalLock(pmedium->hGlobal);
	Assert(pb);

	*((ULONG *) pb) = cRows;
	pb += sizeof(ULONG);

	for (iRow = 0; iRow < prws->cRows; ++iRow)
	{
		pvalSrc = prws->aRow[iRow].lpProps;
		if (pvalSrc == NULL)
			continue;				// skip empty rows

		pbOld = pb;
		pb += sizeof(ULONG);

		iCol = *((ULONG *) pb) = prws->aRow[iRow].cValues;
		pvalDst = (LPSPropValue) (pb + sizeof(ULONG));
		pb = (LPBYTE) (pvalDst + iCol);		// point past the rgSPropValue.

		while (iCol--)
		{
			pb = CopyPval(pvalSrc, pvalDst, pb, NULL, imodeFlatten);
			++pvalSrc;
			++pvalDst;
		}

		*((ULONG *) pbOld) = pb - pbOld - sizeof(ULONG);
	}

	GlobalUnlock(pmedium->hGlobal);
	return S_OK;
}



/*
 *	FindTripleProperties
 *	
 *	Purpose:
 *		This is some common code needed when creating a recipient
 *		in a TRIPLE object.
 *	
 *	Parameters:
 *		ptriple		pointer to triple object
 */
VOID CTriple::FindTripleProperties()
{
	ULONG			i;
	LPSPropValue	pval	= _rw.lpProps;

	_iName = LONG_MAX;
#ifdef	DEBUG
	_iEid = LONG_MAX;
#endif	
	_iType = LONG_MAX;			//$ REVIEW - Is it OK if this is missing?
	for (i = 0; i < _rw.cValues; i++)
	{
		if (pval[i].ulPropTag == PR_DISPLAY_NAME_A)
			_iName = i;
		else if (pval[i].ulPropTag == PR_ENTRYID)
			_iEid = i;
		else if (pval[i].ulPropTag == PR_DISPLAY_TYPE)
			_iType = i;
	}
	AssertSz(_iEid != LONG_MAX, "No EntryId in recipient");
}



/*
 *	T R I P P E R   I m p l e m e n t a t i o n
 */

/*
 *	GetClassID
 *
 *	Purpose:
 *		Returns an object's class identifier.
 *
 *	Parameters:
 *		ppersist		pointer to IPersist object
 *		pClassID		pointer to where to return the object's
 *						CLSID
 *
 *	Returns:
 *		hr
 */
HRESULT CTriple::GetClassID(LPCLSID pClassID)
{
	//TraceTag(tagTripole, "TRIPPER_GetClassID");

	*pClassID = CLSID_CTriple;

	return S_OK;
}


/*
 *	T R I P L E   I m p l e m e n t a t i o n
 */

/*
 *	Constructor CTriple
 *	
 *	Purpose:
 *		Creates a new class CTRIPLE.
 *	
 *	Parameters:
 *		prw			pointer to row respresenting an ADRENTRY
 *	
 *	Returns:
 *		CTriple *	The newly created CTriple.
 */
CTriple::CTriple(CPadMessage * pPad, LPSRow prw)
{
	//TraceTag(tagTripole, "TRIPLE_New");

	_cRef = 1;					// Start with one reference
	_pClientSite = NULL;
	_padvisesink = NULL;
	_pPad = pPad;
	if (prw)
	{
		_rw = *prw;
		FindTripleProperties();
	}

	_pstg = NULL;
	_fUnderline = TRUE;

	// Try to set up an OleAdviseHolder
	CreateOleAdviseHolder(&_poleadviseholder);

#if DBG == 1
	g_pTripObject = this;
#endif
}

/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Parameters:
 *		LPUNKNOWN *	 Object from which we want an interface.
 *		REFIID		 Interface we want.
 *		LPUNKNOWN *	 Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTriple::QueryInterface(REFIID riid,
								   LPVOID * ppvObj)
{
	//TraceTag(tagTripole, "TRIPLE_QueryInterface");

	if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleObject))
	{
		*ppvObj = (IOleObject*)this;
	}
	else if (IsEqualIID(riid, IID_IViewObject))
	{
		*ppvObj = (IViewObject*)this;
	}
	else if (IsEqualIID(riid, IID_IPersist))
    {
		*ppvObj = (IPersist*)this;
	}
    else
	{
		//TraceTag(tagTripole, "Don't know interface %lx", riid->Data1);
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

    (*(IUnknown**)ppvObj)->AddRef();

	return S_OK;
}

/*
 *	AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTriple::AddRef()
{
	//TraceTag(tagTripole, "TRIPLE_AddRef");

	return ++_cRef;
}

/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTriple::Release()
{
	ULONG cRef = --_cRef;

	//TraceTag(tagTripole, "TRIPLE_Release");

	if (!cRef)
	{
		//TraceTag(tagTripole, "TRIPLE_Release: freeing the triple");
#ifdef	DEBUG
		g_pTripObject = NULL;
#endif	
		MAPIFreeBuffer(_rw.lpProps);
		ReleaseInterface(_pClientSite);
		ReleaseInterface(_pstg);
		ReleaseInterface(_poleadviseholder);
		ReleaseInterface(_padvisesink);
		delete this;
	}

	AssertSz(cRef >= 0, "TRIPLE_Release: negative cRef");
	return cRef;
}



/*
 *	SetClientSite
 *	
 *	Purpose:
 *		Stores the IClientSite that this object is contained in.
 *	
 *	Parameters:
 *		pClientSite			the client site
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::SetClientSite(IOleClientSite * pClientSite)
{
	HRESULT			hr;
	CTripCall *		pTripCall;

	//TraceTag(tagTripole, "TRIPOBJECT_SetClientSite");

	if (_pClientSite)
	{
		ClearInterface(&_pClientSite);
	}

	if (!pClientSite)
		return S_OK;

	_pClientSite = pClientSite;
	_pClientSite->AddRef();

	hr = THR(pClientSite->QueryInterface(IID_IRichEditOleCallback, (void**)&pTripCall));

    if (hr == S_OK)
	{
		_fUnderline = pTripCall->GetUnderline();
		pTripCall->Release();
	}

	return S_OK;
}


/*
 *	GetClientSite
 *
 *	Purpose:
 *		Retrieves the IClientSite that this object is contained in.
 *
 *	Parameters:
 *		poleobject			this object
 *		ppClientSite		on return, a pointer to the client site
 *
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetClientSite(IOleClientSite ** ppClientSite)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetClientSite");

	*ppClientSite = _pClientSite;
    _pClientSite->AddRef();

	return S_OK;
}


/*
 *	SetHostNames
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
	//TraceTag(tagTripole, "TRIPOBJECT_SetHostNames");

	return S_OK;
}


/*
 *	Close
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Close(DWORD dwSaveOption)
{
	//TraceTag(tagTripole, "TRIPOBJECT_Close");

	return S_OK;
}


/*
 *	SetMoniker
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_SetMoniker: NYI");
	return E_NOTIMPL;
}


/*
 *	GetMoniker
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetMoniker");

	// I don't do Monikers

	return E_FAIL;
}


/*
 *	InitFromData
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_InitFromData: NYI");
	return E_NOTIMPL;
}


/*
 *	GetClipboardData
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject)
{
	HRESULT			hr;
	SCODE			sc;
	LPSRowSet		prws;
    CTripData *     pTripleData;

	//TraceTag(tagTripole, "TRIPOBJECT_GetClipboardData");

	sc = MAPIAllocateBuffer(CbNewSRowSet(1), (void**)&prws);
	if (sc != S_OK)
		goto MemoryError;

	prws->cRows = 1;
	sc = CopyRow(NULL, &_rw, prws->aRow);
	if (sc != S_OK)
	{
		MAPIFreeBuffer(prws);
		goto MemoryError;
	}
	
    pTripleData = new CTripData(prws);
	if (!pTripleData)
	{
		FreeSRowSet(prws);
		goto MemoryError;
	}

	// Need to do the QueryInterface() to get a wrapped object

	hr = pTripleData->QueryInterface(IID_IDataObject, (void**)ppDataObject);

	// QueryInterface() does an AddRef() so we're up to two,
	// but the object we return should only be at one
	pTripleData->Release();

	RRETURN(hr);

MemoryError:
	RRETURN(E_OUTOFMEMORY);
}


/*
 *	DoVerb
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::DoVerb(LONG iVerb,
				LPMSG lpmsg, IOleClientSite * pActivateSite,
				LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
#ifdef LATER
	HRESULT			hr;
	LPADRBOOK		pab;
	ULONG			ulUIParam	= UlFromHwnd(GetParent(hwndParent));
	static SPropTagArray	taga	= {8, {PR_DISPLAY_NAME_A, PR_DISPLAY_TYPE,
								PR_OBJECT_TYPE, PR_ADDRTYPE, PR_ENTRYID,
								PR_SEARCH_KEY, PR_EMAIL_ADDRESS, PR_NULL}};

	
	//TraceTag(tagTripole, "TRIPOBJECT_DoVerb");

    pab = _pab;
	if (!pab)
	{
		//$ NYI - Do what if no _pab
		return S_OK;
	}

	if (iVerb == 0)
	{
		ULONG			ul;
		LONG			lRecipType;
		LPSPropValue	pval;
		BOOL			fRecipientType	= FALSE;
		DETAILSDATA 	dtd = {0};
		LPMAPIERROR		pme = NULL;
		HRESULT			hr;
		ULONG			cbEid;
		LPENTRYID		peid;

		dtd.ppme = &pme;
		dtd.pab = pab;
		dtd.ulUIParam = ulUIParam;
		dtd.cbEid = _rw.lpProps[_iEid].Value.bin.cb;
		dtd.peid = (LPENTRYID) _rw.lpProps[_iEid].Value.bin.lpb;

		// Do we have a PAB?
		dtd.fShowAddToPAB			= FALSE;
		hr = pab->GetPAB(&cbEid, &peid);
		if (hr == S_OK && peid)
		{
			dtd.fShowAddToPAB		= TRUE;
			MAPIFreeBuffer(peid);
		}

		dtd.fWantPmpReturned = TRUE;
		dtd.lDisplayType = -1;
		Assert(dtd.hr == S_OK);
		Assert(dtd.fNextPrevVisible == FALSE);
		Assert(dtd.fNewEntryInvoked == FALSE);
		Assert(dtd.pabd == NULL);
		Assert(dtd.dtret == 0);
		Assert(dtd.pmp == NULL);
		Assert(dtd.szDisplayName == NULL);
		Assert(dtd.lpfndismiss == NULL);
		Assert(dtd.lpvDismissContext == NULL);
		Assert(dtd.lpfnCustom == NULL);
		Assert(dtd.lpvButtonContext == NULL);
		Assert(dtd.szCustomText == NULL);

		DisplayDetailsDialog(&dtd);
		if (dtd.hr != S_OK || !dtd.fChanged
				|| GetWindowLong(hwndParent, GWL_STYLE) & ES_READONLY)
		{
			if (!dtd.hr)
				dtd.pmp->(dtd.pmp);

			if (dtd.hr && dtd.hr != MAPI_E_USER_CANCEL)
			{
				//TraceError("TRIPOBJECT_DoVerb", GetScode(dtd.hr));
				DisplayTheError(dtd.hr, dtd.ppme);
			}
			goto Cleanup;
		}

		// The user might have changed some of the properties, or the
		// properties may have been changed in the Address Book. If the
		// user OK'd the details dialog, get the new values

		pval = PvalFind(&_rw, PR_RECIPIENT_TYPE);
		if (pval)
		{
			fRecipientType = TRUE;
			lRecipType = pval->Value.l;
		}

		ul = taga.cValues;
		hr = dtd.pmp->GetProps(&taga, 0, &ul, &pval);
		Assert(ul == taga.cValues);
		if (FAILED(hr))
		{
			//ScReportErrorHrPmunk(hr, (LPMAPIUNK) dtd.pmp);
			dtd.pmp->Release();
			goto Cleanup;
		}

		dtd.pmp->Release();
		MAPIFreeBuffer(_rw.lpProps);
		if (fRecipientType)
		{
			pval[ul - 1].ulPropTag = PR_RECIPIENT_TYPE;
			pval[ul - 1].Value.l = lRecipType;
		}

		_rw.cValues = ul;
		_rw.lpProps = pval;
		FindTripleProperties();

		Edit_SetModify(hwndParent, TRUE);
		_padvisesink->OnViewChange(DVASPECT_CONTENT, -1);
	}
	else if (iVerb == 1)
	{
		LPADRENTRY		pae	= (LPADRENTRY) &_rw;

		hr = pab->RecipOptions(ulUIParam, 0, pae);
		if (hr != S_OK)
		{
			//if (hr != MAPI_E_USER_CANCEL)
				//ScReportErrorHrPmunk(hr, (LPMAPIUNK) pabTriple);
			goto Cleanup;
		}
		Assert(pae == (LPADRENTRY) &_rw);
		FindTripleProperties();
		Edit_SetModify(hwndParent, TRUE);
	}
	else if (iVerb == 2)
	{
		LPABCONT		pabcPAB;
		ENTRYLIST		el;
		SBinary			bin;

		if (OpenPAB(pab, &pabcPAB) != S_OK)
		{
			ReportLastErrorNull();
			goto Cleanup;
		}

		el.cValues = 1;
		el.lpbin = &bin;
		bin.cb = _rw.lpProps[_iEid].Value.bin.cb;
		bin.lpb = _rw.lpProps[_iEid].Value.bin.lpb;

		hr = pabcPAB->CopyEntries(pabcPAB, &el, ulUIParam,
					NULL, CREATE_CHECK_DUP_STRICT);
		if (hr != S_OK)
		{
			TraceError("TRIPOBJECT_DoVerb", GetScode(hr));
			ScReportErrorHrPmunk(hr, (LPMAPIUNK) pabcPAB);
		}
		ReleaseInterface(pabcPAB);
	}
	else
	{
		return OLEOBJ_S_INVALIDVERB;
	}

Cleanup:
	return S_OK;
#else
    RRETURN(E_NOTIMPL);
#endif
}


#ifdef LATER
/*
 *	EnumVerbsCallback
 *
 *	Purpose:
 *		Support function for the EnumVerbs() which will allocate
 *		the value for each of the elements
 *
 *	Arguments:
 *		iel			The index of the element
 *		pbDst		Pointer to the data to be munged
 *
 *	Returns:
 *		BOOL		TRUE on success
 */
BOOL CTRIPLE::EnumVerbsCallback(ULONG iel, LPVOID pbDst)
{
	OLEVERB *	poleverb = (OLEVERB *) pbDst;
	CHAR		rgch[40];
	UsesMakeOLESTR;

	AssertSz(iel < 3, "Know only three verbs");
	LoadString(g_hInstResource, STR_TripoleVerb0 + (UINT) iel, rgch,
				sizeof(rgch) / sizeof(CHAR));
#if defined (WIN32) && !defined (MAC)
	poleverb->lpszVerbName = OleStdMalloc(40 * sizeof(OLECHAR));
	if (!poleverb->lpszVerbName)
		return FALSE;
	lstrcpyW(poleverb->lpszVerbName, MakeOLESTR(rgch));
	return TRUE;
#else
	return (poleverb->lpszVerbName = OleStdCopyString(rgch, NULL))
														? TRUE : FALSE;
#endif
}
#endif

/*
 *	EnumVerbs
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::EnumVerbs(IEnumOLEVERB ** ppenumOleVerb)
{
#ifdef LATER
	static OLEVERB	oleverb[]	= {
						{0, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU},
						{1, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU},
						{2, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU}};

	//TraceTag(tagTripole, "TRIPOBJECT_EnumVerbs");

	*ppenumOleVerb = (LPENUMOLEVERB) ENUMUNK_New(
						(LPIID) &IID_IEnumOLEVERB,
						3, sizeof(OLEVERB), &oleverb,
						EnumVerbsCallback);
	if (!*ppenumOleVerb)
		return E_OUTOFMEMORY;

	return S_OK;
#else
    RRETURN(OLEOBJ_E_NOVERBS);
#endif
}


/*
 *	Update
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Update()
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_Update: NYI");
	return E_NOTIMPL;
}


/*
 *	IsUpToDate
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::IsUpToDate()
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_IsUpToDate: NYI");
	return E_NOTIMPL;
}


/*
 *	GetUserClassID
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetUserClassID(CLSID * pclsid)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetUserClassID");

	*pclsid = CLSID_CTriple;

	return S_OK;
}


/*
 *	GetUserType
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetUserType(DWORD dwFormOfType, LPOLESTR * lpszUserType)
{
	UINT	ids;
	INT		cch;
#if defined(WIN32) && !defined(MAC)
	TCHAR	szT[40];
#endif

	if (dwFormOfType == USERCLASSTYPE_APPNAME)
	{
		ids = IDS_ErrorCaptionMail;
		cch = 40;
	}
	else
	{
		ids = IDS_TripoleFullName;
		cch = 20;
	}

	*lpszUserType = (TCHAR *) OleStdMalloc(cch * sizeof(OLECHAR));
	if (*lpszUserType == NULL)
		return E_OUTOFMEMORY;

#if defined(WIN32) && !defined(MAC)
	LoadString(g_hInstResource, ids, szT, cch);
	lstrcpyW(*lpszUserType, szT);
#else	// !WIN32
	LoadString(g_hInstResource, ids, (char*)*lpszUserType, cch);
#endif	// !WIN32

	//TraceTag(tagTripole, "TRIPOBJECT_GetUserType");

	return S_OK;
}


/*
 *	SetExtent
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	//TraceTag(tagTripole, "TRIPOBJECT_SetExtent");

	// The object's size is fixed

	return E_FAIL;
}


/*
 *	GetExtent
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	HFONT			hfontOld;
	HDC				hdc;
	TEXTMETRIC		tm;
	LPSTR			szName;
	SIZE			size;
	SIZEL			sizel;

	//TraceTag(tagTripole, "TRIPOBJECT_GetExtent");

	hdc = GetWindowDC(NULL);
	Assert(hdc);

    hfontOld = SelectFont(hdc, GetStockObject(DEFAULT_GUI_FONT));

	if (_iName == LONG_MAX)
		szName = "";
	else
		szName = _rw.lpProps[_iName].Value.lpszA;

	GetTextExtentPointA(hdc, szName, lstrlenA(szName), &size);

	GetTextMetrics(hdc, &tm);

	sizel.cx = size.cx + 1;					// One pixel seems to be clipped
	sizel.cy = size.cy - tm.tmDescent;		// Same height as normal line (RAID 11516 was +1)



    lpsizel->cx = sizel.cx * 2540 / GetDeviceCaps(hdc, LOGPIXELSX);
    lpsizel->cy = sizel.cy * 2540 / GetDeviceCaps(hdc, LOGPIXELSY);

	SelectFont(hdc, hfontOld);
	ReleaseDC(NULL, hdc);
	return S_OK;
}


/*
 *	Advise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Advise(IAdviseSink * pAdvSink, DWORD * pdwConnection)
{
    if (_poleadviseholder)
		return _poleadviseholder->Advise(pAdvSink, pdwConnection);

	return OLE_E_ADVISENOTSUPPORTED;
}


/*
 *	Unadvise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Unadvise(DWORD dwConnection)
{
	if (_poleadviseholder)
		return _poleadviseholder->Unadvise(dwConnection);

	return E_FAIL;
}


/*
 *	EnumAdvise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::EnumAdvise(LPENUMSTATDATA * ppenumAdvise)
{
	if (_poleadviseholder)
		return _poleadviseholder->EnumAdvise(ppenumAdvise);

	return OLE_E_ADVISENOTSUPPORTED;
}


/*
 *	GetMiscStatus
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetMiscStatus");

	*pdwStatus = 0;

	return S_OK;
}


/*
 *	SetColorScheme
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetColorScheme(LPLOGPALETTE lpLogpal)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_SetColorScheme: NYI");
	return E_NOTIMPL;
}


/*
 *	Draw
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Draw(DWORD dwDrawAspect,
                    LONG lindex,
                    void *pvAspect,
                    DVTARGETDEVICE *ptd,
                    HDC hdcTargetDev,
                    HDC hdcDraw,
                    LPCRECTL lprcBounds,
                    LPCRECTL lprcWBounds,
                    BOOL (STDMETHODCALLTYPE *pfnContinue)(DWORD dwContinue),
                    DWORD dwContinue)
{
	LPSTR			szName;
	TEXTMETRIC		tm;

	if (_iName == LONG_MAX)
		szName = "";
	else
   		szName = _rw.lpProps[_iName].Value.lpszA;

	SetTextAlign(hdcDraw, TA_BOTTOM);
	TextOutA(hdcDraw, lprcBounds->left, lprcBounds->bottom, szName, lstrlenA(szName));

	GetTextMetrics(hdcDraw, &tm);

	// Only draw the underline if we're told to
	if (_fUnderline)
	{
		if (!hpenUnderline)
		{
			hpenUnderline = CreatePen(PS_SOLID, 0,
									GetSysColor(COLOR_WINDOWTEXT));
			if (!hpenUnderline)
				return E_OUTOFMEMORY;
		}

		SelectPen(hdcDraw, hpenUnderline);
#ifndef DBCS
		MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom - tm.tmDescent + 1, NULL);
		LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom - tm.tmDescent + 1);
#else
		MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom-1 , NULL);
		LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom-1 );
#endif
	}

	return S_OK;
}


/*
 *	GetColorSet
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	xxc
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetColorSet(DWORD dwDrawAspect, LONG lindex, void FAR* pvAspect,
				DVTARGETDEVICE FAR * ptd, HDC hicTargetDev,
				LPLOGPALETTE FAR* ppColorSet)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_GetColorSet: NYI");
	return E_NOTIMPL;
}


/*
 *	Freeze
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Freeze(DWORD dwDrawAspect,
				LONG lindex, void FAR* pvAspect, DWORD FAR* pdwFreeze)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_Freeze: NYI");
	return E_NOTIMPL;
}


/*
 *	Unfreeze
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Unfreeze(DWORD dwFreeze)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_Unfreeze: NYI");
	return E_NOTIMPL;
}


/*
 *	SetAdvise
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
	
	//TraceTag(tagTripole, "TRIPVIEW_SetAdvise");

	ReleaseInterface(_padvisesink);
	if (pAdvSink)
		pAdvSink->AddRef();
	_padvisesink = pAdvSink;

	return S_OK;
}


/*
 *	GetAdvise
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetAdvise(DWORD FAR* pAspects, DWORD FAR* pAdvf,
				LPADVISESINK FAR* ppAdvSink)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_GetAdvise: NYI");
	AssertSz(FALSE, "I'm easy to implement if I'm called");
	return E_NOTIMPL;
}


/*
 *	Constructor
 *	
 *	Purpose:
 *		Creates a new CTRIPDATA object.
 *	
 *	Parameters:
 *		prws		pointer to row set containing one or more objects
 *	
 *	Returns:
 *		TRIPDATA *	The newly created TRIPDATA.
 */
CTripData::CTripData(LPSRowSet prws)
{
	//TraceTag(tagTripole, "TRIPDATA_New");

	_cRef = 1;				// Start with one reference
	_prws = prws;

    if (s_rgformatetcTRIPOLE[iFormatText].cfFormat == 0)
    {
	    // Register our clipboard formats
	    s_rgformatetcTRIPOLE[iFormatText].cfFormat = CF_TEXT;
	    s_rgformatetcTRIPOLE[iFormatTriple].cfFormat =
					    RegisterClipboardFormat(s_szClipFormatTriple);
    }
}


/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Parameters:
 *		REFIID		 Interface we want.
 *		LPUNKNOWN *	 Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTripData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	//TraceTag(tagTripole, "TRIPDATA_QueryInterface");

	if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
	{
		*ppvObj = (IDataObject*)this;
        AddRef();
	}
	else
	{
		//TraceTag(tagTripole, "Don't know interface %lx", riid->Data1);
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

/*
 *  AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripData::AddRef()
{
	//TraceTag(tagTripole, "TRIPDATA_AddRef");

	return ++_cRef;
}


/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripData::Release()
{
	ULONG		cRef		= --_cRef;

	//TraceTag(tagTripole, "TRIPDATA_Release");

	if (!cRef)
	{
		//TraceTag(tagTripole, "TRIPDATA_Release: freeing the tripdata");
    	FreeSRowSet(_prws);
		delete this;
	}

	AssertSz(cRef >= 0, "TRIPDATA_Release: negative cRef");
	return cRef;
}


HRESULT CTripData::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	//TraceTag(tagTripole, "TRIPDATA_GetData");
//$BUG
//	Naughty, naughty, naughty.  You weren't following the OLE2 spec.
//
//	The call to GetDataHereOrThere assumes that pmedium is
//	pre-initialized.  This is fine and dandy for a IDataObject::GetDataHere
//	call, but the OLE2 spec says that the pmedium isn't initialized
//	for IDataObject::GetData.  This fix should probably be taken in
//	for all clients, not just the Mac.
#ifdef MAC
	pmedium->tymed = TYMED_NULL;
	pmedium->pUnkForRelease = NULL;
#endif	// MAC
	return this->GetDataHereOrThere(pformatetcIn, pmedium);
}

HRESULT CTripData::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
	//TraceTag(tagTripole, "TRIPDATA_GetDataHere");

	return this->GetDataHereOrThere(pformatetc, pmedium);
}

/*
 *	GetDataHereOrThere
 *	
 *	Purpose:
 *		Both TRIPDATA_GetData() and TRIPDATA_GetDataHere() do
 *		basically the same thing, so I have them each call this
 *		function.
 *	
 *	Parameters:
 *		pdataobject		an IDataObject
 *		pformatetcIn	the format to get the data
 *		pmedium			where and how to give the data
 *	
 *	Returns:
 *		hr
 */
HRESULT CTripData::GetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	HRESULT			hr			= S_OK;
	UINT			cbName;
	ULONG			i;
	LPSPropValue	pval;
	LPSTR			pDst;

//	TraceTag(tagTripole, "GetDataHereOrThere");

	if (pformatetcIn->cfFormat == s_rgformatetcTRIPOLE[iFormatTriple].cfFormat)
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->pUnkForRelease = NULL;
		return (StuffRwsInHglobal(_prws, pmedium));
	}
	else if (pformatetcIn->cfFormat != s_rgformatetcTRIPOLE[iFormatText].cfFormat)
	{
#ifdef DEBUG
		TCHAR	szT[50];

		if (!GetClipboardFormatName(pformatetcIn->cfFormat, szT, sizeof(szT)))
			wsprintf(szT, L"%d", pformatetcIn->cfFormat);
		//TraceTag(tagTripole, "Don't know Clipboard Format %s", szT);
#endif
		return DATA_E_FORMATETC;
	}

	for (i = 0, cbName = 0; i < _prws->cRows; ++i)
	{
		pval = PvalFind(&_prws->aRow[i], PR_DISPLAY_NAME_A);
		Assert(pval);
		cbName += (lstrlenA(pval->Value.lpszA) + 2) * sizeof(TCHAR);
	}

	if (pmedium->tymed == TYMED_NULL ||
			(pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal == NULL))
	{
		// This is easy, we can quit right after copying stuff
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cbName);
		pmedium->pUnkForRelease = NULL;
	}
	else if (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal != NULL)
	{
		// Caller wants us to fill his hGlobal
		// Realloc the destination to make sure there is enough room
        void *pTemp;
        pTemp = GlobalReAlloc(pmedium->hGlobal, cbName, 0);
        if (pTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
		pmedium->hGlobal = pTemp;
	}
	else
		goto Cleanup;

	if (!pmedium->hGlobal)
	{
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	pDst = (LPSTR)GlobalLock(pmedium->hGlobal);
	for (i = 0; i < _prws->cRows; ++i)
	{
		if (i > 0)
		{
			*((LPSTR) pDst) = ';';
			pDst ++;
			*((LPSTR) pDst) = ' ';
			pDst ++;
		}

		pval = PvalFind(&_prws->aRow[i], PR_DISPLAY_NAME_A);
		Assert(pval);
		cbName = (lstrlenA(pval->Value. lpszA) + 1);;
		CopyMemory(pDst, pval->Value.lpszA, cbName);
		pDst += cbName - 1;
	}
	GlobalUnlock(pmedium->hGlobal);

Cleanup:
	RRETURN(hr);
}


HRESULT CTripData::QueryGetData(LPFORMATETC pformatetc)
{
	LONG		iformatetc;
	LPFORMATETC	pformatetcT	= s_rgformatetcTRIPOLE;
	CLIPFORMAT	cfFormat	= pformatetc->cfFormat;
	DWORD		tymed		= pformatetc->tymed;

	//TraceTag(tagTripole, "TRIPDATA_QueryGetData");

	for (iformatetc = 0; iformatetc < cformatetcTRIPOLE;
								++iformatetc, ++pformatetcT)
	{
		// Stop searching if we have compatible formats and mediums
		if (pformatetcT->cfFormat == cfFormat &&
					(pformatetcT->tymed & tymed))
			return S_OK;
	}

	return S_FALSE;
}

HRESULT CTripData::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
	//TraceTag(tagTripole, "TRIPDATA_GetCanonicalFormatEtc");

	return DATA_S_SAMEFORMATETC;
}

HRESULT CTripData::SetData(LPFORMATETC pformatetc, LPSTGMEDIUM  pmedium, BOOL fRelease)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_SetData: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    RRETURN(THR(CreateFORMATETCEnum(s_rgformatetcTRIPOLE, cformatetcTRIPOLE, ppenumFormatEtc)));
}

HRESULT CTripData::DAdvise(LPFORMATETC pFormatetc, DWORD advf,
					LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_Advise: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::DUnadvise(DWORD dwConnection)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_Unadvise: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_EnumAdvise: NYI");

	return E_NOTIMPL;
}


/*
 *	T R I P C A L L   I m p l e m e n t a t i o n
 */


/*
 *	Constructor CTripCall
 *	
 *	Parameters:
 *		pPad			    pointer to CPadMessage this belongs to
 *		hwndEdit			hwnd of this edit control
 *		fUnderline			do we want to underline the triples
 *	
 *	Returns:
 *		TRIPCALL *	The newly created TRIPCALL.
 */
CTripCall::CTripCall(   CPadMessage * pPad,
                        HWND hwndEdit,
                        BOOL fUnderline)
{

	_cRef = 1;					// Start with one reference
	_pPad = pPad;				// Don't need to refcount
	_hwndEdit = hwndEdit;
	_fUnderline = fUnderline;
}


/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Arguments:
 *		REFIID			Interface we want.
 *		LPUNKNOWN *		Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTripCall::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
					IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		*ppvObj = (IRichEditOleCallback*)this;
        AddRef();
		return S_OK;
	}
    else
    {
	    *ppvObj = NULL;
	    return E_NOINTERFACE;
    }
}


/*
 *	AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripCall::AddRef()
{
	return ++_cRef;
}


/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripCall::Release()
{
	ULONG cRef = --_cRef;

	if (!cRef)
	{

		// Free memory allocated for us
		delete this;
		//TraceTag(tagTripole, "TRIPCALL_Release: freeing the tripcall");
	}

	AssertSz(cRef >= 0, "TRIPCALL_Release: negative cRef");
	return cRef;
}


/*
 *	GetNewStorage
 *
 *	Purpose:
 *		Gets storage for a new object.
 *
 *	Arguments:
 *		LPSTORAGE FAR *		Where to return storage.
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTripCall::GetNewStorage(LPSTORAGE FAR * ppstg)
{
	*ppstg = StgCreateOnHglobal();
	if (!*ppstg)
		return E_OUTOFMEMORY;
	return S_OK;
}


/*
 *	GetInPlaceContext
 *
 *	Purpose:
 *		Gets context information for an in place object.
 *
 *	Arguments:
 *		LPOLEINPLACEFRAME *		Frame window object.
 *		LPOLEINPLACEUIWINDOW *	Document window object.
 *		LPOLEINPLACEFRAMEINFO	Frame window information.
 *
 *	Returns:
 *		HRESULT					Error status.
 */
HRESULT CTripCall::GetInPlaceContext(LPOLEINPLACEFRAME FAR * ppipframe,
    							   LPOLEINPLACEUIWINDOW FAR* ppipuiDoc,
	    						   LPOLEINPLACEFRAMEINFO pipfinfo)
{
	return E_NOTIMPL;
}


/*
 *	ShowContainerUI
 *
 *	Purpose:
 *		Displays or hides REITP's container UI.
 *
 *	Arguments:
 *		BOOL			
 *
 *	Returns:
 *		HRESULT			Error status.
 */
HRESULT CTripCall::ShowContainerUI(BOOL fShow)
{
	return E_NOTIMPL;
}


HRESULT CTripCall::QueryInsertObject(LPCLSID pclsid, LPSTORAGE pstg, LONG cp)
{
	if (IsEqualIID(*pclsid, CLSID_CTriple))
		return S_OK;
	else
		return E_FAIL;
}


HRESULT CTripCall::DeleteObject(LPOLEOBJECT poleobj)
{
	return S_OK;
}


HRESULT CTripCall::QueryAcceptData(LPDATAOBJECT pdataobj, CLIPFORMAT *pcfFormat,
                                    DWORD reco, BOOL fReally,
		                            HGLOBAL hMetaPict)
{
	HRESULT			hr;
	ULONG			cRows;
	ULONG			iRow;
	ULONG			cb;
	LPBYTE			pb;
	SRow			rw;
	STGMEDIUM		stgmedium;

	//TraceTag(tagTripole, "TRIPCALL_QueryAcceptData");

	if (!*pcfFormat)
	{
		// default to text
		*pcfFormat = CF_TEXT;

		if (pdataobj->QueryGetData(&CTripData::s_rgformatetcTRIPOLE[iFormatTriple]) == S_OK)
		{
			// Goody, goody, this data object support CF_TRIPLE
			*pcfFormat = CTripData::s_rgformatetcTRIPOLE[iFormatTriple].cfFormat;
		}
	}
	else
	{
		if (*pcfFormat != CTripData::s_rgformatetcTRIPOLE[iFormatTriple].cfFormat
				 && *pcfFormat != CTripData::s_rgformatetcTRIPOLE[iFormatText].cfFormat)
			return DATA_E_FORMATETC;
	}

	if (*pcfFormat == CF_TEXT)
	{
		// let the richedit take care of text
		return S_OK;
	}

	// If I'm read-only, return Success and Richedit won't do anything
	if (GetWindowLong(_hwndEdit, GWL_STYLE) & ES_READONLY)
		return S_OK;

	if (!fReally)
	{
		// return that we'll import it ourselves
 		return S_FALSE;
	}

	hr = pdataobj->GetData(&CTripData::s_rgformatetcTRIPOLE[iFormatTriple], &stgmedium);
	if (hr != S_OK)
		RRETURN(hr);

    // STGFIX: t-gpease 8-13-97
    Assert(stgmedium.tymed == TYMED_HGLOBAL);

	pb = (BYTE*)GlobalLock(stgmedium.hGlobal);
	cRows = *((ULONG *) pb);
	pb += sizeof(ULONG);

	for (iRow = 0; iRow < cRows; ++iRow)
	{
		cb = *((ULONG *) pb);
		pb += sizeof(ULONG);

		hr = THR(MAPIAllocateBuffer(cb, (void**)&rw.lpProps));
		if (hr)
			goto Cleanup;

		CopyBufferToRow(pb, &rw);
		pb += cb;

		if (iRow > 0)
			Edit_ReplaceSel(_hwndEdit, TEXT("; "));

		//$ REVIEW - if we fail, do I want to do anything?

		_pPad->AddRecipientToWell(_hwndEdit, (LPADRENTRY) &rw, FALSE, FALSE);

		MAPIFreeBuffer(rw.lpProps);
	}

	hr = S_FALSE;

Cleanup:
	GlobalUnlock(stgmedium.hGlobal);
	GlobalFree(stgmedium.hGlobal);
	return hr;
}


HRESULT CTripCall::ContextSensitiveHelp(BOOL fEnterMode)
{
	return S_OK;
}


HRESULT CTripCall::GetClipboardData(CHARRANGE * pchrg,
					DWORD reco, LPDATAOBJECT * ppdataobj)
{
	HRESULT     hr;
	LPADRLIST	pal = NULL;
	CTripData *	ptripdata;

	//$ REVIEW - possible optimization - return E_NOTIMPL if no objects
	//				in selection

	// Exchange 18403: Need to prevent cut on read only
	if (reco == RECO_CUT &&
		(GetWindowStyle(_hwndEdit) & ES_READONLY))
		return E_NOTIMPL;

	hr = THR(_pPad->BuildSelectionAdrlist(&pal, _hwndEdit, pchrg));
	if (hr)
		goto Error;

	// this will gobble up the pal so I don't want to free it
	ptripdata = new CTripData((LPSRowSet) pal);
	if (!ptripdata)
		goto Error;

	// steal the refcount of the ptripdata
	*ppdataobj = (LPDATAOBJECT) ptripdata;

	return S_OK;

Error:
	FreeAdrlist(pal);
	RRETURN(E_FAIL);
}


HRESULT CTripCall::GetDragDropEffect(BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
	if (fDrag)			// use the default
		return S_OK;

	if (GetWindowLong(_hwndEdit, GWL_STYLE) & ES_READONLY)
	{
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		if ((grfKeyState & MK_CONTROL) || !(*pdwEffect & DROPEFFECT_MOVE))
			*pdwEffect = DROPEFFECT_COPY;
		else
			*pdwEffect = DROPEFFECT_MOVE;
	}

	return S_OK;
}


HRESULT CTripCall::GetContextMenu(WORD seltype,	LPOLEOBJECT poleobj, CHARRANGE * pchrg,
                                    HMENU * phmenu)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgvwsnk.cxx ===
/* copyright (c) 1995 Microsoft Corporation -- All rights reserved */

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#pragma warning(disable:4514) // Unreferened inline function has been removed

CViewNotifier::CViewNotifier (void)
{
    Initialize();
}

CViewNotifier::~CViewNotifier ()
{
}

BOOL CViewNotifier::Initialize (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        m_aryAdviseSink [i] = NULL;
    }

    return TRUE;
}

HRESULT CViewNotifier::Advise(LPMAPIVIEWADVISESINK pAdvise,
                              ULONG * pulConnection)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL == m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] = pAdvise;
            m_aryAdviseSink [i] ->AddRef();
            *pulConnection = ++i;
            // connection == index + 1
            return S_OK;
        }
    }

    return ResultFromScode(E_OUTOFMEMORY);
}

HRESULT CViewNotifier::Unadvise (ULONG ulConnection)
{
    if (--ulConnection < MAXSINKS)
    {   // connection == index + 1
        m_aryAdviseSink [ulConnection] ->Release();
        m_aryAdviseSink [ulConnection] = NULL;
        return S_OK;
    }
    return ResultFromScode(E_INVALIDARG);
}

void CViewNotifier::OnShutdown (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] -> OnShutdown ();
        }
    }
}

void CViewNotifier::OnNewMessage (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] ->OnNewMessage();
        }
    }
}

HRESULT CViewNotifier::OnPrint(ULONG ulPageNumber, HRESULT hrStatus)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            if(MAPI_E_USER_CANCEL == GetScode(m_aryAdviseSink [i] ->OnPrint(ulPageNumber, hrStatus)))
                return MAPI_E_USER_CANCEL;
        }
    }
    
    return hrSuccess;
}

void CViewNotifier::OnSubmitted (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i) {
        if (NULL != m_aryAdviseSink [i] ) {
            m_aryAdviseSink [i] ->OnSubmitted();
        }
    }
}

void CViewNotifier::OnSaved (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i) {
        if (NULL != m_aryAdviseSink [i] ) {
            m_aryAdviseSink [i] ->OnSaved();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgutil.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddoc.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

/*
 *	PvalFind
 *	
 *	Purpose:
 *		Given the row prw, finds the first property whose tag is
 *		ulPropTag.
 *	
 *	Arguments:
 *		prw			The row to seek.
 *		ulPropTag	The property tag we're seeking.
 *	
 *	Returns:
 *		A pointer to the SPropValue with the desired property tag, or
 *		NULL if no such SPropValue was found.
 */
LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag)
{
	UINT			ival;
	LPSPropValue	pval;

	ival = (UINT) prw->cValues;
	pval = prw->lpProps;
	if (PROP_TYPE(ulPropTag) != PT_NULL)
	{
		while (ival--)
		{
			if (pval->ulPropTag == ulPropTag)
				return pval;
			++pval;
		}
	}
	else	// Ignore property type (error)
	{
		ULONG ulPropId = PROP_ID(ulPropTag);

		while (ival--)
		{
			if (PROP_ID(pval->ulPropTag) == ulPropId)
				return pval;
			++pval;
		}
	}
	return NULL;
}


/*
 *	FreeSRowSet
 *
 *	Purpose:
 *		Frees an SRowSet structure and the rows therein
 *
 *	Parameters:
 *		LPSRowSet		The row set to free
 */

VOID FreeSRowSet(LPSRowSet prws)
{
	ULONG irw;

	if (!prws)
		return;

	// Free each row
	for (irw = 0; irw < prws->cRows; irw++)
		MAPIFreeBuffer(prws->aRow[irw].lpProps);

	// Free the top level structure
	MAPIFreeBuffer(prws);
}


/*
 *	CopyRow
 *	
 *	Purpose:
 *		This function copies the properties of one row to another. If <pv> is
 *		NULL then MAPIAllocateBuffer is used to allocate the storage for
 *		<prwDst>. If <pv> is non NULL it is assumed to be a pointer to a
 *		MAPIAllocateBuffer(d) chunk of memory so MAPIAllocateMore is used to
 *		allocate the storage for <prwDst>.
 *	
 *	Parameters:
 *		pv			in		chunk of memory
 *		prwSrc		in		source row
 *		prwDst		out		destination row
 *	
 *	Returns:
 *		sc
 */
HRESULT CopyRow(LPVOID pv, LPSRow prwSrc, LPSRow prwDst)
{
	HRESULT	        hr = S_OK;
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	BYTE *			pb;
	ULONG			cb;

	if (prwSrc->cValues == 0)
	{
		// Handle the empty row case (Raid 3300)

		prwDst->cValues = 0;
		prwDst->lpProps = NULL;
		return S_OK;
	}

	// Compute the size needed to store the row in its entirety.

	pvalSrc = prwSrc->lpProps;
	for (iCol = prwSrc->cValues, cb = 0L; iCol > 0; ++pvalSrc, --iCol)
	{
		cb += PAD4(CbForPropValue(pvalSrc)) + sizeof (SPropValue);
	}

	// Allocate enough room for the new copy of the SPropValue.

	if (pv)
		hr = THR(MAPIAllocateMore(cb, pv, (void**)&prwDst->lpProps));
	else
		hr = THR(MAPIAllocateBuffer(cb, (void**)&prwDst->lpProps));

	if (hr)
		goto Cleanup;

	// Do the finicky copy of the items one-by-one.

	pvalDst = prwDst->lpProps;
	pvalSrc = prwSrc->lpProps;
	iCol = prwDst->cValues = prwSrc->cValues;
	pb = (BYTE *) (pvalDst + iCol);		// point past the rgSPropValue.

	while (iCol--)
	{
		pb = CopyPval(pvalSrc, pvalDst, pb, NULL, imodeCopy);
		++pvalSrc;
		++pvalDst;
	}
	
Cleanup:
    RRETURN(hr);
}


/*
 *	CbForPropValue
 *	
 *	Purpose:
 *		Determines how many bytes are needed for storage of the
 *		property pv, in addition to the space taken up by the SPropValue
 *		itself.
 *	Arguments:
 *		pv		The SPropValue of the property.
 *	Returns:
 *		A count of the bytes needed to store this thing
 */
ULONG CbForPropValue(LPSPropValue pval)
{
	ULONG	cb;
	
	switch (PROP_TYPE(pval->ulPropTag))
	{
		// Types whose values fit in the 64-bit Value of the property.
	  case PT_I2:
	  case PT_I8:
	  case PT_LONG:
	  case PT_R4:
	  case PT_DOUBLE:
	  case PT_CURRENCY:
	  case PT_ERROR:
	  case PT_BOOLEAN:
	  case PT_SYSTIME:
	  case PT_APPTIME:
	  case PT_NULL:
		return 0;
	  case PT_BINARY:
		cb = pval->Value.bin.cb;
		break;
	  case PT_STRING8:
		cb = (lstrlenA(pval->Value.lpszA) + 1) * sizeof (CHAR);
		break;
	  case PT_UNICODE:
		cb = (lstrlenW(pval->Value.lpszW) + 1) * sizeof (WCHAR);
		break;
	  case PT_CLSID:
		cb = sizeof (GUID);
		break;

		// Multi-valued properties.
	  case PT_MV_I2:
		cb = pval->Value.MVi.cValues * sizeof (short int);
		break;
	  case PT_MV_LONG:
		cb = pval->Value.MVl.cValues * sizeof (LONG);
		break;
	  case PT_MV_R4:
		cb = pval->Value.MVflt.cValues * sizeof (float);
		break;
	  case PT_MV_DOUBLE:
	  case PT_MV_APPTIME:
		cb = pval->Value.MVdbl.cValues * sizeof (double);
		break;
	  case PT_MV_CURRENCY:
		cb = pval->Value.MVcur.cValues * sizeof (CURRENCY);
		break;
	  case PT_MV_SYSTIME:
		cb = pval->Value.MVat.cValues * sizeof (FILETIME);
		break;
//$	case PT_MV_I8:
//		cb = pval->Value.MVli.cValues * sizeof (LARGE_INTEGER);
		break;
	  case PT_MV_BINARY:
		{
		//	Multi-valued binaries are copied in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, pb1 ... cbn, pbn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and pbn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus pb1 points
		//	to the b1,0, etc.

			SBinaryArray *	pbina = &pval->Value.MVbin;
			ULONG			uliValue;
			SBinary *		pbinSrc;

			cb = pbina->cValues * sizeof (SBinary);

			for (uliValue = 0, pbinSrc = pbina->lpbin;
					uliValue < pbina->cValues;
					uliValue++, pbinSrc++)
			{
				cb += pbinSrc->cb;
			}
			break;
		}
	  case PT_MV_STRING8:
		{
		//	Multi-valued STRING8 properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszA1, pszA2 ... | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where pszAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each pszAn points
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.

			SLPSTRArray *	pSLPSTRArray = &pval->Value.MVszA;
			ULONG			uliValue;
			LPSTR *			pszASrc;

			//	Figure out the size of the buffer we need

			cb = pSLPSTRArray->cValues * sizeof (LPSTR);

			for (uliValue = 0, pszASrc = pSLPSTRArray->lppszA;
					uliValue < pSLPSTRArray->cValues;
					uliValue++, pszASrc++)
			{
				cb += (lstrlenA(*pszASrc) + 1) * sizeof (CHAR);
			}
			break;
		}

	  case PT_MV_UNICODE:
		{
		//	Multi-valued UNICODE properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszW1, pszW2 ... | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPWSTR array   |     String data    |
		//
		//	Where pszWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each pszWn points
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.

			SWStringArray *	pSWStringArray = &pval->Value.MVszW;
			ULONG			uliValue;
			LPWSTR *		pszWSrc;

			//	Figure out the size of the buffer we need

			cb = pSWStringArray->cValues * sizeof (LPWSTR);

			for (uliValue = 0, pszWSrc = pSWStringArray->lppszW;
					uliValue < pSWStringArray->cValues;
					uliValue++, pszWSrc++)
			{
				cb += (lstrlenW(*pszWSrc) + 1) * sizeof (WCHAR);
			}
			break;
		}
	  case PT_UNSPECIFIED:
	  case PT_OBJECT:
	  default:
		cb = 0;
		break;
	}
	return cb;
}


/*
 *	CopyPropValue
 *	
 *	Purpose:
 *		Copies the property from pvSrc to pvDst. This is done by copying
 *		the LPSPropValue at pvSrc to pvDst, and copying any external data
 *		to pbIn.
 *	Arguments:
 *		pvSrc		Source property
 *		pvDst		Destination property
 *		pb			Pointer to buffer area for strings, binaries, &c.
 *		ppbDest		(for imodeUnflatten) pb for destination row
 *		imode		One of:
 *						imodeCopy		- straight row copy
 *						imodeFlatten	- flatten out row to buffer
 *						imodeUnflatten	- unflatten buffer to row
 *	
 *	Returns:
 *		The updated PB, which should be on an aligned boundary.
 */
LPBYTE CopyPval(LPSPropValue pvalSrc, LPSPropValue pvalDst,
			   LPBYTE pb, LPBYTE * ppbDest, UINT imode)
{
	ULONG			cb;
	LPBYTE			pbSrc;
	LPBYTE FAR *	ppbDst;

	*pvalDst = *pvalSrc;
	switch (PROP_TYPE(pvalDst->ulPropTag))
	{
		//	Types whose values fit in the 64-bit Value of the property
	  case PT_I2:
	  case PT_I8:
	  case PT_LONG:
	  case PT_R4:
	  case PT_DOUBLE:
	  case PT_CURRENCY:
	  case PT_ERROR:
	  case PT_BOOLEAN:
	  case PT_SYSTIME:
	  case PT_APPTIME:
	  case PT_NULL:
		return pb;
	}
	
	switch (PROP_TYPE(pvalDst->ulPropTag))
	{
	  case PT_BINARY:
		pbSrc	= pvalSrc->Value.bin.lpb;
		ppbDst	= &pvalDst->Value.bin.lpb;
		break;

	  case PT_STRING8:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpszA;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpszA;
		break;

	  case PT_UNICODE:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpszW;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpszW;
		break;

	  case PT_CLSID:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpguid;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpguid;
		break;

	  case PT_MV_I2:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVi.lpi;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVi.lpi;
		break;

	  case PT_MV_LONG:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVl.lpl;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVl.lpl;
		break;

	  case PT_MV_R4:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVflt.lpflt;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVflt.lpflt;
		break;

	  case PT_MV_DOUBLE:
	  case PT_MV_APPTIME:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVdbl.lpdbl;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVdbl.lpdbl;
		break;

	  case PT_MV_CURRENCY:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVcur.lpcur;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVcur.lpcur;
		break;

	  case PT_MV_SYSTIME:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVat.lpat;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVat.lpat;
		break;

//$	  case PT_MV_I8:
// 		pbSrc	= (LPBYTE) pvalSrc->Value.MVli.lpli;
// 		ppbDst	= (LPBYTE *) &pvalDst->Value.MVli.lpli;
// 		break;

	  case PT_MV_BINARY:
		{
		//	Multi-valued binaries are copied in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, pb1 ... cbn, pbn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and pbn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus pb1 points
		//	to the b1,0, etc.

		//	Multi-valued binaries are flattened in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, ib1 ... cbn, ibn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and ibn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus ib1 contains
		//	the offset from the beginning of the allocated buffer
		//	to the b1,0, etc.
		//	The pvalDst->Value.MVbin.lpbin contains the size of the allocated
		//	buffer.

			SBinaryArray *	pbina = &pvalSrc->Value.MVbin;
			ULONG			iVal;
			SBinary *		pbinSrc;
			SBinary *		pbinDst;

			if (imode == imodeCopy)
			{
				//	And copy it all in

				pbinDst = (LPSBinary) pb;
				pvalDst->Value.MVbin.lpbin = pbinDst;
				pb = (LPBYTE) (pbinDst + pbina->cValues);

				for (iVal = 0, pbinSrc = pbina->lpbin;
						iVal < pbina->cValues;
						iVal++, pbinSrc++, pbinDst++ )
				{
					pbinDst->cb = pbinSrc->cb;
					pbinDst->lpb = pb;
					CopyMemory(pb, pbinSrc->lpb, (UINT) pbinSrc->cb);
					pb += pbinSrc->cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the data into the buffer and set offsets
				//	to them in the SBinary array at the beginning of the buffer

				pbinDst = (LPSBinary) pb;
				pb = (LPBYTE) (pbinDst + pbina->cValues);
				ib = pbina->cValues * sizeof(SBinary);

				//	Copy the data into the buffer and set offsets
				//	to them in the SBinary array at the beginning of the buffer

				for (iVal = 0, pbinSrc = pbina->lpbin;
						iVal < pbina->cValues;
						iVal++, pbinSrc++, pbinDst++ )
				{
					pbinDst->cb = pbinSrc->cb;
					pbinDst->lpb = (LPBYTE) ib;
					CopyMemory(pb, pbinSrc->lpb, (UINT) pbinSrc->cb);
					pb += pbinSrc->cb;
					ib += pbinSrc->cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVbin.lpbin = (LPSBinary) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG 		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pbina->lpbin;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to data back into pointers to
					//	strings

					pvalDst->Value.MVbin.lpbin = pbinDst = (LPSBinary) *ppbDest;
					ulBase = (ULONG) pbinDst;
					for (iVal = 0;
							iVal < pbina->cValues;
							iVal++, pbinDst++)
					{
						pbinDst->lpb = (LPBYTE) (ulBase + (ULONG) pbinDst->lpb);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_MV_STRING8:
		{
		//	Multi-valued STRING8 properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszA1, pszA2 ... | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where pszAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each pszAn points
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.

		//	Multi-valued STRING8 properties are flattened into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| ibA1, ibA2 ...   | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where ibAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each ibAn contains an offset
		//	the beginning of the allocated buffer
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.
		//	The pvalDst->Value.MVszA contains the size of the allocated
		//	buffer.

			SLPSTRArray *	pSLPSTRArray = &pvalSrc->Value.MVszA;
			ULONG			iVal;
			LPSTR *			pszSrc;
			LPSTR *			pszDst;

			if (imode == imodeCopy)
			{
				//	Allocate the buffer to hold the strings

				pszDst = (LPSTR *) pb;
				pvalDst->Value.MVszA.lppszA = pszDst;
				pb = (LPBYTE) (pszDst + pSLPSTRArray->cValues);

				//	Copy the strings into the buffer and set pointers
				//	to them in the LPSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSLPSTRArray->lppszA;
						iVal < pSLPSTRArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenA(*pszSrc) + 1) * sizeof (CHAR);

					*pszDst = (LPSTR) pb;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPSTR array at the beginning of the buffer

				pszDst = (LPSTR *) pb;
				pb = (LPBYTE) (pszDst + pSLPSTRArray->cValues);
				ib = pSLPSTRArray->cValues * sizeof(LPSTR *);

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSLPSTRArray->lppszA;
						iVal < pSLPSTRArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenA(*pszSrc) + 1) * sizeof (CHAR);

					*pszDst = (LPSTR) ib;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
					ib += cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVszA.lppszA = (LPSTR *) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG 		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pSLPSTRArray->lppszA;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to strings back into pointers to
					//	strings

					pvalDst->Value.MVszA.lppszA = pszDst = (LPSTR *) *ppbDest;
					ulBase = (ULONG) pszDst;
					for (iVal = 0;
							iVal < pSLPSTRArray->cValues;
							iVal++, pszDst++)
					{
						*pszDst = (LPSTR) (ulBase + (ULONG) *pszDst);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_MV_UNICODE:
		{
		//	Multi-valued UNICODE properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszW1, pszW2 ... | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPWSTR array   |     String data    |
		//
		//	Where pszWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each pszWn points
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.

		//	Multi-valued UNICODE properties are flattened into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| ibW1, ibW2 ...   | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where ibWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each ibWn contains an offset
		//	the beginning of the allocated buffer
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.
		//	The pvalDst->Value.MVszW contains the size of the allocated
		//	buffer.

			SWStringArray *	pSWStringArray = &pvalSrc->Value.MVszW;
			ULONG			iVal;
			LPWSTR *		pszSrc;
			LPWSTR *		pszDst;

			if (imode == imodeCopy)
			{
				//	Allocate the buffer to hold the strings

				pszDst = (LPWSTR *) pb;
				pvalDst->Value.MVszW.lppszW = pszDst;
				pb = (LPBYTE) (pszDst + pSWStringArray->cValues);

				//	Copy the strings into the buffer and set pointers
				//	to them in the LPWSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSWStringArray->lppszW;
						iVal < pSWStringArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenW(*pszSrc) + 1) * sizeof (WCHAR);

					*pszDst = (LPWSTR) pb;
					CopyMemory(pb, (LPBYTE) *pszSrc, cb);
					pb += cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPWSTR array at the beginning of the buffer

				pszDst = (LPWSTR *) pb;
				pb = (LPBYTE) (pszDst + pSWStringArray->cValues);
				ib = pSWStringArray->cValues * sizeof(LPWSTR *);

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPWSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSWStringArray->lppszW;
						iVal < pSWStringArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenW(*pszSrc) + 1) * sizeof (WCHAR);

					*pszDst = (LPWSTR) ib;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
					ib += cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVszW.lppszW = (LPWSTR *) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pSWStringArray->lppszW;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to strings back into pointers to
					//	strings

					pvalDst->Value.MVszW.lppszW = pszDst = (LPWSTR *) *ppbDest;
					ulBase = (ULONG) pszDst;
					for (iVal = 0;
							iVal < pSWStringArray->cValues;
							iVal++, pszDst++)
					{
						*pszDst = (LPWSTR) (ulBase + (ULONG) *pszDst);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_UNSPECIFIED:
	  case PT_OBJECT:
	  default:
		return pb;
	}

	if (imode == imodeUnflatten)
	{
		cb = pvalSrc->Value.bin.cb;
		*ppbDst = *ppbDest;
		CopyMemory(*ppbDest, pb, (size_t) cb);
		*ppbDest += cb;
	}
	else
	{
		cb = CbForPropValue(pvalSrc);
		if (imode == imodeFlatten)
		{
			pvalDst->Value.bin.cb = cb;
		}
		else
		{
			Assert(imode == imodeCopy);
			*ppbDst = pb;
		}

		CopyMemory(pb, pbSrc, (size_t) cb);
	}
	
	return pb + PAD4(cb);	// make sure next one will be dword-aligned
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padauto.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padauto.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifdef USE_PERFORMANCE_DATA_HELPER
#include <pdh.h>
#endif

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include "platform.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_UNICWRAP_HXX
#define X_UNICWRAP_HXX
#include "unicwrap.hxx"
#endif

#ifndef X_MSHTMSVR_H_
#define X_MSHTMSVR_H_
#include "mshtmsvr.h"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_DIMM_HXX_
#define X_DIMM_HXX_
#include "dimm.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_PRIVACY_H_
#define X_PRIVACY_H_
#include "privacy.h"
#endif

#undef ASSERT

PerfTag(tagPerfScript, "Perf", "PerfLog from pad script")

DeclareTag(tagScriptLog, "ScriptLog", "script log");

DeclareTag(tagSnapGrid, "Snap to Grid", "Snap to Grid");
DeclareTag(tagShowMoveMouseTo,"Pad","Show MoveMouseTo Output");

extern DYNLIB g_dynlibMSHTML;

extern "C" const GUID SID_SHTMLEditServices;

DYNLIB g_dynlibOLEACC = { NULL, NULL, "OLEACC.DLL" };

#define FILEBUFFERSIZE 2048

#ifndef UNIX
#define PRINTDRT_FILE _T("c:\\printdrt.ps")  // CONSIDER: use GetTempFileName instead.
#define PRINTDRT_FILEA "c:\\printdrt.ps"
#else
#define PRINTDRT_FILE _T("printdrt.ps")  // CONSIDER: use GetTempFileName instead.
#define PRINTDRT_FILEA "printdrt.ps"
#endif
#define WM_UPDATEDEFAULTPRINTER WM_USER+338

#define MSHTML_WINDOW_CLASSNAME     _T("Internet Explorer_Server")
#define MSGNAME_WM_HTML_GETOBJECT   _T("WM_HTML_GETOBJECT")

TCHAR achScriptPath[MAX_PATH] = { 0 };
TCHAR achScriptStartDir[MAX_PATH] = { 0 };
TCHAR achDRTPath[MAX_PATH] = { 0 };
HWND  hwndInternetExplorerServer = 0;

//
// Array of keyboard layouts used for the IME testss.
// The Global IMEs that ship with US systems prior to NT 5.0 can
// be activated using the layouts in the first column.  NT 5.0
// systems activate the IMEs using the layouts on the second
// column.
//
#define KEYBOARD_LAYOUT_JPN     0
#define KEYBOARD_LAYOUT_KOR     1
#define KEYBOARD_LAYOUT_CHT     2
#define KEYBOARD_LAYOUT_CHS     3

#define KEYBOARD_LAYOUT_MAX     4

char *astrKeyboardLayouts[KEYBOARD_LAYOUT_MAX][2] =
        {
            {   "00000411", "E0010411"  },          // Japanese (Global IMEs) / NT 5.0
            {   "00000412", "E0010412"  },          // Korean
            {   "00000404", "E0010404"  },          // Traditional Chinese
            {   "00000804", "E00E0804"  }           // Simplified Chinese
        };


#ifdef UNIX
void SanitizePath( TCHAR *pszPath )
{
    if ( pszPath ) {
        TCHAR *pch = pszPath;

        while (*pch) {
            if (( *pch == L'/') ||
                ( *pch == L'\\')) {
                *pch = _T(FILENAME_SEPARATOR);
            }

            pch++;
        }
    }
}
#endif

void PrimeDRTPath()
{
    if (!achDRTPath[0])
    {
        char achDRTPathA[MAX_PATH] = "";

        GetPrivateProfileStringA("PadDirs","DRTScript","",achDRTPathA,MAX_PATH, "mshtmdbg.ini");

        if (achDRTPathA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achDRTPathA, MAX_PATH, achDRTPath, MAX_PATH);
        }

    }

    if (!achDRTPath[0])
    {
        TCHAR  *pch;

        // Prime file name with drt file directory.

        // Start with the directory containing this file.

        _tcscpy(achDRTPath, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achScriptPath.

        for (int i = 0; i < 4; i++)
        {
            pch = _tcsrchr(achDRTPath, _T(FILENAME_SEPARATOR));
            if (pch)
                *pch = 0;
        }

        // Glue on the name of the directory containing the test cases.

        _tcscat(achDRTPath, _T(FILENAME_SEPARATOR_STR)
                               _T("src")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("f3")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("drt")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("0drt.js"));
    }
}

void PrimeScriptStartDir()
{
    // look in mshtmdbg.ini first
    if(!achScriptStartDir[0])
    {
        char achScriptPathA[MAX_PATH] = "";

        GetPrivateProfileStringA("PadDirs","ScriptDir","",achScriptPathA,MAX_PATH, "mshtmdbg.ini");

        if (achScriptPathA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achScriptPathA, MAX_PATH, achScriptStartDir, MAX_PATH);
        }
    }

    // cobble something up form where we were compiled
    if (!achScriptStartDir[0])
    {
        TCHAR  *pch;

        // Prime file name with drt file directory.

        // Start with the directory containing this file.

        _tcscpy(achScriptStartDir, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achScriptPath.

        for (int i = 0; i < 4; i++)
        {
            pch = _tcsrchr(achScriptStartDir, _T(FILENAME_SEPARATOR));
            if (pch)
                *pch = 0;
        }

        // Glue on the name of the directory containing the test cases.

        _tcscat(achScriptStartDir,  _T(FILENAME_SEPARATOR_STR)
                                    _T("src")
                                    _T(FILENAME_SEPARATOR_STR)
                                    _T("f3")
                                    _T(FILENAME_SEPARATOR_STR)
                                    _T("drt"));
    }
}

HRESULT
CPadDoc::ExecuteDRT()
{
    HRESULT hr = S_OK;

    PrimeDRTPath();

    hr = THR(ExecuteTopLevelScript(achDRTPath));

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
        hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        TCHAR achMsg[400];

        _tcscpy(achMsg, _T("Could not find the DRT script at "));
        _tcscat(achMsg, achDRTPath);
        _tcscat(achMsg, _T(".\nDo you wish to try and find the script yourself?"));

        if (MessageBox(_hwnd, achMsg, _T("Could not find DRT."), MB_YESNO) == IDYES)
        {
            hr = THR(PromptExecuteScript(TRUE));
        }
        else
        {
            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CPadDoc::PromptExecuteScript(BOOL fDRT)
{
    HRESULT         hr;
    OPENFILENAME    ofn;
    BOOL            f;
    TCHAR *         pchPath;
    TCHAR *         pchStartDir;

    if (fDRT)
    {
        // This should only be called from ExecuteDRT which
        // will already have called PrimeScriptPath.  We didn't
        // find the DRT start file so we open the dialog at
        // where we looked for it.
        Assert( *achDRTPath );
        pchPath = achDRTPath;
        pchStartDir = NULL;
    }
    else
    {
        if (!*achScriptStartDir)
        {
            PrimeScriptStartDir();
        }

        pchPath = achScriptPath;
        pchStartDir = *pchPath ? NULL : achScriptStartDir;
    }

    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = _hwnd;
    ofn.lpstrFilter = TEXT("All Scripts (*.js;*.vbs)\0*.js;*.vbs\0JavaScript (*.js)\0*.js\0VBScript (*.vbs)\0*.vbs\0All Files (*.*)\0*.*\0");
    ofn.lpstrFile = pchPath;
    ofn.lpstrDefExt = _T("js");
    ofn.lpstrInitialDir = pchStartDir;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    DbgMemoryTrackDisable(TRUE);
    f = GetOpenFileName(&ofn);
    DbgMemoryTrackDisable(FALSE);

    if (!f)
        return S_FALSE;

    hr = THR(ExecuteTopLevelScript(pchPath));

    RRETURN(hr);
}

HRESULT
CPadDoc::LoadTypeLibrary()
{
    HRESULT hr = S_OK;
    TCHAR achExe[MAX_PATH];

    if (!_pTypeLibPad)
    {
        GetModuleFileName(g_hInstCore, achExe, MAX_PATH);

        // ISSUE (carled) again the crt library shutdown causes oleaut32 to leak memory
        // which is allocated on the very first call to GetTypeLib. Remove this
        // block once the crt libraries are no longer linked in.

        DbgMemoryTrackDisable(TRUE);

        hr = THR(LoadTypeLib(achExe, &_pTypeLibPad));

        DbgMemoryTrackDisable(FALSE);

        if (hr)
            goto Cleanup;

        hr = THR(RegisterTypeLib(_pTypeLibPad, achExe, NULL));
        if (hr)
            goto Cleanup;
    }

    if (!_apTypeComp[0])
    {
        hr = THR(_pTypeLibPad->GetTypeComp(&_apTypeComp[0]));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoCPad)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(CLSID_Pad, &_pTypeInfoCPad));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoIPad)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_IPad, &_pTypeInfoIPad));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoILine)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_ILine, &_pTypeInfoILine));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoICascaded)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_ICascaded, &_pTypeInfoICascaded));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeLibDLL)
    {
        // If specified, load MSHTML from the system[32] directory
        // instead of the from the exe directory.
        if (g_fLoadSystemMSHTML)
        {
            UINT uRet = GetSystemDirectory(achExe, sizeof(achExe));
            Assert(uRet);
            achExe[uRet] = FILENAME_SEPARATOR;

            achExe[uRet + 1] = 0;
        }

        TCHAR * pchName = _tcsrchr(achExe, FILENAME_SEPARATOR);
        if (!pchName)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

#ifdef UNIX
        _tcscpy(achExe, _T("mshtml.tlb"));
#else
        _tcscpy(pchName + 1, _T("mshtml.tlb"));
#endif
        hr = THR(LoadTypeLib(achExe, &_pTypeLibDLL));

        if (hr)
        {
#ifdef UNIX
            _tcscpy(achExe, _T("mshtml.dll"));
#else
            _tcscpy(pchName + 1, _T("mshtml.dll"));
#endif

            hr = THR(LoadTypeLib(achExe, &_pTypeLibDLL));
            if (hr)
                goto Cleanup;
        }
    }

    if (!_apTypeComp[1])
    {
        hr = THR(_pTypeLibDLL->GetTypeComp(&_apTypeComp[1]));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PushScript
//
//  Create a new script site/engine and push it on the script stack
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PushScript(TCHAR *pchType)
{
    HRESULT hr;
    CPadScriptSite * pScriptSite;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    pScriptSite = new CPadScriptSite(this);
    if(!pScriptSite)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pScriptSite->Init(pchType);
    if (hr)
    {
        delete pScriptSite;
        pScriptSite = NULL;
        goto Cleanup;
    }

    pScriptSite->_pScriptSitePrev = _pScriptSite;
    _pScriptSite = pScriptSite;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PopScript
//
//  Pop last script site/engine off the script stack
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PopScript()
{
    CPadScriptSite * pScriptSite = _pScriptSite;

    if(!_pScriptSite)
        return S_FALSE;

    // Script about to unload fire unload.
    FireEvent(DISPID_PadEvents_Unload, 0, NULL);

    _pScriptSite = _pScriptSite->_pScriptSitePrev;

    pScriptSite->Close();
    delete pScriptSite;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CloseScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CloseScripts()
{
    while(PopScript() == S_OK)
        ;

    Assert(_pScriptSite == NULL);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteTopLevelScript
//
//  Close previous top level script engine then load and execute script
//  in a new top level script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteTopLevelScript(TCHAR * pchPath)
{
    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    // Getting read to close the scripts fire unload event.
    CloseScripts();

    hr = THR(PushScript(_tcsrchr(pchPath, _T('.'))));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->ExecuteScriptFile(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    FireEvent(DISPID_PadEvents_Load, 0, NULL);

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteScriptlet
//
//  Add a scriptlet to the current top level script engine and execute it
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteTopLevelScriptlet(TCHAR * pchScript)
{
    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    if(!_pScriptSite)
    {
        hr = THR(PushScript(NULL));
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pScriptSite->_pScriptSitePrev == NULL);
    }

    hr = THR(_pScriptSite->ExecuteScriptStr(pchScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, UINT carg, VARIANTARG *pvararg)
{
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;

    if (_pScriptSite && _pScriptSite->_pDispSink)
    {
        dp.rgvarg            = pvararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = carg;
        dp.cNamedArgs        = 0;

        _pScriptSite->_pDispSink->Invoke(
                dispid,
                IID_NULL,
                0,
                DISPATCH_METHOD,
                &dp,
                NULL,
                &ei,
                &uArgErr);
    }
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, LPCTSTR pch)
{
    VARIANT var;

    V_BSTR(&var) = SysAllocString(pch);
    V_VT(&var) = VT_BSTR;
    FireEvent(dispid, 1, &var);
    SysFreeString(V_BSTR(&var));
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, BOOL fArg)
{
    VARIANT var;

    V_BOOL(&var) = fArg ? VARIANT_TRUE : VARIANT_FALSE;
    V_VT(&var) = VT_BOOL;
    FireEvent(dispid, 1, &var);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = _pTypeInfoIPad;
    (*pptinfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pTypeInfoIPad->GetIDsOfNames(rgszNames, cNames, rgdispid));

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pdispparams, VARIANT * pvarResult,EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pTypeInfoIPad->Invoke((IPad *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DoEvents, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DoEvents(VARIANT_BOOL fWait)
{
    PADTHREADSTATE * pts = GetThreadState();

    PerfLog1(tagPerfWatchPad, this, "+CPadDoc::DoEvents(fWait=%d)", fWait);

    pts->fEndEvents = FALSE;
    pts->cDoEvents += !!fWait;
    Run(!fWait);

    if (fWait && !pts->fEndEvents)
    {
        MessageBox(
            _hwnd,
            TEXT("Warning: DoEvents TRUE was not balanced by a call to EndEvents."),
            TEXT("EndEvents pad script error"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    if (pts->fEndEvents && !fWait)
    {
        MessageBox(
            _hwnd,
            TEXT("Warning: EndEvents called inside a DoEvents FALSE."),
            TEXT("EndEvents pad script error"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    pts->fEndEvents = FALSE;
    pts->cDoEvents -= !!fWait;

    PerfLog(tagPerfWatchPad, this, "-CPadDoc::DoEvents()");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EndEvents, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::EndEvents()
{
    PADTHREADSTATE * pts = GetThreadState();

    if (!pts->cDoEvents)
    {
        return S_OK;
    }

    pts->fEndEvents = TRUE;

    PerfLog(tagPerfWatchPad, this, "CPadDoc::EndEvents()");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::OpenFileStream, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::OpenFileStream(BSTR bstrPath)
{
    HRESULT hr = S_OK;
    IStream *pStream = NULL;

    if (_fUseShdocvw)
        return E_FAIL;

    if (bstrPath && !*bstrPath)
        bstrPath = NULL;

    if (!bstrPath)
    {
        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(CreateStreamOnFile(bstrPath, STGM_READ|STGM_SHARE_DENY_NONE, &pStream));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Open(pStream));

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::OpenFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::OpenFile(BSTR bstrPath, BSTR bstrProgID)
{
    HRESULT hr = S_OK;
    VARIANT vEmpty;
    BOOL fUseBindToObject = FALSE;

    PerfLog1(tagPerfWatchPad, this, "+CPadDoc::OpenFile(\"%ls\")", bstrPath);

    if (bstrPath && !*bstrPath)
        bstrPath = NULL;

    if (bstrPath && (*bstrPath == '*'))
    {
        fUseBindToObject = TRUE;
        bstrPath += 1;
    }

#ifdef UNIX
    SanitizePath( bstrPath );
#endif

    if (bstrProgID && *bstrProgID)
    {
        CLSID clsid;

        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if(hr)
            goto Cleanup;

        hr = THR(Open(clsid, bstrPath));
    }
    else if (bstrPath)
    {
        if (_fUseShdocvw)
        {
            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile GetBrowser");
            hr = THR(GetBrowser());
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile GetBrowser");
            if (hr)
            {
                goto Cleanup;
            }

            VariantInit(&vEmpty);

            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile _pBrowser::Navigate()");
            hr = THR(_pBrowser->Navigate(bstrPath, &vEmpty, &vEmpty, &vEmpty, &vEmpty));
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile _pBrowser::Navigate()");

            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile UpdateToolbarUI");
            UpdateToolbarUI();
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile UpdateToolbarUI");
        }
        else if (fUseBindToObject)
        {
            TCHAR ach[MAX_PATH];
            BOOL IsUrlPrefix(const TCHAR * pchPath);

            if (!IsUrlPrefix(bstrPath))
            {
                _tcscpy(ach, _T("file://"));
                _tcscat(ach, bstrPath);
                bstrPath = ach;
            }

            hr = THR(Open(bstrPath));
        }
        else
        {
            hr = THR(Open(CLSID_HTMLDocument, bstrPath));
        }
    }
    else
    {
        hr = THR(Open(CLSID_HTMLDocument, NULL));
    }

Cleanup:
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile()");
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SaveFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SaveFile(BSTR bstrPath)
{
    if(!bstrPath)
        return E_INVALIDARG;

    return Save(bstrPath);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CloseFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CloseFile()
{
    HRESULT hr;

    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    Welcome();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteCommand, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteCommand(LONG lCmdID, VARIANT * pvarParam, VARIANT *pIDocument)
{
    HRESULT hr = S_OK;;
    IOleCommandTarget * pCommandTarget = NULL;
    IDispatch         * pIDisp = NULL;

    if (!_pInPlaceObject)
        goto Cleanup;

    if ( pIDocument && V_VT( pIDocument ) == VT_DISPATCH )
    {
        //
        // If they passed a document interface
        //
        hr = THR_NOTRACE( V_DISPATCH( pIDocument )->QueryInterface( IID_IOleCommandTarget, (void **)&pCommandTarget ) );
        if( hr )
            goto Cleanup;
    }
    else
    {
        if (! g_hwndActiveWindow)
        {
            hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
                                    IID_IOleCommandTarget,
                                    (void **)&pCommandTarget));
            if(hr)
                goto Cleanup;
        }
        else
        {
            // Direct the command to the host application
            hr = GetMshtmlDoc( HandleToLong( g_hwndActiveWindow ), & pIDisp );
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pIDisp->QueryInterface(
                                    IID_IOleCommandTarget,
                                    (void **)&pCommandTarget));
            if(hr)
                goto Cleanup;
        }
    }

    if(!pvarParam || pvarParam->vt != VT_ERROR)
    {
        hr = pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                lCmdID,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                pvarParam,
                NULL);
    }
    else
    {
        hr = pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                lCmdID,
                0,
                NULL,
                NULL);
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pIDisp);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetCommandState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::QueryCommandStatus(LONG lCmdID, VARIANT * pvarState)
{
    HRESULT hr;
    IOleCommandTarget * pCommandTarget = NULL;

    if(!pvarState)
        return E_INVALIDARG;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
                            IID_IOleCommandTarget,
                            (void **)&pCommandTarget));
    if(hr)
        goto Cleanup;

    pvarState->vt = VT_NULL;

    switch(lCmdID)
    {
    case IDM_FONTSIZE:
        pvarState->vt   = VT_I4;
        pvarState->lVal = 0;
        goto QueryWithExec;
    case IDM_BLOCKFMT:
        pvarState->vt      = VT_BSTR;
        pvarState->bstrVal = NULL;
        goto QueryWithExec;
    case IDM_FONTNAME:
        pvarState->vt      = VT_BSTR;
        pvarState->bstrVal = NULL;
        goto QueryWithExec;
    case IDM_FORECOLOR:
        pvarState->vt      = VT_I4;
        pvarState->lVal    = 0;
        goto QueryWithExec;

QueryWithExec:
        hr = THR(pCommandTarget->Exec(
                    (GUID *)&CGID_MSHTML,
                    lCmdID,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    pvarState));
        break;


    default:
        MSOCMD rgCmds[1];

        rgCmds[0].cmdID = lCmdID;

        hr = pCommandTarget->QueryStatus(
                (GUID *)&CGID_MSHTML,
                1,
                rgCmds,
                NULL);
        if(hr)
            goto Cleanup;

        pvarState->vt = VT_I4;
        pvarState->lVal = rgCmds[0].cmdf;
        break;
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

HRESULT
CPadDoc::TransformXGlobal(int x, int* retX)
{
   int y = 0;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL) ;
   *retX = x ;
   return (hr);
}


HRESULT
CPadDoc::TransformYGlobal(int y, int* retY)
{
   int x = 0;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL) ;
   *retY = y ;
   return (hr) ;
}

HRESULT
CPadDoc::TransformXDocument(int x , int* retX)
{
   int y =  0 ;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT) ;
   *retX = x ;
   return (hr) ;
}


HRESULT
CPadDoc::TransformYDocument(int y, int* retY)
{
   int x =  0  ;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT) ;
   *retY = y ;
   return (hr);
}

HRESULT
CPadDoc::TransformPoint(int& X, int& Y, COORD_SYSTEM eSource, COORD_SYSTEM eDestination)
{
    HRESULT            hr = S_OK ;
    IDispatch *        pDocDisp = NULL;
    IDisplayServices*  pDispServices = NULL ;
    IHTMLDocument2*    pIDoc = NULL ;
    IHTMLElement *     pIBodyElement = NULL;
    POINT              point ;

    point.x = X ;
    point.y = Y ;

    hr = THR( get_Document( & pDocDisp ) );
    if (hr)
        goto Cleanup;

    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pIDoc) );
    Assert (pIDoc != NULL) ;

    hr = THR( pIDoc->get_body( &pIBodyElement ) ) ;
    if (hr)
        goto Cleanup;

    Assert (pIBodyElement  != NULL) ;

    hr = THR( pDocDisp->QueryInterface( IID_IDisplayServices, (void **) & pDispServices) );
    if (hr)
        goto Cleanup;

    hr = THR(pDispServices->TransformPoint( & point, eSource, eDestination, pIBodyElement) );
    X = point.x ;
    Y = point.y ;

  Cleanup :
    ReleaseInterface(pDispServices) ;
    ReleaseInterface(pIBodyElement);
    ReleaseInterface(pIDoc);
    ReleaseInterface(pDocDisp);

    RRETURN (hr);
}



//+--------------------------------------------------------------------------
//
//  Member : MoveMouseTo
//
//  Synopsis : this exposes mouse control through the pad's OM so that
//      (like send keys) script files, and drt tests can verify mouse
//      events and behavior.  the mosue api's in t3ctrl.dll is used.
//      the X and Y parameters are assumed to be in client coordiantes.
//
//+--------------------------------------------------------------------------

HRESULT
CPadDoc::MoveMouseTo(int x, int y, VARIANT_BOOL fLeftButton, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    WPARAM  wParam=0;
    LPARAM  lParam=0;

    TraceTag( (tagShowMoveMouseTo, "MoveMouse To. %d,%d " , x, y ));

    // get the appropriate HWND for this event
    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            // use window from app hosting Trident
            hwnd = g_hwndActiveWindow;
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if ((hwnd = GetFocus()) != NULL)
    {
        // use focus window if we can get one
    }
    else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
    {
        // use inplace active object hwnd
    }
    else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
    {
        // use inplace object window
    }
    else
    {
        // use our window
        hwnd = _hwnd;
    }

    pt.x = x;
    pt.y = y;

    if (!ClientToScreen(hwnd, &pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // first move the mosue, but because the accompaning
    // mosemove msg is flaky, we want to send another
    // immediately
    if(!SetCursorPos(pt.x, pt.y))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // set up the LParam
    lParam = y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += x;         // set the LOWORD

    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    wParam |= (fLeftButton==VB_TRUE) ? MK_LBUTTON : 0;

    // SendMessage to make this happen now
    if (!SendMessage(hwnd, WM_MOUSEMOVE, wParam, lParam))
    {
        hr = GetLastError();
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member : DoMouseButtonAt
//
//  Synopsis: iniate a mouse button event
//
//---------------------------------------------------------------------------

//
// ISSUE - duplication between DoMouseButton and DoMouseButtonAt.
//
HRESULT
CPadDoc::DoMouseButtonAt(int x, int y, VARIANT_BOOL fLeftButton, BSTR bstrAction, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    UINT    uMsg=0;
    WPARAM  wParam=0;
    LPARAM  lParam=0;
    BYTE             abState[256];

    // get the appropriate HWND for this event
    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            // use window from app hosting Trident
            hwnd = g_hwndActiveWindow;
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if ((hwnd = GetFocus()) != NULL)
    {
        // use focus window if we can get one
    }
    else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
    {
        // use inplace active object hwnd
    }
    else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
    {
        // use inplace object window
    }
    else
    {
        // use our window
        hwnd = _hwnd;
    }
    pt.x = x;
    pt.y = y;

    // set up the LParam
    lParam = pt.y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += pt.x;         // set the LOWORD



    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    if (GetKeyboardState(abState))
    {
        abState[VK_SHIFT] = (keyState & 0x0002) ? 0x80 : 0;
        abState[VK_CONTROL] = (keyState & 0x0001) ? 0x80 : 0;
        SetKeyboardState(abState);
    }

    // set up the Msg and the wParam
    if (_tcsicmp(bstrAction, _T("down"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDOWN;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDOWN;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("up"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("click"))==0)
    {
        // down
        hr = THR_NOTRACE(DoMouseButtonAt(x, y, fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        // up
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if ((_tcsicmp(bstrAction, _T("doubleclick"))==0) ||
            (_tcsicmp(bstrAction, _T("double"))==0))
    {
        // oh oh gotta do some work, simulate by sending down, up, down, dbl
        hr = THR_NOTRACE(DoMouseButtonAt(x,y,fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButtonAt(x,y, fLeftButton, _T("up"), keyState));
        if (hr)
            goto Cleanup;

/*        hr = THR_NOTRACE(DoMouseButtonAt(x,y, fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;*/

        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDBLCLK;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDBLCLK;
            wParam |= MK_RBUTTON;
        }
    }

    if (!PostMessage(hwnd, uMsg, wParam, lParam))
        hr = GetLastError();

Cleanup:
    RRETURN ( hr );
}

//---------------------------------------------------------------------------
//
//  Member : DoMouseButton
//
//  Synopsis: iniate a mouse button event
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DoMouseButton(VARIANT_BOOL fLeftButton, BSTR bstrAction, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    UINT    uMsg=0;
    WPARAM  wParam=0;
    LPARAM  lParam=0;

    // get the cursor's position
    if (!GetCursorPos(&pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // and the window that is going to get the message

    hwnd = WindowFromPoint(pt);
    if (!hwnd)
        goto Cleanup;

    // adjust the point
    if (!ScreenToClient(hwnd, &pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // set up the LParam
    lParam = pt.y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += pt.x;         // set the LOWORD

    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    // set up the Msg and the wParam
    if (_tcsicmp(bstrAction, _T("down"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDOWN;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDOWN;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("up"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("click"))==0)
    {
        // down
        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        // up
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if ((_tcsicmp(bstrAction, _T("doubleclick"))==0) ||
            (_tcsicmp(bstrAction, _T("double"))==0))
    {
        // oh oh gotta do some work, simulate by sending down, up, down, dbl
        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("up"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDBLCLK;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDBLCLK;
            wParam |= MK_RBUTTON;
        }
    }

    if (!PostMessage(hwnd, uMsg, wParam, lParam))
        hr = GetLastError();

Cleanup:
    RRETURN ( hr );
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintStatus, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintStatus(BSTR bstrMessage)
{
    SetStatusText(bstrMessage);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ScriptParam, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptParam(VARIANT *pvarScriptParam)
{
    HRESULT hr;

    if (_pScriptSite)
    {
        hr = THR(VariantCopy(pvarScriptParam, &_pScriptSite->_varParam));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ScriptObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptObject(IDispatch **ppDisp)
{
    HRESULT hr;

    if (_pScriptSite)
    {
        hr = THR(_pScriptSite->_pScript->GetScriptDispatch(_T("Pad"), ppDisp));
    }
    else
    {
        *ppDisp = NULL;
        hr = E_FAIL;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteScript, IPad
//
//  Load and execute script file in a brand new script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteScript(BSTR bstrPath, VARIANT *pvarScriptParam, VARIANT_BOOL fAsync)
{
    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    hr = THR(PushScript(_tcsrchr(bstrPath, _T('.'))));
    if(hr)
        goto Cleanup;

    SetWindowText(_hwnd, bstrPath);

    if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        hr = THR(VariantCopy(&_pScriptSite->_varParam, pvarScriptParam));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pScriptSite->ExecuteScriptFile(bstrPath));

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    if (fAsync)
    {
        PostMessage(_hwnd, WM_RUNSCRIPT, 0, 0);
    }
    else
    {
        FireEvent(DISPID_PadEvents_Load, 0, NULL);
        PopScript();
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::RegisterControl, IPad
//
//  Synopsis:   Register the control whose fully qualified name is passed
//              in Path.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::RegisterControl(BSTR Path)
{
#ifdef UNIX
    // Fix path in case we succeed but silently fail

    SanitizePath( Path );
    RegisterDLL( Path );

    return S_OK;
#else
    RRETURN(RegisterDLL(Path));
#endif
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IncludeScript, IPad
//
//  Load and execute script file in current script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IncludeScript(BSTR bstrPath)
{
    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    hr = THR(_pScriptSite->ExecuteScriptFile(bstrPath));

    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetProperty, IPad
//
//  Sets a property for an object, given property name and value
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetProperty(IDispatch * pDisp, BSTR bstrProperty, VARIANT * pvar)
 {
    HRESULT     hr;
    DISPPARAMS  dp;
//    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    DISPID      dispidProp;
    DISPID      dispidPut = DISPID_PROPERTYPUT;

    if (!pvar)
    {
        return E_INVALIDARG;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &bstrProperty, 1, 0, &dispidProp);
    if (hr)
        goto Cleanup;

    dp.rgvarg            = pvar;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs             = 1;
    dp.cNamedArgs        = 1;

    hr = pDisp->Invoke(
                dispidProp,
                IID_NULL,
                0,
                DISPATCH_PROPERTYPUT,
                &dp,
                NULL,
                NULL,   // use excepinfo?
                &uArgErr);

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetProperty, IPad
//
//  Gets a property value for an object, given property name
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetProperty(IDispatch * pDisp, BSTR bstrProperty, VARIANT * pvar)
{
    HRESULT     hr;
    DISPPARAMS  dp;
//    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    DISPID      dispidProp;

    if (!pvar)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &bstrProperty, 1, 0, &dispidProp);
    if (hr)
        goto Cleanup;

    dp.rgvarg            = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs             = 0;
    dp.cNamedArgs        = 0;

    hr = pDisp->Invoke(
                dispidProp,
                IID_NULL,
                0,
                DISPATCH_PROPERTYGET,
                &dp,
                pvar,
                NULL,       // use excepinfo?
                &uArgErr);

Cleanup:
    if (hr)
    {
        pvar->vt = VT_NULL;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_Document, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_Document(IDispatch **ppDocDisp)
{
    HRESULT hr = S_OK;
    IHTMLDocument2 *pOmDoc;

    if(!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->get_Document(ppDocDisp));
    }
    else if (_pObject)
    {
        hr = THR(GetOmDocumentFromDoc (_pObject, &pOmDoc));
        if (OK(hr))
        {
            *ppDocDisp = pOmDoc;
        }
    }

Cleanup:
    RRETURN (hr);
}

HRESULT 
CPadDoc::get_Document_Early(IDispatch **ppDocDisp)
{
    HRESULT hr = S_OK;
    IHTMLDocument2 *pOmDoc;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pObjectHBI)
    {
        hr = THR(GetOmDocumentFromDoc(_pObjectHBI, &pOmDoc));
        if (OK(hr))
        {
            *ppDocDisp = pOmDoc;
        }
    }

Cleanup:
    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TempPath, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_TempPath(BSTR * pbstrPath)
{
    TCHAR achTempPath[MAX_PATH];
    int cch;

    if(!pbstrPath)
        return E_INVALIDARG;

    cch = GetTempPath(ARRAY_SIZE(achTempPath), achTempPath);

    if(cch == 0 || cch > ARRAY_SIZE(achTempPath))
        return E_FAIL;

    *pbstrPath = SysAllocString(achTempPath);

    if(!*pbstrPath)
        return E_OUTOFMEMORY;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TempFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTempFileName(BSTR * pbstrName)
{
    HRESULT hr;
    BSTR bstrPath;
    TCHAR achTempFile[MAX_PATH];

    if(!pbstrName)
        return E_INVALIDARG;

    hr = get_TempPath(&bstrPath);
    if(hr)
        goto Cleanup;

    if(::GetTempFileName(bstrPath, _T("PAD"), 0, achTempFile) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pbstrName = SysAllocString(achTempFile);

    if(!*pbstrName)
        hr = E_OUTOFMEMORY;

Cleanup:
    SysFreeString(bstrPath);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CleanupTempFiles, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CleanupTempFiles()
{
    HRESULT          hr;
    BSTR             bstrPath;
    CHAR             achTempFile[MAX_PATH];
    HANDLE           hFiles;
    WIN32_FIND_DATAA fd;
    CHAR          *  pch;
    int              c;

    //
    // This is all done in ANSI because we don't have unicode wrappers for
    // FindFirstFile and etc.
    //
    hr = get_TempPath(&bstrPath);
    if (hr)
        goto Cleanup;

    c = WideCharToMultiByte(CP_ACP,
                            0,
                            bstrPath,
                            SysStringLen(bstrPath),
                            achTempFile,
                            MAX_PATH,
                            NULL,
                            NULL);

    pch = achTempFile + c;

    Assert(*(pch-1) == FILENAME_SEPARATOR);

    strcpy(pch, "PAD*.TMP");

    hFiles = FindFirstFileA(achTempFile, &fd);

    if (hFiles == INVALID_HANDLE_VALUE)
    {
        hr = S_OK;
        goto Cleanup;
    }

    do
    {
        if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            strcpy(pch, fd.cFileName);

            (void) DeleteFileA(achTempFile); // Ignore errors
        }
    } while (FindNextFileA(hFiles, &fd));

    FindClose(hFiles);

Cleanup:
    SysFreeString(bstrPath);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintLog, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintLog(BSTR bstrLine)
{
    DWORD  cchLen = SysStringLen(bstrLine);
    char * pchBuf = new char[cchLen+3];

    WideCharToMultiByte(CP_ACP, 0, bstrLine, cchLen, pchBuf, cchLen+1, NULL, NULL);
    pchBuf[cchLen] = '\0';

    TraceTagEx((tagScriptLog, TAG_NONAME, "%s", pchBuf));

    DWORD  cbWrite;

    //
    // Write to STDOUT. Used by the DRTDaemon process to relay information
    // back to the build machine. Ignore any errors.
    //
    strcat(pchBuf, "\r\n");

    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
              pchBuf,
              cchLen+2,
              &cbWrite,
              NULL);

    delete pchBuf;

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintLogFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintLogFile(BSTR bstrFileName)
{
    HANDLE hFile = CreateFile(bstrFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD err;

    if (hFile)
    {
        char  buffer[200];
        DWORD cbRead = 0;
        DWORD cbWrite = 0;
        int ichLimRead = 0;
        int ichLim = 0;

        // read from file while it lasts
        do
        {
            if (ichLim >= ichLimRead
                && ::ReadFile(hFile,
                              buffer + ichLimRead,
                              sizeof(buffer) - ichLimRead,
                              &cbRead,
                              NULL)
                && cbRead)
            {
                // if read something, write it to STDOUT
                WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
                          buffer + ichLimRead,
                          cbRead,
                          &cbWrite,
                          NULL);

                if (!cbWrite)
                    err = GetLastError();

                ichLimRead += cbRead;
            }

            // now break text in lines and send to debug output one at a time

            // Look for LF or full buffer
            while (ichLim < ichLimRead && buffer[ichLim] != '\n')
                ichLim++;

            if (ichLim < ichLimRead ||          // found LF
                ichLimRead == sizeof(buffer) || // full buffer
                cbRead == 0 && ichLimRead > 0)  // EOF
            {
                int cch = ichLim++; // skip LF

                // ignore CR
                if (cch && buffer[cch - 1] == '\r')
                    cch--;

                // write line to debug output
                TraceTagEx((tagScriptLog, TAG_NONAME, "%.*s", cch, buffer));

                // shift remainder of the buffer to the left
                int ichLimCopy;
                for (ichLimCopy = ichLimRead, ichLimRead = 0; ichLim < ichLimCopy;)
                    buffer[ichLimRead++] = buffer[ichLim++];
                ichLim = 0;
            }
        }
        while (cbRead);

        CloseHandle(hFile);
    }

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintDebug, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintDebug(BSTR bstrValue)
{
    if(!_pDebugWindow)
        ToggleDebugWindowVisibility();

    Assert(_pDebugWindow);

    RRETURN(THR(_pDebugWindow->Print(bstrValue)));
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DRTPrint, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DRTPrint(long Flags, VARIANT_BOOL * Success)
{
    HRESULT hr = E_FAIL;
    VARIANT varPrintFlags;
    VARIANT_BOOL fOutputFileExists;

    // 1. Print the current doc.

    V_VT(&varPrintFlags) = VT_I2;
    V_I2(&varPrintFlags) = (short) Flags;

    hr = THR( ExecuteCommand(IDM_PRINT, &varPrintFlags, NULL) );
    if (hr)
        goto Cleanup;

    // 2. Wait until the DRT output file exists.
    do
    {
        hr = THR( FileExists(PRINTDRT_FILE, &fOutputFileExists) );

        if (hr)
            goto Cleanup;
    }
    while (fOutputFileExists == VB_FALSE && MsgWaitForMultipleObjects(0, NULL, FALSE, 250, 0) == WAIT_TIMEOUT);

    #if (defined(_X86_))
    // 3. Fire up a postscript viewer.
    if (!(Flags & 128))
    {
        HINSTANCE hInstance = 0;
        HWND hwndDesktop = GetDesktopWindow();

        if (g_fUnicodePlatform)
        {
            hInstance = ShellExecuteW(hwndDesktop, NULL, _T("gs.bat"), PRINTDRT_FILE, NULL, SW_HIDE);
        }
        else
        {
            hInstance = ShellExecuteA(hwndDesktop, NULL, "gs.bat", PRINTDRT_FILEA, NULL, SW_HIDE);
        }

        Assert((LONG) hInstance > 32 && "Error bringing up a postscript viewer.  Verify C:\\PRINTDRT.PS manually by printing it.");
    }
    #endif

Cleanup:

    *Success = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetDefaultPrinter, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetDefaultPrinter(BSTR bstrNewDefaultPrinter, VARIANT_BOOL * Success)
{
    HRESULT hr= E_FAIL;
    *Success = VB_FALSE;;

#if (defined(_X86_))
    HWND hwndDesktopWindow = GetDesktopWindow();
    HWND hwndInternetExplorer = 0;

    if (g_fUnicodePlatform)
    {
       hr = WriteProfileStringW(_T("Windows"), _T("Device"), (const TCHAR *)bstrNewDefaultPrinter)
           ? S_OK : E_FAIL;


        if (!hr && hwndDesktopWindow)
        {
            // make sure the spooler knows about the new default printer
            // Cause MSHMTL.DLL to re-read registry settings
            do
            {
                hwndInternetExplorer = FindWindowExW(hwndDesktopWindow, hwndInternetExplorer, _T("Internet Explorer_Hidden"), NULL);


                if (hwndInternetExplorer)
                {
                    SendMessage(hwndInternetExplorer, WM_UPDATEDEFAULTPRINTER, 0, 0);
                }
            }
            while (hwndInternetExplorer);
        }
    }
    else
    {
        char strNewDefaultPrinter[100];
        DWORD cbNewDefaultPrinter = WideCharToMultiByte(
                CP_ACP, 0, bstrNewDefaultPrinter, -1, strNewDefaultPrinter, 100, NULL, NULL);

        hr = (cbNewDefaultPrinter && WriteProfileStringA("Windows", "Device", (const char *)strNewDefaultPrinter))
            ? S_OK : E_FAIL;

        if (!hr && hwndDesktopWindow)
        {
            // make sure the spooler knows about the new default printer
            // Cause MSHMTL.DLL to re-read registry settings
            do
            {
                hwndInternetExplorer = FindWindowExA(hwndDesktopWindow, hwndInternetExplorer, "Internet Explorer_Hidden", NULL);

                if (hwndInternetExplorer)
                {
                    SendMessage(hwndInternetExplorer, WM_UPDATEDEFAULTPRINTER, 0, 0);
                }
            }
            while (hwndInternetExplorer);
        }
    }

    *Success = hr ? VB_FALSE : VB_TRUE;

#endif // _X86_

    RRETURN1(hr, E_FAIL);
}

HRESULT
CPadDoc::SetPrintTemplate(IUnknown *pUnk, VARIANT_BOOL fTemplate)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pioct = NULL;
    VARIANT varIn;
    VariantInit(&varIn);

    if (!pUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = fTemplate;

    hr = pUnk->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    hr = pioct->Exec(&CGID_MSHTML, IDM_SETPRINTTEMPLATE, 0, &varIn, 0);

Cleanup:
    ReleaseInterface(pioct);
    return hr;
}

HRESULT
CPadDoc::IsPrintTemplate(IUnknown *pUnk, VARIANT_BOOL * pfTemplate)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pioct = NULL;
    VARIANT     varOut;
    VariantInit(&varOut);

    if (!pUnk || !pfTemplate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pUnk->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    hr = pioct->Exec(&CGID_MSHTML, IDM_GETPRINTTEMPLATE, 0, 0, &varOut);
    if (hr)
        goto Cleanup;

    if (V_VT(&varOut) != VT_BOOL)
        hr = E_FAIL;
    else
        *pfTemplate = V_BOOL(&varOut);

Cleanup:
    VariantClear(&varOut);
    ReleaseInterface(pioct);
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CompareFiles, IPad
//          and AreFilesSame helper fn()
//          and IsPostscript helper fn()
//          and ComparePostscriptFiles helper fn()
//
//---------------------------------------------------------------------------

BOOL
AreFilesSame(HANDLE hFile1, HANDLE hFile2)
{
    DWORD dwFile1Size, dwFile2Size, dwCurSize, dwActualRead;

    Assert(hFile1 != INVALID_HANDLE_VALUE && hFile2 != INVALID_HANDLE_VALUE);

    // get and compare the files
    dwFile1Size = GetFileSize(hFile1, NULL);
    dwFile2Size = GetFileSize(hFile2, NULL);

    if (dwFile1Size != dwFile2Size)
        return FALSE;

    dwCurSize = 0;

    while (dwCurSize < dwFile1Size)
    {
        DWORD dwRead;
        char Buf1[FILEBUFFERSIZE], Buf2[FILEBUFFERSIZE];
        dwCurSize += FILEBUFFERSIZE;

        // determine number of bytes to read
        if (dwCurSize <= dwFile1Size)
            dwRead = FILEBUFFERSIZE;
        else
            dwRead = dwFile1Size - (dwCurSize - FILEBUFFERSIZE);

        // read a portion of the first file
        if (!ReadFile(hFile1, Buf1, dwRead, &dwActualRead, NULL) ||
            !ReadFile(hFile2, Buf2, dwRead, &dwActualRead, NULL))
        {
            TraceTag((tagError, "ERROR reading one of the htm files."));
            return FALSE;
        }

        if (memcmp(Buf1, Buf2, dwActualRead) != 0)
            return FALSE;
    }
    return TRUE;
}

BOOL IsPostscript(BSTR bstrFile)
{
    if (!bstrFile)
        return FALSE;

    if (_tcslen(bstrFile) < 3)
        return FALSE;

    return (StrCmpIC(_T(".ps"), bstrFile+_tcslen(bstrFile)-3) == 0);
}

HRESULT
ReadNextPostscriptLine(HANDLE hFile, char *lpBuffer, LPDWORD pdwLineLength)
{
    char  * lpFirstNewLine;
    char  * lpFirstRandomIdentifier;
    int     cch;

    Assert(lpBuffer);

    do
    {
        // read a portion of the file
        if (!ReadFile(hFile, lpBuffer, FILEBUFFERSIZE, pdwLineLength, NULL))
        {
            TraceTag((tagError, "ERROR reading one of the postscript files."));
            return E_FAIL;
        }

        // end of file?
        if (*pdwLineLength == 0)
            return S_OK;

        // find the first new line in the buffer
        for (cch = *pdwLineLength, lpFirstNewLine = lpBuffer; cch > 0; --cch, ++lpFirstNewLine)
            if (*lpFirstNewLine == 10)
                break;
        if (*lpFirstNewLine != 10)
            lpFirstNewLine = NULL;

        // if we found a new line, reposition the file pointer
        if (lpFirstNewLine)
        {
            SetFilePointer(hFile, (lpFirstNewLine - lpBuffer + 1) - *pdwLineLength, NULL, FILE_CURRENT);

            *pdwLineLength = lpFirstNewLine - lpBuffer;
        }
    }
    while (lpBuffer[0] == '%' && lpBuffer[1] == '%');

    // before we return successfully, we have to NULL out all font identifiers starting with
    // MSTT followed by a 8-digit hexcode.

    lpBuffer[*pdwLineLength] = 0;
    lpFirstRandomIdentifier = lpBuffer;

    do
    {
        // Find first occurence of "MSTT"
        lpFirstRandomIdentifier = StrStrA(lpFirstRandomIdentifier, "MSTT");

        // If found, NULL out the random 8-digit hexcode following it.
        if (lpFirstRandomIdentifier)
        {
            int nPadding = *pdwLineLength - (lpFirstRandomIdentifier+4-lpBuffer); // chars left in line

            // Zero out at most 8 characters.
            if (nPadding > 8)
                nPadding = 8;

            memset( lpFirstRandomIdentifier+4, '0', nPadding );

            // prevent finding the same occurence again.
            lpFirstRandomIdentifier++;
        }
    }
    while (lpFirstRandomIdentifier);

    return S_OK;
}

BOOL
ComparePostscriptFiles(HANDLE hFile1, HANDLE hFile2)
{
    DWORD dwActualRead1, dwActualRead2;

    Assert(hFile1 != INVALID_HANDLE_VALUE && hFile2 != INVALID_HANDLE_VALUE);

    do
    {
        char Buf1[FILEBUFFERSIZE], Buf2[FILEBUFFERSIZE];
        HRESULT hr;

        hr = ReadNextPostscriptLine(hFile1, Buf1, &dwActualRead1);
        if (hr)
            return FALSE;

        hr = ReadNextPostscriptLine(hFile2, Buf2, &dwActualRead2);
        if (hr)
            return FALSE;

        if (dwActualRead1 && dwActualRead2)
        {
            // Compare lengths of lines.
            if (dwActualRead1 != dwActualRead2)
                return FALSE;

            // Compare lines.
            if (memcmp(Buf1, Buf2, dwActualRead1) != 0)
                return FALSE;
        }
    }
    // We compare until one of the files reaches its end.
    while (dwActualRead1 && dwActualRead2);

    return TRUE;
}

HRESULT
CPadDoc::CompareFiles(BSTR bstrFile1, BSTR bstrFile2, VARIANT_BOOL *pfMatch)
{
    HANDLE hFile1;
    HANDLE hFile2;
    BOOL fMatch = TRUE;

    hFile1 = CreateFile(bstrFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE)
        fMatch = FALSE;

    hFile2 = CreateFile(bstrFile2, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE)
        fMatch = FALSE;

    if (fMatch)
    {
        fMatch =
        // Are we comparing postscript files?
        (IsPostscript(bstrFile1) && IsPostscript(bstrFile2)) ?
            // Comparing postscript files requires dropping postscript
            // comments (%%) that contain irrelevant, but distinct information
            // such as the creation date, time, and environment.
            ComparePostscriptFiles(hFile1,hFile2) :
            // else do normal compare
            AreFilesSame(hFile1, hFile2);
    }
    if (hFile1 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile1);
    if (hFile2 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile2);

    *pfMatch = fMatch ? VB_TRUE : VB_FALSE;
    RRETURN(S_OK);
}

HRESULT
CPadDoc::CopyThisFile(BSTR bstrFile1, BSTR bstrFile2, VARIANT_BOOL *pfSuccess)
{
    *pfSuccess = CopyFile(bstrFile1, bstrFile2, FALSE) ? VB_TRUE : VB_FALSE;
    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FileExists, IPad
//
//  Synopsis:  Return TRUE if file exists.
//---------------------------------------------------------------------------

HRESULT
CPadDoc::FileExists(BSTR bstrFile, VARIANT_BOOL *pfFileExists)
{
    DWORD dwReturn;
    LPTSTR pDummy;

    dwReturn = SearchPath(NULL, bstrFile, NULL, 0, NULL, &pDummy);
    *pfFileExists = (dwReturn > 0) ? VB_TRUE : VB_FALSE;

    if (*pfFileExists == VB_TRUE)
    {
        HANDLE hFile = CreateFile(bstrFile, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            *pfFileExists = VB_FALSE;
        else
            CloseHandle(hFile);
    }

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DisableDialogs, IPad
//
//  Note: UnhandledExceptionHandler is the global exception handler that gets
//        called whenever an unhandled exception occurs in Pad. This is
//        installed when SetUnhandledExceptionFilter is called from
//        DisableDialogs.
//
//---------------------------------------------------------------------------

LONG UnhandledExceptionHandler(LPEXCEPTION_POINTERS lpexpExceptionInfo)
{
    HANDLE hProcess;

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
    if (hProcess)
    {
        char * pszExType = NULL;
        char   achBuf[200];

        switch (lpexpExceptionInfo->ExceptionRecord->ExceptionCode)
        {
        case EXCEPTION_ACCESS_VIOLATION:
            pszExType = "Access Violation";
            break;

        case EXCEPTION_BREAKPOINT:
            pszExType = "Breakpoint Hit";
            break;

        case EXCEPTION_STACK_OVERFLOW:
            pszExType = "Stack Overflow";
            break;

        default:
            pszExType = "Unhandled Exception";
            break;
        }

        wsprintfA(achBuf, "*** FATAL ERROR: %s at", pszExType);

        DbgExGetSymbolFromAddress(lpexpExceptionInfo->ExceptionRecord->ExceptionAddress,
                                  &achBuf[strlen(achBuf)], ARRAY_SIZE(achBuf) - strlen(achBuf) - 2);

        //
        // We explicitly turn off the assert stacktrace here because it only
        // gives the stacktrace of this UnhandledExceptionHandler, which means
        // nothing and just confuses people.
        //
        BOOL fStacktrace = DbgExEnableTag(tagAssertStacks, FALSE);

        AssertSz(FALSE, achBuf);

        DbgExEnableTag(tagAssertStacks, fStacktrace);

        TerminateProcess(hProcess, 1);
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

HRESULT
CPadDoc::DisableDialogs()
{
    SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOGPFAULTERRORBOX);
    SetUnhandledExceptionFilter(UnhandledExceptionHandler);
    EnableTag(tagAssertExit, TRUE);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_DialogsDisabled, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_DialogsEnabled(VARIANT_BOOL *pfEnabled)
{
    *pfEnabled = IsTagEnabled(tagAssertExit) ? VB_FALSE : VB_TRUE;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::get_ScriptBase, IPad
//
//  Arguments:  i  - Number of levels back up the script path to return.
//                   0 returns directory containing script.
//                   1 returns parent of directory containing script
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptPath(long i, BSTR * pbstrPath)
{
    TCHAR achPath[MAX_PATH];
    TCHAR *pch = NULL;

    *pbstrPath = NULL;
    if (_pScriptSite)
    {
        memcpy(achPath, _pScriptSite->_achPath, sizeof(achPath));
        for (; i >= 0; i--)
        {
            pch = _tcsrchr(achPath, _T(FILENAME_SEPARATOR));
            if (pch)
            {
                *pch = 0;
            }
            else
            {
                return E_FAIL;
            }
        }
        if (pch)
        {
            pch[0] = _T(FILENAME_SEPARATOR);
            pch[1] = 0;
        }
        *pbstrPath = SysAllocString(achPath);
    }

    return *pbstrPath ? S_OK : E_FAIL;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_TimerInterval, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_TimerInterval(long lInterval)
{
    KillTimer(_hwnd, 0);
    _lTimerInterval = lInterval;
    if (_lTimerInterval)
    {
        SetTimer(_hwnd, 0, _lTimerInterval, NULL);
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TimerInterval, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_TimerInterval(long *plInterval)
{
    *plInterval = _lTimerInterval;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ResumeCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ResumeCAP()
{
    ::ResumeCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SuspendCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SuspendCAP()
{
    ::SuspendCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::StartCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::StartCAP()
{
    ::StartCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::StopCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::StopCAP()
{
    ::StopCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::TicStartAll, IPad
//  Member: CPadDoc::TicStopAll, IPad
//
//---------------------------------------------------------------------------

DYNLIB g_dynlibTimeLib = { NULL, NULL, "TimeLib.DLL" };
DYNPROC g_dynprocTicStartAll = { NULL, &g_dynlibTimeLib, "TicStartAll" };
DYNPROC g_dynprocTicStopAll = { NULL, &g_dynlibTimeLib, "TicStopAll" };

HRESULT
CPadDoc::TicStartAll()
{
    if (    g_dynprocTicStartAll.pfn != NULL
        ||  LoadProcedure(&g_dynprocTicStartAll) == S_OK)
    {
        ((HRESULT (STDAPICALLTYPE *)())g_dynprocTicStartAll.pfn)();
    }

    return(S_OK);
}

HRESULT
CPadDoc::TicStopAll()
{
    if (    g_dynprocTicStopAll.pfn != NULL
        ||  LoadProcedure(&g_dynprocTicStopAll) == S_OK)
    {
        ((HRESULT (STDAPICALLTYPE *)())g_dynprocTicStopAll.pfn)();
    }

    return(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DumpMeterLog, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DumpMeterLog(BSTR bstrFileName)
{
    char ach[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, bstrFileName, -1, ach, sizeof(ach), NULL, NULL);
    DbgExMtLogDump(ach);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::LookupMeter, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LookupMeter(BSTR Meter, long* mt)
{
    char ach[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, Meter, -1, ach, sizeof(ach), NULL, NULL);

    *mt = (long)DbgExMtLookupMeter( ach );

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterName, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterName(long mt, BSTR* pbstrName)
{
    char * pchA = DbgExMtGetName( (PERFMETERTAG) mt );

    WCHAR  szBufW[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pchA, -1,
                        szBufW, sizeof(szBufW)/sizeof(TCHAR));

    *pbstrName = SysAllocString(szBufW);

    RRETURN(*pbstrName ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterDesc, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterDesc(long mt, BSTR* pbstrDesc)
{
    char * pchA = DbgExMtGetDesc( (PERFMETERTAG) mt );

    WCHAR  szBufW[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pchA, -1,
                        szBufW, sizeof(szBufW)/sizeof(TCHAR));

    *pbstrDesc = SysAllocString(szBufW);

    RRETURN(*pbstrDesc ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterCnt, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterCnt(long mt, VARIANT_BOOL fExcl, long* plCnt)
{
    *plCnt = DbgExMtGetMeterCnt( (PERFMETERTAG) mt, !!fExcl );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterVal, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterVal(long mt, VARIANT_BOOL fExcl, long* plVal)
{
    *plVal = DbgExMtGetMeterVal( (PERFMETERTAG) mt, !!fExcl );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MeterAdd, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MeterAdd(long mt, long lCnt, long lVal)
{
    DbgExMtAdd( (PERFMETERTAG) mt, lCnt, lVal );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MeterSet, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MeterSet(long mt, long lCnt, long lVal)
{
    DbgExMtSet( (PERFMETERTAG) mt, lCnt, lVal );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetSwitchTimers, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetSwitchTimers(VARIANT * pValue)
{
    TCHAR ach[256];

    ach[0] = 0;
    pValue->vt = VT_BSTR;
    pValue->bstrVal = NULL;

    IOleCommandTarget * pCommandTarget = NULL;

    _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

    if (pCommandTarget)
    {
        VARIANT v;
        v.vt = VT_BSTR;
        v.bstrVal = (BSTR)ach;
        pCommandTarget->Exec((GUID *)&CGID_MSHTML, IDM_GETSWITCHTIMERS, 0, NULL, &v);
        pCommandTarget->Release();
    }

    pValue->bstrVal = SysAllocString(ach);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetObject(BSTR bstrFile, BSTR bstrProgID, IDispatch **ppDisp)
{
    HRESULT hr;
    CLSID clsid;
    IPersistFile *pPF = NULL;
    IUnknown *pUnk = NULL;
    IBindCtx *pBCtx = NULL;
    IMoniker *pMk = NULL;

    *ppDisp = NULL;

    if (bstrFile && !*bstrFile)
        bstrFile = NULL;

    if (bstrProgID && !*bstrProgID)
        bstrProgID = NULL;

    if (bstrProgID)
    {
        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if (hr)
            goto Cleanup;
    }

    if (bstrFile && bstrProgID)
    {
        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_SERVER,
                IID_IPersistFile, (void **)&pPF));
        if (hr)
            goto Cleanup;

        hr = THR(pPF->Load(bstrFile, 0));
        if (hr)
            goto Cleanup;

        hr = THR(pPF->QueryInterface(IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;
    }
    else if (bstrFile)
    {
        ULONG cEaten;

        hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
        if (hr)
            goto Cleanup;

        hr = THR(MkParseDisplayName(pBCtx, bstrFile, &cEaten, &pMk));
        if (hr)
            goto Cleanup;

        hr = THR(pMk->BindToObject(pBCtx, NULL, IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;

    }
    else if (bstrProgID)
    {
        hr = THR(GetActiveObject(clsid, NULL, &pUnk));
        if (hr)
            goto Cleanup;

        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_INVALIDARG;
    }


Cleanup:
    ReleaseInterface(pPF);
    ReleaseInterface(pBCtx);
    ReleaseInterface(pMk);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CreateObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CreateObject(BSTR bstrProgID, IDispatch **ppDisp)
{
    extern CPadFactory PadDocFactory;
    HRESULT hr;
    CLSID clsid;
    IUnknown *pUnk = NULL;

    if (StrCmpIC(bstrProgID, _T("TridentPad")) == 0)
    {

        // Short circuit our own object so we do not depend
        // on user registering this version of HTMLPad.

        CThreadProcParam tpp(FALSE, ACTION_NONE);
        hr = THR(CreatePadDoc(&tpp, &pUnk));
        if (hr)
            goto Cleanup;

        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)ppDisp));
    }
    else
    {
        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if (hr)
            goto Cleanup;

        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_SERVER,
                     IID_IDispatch, (void **)ppDisp));
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_CurrentTime, IPad
//
//---------------------------------------------------------------------------

#ifdef USE_PERFORMANCE_DATA_HELPER

static DYNLIB g_dynlibPdh = { NULL, NULL, "pdh.dll" };
static DYNPROC g_dynprocPdhOpenQuery = { NULL, &g_dynlibPdh, "PdhOpenQuery" };
static DYNPROC g_dynprocPdhAddCounterW = { NULL, &g_dynlibPdh, "PdhAddCounterW" };
static DYNPROC g_dynprocPdhCollectQueryData = { NULL, &g_dynlibPdh, "PdhCollectQueryData" };
static DYNPROC g_dynprocPdhSetCounterScaleFactor = { NULL, &g_dynlibPdh, "PdhSetCounterScaleFactor" };
static DYNPROC g_dynprocPdhGetFormattedCounterValue = { NULL, &g_dynlibPdh, "PdhGetFormattedCounterValue" };
static DYNPROC g_dynprocPdhCloseQuery = { NULL, &g_dynlibPdh, "PdhCloseQuery" };
typedef PDH_STATUS (WINAPI *PFN_PDHOPENQUERY)(LPVOID, DWORD_PTR, HQUERY);
typedef PDH_STATUS (WINAPI *PFN_PDHADDCOUNTER)(HQUERY, LPCWSTR, DWORD_PTR, HCOUNTER);
typedef PDH_STATUS (WINAPI *PFN_PDHCOLLECTQUERYDATA)(HQUERY);
typedef PDH_STATUS (WINAPI *PFN_PDHSETCOUNTERSCALEFACTOR)(HCOUNTER, LONG);
typedef PDH_STATUS (WINAPI *PFN_PDHGETFORMATTEDCOUNTERVALUE)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
typedef PDH_STATUS (WINAPI *PFN_PDHCLOSEQUERY)(HQUERY);

static BOOL g_fInitDone = FALSE;
static BOOL g_fInitSuccess = FALSE;

static BOOL EnsureInitPDH()
{
    if (g_fInitDone)
        return g_fInitSuccess;

    if (    LoadProcedure(&g_dynprocPdhOpenQuery) != S_OK
        ||  LoadProcedure(&g_dynprocPdhAddCounterW) != S_OK
        ||  LoadProcedure(&g_dynprocPdhCollectQueryData) != S_OK
        ||  LoadProcedure(&g_dynprocPdhSetCounterScaleFactor) != S_OK
        ||  LoadProcedure(&g_dynprocPdhGetFormattedCounterValue) != S_OK
        ||  LoadProcedure(&g_dynprocPdhCloseQuery) != S_OK )
    {
        g_fInitSuccess = FALSE;
    }
    else
    {
        g_fInitSuccess = TRUE;
    }

    g_fInitDone = TRUE;

    return g_fInitSuccess;
}
#endif

HRESULT
CPadDoc::get_CurrentTime(long *plTime)
{
    LONGLONG f;
    LONGLONG t;

    QueryPerformanceFrequency((LARGE_INTEGER *)&f);
    QueryPerformanceCounter((LARGE_INTEGER *)&t);

    *plTime = (long)((t * 1000) / f);

    PerfLog1(tagPerfWatchPad, this, "CPadDoc::CurrentTime(*plTime=%ld)", *plTime);

    return S_OK;

#ifdef USE_GETPROCESSTIMES
    FILETIME ftCreate;
    FILETIME ftExit;
    LONGLONG kt;
    LONGLONG ut;

    if (!GetProcessTimes( ::GetCurrentProcess(), &ftCreate, &ftExit, (LPFILETIME)&kt, (LPFILETIME)&ut) )
    {
        return E_FAIL;
    }

    *plTime = (long)(ut / 10000i64);

    return S_OK;
#endif

#ifdef USE_PERFORMANCE_DATA_HELPER
    PDH_STATUS  status;
    HQUERY      hQuery;
    HQUERY      hCounter;
    PDH_FMT_COUNTERVALUE value;

    if (!EnsureInitPDH())
    {
        return E_FAIL;
    }

    status = ((PFN_PDHOPENQUERY)g_dynprocPdhOpenQuery.pfn)(NULL, NULL, &hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHADDCOUNTER)g_dynprocPdhAddCounterW.pfn)(hQuery, _T("\\Process(MSHTMPAD)\\Elapsed Time"), NULL, &hCounter);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHSETCOUNTERSCALEFACTOR)g_dynprocPdhSetCounterScaleFactor.pfn)(hCounter, 3);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHCOLLECTQUERYDATA)g_dynprocPdhCollectQueryData.pfn)(hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHGETFORMATTEDCOUNTERVALUE)g_dynprocPdhGetFormattedCounterValue.pfn)(hCounter, PDH_FMT_LONG, NULL, &value);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHCLOSEQUERY)g_dynprocPdhCloseQuery.pfn)(hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    *plTime = value.longValue;

Cleanup:
    return status == ERROR_SUCCESS ? S_OK : E_FAIL;
#endif
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Show, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ShowWindow(long lCmdShow)
{
    if (_hwnd)
    {
        ::ShowWindow(_hwnd, lCmdShow);
    }

    if (lCmdShow == SW_HIDE && _fVisible)
    {
        _fVisible = FALSE;
        Release();
    }
    else if (lCmdShow != SW_HIDE && !_fVisible)
    {
        _fVisible = TRUE;
        AddRef();
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MoveWindow, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MoveWindow(long x, long y, long cx, long cy)
{
    if (_hwnd)
    {
        ::MoveWindow(_hwnd, x, y, cx, cy, TRUE);
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Left/Top/Width/Height, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_WindowLeft(long *px)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *px = rc.left;
    }
    else
    {
        *px = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowTop(long *py)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *py = rc.top;
    }
    else
    {
        *py = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowWidth(long *pcx)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *pcx = rc.right - rc.left;
    }
    else
    {
        *pcx = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowHeight(long *pcy)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *pcy = rc.bottom - rc.top;
    }
    else
    {
        *pcy = 0;
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Assert, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ASSERT(VARIANT_BOOL fAssert, BSTR bstrMessage)
{
    if (!fAssert)
    {
        char ach[20000];

        // Add name of currently executing script to the assert message.

        if (!_pScriptSite || !_pScriptSite->_achPath[0])
        {
            ach[0] = 0;
        }
        else
        {
            // Try to chop of directory name.

            TCHAR * pchName = wcsrchr(_pScriptSite->_achPath, _T(FILENAME_SEPARATOR));
            if (pchName)
                pchName += 1;
            else
                pchName = _pScriptSite->_achPath;

            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchName,
                    -1,
                    ach,
                    MAX_PATH,
                    NULL,
                    NULL);

            strcat(ach, ": ");
        }

        // Add message to the assert.

        if (!bstrMessage || !*bstrMessage)
        {
            strcat(ach, "HTMLPad Script Assert");
        }
        else
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    bstrMessage,
                    -1,
                    &ach[strlen(ach)],
                    ARRAY_SIZE(ach) - MAX_PATH - 3,
                    NULL,
                    NULL);
        }

        PrintLog(bstrMessage);

        AssertSz(0, ach);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::WaitForRecalc, IPad
//
//  Synopsis: Wait for the document to finish recalcing
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::WaitForRecalc()
{
    IOleCommandTarget * pCommandTarget = NULL;

    _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

    if (pCommandTarget)
    {
        pCommandTarget->Exec((GUID *)&CGID_MSHTML, IDM_WAITFORRECALC, 0, NULL, NULL);
        pCommandTarget->Release();
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetPerfCtl, IPad
//
//  Synopsis: Setup the HtmPerfCtl block
//
//---------------------------------------------------------------------------

HANDLE      g_hMapHtmPerfCtl = NULL;
HTMPERFCTL *g_pHtmPerfCtl = NULL;

void WINAPI PadDocCallback(DWORD dwArg1, void * pvArg2)
{
    ((CPadDoc *)g_pHtmPerfCtl->pvHost)->PerfCtlCallback(dwArg1, pvArg2);
}

void
DeletePerfCtl()
{
    if (g_pHtmPerfCtl)
        Verify(UnmapViewOfFile(g_pHtmPerfCtl));
    if (g_hMapHtmPerfCtl)
        Verify(CloseHandle(g_hMapHtmPerfCtl));
    g_pHtmPerfCtl = NULL;
    g_hMapHtmPerfCtl = NULL;
}

void
CreatePerfCtl(DWORD dwFlags, void * pvHost)
{
    char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
    wsprintfA(achName, "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

    if (g_hMapHtmPerfCtl == NULL)
        g_hMapHtmPerfCtl = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, achName);
    if (g_hMapHtmPerfCtl == NULL)
    {
        TraceTag((tagError, "CreateFileMappingA(\"%s\") failed (%ld)", achName, GetLastError()));
        return;
    }
#ifndef UNIX
    if (g_pHtmPerfCtl == NULL)
        g_pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);
#endif
    if (g_pHtmPerfCtl == NULL)
    {
        TraceTag((tagError, "MapViewOfFile() failed (%ld)", GetLastError()));
        return;
    }

    g_pHtmPerfCtl->dwSize  = sizeof(HTMPERFCTL);
    g_pHtmPerfCtl->dwFlags = dwFlags;
    g_pHtmPerfCtl->pfnCall = PadDocCallback;
    g_pHtmPerfCtl->pvHost  = pvHost;
}

void
CPadDoc::PerfCtlCallback(DWORD dwArg1, void * pvArg2)
{
    if (_fDisablePadEvents)
    {
        EndEvents();
    }
    else
    {
        VARIANT var;

        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = dwArg1;
        FireEvent(DISPID_PadEvents_PerfCtl, 1, &var);
    }
}

HRESULT
CPadDoc::SetPerfCtl(DWORD dwFlags)
{
    CreatePerfCtl(dwFlags, this);
    _fDisablePadEvents = !!(dwFlags & HTMPF_DISABLE_PADEVENTS);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ClearDownloadCache, IPad
//
//  Synopsis: Flush WININET disk cache
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ClearDownloadCache()
{
    HANDLE  hEnumCache;
    DWORD   dw;

    struct
    {
        INTERNET_CACHE_ENTRY_INFOA info;
        BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    } info;

    dw = sizeof(info);
    hEnumCache = FindFirstUrlCacheEntryA("*.*", &info.info, &dw);
    if (hEnumCache == 0)
        return S_OK;

    do
    {
        DeleteUrlCacheEntryA(info.info.lpszSourceUrlName);
        dw = sizeof(info);
    } while (FindNextUrlCacheEntryA(hEnumCache, &info.info, &dw));

    FindCloseUrlCache(hEnumCache);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnablePainting, IPad
//
//  Synopsis: Enable painting.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LockWindowUpdate(VARIANT_BOOL fLock)
{
    _fPaintLocked = fLock != 0;

    if (!fLock && _fPaintOnUnlock && _hwnd)
    {
        RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE|RDW_ALLCHILDREN);
    }

    return S_OK;
}

#ifdef NEVER    // (srinib) - commenting this out, since it is not being used
                // causing maintenance problems and also forces text.lib to be linked
                // to pad.
extern HRESULT Lines(IDispatch * pObject, long *pl);
extern HRESULT Line(IDispatch * pObject, long l, IDispatch **ppLine, CPadDoc * pPadDoc);
extern HRESULT Cascaded(IDispatch * pObject, IDispatch **ppCascaded, CPadDoc * pPadDoc);
#endif

HRESULT CPadDoc::get_Lines(IDispatch * pObject, long *pl)
{
    return 0;
#ifdef NEVER
    return ::Lines(pObject, pl);
#endif
}

HRESULT CPadDoc::get_Line(IDispatch * pObject, long l, IDispatch **ppLine)
{
    return 0;
#ifdef NEVER
    return ::Line(pObject, l, ppLine, this);
#endif
}

HRESULT CPadDoc::get_Cascaded(IDispatch * pObject, IDispatch **ppCascaded)
{
    return 0;
#ifdef NEVER
    return ::Cascaded(pObject, ppCascaded, this);
#endif
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnableTraceTag, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::EnableTraceTag(BSTR bstrTag, BOOL fEnable)
{
    if (!bstrTag || !_tcslen(bstrTag))
        return S_FALSE;

    int     tag;
    int     ret;
    char    str[256];

    ret = WideCharToMultiByte(CP_ACP, 0, bstrTag, _tcslen(bstrTag), str, 256, NULL, NULL);
    if (!ret)
        return S_FALSE;

    str[ret] = '\0';

    tag = FindTag (str);
    if (tag)
    {
        EnableTag(tag, fEnable);
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnableSnapToGrid, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::EnableSnapToGrid(BOOL fEnable)
{
    // to snap the point to the grid
    BSTR bstrSnapGrid = SysAllocString(_T("Snap to Grid"));
    EnableTraceTag(bstrSnapGrid, fEnable);

    SysFreeString(bstrSnapGrid);

    return S_OK;
}

HRESULT
CPadDoc::GetRegValue(long hKeyIn, BSTR bstrSubkey, BSTR bstrValueName, VARIANT *pValue)
{
    HKEY hKey = (HKEY)(LONG_PTR)hKeyIn;
    HKEY hOpenedKey = 0;
    HRESULT hr;
    WCHAR buffer[128];                  // Buffer for RegQueryValueEx
    DWORD type;
    DWORD lType = sizeof(buffer);

    // Default key to HKEY_CURRENT_USER
    if (hKey==0)
    {
        hKey = HKEY_CURRENT_USER;
    }

    (*pValue).vt = VT_BSTR;                  // Initialize answer to empty BSTR
    (*pValue).bstrVal = NULL;

    hr = RegOpenKeyEx(hKey, bstrSubkey, 0, KEY_QUERY_VALUE, &hOpenedKey);
    if (hr)
        goto Cleanup;
    hr = RegQueryValueEx(hOpenedKey, bstrValueName, NULL, &type, (UCHAR *)buffer, &lType);
    if (hr)
        goto Cleanup;

    VariantClear(pValue);
    switch (type)
    {
        case REG_SZ:
            (*pValue).bstrVal = SysAllocString(buffer);
            if (!(*pValue).bstrVal)       // Alloc failed?
                goto Cleanup;
            (*pValue).vt = VT_BSTR;
            break;

        case REG_DWORD:
            (*pValue).vt = VT_I4;
            (*pValue).lVal = *(DWORD*)buffer;
            break;

        default:
            hr = E_NOTIMPL;
            goto Cleanup;
    }

Cleanup:
    if (hOpenedKey)
        (void) RegCloseKey(hOpenedKey);
    return S_OK;
}

HRESULT
CPadDoc::DeleteRegValue(long hkeyIn, BSTR bstrSubKey, BSTR bstrValueName)
{
    HKEY hkey = (HKEY)(LONG_PTR)hkeyIn;
    HKEY hOpenedKey;
    HRESULT hr = S_OK;

    // Default key to HKEY_CURRENT_USER
    if (hkey==0)
    {
        hkey = HKEY_CURRENT_USER;
    }

    hr = RegOpenKeyEx(hkey, bstrSubKey, 0, KEY_SET_VALUE, &hOpenedKey);

    if (ERROR_SUCCESS == hr)
    {
        RegDeleteValue(hOpenedKey, bstrValueName);
        (void)RegCloseKey(hOpenedKey);
    }

    return hr;
}

HRESULT
CPadDoc::SetRegValue(long hkeyIn, BSTR bstrSubKey, BSTR bstrValueName, VARIANT value)
{
    HKEY hkey = (HKEY)(LONG_PTR)hkeyIn;
    HKEY hOpenedKey;
    HRESULT hr = S_OK;
    DWORD dwDisposition;

    // Default key to HKEY_CURRENT_USER
    if (hkey==0)
    {
        hkey = HKEY_CURRENT_USER;
    }

    if (!RegCreateKeyEx(hkey, bstrSubKey, 0, 0, 0, KEY_SET_VALUE, 0,
                            &hOpenedKey, &dwDisposition))
    {
        long lval;
        switch V_VT(&value)
        {
        case VT_I4:
            lval = V_I4(&value);

            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_DWORD, (const BYTE *)(&lval), sizeof(DWORD)))
            {
                hr = E_FAIL;
            }
            break;

        case VT_I2:
            lval = V_I2(&value);

            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_DWORD, (const BYTE *)(&lval), sizeof(DWORD)))
            {
              hr = E_FAIL;
            }
            break;

        case VT_BSTR:
            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_SZ, (const BYTE *)(V_BSTR(&value)), SysStringLen(V_BSTR(&value))*2 + 2))
            {
              hr = E_FAIL;
            }
            break;

        default: hr = E_FAIL;
        }

        Verify(!RegCloseKey(hOpenedKey));

        // Cause MSHMTL.DLL to re-read registry settings
        if (_pInPlaceObject)
        {
            HWND hwndDoc;
            _pInPlaceObject->GetWindow(&hwndDoc);
            (void)SendMessage(hwndDoc, WM_WININICHANGE, 0, 0);
        }

    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT
CPadDoc::TrustProvider(BSTR bstrKeyname, BSTR bstrProvidername, VARIANT *pOldKey)
{
    HRESULT hr;
    VARIANT varProvider;

    VariantInit(pOldKey);            // assume there was no previous key

    VariantInit(&varProvider);          // GetRegValue wants a varaint

    // Get old key value
    hr = GetRegValue(0,
                     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                     bstrKeyname,
                     &varProvider);

    // Was there an existing key?
    if (VT_BSTR!=varProvider.vt || NULL==varProvider.bstrVal)
    {
        varProvider.vt = VT_BSTR;
        varProvider.bstrVal = SysAllocString(bstrProvidername);

        // No, then we set one
        hr = SetRegValue(0,
                         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                         bstrKeyname,
                         varProvider);

        // and return a copy of the keyname to indicate we set it
        // (this will be used by RevertTrustProvider to delete it).
        pOldKey->vt = VT_BSTR;
        pOldKey->bstrVal = SysAllocString(bstrKeyname);
    }

    VariantClear(&varProvider);

    return hr;
}

HRESULT
CPadDoc::RevertTrustProvider(BSTR keyname)
{
    HRESULT hr = S_OK;

    if (keyname && *keyname)
    {
        hr = DeleteRegValue(0,
                            _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                            keyname);
    }

    return hr;
}

HRESULT GetPadLineTypeInfo(CPadDoc * pPadDoc, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(pPadDoc->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = pPadDoc->_pTypeInfoILine;

Cleanup:
    RRETURN(hr);
}

HRESULT GetPadCascadedTypeInfo(CPadDoc * pPadDoc, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(pPadDoc->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = pPadDoc->_pTypeInfoICascaded;

Cleanup:
    RRETURN(hr);
}

HRESULT
CPadDoc::ComputeCRC(BSTR bstrText, VARIANT * pCRC)
{
    const TCHAR* pch = bstrText;
    WORD         wHash = 0;

    if (pch)
    {
        for (;*pch; pch++)
        {
            wHash = wHash << 7 ^ wHash >> (16-7) ^ (*pch);
        }
    }

    V_VT(pCRC) = VT_I2;
    V_I2(pCRC) = wHash;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_Dbg, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_Dbg(long *plDbg)
{
#ifdef DBG
    *plDbg = DBG;
#else
    *plDbg = 0;
#endif
    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::get_ProcessorArchitecture, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ProcessorArchitecture(BSTR * pbstrMachineType)
{
    *pbstrMachineType = SysAllocString(ProcessorArchitecture());

    RRETURN(*pbstrMachineType ? S_OK : E_OUTOFMEMORY);
}

TCHAR *
CPadDoc::ProcessorArchitecture()
{
    SYSTEM_INFO si;
    TCHAR *     pch;

    GetSystemInfo(&si);

    switch (si.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        pch = _T("x86");
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        pch = _T("amd64");
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        pch = _T("ia64");
        break;
    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        pch = _T("Unknown");
        break;
    }

    return pch;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CoMemoryTrackDisable, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CoMemoryTrackDisable(VARIANT_BOOL fDisable)
{
    DbgCoMemoryTrackDisable(fDisable);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_UseShdocvw, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_UseShdocvw(VARIANT_BOOL *pfHosted)
{
    *pfHosted = !!_fUseShdocvw;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_UseShdocvw, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_UseShdocvw(VARIANT_BOOL fHosted)
{
    _fUseShdocvw = fHosted;
    SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, (LPARAM)MAKELONG(_fUseShdocvw, 0));
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_DownloadNotifyMask, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_DownloadNotifyMask(ULONG *pulMask)
{
    *pulMask = _ulDownloadNotifyMask;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_DownloadNotifyMask, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_DownloadNotifyMask(ULONG ulMask)
{
    _ulDownloadNotifyMask = ulMask;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GoBack, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GoBack(VARIANT_BOOL *pfWentBack)
{
    HRESULT hr;
    *pfWentBack = FALSE;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->GoBack());
        *pfWentBack = (hr == S_OK);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GoForward, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GoForward(VARIANT_BOOL *pfWentForward)
{
    HRESULT hr;
    *pfWentForward = FALSE;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->GoForward());
        *pfWentForward = (hr == S_OK);
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::TestExternal, IPad
//
//---------------------------------------------------------------------------

typedef HRESULT (TestExternal_Func)(VARIANT *pParam, long *plRetVal);

HRESULT
CPadDoc::TestExternal(
    BSTR bstrDLLName,
    BSTR bstrFunctionName,
    VARIANT *pParam,
    long *plRetVal)
{
    HRESULT hr = S_OK;
    HINSTANCE hInstDLL = NULL;
    TestExternal_Func *pfn = NULL;

    if (!plRetVal || !bstrDLLName || !bstrFunctionName)
        return E_POINTER;

    *plRetVal = -1;

    int cchLen = SysStringLen(bstrDLLName);
    char * pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrDLLName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        hInstDLL = LoadLibraryA(pchBuf);

        delete pchBuf;
    }

    if (NULL == hInstDLL)
    {
        TraceTagEx((tagScriptLog, TAG_NONAME, "TestExternal can't load external dll"));
        return S_FALSE;     // Can't return error codes or the script will abort
    }

    cchLen = SysStringLen(bstrFunctionName);
    pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrFunctionName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        pfn = (TestExternal_Func *)GetProcAddress(hInstDLL, pchBuf);

        delete pchBuf;
    }

    if (NULL == pfn)
    {
        TraceTagEx((tagScriptLog, TAG_NONAME, "TestExternal can't find external function"));
        hr = S_FALSE;
    }
    else
    {
        *plRetVal = 0;
        hr = (*pfn)(pParam, plRetVal);
    }

    FreeLibrary(hInstDLL);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::UnLoadDLL, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::UnLoadDLL()
{
    HRESULT hr;

    hr = THR(CloseFile());
    if (hr)
        goto Cleanup;

    UnregisterLocalCLSIDs();
    CoFreeUnusedLibraries();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DeinitDynamicLibrary, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DeinitDynamicLibrary(BSTR bstrDLLName)
{
    static DYNPROC s_dynprocDeinitDynamicLibrary = { NULL, &g_dynlibMSHTML, "DeinitDynamicLibrary" };

    if (    s_dynprocDeinitDynamicLibrary.pfn != NULL
        ||  LoadProcedure(&s_dynprocDeinitDynamicLibrary) == S_OK)
    {
        ((void (STDAPICALLTYPE *)(LPCTSTR))s_dynprocDeinitDynamicLibrary.pfn)(bstrDLLName);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IsDynamicLibraryLoaded, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IsDynamicLibraryLoaded(BSTR bstrDLLName, VARIANT_BOOL *pfLoaded)
{
    static DYNPROC s_dynprocIsDynamicLibraryLoaded = { NULL, &g_dynlibMSHTML, "IsDynamicLibraryLoaded" };
    if (    s_dynprocIsDynamicLibraryLoaded.pfn != NULL
        ||  LoadProcedure(&s_dynprocIsDynamicLibraryLoaded) == S_OK)
    {
        *pfLoaded = ((BOOL (STDAPICALLTYPE *)(LPCTSTR))s_dynprocIsDynamicLibraryLoaded.pfn)(bstrDLLName) ?
            VB_TRUE : VB_FALSE;
    }

    return S_OK;
}

HRESULT CPadDoc::get_ViewChangesFired(long *plCount)
{
    *plCount = _lViewChangesFired;
    _lViewChangesFired = 0; // reset count
    return S_OK;
}

HRESULT CPadDoc::get_DataChangesFired(long *plCount)
{
    *plCount = _lDataChangesFired;
    _lDataChangesFired = 0; // reset count
    return S_OK;
}



class CPadServerOM : public IDispatch
{
public:
    CPadServerOM(DWORD dwUA, TCHAR *pchUA, TCHAR *pchFile, TCHAR *pchQS);

    DECLARE_FORMS_STANDARD_IUNKNOWN(CPadServerOM)
    STDMETHOD(GetTypeInfo)(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
        { return E_NOTIMPL; }
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo)
        { return E_NOTIMPL; }
    STDMETHOD(GetIDsOfNames)(REFIID riid,
                             LPOLESTR * rgszNames,
                             UINT cNames,
                             LCID lcid,
                             DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr);

    //
    // Data
    //

    CStr    _cstrUA;
    CStr    _cstrFile;
    CStr    _cstrQS;
    DWORD   _dwUA;
};


CPadServerOM::CPadServerOM(DWORD dwUA, TCHAR *pchUA, TCHAR *pchFile, TCHAR *pchQS)
{
    _dwUA = dwUA;
    _cstrUA.Set(pchUA);
    _cstrFile.Set(pchFile);
    _cstrQS.Set(pchQS);
    _ulRefs = 0;
}


HRESULT
CPadServerOM::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDispatch)
    {
        *ppv = (IDispatch *)this;
        AddRef();
        return S_OK;
    }

    return E_NOTIMPL;
}


HRESULT
CPadServerOM::GetIDsOfNames(
    REFIID riid,
    LPOLESTR * rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID * rgdispid)
{
    DISPID  dispid = DISPID_UNKNOWN;

    if (_tcsequal(*rgszNames, _T("UserAgent")))
    {
        dispid = 1;
    }
    else if (_tcsequal(*rgszNames, _T("NormalizedUA")))
    {
        dispid = 2;
    }
    else if (_tcsequal(*rgszNames, _T("URL")))
    {
        dispid = 3;
    }
    else if (_tcsequal(*rgszNames, _T("Path")))
    {
        dispid = 4;
    }
    else if (_tcsequal(*rgszNames, _T("QueryString")))
    {
        dispid = 5;
    }

    *rgdispid = dispid;
    return dispid == DISPID_UNKNOWN ? DISP_E_UNKNOWNNAME : S_OK;
}


HRESULT
CPadServerOM::Invoke(
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS * pdispparams,
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo,
    UINT * puArgErr)
{
    if (!pvarResult)
        return S_OK;

    switch (dispidMember)
    {
    case 1:
        V_VT(pvarResult) = VT_BSTR;
        _cstrUA.AllocBSTR(&V_BSTR(pvarResult));
        break;

    case 2:
        V_VT(pvarResult) = VT_I4;
        V_I4(pvarResult) = _dwUA;
        break;

    case 3:
    case 4:
        V_VT(pvarResult) = VT_BSTR;
        _cstrFile.AllocBSTR(&V_BSTR(pvarResult));
        break;

    case 5:
        if (_cstrQS)
        {
            V_VT(pvarResult) = VT_BSTR;
            _cstrQS.AllocBSTR(&V_BSTR(pvarResult));
        }
        else
        {
            V_VT(pvarResult) = VT_NULL;
        }
        break;

    default:
        return DISP_E_MEMBERNOTFOUND;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Sleep, per IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::Sleep (int nTimeout)
{
    ::Sleep (nTimeout);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IsWin95, per IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IsWin95(long * pfWin95)
{
    OSVERSIONINFOA ovi;

    if (!pfWin95)
        return E_POINTER;

    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&ovi);

    *pfWin95 = (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetAccWindow, per IPad
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccWindow( IDispatch ** ppAccWindow )
{
    HWND                hwnd = NULL;
    HRESULT             hr = S_OK;
    HINSTANCE           hInstOleacc = 0;
    IDispatch *         pHTMLDoc = NULL;
    IServiceProvider *  pServProv = NULL;

    if ( !ppAccWindow )
        return E_POINTER;

    *ppAccWindow = NULL;

    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    hInstOleacc = LoadLibraryA( "OLEACC.DLL" );

    if ( hwnd && hInstOleacc )
    {
        // get the document
        hr = get_Document( &pHTMLDoc );
        if ( hr || !pHTMLDoc )
            goto Cleanup;

        // get the service provider interface
        hr = pHTMLDoc->QueryInterface( IID_IServiceProvider, (void **)&pServProv);
        if ( hr || !pServProv )
            goto Cleanup;


        // get the IAccessible interface
        hr = pServProv->QueryService( IID_IAccessible, IID_IAccessible, (void **)ppAccWindow);
        if ( hr || !ppAccWindow )
            goto Cleanup;

    }


//FerhanE:
//  Even if we can not find the OLEACC.DLL, return NULL as the out value and a success code.
//  This way, the script can skip over the code that requires this information.

Cleanup:
    if ( hInstOleacc)
        FreeLibrary( hInstOleacc );

    if ( pHTMLDoc )
        pHTMLDoc->Release();

    if ( pServProv )
        pServProv->Release();

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetAccObjAtPoint, per IPad
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccObjAtPoint( long x, long y, IDispatch ** ppAccObject )
{
    HRESULT         hr = S_OK;
    IAccessible *   pAcc = NULL;
    VARIANT         varChild;
    HWND            hwnd = NULL;
    RECT            rectPos;

    // check the parameters.
    if ( !ppAccObject )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset the return value.
    *ppAccObject = NULL;

    // get the window object for this
    hr = GetAccWindow((IDispatch **)&pAcc);
    if(hr)
        goto Cleanup;

    // get the window handle, so we can get the coordinates for
    // the window that contains us.
    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    ::GetWindowRect( hwnd, &rectPos );

    while (pAcc)
    {
        V_VT(&varChild) = VT_EMPTY;
        V_I4(&varChild) = 0;

        // get the object at the location given relative to
        // the top left of the Trident window
        hr = pAcc->accHitTest(rectPos.left+x, rectPos.top+y, &varChild);
        if (hr)
            goto Cleanup;

        if (V_VT(&varChild) == VT_I4)
        {
            // either the object itself, or a text child of that object
            // has been hit. Return the object's pointer.

            // This pointer is already addref'ed we don't have to addref again.
            *ppAccObject = pAcc;

            // clean the pointer variable to get out of the loop and return.
            pAcc = NULL;
        }
        else
        {
            // Release the object we have in hand, make the accessible
            // child that contains the hit the current accessible object.
            ReleaseInterface(pAcc);

            Assert(V_DISPATCH(&varChild));

            // no need to addref since it is already addref'ed for us.
            // we won't use it here, pass it out as it is.
            pAcc = (IAccessible *)V_DISPATCH(&varChild);
        }
    }

Cleanup:
    if (hr)
        ReleaseInterface(pAcc);

    return hr;
}


//----------------------------------------------------------------------------
//
//  Returns the child id of the text child that this object contains,
//  If the object itself received the hit but no child ( body with no text or
//  an empty area of the page) , it returns 0 (CHILDID_SELF) = *plChildId
//
//  If the child that is hit is actually another object, then it returns -1 = *plChildId
//  If the object that is hit is not this object, then it returns -1 = *plChildId.
//
//  This function is supposed to be used after getting the object that is hit using
//  the GetAccObjAtPoint function. This function will be only useful when the child
//  that is hit is a text child of a certain object.
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccChildIdAtPoint( IDispatch * pAccObj, long x, long y, long * plChildId )
{
    HRESULT     hr = S_OK;
    RECT        rectPos;
    HWND        hwnd = NULL;
    VARIANT     varChild;

    if (!plChildId)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plChildId = -1;        // prepare for the worst case.

    // adjust the coordinates to screen coordinates.
    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    ::GetWindowRect( hwnd, &rectPos);

    // we have the accessible object, we can make the hittest call.
    //
    // casting here, since we are sure that this is an accessible pointer.
    // if this was mshtml.code, we would QI.
    hr = ((IAccessible *)pAccObj)->accHitTest(rectPos.left+x, rectPos.top+y, &varChild);
    if (hr)
        goto Cleanup;

    if (V_VT(&varChild) == VT_I4)
    {
        // set the return value.
        *plChildId = V_I4(&varChild);
    }
    else
    {
        // else just return with the return code we already have.
        // since it means that we hit another child object, or the object we have
        // did not get hit.

        // release the object we received not to leak it.
        if (V_VT(&varChild) == VT_DISPATCH)
            V_DISPATCH(&varChild)->Release();
    }


Cleanup:
    return hr;
}


//----------------------------------------------------------------------------
//
//  Callback function: FindTridentWindow()
//                     This callback function is used by FindMshtmlWindow() to
//                     find a child window whose class matches MSHTML_WINDOW_CLASSNAME
//
//----------------------------------------------------------------------------
static BOOL CALLBACK
FindTridentWindow ( HWND hwnd, LPARAM lparam)
{
    TCHAR pch[ 80 ];

    hwndInternetExplorerServer = 0;

    if ( ! GetClassName( hwnd, pch, 80 ) )
        goto Cleanup;

    if (! StrCmpC( MSHTML_WINDOW_CLASSNAME, pch ) )
    {
        hwndInternetExplorerServer = hwnd;
        return FALSE;
    }

Cleanup:
    return TRUE;
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::FindMshtmlWindow()
//          Finds the window that hosts Trident given the class name of an application
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::FindMshtmlWindow ( BSTR bstrClassName, long * plhwnd )
{
    HWND    hwndHostApplication;

    *plhwnd = 0;

    hwndHostApplication = FindWindow( bstrClassName, NULL );
    if (! hwndHostApplication)
        goto Cleanup;

    EnumChildWindows( hwndHostApplication, FindTridentWindow, 0 );

    *plhwnd = HandleToLong( hwndInternetExplorerServer );

Cleanup:
    return( *plhwnd ? S_OK : E_FAIL );
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMshtmlDoc()
//          Uses active accessibility to fetch IHTMLDocument2 given a window handle
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::GetMshtmlDoc ( long lhwnd, IDispatch ** ppdispDocument )
{
    UINT        msgHtmlGetobject;
    LRESULT     lr;
    HRESULT     hr;
    HWND        hwndToUse = (HWND)(LongToPtr(lhwnd));

    static DYNPROC s_dynprocObjectFromLresult =
            { NULL, &g_dynlibOLEACC, "ObjectFromLresult" };

    *ppdispDocument = NULL;

    // Check the argument sanity
    if (! IsWindow( hwndToUse ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Register and send the getobject message
    msgHtmlGetobject = RegisterWindowMessage( MSGNAME_WM_HTML_GETOBJECT );
    if (! msgHtmlGetobject)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lr = SendMessage( hwndToUse, msgHtmlGetobject, 0, 0);
    if (! lr)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Load ObjectFromLresult() from OLEACC.DLL and call it
    hr = THR( LoadProcedure( & s_dynprocObjectFromLresult ) );
    if (hr)
    {
        goto Cleanup;
    }

    hr = (*(HRESULT (APIENTRY *)(LRESULT, REFIID, WPARAM, void**) )
            s_dynprocObjectFromLresult.pfn)(lr,
                                            IID_IDispatch,
                                            0,
                                            (void **) ppdispDocument);

Cleanup:
    return hr;
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::SetActiveWindow()
//          After this function is called, mouse and keyboard actions are directed
//          to g_hwndActiveWindow rather than the pad.
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::SetActiveWindow (long lhwnd)
{
    HRESULT hr = S_OK;
    HWND    hwnd = (HWND)(LongToPtr(lhwnd));

    if (! IsWindow( hwnd ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    g_hwndActiveWindow = hwnd;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member : SetKeyboard
//
//  Synopsis: Change the keyboard layout for IME testing.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetKeyboard( BSTR bstrKeyboard)
{
    int     nIndex = -1;
    int     nSystem;
    HKL     hkblyt;
    char    *pBuf = NULL;
    char    szBufA[KL_NAMELENGTH];

    //
    // Initialize the system index.  This is used to index the array of keyboard layouts
    // which indicates how to load the IME.  This differs for the GIMEs shipped with
    // non-native systems and NT 5.0.  See the comment for astrKeyboardLayouts at the
    // top of this file
    //
    nSystem = ( g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000 ) ? 1 : 0;

    if (bstrKeyboard)
    {
        if( StrCmpIC( bstrKeyboard, _T("jpn") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_JPN;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("kor") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_KOR;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("cht") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_CHT;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("chs") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_CHS;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else
        {
            WideCharToMultiByte(CP_ACP, 0,
                                bstrKeyboard, SysStringLen(bstrKeyboard),
                                szBufA, sizeof(szBufA), NULL, NULL);
            szBufA[KL_NAMELENGTH-1] = (char)0;
            pBuf = szBufA;
        }

        //
        // Load the keyboard layout
        //
        hkblyt = LoadKeyboardLayoutA( pBuf, 0);
        if (hkblyt)
        {
            HKL     hkblytPrev;
            hkblytPrev = ActivateKeyboardLayout(hkblyt, KLF_SETFORPROCESS);
            if (hkblytPrev)
            {
                return S_OK;
            }
            else
                UnloadKeyboardLayout(hkblyt);
        }
    }

    return E_POINTER;
}

//---------------------------------------------------------------------------
//
//  Member : GetKeyboard
//
//  Synopsis: Change the keyboard layout for IME testing.
//
//---------------------------------------------------------------------------

HRESULT
   CPadDoc::GetKeyboard( VARIANT *pKeyboard)
{
    if (pKeyboard)
    {
        char szBufA[KL_NAMELENGTH];
        if (GetKeyboardLayoutNameA(szBufA))
        {
            TCHAR szBufW[KL_NAMELENGTH];
            MultiByteToWideChar(CP_ACP, 0, szBufA, sizeof(szBufA),
                                szBufW, sizeof(szBufW)/sizeof(TCHAR));
            szBufW[KL_NAMELENGTH-1] = (char)0;
            V_VT(pKeyboard) = VT_BSTR;
            V_BSTR(pKeyboard) = SysAllocString(szBufW);
            if (V_BSTR(pKeyboard))
                return (S_OK);
        }
    }

    return E_POINTER;
}
//---------------------------------------------------------------------------
//
//  Member : ToggleIMEMode
//
//  Synopsis: Change the IME mode.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ToggleIMEMode( BSTR bstrIME)
{
    HRESULT             hr = S_OK;
    IDispatch           *pHTMLDoc = NULL;
    IIMEServices        *pIMEServices = NULL;
    IActiveIMMApp       *pIMEApp = NULL;
    DWORD               dwConversion;
    DWORD               dwSentence;
    HIMC                hIMC = NULL;
    HWND                hWnd;
    IOleWindow          *pIOleWindow = NULL;
    BOOL                fSuccess;

    //
    // Get the IActiveIMMApp interface pointer
    //
    IFC( get_Document( &pHTMLDoc ) );
    IFC( pHTMLDoc->QueryInterface(IID_IOleWindow, (void **)&pIOleWindow));
    IFC( pIOleWindow->GetWindow( &hWnd ) );

    IFC( pHTMLDoc->QueryInterface( IID_IIMEServices, (void **)&pIMEServices ) );
    IFC( pIMEServices->GetActiveIMM(&pIMEApp) );

    //
    // If we have an IActiveIMMApp pointer, use that to change
    // the IME properties, otherwise, just use plain IMM32 calls.
    if( pIMEApp )
    {
        IFC( pIMEApp->GetContext( hWnd, &hIMC ) );
    }
    else
    {
        hIMC = ImmGetContext( hWnd );
        if( !hIMC )
            goto Cleanup;
    }

    if( pIMEApp )
    {
        IFC( pIMEApp->GetConversionStatus( hIMC, &dwConversion, &dwSentence ) );
    }
    else
    {
        if( !ImmGetConversionStatus( hIMC, &dwConversion, &dwSentence ) )
            goto Cleanup;
    }

    dwConversion &= ~IME_CMODE_NOCONVERSION;
    dwConversion &= ~IME_CMODE_SYMBOL;

    if( StrCmpIC(bstrIME, _T("KOR") ) == 0 )
        dwConversion |= IME_CMODE_NATIVE;


    if( pIMEApp )
    {
        IFC( pIMEApp->SetConversionStatus( hIMC, dwConversion, dwSentence ) );
    }
    else
    {
        if( !ImmSetConversionStatus( hIMC, dwConversion, dwSentence ) )
            goto Cleanup;
    }

    if (StrCmpIC(bstrIME, _T("JPN")) == 0)
    {
        if( pIMEApp )
        {
            IFC( pIMEApp->SetOpenStatus( hIMC, TRUE ) );
        }
        else
        {
            if( !ImmSetOpenStatus( hIMC, TRUE ) )
                goto Cleanup;
        }
    }


Cleanup:

    ReleaseInterface( pIOleWindow );
    ReleaseInterface( pIMEServices );
    ReleaseInterface( pIMEApp );
    ReleaseInterface( pHTMLDoc );

    RRETURN(hr);
}
//---------------------------------------------------------------------------
//
//  Member : SendIMEKeys
//
//  Synopsis: Send keyboard events from the given string
//            so that the IME will be able to trap them.
//
//---------------------------------------------------------------------------

// For just one key at a time.
TCHAR *
   CPadDoc::SendIMEKey(TCHAR *pch, DWORD dwFlags)
{
    BYTE ch;
    switch (*pch)
    {
        default:
            ch = (BYTE)*pch;
            if (ch >= 'a' && ch <= 'z')
                ch -= 'a' - 'A';
            keybd_event(ch, (BYTE)MapVirtualKey(ch, 0), 0, 0);
            keybd_event(ch, (BYTE)MapVirtualKey(ch, 0), KEYEVENTF_KEYUP, 0);
            pch++;
            break;

        case _T('+'):
            keybd_event(VK_SHIFT, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags);
            keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('^'):
            keybd_event(VK_CONTROL, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags);
            keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('%'):
            keybd_event(VK_MENU, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags | (KF_ALTDOWN << 16));
            keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('{'):
            pch++;
            pch = SendIMESpecial(pch, 0);
            break;
    }
    return pch;
}
HRESULT
   CPadDoc::SendIMEKeys( BSTR bstrKeys )
{
    if (bstrKeys)
    {
        TCHAR *pch = bstrKeys;

        // Put in all the keystrokes.
        while (*pch != 0)
        {
            pch = SendIMEKey(pch, 0);
        }
        return (S_OK);
    }

    return E_POINTER;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::RemoveElement
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::RemoveElement ( IDispatch * pIDispatch )
{
    HRESULT            hr = S_OK;
    IDispatch *        pDocDisp = NULL;
    IMarkupServices *  pMarkupServices = NULL;
    IHTMLElement *     pIElement = NULL;

    if (!pIDispatch)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( pIDispatch->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );

    if (hr)
        goto Cleanup;

    hr = THR( get_Document( & pDocDisp ) );

    if (hr)
        goto Cleanup;

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupServices, (void **) & pMarkupServices ) );

    if (hr)
        goto Cleanup;

    hr = THR( pMarkupServices->RemoveElement( pIElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (pDocDisp)
        pDocDisp->Release();

    if (pIElement)
        pIElement->Release();

    if (pMarkupServices)
        pMarkupServices->Release();

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::Markup
//
//----------------------------------------------------------------------------

static IMarkupServices *  g_MS = NULL;
static IMarkupContainer * g_PM = NULL;

static HRESULT
FindElementByTagId ( ELEMENT_TAG_ID tagIdFindThis, IHTMLElement * * ppIElement )
{
    HRESULT          hr = S_OK;
    IMarkupPointer * pIPointer = NULL;

    Assert( ppIElement );

    *ppIElement = NULL;

    hr = THR( g_MS->CreateMarkupPointer( & pIPointer ) );

    if (hr)
        goto Cleanup;

    hr = THR( pIPointer->MoveToContainer( g_PM, TRUE ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;

        hr = THR( pIPointer->Right( TRUE, & ct, ppIElement, NULL, NULL ) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            ELEMENT_TAG_ID tagId;

            hr = THR( g_MS->GetElementTagId( *ppIElement, & tagId ) );

            if (hr)
                goto Cleanup;

            if (tagId == tagIdFindThis)
                break;

        }
        if (*ppIElement)
            (*ppIElement)->Release();
    }

Cleanup:

    if (pIPointer)
        pIPointer->Release();

    RRETURN( hr );
}

static HRESULT
MangleRemoveBody ( )
{
    HRESULT        hr = S_OK;
    IHTMLElement * pIElement = NULL;

    hr = THR( FindElementByTagId( TAGID_BODY, & pIElement ) );

    if (hr)
        goto Cleanup;

    if (!pIElement)
        goto Cleanup;

    hr = THR( g_MS->RemoveElement( pIElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (pIElement)
        pIElement->Release();

    RRETURN( hr );
}

static HRESULT
MangleRemoveTables ( )
{
    HRESULT        hr = S_OK;
    IHTMLElement * pIElement = NULL;

    for ( ; ; )
    {
        hr = THR( FindElementByTagId( TAGID_TABLE, & pIElement ) );

        if (hr)
            goto Cleanup;

        if (!pIElement)
            goto Cleanup;

        hr = THR( g_MS->RemoveElement( pIElement ) );

        if (hr)
            goto Cleanup;

        pIElement->Release();
        pIElement = NULL;
    }

Cleanup:

    if (pIElement)
        pIElement->Release();

    RRETURN( hr );
}

IMarkupPointer *
CPadDoc::FindPadPointer ( long id )
{
    for ( int i = 0 ; i < _aryPadPointers.Size() ; i++ )
        if (_aryPadPointers[i]._id == id)
            return _aryPadPointers[i]._pPointer;

    return NULL;
}

IMarkupPointer *
CPadDoc::FindPadPointer ( VARIANT * pvar )
{
    if (!pvar || V_VT( pvar ) != VT_I4)
        return NULL;

    return FindPadPointer( V_I4( pvar ) );
}

IMarkupContainer *
CPadDoc::FindPadContainer ( long id )
{
    for ( int i = 0 ; i < _aryPadContainers.Size() ; i++ )
        if (_aryPadContainers[i]._id == id)
            return _aryPadContainers[i]._pContainer;

    return NULL;
}

IMarkupContainer *
CPadDoc::FindPadContainer ( VARIANT * pvar )
{
    if (!pvar || V_VT( pvar ) != VT_I4)
        return NULL;

    return FindPadContainer( V_I4( pvar ) );
}

IHTMLElement *
CPadDoc::GetElement ( VARIANT * pvar )
{
    IHTMLElement * pIElement;

    if (!pvar || V_VT( pvar ) != VT_DISPATCH || !V_DISPATCH( pvar ))
        return NULL;

    if (V_DISPATCH( pvar )->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) != S_OK)
        return NULL;

    return pIElement;
}

HRESULT
CPadDoc::Markup (
    VARIANT * pvarParam1, VARIANT * pvarParam2, VARIANT * pvarParam3,
    VARIANT * pvarParam4, VARIANT * pvarParam5, VARIANT * pvarParam6,
    VARIANT * pvarRet )
{
    HRESULT            hr = S_OK;
    IDispatch *        pDocDisp = NULL;
    IHTMLElement *     pIElement = NULL;

    VariantClear( pvarRet );

    hr = THR( get_Document( & pDocDisp ) );

    if (hr)
        goto Cleanup;

    Assert( ! g_MS && ! g_PM );

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupServices, (void **) & g_MS ) );

    if (hr)
        goto Cleanup;

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupContainer, (void **) & g_PM ) );

    if (hr)
        goto Cleanup;

    if (!pvarParam1 || V_VT( pvarParam1 ) != VT_BSTR)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveElement" )))  // element
    {
        if (!pvarParam2)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIElement = GetElement( pvarParam2 );

        if (pIElement)
        {
            hr = THR( RemoveElement( V_DISPATCH( pvarParam2 ) ) );

            if (hr)
                goto Cleanup;
        }
        else if (V_VT( pvarParam2 ) == VT_BSTR)
        {
            ELEMENT_TAG_ID tagId;
            IHTMLElement * pIElement = NULL;

            hr = THR( g_MS->GetTagIDForName ( V_BSTR( pvarParam2 ), & tagId ) );

            if (hr)
                goto Cleanup;

            hr = THR( FindElementByTagId( tagId, & pIElement ) );

            if (hr)
                goto Cleanup;

            if (pIElement)
            {
                hr = THR( RemoveElement( pIElement ) );

                if (hr)
                    goto Cleanup;

                pIElement->Release();
            }

        }
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "TagIdToString" )))  // str/element
    {
        if (!pvarParam2 || V_VT( pvarParam2 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->GetNameForTagID( ELEMENT_TAG_ID( V_I4( pvarParam2 ) ), & V_BSTR( pvarRet ) ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "GetTagId" )))  // str/element
    {
        IHTMLElement * pElement = NULL;
        ELEMENT_TAG_ID tagID = TAGID_NULL;

        if (!pvarParam2)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIElement = GetElement( pvarParam2 );

        if (pIElement)
        {
            hr = THR( g_MS->GetElementTagId( pElement, & tagID ) );

            if (hr)
                goto Cleanup;
        }
        else if (V_VT( pvarParam2 ) == VT_BSTR)
        {
            hr = THR( g_MS->GetTagIDForName ( V_BSTR( pvarParam2 ), & tagID ) );

            if (hr)
                goto Cleanup;
        }

        pvarRet->vt = VT_I4;
        pvarRet->lVal = tagID;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "InsertElement" )))  // pStart, pFin, element
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );

        pIElement = GetElement( pvarParam4 );

        if (!pIPointerStart || !pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->InsertElement( pIElement, pIPointerStart, pIPointerFinish ) );
        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Remove" )))  // pStart, pFin
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );

        if (!pIPointerStart || !pIPointerFinish)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Remove( pIPointerStart, pIPointerFinish ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Move" )))  // pStart, pFin, pTarget
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );
        IMarkupPointer * pIPointerTarget = FindPadPointer( pvarParam4 );

        if (!pIPointerStart || !pIPointerFinish || !pIPointerTarget)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Move( pIPointerStart, pIPointerFinish, pIPointerTarget ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Copy" )))  // pStart, pFin, pTarget
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );
        IMarkupPointer * pIPointerTarget = FindPadPointer( pvarParam4 );

        if (!pIPointerStart || !pIPointerFinish || !pIPointerTarget)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Copy( pIPointerStart, pIPointerFinish, pIPointerTarget ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "FindText" )))  // start, text, end match, end search
    {
        IMarkupPointer * pIPointerStartSearch = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerEndMatch = FindPadPointer( pvarParam4 );
        IMarkupPointer * pIPointerEndSearch = FindPadPointer( pvarParam5 );

        if (!pIPointerStartSearch || !pIPointerStartSearch || !pIPointerEndSearch)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pIPointerStartSearch->FindText( V_BSTR( pvarParam3 ), 0, pIPointerEndMatch, pIPointerEndSearch );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = hr = S_FALSE ? 0 : 1;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "InsertText" )))  // pointer, text
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer || !pvarParam3|| V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            g_MS->InsertText(
                V_BSTR( pvarParam3 ),
                FormsStringLen( V_BSTR( pvarParam3 ) ),
                pIPointer ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveBody" )))  // no args
    {
        hr = THR( MangleRemoveBody() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveTables" )))   // no args
    {
        hr = THR( MangleRemoveTables() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "DumpTree" )))  // pointer [optional]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IEditDebugServices * pEditDebug;

        hr = THR( pDocDisp->QueryInterface( IID_IEditDebugServices, (void **) & pEditDebug ) );

        if (hr)
            goto Cleanup;

        pEditDebug->DumpTree( pIPointer );

        pEditDebug->Release();
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateElement" ))) // tag id, attribute string, ret element
    {
        hr = THR( g_MS->CreateElement((ELEMENT_TAG_ID)V_I4(pvarParam2), V_BSTR(pvarParam3), &pIElement) );
        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;
        pvarRet->pdispVal = pIElement;

        pIElement = NULL;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CloneElement" )))  // in element, ret clone
    {
        IHTMLElement * pIElementClone;

        pIElement = GetElement( pvarParam2 );

        if (!pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->CloneElement( pIElement, & pIElementClone ) );
        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;
        pvarRet->pdispVal = pIElementClone;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateMarkupPointer" )))  // return pointer
    {
        IMarkupPointer * pIPointer;
        PadPointerData   padPointer;

        hr = THR( g_MS->CreateMarkupPointer( & pIPointer ) );

        if (hr)
            goto Cleanup;

        padPointer._pPointer = pIPointer;
        padPointer._id = _idPadIDNext++;

        _aryPadPointers.AppendIndirect( & padPointer, NULL );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = padPointer._id;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateMarkupContainer" )))  // return pointer
    {
        IMarkupContainer * pIContainer;
        PadContainerData   padContainer;

        hr = THR( g_MS->CreateMarkupContainer( & pIContainer ) );

        if (hr)
            goto Cleanup;

        padContainer._pContainer = pIContainer;
        padContainer._id = _idPadIDNext++;

        _aryPadContainers.AppendIndirect( & padContainer, NULL );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = padContainer._id;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ReleasePointer" )))  // pointer
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIPointer->Release();

        for ( int i = 0 ; i < _aryPadPointers.Size() ; i++ )
            if (_aryPadPointers[i]._id == V_I4( pvarParam2 ))
                _aryPadPointers.Delete( i );
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ReleaseContainer" )))  // pointer
    {
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam2 );

        if (!pIContainer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIContainer->Release();

        for ( int i = 0 ; i < _aryPadContainers.Size() ; i++ )
            if (_aryPadContainers[i]._id == V_I4( pvarParam2 ))
                _aryPadContainers.Delete( i );
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "SetGravity" )))  // pStrGravity (left|right)
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        POINTER_GRAVITY  eGravity;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            eGravity = POINTER_GRAVITY_Left;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            eGravity = POINTER_GRAVITY_Right;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->SetGravity( eGravity ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "SetCling" )))  // bool
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BOOL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->SetCling( V_BOOL( pvarParam3 ) ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Unposition" )))  // no args
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->Unposition() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToPointer" )))  // p1, p2
    {
        IMarkupPointer * pIPointerMoveMe = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerToHere = FindPadPointer( pvarParam3 );

        if (!pIPointerMoveMe || !pIPointerToHere)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointerMoveMe->MoveToPointer( pIPointerToHere ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToBeginning" )))  // pointer, container [ optional ]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam3 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveToContainer( pIContainer ? pIContainer : g_PM, TRUE ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToEnd" )))  // pointer, container [ optional ]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam3 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveToContainer( pIContainer ? pIContainer : g_PM, FALSE ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MovePointer" )))  // pointer, dir, cchMax, ret actual cch
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        long             cch;
        BOOL             fLeft;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) == VT_ERROR)
            cch = -1;
        else if (V_VT( pvarParam4 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        else
            cch = V_I4( pvarParam4 );

        if (fLeft)
            hr = THR( pIPointer->Left( TRUE, NULL, NULL, & cch, NULL ) );
        else
            hr = THR( pIPointer->Right( TRUE, NULL, NULL, & cch, NULL ) );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = cch;

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Context" )))  // pointer, dir, ret context (bstr)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, NULL, NULL, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;

        switch ( ct )
        {
        case CONTEXT_TYPE_None        : hr = THR( FormsAllocStringW( _T( "None" ),       & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_EnterScope  : hr = THR( FormsAllocStringW( _T( "EnterScope" ), & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_ExitScope   : hr = THR( FormsAllocStringW( _T( "ExitScope" ),  & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_NoScope     : hr = THR( FormsAllocStringW( _T( "NoScope" ),    & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_Text        : hr = THR( FormsAllocStringW( _T( "Text" ),       & pvarRet->bstrVal ) ); break;
        }

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ContextElement" )))  // pointer, dir, ret context (elem)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;
        IHTMLElement *      pIElement = NULL;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, & pIElement, NULL, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, & pIElement, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;

        if (ct == CONTEXT_TYPE_EnterScope || ct == CONTEXT_TYPE_ExitScope || ct == CONTEXT_TYPE_NoScope)
        {
            hr = THR( pIElement->QueryInterface( IID_IDispatch, (void **) & pvarRet->pdispVal ) );

            if (hr)
                goto Cleanup;
        }
        else
        {
            pvarRet->pdispVal = NULL;
        }

        if (pIElement)
            pIElement->Release();

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ContextText" )))  // pointer, dir, cchMax, ret text (bstr)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;
        long                cch;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) == VT_ERROR)
            cch = -1;
        else if (V_VT( pvarParam4 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        else
            cch = V_I4( pvarParam4 );

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, NULL, & cch, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, NULL, & cch, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;

        if (ct == CONTEXT_TYPE_Text)
        {
            TCHAR * pch = new TCHAR [ cch + 1 ];

            if (!pch)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (fLeft)
                hr = THR( pIPointer->Left( FALSE, NULL, NULL, & cch, pch ) );
            else
                hr = THR( pIPointer->Right( FALSE, NULL, NULL, & cch, pch ) );

            pch[cch] = 0;

            hr = THR( FormsAllocStringW( pch, & pvarRet->bstrVal ) );

            delete pch;
        }
        else
        {
            hr = THR( FormsAllocStringW( _T( "" ), & pvarRet->bstrVal ) );

            if (hr)
                goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveAdjacentToElement" )))  // pointer, element, adj
    {
        IMarkupPointer *  pIPointer = FindPadPointer( pvarParam2 );

        ELEMENT_ADJACENCY eAdj;

        pIElement = GetElement( pvarParam3 );

        if (!pIPointer || !pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "BeforeBegin" )))
            eAdj = ELEM_ADJ_BeforeBegin;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "AfterBegin" )))
            eAdj = ELEM_ADJ_AfterBegin;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "BeforeEnd" )))
            eAdj = ELEM_ADJ_BeforeEnd;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "AfterEnd" )))
            eAdj = ELEM_ADJ_AfterEnd;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveAdjacentToElement( pIElement, eAdj ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Compare" )))  // p1, p2, how, return t/f
    {
        IMarkupPointer *  p1 = FindPadPointer( pvarParam2 );
        IMarkupPointer *  p2 = FindPadPointer( pvarParam3 );
        BOOL              fResult;

        if (!p1 || !p2 || !pvarParam4 || V_VT( pvarParam4 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsEqualTo" )))
            hr = THR( p1->IsEqualTo( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsLeftOf" )))
            hr = THR( p1->IsLeftOf( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsLeftOfOrEqualTo" )))
            hr = THR( p1->IsLeftOfOrEqualTo( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsRightOf" )))
            hr = THR( p1->IsRightOf( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsRightOfOrEqualTo" )))
            hr = THR( p1->IsRightOfOrEqualTo( p2, & fResult ) );
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pvarRet->vt = VT_BOOL;
        pvarRet->boolVal = !!fResult;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "BeginUndoUnit" )))  // undo string
    {
        if (!pvarParam2 || V_VT( pvarParam2 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->BeginUndoUnit( V_BSTR( pvarParam2 ) ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "EndUndoUnit" )))
    {
        hr = THR( g_MS->EndUndoUnit() );

        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    if (g_PM)
    {
        g_PM->Release();
        g_PM = NULL;
    }

    if (pDocDisp)
        pDocDisp->Release();
    if( pIElement )
        pIElement->Release();

    if (g_MS)
    {
        g_MS->Release();
        g_MS = NULL;
    }

    RRETURN( hr );
}



// #define SELF_TEST        // define if you want self-test
// #define HIGH_RESOLUTION  // define if 63 bits resolution desired

// If your system doesn't have a rotate function for 32 bits integers,
// then define it thus:
// uint32 _lrotr (uint32 x, int r) {
//   return (x >> r) | (x << (sizeof(x)-r));}

// define parameters
#define KK 17
#define JJ 10
#define R1 13
#define R2  5

typedef unsigned long uint32;       // use 32 bit unsigned integers
#ifdef HIGH_RESOLUTION
typedef long double trfloat;        // define floating point precision
#else
typedef double trfloat;             // define floating point precision
#endif

class TRanrotGenerator {            // encapsulate random number generator
  public:
  void RandomInit(uint32 seed);     // initialization
  void SetInterval(int min, int max); // set interval for iRandom
  int iRandom();                    // get integer random number
  trfloat Random();                 // get floating point random number
  TRanrotGenerator(uint32 seed=-1); // constructor
  protected:
  void step();                      // generate next random number
  union {                           // used for conversion to float
    trfloat randp1;
    uint32 randbits[3];};
  int p1, p2;                       // indexes into buffer
  int imin, iinterval;              // interval for iRandom
  uint32 randbuffer[KK][2];         // history buffer
#ifdef SELF_TEST
  uint32 randbufcopy[KK*2][2];      // used for self-test
#endif
};


TRanrotGenerator::TRanrotGenerator(uint32 seed) {
  // constructor
  RandomInit(seed);  SetInterval(0, 0xfffffff);}


void TRanrotGenerator::SetInterval(int min, int max) {
  // set interval for iRandom
  imin = min; iinterval = max - min + 1;}


void TRanrotGenerator::step() {
  // generate next random number
  uint32 a, b;
  // generate next number
  b = _lrotr(randbuffer[p1][0], R1) + randbuffer[p2][0];
  a = _lrotr(randbuffer[p1][1], R2) + randbuffer[p2][1];
  randbuffer[p1][0] = a; randbuffer[p1][1] = b;
  // rotate list pointers
  if (--p1 < 0) p1 = KK - 1;
  if (--p2 < 0) p2 = KK - 1;
#ifdef SELF_TEST
  // perform self-test
  if (randbuffer[p1][0] == randbufcopy[0][0] &&
    memcmp(randbuffer, randbufcopy[KK-p1], 2*KK*sizeof(uint32)) == 0) {
      // self-test failed
      if ((p2 + KK - p1) % KK != JJ) {
        // note: the way of printing error messages depends on system
        printf("Random number generator not initialized");}
      else {
        printf("Random number generator returned to initial state");}
      abort();}
#endif
  // convert to float
  randbits[0] = a;
#ifdef HIGH_RESOLUTION
  randbits[1] = b | 0x80000000;                // 80 bits floats = 63 bits resolution
#else
  randbits[1] = (b & 0x000FFFFF) | 0x3FF00000; // 64 bits floats = 52 bits resolution
#endif
  }


trfloat TRanrotGenerator::Random() {
  // returns a random number between 0 and 1.
  trfloat r = randp1 - 1.;
  step();
  return r;}


int TRanrotGenerator::iRandom() {
  // get integer random number
  int i = iinterval * Random();
  if (i >= iinterval) i = iinterval;
  return imin + i;}


void TRanrotGenerator::RandomInit (uint32 seed) {
  // this function initializes the random number generator.
  int i, j;
  // make sure seed != 0
  if (seed==0) seed = 0x7fffffff;

  // make random numbers and put them into the buffer
  for (i=0; i<KK; i++) {
    for (j=0; j<2; j++) {
      seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5;
      randbuffer[i][j] = seed;}}
  // set exponent of randp1
  randp1 = 1.5;
#ifdef HIGH_RESOLUTION
  assert((randbits[2]&0xFFFF)==0x3FFF); // check that Intel 10-byte float format used
#else
  Assert(randbits[1]==0x3FF80000); // check that IEEE double precision float format used
#endif
  Assert(sizeof(uint32)==4);  // check that 32 bits integers used

  // initialize pointers to circular buffer
  p1 = 0;  p2 = JJ;
#ifdef SELF_TEST
  memcpy (randbufcopy, randbuffer, 2*KK*sizeof(uint32));
  memcpy (randbufcopy[KK], randbuffer, 2*KK*sizeof(uint32));
#endif
  // randomize some more
  for (i=0; i<97; i++) step();
}

static TRanrotGenerator r;

HRESULT
CPadDoc::Random ( long range, long * plRet )
{
    *plRet = range > 0 ? r.iRandom() % range : 0;

    return S_OK;
}

HRESULT
CPadDoc::RandomSeed ( long seed )
{
    r.RandomInit( seed );

    return S_OK;
}

void
GetHeapTotals(LONG * pcHeapBlocks, LONG * pcHeapBytes)
{
    HANDLE rgHeaps[256];
    DWORD dwHeap, dwHeaps;
    PROCESS_HEAP_ENTRY he;
    LONG cBlocks = 0, cBytes = 0;

    dwHeaps = GetProcessHeaps(ARRAY_SIZE(rgHeaps), rgHeaps);

    for (dwHeap = 0; dwHeap < dwHeaps; ++dwHeap)
    {
        HeapLock(rgHeaps[dwHeap]);

        memset(&he, 0, sizeof(PROCESS_HEAP_ENTRY));

        while (HeapWalk(rgHeaps[dwHeap], &he))
        {
            if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY)
            {
                cBlocks += 1;
                cBytes += he.cbData;
            }
        }

        HeapUnlock(rgHeaps[dwHeap]);
    }

    *pcHeapBlocks = cBlocks;
    *pcHeapBytes = cBytes;
}

HRESULT
CPadDoc::GetHeapCounter(long iCounter, long * plRet)
{
    static long g_cHeapBlocks = 0;
    static long g_cHeapBytes  = 0;

    *plRet = 0;

    if (iCounter == 0)
    {
        GetHeapTotals(&g_cHeapBlocks, &g_cHeapBytes);
    }

    if (iCounter == 0)
        *plRet = g_cHeapBytes;
    else if (iCounter == 1)
        *plRet = g_cHeapBlocks;
    else
        *plRet = 0;

    return S_OK;
}

HRESULT
CPadDoc::CreateProcess(BSTR bstrCommandLine, VARIANT_BOOL fWait, VARIANT_BOOL fCaptureOutput, DWORD *pdwExitCode)
{
    char achCommandLine[2048];
    int cch, ret;
    DWORD err;
    PROCESS_INFORMATION pi;
    STARTUPINFOA si = { 0 };

    if (pdwExitCode)
        *pdwExitCode = 0;

    // convert strings to ANSI to be usable on Win95
    cch = WideCharToMultiByte(CP_ACP, 0, bstrCommandLine, _tcslen(bstrCommandLine), achCommandLine, 2048, NULL, NULL);
    if (!cch)
        return E_FAIL;
    achCommandLine[cch] = '\0';

    si.cb = sizeof(STARTUPINFOA);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;

    if (fCaptureOutput)
    {
        // TODO alexmog: this doesn't work. What am I doing wrong?
        AssertSz(0, "fCaptureOutput is not implemented");
        si.dwFlags |= STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    }

    ret = CreateProcessA(NULL, achCommandLine, NULL, NULL, fCaptureOutput, 0, NULL, NULL, &si, &pi);
    if (!ret)
    {
        err = GetLastError();
        return E_FAIL;
    }

    CloseHandle(pi.hThread);

    if (fWait)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(pi.hProcess, INFINITE)
            && pdwExitCode)
        {
            GetExitCodeProcess(pi.hProcess, pdwExitCode);
        }
        else
            AssertSz(0, "Wait for process failed");
    }

    CloseHandle(pi.hProcess);

    return S_OK;
}

HRESULT
CPadDoc::GetCurrentProcessId(long * plRetVal)
{
    *plRetVal = ::GetCurrentProcessId();
    return S_OK;
}

HRESULT
CPadDoc::GetMarkupServices(IMarkupServices **ppMarkupServices)
{
    HRESULT     hr;
    IDispatch   *pdispDoc = NULL;

    if (!ppMarkupServices)
        return E_INVALIDARG;

    *ppMarkupServices = NULL;

    IFC( get_Document(&pdispDoc) );
    IFC( pdispDoc->QueryInterface(IID_IMarkupServices, (LPVOID *)ppMarkupServices) );

Cleanup:
    ReleaseInterface(pdispDoc);
    RRETURN(hr);
}

HRESULT
CPadDoc::InnerHTML(IDispatch *pdispElement, BSTR *pbstrHTML)
{
    HRESULT             hr;
    IMarkupServices     *pMarkupServices = NULL;
    IHTMLElement        *pElement = NULL;

    if (!pbstrHTML || !pdispElement)
        return E_INVALIDARG;

    *pbstrHTML = NULL;

    IFC( GetMarkupServices(&pMarkupServices) );
    IFC( pdispElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );

    IFC( InnerHTML(pMarkupServices, pElement, pbstrHTML) );

Cleanup:
    ReleaseInterface(pMarkupServices);
    ReleaseInterface(pElement);

    RRETURN(hr);
}

HRESULT
CPadDoc::CurrentBlockElement(IDispatch **ppdispElement)
{
    HRESULT             hr;
    IHTMLElement        *pElement = NULL;
    IMarkupServices     *pMarkupServices = NULL;

    if (!ppdispElement)
        return E_INVALIDARG;

    *ppdispElement = NULL;

    IFC( GetMarkupServices(&pMarkupServices) );
    IFC( CurrentBlockElement(pMarkupServices, &pElement) );
    IFC( pElement->QueryInterface(IID_IDispatch, (LPVOID *)ppdispElement) );

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pMarkupServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::DoPerfEnable(BOOL fEnable)
{
    PerfEnable( fEnable );
    return S_OK;
}

HRESULT
CPadDoc::DoPerfLog(BSTR bstrLog)
{
    DWORD  cchLen = SysStringLen(bstrLog);
    char * pchBuf = new char[cchLen+3];

    WideCharToMultiByte(CP_ACP, 0, bstrLog, cchLen, pchBuf, cchLen+1, NULL, NULL);
    pchBuf[cchLen] = '\0';

    PerfLog(tagPerfScript, NULL, pchBuf);

    delete pchBuf;

    return S_OK;
}

HRESULT
CPadDoc::DoPerfDump()
{
    PerfDump();
    return S_OK;
}

HRESULT
CPadDoc::DoPerfClear()
{
    PerfClear();
    return S_OK;
}

static LONGLONG g_lStartCounter0, g_lStartCounter1, g_lStartTime;
static LONGLONG g_lStopCounter0, g_lStopCounter1, g_lStopTime;

#define RDTSC _asm _emit 0fh _asm _emit 31h
#define RDPMC _asm _emit 0fh _asm _emit 33h

HRESULT
CPadDoc::BeginPCounters()
{
#if (defined(_X86_))
    _asm mov ecx, 0
    RDPMC
    _asm mov dword ptr [g_lStartCounter0], eax
    _asm mov dword ptr [g_lStartCounter0+4], edx
    _asm mov ecx, 1
    RDPMC
    _asm mov dword ptr [g_lStartCounter1], eax
    _asm mov dword ptr [g_lStartCounter1+4], edx
    RDTSC
    _asm mov dword ptr [g_lStartTime], eax
    _asm mov dword ptr [g_lStartTime+4], edx
#endif

    return S_OK;
}

HRESULT
CPadDoc::EndPCounters()
{
#if (defined(_X86_))
    RDTSC
    _asm mov dword ptr [g_lStopTime], eax
    _asm mov dword ptr [g_lStopTime+4], edx
    _asm mov ecx, 1
    RDPMC
    _asm mov dword ptr [g_lStopCounter1], eax
    _asm mov dword ptr [g_lStopCounter1+4], edx
    _asm mov ecx, 0
    RDPMC
    _asm mov dword ptr [g_lStopCounter0], eax
    _asm mov dword ptr [g_lStopCounter0+4], edx
#endif

    return S_OK;
}

HRESULT
CPadDoc::GetPCounter( long lWhich, DWORD * plCounter )
{
    if (lWhich == 0)
    {
        *plCounter = (long)(g_lStopCounter0 - g_lStartCounter0);
    }
    else
    {
        *plCounter = (long)(g_lStopCounter1 - g_lStartCounter1);
    }

    return S_OK;
}

HRESULT
CPadDoc::GetPTime( DWORD * plTime )
{
    *plTime = (long)(g_lStopTime - g_lStartTime);

    return S_OK;
}

HRESULT
CPadDoc::GetPCounterString(VARIANT * pValue)
{
    TCHAR ach[256], *pch = ach;

    ach[0] = 0;
    pValue->vt = VT_BSTR;
    pValue->bstrVal = NULL;

#if defined(_X86_)
    if (g_apchCtrShort[0])
    {
        wsprintfW( pch, L"%S=%ld ", g_apchCtrShort[0], (long)(g_lStopCounter0 - g_lStartCounter0) );
        pch += lstrlenW(pch);
    }
    if (g_apchCtrShort[1])
    {
        wsprintfW( pch, L"%S=%ld ", g_apchCtrShort[1], (long)(g_lStopCounter1 - g_lStartCounter1) );
        pch += lstrlenW(pch);
    }

    wsprintfW( pch, L"cycles=%ld ", (long)(g_lStopTime - g_lStartTime) );

    pValue->bstrVal = SysAllocString(ach);
#endif //defined(_X86_)
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Repaint, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::Repaint()
{
    HRESULT     hr = S_OK;
    HWND        hwndToUse = NULL;

    if(_pInPlaceActiveObject)
    {
        hr = _pInPlaceActiveObject->GetWindow(&hwndToUse);
        if(FAILED(hr))
            goto Cleanup;
    }

    if(!hwndToUse && _pInPlaceObject)
    {
        hr = _pInPlaceObject->GetWindow(&hwndToUse);
        if(FAILED(hr))
            goto Cleanup;
    }

    if(!hwndToUse)
    {
        // Use the host window
        hwndToUse = _hwnd;
    }

    ::RedrawWindow(hwndToUse, NULL, NULL, RDW_INVALIDATE|RDW_ALLCHILDREN|RDW_UPDATENOW);

Cleanup:
    return hr;
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::alert, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::alert(BSTR bstrLine)
{
    if(!::MessageBox(_hwnd, bstrLine, L"Mshtmpad Message", MB_OK))
        return E_FAIL;
    return S_OK;
}

HRESULT
CPadDoc::IsDebugPad(VARIANT_BOOL *pfDebugPad)
{
    if (!pfDebugPad)
        return E_INVALIDARG;

#if DBG==1
    *pfDebugPad = VARIANT_BOOL_FROM_BOOL(TRUE);
#else
    *pfDebugPad = VARIANT_BOOL_FROM_BOOL(FALSE);
#endif

    return S_OK;
}

HRESULT
CPadDoc::EnableUIUpdate(VARIANT_BOOL vbEnable )
{
    _fUpdateUI = (vbEnable == VB_TRUE);

    RRETURN( S_OK );
}

HRESULT
CPadDoc::GetPrimaryElement( int* piPrimaryElement )
{
    HRESULT hr;
    ISelectionServices          *pSelSvc = NULL;
    IHTMLEditServices           *pIEdServ = NULL;
    IDispatch                   *pDocDisp = NULL;
    IHTMLDocument               *pDoc = NULL;
    IServiceProvider            *pSP = NULL;
    ISegmentList                *pSegmentList = NULL;
    ISegmentListIterator        *pIter = NULL;
    ISegment                    *pSegment = NULL;
    IElementSegment             *pElementSegment = NULL;
    int iPrimary = -1;
    int iIndex = 1;
    BOOL fPrimary;
    SELECTION_TYPE              eType = SELECTION_TYPE_None;
    // Get the selection services
    IFC( get_Document(&pDocDisp) );
    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
    IFC( pDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) );

    IFC( pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)& pIEdServ) );
    IFC( pIEdServ->GetSelectionServices(NULL, &pSelSvc) );
    IFC( pSelSvc->QueryInterface(IID_ISegmentList, (LPVOID *)&pSegmentList ) );

    IFC( pSegmentList->GetType(&eType) );
    if ( eType == SELECTION_TYPE_Control )
    {
        IFC( pSegmentList->CreateIterator( & pIter ));

        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pSegment) );

            IFC( pSegment->QueryInterface( IID_IElementSegment, (void**) & pElementSegment ));
            IFC( pElementSegment->IsPrimary( & fPrimary ));
            if ( fPrimary )
            {
                iPrimary = iIndex;
                break;
            }

            ClearInterface( &pSegment );
            ClearInterface( &pElementSegment);

            IFC( pIter->Advance() );
            iIndex++;
        }

        *piPrimaryElement = iPrimary;
    }
    else
        *piPrimaryElement = -1;

Cleanup:
    ReleaseInterface( pIEdServ );
    ReleaseInterface( pDocDisp );
    ReleaseInterface( pDoc );
    ReleaseInterface( pSP );
    ReleaseInterface( pSelSvc );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );
    ReleaseInterface( pElementSegment );

    RRETURN( hr );
}

HRESULT CPadDoc::LinesInElement(IDispatch *pDispElement, int *piLines)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    IHTMLElement *pIElement = NULL;
    HRESULT hr = S_OK;

    if (!pDispElement)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pDispElement->QueryInterface(IID_IHTMLElement, (void **)&pIElement));
    IFC(pEditDebugServices->LinesInElement(pIElement, (long*)piLines));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    ReleaseInterface(pIElement);
    RRETURN(hr);
}

HRESULT CPadDoc::FontsOnLine(IDispatch *pDispElement, int iLine, BSTR *pbstrFonts)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    IHTMLElement *pIElement = NULL;
    HRESULT hr = S_OK;

    if (!pDispElement)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pDispElement->QueryInterface(IID_IHTMLElement, (void **)&pIElement));
    IFC(pEditDebugServices->FontsOnLine(pIElement, iLine, pbstrFonts));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    ReleaseInterface(pIElement);
    RRETURN(hr);
}

HRESULT CPadDoc::GetPixel(int X, int Y, int *piColor)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = S_OK;

    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pEditDebugServices->GetPixel(X, Y, (long*)piColor));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsDebugTrident(VARIANT_BOOL *pfDebugTrident)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fIsDebugTrident = FALSE;

    if (!pfDebugTrident)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (   pHTMLDoc
        && S_OK == pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices)
        && pEditDebugServices != NULL
       )
    {
        fIsDebugTrident = TRUE;
    }

    *pfDebugTrident = VARIANT_BOOL_FROM_BOOL(fIsDebugTrident);
    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsWin2k(VARIANT_BOOL *pfWin2k)
{
    if (!pfWin2k)
        return E_INVALIDARG;

    *pfWin2k = (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000);

    return S_OK;
}

HRESULT
CPadDoc::IsWhistler(VARIANT_BOOL *pfWhistler)
{
    if (!pfWhistler)
        return E_INVALIDARG;

    *pfWhistler = (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050001);

    return S_OK;
}

HRESULT
CPadDoc::ComputerName(BSTR *pbstrComputerName)
{
    HRESULT hr = E_INVALIDARG;

    if (!pbstrComputerName)
        return hr;

    DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    if (GetComputerName(achComputerName, &dwComputerName))
    {
        CStr strComputerName;
        strComputerName.Set(achComputerName);
        hr = THR(strComputerName.AllocBSTR(pbstrComputerName));
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

#include <buildid.hxx>
HRESULT
CPadDoc::get_BuildId(BSTR *pbstrBuildId)
{
    TCHAR * pch = _T(SZ_BUILDID);

    *pbstrBuildId = SysAllocString(pch);

    RRETURN(*pbstrBuildId ? S_OK : E_OUTOFMEMORY);
}

//----------------------------------------------------------------------------
//  Function:   GetUnsecureWindow
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetUnsecureWindow(IDispatch * pWindowIn, IDispatch **ppWndDisp)
{
    HRESULT hr;
    IHTMLWindow2 *      pHW2 = NULL;
    IHTMLDocument2 *    pDoc = NULL;
    IServiceProvider *  pSP1 = NULL, * pSP2 = NULL;
    IAccessible *       pAcc = NULL;
    IHTMLWindow2 *      pUnsecureWindow = NULL;

    // get the IHTMLWindow2 of the pWindowIn
    hr = pWindowIn->QueryInterface(IID_IHTMLWindow2, (void **)&pHW2);
    if (hr)
        goto Cleanup;

    // get the IDispatch of the Document
    hr = pHW2->get_document(&pDoc);
    if (hr)
        goto Cleanup;

    // get the service provider from the document object
    hr = pDoc->QueryInterface(IID_IServiceProvider, (void **)&pSP1);
    if (hr)
        goto Cleanup;

    // get the accessible window object from the document
    hr = pSP1->QueryService( IID_IAccessible, IID_IAccessible, (void **)&pAcc);
    if (hr)
        goto Cleanup;

    // make a service QS call on the accessible window object for its inner window
    hr = pAcc->QueryInterface( IID_IServiceProvider, (void **)&pSP2);
    if (hr)
        goto Cleanup;

    hr = pSP2->QueryService( IID_IHTMLWindow2, IID_IHTMLWindow2, (void **)&pUnsecureWindow);
    if (hr)
        goto Cleanup;

    hr = pUnsecureWindow->QueryInterface(IID_IDispatch, (void **)ppWndDisp);

Cleanup:
    ReleaseInterface(pHW2);
    ReleaseInterface(pDoc);
    ReleaseInterface(pSP1);
    ReleaseInterface(pSP2);
    ReleaseInterface(pAcc);
    ReleaseInterface(pUnsecureWindow);

    RRETURN(hr);
}

HRESULT
CPadDoc::IsUsingBckgrnRecalc(VARIANT_BOOL *pfUsingBckgrnRecalc)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fUsingBckgrnRecalc;

    if (!pfUsingBckgrnRecalc)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsUsingBckgrnRecalc(&fUsingBckgrnRecalc));
        *pfUsingBckgrnRecalc = VARIANT_BOOL_FROM_BOOL(fUsingBckgrnRecalc);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsUsingTableIncRecalc(VARIANT_BOOL *pfUsingTableIncRecalc)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fUsingTableIncRecalc;

    if (!pfUsingTableIncRecalc)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsUsingTableIncRecalc(&fUsingTableIncRecalc));
        *pfUsingTableIncRecalc = VARIANT_BOOL_FROM_BOOL(fUsingTableIncRecalc);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsEncodingAutoSelect(VARIANT_BOOL *pfEncodingAutoSelect)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fEncodingAutoSelect;

    if (!pfEncodingAutoSelect)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsEncodingAutoSelect(&fEncodingAutoSelect));
        *pfEncodingAutoSelect = VARIANT_BOOL_FROM_BOOL(fEncodingAutoSelect);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::EnableEncodingAutoSelect(VARIANT_BOOL fEnable)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->EnableEncodingAutoSelect(fEnable));
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::GetPadEnumPrivacyRecords(IDispatch** ppPadEnumPrivacyRecords )
{
    HWND                     hwnd        = NULL;
    HRESULT                  hr          = S_OK;
    IDispatch              * pHTMLDoc    = NULL;
    IServiceProvider       * pServProv   = NULL;
    IEnumPrivacyRecords    * pIEnumPri   = NULL;
    CPadEnumPrivacyRecords * pPadEnumPri = NULL;

    if ( !ppPadEnumPrivacyRecords )
        return E_POINTER;

    *ppPadEnumPrivacyRecords = NULL;

    // get the document
    hr = get_Document( &pHTMLDoc );
    if ( hr || !pHTMLDoc )
        goto Cleanup;

    // get the service provider interface
    hr = pHTMLDoc->QueryInterface( IID_IServiceProvider, (void **)&pServProv);
    if ( hr || !pServProv )
        goto Cleanup;


    // get the IEnumPrivacyRecords interface
    hr = pServProv->QueryService( IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, (void **)&pIEnumPri);
    if ( hr || !ppPadEnumPrivacyRecords )
        goto Cleanup;

    pPadEnumPri = new CPadEnumPrivacyRecords(pIEnumPri);
    if (!pPadEnumPri)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    *ppPadEnumPrivacyRecords = (IDispatch*)pPadEnumPri;

Cleanup:
    if ( pHTMLDoc )
        pHTMLDoc->Release();

    if ( pServProv )
        pServProv->Release();

    if (pIEnumPri)
        pIEnumPri->Release();

    return hr;
}

HRESULT
CPadDoc::PadCommand(WORD widm)
{
    return OnCommand(0, widm, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\msgwnd.cxx ===
/***********************************************************************
 *
 *  FORMWND.CPP
 *
 *
 *  Copyright 1986-1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#define  WM_DEFERCOMBOUPDATE        (WM_APP + 1)
const int cxMargin = 4;
const int cyMargin = 4;

LRESULT DlgChildWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WNDPROC pWndProc;
    LRESULT lResult;

    pWndProc = (WNDPROC)GetWindowLong(hwnd, GWL_USERDATA);

    switch ( msg )
    {
        case WM_LBUTTONUP:
        {
            CPadMessage * pPad;
            pPad = (CPadMessage *) GetWindowLong(GetParent(GetParent(hwnd)), GWL_USERDATA);

            // Hack: Need to do the default behavior before deactivating the pad so that the button
            // other the button has shifted underneath the mouse by the time the default processing
            // for WM_LBUTTONUP happens and it does not fire the WM_COMMAND
            lResult = CallWindowProc(pWndProc, hwnd, msg, wParam, lParam);

            pPad->OnDialogControlActivate(hwnd);

            return lResult;
        }
    }

    return CallWindowProc(pWndProc, hwnd, msg, wParam, lParam);
}


void
CPadMessage::HookControl(ULONG ulIdControl)
{
    WNDPROC pWndProc;
    HWND hwndControl;

    hwndControl = GetDlgItem(_hwndDialog, ulIdControl);
    pWndProc = (WNDPROC)SetWindowLong(hwndControl, GWL_WNDPROC, (LONG)DlgChildWndProc);
    SetWindowLong(hwndControl, GWL_USERDATA, (LONG)pWndProc);
}


void
CPadMessage::OnDialogControlActivate(HWND hwndControl)
{
    CPadDoc * pPad1;

    // Make sure the command has not deleted pPad
    for(pPad1 = g_pDocFirst; pPad1 != NULL; pPad1 = pPad1->_pDocNext)
    {
        if(pPad1 == this)
            break;
    }

    // If not, deactivate Trident DocObject
    if(pPad1)
    {
        Assert(pPad1 == this);
        IGNORE_HR(UIDeactivateDoc());
    }

    // ISSUE: chrisf - hack: apparently the focus goes away from the control
    // during UIdeactivateDoc
    SetFocus(hwndControl);
}


HWND
CPadMessage::CreateField(
    ULONG ulIdField,
    ULONG ulIdLabel,
    DWORD dwStyle,
    BOOL fCreateOleCallBack)
{
    RECT rc;
    HWND hwndField;
    DWORD dwEventMask;
    HFONT hFont;
    CTripCall * pTripCall = NULL;

    hwndField = GetDlgItem(_hwndDialog, ulIdLabel);
    GetWindowRect(hwndField, &rc);

    hwndField = CreateWindowEx(
            WS_EX_CLIENTEDGE,	// extended window style
            TEXT("RichEdit"),	// pointer to registered class name
            LPCTSTR (NULL),	    // pointer to window name
            dwStyle |
            WS_CHILD | WS_VISIBLE | ES_MULTILINE |
            ES_SUNKEN | ES_SAVESEL | WS_TABSTOP,	// window style
            rc.right - _rcDialog.left + cxMargin,
            rc.top - _rcDialog.top,
            _rcDialog.right - rc.right - cxMargin * 2,	
            rc.bottom - rc.top,
            _hwndDialog,    // handle to parent or owner window
            NULL,	        // handle to menu, or child-window identifier
            g_hInstCore,	// handle to application instance
            NULL         	// pointer to window-creation data
    );

    if (!hwndField)
        goto Cleanup;

    SetWindowLong(hwndField, GWL_ID, ulIdField);

    dwEventMask = SendMessage(hwndField, EM_GETEVENTMASK, 0, 0);
    SendMessage(hwndField, EM_SETEVENTMASK, 0,
                    dwEventMask | ENM_REQUESTRESIZE | ENM_MOUSEEVENTS);

    hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hwndField, WM_SETFONT, (WPARAM)hFont, 0);

    SendMessage(hwndField, EM_REQUESTRESIZE, 0, 0);

    if (dwStyle & ES_READONLY)
        SendMessage(hwndField, EM_SETBKGNDCOLOR, FALSE, GetSysColor(COLOR_BTNFACE));

    if (fCreateOleCallBack)
    {
        pTripCall = new CTripCall(this, hwndField, TRUE);
        if (!pTripCall)
        {
            hwndField = NULL;
            goto Cleanup;
        }

        Verify(SendMessage(hwndField, EM_SETOLECALLBACK, 0, (LPARAM)pTripCall));
    }

Cleanup:
    if (pTripCall)
        pTripCall->Release();

    return hwndField;
}

HDWP
CPadMessage::FieldRequestResize (
    HDWP    hdwp,
    RECT *  prcResize,
    ULONG   ulIdResize,
    ULONG   ulIdField,
    ULONG   ulIdLabel,
    RECT *  prcSubmitBtn,
    int *   pcyDialogHeight)
{
    HWND    hwndField;
    HWND    hwndLabel;
    RECT    rc;
    int     cyHeight;

    hwndField = GetDlgItem(_hwndDialog, ulIdField);
    if (!hwndField)
        return hdwp;

    GetWindowRect(hwndField, &rc);

    cyHeight = (ulIdResize == ulIdField) ?
                prcResize->bottom - prcResize->top + 1:
                rc.bottom - rc.top;

    if (*pcyDialogHeight == 0)
        *pcyDialogHeight = rc.top - _rcDialog.top;

    if (rc.top - _rcDialog.top >= prcResize->top)
    {
         hdwp = DeferWindowPos(hdwp, hwndField, NULL,
                rc.left - _rcDialog.left,
                *pcyDialogHeight,
                _rcDialog.right - rc.left -
                    (prcSubmitBtn &&
                        (*pcyDialogHeight + _rcDialog.top <= prcSubmitBtn->bottom) ?
                            prcSubmitBtn->right - prcSubmitBtn->left + cxMargin * 2 :
                            cxMargin),
                cyHeight,
                SWP_NOACTIVATE | SWP_NOZORDER);
          if(!hdwp)
                return NULL;

         // reposition Field Button
         hwndLabel = GetDlgItem(_hwndDialog, ulIdLabel);
         if (hwndLabel)
         {
             GetWindowRect(hwndLabel, &rc);
             hdwp = DeferWindowPos(hdwp, hwndLabel, NULL,
                          rc.left - _rcDialog.left,
                          *pcyDialogHeight,
                          0, 0,
                          SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
             if(!hdwp)
                 return NULL;
         }
     }

     *pcyDialogHeight += cyHeight + cyMargin;

     return hdwp;
}


//+---------------------------------------------------------------------------
//
//  Member:     FormDlgProcSend
//              CPadMessage::DlgProcSend
//
//  Synopsis:   Dialog procedure for field dialogs, Send form
//
//----------------------------------------------------------------------------

BOOL CALLBACK FormDlgProcSend(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadMessage *       pPad;

    pPad = (CPadMessage *) GetWindowLong(GetParent(hwnd), GWL_USERDATA);

    Assert(pPad);

    return pPad->DlgProcSend(hwnd, msg, wParam, lParam);
}

BOOL
CPadMessage::DlgProcSend(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT                rc;
    int                 wmId;
    int                 wmEvent;
    HBITMAP             hBitmap;
    HWND                hButton;

    switch ( msg )
    {
    case WM_INITDIALOG:
    {
        _hwndDialog = hwnd;

        GetWindowRect(hwnd, &_rcDialog);

        // Load bitmap in "Send" button
        hBitmap = LoadBitmap(g_hInstResource, MAKEINTRESOURCE(IDB_MESSAGE_SEND));
        hButton = GetDlgItem(hwnd, ID_SUBMIT);
        SendMessage(hButton, BM_SETIMAGE,0, (LONG) hBitmap);

        // Create TO, CC and SUBJECT fields
        _rghwndEdit[0] = NULL;
        _rgulRecipTypes[0] = MAPI_ORIG;

        _rghwndEdit[1] = CreateField(ID_TO, ID_TO_BUTTON, 0, TRUE);
        _rgulRecipTypes[1] = MAPI_TO;

        _rghwndEdit[2] = CreateField(ID_CC, ID_CC_BUTTON, 0, TRUE);
        _rgulRecipTypes[2] = MAPI_CC;

        _cRecipTypes = 3;

        CreateField(ID_SUBJECT, ID_SUBJECT_LABEL, 0, FALSE);

        // Hook TO and CC buttons to trap mouse up
        HookControl(ID_TO_BUTTON);
        HookControl(ID_CC_BUTTON);

        return TRUE;
    }
    case WM_WINDOWPOSCHANGED:
        {
            HWND        hwndItem;
            HWND        hwndIcon;
            RECT        rc;
            RECT        rcSubmitBtn;
            int         cxSubmitBtn;
            int         xSubmitBtn;
            int         cxDialogOld;
            int         cyDialogOld;

            Assert(_hwndDialog == hwnd);

            cxDialogOld = _rcDialog.right - _rcDialog.left;
            cyDialogOld = _rcDialog.bottom - _rcDialog.top;

            GetWindowRect(hwnd, &_rcDialog);

            if (cxDialogOld != _rcDialog.right - _rcDialog.left)
            {
                hwndIcon = GetDlgItem(hwnd, ID_SUBMIT);
                GetWindowRect(hwndIcon, &rcSubmitBtn);
                ScreenToClient(hwnd, (POINT*)&rcSubmitBtn.left);
                ScreenToClient(hwnd, (POINT*)&rcSubmitBtn.right);
                cxSubmitBtn = rcSubmitBtn.right - rcSubmitBtn.left;

                HDWP hdwp = BeginDeferWindowPos(4);
                if(NULL == hdwp)
                    break;

                hwndItem = GetDlgItem(hwnd, ID_TO);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxSubmitBtn - cxMargin * 2,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_CC);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxSubmitBtn - cxMargin * 2,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SUBJECT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                xSubmitBtn = _rcDialog.right - _rcDialog.left - cxSubmitBtn - cxMargin;
                if(NULL == DeferWindowPos(hdwp, hwndIcon, NULL, xSubmitBtn, rcSubmitBtn.top,
                            rcSubmitBtn.right - rcSubmitBtn.left, rcSubmitBtn.bottom - rcSubmitBtn.top,
                            SWP_NOACTIVATE | SWP_NOZORDER))
                {
                    break;
                }

                EndDeferWindowPos(hdwp);
            }

            if (cyDialogOld != _rcDialog.bottom - _rcDialog.top)
            {
                Resize();
            }
        }
        break;

    case WM_NOTIFY:
        wmId = wParam;
        wmEvent = ((NMHDR*)lParam)->code;

        Assert(_hwndDialog == hwnd);

        switch(wmEvent)
        {
        case EN_MSGFILTER:
            if (((MSGFILTER*)lParam)->msg == WM_LBUTTONUP)
            {
                OnDialogControlActivate(((MSGFILTER*)lParam)->nmhdr.hwndFrom);
            }
            break;

        case EN_REQUESTRESIZE:
            {
            int             cyDialogHeight = 0;
            HWND            hwndItem;
            REQRESIZE *     lpResize;
            HWND            hwndIcon;
            HDWP            hdwp;
            RECT            rcSubmitBtn;

            // Get new height for item requesting size change
            lpResize = (REQRESIZE *)(lParam);

            // Break out if no change in size
            hwndItem = GetDlgItem(hwnd, wmId);
            GetWindowRect(hwndItem, &rc);
            if(lpResize->rc.bottom - lpResize->rc.top + 1 == rc.bottom - rc.top)
                break;

            // Get Submit button width
            hwndIcon = GetDlgItem(hwnd, ID_SUBMIT);
            GetWindowRect(hwndIcon, &rcSubmitBtn);

            hdwp = BeginDeferWindowPos(6);
            if(!hdwp)
                break;

            // Reposition TO field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_TO, ID_TO_BUTTON,
                                    &rcSubmitBtn, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition CC field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_CC, ID_CC_BUTTON,
                                    &rcSubmitBtn, &cyDialogHeight);
            if(!hdwp)
                break;

            // Reposition Subject field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_SUBJECT, ID_SUBJECT_LABEL,
                                    &rcSubmitBtn, &cyDialogHeight);
            if(!hdwp)
                break;

            EndDeferWindowPos(hdwp);

            // Resize dialog as a whole
            SetWindowPos(hwnd, NULL, 0, 0, _rcDialog.right - _rcDialog.left,
                         cyDialogHeight, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch(wmId) {
        case ID_TO_BUTTON:
        case ID_CC_BUTTON:
            switch (wmEvent) {
            case BN_CLICKED:
                Address(wmId);
                break;

            default:
                return FALSE;
            }
            break;
        case ID_SUBJECT:
            if (wmEvent == EN_KILLFOCUS) {
                TCHAR    sz[250];

                if (Edit_GetText(GET_WM_COMMAND_HWND(wParam, lParam), sz, 200)) {
                    lstrcat(sz, TEXT (" - "));
                    lstrcat(sz, g_achWindowCaption);
                    SetWindowText(GetParent(hwnd), sz);
                }
                else
                    SetWindowText(GetParent(hwnd), g_achWindowCaption);

                break;
            }
            return FALSE;
        case ID_SUBMIT:
            if(wmEvent == BN_CLICKED)
            {
                SendMessage(GetParent(hwnd), WM_COMMAND, IDM_MESSAGE_SUBMIT, 0);
            }
            return TRUE;
        }
        return FALSE;

    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     FormDlgProcRead
//              CPadMessage::DlgProcRead
//
//  Synopsis:   Dialog procedure for field dialogs, Read form
//
//----------------------------------------------------------------------------

BOOL CALLBACK FormDlgProcRead(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadMessage *       pPad;

    pPad = (CPadMessage *) GetWindowLong(GetParent(hwnd), GWL_USERDATA);

    Assert(pPad);

    return pPad->DlgProcRead(hwnd, msg, wParam, lParam);
}

BOOL
CPadMessage::DlgProcRead(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT                rc;
    int                 wmId;
    int                 wmEvent;

    switch ( msg ) {
    case WM_INITDIALOG:
    {
        _hwndDialog = hwnd;

        GetWindowRect(hwnd, &_rcDialog);

        // Create TO, CC and SUBJECT fields
        CreateField(ID_FROM, ID_FROM_LABEL, ES_READONLY, FALSE);
        CreateField(ID_SENT, ID_SENT_LABEL, ES_READONLY, FALSE);
        CreateField(ID_TO, ID_TO_LABEL, ES_READONLY, FALSE);
        CreateField(ID_CC, ID_CC_LABEL, ES_READONLY, FALSE);
        CreateField(ID_SUBJECT, ID_SUBJECT_LABEL, ES_READONLY, FALSE);

        return TRUE;
    }

    case WM_NOTIFY:
        wmId = wParam;
        wmEvent = ((NMHDR*)lParam)->code;

        Assert(_hwndDialog == hwnd);

        switch(wmEvent)
        {
        case EN_MSGFILTER:
            if (((MSGFILTER*)lParam)->msg == WM_LBUTTONUP)
            {
                OnDialogControlActivate(((MSGFILTER*)lParam)->nmhdr.hwndFrom);
            }
            break;

        case EN_REQUESTRESIZE:
            {
            int             cyDialogHeight = 0;
            HWND            hwndItem;
            REQRESIZE *     lpResize;
            HDWP            hdwp;

            // Get new height for item requesting size change
            lpResize = (REQRESIZE *)(lParam);

            // Break out if no change in size
            hwndItem = GetDlgItem(hwnd, wmId);
            GetWindowRect(hwndItem, &rc);
            if(lpResize->rc.bottom - lpResize->rc.top + 1 == rc.bottom - rc.top)
                break;

            hdwp = BeginDeferWindowPos(10);
            if(!hdwp)
                break;

            // Reposition FROM field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_FROM, ID_FROM_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition SENT field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_SENT, ID_SENT_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition TO field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_TO, ID_TO_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition CC field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_CC, ID_CC_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition SUBJECT field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_SUBJECT, ID_SUBJECT_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            EndDeferWindowPos(hdwp);

            // Resize dialog as a whole
            SetWindowPos(hwnd, NULL, 0, 0, _rcDialog.right - _rcDialog.left,
                         cyDialogHeight, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;


    case WM_WINDOWPOSCHANGED:
        {
            HWND        hwndItem;
            RECT        rc;
            int         cxDialogOld;
            int         cyDialogOld;

            Assert(_hwndDialog == hwnd);

            cxDialogOld = _rcDialog.right - _rcDialog.left;
            cyDialogOld = _rcDialog.bottom - _rcDialog.top;

            GetWindowRect(hwnd, &_rcDialog);

            if (cxDialogOld != _rcDialog.right - _rcDialog.left)
            {
                HDWP hdwp = BeginDeferWindowPos(5);
                if(NULL == hdwp)
                    break;

                hwndItem = GetDlgItem(hwnd, ID_FROM);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SENT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_TO);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_CC);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SUBJECT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                EndDeferWindowPos(hdwp);
        }

        if (cyDialogOld != _rcDialog.bottom - _rcDialog.top)
        {
           Resize();
        }
    }
        break;
    }
    return FALSE;
}


//
// Window proc for frame window of both the read and send form.
//
//  Send frame window does not receive IDC_VIEW_ITEMABOVE, IDC_VIEW_ITEMBELOW
// commands.
// Read frame window does not receive IDC_MESSAGE_SUBMIT command.
LRESULT
CPadMessage::PadWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    HRESULT             hr;
    HMENU               hMenu;
    int                 wmId;
    int                 wmEvent;

    switch( wm )
    {
    case WM_DESTROY:
        OnDestroy();
        break;

    case WM_DEFERCOMBOUPDATE:
        return OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch( wmId )
        {
        case IDM_MESSAGE_OPENHTM:
            hr = THR(PromptOpenFile(_hwnd, &CLSID_HTMLDocument));
            _fUserMode = 0;
            SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
            break;

        case IDM_MESSAGE_CLOSE:
            ShutdownForm(SAVEOPTS_PROMPTSAVE);
            break;

        case IDM_MESSAGE_SAVE:
            hr = THR(DoSave(FALSE));
            if ( hr == MSOCMDERR_E_CANCELED )
            {
                hr = S_OK;
            }
            break;

        case IDM_MESSAGE_SAVE_AS:
            hr = THR(DoSave(TRUE));
            if ( hr == MSOCMDERR_E_CANCELED )
            {
                hr = S_OK;
            }
            break;

        case IDM_VIEW_ITEMABOVE:
        case IDM_VIEW_ITEMBELOW:
            {
                ULONG ulDir = IDM_VIEW_ITEMABOVE == wmId ? VCDIR_PREV:VCDIR_NEXT;
                DoNext(ulDir);

                break;
            }

        case IDM_MESSAGE_DELETE:
            DoDelete();
            break;

        case IDM_MESSAGE_REPLY:
            DoReply(eREPLY);
            break;

        case IDM_MESSAGE_REPLY_ALL:
            DoReply(eREPLY_ALL);
            break;

        case IDM_MESSAGE_FORWARD:
            DoReply(eFORWARD);
            break;

        case IDM_MESSAGE_SUBMIT:
            DoSubmit();
            break;

        case IDM_MESSAGE_COPY:
            DoCopy();
            break;

        case IDM_MESSAGE_MOVE:
            DoMove();
            break;

        case IDM_MESSAGE_CHECK_NAMES:
            DoCheckNames();
            break;

        case IDM_FONTSIZE:
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
        case IDM_FORECOLOR:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                PostMessage(_hwnd, WM_DEFERCOMBOUPDATE, wParam, lParam);
            }
            break;

        default:
            return OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        }
        break;

        //
        //  Do all of the correct menu graying
        //

    case WM_INITMENU:
        hMenu = (HMENU) wParam;
        ConfigMenu(hMenu);
        break;

        //
        //  Deal with the System Close message
        //
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_CLOSE)
        {
            ShutdownForm(SAVEOPTS_PROMPTSAVE);
        }
        else
        {
            goto DoDefault;
        }
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndDialog);
        break;

    default:

DoDefault:
        return CPadDoc::PadWndProc(hwnd, wm, wParam, lParam);
    }

    return 0;
}



HRESULT
CPadMessage::InitReadToolbar ()
{
    static const TBBUTTON tbButton[] =
    {
        { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_MESSAGE_PRINT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_MESSAGE_MOVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 2, IDM_MESSAGE_DELETE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 3, IDM_MESSAGE_REPLY, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 4, IDM_MESSAGE_REPLY_ALL, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_MESSAGE_FORWARD, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 6, IDM_VIEW_ITEMABOVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 7, IDM_VIEW_ITEMBELOW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},


        { 8, IDM_PAD_ABOUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

    };

    HRESULT     hr = S_OK;

    // Create the toolbar

    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_MESSAGE_TOOLBAR,
            9,                             // number of bitmaps
            g_hInstResource,
            IDB_MESSAGE_TOOLBAR,
            (LPCTBBUTTON) &tbButton,
            ARRAY_SIZE(tbButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!_hwndToolbar)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\p6cnt.cxx ===
//------------------------------------------------------------------------
//
//  Microsoft MSHTML
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       p6cnt.cxx
//
//  Contents:   Pentium 6+ counter management (copied from NT's pdump.c)
//
//-------------------------------------------------------------------------

#if defined(_X86_)

// This is just a big hack. We can't include padhead.hxx first so it doesn't get first crack
// at doing this stuff.  When I finally change this over to use the new icecap driver instead
// of pstat.sys this should all go away since I won't need the internal nt headers.
// Look in src\core\include\always.h for more details.
// -- JBeda

#define _strdup CRT__strdup_DontUse
#define _wcsdup CRT__wcsdup_DontUse
#define strdup  CRT_strdup_DontUse
#define malloc  CRT_malloc_DontUse
#define realloc CRT_realloc_DontUse
#define calloc  CRT_calloc_DontUse
#define free    CRT_free_DontUse
#define _wcsicmp CRT__wcsicmp
#define isdigit     CRT_isdigit
#define isalpha     CRT_isalpha
#define isspace     CRT_isspace
#define iswspace    CRT_iswspace


#ifndef X_NT_H_
#define X_NT_H_
#include <nt.h>
#endif

#ifndef X_NTRTL_H_
#define X_NTRTL_H_
#include <ntrtl.h>
#endif

#ifndef X_NTURTL_H_
#define X_NTURTL_H_
#include <nturtl.h>
#endif

#undef _strdup
#undef _wcsdup
#undef strdup
#undef _wcsicmp
#undef malloc
#undef realloc
#undef calloc
#undef free
#undef isdigit
#undef isalpha
#undef isspace
#undef iswspace

#undef ASSERT

#include "padhead.hxx"

#ifndef X_PSTAT_H_
#define X_PSTAT_H_
#include "pstat.h"
#endif

static DYNLIB g_dynlibNTDLL = { NULL, NULL, "ntdll.dll" };
static DYNPROC g_dynprocNtQuerySystemInformation = { NULL, &g_dynlibNTDLL, "NtQuerySystemInformation" };
static DYNPROC g_dynprocRtlInitUnicodeString = { NULL, &g_dynlibNTDLL, "RtlInitUnicodeString" };
static DYNPROC g_dynprocNtOpenFile = { NULL, &g_dynlibNTDLL, "NtOpenFile" };
static DYNPROC g_dynprocNtDeviceIoControlFile = { NULL, &g_dynlibNTDLL, "NtDeviceIoControlFile" };
static DYNPROC g_dynprocNtClose = { NULL, &g_dynlibNTDLL, "NtClose" };

typedef NTSTATUS (NTAPI *PFN_NTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
typedef VOID (NTAPI *PFN_RTLINITUNICODESTRING)(PUNICODE_STRING, PCWSTR);
typedef NTSTATUS (NTAPI *PFN_NTOPENFILE)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);
typedef NTSTATUS (NTAPI *PFN_NTDEVICEIOCONTROLFILE)(HANDLE FileHandle, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
typedef NTSTATUS (NTAPI *PFN_NTCLOSE)(HANDLE);

static BOOL g_fNTDLLInitDone = FALSE;
static BOOL g_fNTDLLInitSuccess = FALSE;

static BOOL EnsureInitNTDLL()
{
    LOCK_GLOBALS;

    if (g_fNTDLLInitDone)
        return g_fNTDLLInitSuccess;

    if (    LoadProcedure(&g_dynprocNtQuerySystemInformation) != S_OK
        ||  LoadProcedure(&g_dynprocRtlInitUnicodeString) != S_OK
        ||  LoadProcedure(&g_dynprocNtOpenFile) != S_OK
        ||  LoadProcedure(&g_dynprocNtDeviceIoControlFile) != S_OK
        ||  LoadProcedure(&g_dynprocNtClose) != S_OK)
    {
        g_fNTDLLInitSuccess = FALSE;
    }
    else
    {
        g_fNTDLLInitSuccess = TRUE;
    }

    g_fNTDLLInitDone = TRUE;

    return g_fNTDLLInitSuccess;
}

HRESULT       
InitP6Counters()
{
    HRESULT hr = S_OK;
    Assert( !g_hPStat );

    if (!EnsureInitNTDLL())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( InitPStatDriver() );
    if (hr)
        goto Cleanup;

    hr = THR( SetP6Counters() );
    if (hr)
        goto Cleanup;
    
Cleanup:

    IGNORE_HR( ClosePStatDriver() );

    return hr;
}

HRESULT          
InitPStatDriver()
{
    UCHAR                       NumberOfProcessors;
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    ((PFN_NTQUERYSYSTEMINFORMATION)g_dynprocNtQuerySystemInformation.pfn)(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return E_FAIL;
    }

    //
    // Open PStat driver
    //

    ((PFN_RTLINITUNICODESTRING)g_dynprocRtlInitUnicodeString.pfn)(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = ((PFN_NTOPENFILE)g_dynprocNtOpenFile.pfn) (
            &g_hPStat,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (NT_SUCCESS(status))
    {
        return S_OK;
    }
    else
    {
        g_hPStat = NULL;
        return E_FAIL;
    }
}

HRESULT          
SetP6Counters()
{
    IO_STATUS_BLOCK             IOSB;
    Assert(MAX_EVENTS == 2);

    SETEVENT  aSetEvent[MAX_EVENTS];
    char chModes[2];

    aSetEvent[0].EventId = GetPrivateProfileIntA("P6Ctr", "Ctr0", 0xFF, "mshtmdbg.ini");
    aSetEvent[0].AppReserved = 0;
    aSetEvent[0].Active = aSetEvent[0].EventId != 0xFF;
    GetPrivateProfileStringA("P6Ctr", "Ctr0Modes", "*", chModes, 2, "mshtmdbg.ini");
    aSetEvent[0].UserMode = chModes[0] == '*' || chModes[0] == '3';
    aSetEvent[0].KernelMode = chModes[0] == '*' || chModes[0] == '0';
    aSetEvent[0].EdgeDetect = FALSE;

    aSetEvent[1].EventId = GetPrivateProfileIntA("P6Ctr", "Ctr1", 0xFF, "mshtmdbg.ini");
    aSetEvent[1].AppReserved = 0;
    aSetEvent[1].Active = aSetEvent[1].EventId != 0xFF;
    GetPrivateProfileStringA("P6Ctr", "Ctr1Modes", "*", chModes, 2, "mshtmdbg.ini");
    aSetEvent[1].UserMode = chModes[0] == '*' || chModes[0] == '3';
    aSetEvent[1].KernelMode = chModes[0] == '*' || chModes[0] == '0';
    aSetEvent[1].EdgeDetect = FALSE;

    {
        char                buffer[400];
        ULONG               i, Count;
        NTSTATUS            status;
        PEVENTID            Event;

        Event = (PEVENTID) buffer;
        Count = 0;
        do {
            *((PULONG) buffer) = Count;
            Count += 1;

            status = ((PFN_NTDEVICEIOCONTROLFILE)g_dynprocNtDeviceIoControlFile.pfn)(
                        g_hPStat,
                        (HANDLE) NULL,          // event
                        (PIO_APC_ROUTINE) NULL,
                        (PVOID) NULL,
                        &IOSB,
                        PSTAT_QUERY_EVENTS,
                        buffer,                 // input buffer
                        sizeof (buffer),
                        NULL,                   // output buffer
                        0
                        );

            if (NT_SUCCESS(status))
            {
                for (i=0; i < MAX_EVENTS; i++)
                {
                    if (aSetEvent[i].Active && aSetEvent[i].EventId == Event->EventId)
                    {
                        ULONG nLen;

                        nLen = lstrlenA((char*)(Event->Buffer));
                        Assert(g_apchCtrShort[i] == NULL);
                        g_apchCtrShort[i] = new char[nLen+1];
                        lstrcpyA(g_apchCtrShort[i], (char*)(Event->Buffer));

                        nLen = lstrlenA((char*)(Event->Buffer + Event->DescriptionOffset));
                        Assert(g_apchCtrLong[i] == NULL);
                        g_apchCtrLong[i] = new char[nLen+1];
                        lstrcpyA(g_apchCtrLong[i], (char*)(Event->Buffer + Event->DescriptionOffset));

                        g_achCtrModes[i] = aSetEvent[i].UserMode 
                                            ? (aSetEvent[i].KernelMode ? '*' : '3') 
                                            : (aSetEvent[i].KernelMode ? '0' : '-');
                    }
                }
            }
        } while (NT_SUCCESS(status));

        for (i=0; i < MAX_EVENTS; i++)
            if (g_apchCtrShort[i] == NULL)
                aSetEvent[i].Active = FALSE;
    }

    


    ((PFN_NTDEVICEIOCONTROLFILE)g_dynprocNtDeviceIoControlFile.pfn)(
        g_hPStat,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        aSetEvent,           // input buffer
        sizeof(SETEVENT)*MAX_EVENTS,
        NULL,                   // output buffer
        0
    );

    return S_OK;
}

HRESULT          
ClosePStatDriver()
{
    if (g_hPStat)
    {
        ((PFN_NTCLOSE)g_dynprocNtClose.pfn) (g_hPStat);
    }

    return S_OK;
}

#endif //defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\paddisp.h ===
#define DISPID_PadEvents_Load  10
#define DISPID_PadEvents_Status 11
#define DISPID_PadEvents_Timer 12
#define DISPID_PadEvents_DocLoaded 13
#define DISPID_PadEvents_OnPaint 14
#define DISPID_PadEvents_Unload  15
#define DISPID_PadEvents_PerfCtl 16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\paddebug.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddebug.hxx
//
//  Contents:   CDebugWindow class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

BOOL    CDebugWindow::s_fDebugWndClassRegistered = FALSE;


//+-------------------------------------------------------------------
//
// Member:    CDebugWindow ::CDebugWindow
//
// Synopsis:
//
//--------------------------------------------------------------------
CDebugWindow::CDebugWindow (CPadDoc * pDoc)
{     
    _pDoc = pDoc;
}


CDebugWindow::~CDebugWindow ()
{     
}


HRESULT
CDebugWindow::RegisterDebugWndClass()
{
    WNDCLASS    wc;

    // Protect s_fDebugWndClassRegistered
    
    if (!s_fDebugWndClassRegistered)
    {
        LOCK_GLOBALS;

        if (!s_fDebugWndClassRegistered)
        {
            memset(&wc, 0, sizeof(wc));
            wc.lpfnWndProc = CDebugWindow::WndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
            wc.lpszMenuName =  NULL;
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" Debug Window");
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

            if (!RegisterClass(&wc))
            {
                return E_FAIL;
            }
            s_fDebugWndClassRegistered = TRUE;
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
// Member:    CDebugWindow ::Init
//
// Synopsis:
//
//--------------------------------------------------------------------
HRESULT
CDebugWindow::Init()
{
    
    HRESULT     hr = S_OK;
    RECT        rc;
    
    hr = THR(RegisterDebugWndClass());
    if (hr)
        goto Error;

   _hwnd = CreateWindowEx(
            0,
            SZ_APPLICATION_NAME TEXT(" Debug Window"),
            SZ_APPLICATION_NAME TEXT(" Debug Window"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            NULL,
            NULL,
            g_hInstCore,
            this);

    if (!_hwnd)
    {
        hr = E_FAIL;
        goto Error;
    }


    GetClientRect (_hwnd, &rc);

    _hwndText = CreateWindowEx(
        NULL,
        TEXT("Edit"),
        NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | 
            WS_BORDER | ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        0, 0, rc.left - rc.right, rc.top - rc.bottom,
        _hwnd,                 
        0,               
        g_hInstCore,          
        NULL);    
    
    if(!_hwndText)
    {
        hr = E_FAIL;
        goto Error;             
    }
  
    SetWindowLongPtr(_hwndText, GWLP_USERDATA, (LONG_PTR) this);
    _wpOrigEditProc = (WNDPROC) SetWindowLongPtr(_hwndText, GWLP_WNDPROC, (LONG_PTR) DebugTextWndProc); 
 
    RRETURN(hr);

Error:
    if(_hwnd)
        DestroyWindow(_hwnd); 
    if(_hwndText)
        DestroyWindow(_hwndText); 
    RRETURN(hr);
}

void
CDebugWindow::Destroy()
{
    if(_hwndText)
        DestroyWindow(_hwndText);
    if(_hwnd)
        DestroyWindow(_hwnd);
}


LRESULT
CDebugWindow::ExecuteScript ()
{
    TCHAR achCommand[256], achString[256];
    LONG cch, lLine;
    DWORD dwStart, dwEnd;
    //HWND hwndAct;
        
    // Retrieve current cursor position
    SendMessage(_hwndText, EM_GETSEL,(WPARAM) &dwStart, (LPARAM) &dwEnd); 
    
    // Retrieve current line index
    lLine = SendMessage(_hwndText, EM_LINEFROMCHAR,(WPARAM) dwStart, 0);
    
    // Retrieve line text
    achCommand[0] = (TCHAR) ARRAY_SIZE(achCommand)-1; 
    cch = SendMessage(_hwndText, EM_GETLINE, lLine, (LPARAM)achCommand);

    // if the end of the buffer has been overwritten!!!
    Assert(cch < ARRAY_SIZE(achCommand)-1);

    achCommand[cch] = TEXT('\0');

    // Replace ? at start of script by PrintDebug command
    cch = 0;

    while (achCommand[cch] == TEXT(' '))
        cch++;

    if (achCommand[cch] == TEXT('?')) 
    {
        wcscpy(achString,TEXT ("PrintDebug"));
        wcscat(achString,achCommand + 1);
        wcscpy(achCommand,achString);
    }
            
    // Move cursor to next line, creating one if necessary
    NextLine();
            
    // ISSUE: chrisf - necessary if SendKeys goes to focus window
    //hwndAct = SetActiveWindow(_pDoc->_hwnd);

    IGNORE_HR(_pDoc->ExecuteTopLevelScriptlet(achCommand));
    
    //SetActiveWindow(hwndAct);

    return 0;
}


LRESULT CALLBACK
CDebugWindow::DebugTextWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    
    switch (wm)
    {
    case WM_CHAR :
        if (wParam == '\r')      //carriage return
        {
            return pDebug->ExecuteScript();
        }
        break;
    }

    return CallWindowProc(pDebug->_wpOrigEditProc, hwnd, wm, wParam, lParam); 
   
}

HRESULT
CDebugWindow::Print(BSTR PrintValue)
{
    LONG lLine;
    LONG lLineLength;
    LONG lLineStart;
    DWORD dwStart, dwEnd;

    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(_hwnd, GWLP_USERDATA);

    // Get cursor position
    SendMessage(pDebug->_hwndText, EM_GETSEL, (WPARAM) &dwStart, (LPARAM) &dwEnd); 
    
    // Retrieve line at cursor position
    lLine = SendMessage (pDebug->_hwndText, EM_LINEFROMCHAR, (WPARAM) dwStart, 0);
    
    // Retrieve line start and length
    lLineLength = SendMessage(_hwndText, EM_LINELENGTH, (WPARAM) dwStart, 0);
    lLineStart = SendMessage(_hwndText, EM_LINEINDEX, (WPARAM) lLine, 0);

    // Selection entire line
    SendMessage(_hwndText, EM_SETSEL, lLineStart, lLineStart + lLineLength);
    
    // And replace with string to print
    SendMessage(
        pDebug->_hwndText, EM_REPLACESEL, 0, LPARAM( STRVAL( PrintValue ) ) );

    // Then move to next line
    NextLine();
    
    return S_OK;
}

HRESULT
CDebugWindow::NextLine()
{ 
    DWORD dwStart, dwEnd;
    LONG lLine, lLineLength, lLineStart;
    LONG lCount;

    lCount = SendMessage(_hwndText, EM_GETLINECOUNT,0, 0L);
    SendMessage(_hwndText, EM_GETSEL, (WPARAM) &dwStart, (LPARAM) &dwEnd); 
    lLine = SendMessage(_hwndText, EM_LINEFROMCHAR, (WPARAM) dwStart, 0);
    lLineLength = SendMessage(_hwndText, EM_LINELENGTH, (WPARAM) dwStart, 0);
    lLineStart = SendMessage(_hwndText, EM_LINEINDEX, (WPARAM) lLine, 0);

    if (lLine + 1 < lCount)
    {
        SendMessage(_hwndText, EM_SETSEL, lLineStart + lLineLength + 2, lLineStart + lLineLength + 2);
    }
    else
    {
        SendMessage(_hwndText, EM_SETSEL, lLineStart + lLineLength, lLineStart + lLineLength);
        CallWindowProc(_wpOrigEditProc, _hwndText, WM_CHAR, '\r', 1); 
    }

    return S_OK;
}


LRESULT
CDebugWindow::DebugWindowOnClose()
{
    ::ShowWindow(_hwnd, SW_HIDE);
    return 0;
}


LRESULT CALLBACK
CDebugWindow::WndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{

    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (wm)
    {
    case WM_NCCREATE:
        {
            pDebug = (CDebugWindow *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDebug);
            pDebug->_hwnd = hwnd;
        }
        break;
    case WM_NCDESTROY:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            pDebug->_pDoc->_pDebugWindow = NULL;
            delete pDebug;
        }
        break;
    case WM_CLOSE:
        pDebug->DebugWindowOnClose();
        return 0;
    case WM_SIZE:
        ::MoveWindow (pDebug->_hwndText,0,0,LOWORD (lParam), HIWORD (lParam), TRUE);
        return 0;
    case WM_ACTIVATE:
        if(wParam != WA_INACTIVE)
        {
            SetFocus(pDebug->_hwndText);
        }
        return 0;
    }
    return DefWindowProc(hwnd, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padbox.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padbox.cxx
//
//  Contents:   Implements control palette.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

static BOOL s_fWndClassRegistered = FALSE;

static void CheckButton(int ici);

static const CLSID CLSID_SuperLabel = {0x67EEB7C3L,0x6242,0x11CF,0xA0,0xC0,0x00,0xAA,0x00,0x62,0xBE,0x57};

static const struct CLASSINFO
{
    const CLSID *   pclsid;
    int             idr;
}
s_aci[] =
{
    { &CLSID_NULL, IDR_SELECT_TOOL },
    { &CLSID_HTMLImg, IDR_IMAGE_TOOL },
    { &CLSID_HTMLInputElement, IDR_BUTTON_TOOL },
    { &CLSID_HTMLInputElement, IDR_TEXTBOX_TOOL },
    { &CLSID_HTMLListElement, IDR_LISTBOX_TOOL },
    { &CLSID_HTMLInputElement, IDR_CHECKBOX_TOOL },
    { &CLSID_HTMLInputElement, IDR_RADIOBUTTON_TOOL },
    { &CLSID_HTMLDivPosition, IDR_TEXTSITE_TOOL },
};

//+------------------------------------------------------------------------
//
//  Class:   CControlPaletteService
//
//-------------------------------------------------------------------------

class CControlPaletteService : public IControlPalette
{
public:
    CControlPaletteService();
    ~CControlPaletteService();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IControlPalette methods

    STDMETHOD(SetCursor)();
    STDMETHOD(GetData)(IDataObject **ppDO);
    STDMETHOD(DataUsed)();

    // Data members

    ULONG   _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Class:   CControlPaletteData
//
//-------------------------------------------------------------------------

class CControlPaletteData : public IDataObject, public IDropSource
{
public:
    CControlPaletteData(const CLSID *pclsid);
    ~CControlPaletteData();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IDataObject methods

    STDMETHOD(GetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium);
    STDMETHOD(GetDataHere)(FORMATETC * pformatetc, STGMEDIUM * pmedium);
    STDMETHOD(QueryGetData)(FORMATETC * pfe);
    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC * pformatetc, FORMATETC * pformatetcOut);
    STDMETHOD(SetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, IEnumFORMATETC ** ppenum);
    STDMETHOD(DAdvise)(FORMATETC * pformatetc, DWORD advf, IAdviseSink * pAdvSink, DWORD * pdwConnection);
    STDMETHOD(DUnadvise)(DWORD dwConnection);
    STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** ppenumAdvise);

    // IDropSource methods

    STDMETHOD(QueryContinueDrag)(BOOL fEscPressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

    // Data members

    ULONG _ulRefs;
    CLSID _clsid;
};

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::CControlPaletteService
//
//-------------------------------------------------------------------------

CControlPaletteService::CControlPaletteService()
{
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::~CControlPaletteService
//
//-------------------------------------------------------------------------

CControlPaletteService::~CControlPaletteService( )
{
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IControlPalette)
    {
        *ppv = (IControlPalette *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::AddRef, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteService::AddRef()
{
    return _ulRefs += 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::Release, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteService::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::SetCursor, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::SetCursor()
{
    if (s_iciChecked == 0)
    {
        return S_FALSE;
    }
    else
    {
        ::SetCursor(LoadCursor(NULL, IDC_CROSS));
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::GetData, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::GetData(IDataObject **ppDO)
{
    CControlPaletteData *pData = NULL;

    if (s_iciChecked == 0)
    {
        *ppDO = NULL;
        return S_FALSE;
    }
    else
    {
        *ppDO = new CControlPaletteData(s_aci[s_iciChecked].pclsid);
        RRETURN(*ppDO == NULL ? E_OUTOFMEMORY : S_OK);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::DataUsed, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::DataUsed()
{
    CheckButton(0);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::CControlPaletteData
//
//-------------------------------------------------------------------------

CControlPaletteData::CControlPaletteData(const CLSID *pclsid)
{
    _ulRefs = 1;
    _clsid = *pclsid;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::~CControlPaletteData
//
//-------------------------------------------------------------------------

CControlPaletteData::~CControlPaletteData( )
{
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDataObject)
    {
        *ppv = (IDataObject *) this;
    }
    else if (iid == IID_IDropSource)
    {
        *ppv = (IDropSource *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::AddRef, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteData::AddRef()
{
    return _ulRefs += 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::Release, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteData::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryContinueDrag, IDropSource
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryContinueDrag(BOOL fEscPressed, DWORD grfKeyState)
{
    if (fEscPressed)
    {
        return DRAGDROP_S_CANCEL;
    }

    if (!((grfKeyState & MK_LBUTTON) || (grfKeyState & MK_RBUTTON)))
    {
        return DRAGDROP_S_DROP;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryContinueDrag, IDropSource
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GiveFeedback(DWORD dwEffect)
{
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetData(FORMATETC * pfe, STGMEDIUM * pmedium)
{
    HRESULT     hr = S_OK;
    void *      ptr;
#ifdef _MAC
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif

    TCHAR       tszClsid[MAX_PATH] = _T("");

    if (pfe->cfFormat == s_cfCLSID &&
        pfe->dwAspect == DVASPECT_CONTENT &&
        pfe->tymed == TYMED_HGLOBAL)
    {
        hr = THR(Format (
            0, tszClsid, MAX_PATH,
            _T("<0g>"),
            &_clsid));
        if (!OK(hr))
            goto Cleanup;

        *phdl = GlobalAlloc(
            GMEM_SHARE | GMEM_MOVEABLE, 
            (CLSID_STRLEN+1)*sizeof(TCHAR));
        if (*phdl == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

#ifndef _MAC
        ptr = GlobalLock(*phdl);
        memcpy((void *) ptr, tszClsid, (CLSID_STRLEN+1)*sizeof(TCHAR));
        GlobalUnlock(*phdl);
#else
        ptr = GlobalLock(*phdl)
        memcpy(ptr, ptszClsid, (CLSID_STRLEN+1)*sizeof(TCHAR));
        GlobalUnlock(*phdl);
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif
    }
    else
    {
        hr = DV_E_FORMATETC;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetDataHere, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetDataHere(FORMATETC * pformatetc, STGMEDIUM * pmedium)
{
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryGetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryGetData(FORMATETC * pfe)
{
    HRESULT hr;

    if (pfe->cfFormat == s_cfCLSID &&
        pfe->dwAspect == DVASPECT_CONTENT &&
        pfe->tymed == TYMED_HGLOBAL)
    {
        hr = S_OK;
    }
    else
    {
        hr = DV_E_FORMATETC;
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetCanonicalFormatEtc, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetCanonicalFormatEtc(
        FORMATETC * pformatetc,
        FORMATETC * pformatetcOut)
{
    pformatetcOut = NULL;
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::SetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::SetData(
        FORMATETC * pformatetc,
        STGMEDIUM * pmedium,
        BOOL fRelease)
{
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::EnumFormatEtc, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenum)
{
    *ppenum = NULL;
    return E_UNEXPECTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::DAdvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::DAdvise(
        FORMATETC * pformatetc,
        DWORD advf,
        IAdviseSink * pAdvSink,
        DWORD * pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::DUnadvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::EnumDAdvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::EnumDAdvise(IEnumSTATDATA ** ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

static void
CheckButton(int ici)
{
    if (s_hwndBar && ici != s_iciChecked)
    {
        SendMessage(s_hwndBar, TB_CHECKBUTTON, ici, MAKELONG(TRUE, 0));
        s_iciChecked = ici;
    }
}

static LRESULT
FrameOnCommand(WORD wNotifyCode, WORD ici, HWND hwndCtl)
{
    // Get out if it does not look like one of our commands.
    if (hwndCtl != s_hwndBar)
        return 0;

    s_iciChecked = ici;

    return 0;
}

static LRESULT
FrameOnClose()
{
    ShowWindow(s_hwndFrame, SW_HIDE);
    return 0;
}

LRESULT
FrameOnNCHitTest(WPARAM wParam, LPARAM lParam)
{
    LRESULT l;

    l = DefWindowProc(s_hwndFrame, WM_NCHITTEST, wParam, lParam);
    switch (l)
    {
    case HTTOPLEFT:
    case HTBOTTOMLEFT:
    case HTLEFT:
    case HTTOPRIGHT:
    case HTBOTTOMRIGHT:
    case HTRIGHT:
    case HTTOP:
    case HTBOTTOM:
        // Force fixed size window.
        l = HTCAPTION;
        break;
    }

    return l;
}

#if !defined(UNIX)
static LRESULT
FrameOnNotify(int idCtrl, NMHDR *pnmhdr)
{
    TBBUTTON    tbb;
    DWORD       dw;

    if (pnmhdr->hwndFrom == s_hwndBar)
    {
        if (pnmhdr->code == TBN_BEGINDRAG)
        {
            SendMessage(pnmhdr->hwndFrom,
                    TB_GETBUTTON,
                    ((TBNOTIFY *)pnmhdr)->iItem,
                    (LPARAM)&tbb);
            s_iciDrag = tbb.idCommand;
            dw = GetMessagePos();
            s_ptsDrag = MAKEPOINTS(dw);
        }
        else if (pnmhdr->code == TBN_ENDDRAG)
        {
            s_iciDrag = 0;
        }
    }

    return DefWindowProc(s_hwndFrame, WM_NOTIFY, idCtrl, (LPARAM)pnmhdr);
}
#endif

static LRESULT CALLBACK
FrameWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_COMMAND:
        return FrameOnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                              GET_WM_COMMAND_ID(wParam, lParam), 
                              GET_WM_COMMAND_HWND(wParam, lParam));

    case WM_CLOSE:
        return FrameOnClose();

    case WM_NCHITTEST:
        return FrameOnNCHitTest(wParam, lParam);

#if !defined(UNIX)
    case WM_NOTIFY:
        return FrameOnNotify(wParam, (NMHDR *)lParam);
#endif

    default:
        return DefWindowProc(hwnd, wm, wParam, lParam);
    }
}

static LRESULT
BarOnMouseMove(WORD fwKeys, int xPos, int yPos)
{
    POINTS      pts;
    DWORD       dwEffect;
    CControlPaletteData *  pData;
    DWORD       dw;
    POINTS      ptsDrag = s_ptsDrag;

    if (s_iciDrag != 0)
    {
        dw = GetMessagePos();
        pts = MAKEPOINTS(dw);
        if (pts.x < ptsDrag.x - 2 ||
            pts.x > ptsDrag.x + 2 ||
            pts.y < ptsDrag.y - 2 ||
            pts.y > ptsDrag.y + 2)
        {
            Verify(pData = new CControlPaletteData(s_aci[s_iciDrag].pclsid));
            if (pData)
            {
#if DBG==1
                Assert(!TLS(fHandleCaptureChanged));
#endif
                ReleaseCapture();
                CheckButton(s_iciDrag);
                s_iciDrag = 0;
                IGNORE_HR(DoDragDrop(pData, pData, DROPEFFECT_COPY|DROPEFFECT_MOVE, &dwEffect));
                pData->Release();
                CheckButton(0);
            }
        }
    }

    return s_pfnBarWndProc(s_hwndBar, WM_MOUSEMOVE, fwKeys, MAKELONG(xPos, yPos));
}

static LRESULT CALLBACK
BarWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_MOUSEMOVE:
        return BarOnMouseMove(wParam, LOWORD(lParam), HIWORD(lParam));

    default:
        return s_pfnBarWndProc(hwnd, wm, wParam, lParam);
    }
}

static BOOL
InitControlPalette()
{
    WNDCLASS    wc;
    TCHAR       achKey[MAX_PATH];
    TCHAR       achValue[MAX_PATH];
    TCHAR *     pch;
    long        cb;
    int         idr;
    TBADDBITMAP tbab;
    TBBUTTON    tbb;
    int         i, c;
    HINSTANCE   hinst;
    RECT        rc, rcBar;

    s_cfCLSID = RegisterClipboardFormatA("MS Forms CLSID");

    if (!s_fWndClassRegistered)
    {
        LOCK_GLOBALS;

        if (!s_fWndClassRegistered)
        {
            memset(&wc, 0, sizeof(wc));
            wc.style = NULL;
            wc.lpfnWndProc = FrameWndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" CP Frame");

            if (!RegisterClass(&wc))
                return FALSE;
                                  
            if (!GetClassInfo(NULL, TOOLBARCLASSNAME, &wc))
                return FALSE;

            s_pfnBarWndProc = wc.lpfnWndProc;
            wc.lpfnWndProc = BarWndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" CP ToolBar");

            if (!RegisterClass(&wc))
                return FALSE;

            s_fWndClassRegistered = TRUE;
        }
    }

    s_hwndFrame = CreateWindowEx(
            WS_EX_TOOLWINDOW,
            SZ_APPLICATION_NAME TEXT(" CP Frame"),
            TEXT("Controls"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            0, 0,
            s_hwndOwner,
            NULL,
            g_hInstCore,
            NULL);

    if (!s_hwndFrame)
        return FALSE;

    s_hwndBar = CreateWindowEx(
            0,
            SZ_APPLICATION_NAME TEXT(" CP Toolbar"),
            (LPCTSTR) NULL,
            CCS_NODIVIDER |
                TBSTYLE_WRAPABLE |
                WS_CHILD | WS_VISIBLE,
            0, 0, 0, 0,
            s_hwndFrame,
            (HMENU) 0,
            g_hInstCore,
            NULL);
    if (!s_hwndBar)
        return FALSE;

    SendMessage(s_hwndBar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);

    _tcscpy(achKey, TEXT("CLSID\\"));

    c = 0;
    for (i = 0; i < ARRAY_SIZE(s_aci); i++)
    {
        if (s_aci[i].idr)
        {
            tbab.hInst = g_hInstResource;
            tbab.nID   = s_aci[i].idr;
            tbb.iBitmap = SendMessage(s_hwndBar, TB_ADDBITMAP, 1, (WPARAM) &tbab);
            tbb.idCommand = i;
            tbb.fsState = TBSTATE_ENABLED;
            if (i == 0)
            {
                tbb.fsState |= TBSTATE_CHECKED;
            }
            tbb.fsStyle = TBSTYLE_CHECK | TBSTYLE_CHECKGROUP;
            tbb.dwData = 0;
            tbb.iString = 0;
            SendMessage(s_hwndBar, TB_ADDBUTTONS, 1, (LPARAM) &tbb);
        }
        else
        {
            Verify(StringFromGUID2(*s_aci[i].pclsid, &achKey[6], ARRAY_SIZE(achKey) - 6));
            _tcscat(achKey, TEXT("\\ToolboxBitmap32"));

            cb = sizeof(achValue);
            if (RegQueryValue(HKEY_CLASSES_ROOT, achKey, achValue, &cb))
                continue;

            pch = _tcschr(achValue, TEXT(','));
            if (pch)
            {
                *pch++ = TEXT('\0');
                idr = (int)_tcstol(pch, NULL, 10);
            }
            else
            {
                idr = 0;
            }

            hinst = LoadLibraryEx(achValue, NULL, DONT_RESOLVE_DLL_REFERENCES);
            if (!hinst)
                continue;

            tbab.hInst = hinst;
            tbab.nID   = idr;
            tbb.iBitmap = SendMessage(s_hwndBar, TB_ADDBITMAP, 1, (WPARAM) &tbab);
            tbb.idCommand = i;
            tbb.fsState = TBSTATE_ENABLED;
            tbb.fsStyle = TBSTYLE_CHECK | TBSTYLE_CHECKGROUP;
            tbb.dwData = 0;
            tbb.iString = 0;
            SendMessage(s_hwndBar, TB_ADDBUTTONS, 1, (LPARAM) &tbb);

            c += 1;

            FreeLibrary(hinst);
        }
    }

    SendMessage(s_hwndBar, TB_SETROWS, MAKEWPARAM((c + 2) / 3, TRUE), (LPARAM)&rcBar);

    rc = rcBar;

    AdjustWindowRectEx(&rc,
            WS_OVERLAPPEDWINDOW,
            FALSE,
            WS_EX_TOOLWINDOW);

    SetWindowPos(s_hwndFrame,
            NULL,
            0, 0,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    SetWindowPos(s_hwndBar,
            NULL,
            0, 0,
            rcBar.right - rcBar.left,
            rcBar.bottom - rcBar.top,
            SWP_NOZORDER | SWP_NOACTIVATE);

    s_fInitialized = TRUE;

    return TRUE;
}

void
DeinitControlPalette()
{
    if (s_hwndFrame)
    {
        DestroyWindow(s_hwndFrame);
    }
}

BOOL
IsControlPaletteVisible()
{
    return s_hwndFrame && IsWindowVisible(s_hwndFrame);
}

void
ToggleControlPaletteVisibility()
{
    if (!s_fInitialized)
    {
        if (!InitControlPalette())
            return;
    }

    ShowWindow(s_hwndFrame, IsControlPaletteVisible() ? SW_HIDE : SW_SHOW);
}

void
SetControlPaletteOwner(HWND hwnd)
{
    s_hwndOwner = hwnd;
}

HRESULT
GetControlPaletteService(REFIID iid, void **ppv)
{
    HRESULT hr;
    CControlPaletteService *pService;

    pService = new CControlPaletteService();
    if (pService == NULL)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pService->QueryInterface(iid, ppv));

    pService->Release();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padbsc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padbsc.cxx
//
//  Contents:   CPadBSC class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

DeclareTag(tagPadBSC, "PadBSC", "Bind status callback")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadBSC, CPadDoc, PadDoc, _BSC);

HRESULT
CPadBSC::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CPadBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pBinding)
{
    TraceTag((tagPadBSC, "OnStartBinding %08x", grfBSCOption));
    ReplaceInterface(&PadDoc()->_pBinding, pBinding);
    return S_OK;
}

HRESULT
CPadBSC::GetPriority(LONG *pnPriority)
{
    TraceTag((tagPadBSC, "GetPriority"));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnLowResource(DWORD reserved)
{
    TraceTag((tagPadBSC, "OnLowResource"));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnProgress(
    ULONG ulProgress, 
    ULONG ulProgressMax, 
    ULONG ulStatusCode, 
    LPCWSTR pchStatusText)
{
    TCHAR achBuf[MAX_PATH];
    static TCHAR *s_apch[] =
    {
        NULL,                               // 0
        TEXT("Finding resource <0s>"),      // 1
        TEXT("Connecting to <0s>"),         // 2
        TEXT("Redirecting <0s>"),           // 3
        TEXT("Downloading <0s>"),           // 4
        TEXT("Downloading <0s>"),           // 4
        NULL,                               // 6
        TEXT("Downloading components for <0s>"), // 7
        TEXT("Installing components for <0s>"),  // 8
        TEXT("Downloading <0s>"),                // 9
    };

    TraceTag((tagPadBSC, "OnProgress cur=%d, max=%d, status=%d", ulProgress, ulProgressMax, ulStatusCode));

    if (ulStatusCode < ARRAY_SIZE(s_apch) && s_apch[ulStatusCode])
    {
        Verify(!Format(0, achBuf, ARRAY_SIZE(achBuf),
                s_apch[ulStatusCode],
                pchStatusText));
        PadDoc()->SetStatusText(achBuf);
    }

    RRETURN(S_OK);
}

HRESULT
CPadBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    TraceTag((tagPadBSC, "OnStopBinding hr=%hr", hresult));

    if (PadDoc()->_pBCtx)
    {
        THR(RevokeBindStatusCallback(PadDoc()->_pBCtx, &PadDoc()->_BSC));
        ClearInterface(&PadDoc()->_pBCtx);
    }
    ClearInterface(&PadDoc()->_pBinding);
    return S_OK;
}

HRESULT
CPadBSC::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo)
{
    TraceTag((tagPadBSC, "GetBindInfo"));

    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;
    
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    if (pbindinfo)
    {
        DWORD cbSize = pbindinfo->cbSize;
        memset(pbindinfo, 0, cbSize);
        pbindinfo->cbSize = cbSize;

        pbindinfo->dwBindVerb = BINDVERB_GET;
    }
    return S_OK;
}

HRESULT
CPadBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM  *pstgmed)
{
    TraceTag((tagPadBSC, "OnDataAvailable grfBSCF=%08x, size=%d", grfBSCF, dwSize));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnObjectAvailable(REFIID iid, IUnknown *pUnk)
{
    PerfLog(tagPerfWatchPad, this, "+CPadBSC::OnObjectAvailable");

    HRESULT         hr = S_OK;
    IOleObject *    pObject = NULL;

    TraceTag((tagPadBSC, "OnObjectAvailable"));

    if (PadDoc()->_pBinding)
    {
        hr = THR(pUnk->QueryInterface(IID_IOleObject, (void **)&pObject));
        if (hr)
            goto Cleanup;

        hr = THR(PadDoc()->Activate(pObject));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pObject);
    PerfLog(tagPerfWatchPad, this, "-CPadBSC::OnObjectAvailable");
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padconst.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padconst.cxx
//
//  Contents:   CPadScriptSite
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadScriptConst, CPadDoc, PadDoc, _ScriptConst);

static HRESULT
LookupSymbol(ITypeComp *pTypeComp, TCHAR *pch, long *pl)
{
    HRESULT     hr;
    ITypeInfo * pTypeInfo = NULL;
    DESCKIND    desckind = DESCKIND_NONE;
    BINDPTR     bindptr;

    hr = THR(pTypeComp->Bind(
            pch, 
            0, 
            INVOKE_PROPERTYGET, 
            &pTypeInfo,
            &desckind,
            &bindptr));
    if (hr)
        goto Cleanup;

    if (desckind != DESCKIND_VARDESC || 
        bindptr.lpvardesc->varkind != VAR_CONST ||
        bindptr.lpvardesc->lpvarValue->vt != VT_I4)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    *pl = V_I4(bindptr.lpvardesc->lpvarValue);

Cleanup:
    switch (desckind)
    {
    case DESCKIND_FUNCDESC:
        pTypeInfo->ReleaseFuncDesc(bindptr.lpfuncdesc);
        break;

    case DESCKIND_VARDESC:
        pTypeInfo->ReleaseVarDesc(bindptr.lpvardesc);
        break;

    case DESCKIND_TYPECOMP:
        ReleaseInterface(bindptr.lptcomp);
        break;

    case DESCKIND_IMPLICITAPPOBJ:
        Assert(0 && "What is this?");
        break;
    }

    ReleaseInterface(pTypeInfo);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::QueryInterface
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPadScriptConst::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IDispatch ||
        iid == IID_IUnknown)
    {
        *ppv = (IDispatch*)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    Assert(FALSE);
    return E_FAIL;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 0;
    return S_OK;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT     hr;
    int         i;

    hr = THR(PadDoc()->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    for (i = 0; i < ARRAY_SIZE(PadDoc()->_apTypeComp); i++)
    {
        hr = THR_NOTRACE(LookupSymbol(PadDoc()->_apTypeComp[i], rgszNames[0], rgdispid));
        if (!hr)
            break;
    }

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::Invoke(DISPID dispidMember, 
                        REFIID riid, 
                        LCID lcid, 
                        WORD wFlags,
                        DISPPARAMS * pdispparams, 
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo, 
                        UINT * puArgErr)
{
    HRESULT hr = S_OK;
    
    if(!(wFlags & DISPATCH_PROPERTYGET))
        return DISP_E_MEMBERNOTFOUND;

    pvarResult->vt = VT_I4;
    pvarResult->lVal = dispidMember;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padframe.cxx
//
//  Contents:   CPadFrame class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadFrame, CPadDoc, PadDoc, _Frame);

STDMETHODIMP
CPadFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


STDMETHODIMP
CPadFrame::GetWindow(HWND * phWnd)
{
    *phWnd = PadDoc()->_hwnd;
    return S_OK;
}


STDMETHODIMP
CPadFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadFrame::GetBorder(LPOLERECT prcBorder)
{
    RECT rc;
    PadDoc()->GetViewRect(&rc, FALSE);
    CopyRect(prcBorder, &rc);
    return S_OK;
}


STDMETHODIMP
CPadFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    // Always try to grant the space, delay the actual BorderSpace checks to
    // SetBorderSpace.

    RRETURN(S_OK);
}


STDMETHODIMP
CPadFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    RECT         rcCurrentSize;
    BORDERWIDTHS bw;

    if (pbw == NULL) // in-place object is not interested in tools.
    {
        memset(&bw, 0, sizeof(bw));
        pbw = &bw;
    }

    PadDoc()->GetViewRect(&rcCurrentSize, TRUE);

    // If the requested border space is larger than the current window size, no space can be given.

    if (((rcCurrentSize.bottom - rcCurrentSize.top) <= (pbw->top + pbw->bottom)) ||
        ((rcCurrentSize.right - rcCurrentSize.left) <= (pbw->left + pbw->right)))
    {
        RRETURN(INPLACE_E_NOTOOLSPACE);
    }

    // Record the requested in-place toolbar border space and re-set the client window area size.

    PadDoc()->_bwToolbarSpace = *pbw;
    PadDoc()->Resize(); // We must call this here for the doc-obj to resize itself.

    RRETURN(S_OK);
}


STDMETHODIMP
CPadFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    ReplaceInterface(&PadDoc()->_pInPlaceActiveObject, pActiveObj);
    return S_OK;
}


STDMETHODIMP
CPadFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    return PadDoc()->InsertMenus(hmenuShared, pmgw);
}


STDMETHODIMP
CPadFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return S_OK;
}


STDMETHODIMP
CPadFrame::RemoveMenus(HMENU hmenuShared)
{
    while (GetMenuItemCount(hmenuShared) > 0)
    {
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);
    }

    return S_OK;
}


STDMETHODIMP
CPadFrame::SetStatusText(LPCTSTR szStatusText)
{
    PadDoc()->SetStatusText(szStatusText);
    return S_OK;
}


STDMETHODIMP
CPadFrame::EnableModeless(BOOL fEnable)
{
    //  TODO should probably disable ourselves?
    return S_OK;
}


STDMETHODIMP
CPadFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padfact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padfact.cxx
//
//  Contents:   Class factories.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

CPadFactory * CPadFactory::s_pFactoryFirst = NULL;

CPadFactory::CPadFactory(REFCLSID clsid, HRESULT (*pfnCreate)(IUnknown **), void (*pfnRevoke)())
{
    _pfnCreate = pfnCreate;
    _pfnRevoke = pfnRevoke;
    _clsid = clsid;
    _dwRegister = 0;
    _pFactoryNext = s_pFactoryFirst;
    s_pFactoryFirst = this;
}

HRESULT 
CPadFactory::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}
    

ULONG 
CPadFactory::AddRef()
{
    return 0;
}

ULONG 
CPadFactory::Release()
{
    return 0;
}

HRESULT
CPadFactory::CreateInstance(
        IUnknown *pUnkOuter,
        REFIID   iid,
        void **  ppv)
{
    IUnknown *pUnk = NULL;
    HRESULT hr;
    
    if (pUnkOuter)
        RRETURN(CLASS_E_NOAGGREGATION);

    hr = THR(_pfnCreate(&pUnk));
    if (hr)
        goto Cleanup;

    hr = THR(pUnk->QueryInterface(iid, ppv));

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

HRESULT
CPadFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        IncrementObjectCount();
    }
    else
    {
        DecrementObjectCount();
    }

    return S_OK;
}

HRESULT
CPadFactory::Register()
{
    HRESULT hr;
    CPadFactory *pFactory;

    for (pFactory = s_pFactoryFirst; pFactory; pFactory = pFactory->_pFactoryNext)
    {
        hr = THR(CoRegisterClassObject(
            pFactory->_clsid,
            pFactory,
            CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE,
            &pFactory->_dwRegister));
        if (hr)
            RRETURN(hr);
    }

    return S_OK;
}

HRESULT
CPadFactory::Revoke()
{
    CPadFactory *pFactory;

    for (pFactory = s_pFactoryFirst; pFactory; pFactory = pFactory->_pFactoryNext)
    {
        if (pFactory->_dwRegister)
        {
            IGNORE_HR(CoRevokeClassObject(pFactory->_dwRegister));
            pFactory->_dwRegister = 0;

            if(pFactory->_pfnRevoke)
                (*pFactory->_pfnRevoke)();
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\paddoc.cxx ===
//------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddoc.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include "stdio.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include "platform.h"
#endif

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

#if CICERO==1

#ifndef X_HTMLUIM_I_C
#define X_HTMLUIM_I_C
#define __mshtml_h__	// HACKHACK: to prevent inclusion of mshtml.h
#include "htmluim_i.c"
#endif

#endif

extern "C" const GUID SID_SHTMLEditServices;
extern void DeinitTearOffCache();

BOOL g_fHiResAware = FALSE;
BOOL g_fUseHR = FALSE;

// This is here for testing print templates
//DYNLIB g_dynlibPrintHTML = { NULL, NULL, "mshtml.dll" };

extern void ScrubRegistry();
extern DYNLIB g_dynlibMSHTML;

DeclareTag(tagPadPositionPersist, "Pad", "Save last pad position to mshtmdbg.ini")
DeclareTag(tagPadNoSuspendForMessage, "Pad", "Don't Suspend/Resume CAP around PeekMessage/GetMessage")
DeclareTag(tagStatus, "Status",      "Write status line text to logfile")
DeclareTag(tagPalette, "Palette", "Trace Palette and ColorSet behaviour");
DeclareTag(tagSpanTag, "Edit",    "Insert span tags around block elements when editing")
DeclareTag(tagSpanTag2, "Edit",    "Insert span tags with compose settings outside")
DeclareTag(tagPPVTemplateOverride, "PrintPv", "Use TRIDENT_PPVPATH env var as print template")
PerfTag(tagPerfWatchPad, "Perf", "PerfWatch: Trace MSHTMPAD performance points")
ExternTag(tagPeerProvideTestBehaviors);
ExternTag(tagDefaultDIV);
ExternTag(tagDefault);
MtDefine(Pad, WorkingSet, "mshtmpad.exe")
MtDefine(CPadDoc, Pad, "CPadDoc")
MtDefine(CPadScriptSite, Pad, "CPadScriptSite")
MtDefine(CDebugWindow, Pad, "CDebugWindow")
MtDefine(CDebugDownloadNotify, Pad, "CDebugDownloadNotify")

//
// static to store the pointer to WndProc of ComboBox'es in Format Toolbar
//
static WNDPROC lpfnDefCombo;

// messages for zoom combo box in Standard Toolbar
#define WM_ZOOMRETURN   (WM_USER+1)
#define WM_ZOOMESCAPE   (WM_USER+2)
#define WM_ZOOMUP       (WM_USER+3)
#define WM_ZOOMDOWN     (WM_USER+4)

static FORMATETC s_FormatEtcMF =
    { (CLIPFORMAT) CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT };

BOOL  CPadDoc::s_fPadWndClassRegistered = FALSE;
BOOL  CPadDoc::s_fPaletteDevice;

extern DWORD WINAPI CreatePadDocThreadProc(void * pv);

int CALLBACK
FillFontProc(const LOGFONT *    lplf,
             const TEXTMETRIC * lptm,
             DWORD            iFontType,
             LPARAM           lParam);

static const ComboItem ComboColorItems[] =
{
    {IDS_COLOR_BLACK,      RGB(0, 0, 0)},
    {IDS_COLOR_NAVY,       RGB(0, 0, 128)},
    {IDS_COLOR_BLUE,       RGB(0, 0, 255)},
    {IDS_COLOR_CYAN,       RGB(0, 255, 255)},
    {IDS_COLOR_RED,        RGB(255, 0, 0)},
    {IDS_COLOR_LIME,       RGB(0, 255, 0)},
    {IDS_COLOR_GRAY,       RGB(128, 128, 128)},
    {IDS_COLOR_GREEN,      RGB(0, 128, 0)},
    {IDS_COLOR_YELLOW,     RGB(255, 255, 0)},
    {IDS_COLOR_PINK,       RGB(255, 192, 203)},
    {IDS_COLOR_VIOLET,     RGB(238, 130, 238)},
    {IDS_COLOR_WHITE,      RGB(255, 255, 255)},
    {0, 0L}
};

#define INDEX_ZOOM_100  4

static const ComboItem ComboZoomItems[] =
{
    {IDS_ZOOM_1000,         1000},  //  0
    {IDS_ZOOM_500,          500},   //  1
    {IDS_ZOOM_200,          200},   //  2
    {IDS_ZOOM_150,          150},   //  3
    {IDS_ZOOM_100,          100},   //  4
    {IDS_ZOOM_75,           75},    //  5
    {IDS_ZOOM_50,           50},    //  6
    {IDS_ZOOM_25,           25},    //  7
    {IDS_ZOOM_10,           10},    //  8
    {IDS_ZOOM_5,            5},     //  9
    {IDS_ZOOM_1,            1},     // 10
    {0, 0L}
};

char *
IntToString(int i)
{
    static char ach[32];
    wsprintfA(ach, "%d", i);
    return(ach);
}

BOOL
IsUrlPrefix(const TCHAR * pchPath)
{
    return(memcmp(pchPath, _T("file:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("http:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("https:"),        6 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("ftp:"),          4 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("gopher:"),       7 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("sock:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("about:"),        6 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("javascript:"),   11 * sizeof(TCHAR)) == 0 ||
           memcmp(pchPath, _T("vbscript:"),     9 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("mk:"),           3 * sizeof(TCHAR)) == 0);
}

HRESULT
GetOmDocumentFromDoc (IUnknown * pUnkDoc, IHTMLDocument2 ** ppOmDoc)
{
    HRESULT             hr;

    hr = THR(pUnkDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppOmDoc));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

static HRESULT
CreateDoc(IUnknown **ppUnk)
{
    CThreadProcParam tpp(FALSE, ACTION_NONE);

    RRETURN(THR(CreatePadDoc(&tpp, ppUnk)));
}

CPadFactory PadDocFactory(CLSID_Pad, CreateDoc);

CPadDoc::CPadDoc(BOOL fUseShdocvw)
  : _aryPadPointers( Mt( Mem ) ), _aryPadContainers( Mt( Mem ) )
{
    PADTHREADSTATE * pts = GetThreadState();

    IncrementObjectCount();
    _ulRefs = 1;
    _ulAllRefs = 1;
    _fUserMode = TRUE;  // start in browse mode
    _pBrowser = NULL;
    _fUseShdocvw = fUseShdocvw;
    _lViewChangesFired = 0;
    _lDataChangesFired = 0;
    _dwCookie = 0;
    _fToolbarDestroy = FALSE;
    _fComboLoaded = FALSE;
    _fToolbarhidden = TRUE;
    _fFormatInit = FALSE;
    _fStandardInit = FALSE;
    _palState = palUnknown;
    _idPadIDNext = 1;
    _fUpdateUI = TRUE;

    _pObjectHBI = NULL;

    //
    //  Add self to the head of the linked list of forms
    //
    _pDocNext = pts->pDocFirst;
    pts->pDocFirst = this;

    _hAccelerators = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_PAD_ACCELERATORS));

    _pScriptRecorder = new CDummyScriptRecorder;

    ::AddAtom(DOCHOSTUIATOM_ENABLE_HIRES);
#if CICERO==1
    _pCicero = NULL;
#endif // CICERO==1
}


CPadDoc::~CPadDoc( )
{
    PADTHREADSTATE * pts = GetThreadState();

    CPadDoc ** ppDoc;

    if (pts)
    {
        //  Remove from list of active documents
        for (ppDoc = &pts->pDocFirst; *ppDoc != NULL; ppDoc = &(*ppDoc)->_pDocNext)
        {
            if (*ppDoc == this)
            {
                *ppDoc = _pDocNext;
                break;
            }
        }
    }

    if (!_fDecrementedObjectCount)
    {
        DecrementObjectCount();
    }

    if (_hAccelerators)
        DestroyAcceleratorTable(_hAccelerators);

    delete _pScriptRecorder;

    ::DeleteAtom(::FindAtom(DOCHOSTUIATOM_ENABLE_HIRES));
    DeinitTearOffCache();
}



HRESULT
CPadDoc::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IDispatch)
    {
        HRESULT hr = CreateTearOffThunk(
            this,                                   // pvObject1
            *(void **)(IDispatch*)this,             // apfn1
            NULL,                                   // pUnkOuter
            ppvObj,                                 // ppvThunk
            &_Site,                                  // pvObject2
            *(void **)(IUnknown*)(IOleClientSite *)&_Site, // apfn2
            ADDREF_MASK | RELEASE_MASK,             // dwMask
            NULL);                                  // appropdescsInVtblOrder

        if (hr)
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (iid == IID_IPad || iid == IID_IUnknown)
    {
        *ppvObj = (IPad *)this;
    }
    else if (iid == IID_IOleObject)
    {
        *ppvObj = (IOleObject *)this;
    }
    else if (iid == IID_IOleContainer)
    {
        *ppvObj = (IOleContainer *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

ULONG
CPadDoc::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CPadDoc::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
        SubRelease();
        return 0;
    }

    return _ulRefs;
}

ULONG
CPadDoc::SubAddRef( )
{
    return ++_ulAllRefs;
}

ULONG
CPadDoc::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }
    return 0;
}


DYNPROC s_dynprocClearCache = { NULL, &g_dynlibMSHTML, "SvrTri_ClearCache" };
typedef void (WINAPI *PFN_SVRTRI_CLEARCACHE)();

void
CPadDoc::Passivate( )
{
    PFN_SVRTRI_CLEARCACHE  TRI_ClearCache;
    int i;

    for ( i = 0 ; i < _aryPadPointers.Size() ; i++ )
        _aryPadPointers[i]._pPointer->Release();

    for ( i = 0 ; i < _aryPadContainers.Size() ; i++ )
        _aryPadContainers[i]._pContainer->Release();

    PersistWindowPosition();

    if (    GetModuleHandleA("mshtml.dll")
        &&  OK(LoadProcedure(&s_dynprocClearCache)))
    {
        TRI_ClearCache = (PFN_SVRTRI_CLEARCACHE)s_dynprocClearCache.pfn;
        TRI_ClearCache();
    }

    CloseScripts();
    Deactivate();

    //
    // Some poorly behaved controls don't call OleSetMenuDescriptor when
    // cleaning up.  Do it now on behalf of them.
    //

    OleSetMenuDescriptor(NULL, _hwnd, NULL, &_Frame, NULL);

    ClearInterface(&_pObject);
    ClearInterface(&_pInPlaceObject);
    ClearInterface(&_pInPlaceActiveObject);
    ClearInterface(&_pTypeLibPad);
    ClearInterface(&_pTypeInfoCPad);
    ClearInterface(&_pTypeInfoIPad);
    ClearInterface(&_pTypeInfoILine);
    ClearInterface(&_pTypeInfoICascaded);
    ClearInterface(&_pTypeLibDLL);

    for ( i = 0; i < ARRAY_SIZE(_apTypeComp); i++)
    {
        ClearInterface(&_apTypeComp[i]);
    }

    ReleaseBindContext();

    DestroyToolbars();
    SetMenu(_hwnd, NULL);
    DestroyWindow(_hwnd);

    if(_pDebugWindow)
    {
        _pDebugWindow->Destroy();
    }

    if (!_fDecrementedObjectCount)
    {
        DecrementObjectCount();
        _fDecrementedObjectCount = TRUE;
    }

    if (_hpal)
    {
        DeleteObject(_hpal);
        _hpal = 0;
    }
    if ( _hmenuEdit )
    {
        ::DestroyMenu( _hmenuEdit );
        _hmenuEdit = NULL;
    }
    if ( _hmenuMain )
    {
        ::DestroyMenu( _hmenuMain );
        _hmenuMain = NULL;
    }
    if ( _hmenuHelp )
    {
        ::DestroyMenu( _hmenuHelp );
        _hmenuHelp = NULL;
    }

    delete _pScriptRecorder;
    _pScriptRecorder = NULL;

}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetWindowPosition
//
//  Synopsis:   Restore window position from c:\ef if tagPadPosition is set.
//
//----------------------------------------------------------------------------

void
CPadDoc::SetWindowPosition()
{
    if (GetPrivateProfileIntA("PadPosition", "RestorePosition", FALSE, "mshtmdbg.ini"))
    {
        RECT rc;
        rc.left = GetPrivateProfileIntA("PadPosition", "PadLeft", 0, "mshtmdbg.ini");
        rc.top = GetPrivateProfileIntA("PadPosition", "PadTop", 0, "mshtmdbg.ini");
        rc.right = GetPrivateProfileIntA("PadPosition", "PadRight", 800, "mshtmdbg.ini");
        rc.bottom = GetPrivateProfileIntA("PadPosition", "PadBottom", 600, "mshtmdbg.ini");
        MoveWindow(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::PersistWindowPosition
//
//  Synopsis:   Write the pad window's coordinates to c:\ef if
//              tagPadPositionPersist is set.
//
//----------------------------------------------------------------------------

void
CPadDoc::PersistWindowPosition()
{
    if (IsTagEnabled(tagPadPositionPersist))
    {
        RECT rc;
        GetWindowRect(_hwnd, &rc);

        WritePrivateProfileStringA("PadPosition", "RestorePosition", IntToString(TRUE), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadLeft", IntToString(rc.left), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadTop", IntToString(rc.top), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadRight", IntToString(rc.right), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadBottom", IntToString(rc.bottom), "mshtmdbg.ini");
    }
}

BOOL
CPadDoc::GetDirtyState()
{
    BOOL fDirty = FALSE;
    IPersistFile *pPF = NULL;

    if (!_pObject)
        return FALSE;

    if (OK(THR_NOTRACE(_pObject->QueryInterface(IID_IPersistFile, (void **)&pPF))))
    {
        // ISSUE: Netscape cannot dirty the document but it reports dirty
        if (_fNetscape)
        {
            fDirty = FALSE;
        }
        else
        {
            fDirty = THR(pPF->IsDirty()) == S_OK;
        }
        pPF->Release();
    }

    return fDirty;
}

HRESULT
CPadDoc::QuerySave(DWORD dwSaveOptions)
{
    if (!GetDirtyState())
        return S_OK;

    switch( dwSaveOptions )
    {
    default:
        Assert(FALSE);

    case SAVEOPTS_SAVEIFDIRTY:
        break;

    case SAVEOPTS_NOSAVE:
        return S_OK;

    case SAVEOPTS_PROMPTSAVE:
        switch (MessageBox(_hwnd,
                TEXT("Do you want to save the changes ?"),
                SZ_APPLICATION_NAME,
                MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL))
        {
        case IDYES:
            break;

        case IDNO:
            return S_OK;

        case IDCANCEL:
        default:
            return S_FALSE;
        }
    }

    return DoSave(FALSE);
}



HRESULT
CPadDoc::DoSave(BOOL fPrompt)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pCommandTarget = 0;

    // (jenlc) Save through URL has not been implemented yet.
    // Request users to SAVEAS fils.
    //
    if ( fPrompt || _fInitNew || _fOpenURL)
    {
        //  Have to do Save As...
        //  The trick is the user can cancel this
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            hr = pCommandTarget->Exec(
                    NULL,
                    OLECMDID_SAVEAS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);

            if ( hr )
                goto Cleanup;

            _fInitNew = FALSE;
        }
    }
    else
    {
        //  Save silently
        hr = THR(Save((TCHAR*)NULL));
    }

Cleanup:
    if ( hr == OLECMDERR_E_CANCELED )
    {
        hr = S_FALSE;
    }
    UpdateDirtyUI();
    ReleaseInterface(pCommandTarget);
    RRETURN1(hr, S_FALSE);
}


HRESULT
CPadDoc::PromptOpenFile(HWND hwnd, const CLSID * pclsid)
{
    HRESULT         hr;
    OPENFILENAME    ofn;
    BOOL            f;

    hr = QuerySave(SAVEOPTS_PROMPTSAVE);
    if (hr)
        RRETURN1(hr, S_FALSE);

    static TCHAR achPath[MAX_PATH] = _T("");
    static TCHAR achStartDir[MAX_PATH] = _T("");

#if !defined(WINCE)
    if (    !achPath[0]
        &&  !achStartDir[0]
        &&  GetEnvironmentVariable(_T("PAD_DEFAULTFILEDIR"), achStartDir, MAX_PATH))
    {
        if (_tcscmp(achStartDir, _T("CurrentDir")) == 0)
        {
            GetCurrentDirectory(MAX_PATH, achStartDir);
        }
    }
#endif

    if (!achPath[0] && !achStartDir[0])
    {
        char achStartDirA[MAX_PATH] = "";
        GetPrivateProfileStringA("PadDirs","FileDir","",achStartDirA,MAX_PATH, "mshtmdbg.ini");

        if (achStartDirA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achStartDirA, MAX_PATH, achStartDir, MAX_PATH);
        }
    }

    if (!achPath[0] && !achStartDir[0])
    {
        // Prime file name with samples directory.

        // Start with the directory containing this file.

        _tcscpy(achStartDir, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achPath.

        if ( ! _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR))) {
            achStartDir[0] = (TCHAR)0;

        } else {

            for (int i = 0; i < 4; i++)
                {
                    TCHAR *pch = _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR));
                    if (pch)
                        *pch = 0;
                }
        }

        // Append the name of the directory containing the samples.

        _tcscat(achStartDir, _T(FILENAME_SEPARATOR_STR) _T("src")
                             _T(FILENAME_SEPARATOR_STR) _T("f3")
                             _T(FILENAME_SEPARATOR_STR) _T("drt")
                             _T(FILENAME_SEPARATOR_STR) _T("samples"));
    }

    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd ? hwnd : _hwnd;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0RTF Documents (*.rtf)\0*.rtf\0Text files (*.txt)\0*.txt\0Dialogs (*.fmd)\0*.fmd\0All Files (*.*)\0*.*\0");
    ofn.lpstrFile = achPath;
    ofn.lpstrInitialDir = *achPath ? NULL : achStartDir;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ARRAY_SIZE(achPath);
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    DbgMemoryTrackDisable(TRUE);
    f = GetOpenFileName(&ofn);
    DbgMemoryTrackDisable(FALSE);

    if (!f)
        return S_FALSE;

    hr = _fUseShdocvw ? THR(OpenFile(achPath, NULL)) : ((!pclsid) ? THR(Open(achPath)) : THR(Open(*pclsid, achPath)));

    RRETURN(hr);
}

HRESULT
CPadDoc::PromptOpenURL(HWND hwnd, const CLSID *pclsid)
{
    TCHAR   achURL[MAX_PATH];
    HRESULT hr;

    hr = QuerySave(SAVEOPTS_PROMPTSAVE);
    if (hr)
        RRETURN1(hr, S_FALSE);

    if (!GetURL(hwnd ? hwnd : _hwnd, achURL, ARRAY_SIZE(achURL)))
        return S_FALSE;

    hr = _fUseShdocvw ? THR(OpenFile(achURL, NULL)) : ((!pclsid) ? THR(Open(achURL)) : THR(Open(*pclsid, achURL)));

    if (hr)
    {
        MessageBox(
            _hwnd,
            TEXT("Could not open the specified URL."),
            TEXT("Unable to open URL"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    return S_OK;
}

void
CPadDoc::ReleaseBindContext()
{
    if (_pBinding)
    {
        THR(_pBinding->Abort());
        ClearInterface(&_pBinding);
    }

    if (_pBCtx)
    {
        // TODO (dbau) rearrange so that RevokeBSC is called in BSC::OnStopBinding

        THR(RevokeBindStatusCallback(_pBCtx, &_BSC));

        ClearInterface(&_pBCtx);
    }
}

HRESULT
CPadDoc::InitializeBindContext()
{
    HRESULT hr;

    // Cleanup previous binding and bind context.

    ReleaseBindContext();

    // Create new bind context.

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &_pBCtx, 0));
    if (hr)
        goto Cleanup;

    hr = THR(RegisterBindStatusCallback(_pBCtx, &_BSC, NULL, 0));

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::Open(TCHAR *pchPath)
{
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Open");

    HRESULT         hr = S_OK;
    IOleObject *    pObject = NULL;
    ULONG           ulEaten;

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    // Shutdown the previous object.
    hr = Deactivate();
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(pchPath, TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(InitializeBindContext());
    if (hr)
        goto Cleanup;

    // Parse the text into a moniker. A single call to MkParseDisplayNameEx
    // should be all that it takes to handle this.  Due to bugs in
    // MkParseDisplayNameEx and the possiblity that URLMON.DLL is not
    // installed on the user's system, we have this more complicated code.

    if (IsUrlPrefix(pchPath))
    {
        DbgMemoryTrackDisable(TRUE);
        hr = THR(CreateURLMoniker(NULL, pchPath, &_pMk));
        DbgMemoryTrackDisable(FALSE);
    }
    else
    {
        hr = E_FAIL;
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    if (hr)
    {
        hr = THR(MkParseDisplayName(_pBCtx, pchPath, &ulEaten, &_pMk));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pBCtx->RegisterObjectParam(SZ_HTML_CLIENTSITE_OBJECTPARAM, (IUnknown *)((IOleClientSite *)&_Site)));
    if (FAILED(hr))
        goto Cleanup;

    // Register this moniker as the one that binds asynchronously.

    // Get the object.

    DbgMemoryTrackDisable(TRUE);
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Open BindToObject");
    hr = THR_NOTRACE(_pMk->BindToObject(_pBCtx, NULL, IID_IOleObject, (void **)&pObject));
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Open BindToObject");
    DbgMemoryTrackDisable(FALSE);

    if (FAILED(hr))
        goto Cleanup;

    Assert(hr == S_OK || hr == S_ASYNCHRONOUS);
    hr = S_OK;

    _fOpenURL = IsUrlPrefix(pchPath);
    _fInitNew = FALSE;
    _fUserMode = !_fInitNew;

    // If the binding is asynchronous, then we get the object
    // pointer in a later call to the bind status callback.

    if (pObject)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        hr = THR(Activate(pObject));
    }

Cleanup:
    ReleaseInterface(pObject);
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Open");
    RRETURN(hr);
}

HRESULT
CPadDoc::PopulateDrtNamespaces(IUnknown * punkDoc)
{
    HRESULT                     hr;
    IServiceProvider *          pServiceProvider = NULL;
    IElementNamespaceTable *    pTable = NULL;
    VARIANT                     varFactory;
    BSTR                        bstrNamespace1 = SysAllocString(_T("DRTNS1"));
    BSTR                        bstrNamespace2 = SysAllocString(_T("DRTNS2"));
    BSTR                        bstrNamespace3 = SysAllocString(_T("DRTNS3"));

    // get the table

    hr = THR(punkDoc->QueryInterface(IID_IServiceProvider, (void**) &pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(IID_IElementNamespaceTable, IID_IElementNamespaceTable, (void**) &pTable));
    if (hr)
        goto Cleanup;

    // prepare factory

    V_VT(&varFactory) = VT_UNKNOWN;
    hr = THR(_Site.QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varFactory)));
    if (hr)
        goto Cleanup;

    // add namespaces

    hr = THR(pTable->AddNamespace(bstrNamespace1, NULL, 0, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace2, NULL, ELEMENTNAMESPACEFLAGS_ALLOWANYTAG, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace3, NULL, ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS, &varFactory));
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pTable);
    VariantClear (&varFactory);
    SysFreeString(bstrNamespace1);
    SysFreeString(bstrNamespace2);
    SysFreeString(bstrNamespace3);

    RRETURN (hr);
}

HRESULT
CPadDoc::Open(REFCLSID clsid, TCHAR *pchPath)
{
    HRESULT                 hr;
    IPersistFile *          pPFile = NULL;
    IPersistStreamInit *    pPStm = NULL;
    IPersistMoniker *       pPMk = NULL;
    IPersistStorage *       pPStg = NULL;
    IStorage *              pStg = NULL;
    IOleObject   *          pObject = NULL;
    TCHAR *                 pchClass = NULL;
    IUnknown *              pUnk = NULL;
    DWORD                   dwFlags;
    BOOL                    fInitNew = _fInitNew;
    BOOL                    fUserMode = _fUserMode;
    BOOL                    fOpenURL = _fOpenURL;

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(pchPath, TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    //
    // *********** UGLY WORKAROUND TO ALLOW HOSTING OF Netscape ! (istvanc)**************
    //
    if (clsid == CLSID_NSCP)
    {
        _fNetscape = TRUE;
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            clsid,
            NULL,
            _fNetscape ? CLSCTX_LOCAL_SERVER :
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    _fInitNew = ((pchPath == NULL) || (*pchPath == 0)) && !(clsid == CLSID_WebBrowser);
    _fUserMode = !_fInitNew;
    _fOpenURL = pchPath && IsUrlPrefix(pchPath);

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        // Hack for IHostBehaviorInit testing
        _pObjectHBI = pObject;
        // End Hack
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    if (IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        IGNORE_HR(PopulateDrtNamespaces(pObject));
    }

    if (pchPath)
    {
        // NOTE: (alexz) please note that moniker should be created
        // regardless of if we use it in this routine or not; this moniker
        // will be used by GetMoniker function.

        hr = THR(CreateURLMoniker(NULL, pchPath, &_pMk));
        if (hr)
            goto Cleanup;

        if (IsUrlPrefix(pchPath))
        {
            hr = THR(pObject->QueryInterface(
                    IID_IPersistMoniker,
                    (void **)&pPMk));
            if (hr)
                goto Cleanup;

            hr = THR(pPMk->Load(FALSE, _pMk, NULL, STGM_READ));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pUnk->QueryInterface(
                    IID_IPersistFile,
                    (void **) &pPFile));
            if (hr)
                goto Cleanup;

            hr = THR(pPFile->Load(pchPath, 0));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR(pObject->QueryInterface(
                IID_IPersistStreamInit,
                (void **)&pPStm));
        if (OK(hr))
        {
            hr = THR(pPStm->InitNew());
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pObject->QueryInterface(
                    IID_IPersistStorage,
                    (void **)&pPStg));
            if (hr)
                goto Cleanup;

            hr = THR(StgCreateDocfile(
                    NULL,
                    STGM_READWRITE | STGM_DELETEONRELEASE | STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_TRANSACTED,
                    0,
                    &pStg));
            if (hr)
                goto Cleanup;

            hr = THR(pPStg->InitNew(pStg));
            if (hr)
                goto Cleanup;
        }
    }

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));
    if (hr)
        goto Cleanup;

    //  Reset Zooming
    ResetZoomPercent();

Cleanup:
    if (hr)
    {
        _fInitNew = fInitNew;
        _fUserMode = fUserMode;
        _fOpenURL = fOpenURL;
    }

    CoTaskMemFree(pchClass);
    ReleaseInterface(pUnk);
    ReleaseInterface(pObject);
    ReleaseInterface(pPFile);
    ReleaseInterface(pPStg);
    ReleaseInterface(pStg);
    ReleaseInterface(pPStm);
    ReleaseInterface(pPMk);
    RRETURN(hr);
}

HRESULT
CPadDoc::Deactivate()
{
    HRESULT hr = S_OK;
    CVariant varBool;

    // give events a chance to fire
    hr = THR_NOTRACE(ExecuteCommand(OLECMDID_ONUNLOAD, &varBool, NULL));
    if ((V_VT(&varBool) == VT_BOOL && !V_BOOL(&varBool)))
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (_hwndWelcome)
    {
        DestroyWindow(_hwndWelcome);
        _hwndWelcome = NULL;
    }

    if (_pInPlaceActiveObject)
    {
        IGNORE_HR(_pInPlaceObject->UIDeactivate());
    }

    if (_pInPlaceObject)
    {
        IGNORE_HR(_pInPlaceObject->InPlaceDeactivate());
    }

    if (_PNS._dwCookie)
    {
        DisconnectSink(_pObject, IID_IPropertyNotifySink, &_PNS._dwCookie);
        Assert(_PNS._dwCookie == 0);
    }

    if (_pObject)
    {
        IViewObject *pVO = NULL;

        if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
        {
            pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL);
            pVO->Release();
        }

        if (_dwCookie)
        {
            IDataObject *pDO = NULL;

            if (OK(_pObject->QueryInterface(IID_IDataObject, (void **)&pDO)))
            {
                pDO->DUnadvise(_dwCookie);
                pDO->Release();
            }

            _dwCookie = 0;
        }

        hr = THR(_pObject->Close(OLECLOSE_NOSAVE));
        if (hr)
            goto Cleanup;
    }

    ClearInterface(&_pBrowser);
    ClearInterface(&_pInPlaceObject);
    ClearInterface(&_pInPlaceActiveObject);
    ClearInterface(&_pObject);
    ClearInterface(&_pMk);

    _fOpenURL = FALSE;

    _lReadyState = READYSTATE_UNINITIALIZED;

Cleanup:
    //  Reset doc title
    SetDocTitle(NULL);

    RRETURN(hr);
}

HRESULT
CPadDoc::Activate(IOleObject *pObject)
{
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Activate");

    HRESULT hr;
    RECT rc;

    // Activate the new object.

    Assert(!_pObject);
    _pObject = pObject;
    _pObject->AddRef();

    IViewObject *pVO = NULL;

    if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
    {
        PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (IID_IViewObject Advise)");
        pVO->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, (IAdviseSink *)&_Site);
        pVO->Release();
    }

    IDataObject *pDO = NULL;

    if (OK(_pObject->QueryInterface(IID_IDataObject, (void **)&pDO)))
    {
        PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (IID_IDataObject Advise)");
        pDO->DAdvise(&s_FormatEtcMF, ADVF_NODATA, (IAdviseSink *)&_Site, &_dwCookie);
        pDO->Release();
    }

    GetViewRect(&rc, TRUE);

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (DoVerb OLEIVERB_SHOW)");
    hr = THR(_pObject->DoVerb(
            OLEIVERB_SHOW,
            NULL,
            &_Site,
            0,
            _hwnd,
            ENSUREOLERECT(&rc)));
    if (hr)
        goto Cleanup;

    Assert(_PNS._dwCookie == 0);

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (ConnectSink IID_IPropertyNotifySink)");
    hr = THR(ConnectSink(_pObject, IID_IPropertyNotifySink, &_PNS,
            &_PNS._dwCookie));
    if (hr)
        goto Cleanup;

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (UpdateToolbarUI)");
    UpdateToolbarUI();
    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (SetupComposeFont)");
    SetupComposeFont();
    // Use the correct default block element.
    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (SetupDefaultBlock)");
    SetupDefaultBlock();

Cleanup:
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Activate");
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDocPNS::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPadDocPNS, CPadDoc, _PNS)

STDMETHODIMP
CPadDocPNS::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDocPNS::OnChanged
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP CPadDocPNS::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
    {
        MyCPadDoc()->OnReadyStateChange();
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::OnReadyStateChange
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void CPadDoc::OnReadyStateChange()
{
    HRESULT     hr = S_OK;
    CVariant    Var;
    IDispatch * pdisp = NULL;
    LONG        lReadyState;

    _pObject->QueryInterface(IID_IDispatch, (void **)&pdisp);

    if (pdisp == NULL)
        return;

    hr = GetDispProp(pdisp, DISPID_READYSTATE, 0, &Var, NULL);
    pdisp->Release();
    if (hr)
        return;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        lReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        lReadyState = V_I2(&Var);
    }
    else
    {
        return;
    }

    if (_lReadyState == lReadyState)
        return;

    _lReadyState = lReadyState;

    if (!_fDisablePadEvents && _lReadyState == READYSTATE_COMPLETE)
    {
        FireEvent(DISPID_PadEvents_DocLoaded, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::Save
//
//  Synopsis:   This function saves the document to given file name without
//              displaying a dialog. It changes current document name to given
//              name.
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::Save(LPCTSTR szFileName)
{
    HRESULT            hr = S_OK;
    IPersistFile *    pPF = NULL;

    if ( ! _pObject )
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistFile, (void **)&pPF));
    if (hr)
        goto Cleanup;

    hr = THR(pPF->Save(szFileName, TRUE));
    if (hr)
        goto Cleanup;

    hr = THR(pPF->SaveCompleted(NULL));
    if (hr)
        goto Cleanup;

    _fInitNew = FALSE;

Cleanup:
    ReleaseInterface(pPF);
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
// Member:    CPadDoc::Init
//
// Synopsis:
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::Init(int nCmdShow, CEventCallBack * pEvent)
{
    HRESULT     hr = S_OK;

    _pEvent = pEvent;

    // Ensure that the common control DLL is loaded for status window.
    InitCommonControls();

    _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(GetMenuID()));
    _hmenuEdit = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_PADMENU_EDIT));
    hr = THR(RegisterPadWndClass());
    if(hr)
        goto Cleanup;

    CreateWindowEx(
            0,
            SZ_PAD_WNDCLASS,
            SZ_APPLICATION_NAME,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL,
            NULL,
            g_hInstCore,
            this);

    if (!_hwnd)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    SetWindowPosition();

    CreateToolBarUI();

    // Create the status window.
    _hwndStatus = CreateWindowEx(
            0,                       // no extended styles
            STATUSCLASSNAME,         // name of status window class
            (LPCTSTR) NULL,          // no text when first created
            SBARS_SIZEGRIP |         // includes a sizing grip
            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,   // creates a child window
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            _hwnd,                   // handle to parent window
            (HMENU) 0,               // child window identifier
            g_hInstCore,             // handle to application instance
            NULL);                   // no window creation data
    if (!_hwndStatus)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    this->ShowWindow(nCmdShow);

    SetForegroundWindow(_hwnd);

    SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, _fUseShdocvw);

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::RegisterPadWndClass()
{
    if(!s_fPadWndClassRegistered)
    {
        LOCK_GLOBALS;

        HDC hdc = GetDC(NULL);
        s_fPaletteDevice = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
        extern HRESULT InitPalette();
        InitPalette();
        ReleaseDC(NULL, hdc);

        if(!s_fPadWndClassRegistered)
        {
            WNDCLASS    wc;

            memset(&wc, 0, sizeof(wc));
            wc.lpfnWndProc = CPadDoc::WndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
            wc.lpszMenuName =  MAKEINTRESOURCE(IDR_PADMENU);
            wc.lpszClassName = SZ_PAD_WNDCLASS;
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

            if (!RegisterClass(&wc))
            {
                return E_FAIL;
            }
            s_fPadWndClassRegistered = TRUE;
        }
    }
    return S_OK;
}

void
CPadDoc::SetStatusText(LPCTSTR pchStatusText)
{
    TCHAR * pchar;

    if (!_fDisablePadEvents)
    {
        if (_pEvent && pchStatusText && *pchStatusText)
        {
            _pEvent->Event(pchStatusText);
        }

        FireEvent(DISPID_PadEvents_Status, pchStatusText);
    }

    if ((!pchStatusText || _tcscmp(pchStatusText, _T("Ready")) == 0) &&
        _pScriptSite &&
        _pScriptSite->_achPath[0])
    {
        TCHAR achBuf[MAX_PATH];
        TCHAR *pch;

        _tcscpy(achBuf, _T("Script: "));
        pch = _tcsrchr(_pScriptSite->_achPath, FILENAME_SEPARATOR);
        _tcscat(achBuf, pch ? pch + 1 : _pScriptSite->_achPath);
        SetWindowText(_hwndStatus, achBuf);

        pchar = achBuf;
    }
    else
    {
        SetWindowText(_hwndStatus, pchStatusText);

        pchar = const_cast<TCHAR *>(pchStatusText);
    }

    if (IsTagEnabled(tagStatus))
    {
        char    achStatus[256]= "";   // for log status
        if (pchar)
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchar,
                    _tcslen(pchar),
                    achStatus,
                    256,
                    NULL,
                    NULL);
        }
        TraceTag((tagStatus, "%s", achStatus));
    }
}

void
CPadDoc::GetViewRect(RECT *prc, BOOL fIncludeObjectAdornments)
{
    RECT rcToolbar;
    RECT rcFormatToolbar;
    RECT rcStatus;

    GetClientRect(_hwnd, prc);

    if (_hwndToolbar)
    {
        GetWindowRect(_hwndToolbar, &rcToolbar);
        prc->top += rcToolbar.bottom - rcToolbar.top;
    }
    if ((_hwndFormatToolbar) && ( ! _fToolbarhidden) )
    {
        GetWindowRect(_hwndFormatToolbar, &rcFormatToolbar);
        prc->top += rcFormatToolbar.bottom - rcFormatToolbar.top;
    }

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    if (fIncludeObjectAdornments)
    {
        if ( !_fToolbarhidden )
        {
            prc->top    += (_bwToolbarSpace.top * 2) ;
            prc->bottom -= (_bwToolbarSpace.bottom * 2) ;
            prc->left   += ( _bwToolbarSpace.left * 2)  ;
            prc->right  -= ( _bwToolbarSpace.right * 2);
        }
        else
        {
            prc->top    += _bwToolbarSpace.top  ;
            prc->bottom -= _bwToolbarSpace.bottom ;
            prc->left   += _bwToolbarSpace.left ;
            prc->right  -= _bwToolbarSpace.right ;
        }

    }

    if (prc->bottom < prc->top)
        prc->bottom = prc->top;

    if (prc->right < prc->left)
        prc->right = prc->left;
}

void
CPadDoc::SendAmbientPropertyChange(DISPID dispid)
{
    IOleControl *pControl;

    if ( _pObject &&
         OK(_pObject->QueryInterface(IID_IOleControl, (void **)&pControl)))
    {
        pControl->OnAmbientPropertyChange(dispid);
        pControl->Release();
    }
}

void
CPadDoc::Resize()
{
    RECT rc;

    GetViewRect(&rc, TRUE);

    if (_pView)
    {
        // It's an ActiveX Document.

        IGNORE_HR(_pView->SetRect(&rc));
    }
    else if (_pInPlaceObject)
    {
        // It's an ActiveX Control.

        SIZEL sizel;

        HDC hdc = GetDC(_hwnd);
        sizel.cx = MulDiv(rc.right - rc.left, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
        sizel.cy = MulDiv(rc.bottom - rc.top, 2540, GetDeviceCaps(hdc, LOGPIXELSY));
        ReleaseDC(_hwnd, hdc);

        IGNORE_HR(_pObject->SetExtent(DVASPECT_CONTENT, &sizel));
        IGNORE_HR(_pInPlaceObject->SetObjectRects(ENSUREOLERECT(&rc), ENSUREOLERECT(&rc)));
    }
}

LRESULT
CPadDoc::OnClose()
{
    if (QuerySave(SAVEOPTS_PROMPTSAVE) == S_OK)
    {
        this->ShowWindow(SW_HIDE);
    }
    return 0;
}

LRESULT
CPadDoc::OnDestroy()
{
    if (_pInPlaceObject)
    {
        IGNORE_HR(_pInPlaceObject->InPlaceDeactivate());
    }

    Assert(_PNS._dwCookie == 0);

    ClearInterface(&_pObject);

    if (_fVisible)
    {
        _fVisible = FALSE;
        Release();
    }
    return 0;
}

LRESULT
CPadDoc::OnActivate(WORD wFlags)
{
    HRESULT hr;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    SetControlPaletteOwner(_hwnd);
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    if (_pInPlaceActiveObject)
    {
        hr = THR(_pInPlaceActiveObject->OnFrameWindowActivate(wFlags != WA_INACTIVE));
    }

    _fActive = (wFlags != WA_INACTIVE);

    return 0;
}

LRESULT
CPadDoc::OnSize(WORD fwSizeType, WORD nWidth, WORD nHeight)
{
    RECT rc;

    if (_hwndToolbar)
    {
        PostMessage(_hwndToolbar, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }
    if ( (_hwndFormatToolbar) && ( ! _fToolbarhidden ))
    {
        PostMessage(_hwndFormatToolbar, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }
    if (_hwndStatus)
    {
        PostMessage(_hwndStatus, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }

    GetViewRect(&rc, FALSE);
    if (_pInPlaceActiveObject)
    {
        THR_NOTRACE(_pInPlaceActiveObject->ResizeBorder(
                ENSUREOLERECT(&rc),
                &_Frame,
                TRUE));
    }

    Resize();

    return 0;
}

void
CPadDoc::UpdateFontSizeBtns(IOleCommandTarget *pCommandTarget)
{
    VARIANTARG var;
    MSOCMD msocmd;
    HRESULT hr;

    _iZoom = _iZoomMax = _iZoomMin = 0;
    msocmd.cmdID = OLECMDID_ZOOM;
    msocmd.cmdf  = 0;

    hr = pCommandTarget->QueryStatus(
            NULL,
            1,
            &msocmd,
            NULL);
    if (hr)
        goto Cleanup;

    if (msocmd.cmdf && msocmd.cmdf != MSOCMDSTATE_DISABLED)
    {
        var.vt   = VT_I4;
        var.lVal = 0;
        pCommandTarget->Exec(
                NULL,
                OLECMDID_ZOOM,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &var);
        if (var.vt == VT_I4)
            _iZoom = var.lVal;

        var.vt   = VT_I4;
        var.lVal = 0;
        pCommandTarget->Exec(
                NULL,
                OLECMDID_GETZOOMRANGE,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &var);
        if (var.vt == VT_I4)
        {
            _iZoomMin = (int)(short)LOWORD(var.lVal);
            _iZoomMax = (int)(short)HIWORD(var.lVal);
        }
    }

Cleanup:
    SendMessage(
            _hwndToolbar,
            TB_ENABLEBUTTON,
            IDM_PAD_FONTINC,
            (LPARAM) MAKELONG((_iZoom < _iZoomMax), 0));
    SendMessage(
            _hwndToolbar,
            TB_PRESSBUTTON,
            IDM_PAD_FONTINC,
            (LPARAM) MAKELONG(FALSE, 0));
    SendMessage(
            _hwndToolbar,
            TB_ENABLEBUTTON,
            IDM_PAD_FONTDEC,
            (LPARAM) MAKELONG((_iZoom > _iZoomMin), 0));
    SendMessage(
            _hwndToolbar,
            TB_PRESSBUTTON,
            IDM_PAD_FONTDEC,
            (LPARAM) MAKELONG(FALSE, 0));
}


struct MsoCmdInfo {
        UINT localIDM;
        UINT MsoCmdIDM;
        const GUID * MsoCmdGUID;
};

BOOL
CPadDoc::IsDebugWindowVisible()
{
    return _pDebugWindow->_hwnd && IsWindowVisible(_pDebugWindow->_hwnd);
}

void
CPadDoc::ToggleDebugWindowVisibility()
{
    HRESULT hr;

    if (_pDebugWindow == NULL)
    {
        _pDebugWindow = new CDebugWindow (this);

        hr = THR(_pDebugWindow->Init());
        if(hr)
        {
            delete _pDebugWindow;
            _pDebugWindow = NULL;
            return;
        }
    }

    ::ShowWindow(_pDebugWindow->_hwnd, IsDebugWindowVisible() ? SW_HIDE : SW_SHOW);
}



static INT_PTR CALLBACK
WelcomeProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadDoc *pDoc = (CPadDoc *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        break;

    case WM_COMMAND:
        pDoc->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                        GET_WM_COMMAND_ID(wParam, lParam),
                        GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_ERASEBKGND:
        SendMessage(pDoc->_hwnd, msg, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
CPadDoc::Welcome()
{
    Assert(!_hwndWelcome);
    _hwndWelcome = CreateDialogParam(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_WELCOME_DLG),
            _hwnd,
            &WelcomeProc,
            (LPARAM)this);
}

LRESULT
CPadDoc::OnCommand(WORD wNotifyCode, WORD idm, HWND hwndCtl)
{
    HRESULT hr = S_OK;
    IOleCommandTarget *pCommandTarget = NULL;
    DWORD               nCmdexecopt = MSOCMDEXECOPT_DONTPROMPTUSER;

    static const MsoCmdInfo CmdInfo[] = {
            { IDM_PAD_STOP,       OLECMDID_STOP,      NULL         },
            { IDM_PAD_PRINT,      OLECMDID_PRINT,     NULL         },
            { IDM_PAD_PAGESETUP,  OLECMDID_PAGESETUP, NULL         },
            { IDM_PAD_CUT,        OLECMDID_CUT,       NULL         },
            { IDM_PAD_COPY,       OLECMDID_COPY,      NULL         },
            { IDM_PAD_PASTE,      OLECMDID_PASTE,     NULL         },
            { IDM_PAD_SAVE,       OLECMDID_SAVE,      NULL         },
            { IDM_PAD_SAVEAS,     OLECMDID_SAVEAS,    NULL         },
            { IDM_LAUNCHDEBUGGER, IDM_LAUNCHDEBUGGER, &CGID_MSHTML },
            { IDM_PAD_PRINTPREVIEW, OLECMDID_PRINTPREVIEW, NULL    },
            { IDM_PAD_TESTTEMPLATES, OLECMDID_PRINTPREVIEW, NULL    },
            { 0, 0, NULL }
    };

    switch (idm)
    {
    case IDM_PAD_USESHDOCVW:
        _fUseShdocvw = !_fUseShdocvw;
        SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, (LPARAM)MAKELONG(_fUseShdocvw, 0));
        break;

    case IDM_PAD_BACK:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoBack());
            ApplyZoomPercent();
        }
        return 0;

    case IDM_PAD_FORWARD:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoForward());
            ApplyZoomPercent();
        }
        return 0;

    case IDM_PAD_HOME:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoHome());
        }
        break;

    case IDM_PAD_FIND:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoSearch());
        }
        break;

    case IDM_PAD_CLOSE:
        CloseFile();
        CloseScripts();
        UnregisterLocalCLSIDs();
        CoFreeUnusedLibraries();
        break;

    case IDM_PAD_EXIT:
        SendMessage(_hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        break;

    case IDM_PAD_NEW_HTML:
        hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
        if ( hr )
            goto Cleanup;

        hr = THR(Open(CLSID_HTMLDocument));
        if ( hr )
            goto Cleanup;
        break;

    case IDM_PAD_OPEN_FILE:
        hr = THR(PromptOpenFile(_hwnd, &CLSID_HTMLDocument));
        break;

    case IDM_PAD_OPEN_URL:
        hr = THR(PromptOpenURL(_hwnd, &CLSID_HTMLDocument));
        break;

    case IDM_PAD_OPENNSCP:
        hr = THR(PromptOpenFile(_hwnd, &CLSID_NSCP));
        break;

    case IDM_PAD_EXECUTE_SCRIPT:
        hr = THR(PromptExecuteScript(FALSE));
        break;

    case IDM_PAD_EXECUTE_DRT:
        hr = THR(ExecuteDRT());
        break;

    case IDM_PAD_SAVE:
        hr = THR(DoSave(FALSE));
        if ( hr == OLECMDERR_E_CANCELED )
        {
            hr = S_OK;
        }
        break;

    case IDM_PAD_EDITBROWSE:
        IHTMLDocument2 *pOmDoc;

        if (_pObject && S_OK == get_Document((LPDISPATCH *)&pOmDoc))
        {
            _fUserMode = !_fUserMode;

            pOmDoc->put_designMode(_fUserMode ? _T("off") : _T("on"));
            pOmDoc->Release();
            UpdateFormatToolbar();
        }
        break;

    case IDM_PAD_ABOUT:
        #define STRINGIZE2(a) #a
        #define STRINGIZE1(a) _T(STRINGIZE2(a))
        MessageBoxA(
            _hwnd,
            "Microsoft Trident Version " VER_PRODUCTVERSION_STR
            "\r\r"
            "/register - Register Pad Document\r"
            "/mail - Register Trident Exchange Form\r"
            "/nomail - Unregister Trident Exchange Form\r"
            "/local - Register Local MSHTML\r"
            "/system - Register System MSHTML\r"
            "/s - Do not display success message for above commands\r"
            "/n - Open new document\r"
            "/k - Keep running after script completes\r"
            "/l <fname> - Use <fname> to store log\r"
            "/x <fname> - Execute script in <fname>\r"
            "/e <fname> - Open <fname> in edit mode\r"
            "/g <fname> - Open <fname> in script generator mode\r"
            "/trace - Show trace dialog\r"
            "/shdocvw - Host shdocvw in Pad\r"
            "/loadsystem - Load MSHTML from system directory\r"
            "/nopreload - don't pre-load local DLLs (use registered DDLs, not local)\r",
            "About HTMLPad",
            MB_APPLMODAL | MB_OK);
        break;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    case IDM_PAD_TOOLBOX:
        ToggleControlPaletteVisibility();
        break;
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    case IDM_PAD_SHOWGLYPHS:
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            hr = pCommandTarget->Exec(
                    &CGID_MSHTML,
                    IDM_SHOWALLTAGS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);

            pCommandTarget->Release();
        }
        break;

    case IDM_PAD_DISABLE_IME_RECONVERSION:
        EnableIMEReconversion(FALSE);
        break;

    case IDM_PAD_ENABLE_IME_RECONVERSION:
        EnableIMEReconversion(TRUE);
        break;

    case IDM_PAD_IMMEDIATE_WINDOW:
        ToggleDebugWindowVisibility();
        break;

    case IDM_PAD_SCRUB:
        ScrubRegistry();
        break;

    case IDM_PAD_REGISTER_PAD:
        hr = THR(RegisterPad());
        break;

    case IDM_PAD_REGISTER_LOCAL_TRIDENT:
        hr = THR(RegisterTrident(_hwnd, TRUE, FALSE));
        break;

    case IDM_PAD_REGISTER_SYSTEM_TRIDENT:
        hr = THR(RegisterTrident(_hwnd, TRUE, TRUE));
        break;

    case IDM_PAD_DEBUG_TRACE:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExDoTracePointsDialog(FALSE);
        }
        break;

    case IDM_PAD_VIEW_MON:
        if (_pObject)
        {
            DbgExOpenViewObjectMonitor(_hwnd, _pObject, TRUE);
        }
        break;

    case IDM_PAD_MEM_MON:
        DbgExOpenMemoryMonitor();
        break;

    case IDM_PAD_METERS:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExMtOpenMonitor();
        }
        break;

    case IDM_PAD_PERFTAGS:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExPerfTags();
        }
        break;

    case IDM_PAD_NEWWIN:
        {
            CThreadProcParam tpp(_fUseShdocvw);
            hr = THR(CreatePadDoc(&tpp, NULL));
        }
        break;

    case IDM_PAD_CLEAR_CACHE:
        hr = THR(ClearDownloadCache());
        break;

    case IDM_PAD_REFRESH:
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            VARIANT var;

            VariantInit(&var);
            var.vt = VT_I4;

            if (GetAsyncKeyState(VK_CONTROL) < 0)
                var.lVal = OLECMDIDF_REFRESH_COMPLETELY;
            else
                var.lVal = OLECMDIDF_REFRESH_NO_CACHE;

            hr = pCommandTarget->Exec(NULL, OLECMDID_REFRESH,
                    MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);

            pCommandTarget->Release();
        }

        if (_pEvent)
            _pEvent->Event(_T("Refresh"), TRUE);

        break;


    case IDM_PAD_TESTTEMPLATES:
        // ISSUE: TODO: (carled) temporary code...  This is here for testing purposes
        // so that we can specify the template to be used.
        {
            if (   _pInPlaceObject
                && OK(_pInPlaceObject->QueryInterface(IID_IOleCommandTarget,
                                                      (void **)&pCommandTarget))
               )
            {
                int i;

                for (i = 0; CmdInfo[i].localIDM && CmdInfo[i].localIDM != idm; i ++);

                if (CmdInfo[i].localIDM)
                {
                    OPENFILENAME    ofn;
                    static TCHAR achPath[MAX_PATH] = _T("");
                    static TCHAR achStartDir[MAX_PATH] = _T("");

#if !defined(WINCE)
                    if (    !achPath[0]
                        &&  !achStartDir[0]
                        &&  GetEnvironmentVariable(_T("PAD_DEFAULTFILEDIR"), achStartDir, MAX_PATH))
                    {
                        if (_tcscmp(achStartDir, _T("CurrentDir")) == 0)
                        {
                            GetCurrentDirectory(MAX_PATH, achStartDir);
                        }
                    }
#endif

                    if (!achPath[0] && !achStartDir[0])
                    {
                        char achStartDirA[MAX_PATH] = "";
                        GetPrivateProfileStringA("PadDirs","FileDir","",achStartDirA,MAX_PATH, "mshtmdbg.ini");

                        if (achStartDirA[0])
                        {
                            MultiByteToWideChar(CP_ACP, 0, achStartDirA, MAX_PATH, achStartDir, MAX_PATH);
                        }
                    }

                    if (!achPath[0] && !achStartDir[0])
                    {
                        // Prime file name with samples directory.

                        // Start with the directory containing this file.

                        _tcscpy(achStartDir, _T(__FILE__));

                        // Chop off the name of this file and three directories.
                        // This will leave the root of our SLM tree in achPath.

                        if ( ! _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR))) {
                            achStartDir[0] = (TCHAR)0;

                        } else {

                            for (int i = 0; i < 4; i++)
                                {
                                    TCHAR *pch = _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR));
                                    if (pch)
                                        *pch = 0;
                                }
                        }

                        // Append the name of the directory containing the samples.

                        _tcscat(achStartDir, _T(FILENAME_SEPARATOR_STR) _T("src")
                                             _T(FILENAME_SEPARATOR_STR) _T("f3")
                                             _T(FILENAME_SEPARATOR_STR) _T("drt")
                                             _T(FILENAME_SEPARATOR_STR) _T("samples"));
                    }

                    memset(&ofn, 0, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner   = _hwnd;
                    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0Text files (*.txt)\0*.txt\0Dialogs (*.fmd)\0*.fmd\0All Files (*.*)\0*.*\0");
                    ofn.lpstrFile   = achPath;
                    ofn.lpstrInitialDir = *achPath ? NULL : achStartDir;
                    ofn.lpstrDefExt = TEXT("htm");
                    ofn.nMaxFile    = ARRAY_SIZE(achPath);
                    ofn.Flags       = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

                    if (IsTagEnabled(tagPPVTemplateOverride))
                    {
                        if (!GetEnvironmentVariable(_T("TRIDENT_PPVPATH"), achPath, ARRAY_SIZE(achPath)))
                        {
                            _tcscpy( achPath, _T("c:\\temp\\preview.dlg") );
                        }
                    }
                    else
                    {
                        DbgMemoryTrackDisable(TRUE);
                        hr = ( GetOpenFileName(&ofn) ? S_OK : S_FALSE);
                        DbgMemoryTrackDisable(FALSE);
                    }

                    if (SUCCEEDED(hr))
                    {
                        CVariant cvarArgIn;
                        V_VT(&cvarArgIn) = VT_BSTR;
                        V_BSTR(&cvarArgIn) = SysAllocString(achPath);
/*
                        // Testing the PrintHTML api
                        char achTemp[6000];

                        memset(achTemp, 0, 6000);
                        if (WideCharToMultiByte(CP_ACP, 0, achPath, -1, achTemp, 6000, 0, NULL))
                        {
                            static DYNPROC s_dynprocPrintHTML =
                                    { NULL, &g_dynlibPrintHTML, "PrintHTML" };

                            if (THR(LoadProcedure(&s_dynprocPrintHTML)))
                                return FALSE;

                            (*(BOOL (APIENTRY *)(HINSTANCE, HINSTANCE, LPSTR, int))s_dynprocPrintHTML.pfn)
                                    (NULL, NULL, achTemp, 0);
                        }
*/
                        hr = pCommandTarget->Exec(
                                        CmdInfo[i].MsoCmdGUID,
                                        CmdInfo[i].MsoCmdIDM,
                                        idm == IDM_PAD_PRINT ? 0 : MSOCMDEXECOPT_DONTPROMPTUSER,
                                        &cvarArgIn,
                                        NULL);

                    }
                    else if (hr == S_FALSE)
                        hr = S_OK;  // mask cancel from the file open dialog
                }
                pCommandTarget->Release();
            }
        }
        break;

    case IDM_PAD_PRINTPREVIEW:  // Just fall through and delegate
    case IDM_PAD_CUT:
    case IDM_PAD_COPY:
    case IDM_PAD_PASTE:
    case IDM_PAD_PAGESETUP:
    case IDM_PAD_PRINT:
    case IDM_PAD_STOP:
    case IDM_LAUNCHDEBUGGER:


        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            int i;

            for (i = 0; CmdInfo[i].localIDM && CmdInfo[i].localIDM != idm; i ++);
            if (CmdInfo[i].localIDM) // CmdInfo[i].localIDM == idm
            {
                hr = pCommandTarget->Exec(
                        CmdInfo[i].MsoCmdGUID,
                        CmdInfo[i].MsoCmdIDM,
                        idm == IDM_PAD_PRINT ? 0 : MSOCMDEXECOPT_DONTPROMPTUSER,
                        NULL,
                        NULL);

            }
            pCommandTarget->Release();
        }
        break;

#if CICERO==1
    case IDM_PAD_TOGGLE_CICERO:
    // Toggle Cicero:
    {
        ToggleCicero();
        break;
    }
#endif

    case IDM_IMAGE:
    case IDM_INSERTOBJECT:
    case IDM_FONT:
    case IDM_FIND :
    case IDM_REPLACE :
    case IDM_HYPERLINK :
          nCmdexecopt = 0;
                        // fall thru.

    //
    // Edit Menu
    //
    case IDM_UNDO :
    case IDM_REDO :
    case IDM_CUT :
    case IDM_COPY :
    case IDM_PASTE :
    case IDM_PASTEINSERT :
    case IDM_DELETE :
    case IDM_SELECTALL :

    case IDM_BOOKMARK :

    case IDM_UNLINK :
    case IDM_UNBOOKMARK :

    //
    // View Menu
    //

    case IDM_TOOLBARS :
    case IDM_STATUSBAR :
    case IDM_FORMATMARK :
    case IDM_TEXTONLY :
    case IDM_VIEWSOURCE:
    case IDM_BASELINEFONT5 :
    case IDM_BASELINEFONT4 :
    case IDM_BASELINEFONT3 :
    case IDM_BASELINEFONT2 :
    case IDM_BASELINEFONT1 :
    case IDM_EDITSOURCE :
    case IDM_FOLLOWLINKC :
    case IDM_FOLLOWLINKN :
    case IDM_PROPERTIES :
    case IDM_OPTIONS :

    //
    //
    // Insert Menu
    //
    case IDM_HORIZONTALLINE:
    case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_PAGEBREAK:
        case IDM_SPECIALCHAR:
        case IDM_MARQUEE:
        case IDM_1D:
        case IDM_TEXTBOX:
        case IDM_TEXTAREA:
#ifdef NEVER
        case IDM_HTMLAREA:
#endif
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:

        case IDM_IFRAME:

    //
    // Format Menu
    //
    case IDM_DIRLTR:
    case IDM_DIRRTL:
    case IDM_BLOCKDIRLTR:
    case IDM_BLOCKDIRRTL:

    case IDM_INDENT:
        case IDM_OUTDENT:

        {
       if ( IsEdit())
       {
            if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
            {

                hr = pCommandTarget->Exec(
                        (GUID *)&CGID_MSHTML,
                        idm,
                        nCmdexecopt,
                        NULL,
                        NULL);

                pCommandTarget->Release();
             }

        }
        }
        break;

    case IDM_PAD_SAVEAS:
        hr = THR(DoSave(TRUE));
        if ( hr == OLECMDERR_E_CANCELED )
        {
            hr = S_OK;
        }
        break;

    case IDM_PAD_VERIFYHTML_BODY:
        GetScriptRecorder()->VerifyHTML(TS_Body);
        break;

    case IDM_PAD_VERIFYHTML_CUR_BLOCK:
        GetScriptRecorder()->VerifyHTML(TS_CurrentElement);
        break;

    case IDM_PAD_RELOADHIST:
        hr = THR(DoReloadHistory());
        break;

    case IDM_ZOOMPERCENT:
        hr = OnStandardCombobox(wNotifyCode, idm, hwndCtl );
        break;

    case IDM_BLOCKFMT:
    case IDM_FONTSIZE:
    case IDM_FONTNAME:
    case IDM_FORECOLOR:
    {
        hr = OnFormatCombobox(wNotifyCode, idm, hwndCtl );
    }

    // fall through

    case IDM_PAD_FONTINC:
    case IDM_PAD_FONTDEC:
        VARIANTARG var;
        BOOL       fExec = TRUE;

        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            var.vt = VT_I4;
            var.lVal = 0;
            hr = pCommandTarget->Exec(
                    NULL,
                    OLECMDID_ZOOM,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    &var);
            if (hr)
                goto Cleanup;

            if (var.vt == VT_I4)
                _iZoom = var.lVal;

            if (idm == IDM_PAD_FONTINC && _iZoom < _iZoomMax)
            {
                var.lVal = _iZoom + 1;
            }
            else if (idm == IDM_PAD_FONTDEC && _iZoom > _iZoomMin)
            {
                var.lVal = _iZoom - 1;
            }
            else
            {
                fExec = FALSE;
            }

            if (fExec)
            {
                pCommandTarget->Exec(
                        NULL,
                        OLECMDID_ZOOM,
                        MSOCMDEXECOPT_DONTPROMPTUSER,
                        &var,
                        NULL);
            }

            pCommandTarget->Release();
        }

        break;
    }



Cleanup:
    if (hr)
    {
        CheckError(_hwnd, hr);
    }
    return 0;
}

HRESULT
CPadDoc::OnFormatCombobox(WORD wNotifyCode, WORD idm, HWND hwndCtl )
{
    BOOL fRestoreFocus = FALSE ;
    VARIANTARG  var;
    TCHAR achBuffer[64];
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr = S_OK;
    VARIANTARG *pvarIn  = NULL;

    switch (idm)
    {
    case IDM_FONTSIZE:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        GetWindowText(
                _hwndComboSize,
                achBuffer,
                ARRAY_SIZE(achBuffer));
        V_VT(&var)   = VT_I4;
        V_I4(&var) = _wtoi(achBuffer);
        pvarIn   = &var;
        break;

    case IDM_BLOCKFMT:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        *(DWORD *)achBuffer =
        GetWindowText(
                _hwndComboTag,
                achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                ARRAY_SIZE(achBuffer) - sizeof(DWORD) / sizeof(TCHAR));
        V_VT(&var)      = VT_BSTR;
        THR(FormsAllocString(achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                             &V_BSTR(&var)));
        pvarIn      = &var;
        break;

    case IDM_FONTNAME:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        *(DWORD *)achBuffer =
        GetWindowText(
                _hwndComboFont,
                achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                ARRAY_SIZE(achBuffer) - sizeof(DWORD) / sizeof(TCHAR));
        V_VT(&var)      = VT_BSTR;
        THR(FormsAllocString(achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                             &V_BSTR(&var)));
        pvarIn      = &var;
        break;

    case IDM_FORECOLOR:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        V_I4(&var) = SendMessage(
                _hwndComboColor,
                CB_GETITEMDATA,
                (WPARAM) SendMessage(_hwndComboColor, CB_GETCURSEL, 0, 0),
                0);
        V_VT(&var)   = VT_I4;
        pvarIn      = &var;
        break;

    }

    if ( !_pInPlaceObject )
        goto Cleanup;
    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    hr = pCommandTarget->Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL);

    //
    // When the user selects a combo item, pop the focus pack into the document.
    //
    if (fRestoreFocus)
    {
        HWND    hWndInPlace;

        _pInPlaceObject->GetWindow(&hWndInPlace);
        if (hWndInPlace)
        {
            ::SetFocus (hWndInPlace);
        }

        //else
            //SetFocus (TRUE);
    }

Cleanup:
    if ( pCommandTarget) pCommandTarget->Release();

    RRETURN ( hr );
}

HRESULT
CPadDoc::OnStandardCombobox(WORD wNotifyCode, WORD idm, HWND hwndCtl )
{
    IOleCommandTarget * pCommandTarget = NULL;
    BOOL                fRestoreFocus = FALSE;
    VARIANTARG          var;
    VARIANTARG          *pvarIn  = NULL;
    WPARAM              wCurSel;
    HRESULT             hr = S_OK;

    switch (idm)
    {
    case IDM_ZOOMPERCENT:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        wCurSel = (WPARAM)::SendMessage(_hwndComboZoom, CB_GETCURSEL, 0, 0);
        if (wCurSel == CB_ERR)
        {
            TCHAR   szText[256];
            DWORD   dwZoomPercent;

            ::SendMessage(_hwndComboZoom, WM_GETTEXT, (WPARAM)(sizeof(szText) / sizeof(szText[0])), (LPARAM)&szText);
            dwZoomPercent = StrToInt(szText);

            if (dwZoomPercent < 1 || dwZoomPercent > 1000)
            {
                HWND    hWndInPlace;
                _pInPlaceObject->GetWindow(&hWndInPlace);

                ::MessageBox(_hwnd,
                    TEXT("The number must be between 1 and 1000."),
                    TEXT("MSHTMLPAD"),
                    MB_ICONEXCLAMATION);

                //  Set default 100%
                dwZoomPercent = 100;
            }

            Format(0, szText, ARRAY_SIZE(szText), TEXT("<0d>%"), dwZoomPercent);
            ::SendMessage(_hwndComboZoom, WM_SETTEXT, 0, (LPARAM)&szText);

            V_I4(&var) = dwZoomPercent;
        }
        else
        {
            V_I4(&var) = ::SendMessage(_hwndComboZoom, CB_GETITEMDATA, wCurSel, 0);
        }

        V_VT(&var)   = VT_I4;
        pvarIn      = &var;
        break;
    }

    if ( !_pInPlaceObject )
        goto Cleanup;
    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    IGNORE_HR(pCommandTarget->Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL));

    //
    // When the user selects a combo item, pop the focus pack into the document.
    //
    if (fRestoreFocus)
    {
        HWND    hWndInPlace;

        _pInPlaceObject->GetWindow(&hWndInPlace);
        if (hWndInPlace)
        {
            ::SetFocus (hWndInPlace);
        }

        //else
            //SetFocus (TRUE);
    }

Cleanup:
    if ( pCommandTarget) pCommandTarget->Release();

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuPopup(HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    if (fSystemMenu)
        return 0;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    CheckMenuItem(
            hmenuPopup,
            IDM_PAD_TOOLBOX,
            IsControlPaletteVisible() ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    static const MsoCmdInfo MenuItemInfo[] = {
            { IDM_PAD_PAGESETUP,    OLECMDID_PAGESETUP, NULL },
            { IDM_PAD_PRINT,        OLECMDID_PRINT,     NULL },
            { IDM_PAD_SHORTCUT,     IDM_UNKNOWN,        NULL },
            { IDM_PAD_PROPERTIES,   IDM_UNKNOWN,        NULL },
            { IDM_PAD_BACK,         IDM_UNKNOWN,        NULL },
            { IDM_PAD_FORWARD,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_UPLEVEL,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_OPTIONS,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_OPENFAVORITE, IDM_UNKNOWN,        NULL },
            { IDM_PAD_ADDFAVORITE,  IDM_UNKNOWN,        NULL },
            { IDM_PAD_SAVE,         OLECMDID_SAVE,      NULL },
            { IDM_PAD_SAVEAS,       OLECMDID_SAVEAS,    NULL },
            { IDM_PAD_SENDFLOPPY,   IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDMAIL,     IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDBRIEFCASE,IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDWEB,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_PRINTPREVIEW, OLECMDID_PRINTPREVIEW,NULL     },
            { IDM_PAD_TESTTEMPLATES, OLECMDID_PRINTPREVIEW,       NULL },
            { 0, 0, NULL }
    };

    //
    // marka Editing Commands
    //
    static const MsoCmdInfo EditMenuItemInfo[] = {
                { IDM_HORIZONTALLINE,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKNORMAL,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKLEFT,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKRIGHT,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKBOTH,   IDM_UNKNOWN, NULL},
                { IDM_NONBREAK,   IDM_UNKNOWN, NULL},
                { IDM_PAGEBREAK,   IDM_UNKNOWN, NULL},
                { IDM_SPECIALCHAR,   IDM_UNKNOWN, NULL},
                { IDM_MARQUEE,   IDM_UNKNOWN, NULL},
                { IDM_1D,   IDM_UNKNOWN, NULL},
                { IDM_TEXTBOX,   IDM_UNKNOWN, NULL},
                { IDM_TEXTAREA,   IDM_UNKNOWN, NULL},
#ifdef NEVER
                { IDM_HTMLAREA,   IDM_UNKNOWN, NULL},
#endif
                { IDM_CHECKBOX,   IDM_UNKNOWN, NULL},
                { IDM_RADIOBUTTON,   IDM_UNKNOWN, NULL},
                { IDM_DROPDOWNBOX,   IDM_UNKNOWN, NULL},
                { IDM_LISTBOX,   IDM_UNKNOWN, NULL},
                { IDM_BUTTON,   IDM_UNKNOWN, NULL},
                { IDM_IMAGE,   IDM_UNKNOWN, NULL},
                { IDM_IFRAME,   IDM_UNKNOWN, NULL},
                { IDM_INSERTOBJECT,   IDM_UNKNOWN, NULL},
            { 0, 0, NULL }
    };

    int cMenuItem;

    HRESULT hr = S_OK;
    MSOCMD msocmd;
    IOleCommandTarget * pCommandTarget;

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    //
    // ISSUE - marka - why loop through all these commands if
    // they're not on the current menu ? leave it for now
    // this will be moved around in beta 2
    //
    for (cMenuItem = 0; MenuItemInfo[cMenuItem].localIDM; cMenuItem ++)
    {
        msocmd.cmdID = MenuItemInfo[cMenuItem].MsoCmdIDM;
        msocmd.cmdf  = 0;

        hr = pCommandTarget->QueryStatus(
            MenuItemInfo[cMenuItem].MsoCmdGUID,
            1,
            &msocmd,
            NULL);

        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
        case MSOCMDF_ENABLED:
            EnableMenuItem(
                    hmenuPopup,
                    MenuItemInfo[cMenuItem].localIDM,
                    MF_ENABLED);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableMenuItem(
                    hmenuPopup,
                    MenuItemInfo[cMenuItem].localIDM,
                    MF_GRAYED);
            break;
        }
    }
    //
    // marka
    //
    switch( uPos )
    {
        case 1:
            OnInitMenuEdit( uPos, hmenuPopup );
            break;
        case 2:
            OnInitMenuView( uPos, hmenuPopup );
            break;
        case 3:
            OnInitMenuInsert( uPos, hmenuPopup );
            break;
        case 4:
            OnInitMenuFormat( uPos, hmenuPopup );
            break;
    }
    pCommandTarget->Release();

Cleanup:
    return 0;
}

LRESULT
CPadDoc::OnInitMenuEdit(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

        UINT    MenuItem [] =  {
        IDM_UNDO,
        IDM_REDO,
        IDM_CUT,
        IDM_COPY,
        IDM_PASTE,
        IDM_PASTEINSERT,
        IDM_DELETE,
        IDM_SELECTALL,
        IDM_FIND,
        IDM_REPLACE,

        IDM_BOOKMARK,
        IDM_HYPERLINK,
        IDM_UNLINK,
        IDM_UNBOOKMARK,
        0
    };

    EnableMenuItems( MenuItem , hmenu);

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuView(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    UINT    MenuItem [] =  {
         IDM_TOOLBARS,
        IDM_STATUSBAR,
        IDM_FORMATMARK,
        IDM_TEXTONLY,
        IDM_VIEWSOURCE,
        IDM_BASELINEFONT5,
        IDM_BASELINEFONT4,
        IDM_BASELINEFONT3,
        IDM_BASELINEFONT2,
        IDM_BASELINEFONT1,
        IDM_PAD_REFRESH,
        IDM_EDITSOURCE,
        IDM_FOLLOWLINKC,
        IDM_FOLLOWLINKN,
        IDM_PROPERTIES,
        IDM_OPTIONS,
        0 };

    EnableMenuItems( MenuItem , hmenu);

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuInsert(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    EnableMenuItem(
        hmenu,
        IDM_PAGEBREAK,
        MF_GRAYED);

    EnableMenuItem(
        hmenu,
        IDM_SPECIALCHAR,
        MF_GRAYED);

    RRETURN ( hr );
}

LRESULT CPadDoc::OnInitMenuFormat(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    UINT    MenuItem [] =  {
        IDM_FONT,
        IDM_DIRLTR,
        IDM_DIRRTL,
        IDM_BLOCKDIRLTR,
        IDM_BLOCKDIRRTL,
        IDM_INDENT,
            IDM_OUTDENT,
            0 };

        EnableMenuItems( MenuItem, hmenu );

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnMenuSelect(UINT uItem, UINT fuFlags, HMENU hmenu)
{
    TCHAR achMessage[MAX_PATH];

    if (uItem == 0 && fuFlags == 0xFFFF)
    {
        _tcscpy(achMessage, TEXT("Ready"));
    }
    else if ((fuFlags & (MF_POPUP|MF_SYSMENU)) == 0 && uItem != 0)
    {
        LoadString(g_hInstResource, uItem, achMessage, ARRAY_SIZE(achMessage));
    }
    else
    {
        achMessage[0] = TEXT('\0');
    }

    SetStatusText(achMessage);
    return 0;
}

//+========================================================================
//
// Method: CPadDoc::EnableMenuItems
//
// Given an array of Commands - do a QueryStatus in Trident
// and activate / deactivate the corresponding MenuItem.
//
//-------------------------------------------------------------------------

HRESULT
CPadDoc::EnableMenuItems( UINT * pMenuItem , HMENU hmenuPopup)
{
    int         cMenuItem;
    MSOCMD      msocmd;
    UINT        mf;
    IOleCommandTarget * pCommandTarget =NULL;
    HRESULT hr = S_OK;

    if (! _pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    for (cMenuItem = 0; pMenuItem[cMenuItem]; cMenuItem ++)
    {
        msocmd.cmdID = pMenuItem[cMenuItem];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fActive)
        {
            hr = pCommandTarget->QueryStatus(
                    (GUID *)&CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
        }

        switch (msocmd.cmdf)
        {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
        }
        CheckMenuItem(hmenuPopup, msocmd.cmdID, mf);
        EnableMenuItem(hmenuPopup, msocmd.cmdID, mf);
                hr = S_OK;
    }
Cleanup:
    if ( pCommandTarget ) pCommandTarget->Release();

    RRETURN ( hr );
}

LRESULT CALLBACK
ObjectWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CPadDoc * pDoc = (CPadDoc *)GetProp(hwnd, _T("TRIDENT_DOC"));
    LRESULT l;

    if (!pDoc)
    {   // This is very unusual but happens in some scenarios
        // such as running activex.js stand alone.  We are not
        // 100% certain about the cuase but it happens in very
        // deep call stacks during complex shutdown.
        // -Tom
        return( DefWindowProc(hwnd, wm, wParam, lParam) );
    }

    switch(wm)
    {
    case WM_COMMAND:
        // check for justify changes
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDM_JUSTIFYRIGHT:
            case IDM_JUSTIFYLEFT:
            case IDM_JUSTIFYCENTER:
                BOOL fChecked;

                fChecked = SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                       TB_ISBUTTONCHECKED,
                                       (WPARAM)GET_WM_COMMAND_ID(wParam, lParam),
                                       0);

                if (!fChecked)
                    wParam = MAKEWPARAM(IDM_JUSTIFYNONE, LOWORD(wParam));
       }

       break;

    case WM_PAINT:
    {
        long lPaintArea=0;
        RECT rClient = {0};

        if (!pDoc->_fDisablePadEvents)
        {
            if (pDoc->_pEvent)
            {
                pDoc->_pEvent->Event(_T("Paint"));
            }
            pDoc->FireEvent(DISPID_PadEvents_Status, _T("Paint"));

            HRGN hrgn;
            int iRgnType;
            DWORD i;
            RECT rIntersect;

            struct REGION_DATA
            {
                RGNDATAHEADER rdh;
                RECT arc[64];
            } rd;

            Verify((hrgn = CreateRectRgnIndirect(&g_Zero.rc)) != NULL);
            Verify((iRgnType = GetUpdateRgn(hwnd, hrgn, FALSE)) != ERROR);
            Verify(GetClientRect(hwnd, &rClient));
            if (iRgnType != NULLREGION &&
                GetRegionData(hrgn, sizeof(rd), (RGNDATA *)&rd) &&
                rd.rdh.iType == RDH_RECTANGLES &&
                rd.rdh.nCount <= ARRAY_SIZE(rd.arc))
            {
                for (i=0; i<rd.rdh.nCount; i++)
                {
                    if (IntersectRect(&rIntersect, &rClient, &rd.arc[i]))
                    {
                        lPaintArea += (rIntersect.right - rIntersect.left)*(rIntersect.bottom - rIntersect.top);
                    }
                }
            }

            Verify(DeleteObject(hrgn));
        }

        l = CallWindowProc(pDoc->_pfnOrigWndProc, hwnd, wm, wParam, lParam);

        if (!pDoc->_fDisablePadEvents)
        {
            if (lPaintArea)
            {
                VARIANT vargs[2];
                VariantInit(vargs);
                V_VT(vargs) = VT_I4;
                V_I4(vargs) = lPaintArea;
                VariantInit(vargs+1);
                V_VT(vargs+1) = VT_I4;
                V_I4(vargs+1) = rClient.right * rClient.bottom;
                pDoc->FireEvent(DISPID_PadEvents_OnPaint, 2, vargs);
                VariantClear(vargs);
                VariantClear(vargs+1);
            }

            if (pDoc->_pEvent )
            {
                pDoc->_pEvent->Event(_T("After Paint"));
            }
        }

        return l;
        break;
    }
    }
    return CallWindowProc(pDoc->_pfnOrigWndProc, hwnd, wm, wParam, lParam);
}

LRESULT CALLBACK
CPadDoc::WndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CPadDoc * pDoc;

    pDoc = (CPadDoc *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (wm)
    {
    case WM_NCCREATE:
        pDoc = (CPadDoc *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDoc);
        pDoc->_hwnd = hwnd;
        pDoc->SubAddRef();
        break;

    case WM_NCDESTROY:
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        pDoc->_hwnd = NULL;
        pDoc->SubRelease();
        break;

    case WM_GETMINMAXINFO:
        break;

    default:
        if (pDoc)
        {
            LRESULT lResult;

            lResult = pDoc->PadWndProc(hwnd, wm, wParam, lParam);
            return lResult;
        }
    }

    return DefWindowProc(hwnd, wm, wParam, lParam);
}

LRESULT
CPadDoc::PadWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    static UINT g_msgMouseWheel = 0;
    HWND cmdHWND    ;
    switch (wm)
    {
    case WM_SYSCOMMAND:
        if (SC_KEYMENU == (wParam & 0xFFF0) && InSendMessage())
        {
            PostMessage(hwnd, wm, wParam, lParam);
            return 0;
        }
        break;

    case WM_TIMER:
        FireEvent(DISPID_PadEvents_Timer, 0, NULL);
        break;

    case WM_DOKEYACION:
        DoKeyAction();
        break;

    case WM_RUNSCRIPT:
        FireEvent(DISPID_PadEvents_Load, 0, NULL);
        PopScript();
        break;

    case WM_ERASEBKGND:
        if(_pObject)
            return TRUE;
        break;

    case WM_INITMENU:
        _fObjectHelp = FALSE;
        break;

    case WM_INITMENUPOPUP:
        if ((HMENU) wParam == _hmenuObjectHelp)
        {
            HWND hwndDoc;

            _pInPlaceObject->GetWindow(&hwndDoc);
            return SendMessage(hwndDoc, wm, wParam, lParam);
        }
        else
        {

            return OnInitMenuPopup(
                    (HMENU) wParam,
                    LOWORD(lParam),
                    (BOOL) HIWORD(lParam));
        }

    case WM_MENUSELECT:
        UINT fuFlags;
        int  uItem;

        fuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
        uItem   = GET_WM_MENUSELECT_CMD(wParam, lParam);

        // if fuFlag == 0x0000FFFF and (HWND) lParam == NULL, windows closes
        // the popup menu, do nothing.
        //
        if (fuFlags != 0x0000FFFF || GET_WM_MENUSELECT_HMENU(wParam, lParam))
        {
            if (fuFlags & MF_POPUP)
            {
                // selected menu item is a pop-up menu
                if (_hmenuObjectHelp && _hmenuHelp &&
                        _hmenuHelp == GET_WM_MENUSELECT_HMENU(wParam, lParam))
                {
                    _fObjectHelp =
                            (uItem == GetMenuItemCount(_hmenuHelp) - 1);
                }
                else
                {
                    _fObjectHelp = FALSE;
                }
            }
            else
            {
                // selected menu item is a command.

                _fObjectHelp = (GET_WM_MENUSELECT_HMENU(wParam, lParam)== _hmenuObjectHelp);
            }
        }

        if (_fObjectHelp)
        {
            HWND hwndDoc;

            _pInPlaceObject->GetWindow(&hwndDoc);
            return SendMessage(hwndDoc, wm, wParam, lParam);
        }
        else
        {
            return OnMenuSelect(uItem, fuFlags, GET_WM_MENUSELECT_HMENU(wParam, lParam));
        }

    case WM_COMMAND:
        {
            cmdHWND = GET_WM_COMMAND_HWND(wParam, lParam) ;
            if ( (_fObjectHelp && ( cmdHWND != _hwndToolbar) ) || ( cmdHWND == _hwndFormatToolbar) )
            {
                HWND hwndDoc;

                _pInPlaceObject->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
            else
            {
                return OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                 GET_WM_COMMAND_ID(wParam, lParam),
                                 GET_WM_COMMAND_HWND(wParam, lParam));
            }
        }
    case WM_HELP:
        MessageBox(NULL, _T("F1 pressed! If you got here, we bubble onhelp() OK!"), _T("Pad Help Diagnostic"), MB_ICONEXCLAMATION | MB_OK);
        break;

    case WM_DESTROY:
        OnDestroy();
        break;

    case WM_CLOSE:
        return OnClose();

    case WM_ACTIVATE:
        return OnActivate(LOWORD(wParam));

    case WM_SIZE:
        return OnSize((WORD)wParam, LOWORD(lParam), HIWORD(lParam));

#if defined(DBG_TOOLTIPS)
    case WM_NOTIFY:
        // TODO: (jenlc) should be replaced by QueryStatus calls.
        if ((TTN_NEEDTEXTA == ((LPNMHDR) lParam)->code) ||
                (TTN_NEEDTEXTW == ((LPNMHDR) lParam)->code))
        {
            TCHAR           szBuffer[256];
            TCHAR           szTemp[256];
            LPTOOLTIPTEXT   lpTooltipText = (LPTOOLTIPTEXT) lParam;
            int             id = lpTooltipText->hdr.idFrom;

            if (id == IDM_PAD_EDITBROWSE)
                id = _fUserMode ? IDM_PAD_EDIT : IDM_PAD_BROWSE;

            if (id == IDM_PAD_USESHDOCVW)
                id = _fUseShdocvw ? IDM_PAD_UNHOSTSHDOCVW : IDM_PAD_HOSTSHDOCVW;

            LoadString(
                g_hInstResource,
                IDS_TOOLTIP(id),
                szBuffer,
                ARRAY_SIZE(szBuffer));

            DWORD dwVersion;

            dwVersion = GetVersion();
            if (dwVersion >= 0x80000000)
            {
                _tcscpy(szTemp, szBuffer);
                WideCharToMultiByte(
                        CP_ACP,
                        0,
                        szTemp,
                        -1,
                        (char *) szBuffer,
                        sizeof(szBuffer),
                        NULL,
                        NULL);
            }
            lpTooltipText->lpszText = szBuffer;
        }
        break;
#endif

    case WM_PALETTECHANGED:
        if (_hwnd != (HWND)wParam)
            return OnPaletteChanged((HWND)wParam);
        break;
    case WM_QUERYNEWPALETTE:
        return OnQueryNewPalette();
        break;
    default:
        //if (g_msgMouseWheel == 0)
        if (g_msgMouseWheel == 0 && GetVersion() >= 0x80000000)
        {
            g_msgMouseWheel = RegisterWindowMessage(_T("MSWHEEL_ROLLMSG"));
        }
        if (wm == g_msgMouseWheel)
        {
            HWND hwndDoc;

            if (_pInPlaceObject)
            {
                _pInPlaceObject->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
        }
    }

    return DefWindowProc(hwnd, wm, wParam, lParam);
}


BOOL
CPadDoc::OnTranslateAccelerator(MSG * pMsg)
{
    HRESULT hr = S_FALSE;

    if (pMsg->message >= WM_KEYFIRST &&
            pMsg->message <= WM_KEYLAST &&
            _pInPlaceActiveObject)
    {
        //  Hack (olego) we need to give a chance to Combo Zoom getting keyboard messages.
        HWND hwndFocus = ::GetFocus();
        HWND hwndParent = hwndFocus ? ::GetParent(hwndFocus) : NULL;

        if (_hwndComboZoom != hwndParent)
        {
            hr = THR(_pInPlaceActiveObject->TranslateAccelerator(pMsg));
        }
    }
    // Even if hr is not S_OK, the message may have been processed and resulted
    // in an error. In such a case, we don't want to pump the message in again !
    return (hr != S_FALSE);
}


HRESULT
CPadDoc::Open(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnk = NULL;
    IOleObject *            pObject = NULL;
    IPersistStreamInit *    pPS = NULL;
    DWORD                   dwFlags;
    BOOL                    fInitNew = _fInitNew;

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(_T("Open"), TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            CLSID_HTMLDocument,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    _fInitNew = !pStream;

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    hr = THR(pObject->QueryInterface(IID_IPersistStreamInit, (void **)&pPS));

    Assert(pPS);

    if(pStream)
    {
        hr = THR(pPS->Load(pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pPS->InitNew());
        if (hr)
            goto Cleanup;
    }

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));

Cleanup:
    if (hr)
    {
        _fInitNew = fInitNew;
    }

    ReleaseInterface(pObject);
    ReleaseInterface(pPS);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


HRESULT
CPadDoc::Save (IStream *pStream)
{
    HRESULT                 hr = S_OK;
    IPersistStreamInit *    pPS = NULL;

    if (!_pObject)
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistStreamInit, (void **)&pPS));
    if (hr)
        goto Cleanup;

    hr = THR(pPS->Save(pStream, TRUE));
    if (hr)
        goto Cleanup;

    _fInitNew = FALSE;

Cleanup:
    ReleaseInterface(pPS);
    RRETURN(hr);
}



HRESULT
CPadDoc::TimeSaveDocToDummyStream(LONG *plTimeMicros)
{
    LARGE_INTEGER liTimeStart;
    LARGE_INTEGER liTimeEnd;
    LARGE_INTEGER liFreq;
    IStream *pStreamDummy = NULL;
    IOleCommandTarget *pOCT = NULL;
    VARIANTARG varargIn;
    VARIANTARG varargOut;
    HRESULT hr;

    QueryPerformanceFrequency( &liFreq );
    if( liFreq.QuadPart == 0 )
    {
        AssertSz(0,"No high-performance timer available.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Muck with document so that when we save it it actually comes out of the tree
    //

    hr = THR(_pObject->QueryInterface(IID_IOleCommandTarget, (void **)&pOCT));
    if (hr)
        goto Cleanup;

    // Set to design mode.
    hr = THR(pOCT->Exec(&CGID_MSHTML,
                        IDM_EDITMODE,
                        MSOCMDEXECOPT_DODEFAULT,
                        &varargIn,
                        &varargOut) );
    if (hr)
        goto Cleanup;

    // Set dirty bit.
    varargIn.vt = VT_BOOL;
    varargIn.bVal = TRUE;

    hr = THR(pOCT->Exec(&CGID_MSHTML,
                        IDM_SETDIRTY,
                        MSOCMDEXECOPT_DODEFAULT,
                        &varargIn,
                        &varargOut) );
    if (hr)
        goto Cleanup;

    //
    // Make the stream and time the saving.
    //

    CreateStreamOnHGlobal(NULL, TRUE, &pStreamDummy);

    QueryPerformanceCounter( &liTimeStart );
    hr = Save( pStreamDummy );
    QueryPerformanceCounter( &liTimeEnd );

    if( hr )
        goto Cleanup;

    Assert( plTimeMicros );
    *plTimeMicros = (liTimeEnd.QuadPart - liTimeStart.QuadPart) * 1000000 / liFreq.QuadPart;

Cleanup:
    ReleaseInterface( pStreamDummy );
    ReleaseInterface( pOCT );
    RRETURN(hr);
}


HRESULT
CPadDoc::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 0),
            TEXT("&File"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 1),
            TEXT("&Go"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 2),
            TEXT("Favo&rite"));
    _hmenuHelp = LoadMenu(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_PADHELPMENU));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)_hmenuHelp,
            TEXT("&Help"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 4),
            TEXT(" "));

    _cMenuHelpItems = GetMenuItemCount(_hmenuHelp);

    pmgw->width[0] = 1;
    pmgw->width[2] = 0;
    pmgw->width[4] = 2;
    pmgw->width[5] = 2;

    return S_OK;
}

HRESULT
CPadDoc::UIActivateDoc(LPMSG pMsg)
{
    HRESULT hr;
    RECT rc;

    GetViewRect(&rc, TRUE);

    hr = THR(_pObject->DoVerb(
            OLEIVERB_UIACTIVATE,
            pMsg,
            &_Site,
            0,
            _hwnd,
            ENSUREOLERECT(&rc)));

    RRETURN(hr);
}

HRESULT
CPadDoc::UIDeactivateDoc()
{
    RRETURN(THR(_pInPlaceObject->UIDeactivate()));
}

void
CPadDoc::SetDocTitle(TCHAR * pchTitle)
{
    TCHAR szBuf[512];
    TCHAR szTtl[512];

    szTtl[0] = 0;

    if (pchTitle)
    {
        _tcscat(szTtl, pchTitle);
        _tcscat(szTtl, _T(" - "));
    }

    _tcscat(szTtl, SZ_APPLICATION_NAME);

    if (pchTitle)
    {
        //  show if there is a full debug support available.
        if (DbgExIsFullDebug())
        {
            _tcscat(szTtl, _T(" (FULL debug) "));
        }
        else
        {
            _tcscat(szTtl, _T(" (NOT full debug) "));
        }
    }

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    if (!_tcsequal(szBuf, szTtl))
    {
        SetWindowText(_hwnd, szTtl);
    }
    UpdateDirtyUI();
}

HRESULT
CPadDoc::GetMoniker(LPMONIKER * ppmk)
{
    Assert (ppmk);
    if (_pMk)
    {
        * ppmk = _pMk;
        _pMk->AddRef();
        return S_OK;
    }
    else
    {
        * ppmk = NULL;
        RRETURN (E_FAIL);
    }
}

char *
DecodeMessage(UINT msg)
{
    switch (msg)
    {
        case WM_NULL:               return("WM_NULL");
        case WM_CREATE:             return("WM_CREATE");
        case WM_DESTROY:            return("WM_DESTROY");
        case WM_MOVE:               return("WM_MOVE");
        case WM_SIZE:               return("WM_SIZE");
        case WM_ACTIVATE:           return("WM_ACTIVATE");
        case WM_SETFOCUS:           return("WM_SETFOCUS");
        case WM_KILLFOCUS:          return("WM_KILLFOCUS");
        case WM_ENABLE:             return("WM_ENABLE");
        case WM_SETREDRAW:          return("WM_SETREDRAW");
        case WM_SETTEXT:            return("WM_SETTEXT");
        case WM_GETTEXT:            return("WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return("WM_GETTEXTLENGTH");
        case WM_PAINT:              return("WM_PAINT");
        case WM_CLOSE:              return("WM_CLOSE");
        case WM_QUERYENDSESSION:    return("WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return("WM_QUERYOPEN");
        case WM_ENDSESSION:         return("WM_ENDSESSION");
        case WM_QUIT:               return("WM_QUIT");
        case WM_ERASEBKGND:         return("WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return("WM_SYSCOLORCHANGE");
        case WM_SHOWWINDOW:         return("WM_SHOWWINDOW");
        case WM_WININICHANGE:       return("WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return("WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return("WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return("WM_FONTCHANGE");
        case WM_TIMECHANGE:         return("WM_TIMECHANGE");
        case WM_CANCELMODE:         return("WM_CANCELMODE");
        case WM_SETCURSOR:          return("WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return("WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return("WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return("WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return("WM_GETMINMAXINFO");
        case WM_PAINTICON:          return("WM_PAINTICON");
        case WM_ICONERASEBKGND:     return("WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return("WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return("WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return("WM_DRAWITEM");
        case WM_MEASUREITEM:        return("WM_MEASUREITEM");
        case WM_DELETEITEM:         return("WM_DELETEITEM");
        case WM_VKEYTOITEM:         return("WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return("WM_CHARTOITEM");
        case WM_SETFONT:            return("WM_SETFONT");
        case WM_GETFONT:            return("WM_GETFONT");
        case WM_SETHOTKEY:          return("WM_SETHOTKEY");
        case WM_GETHOTKEY:          return("WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return("WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return("WM_COMPAREITEM");
        case WM_COMPACTING:         return("WM_COMPACTING");
        case WM_COMMNOTIFY:         return("WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return("WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return("WM_WINDOWPOSCHANGED");
        case WM_POWER:              return("WM_POWER");
        case WM_COPYDATA:           return("WM_COPYDATA");
        case WM_CANCELJOURNAL:      return("WM_CANCELJOURNAL");
        case WM_NOTIFY:             return("WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return("WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return("WM_INPUTLANGCHANGE");
        case WM_TCARD:              return("WM_TCARD");
        case WM_HELP:               return("WM_HELP");
        case WM_USERCHANGED:        return("WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return("WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return("WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return("WM_STYLECHANGING");
        case WM_STYLECHANGED:       return("WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return("WM_DISPLAYCHANGE");
        case WM_GETICON:            return("WM_GETICON");
        case WM_SETICON:            return("WM_SETICON");
        case WM_NCCREATE:           return("WM_NCCREATE");
        case WM_NCDESTROY:          return("WM_NCDESTROY");
        case WM_NCCALCSIZE:         return("WM_NCCALCSIZE");
        case WM_NCHITTEST:          return("WM_NCHITTEST");
        case WM_NCPAINT:            return("WM_NCPAINT");
        case WM_NCACTIVATE:         return("WM_NCACTIVATE");
        case WM_GETDLGCODE:         return("WM_GETDLGCODE");
        case WM_SYNCPAINT:          return("WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return("WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return("WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return("WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return("WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return("WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return("WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return("WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return("WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return("WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return("WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return("WM_KEYDOWN");
        case WM_KEYUP:              return("WM_KEYUP");
        case WM_CHAR:               return("WM_CHAR");
        case WM_DEADCHAR:           return("WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return("WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return("WM_SYSKEYUP");
        case WM_SYSCHAR:            return("WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return("WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return("WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return("WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return("WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return("WM_INITDIALOG");
        case WM_COMMAND:            return("WM_COMMAND");
        case WM_SYSCOMMAND:         return("WM_SYSCOMMAND");
        case WM_TIMER:              return("WM_TIMER");
        case WM_HSCROLL:            return("WM_HSCROLL");
        case WM_VSCROLL:            return("WM_VSCROLL");
        case WM_INITMENU:           return("WM_INITMENU");
        case WM_INITMENUPOPUP:      return("WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return("WM_MENUSELECT");
        case WM_MENUCHAR:           return("WM_MENUCHAR");
        case WM_ENTERIDLE:          return("WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return("WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return("WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return("WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return("WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return("WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return("WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return("WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return("WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return("WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return("WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return("WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return("WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return("WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return("WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return("WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return("WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return("WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return("WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return("WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return("WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return("WM_EXITMENULOOP");
        case WM_NEXTMENU:           return("WM_NEXTMENU");
        case WM_SIZING:             return("WM_SIZING");
        case WM_CAPTURECHANGED:     return("WM_CAPTURECHANGED");
        case WM_MOVING:             return("WM_MOVING");
        case WM_POWERBROADCAST:     return("WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return("WM_DEVICECHANGE");
        case WM_MDICREATE:          return("WM_MDICREATE");
        case WM_MDIDESTROY:         return("WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return("WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return("WM_MDIRESTORE");
        case WM_MDINEXT:            return("WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return("WM_MDIMAXIMIZE");
        case WM_MDITILE:            return("WM_MDITILE");
        case WM_MDICASCADE:         return("WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return("WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return("WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return("WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return("WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return("WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return("WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return("WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return("WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return("WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return("WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return("WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return("WM_IME_SELECT");
        case WM_IME_CHAR:           return("WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return("WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return("WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return("WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return("WM_MOUSELEAVE");
        case WM_CUT:                return("WM_CUT");
        case WM_COPY:               return("WM_COPY");
        case WM_PASTE:              return("WM_PASTE");
        case WM_CLEAR:              return("WM_CLEAR");
        case WM_UNDO:               return("WM_UNDO");
        case WM_RENDERFORMAT:       return("WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return("WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return("WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return("WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return("WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return("WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return("WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return("WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return("WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return("WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return("WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return("WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return("WM_PALETTECHANGED");
        case WM_HOTKEY:             return("WM_HOTKEY");
        case WM_PRINT:              return("WM_PRINT");
        case WM_PRINTCLIENT:        return("WM_PRINTCLIENT");
        case WM_USER:               return("WM_USER");
        case WM_USER+1:             return("WM_USER+1");
        case WM_USER+2:             return("WM_USER+2");
        case WM_USER+3:             return("WM_USER+3");
        case WM_USER+4:             return("WM_USER+4");
    }

    return("");
}

void
CPadDoc::RunOneMessage(MSG *pmsg)
{
    PADTHREADSTATE * pts = GetThreadState();
    CPadDoc *pDoc;
    char ach[64];
    KEYSTATE ks;

    for (pDoc = pts->pDocFirst; pDoc != NULL; pDoc = pDoc->_pDocNext)
    {
        if (pmsg->hwnd == pDoc->_hwnd || IsChild(pDoc->_hwnd, pmsg->hwnd))
            break;
    }

    ach[0] = 0;

    if (pmsg->hwnd)
    {
        GetClassNameA(pmsg->hwnd, ach, sizeof(ach));
    }

    PerfLog4(tagPerfWatchPad, pDoc, "+CPadDoc::RunOneMessage msg=%04X (%s) hwnd=%lX (%s)",
        pmsg->message, DecodeMessage(pmsg->message), pmsg->hwnd, ach);

    if (pDoc)
    {
        switch (pmsg->message)
        {
        case WM_CHAR:
            ks = (0x8000 & GetKeyState(VK_SHIFT)) ? KEYSTATE_Shift : KEYSTATE_None;

            IGNORE_HR(pDoc->GetScriptRecorder()->RegisterChar(pmsg->wParam, ks));
            break;

        case WM_KEYDOWN:
            ks = (0x8000 & GetKeyState(VK_SHIFT)) ? KEYSTATE_Shift : KEYSTATE_None;

            IGNORE_HR(pDoc->GetScriptRecorder()->RegisterKeyDown(pmsg->wParam, ks));
            break;
        }

        if (WM_KEYFIRST <= pmsg->message &&
                pmsg->message <= WM_KEYLAST &&
                pDoc->OnTranslateAccelerator(pmsg))
        {
            goto leave;
        }

        if (pmsg->message == WM_PAINT && pDoc->_fPaintLocked)
        {
            PAINTSTRUCT ps;
            BeginPaint(pmsg->hwnd, &ps);
            EndPaint(pmsg->hwnd, &ps);
            pDoc->_fPaintOnUnlock = TRUE;
            goto leave;
        }
    }

    TranslateMessage(pmsg);
    DispatchMessage(pmsg);

leave:
    PerfLog(tagPerfWatchPad, pDoc, "-CPadDoc::RunOneMessage");
    return;
}

#define MAX_MESSAGES_TO_RUN 20

int
CPadDoc::Run(BOOL fStopWhenEmpty)
{
    MSG     msg;
    BOOL    fQuit;
    BOOL    fNoSuspend = IsTagEnabled(tagPadNoSuspendForMessage);
    PADTHREADSTATE * pts = GetThreadState();

    msg.wParam = 0;
    if (fStopWhenEmpty)
    {
        // Just grab all the messages that are currently in the queue, then quit.
        // Also quit if the only messages in the queue are timer messages.

        int n = 0;

        for (;;)
        {
            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            Assert(!InSendMessage());

            fQuit = !PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit || msg.message == WM_QUIT)
                break;

            RunOneMessage(&msg);

            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            if (++n > MAX_MESSAGES_TO_RUN)
            {
                fQuit = GetQueueStatus(QS_ALLEVENTS & ~QS_TIMER) == 0;
            }

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit)
                break;
        }
    }
    else
    {
        // Loop until we get a quit message.

        while (!pts->fEndEvents)
        {
            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            //
            // When debug dialog brought up we hit this.  The
            // dialog thread was sending itself a WM_INITDIALOG
            // message and filling in the Listbox.  Why should
            // this assert be valid in this case?  davidd
            //
            //             Assert(!InSendMessage());

            fQuit = !GetMessage(&msg, NULL, 0, 0);

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit)
                break;

            RunOneMessage(&msg);
        }

    }

    return fStopWhenEmpty ? 0 : msg.wParam;
}

HRESULT
CPadDoc::GetBrowser()
{
    HRESULT hr = S_OK;

    if (!_pBrowser)
    {
        hr = THR(Open(CLSID_WebBrowser, NULL));
        if (hr)
        {
            goto Cleanup;
        }

        Assert(_pObject);
        hr = THR(_pObject->QueryInterface(IID_IWebBrowser, (void **)&_pBrowser));
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::SaveHistory(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IPersistHistory *       pPH = NULL;

    if (!_pObject)
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistHistory, (void **)&pPH));
    if (hr)
        goto Cleanup;

    hr = THR(pPH->SaveHistory(pStream));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPH);
    RRETURN(hr);
}


HRESULT
CPadDoc::OpenHistory(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnk = NULL;
    IOleObject *            pObject = NULL;
    IPersistHistory *       pPH = NULL;
    CLSID                   clsid;
    DWORD dwFlags;

    Assert(pStream);

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(_T("Open"), TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            CLSID_HTMLDocument,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    hr = THR(pObject->QueryInterface(IID_IPersistHistory, (void **)&pPH));
    if (hr)
        goto Cleanup;

    Assert(pPH);

    hr = THR(pPH->GetClassID(&clsid));
    if (hr)
        goto Cleanup;

    Assert(clsid == CLSID_HTMLDocument);

    hr = THR(pPH->LoadHistory(pStream, 0));
    if (hr)
        goto Cleanup;

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));

Cleanup:

    ReleaseInterface(pObject);
    ReleaseInterface(pPH);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


HRESULT
CPadDoc::DoReloadHistory()
{
    IStream *pStream = NULL;
    HGLOBAL hg = NULL;
    HRESULT hr;
    static LARGE_INTEGER i64Zero = {0, 0};

    hg = GlobalAlloc(GMEM_MOVEABLE, 0);
    if (!hg)
        return E_OUTOFMEMORY;

    hr = THR(CreateStreamOnHGlobal(hg, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    hr = THR(SaveHistory(pStream));
    if (hr)
        goto Cleanup;

    hr = THR(pStream->Seek(i64Zero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(OpenHistory(pStream));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);

    RRETURN(hr);
}

void
CPadDoc::DirtyColors()
{
    if (_palState == palChanged)
        return;
    _palState = palChanged;
    PostMessage(_hwnd, WM_QUERYNEWPALETTE, 0, 0L);
}

LRESULT
CPadDoc::OnPaletteChanged(HWND hwnd)
{
    HWND hwndDoc = 0;
    if (_pInPlaceObject && SUCCEEDED(_pInPlaceObject->GetWindow(&hwndDoc)) && hwndDoc)
        return SendMessage(hwndDoc, WM_PALETTECHANGED, (WPARAM)hwnd, 0L);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetupComposeFont
//
//  Synopsis:   Set the default composition font for MSHTML when its in edit mode.
//
//----------------------------------------------------------------------------
void
CPadDoc::SetupComposeFont()
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    CVariant varIn;

    Assert(_pInPlaceObject);

    if (_fUserMode)
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = TRUE;

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_HTMLEDITMODE,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );

    V_VT(&varIn) = VT_BSTR;

#if DBG==1
    if (!IsTagEnabled(tagSpanTag))
#endif // DBG==1
        THR(FormsAllocString(_T(",,,,,,Times New Roman"), &V_BSTR(&varIn)));
#if DBG==1
    else if (!IsTagEnabled(tagSpanTag2))
        THR(FormsAllocString(_T("1,,,2,0.128.0,,Times New Roman,MsHtmlPad"), &V_BSTR(&varIn)));
    else
        THR(FormsAllocString(_T("1,,,2,0.128.0,,Times New Roman,MsHtmlPad,1"), &V_BSTR(&varIn)));
#endif // DBG==1

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_COMPOSESETTINGS,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
        );
Cleanup:
    ReleaseInterface(pCommandTarget);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetupDefaultBlock
//
//  Synopsis:   Set the default block tag for editting.
//
//----------------------------------------------------------------------------
void
CPadDoc::SetupDefaultBlock()
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    CVariant varIn;

    Assert(_pInPlaceObject);

    if (_fUserMode)
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = TRUE;

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_HTMLEDITMODE,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );

    V_VT(&varIn) = VT_BSTR;
    if (IsTagEnabled(tagDefaultDIV))
        THR(FormsAllocString(_T("DIV"), &V_BSTR(&varIn)));
    else
        THR(FormsAllocString(_T("P"), &V_BSTR(&varIn)));

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_DEFAULTBLOCK,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );
Cleanup:
    ReleaseInterface(pCommandTarget);
    return;
}

#if 0
LRESULT
CPadDoc::OnQueryNewPalette()
{
    HWND hwndDoc = 0;
    if (_pInPlaceObject && SUCCEEDED(_pInPlaceObject->GetWindow(&hwndDoc) && _hwndDoc)
        return SendMessage(hwndDoc, WM_QUERYNEWPALETTE, hwnd, 0L);
    return FALSE;
}
#else
LRESULT
CPadDoc::OnQueryNewPalette()
{
    if (!_pObject || !s_fPaletteDevice)
        return FALSE;

    switch (_palState)
    {
    case palChanged:
    case palUnknown:
    {
        HPALETTE hpal = _hpal;

        IViewObject *pVO = NULL;
        LOGPALETTE *plp = NULL;

        //
        // Try to get a color set
        //
        if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
        {
            pVO->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, NULL, &plp);
            pVO->Release();
        }

        if (plp)
        {
            PALETTEENTRY ape[256];

            if ( _hpal )
            {
                unsigned cpe = GetPaletteEntries(_hpal, 0, 0, NULL);

                if (cpe > 256 ||
                    cpe != plp->palNumEntries ||
                    (GetPaletteEntries(_hpal, 0, cpe, ape) != cpe) ||
                    memcmp(plp->palPalEntry, ape, cpe * sizeof(PALETTEENTRY)))
                {
                    DeleteObject(_hpal);
                    _hpal = CreatePalette(plp);
                }
            }
            else
            {
                _hpal = CreatePalette(plp);
            }

            CoTaskMemFree(plp);
        }

        if (hpal != _hpal)
            SendAmbientPropertyChange(DISPID_AMBIENT_PALETTE);

        _palState = palNormal;
    }
    // Fall through
    case palNormal:
        HDC hdc = GetDC(_hwnd);
        SelectPalette(hdc, _hpal ? _hpal : (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);
        ReleaseDC(_hwnd, hdc);
    }
    return TRUE;
}
#endif


class CDebugDownloadNotify : public IDownloadNotify
{
public:
    static HRESULT Create(IDownloadNotify **ppdn, ULONG ulMask)
    {
        CDebugDownloadNotify *pddn;
        HRESULT hr = E_OUTOFMEMORY;

        pddn = new CDebugDownloadNotify(ulMask);
        if (!pddn)
            goto Cleanup;

        hr = THR(pddn->QueryInterface(IID_IDownloadNotify, (void**)ppdn));
        if (hr)
            ClearInterface(ppdn);

        pddn->Release();
    Cleanup:
        RRETURN(hr);
    }

private:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDebugDownloadNotify))
    CDebugDownloadNotify(ULONG ulMask) { _ulMask = ulMask; _ulRefs = 1; }

    // IUnknown methods
    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj)
    {
        if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDownloadNotify))
        {
            *ppvObj = (IDownloadNotify *)this;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }

    STDMETHOD_(ULONG,AddRef)()
    {
        return((ULONG)InterlockedIncrement((LONG *)&_ulRefs));
    }

    STDMETHOD_(ULONG,Release)()
    {
        ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulRefs);

        if (ulRefs == 0)
        {
            delete this;
        }

        return(ulRefs);
    }

    // IDownloadNotify methods
    virtual HRESULT STDMETHODCALLTYPE DownloadStart(
        /* [in] */ LPCWSTR pchUrl,
        /* [in] */ DWORD dwDownloadId,
        /* [in] */ DWORD dwType,
        /* [in] */ DWORD dwReserved)
    {
        TraceTag((0, "DownloadStart    %lx (tid%3x): id#%d type %d %ls", this, GetCurrentThreadId(), dwDownloadId, dwType, pchUrl));
        if (!((1 << dwType) & _ulMask))
            return E_ABORT;

        return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE DownloadComplete(
        /* [in] */ DWORD dwDownloadId,
        /* [in] */ HRESULT hrNotify,
        /* [in] */ DWORD dwReserved)
    {
        TraceTag((0, "DownloadComplete %lx (tid%3x): id#%d hr %8lx", this, GetCurrentThreadId(), dwDownloadId, hrNotify));
        return S_OK;
    }

    ULONG _ulRefs;
    ULONG _ulMask;
};


//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::AttachDownloadNotify
//
//  Synopsis:   Attach a new debug download notify object to the doc
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::AttachDownloadNotify(IOleObject *pObject)
{
    IDownloadNotify *pdn = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    VARIANT varIn;

    hr = THR_NOTRACE(pObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    hr = CDebugDownloadNotify::Create(&pdn, _ulDownloadNotifyMask);
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)pdn;

    pCommandTarget->Exec(
                         (GUID *)&CGID_DownloadHost,
                         DWNHCMDID_SETDOWNLOADNOTIFY,
                         MSOCMDEXECOPT_DONTPROMPTUSER,
                         &varIn,
                         NULL
                        );

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pdn);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::DetachDownloadNotify
//
//  Synopsis:   Detach the debug download notify object from the doc
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::DetachDownloadNotify(IOleObject *pObject)
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    VARIANT varIn;

    hr = THR_NOTRACE(pObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)NULL;

    pCommandTarget->Exec(
                         (GUID *)&CGID_DownloadHost,
                         DWNHCMDID_SETDOWNLOADNOTIFY,
                         MSOCMDEXECOPT_DONTPROMPTUSER,
                         &varIn,
                         NULL
                        );

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}

//----------------------------------------------------------------
//
//  Zoom Combo UI Stuff
//
//
//
//----------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Window Procedure: EditZoomWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
LRESULT CALLBACK
EditZoomWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_KEYDOWN:
        {
            switch ((int)wParam)
            {
            case VK_RETURN:
                ::SendMessage(GetParent(hWnd), WM_ZOOMRETURN, 0, 0);
                return 0;
            case VK_ESCAPE:
                ::SendMessage(GetParent(hWnd), WM_ZOOMESCAPE, 0, 0);
                return 0;
            case VK_UP:
                ::SendMessage(GetParent(hWnd), WM_ZOOMUP, 0, 0);
                return 0;
            case VK_DOWN:
                ::SendMessage(GetParent(hWnd), WM_ZOOMDOWN, 0, 0);
                return 0;
            default:
                break;
            }
        }
        break;

    case WM_KEYUP:
        {
            switch ((int)wParam)
            {
            case VK_RETURN:
            case VK_ESCAPE:
            case VK_UP:
            case VK_DOWN:
                return 0;
            default:
                break;
            }
        }
    default:
        break;
    }
    //  Edit has address of default wnd proc in its GWLP_USERDATA
    return CallWindowProc((WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA),
        hWnd, uMessage, wParam, lParam);
}

//+-------------------------------------------------------------------
//
//  Window Procedure: ZoomComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
LRESULT CALLBACK
ZoomComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) ::SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        ::SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_ZOOMRETURN:
        ::SendMessage(::GetParent(hWnd),
            WM_COMMAND,
            (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
            (LPARAM)hWnd);
        return 0;

    case WM_ZOOMESCAPE:
        if ((WPARAM)::SendMessage(hWnd, CB_GETCURSEL, 0, 0) == CB_ERR)
        {
            ::SendMessage(hWnd, CB_SETCURSEL, (WPARAM)-1, 0);
        }
        else
        {
            ::SendMessage(::GetParent(hWnd),
                WM_COMMAND,
                (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
                (LPARAM)hWnd);
        }
        return 0;

    case WM_ZOOMUP:
    case WM_ZOOMDOWN:
        {
            WPARAM wCurSel;

            wCurSel = (WPARAM)::SendMessage(hWnd, CB_GETCURSEL, 0, 0);
            if (wCurSel == CB_ERR)
            {
                wCurSel = 0;
            }

            if (uMessage == WM_ZOOMUP)
            {
                if (wCurSel > 0)
                {
                    wCurSel--;
                }
            }
            else
            {
                if ((wCurSel + 1) < (WPARAM)::SendMessage(hWnd, CB_GETCOUNT, 0, 0))
                {
                    wCurSel++;
                }
            }

            ::SendMessage(hWnd, CB_SETCURSEL, wCurSel, 0);
        }
        return 0;

    default:
        break;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}

//----------------------------------------------------------------
//
//  Editing Toolbar UI Stuff
//
//
//
//----------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Window Procedure: ComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
#if defined(DBG_TOOLTIPS)
LRESULT CALLBACK
ComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_CHAR:
        // Don't allow the user to type anything into the combo
        return 0;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}
#endif

//+-------------------------------------------------------------------
//
// Local Helper Function: InstallComboboxTooltip
//
//--------------------------------------------------------------------

void
CPadDoc::InstallComboboxTooltip(HWND hwndCombo, UINT IDMmessage)
{
#if defined(DBG_TOOLTIPS)
    HWND     hwndTooltip;
    TOOLINFO tbToolInfo;

    Assert(hwndCombo);
    Assert(GetParent(hwndCombo));

    hwndTooltip = (HWND) SendMessage(
            GetParent(hwndCombo),
            TB_GETTOOLTIPS,
            0,
            0);

    SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG)ComboWndProc);

    tbToolInfo.cbSize   = sizeof(TOOLINFO);
    tbToolInfo.uFlags   = TTF_IDISHWND;
    tbToolInfo.hwnd     = GetParent(hwndCombo);
    tbToolInfo.uId      = (UINT) hwndCombo;
    tbToolInfo.hinst    = 0;

#ifndef WINCE
    DWORD dwVersion = GetVersion();
#else
    DWORD dwVersion = 0;
#endif

    tbToolInfo.lpszText = (dwVersion < 0x80000000) ?
            ((LPTSTR) LPSTR_TEXTCALLBACKW) : ((LPTSTR) LPSTR_TEXTCALLBACKA);

    Assert(hwndTooltip);
    SendMessage(
            hwndTooltip,
            (dwVersion < 0x80000000) ? (TTM_ADDTOOLW) : (TTM_ADDTOOLA),
            0,
            (LPARAM)(LPTOOLINFO)&tbToolInfo);
#endif
}

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(const LOGFONT *    lplf,
             const TEXTMETRIC * lptm,
             DWORD            iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    // We don't want to list the vertical fonts.
    // These by convention start with an @ symbol.
    if (lplf->lfFaceName[0] == L'@')
        return TRUE;

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const WCHAR *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);
    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------




void
CPadDoc::ConvColorrefToString(COLORREF crColor, LPTSTR szName, int cchName )
{
    int     i;
    BOOL fFound = FALSE;

    if(crColor == (COLORREF)-1)
    {
        szName[0] = 0;
        return;
    }

    // Reset the upper 8 bits because palettergb type color values have them
    // set to 0x20 and the compare will fail
    crColor &= 0xFFFFFF;

    for(i = 0; ComboColorItems[i].iIdm != 0; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        Format(0, szName, cchName, MAKEINTRESOURCE(ComboColorItems[i].iIdm));
    else
        szName[0] = 0;
}


DWORD
CPadDoc::AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;
    TCHAR   achColor[128];

    while(pComboItems->iIdm)
    {
        Format(0, achColor, ARRAY_SIZE(achColor),
                  MAKEINTRESOURCE(pComboItems->iIdm));

        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) achColor);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}
///--------------------------------------------------------------
//
// Member:    CPadDoc::IsEdit
//
// Synopsis: Return TRUE if we are in Edit Mode
//           False if in BROWSE Mode
//
//---------------------------------------------------------------

BOOL
CPadDoc::IsEdit()
{
    return ! _fUserMode;
}

//+=========================================================
//
// Update the Standard Toolbar UI.
//
//
//
//+=========================================================

LRESULT
CPadDoc::UpdateStandardToolbar()
{
   static const MsoCmdInfo TBBtnInfo[] = {
            { IDM_PAD_BACK,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_FORWARD, IDM_UNKNOWN,    NULL },
            { IDM_PAD_HOME,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_FIND,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_STOP,    OLECMDID_STOP,  NULL },
            { IDM_PAD_REFRESH, OLECMDID_REFRESH,NULL },
            { IDM_PAD_PRINT,   OLECMDID_PRINT, NULL },
            { IDM_PAD_CUT,     OLECMDID_CUT,   NULL },
            { IDM_PAD_COPY,    OLECMDID_COPY,  NULL },
            { IDM_PAD_PASTE,   OLECMDID_PASTE, NULL },
            { 0, 0, NULL }
    };
    int cButton;

    HRESULT hr = S_OK;
    MSOCMD msocmd;

    IOleCommandTarget* pCommandTarget = NULL;

    if (!_fStandardInit)
    {
        InitStandardToolbar();
        _fStandardInit = TRUE;
    }

    if (hr)
        goto Cleanup;

    if (!_hwndToolbar)
        goto Cleanup;

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;
    //
    // Make sure we are in sync with the doc user mode.
    //
    msocmd.cmdID = IDM_EDITMODE;
    msocmd.cmdf  = 0;
    if (OK(THR(pCommandTarget->QueryStatus(&CGID_MSHTML, 1, &msocmd, NULL))))
        _fUserMode = msocmd.cmdf != MSOCMDSTATE_DOWN;

    UpdateFontSizeBtns(pCommandTarget);

    for (cButton = 0; TBBtnInfo[cButton].localIDM; cButton ++)
    {
        msocmd.cmdID = TBBtnInfo[cButton].MsoCmdIDM;
        msocmd.cmdf  = 0;

        hr = pCommandTarget->QueryStatus(
            TBBtnInfo[cButton].MsoCmdGUID,
            1,
            &msocmd,
            NULL);

        if (_pBrowser && (IDM_UNKNOWN == TBBtnInfo[cButton].MsoCmdIDM))
        {
            SendMessage(
                    _hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(TRUE, 0));
        }
        else
        {
            SendMessage(
                    _hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(msocmd.cmdf & MSOCMDF_ENABLED ? TRUE : FALSE, 0));
        }

        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            SendMessage(
                    _hwndToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(
                            (msocmd.cmdf == MSOCMDSTATE_DOWN) ?
                                    (TRUE) : (FALSE),
                            0));
            break;
        }
        SendMessage(
                _hwndToolbar,
                TB_PRESSBUTTON,
                TBBtnInfo[cButton].localIDM,
                (LPARAM) MAKELONG(FALSE, 0));
    }



    SendMessage(
            _hwndToolbar,
            TB_CHANGEBITMAP,
            IDM_PAD_EDITBROWSE,
            MAKELPARAM(_fUserMode ? 13 : 12, 0));

    SendMessage(_hwndToolbar, TB_ENABLEBUTTON, (WPARAM)IDM_PAD_EDITBROWSE, !_pBrowser);

    pCommandTarget->Release();

Cleanup:
    return 0;
}

void
CPadDoc::UpdateFormatButtonStatus()
{
    UINT cButtons;
    CVariant var;
    int j, iIndex, iCurrentIndex;
    TCHAR szBuf[128];
    HWND  hwndCombobox = NULL;
    MSOCMD  msocmd;

        // update zoom combobox status
    static const UINT ComboSet[] = {
            IDM_FONTNAME,
            IDM_FONTSIZE,
            IDM_BLOCKFMT,
            IDM_FORECOLOR,
            0 };


    struct ButtonInfo {
        UINT ButtonIDM;
        UINT ToolbarIDR;
    };


    static const ButtonInfo tbButtons[] =
    {
        { IDM_BOLD,          IDR_HTMLFORM_TBFORMAT },
        { IDM_ITALIC,        IDR_HTMLFORM_TBFORMAT },
        { IDM_UNDERLINE,     IDR_HTMLFORM_TBFORMAT },
        { IDM_ORDERLIST,     IDR_HTMLFORM_TBFORMAT },
        { IDM_UNORDERLIST,   IDR_HTMLFORM_TBFORMAT },
        { IDM_INDENT,        IDR_HTMLFORM_TBFORMAT },
        { IDM_OUTDENT,       IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYLEFT,   IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYCENTER, IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYRIGHT,  IDR_HTMLFORM_TBFORMAT },
        { IDM_BLOCKDIRLTR,   IDR_HTMLFORM_TBFORMAT },
        { IDM_BLOCKDIRRTL,   IDR_HTMLFORM_TBFORMAT },
        { IDM_MULTIPLESELECTION,   IDR_HTMLFORM_TBFORMAT },
        { IDM_2D_POSITION,   IDR_HTMLPAD_TBFORMAT },
        { IDM_ABSOLUTE_POSITION,   IDR_HTMLPAD_TBFORMAT },
        { IDM_LIVERESIZE,    IDR_HTMLFORM_TBFORMAT },
       { 0, 0}
    };

    HRESULT hr;


    IOleCommandTarget * pCommandTarget = NULL;



    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;






    for (j = 0; ComboSet[j]; j ++)
    {
        switch (ComboSet[j])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            var.vt   = VT_I4;
            var.lVal = 0;
            break;
        case IDM_BLOCKFMT:
            hwndCombobox = _hwndComboTag;
            break;
        case IDM_FONTNAME:
            hwndCombobox = _hwndComboFont;
            break;
        case IDM_FORECOLOR:
            hwndCombobox = _hwndComboColor;
            break;
        }

        msocmd.cmdID = ComboSet[j];
        msocmd.cmdf  = 0;
        hr = THR( pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL));
        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            EnableWindow(hwndCombobox, TRUE);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableWindow(hwndCombobox, FALSE);
            break;
        }

        hr = THR_NOTRACE( pCommandTarget->Exec((GUID *)&CGID_MSHTML, ComboSet[j],
                MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &var));
        if (FAILED(hr))
            continue;

        switch (ComboSet[j])
        {
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            // It is legal for the returned bstr to be NULL.
            wcscpy(szBuf, (var.vt == VT_BSTR && var.bstrVal) ? var.bstrVal : TEXT(""));
            break;

        case IDM_FORECOLOR:
            if(V_VT(&var) == VT_NULL)
                szBuf[0] = 0;
            else
                ConvColorrefToString(V_I4(&var), szBuf, ARRAY_SIZE(szBuf));
            break;

        case IDM_FONTSIZE:
            // If the font size is changing in the selection VT_NULL is returned
            if(V_VT(&var) == VT_NULL)
            {
                szBuf[0] = 0;
            }
            else
            {
                Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), var.lVal);
            }
            break;
        }

        iIndex = SendMessage(
                hwndCombobox,
                CB_FINDSTRINGEXACT,
                (WPARAM) -1,
                (LPARAM)(LPTSTR) szBuf);

        if (iIndex == CB_ERR)
        {
            // CB_FINDSTRINGEXACT cannot find the string in the combobox.
            //
            switch (ComboSet[j])
            {
            case IDM_BLOCKFMT:
                // GetBlockFormat returns something not in the BlockFormat
                // combobox, display empty string.
                //
                iIndex = -1;
                break;

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
                // Nothing is selected
                iIndex = -1;
                break;
            }
        }

        iCurrentIndex = SendMessage(hwndCombobox, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if ( iCurrentIndex != iIndex )
            SendMessage(hwndCombobox, CB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0);

        VariantClear(&var);
    }

    // update buttons status
    BOOL fEnabled;
    BOOL fChecked;
    for (cButtons = 0; tbButtons[cButtons].ButtonIDM != 0; cButtons ++)
    {
        if (_hwndFormatToolbar)
        {
            msocmd.cmdID = tbButtons[cButtons].ButtonIDM;
            msocmd.cmdf  = 0;
            hr = pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL);

            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_DOWN:
            case MSOCMDSTATE_NINCHED:
                fEnabled = TRUE;
                fChecked = (msocmd.cmdf == MSOCMDSTATE_DOWN) ? TRUE : FALSE;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                fEnabled = FALSE;
                fChecked = FALSE;
                break;
            }
            SendMessage(
                    _hwndFormatToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fEnabled, 0));
            SendMessage(
                    _hwndFormatToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fChecked, 0));
            SendMessage(
                    _hwndFormatToolbar,
                    TB_PRESSBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(FALSE, 0));
        }

    }
Cleanup:

    if ( pCommandTarget)
        pCommandTarget->Release();

}

LRESULT
CPadDoc::UpdateFormatToolbar()
{
    if ( !_pInPlaceObject )
        goto Cleanup;


    if ( IsEdit())
    {
        if ( ! _fFormatInit )
        {
            InitFormatToolbar(); // Load the pull-downs and other fun stuff.
            _fFormatInit = TRUE;
        }
        UpdateFormatButtonStatus();
        if ( _fToolbarhidden )
            ShowFormatToolbar();
    }
    else if ( ! _fToolbarhidden )
    {
        HideFormatToolbar();
    }

Cleanup:
    return 0;

}

void
CPadDoc::ShowFormatToolbar()
{
    ::ShowWindow(_hwndFormatToolbar, SW_SHOW);
    _fToolbarhidden = FALSE;
    //
    //Resize
    //
    //
    ::SetMenu( _hwnd, _hmenuEdit );
    Resize();
}

void
CPadDoc::HideFormatToolbar()
{
    ::ShowWindow(_hwndFormatToolbar, SW_HIDE);
    _fToolbarhidden = TRUE;
    //
    // Resize
    //
    ::SetMenu( _hwnd, _hmenuMain );
    Resize();
}

LRESULT
CPadDoc::UpdateToolbarUI()
{
    UpdateStandardToolbar();
    UpdateFormatToolbar();
    UpdateDirtyUI();

    return 0;
}

///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateStandardToolbar
//
// Synopsis: Creates the Standard toolbar UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateStandardToolbar()
{
    HRESULT hr = S_OK;
    HWND   hwndToolbar = NULL;
    HFONT  hFont;
    DWORD  cTBCombos;
    TEXTMETRIC tm;
    HDC    hdc;
    HWND * pHwndCombo = NULL;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };
    static const ComboInfo tbCombos[] =
    {
        { IDM_ZOOMPERCENT, IDR_HTMLFORM_TBSTANDARD, 402, 60, 12,
                CBS_DROPDOWN},
        { 0, 0, 0, 0, 0}
    };

   //
    // Standard Toolbar table
    //
    static const TBBUTTON tbButton[] =
    {
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_PAD_BACK, 0, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_PAD_FORWARD, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 2, IDM_PAD_HOME, 0, TBSTYLE_BUTTON, 0L, 0},
        { 3, IDM_PAD_FIND, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 4, IDM_PAD_STOP, 0, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_PAD_REFRESH, 0, TBSTYLE_BUTTON, 0L, 0},
        { 6, IDM_PAD_PRINT, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 7, IDM_PAD_FONTINC, 0, TBSTYLE_BUTTON, 0L, 0},
        { 8, IDM_PAD_FONTDEC, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 9, IDM_PAD_CUT, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, IDM_PAD_COPY, 0, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_PAD_PASTE, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        {13, IDM_PAD_EDITBROWSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        {14, IDM_PAD_USESHDOCVW, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},

        // Reserve space for zoom combo.
        {70, 0, 0, TBSTYLE_SEP, 0L, 0}


    };




    //
    // Create the "standard" toolbar
    //

    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE /* TBSTYLE_TOOLTIPS*/,
            IDR_HTMLPAD_TOOLBAR,
            15,                             // number of bitmaps
            g_hInstResource,
            IDB_HTMLPAD_TOOLBAR,
            (LPCTBBUTTON) &tbButton,
            ARRAY_SIZE(tbButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));

    if (!_hwndToolbar)
    {
        hr = E_FAIL;
    }

    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_ZOOMPERCENT:
            pHwndCombo = &(_hwndComboZoom);
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLFORM_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLFORM_TBFORMAT:
            hwndToolbar = _hwndFormatToolbar;
            break;
        }

        Assert(hwndToolbar);

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                hwndToolbar,
                (HMENU)(ULongToPtr(tbCombos[cTBCombos].ComboIDM)),
                GetResourceHInst(),
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM)hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);
#ifdef IE6_VDEVICE
        EnableWindow(*pHwndCombo, TRUE);
#else
        EnableWindow(*pHwndCombo, FALSE);
#endif
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
        lpfnDefCombo = (WNDPROC) GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
        InstallComboboxTooltip(*pHwndCombo, tbCombos[cTBCombos].ComboIDM);

        if (*pHwndCombo == _hwndComboZoom)
        {
            WNDPROC lpfnDefEdit;
            HWND    hWndEdit;
            POINT   pt;

            //  Set window proc for zoom combo
            lpfnDefEdit = (WNDPROC)GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
            SetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC, (LONG_PTR)ZoomComboWndProc);
            SetWindowLongPtr(*pHwndCombo, GWLP_USERDATA, (LONG_PTR)lpfnDefEdit);

            //  Set window proc for zoom combo edit contol
            pt.x = 3;
            pt.y = 3;
            hWndEdit = ChildWindowFromPoint(*pHwndCombo, pt);
            lpfnDefEdit = (WNDPROC)GetWindowLongPtr(hWndEdit, GWLP_WNDPROC);
            SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)EditZoomWndProc);
            SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)lpfnDefEdit);
        }
    }
Cleanup:
RRETURN ( hr );

}
///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateFormatToolbar
//
// Synopsis: Creates the Formatting Toolbar UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateFormatToolbar()
{

    HRESULT hr = S_OK;
    int newTop = 0;


    HWND   hwndToolbar = NULL;
    HFONT  hFont;
    DWORD  cTBCombos;
    TEXTMETRIC tm;
    HDC    hdc;
    HWND * pHwndCombo = NULL;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };
    static const ComboInfo tbCombos[] =
    {
        { IDM_BLOCKFMT,  IDR_HTMLFORM_TBFORMAT,       5, 100, 16,
                CBS_DROPDOWNLIST},
        { IDM_FONTNAME,    IDR_HTMLFORM_TBFORMAT,   110, 150, 43,
                CBS_SORT | CBS_DROPDOWNLIST},
        { IDM_FONTSIZE,    IDR_HTMLFORM_TBFORMAT,   265,  40,  8,
                CBS_DROPDOWNLIST},
        { IDM_FORECOLOR,   IDR_HTMLFORM_TBFORMAT,   384,  55, 12,
                CBS_DROPDOWNLIST},
        { 0, 0, 0, 0, 0}
    };


    static const TBBUTTON tbFmtButton[] =
    {
        // reserved space for HTML Markup Tag,FontName, and FontSize Comboboxes
        {110, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {155, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        { 45, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {0, IDM_BOLD,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {1, IDM_ITALIC,    TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {2, IDM_UNDERLINE, TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},

        // reserved space for BackGroundColor Combobox.
        { 65, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {3, IDM_JUSTIFYLEFT,   TBSTATE_CHECKED, TBSTYLE_CHECK, 0L, 0},
        {4, IDM_JUSTIFYCENTER, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {5, IDM_JUSTIFYRIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {6, IDM_ORDERLIST,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0L, 0},
        {7, IDM_UNORDERLIST, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {8, IDM_OUTDENT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {9, IDM_INDENT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {10, IDM_BLOCKDIRLTR, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_BLOCKDIRRTL, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {12, IDM_MULTIPLESELECTION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {13, IDM_2D_POSITION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0 },
        {14, IDM_ABSOLUTE_POSITION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0 },
        {15, IDM_LIVERESIZE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
    };


    _hwndFormatToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | TBSTYLE_TOOLTIPS | CCS_NODIVIDER ,
            IDR_HTMLPAD_TOOLBAR,
            15,                             // number of bitmaps
            g_hInstResource,
            IDB_HTMLPAD_TBFORMAT ,
            (LPCTBBUTTON) &tbFmtButton,
            ARRAY_SIZE(tbFmtButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));

    if (!(_hwndFormatToolbar))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
        RECT rcClient;
        GetClientRect( _hwnd, &rcClient);

        RECT rcHost;
        GetWindowRect( _hwnd, & rcHost);
        newTop = 26 ;
        RECT rcTopToolbar;
        GetWindowRect( _hwndToolbar, &rcTopToolbar );
        newTop = rcTopToolbar.bottom - rcTopToolbar.top;
        RECT rcToolbar;
        GetWindowRect( _hwnd, &rcToolbar);

        ::MoveWindow(
                _hwndFormatToolbar,
                0,
                newTop  ,
                3000 /*rcHost.right - rcHost.left*/ ,
                rcToolbar.bottom - rcToolbar.top ,
                TRUE);


    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_BLOCKFMT:
            pHwndCombo = &(_hwndComboTag);
            break;
        case IDM_FONTNAME:
            pHwndCombo = &(_hwndComboFont);
            break;
        case IDM_FONTSIZE:
            pHwndCombo = &(_hwndComboSize);
            break;
        case IDM_FORECOLOR:
            pHwndCombo = &(_hwndComboColor);
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLFORM_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLFORM_TBFORMAT:
            hwndToolbar = _hwndFormatToolbar;
            break;
        }

        Assert(hwndToolbar);

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                hwndToolbar,
                (HMENU)(ULongToPtr(tbCombos[cTBCombos].ComboIDM)),
                GetResourceHInst(),
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM) hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);

        EnableWindow(*pHwndCombo, TRUE);
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
        lpfnDefCombo = (WNDPROC) GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
        InstallComboboxTooltip(*pHwndCombo, tbCombos[cTBCombos].ComboIDM);

        }

Cleanup:
    RRETURN ( hr );

}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::ResetZoomPercent
//
//--------------------------------------------------------------------
void
CPadDoc::ResetZoomPercent()
{
    ::SendMessage(_hwndComboZoom, CB_SETCURSEL, INDEX_ZOOM_100, 0);
}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::ApplyZoomPercent
//
//--------------------------------------------------------------------
void
CPadDoc::ApplyZoomPercent()
{
    ::SendMessage(
        _hwnd,
        WM_COMMAND,
        (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
        (LPARAM)_hwndComboZoom);
}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::InitStandardToolbar
//
//--------------------------------------------------------------------
void
CPadDoc::InitStandardToolbar()
{
    AddComboboxItems(_hwndComboZoom, TRUE, ComboZoomItems);
    ResetZoomPercent();
}


//+-------------------------------------------------------------------
//
// Member:  CDoc::InitFormatToolbar
//
//--------------------------------------------------------------------

void
CPadDoc::InitFormatToolbar()
{

    HDC      hdc;
    HRESULT  hr = S_OK ;

    struct ComboStruct {
        UINT ComboIDM;
        BOOL fLoaded;
    };

    // load items into ComboTag, ComboZoom and ComboSize comboboxes
    ComboStruct ComboLoad[] = {
            { IDM_FONTSIZE, FALSE },
            { IDM_GETBLOCKFMTS, FALSE },
            { 0, FALSE },
    };
    int i;

    if ( ! _fComboLoaded)
    {
        //
        // Load Font Names
        //
        hdc = ::GetDC(_hwnd);
        EnumFontFamilies(
                hdc,
                NULL,
                FillFontProc,
                (LPARAM)_hwndComboFont);
        ::ReleaseDC(_hwnd, hdc);


        //
        // Load Colors
        //
        AddComboboxItems(_hwndComboColor, TRUE, ComboColorItems);
        SendMessage(_hwndComboColor, CB_SETCURSEL, 0, 0);
        _fComboLoaded = TRUE;


        VARIANTARG varRange;
        LONG lLBound, lUBound, lIndex, lValue;
        BSTR  bstrBuf;
        TCHAR szBuf[64];
        SAFEARRAY * psa = NULL;
        HWND hwndCombobox = NULL;

        //
        // Load Sizes and Default Block Formats.
        //
        for (i = 0; ComboLoad[i].ComboIDM; i ++)
        {
            if (ComboLoad[i].fLoaded)
                continue;

            switch (ComboLoad[i].ComboIDM)
            {
            case IDM_FONTSIZE:
                hwndCombobox = _hwndComboSize;
                break;
            case IDM_GETBLOCKFMTS:
                hwndCombobox = _hwndComboTag;
                break;
            }
            varRange.vt = VT_ARRAY;
            varRange.parray = psa;

            IOleCommandTarget* pCommandTarget = NULL;

            if ( _pInPlaceObject )
                hr = THR( _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget));

            if ( ! hr )
                hr = THR( pCommandTarget->Exec(
                        (GUID *)&CGID_MSHTML,
                        ComboLoad[i].ComboIDM,
                        MSOCMDEXECOPT_DONTPROMPTUSER,
                        NULL,
                        &varRange));

            pCommandTarget->Release();

            // NULL pointer will sometimes return huge values and go into
            // an infinite loop.
            if (OK(hr) && V_ARRAY(&varRange) != NULL)
            {
                psa = V_ARRAY(&varRange);
                SafeArrayGetLBound(psa, 1, &lLBound);
                SafeArrayGetUBound(psa, 1, &lUBound);
                for (lIndex = lLBound; lIndex <= lUBound; lIndex ++)
                {
                    switch (ComboLoad[i].ComboIDM)
                    {
                    case IDM_GETBLOCKFMTS:
                        SafeArrayGetElement(psa, &lIndex, &bstrBuf);
                        SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) bstrBuf);
                        SysFreeString(bstrBuf);
                        break;

                    case IDM_FONTSIZE:
                        SafeArrayGetElement(psa, &lIndex, &lValue);
                        Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), lValue);
                        SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) szBuf);
                        break;
                    }
                }

                // OLEAUT32 crashes if psa is NULL
                if (psa)
                {
                    SafeArrayDestroyData(psa);
                }
                SafeArrayDestroy(psa);

                ComboLoad[i].fLoaded = TRUE;
            }
        }

        _fComboLoaded = TRUE;
    }

}

///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateToolBarUI
//
// Synopsis: Creates the PAD UI. We always create the "standard" toolbar
// and the Editing UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateToolBarUI()
{
    HRESULT hr = S_OK;

    CreateStandardToolbar();
    CreateFormatToolbar();

    if ( IsEdit())
        ShowFormatToolbar();
    else
        HideFormatToolbar();

    RRETURN ( hr );
}



void
CPadDoc::DestroyToolbars()
{
    if (_hwndToolbar)
    {
        if (_hwndComboZoom) DestroyWindow(_hwndComboZoom);
        DestroyWindow(_hwndToolbar);
        _hwndComboZoom = NULL;
        _hwndToolbar = NULL;
    }
    if (_hwndFormatToolbar)
    {
        if ( _hwndComboTag) DestroyWindow(_hwndComboTag);
        if ( _hwndComboFont) DestroyWindow(_hwndComboFont);
        if ( _hwndComboSize) DestroyWindow(_hwndComboSize);
        if ( _hwndComboColor) DestroyWindow(_hwndComboColor);
        DestroyWindow(_hwndFormatToolbar);

        _hwndComboTag   = NULL;
        _hwndComboFont  = NULL;
        _hwndComboSize  = NULL;
        _hwndComboColor = NULL;
        _hwndFormatToolbar   = NULL;
    }
}

//+======================
// Move it to the right place
//
//-----------------------
HRESULT
CPadDoc::MoveFormatToolbar()
{
    HRESULT hr = S_OK;

    if (_hwndToolbar || _hwndFormatToolbar)
    {
        RECT         rcToolbar;
        RECT         rcFormatToolbar;

        if ( _hwndToolbar)
        {
            GetWindowRect(_hwndToolbar, &rcToolbar);
        }
        else
        {
            SetRectEmpty(&rcToolbar);
        }
        if ( _hwndFormatToolbar)
        {
            GetWindowRect(_hwndFormatToolbar, &rcFormatToolbar);
        }
        else
        {
            SetRectEmpty(&rcFormatToolbar);
        }

        if (hr)
            goto Error;

        if ( _hwndFormatToolbar)
        {
            RECT rcRect;
            GetWindowRect( _hwnd, &rcRect );

            ::MoveWindow(
                    _hwndFormatToolbar,
                    0,
                    50 ,
                    rcFormatToolbar.right - rcFormatToolbar.left,
                    rcFormatToolbar.bottom - rcFormatToolbar.top,
                    TRUE);
        }
    }
Error:

    RRETURN_NOTRACE(hr);
}

BOOL CPadDoc::IsEditCommand(WORD idm)
{
    switch ( idm )
    {
        case IDM_IMAGE:
        case IDM_INSERTOBJECT:
        case IDM_HORIZONTALLINE:
        case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_PAGEBREAK:
        case IDM_SPECIALCHAR:
        case IDM_MARQUEE:
        case IDM_1D:
        case IDM_TEXTBOX:
#ifdef NEVER
        case IDM_HTMLAREA:
#endif
        case IDM_TEXTAREA:
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:
        case IDM_IFRAME:
            return TRUE;

        default:
            return FALSE;
        }
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::UpdateDirtyUI
//
//--------------------------------------------------------------------

LRESULT
CPadDoc::UpdateDirtyUI()
{
    BOOL  fDirty = GetDirtyState();
    BOOL  fDirtyUI;
    TCHAR szBuf[512];
    INT   iTitleLen;

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    iTitleLen = _tcslen(szBuf);
    Assert(iTitleLen > 0);

    fDirtyUI = (szBuf[iTitleLen-1] == TCHAR('*'));

    if (fDirty != fDirtyUI)
    {
        if (fDirty)
        {
            if (iTitleLen < 511)
            {
                szBuf[iTitleLen]   = TCHAR('*');
                szBuf[iTitleLen+1] = 0;
            }
        }
        else
        {
            szBuf[iTitleLen-1]= 0;
        }
        SetWindowText(_hwnd, szBuf);
    }

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::SetScriptRecorder
//
//--------------------------------------------------------------------

void
CPadDoc::SetScriptRecorder(IScriptRecorder *pScriptRecorder)
{
    delete _pScriptRecorder;
    _pScriptRecorder = pScriptRecorder;
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendQuotedString
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::AppendQuotedString(CStr &str, TCHAR *szString, UINT cLength)
{
    HRESULT hr = S_OK;

    for (UINT i = 0; i < cLength; i++)
    {
        switch (szString[i])
        {
            case '\n':
                IFC( str.Append(_T("\\n"), 2) );
                break;

            case '\t':
                IFC( str.Append(_T("\\t"), 2) );
                break;

            case '\r':
                IFC( str.Append(_T("\\r"), 2) );
                break;

            case '\"':
            case '\'':
            case '\\':
                IFC( str.Append(_T("\\"), 1) );
                IFC( str.Append(&szString[i], 1) );
                break;

            default:
                IFC( str.Append(&szString[i], 1) );
        }
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendElementHTML
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::AppendElementAttributes(IMarkupServices *pMarkupServices, CStr &str, IHTMLElement *pElement)
{
    HRESULT                     hr = S_OK;
    IDispatch                   *pdispAttrCollection = NULL;
    IHTMLAttributeCollection    *pAttrCollection = NULL;
    IHTMLDOMNode                *pDomNode = NULL;
    IDispatch                   *pdispAttr = NULL;
    IHTMLDOMAttribute           *pDomAttr = NULL;
    BOOL                        fFirstAttr = TRUE;
    LONG                        lLength;
    VARIANT                     varIndex;
    VARIANT_BOOL                vBool;
    LONG                        i;
    BSTR                        bstrNodeName = NULL;
    VARIANT                     varValue;
    VARIANT                     varValueBSTR;

    VariantInit(&varIndex);
    VariantInit(&varValue);
    VariantInit(&varValueBSTR);

    //
    // Get attribute collection
    //
    IFC( pElement->QueryInterface(IID_IHTMLDOMNode, (LPVOID *)&pDomNode) );
    IFC( pDomNode->get_attributes(&pdispAttrCollection) );
    if (!pdispAttrCollection)
        goto Cleanup;
    IFC( pdispAttrCollection->QueryInterface(IID_IHTMLAttributeCollection, (LPVOID *)&pAttrCollection) );

    //
    // Iterate through attributes
    //
    IFC( pAttrCollection->get_length(&lLength) );
    V_VT(&varIndex) = VT_I4;

    for (i = 0; i < lLength; ++i)
    {
        V_I4(&varIndex) = i;

        ClearInterface(&pdispAttr);
        IFC( pAttrCollection->item(&varIndex, &pdispAttr) );

        ClearInterface(&pDomAttr);
        IFC( pdispAttr->QueryInterface(IID_IHTMLDOMAttribute, (LPVOID *)&pDomAttr) );

        IFC( pDomAttr->get_specified(&vBool) );
        if (BOOL_FROM_VARIANT_BOOL(vBool))
        {
            // Output attribute
            SysFreeString(bstrNodeName);
            bstrNodeName = NULL;

            IFC( pDomAttr->get_nodeName(&bstrNodeName) );

            if (StrCmp(bstrNodeName, L"style") != 0)
            {
                // Output attribute sperator
                if (!fFirstAttr)
                    IFC( str.Append(L", ") )
                else
                    IFC( str.Append(_T(" ")) );

                fFirstAttr = FALSE;

                IFC( str.Append(bstrNodeName) );
                IFC( str.Append(L"=") );

                VariantClear(&varValue);
                IFC( pDomAttr->get_nodeValue(&varValue) );

                VariantClear(&varValueBSTR);
                IFC( VariantChangeType(&varValueBSTR, &varValue, 0, VT_BSTR) );

                IFC( str.Append(V_BSTR(&varValueBSTR)) );
            }
        }
    }


Cleanup:
    ReleaseInterface(pAttrCollection);
    ReleaseInterface(pdispAttrCollection);
    ReleaseInterface(pdispAttr);
    ReleaseInterface(pDomAttr);
    ReleaseInterface(pDomNode);
    SysFreeString(bstrNodeName);
    VariantClear(&varValue);
    VariantClear(&varValueBSTR);

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendHTML
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::AppendHTML(IMarkupServices *pMarkupServices, CStr &str, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    BOOL                fLeftOf;
    IHTMLElement        *pElement = NULL;
    IMarkupPointer      *pCurrent = NULL;
    MARKUP_CONTEXT_TYPE context;
    LONG                cch, cchGoal;
    BSTR                bstrTagName = NULL;
    const LONG          cBufferSize = 1024;
    TCHAR               szBuffer[cBufferSize];

    if (!pStart || !pEnd)
        return E_INVALIDARG;

    IFC( pMarkupServices->CreateMarkupPointer(&pCurrent) );
    IFC( pCurrent->MoveToPointer(pStart) );

    for (;;)
    {
        // Termination check
        IFC( pCurrent->IsLeftOf(pEnd, &fLeftOf) );
        if (!fLeftOf)
            break;

        // Output next
        cch = -1;
        ClearInterface(&pElement);

        IFC( pCurrent->Right(TRUE, &context, &pElement, &cch, NULL) );
        if (pElement)
        {
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
            IFC( pElement->get_tagName(&bstrTagName) );
        }

        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                Assert(pElement && bstrTagName);
                IFC( str.Append(_T("<")) );
                IFC( str.Append(bstrTagName) );
                IFC( AppendElementAttributes(pMarkupServices, str, pElement) );
                IFC( str.Append(_T(">")) );
                break;

            case CONTEXT_TYPE_ExitScope:
                Assert(pElement && bstrTagName);
                IFC( str.Append(_T("</")) );
                IFC( str.Append(bstrTagName) );
                IFC( str.Append(_T(">")) );
                break;

            case CONTEXT_TYPE_Text:
                IFC( pCurrent->IsLeftOfOrEqualTo(pEnd, &fLeftOf) );
                if (!fLeftOf)
                    IFC( pCurrent->MoveToPointer(pEnd) );

                IFC( pCurrent->Left(TRUE, NULL, NULL, &cch, NULL) );
                cchGoal = cch;
                while (cchGoal > 0)
                {
                    cch = min<LONG>(cchGoal, cBufferSize);

                    IFC( pCurrent->Right(TRUE, &context, NULL, &cch, szBuffer) );
                    Assert(context == CONTEXT_TYPE_Text);

                    IFC( str.Append(szBuffer, cch) );

                    cchGoal -= cch;
                }
                break;

            case CONTEXT_TYPE_None:
                goto Cleanup; // done
                break;

        }
    }


Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pCurrent);
    SysFreeString(bstrTagName);
    RRETURN(hr);
}


HRESULT
CPadDoc::IsPointerInside(IMarkupPointer *pPointer, IMarkupPointer *pRangeStart, IMarkupPointer *pRangeEnd)
{
    HRESULT hr = S_OK;
    BOOL    fIsInside = FALSE;

    IFC( pRangeStart->IsLeftOfOrEqualTo(pPointer, &fIsInside) );
    if (fIsInside)
    {
        IFC( pRangeEnd->IsRightOfOrEqualTo(pPointer, &fIsInside) );
    }

    hr = fIsInside ? S_OK : S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::InnerHTML
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::InnerHTML(IMarkupServices *pMarkupServices, IHTMLElement *pElement, BSTR *pbstrHTML)
{
    HRESULT                     hr;
    IMarkupPointer              *pStart = NULL;
    IMarkupPointer              *pEnd = NULL;
    IMarkupPointer2             *pStart2 = NULL;
    IMarkupPointer2             *pEnd2 = NULL;

#if DBG == 1
    IMarkupPointer              *pLastEnd = NULL;
    IMarkupPointer              *pLastStart = NULL;
    BOOL                        fLastStartPositioned = FALSE;
    BOOL                        fLastEndPositioned = FALSE;
#endif
    IMarkupPointer              *pSelStart = NULL;
    IMarkupPointer              *pSelEnd = NULL;

    CStr                        str;
    IHTMLEditServices           *pIEdSvc = NULL;
    ISelectionServices          *pSelSvc = NULL;
    IDispatch                   *pDocDisp = NULL;
    IHTMLDocument               *pDoc = NULL;
    IServiceProvider            *pSP = NULL;
    ISegmentList                *pSegmentList = NULL;
    ISegmentListIterator        *pIter = NULL;
    ISegment                    *pSegment = NULL;
    INT                         iSegmentCount = 0;
    SELECTION_TYPE              eSelectionType;
    BOOL                        fRightOf;

    if (!pbstrHTML)
        return E_INVALIDARG;

    *pbstrHTML = NULL;

    // Position pointers
    IFC( pMarkupServices->CreateMarkupPointer(&pStart) );
    IFC( pStart->QueryInterface( IID_IMarkupPointer2, (void**) & pStart2 ));
    IFC( pStart2->MoveToContent(pElement, TRUE ) );

    IFC( pMarkupServices->CreateMarkupPointer(&pEnd) );
    IFC( pEnd->QueryInterface( IID_IMarkupPointer2, (void**) & pEnd2 ));
    IFC( pEnd2->MoveToContent(pElement, FALSE) );

    // Get the selection services
    IFC( get_Document(&pDocDisp) );
    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
    IFC( pDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) );

    IFC( pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)& pIEdSvc ) );
    IFC( pIEdSvc->GetSelectionServices(NULL, &pSelSvc) );
    IFC( pSelSvc->QueryInterface(IID_ISegmentList, (LPVOID *)&pSegmentList ) );

    IFC( pSegmentList->GetType(&eSelectionType) );
    IFC( pSegmentList->CreateIterator(&pIter) );

    if( pIter->IsDone() == S_FALSE )
    {
        // TODO: sort all segment pointers for multiple selection

        IFC( pMarkupServices->CreateMarkupPointer(&pSelStart) );
        IFC( pMarkupServices->CreateMarkupPointer(&pSelEnd) );
#if DBG == 1
        IFC( pMarkupServices->CreateMarkupPointer(& pLastStart ));
        IFC( pMarkupServices->CreateMarkupPointer(& pLastEnd ));
#endif
        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pSegment) );

            IFC( pSegment->GetPointers(pSelStart, pSelEnd) );

            switch (eSelectionType)
            {
                case SELECTION_TYPE_Caret:
                    if (IsPointerInside(pSelStart, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelStart) );
                        IFC( str.Append(_T("{caret}")) );
                        IFC( pStart->MoveToPointer(pSelStart) );
                    }
                    break;

                case SELECTION_TYPE_Text:
                    IFC( pSelStart->IsRightOf(pSelEnd, &fRightOf) );
                    if (fRightOf)
                    {
                        // swap pointers
                        IMarkupPointer *pTempPointer = pSelStart;
                        pSelStart = pSelEnd;
                        pSelEnd = pTempPointer;
                    }

                    if (IsPointerInside(pSelStart, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelStart) );
                        IFC( str.Append(_T("{selection start}")) );
                        IFC( pStart->MoveToPointer(pSelStart) );
#if DBG == 1
                        if ( fLastStartPositioned )
                        {
                            BOOL fLastRightOf = FALSE;
                            pSelStart->IsRightOfOrEqualTo( pLastStart, & fLastRightOf);
                            AssertSz( fLastRightOf, "Multiple Text Selection Segments are not ordered");
                        }
                        pLastStart->MoveToPointer( pSelStart );
                        fLastStartPositioned = TRUE;
#endif
                    }
                    if (IsPointerInside(pSelEnd, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelEnd) );
                        IFC( str.Append(_T("{selection end}")) );
                        IFC( pStart->MoveToPointer(pSelEnd) );
#if DBG == 1
                        if ( fLastEndPositioned )
                        {
                            BOOL fLastRightOf = FALSE;
                            pSelEnd->IsRightOfOrEqualTo( pLastEnd, & fLastRightOf);
                            AssertSz( fLastRightOf, "Multiple Text Selection Segments are not ordered");
                        }
                        pLastEnd->MoveToPointer( pSelEnd );
                        fLastEndPositioned = TRUE;
#endif

                    }
                    break;
            }

            ClearInterface( &pSegment );
            IFC( pIter->Advance() );
        }
    }

    IFC( AppendHTML(pMarkupServices, str, pStart, pEnd) );
    IFC( str.AllocBSTR(pbstrHTML) );


Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    ReleaseInterface(pStart2);
    ReleaseInterface(pEnd2);
    ReleaseInterface(pSelStart);
    ReleaseInterface(pSelEnd);
    ReleaseInterface(pIEdSvc);
    ReleaseInterface(pSelSvc);
    ReleaseInterface(pSegmentList);
    ReleaseInterface(pDocDisp);
    ReleaseInterface(pDoc);
    ReleaseInterface(pSP);
    ReleaseInterface(pIter);
    ReleaseInterface(pSegment);
#if DBG == 1
    ReleaseInterface( pLastStart );
    ReleaseInterface( pLastEnd );
#endif
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::CurrentBlockElement
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::CurrentBlockElement( IMarkupServices  *pMarkupServices,
                              IHTMLElement     **ppBlockElement )
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pOldElement   = NULL;
    IHTMLElement        *pElement      = NULL;
    BSTR                bstrDisplay = NULL;
    IHTMLElement2       *pElement2 = NULL;
    IHTMLCurrentStyle   *pCurrStyle = NULL;
    IHTMLCurrentStyle2  *pCurrStyle2 = NULL;
    IDisplayServices    *pDisplayServices = NULL;
    IHTMLCaret          *pCaret        = NULL;
    IMarkupPointer      *pCaretPointer = NULL;
    BOOL                fStopAtElement;
    VARIANT_BOOL        fHasLayout;

    if (!ppBlockElement || !pMarkupServices)
        return E_INVALIDARG;

    *ppBlockElement = NULL;
    IFC( pMarkupServices->QueryInterface(IID_IDisplayServices, (LPVOID *)&pDisplayServices) );

    // Get scope of caret
    IFC( pDisplayServices->GetCaret(&pCaret) );
    IFC( pMarkupServices->CreateMarkupPointer(&pCaretPointer) );
    IFC( pCaret->MoveMarkupPointerToCaret(pCaretPointer) );
    IFC( pCaretPointer->CurrentScope(&pElement) );

    // Walk up to find current block element
    do
    {
        IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        IFC(pElement2->get_currentStyle(&pCurrStyle));
        if (pCurrStyle)
        {
            IFC(pCurrStyle->get_display(&bstrDisplay));
            fStopAtElement = !_tcscmp(bstrDisplay, _T("block"));

            if (fStopAtElement)
                break;

            IFC(pCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&pCurrStyle2));
            IFC(pCurrStyle2->get_hasLayout(&fHasLayout));

            fStopAtElement = fHasLayout ? TRUE : FALSE;
            if (fStopAtElement)
                break;
        }

        pOldElement = pElement;
        hr = THR(pOldElement->get_parentElement(&pElement));
        pOldElement->Release();
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElement2);
        ClearInterface(&pCurrStyle);
        ClearInterface(&pCurrStyle2);
        SysFreeString(bstrDisplay);
        bstrDisplay = NULL;
    }
    while (pElement);

    if (fStopAtElement)
    {
        *ppBlockElement = pElement;
        pElement->AddRef();
    }

Cleanup:
    ReleaseInterface(pDisplayServices);
    ReleaseInterface(pElement);
    ReleaseInterface(pElement2);
    ReleaseInterface(pCurrStyle);
    ReleaseInterface(pCurrStyle2);
    ReleaseInterface(pCaret);
    ReleaseInterface(pCaretPointer);
    SysFreeString(bstrDisplay);
    RRETURN(hr);
}

HRESULT
CPadDoc::InitEditMode()
{
    HRESULT hr ;
    IOleCommandTarget* pCommandTarget = NULL;
    VARIANT var;
    GUID theGUID = CGID_MSHTML;

    VariantInit( & var );
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_TRUE;

    hr = THR(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_MULTIPLESELECTION,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    if ( hr )
        goto Cleanup;

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_2D_POSITION ,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_ABSOLUTE_POSITION ,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_LIVERESIZE,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));
    if ( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pCommandTarget );

    RRETURN( hr );

}

//+====================================================================================
//
// Method: OnSetTitle
//
// Synopsis: Change the window UI. Also a cheap way to sync doc changes.
//
//------------------------------------------------------------------------------------


VOID
CPadDoc::OnSetTitle( TCHAR* pchTitle)
{
    SetDocTitle(pchTitle);
}

VOID
CPadDoc::InplaceDeactivate()
{
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::InitCicero
//              Initialize Cicero -- the Universal Input Manager
//              It is implemented as a designer extention to the editor
//
//  Created:    Nov-12-1999     zhenbinx
//--------------------------------------------------------------------
#if CICERO==1
HRESULT CPadDoc::ToggleCicero(void)
{
    HRESULT        hr = S_OK;
    IDispatch      *pDispatch = NULL;
    IHTMLDocument2 *pHTMLDoc = NULL;

    IFC( get_Document(&pDispatch) );
    IFC( pDispatch->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDoc) );
    if (_pCicero)
    {
        IFC(_pCicero->Unattach());
        IFC(_pCicero->DeInitUim());
        ClearInterface(&_pCicero);
    }
    else
    {
        IFC(CoCreateInstance(CLSID_HTMLUim, NULL, CLSCTX_INPROC_SERVER,
                             IID_IHTMLUim, (LPVOID *)&_pCicero));

        IFC(_pCicero->InitUim());
        IFC(_pCicero->Attach(pHTMLDoc) );
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pHTMLDoc);
    RRETURN(hr);
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::EnableIMEReconversion
//
//  Created:    01/26/1999     zhenbinx
//--------------------------------------------------------------------
HRESULT
CPadDoc::EnableIMEReconversion(BOOL fEnable)
{
    IOleCommandTarget   *pCommandTarget;
    HRESULT hr = S_OK;
    if ( _pInPlaceObject &&
         OK(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget, (void **)&pCommandTarget)) )
    {
        VARIANT var;

        VariantInit(&var);
        var.vt = VT_BOOL;
        V_BOOL(&var) = fEnable? VARIANT_TRUE : VARIANT_FALSE;

        hr = pCommandTarget->Exec(
                &CGID_MSHTML,
                IDM_IME_ENABLE_RECONVERSION,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                &var,
                NULL);

        pCommandTarget->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padguid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padguid.cxx
//
//  Contents:   GUIDs
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

const GUID CLSID_CPadMessage = { 0xad000221, 0xa915, 0x11cf, 0x9c, 0xce, 0x00, 0xa0, 0xc9, 0x05, 0x64, 0xde };
const GUID IID_ICommandID = { 0x4a18a0e0, 0xae5d, 0x11cf, { 0xbf, 0xf1, 0x0, 0xaa, 0x0, 0x3f, 0x40, 0xd0 } };
const GUID GUID_ShellDocView = { 0x000214d1, 0, 0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const GUID CLSID_NSCP = { 0x61d8de20, 0xca9a, 0x11ce, 0x9e, 0xa5, 0x00, 0x80, 0xc8, 0x2b, 0xe3, 0xb6 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pad.rc
//
#define IDR_SEND_FORM                   2
#define IDR_READ_FORM                   3
#define IDR_PAD_ACCELERATORS            4
#define IDS_E_OUTOFMEMORY               100
#define IDF_CFG_FILE                    100
#define IDR_PADICON                     101
#define IDS_INVALID_ARGUMENT            101
#define IDF_SMALL_ICON                  101
#define IDR_PADMENU                     102
#define IDS_INVALID_OBJECT              102
#define IDF_LARGE_ICON                  102
#define IDR_PADHELPMENU                 103
#define IDS_INTERFACE_NOT_SUPPORTED     103
#define IDS_ACCESS_DENIED               104
#define IDR_SELECT_TOOL                 105
#define IDS_NOT_SUPPORTED               105
#define IDS_INVALID_CHARWIDTH           106
#define IDR_WELCOME_DLG                 107
#define IDS_NOT_FOUND                   107
#define IDR_FRAMESITE_TOOL              108
#define IDS_CALL_FAILED                 108
#define IDR_TWODSITE_TOOL               109
#define IDS_USER_CANCEL                 109
#define IDR_TEXTSITE_TOOL               110
#define IDS_ERRORS_RETURNED             110
#define IDS_UNKNOWN_FLAGS               111
#define IDS_UNEXPECTED                  112
#define IDB_PAD_SPLASH                  112
#define IDS_CANTNOW                     113
#define IDS_COMPONENT                   114
#define IDI_PADSMALLICON                115
#define IDB_MESSAGE_SEND                118
#define IDR_IMAGE_TOOL                  119
#define IDR_ABOUT_DIALOG                119
#define IDR_TEXTBOX_TOOL                120
#define IDR_LISTBOX_TOOL                121
#define IDR_CHECKBOX_TOOL               122
#define IDR_RADIOBUTTON_TOOL            123
#define IDR_BUTTON_TOOL                 124
#define IDR_PADMENU_EDIT                125
#define IDB_HTMLPAD_TOOLBAR             1000
#define IDM_MESSAGE_SAVE                1000
#define IDB_MESSAGE_TOOLBAR             1001
#define IDM_MESSAGE_MOVE                1002
#define IDM_MESSAGE_COPY                1003
#define IDM_MESSAGE_PRINT               1004
#define IDM_MESSAGE_DELETE              1005
#define IDM_MESSAGE_CLOSE               1006
#define IDM_MESSAGE_SUBMIT              1007
#define IDM_MESSAGE_REPLY               1008
#define IDM_MESSAGE_REPLY_ALL           1009
#define IDM_MESSAGE_FORWARD             1010
#define IDR_MESSAGE_TOOLBAR             1011
#define ID_SUBMIT                       1013
#define IDB_HTMLPAD_TBSTANDARD          1014
#define IDB_HTMLPAD_TBFORMAT            1015
#define IDR_OPEN_URL                    1122
#define IDI_ADDRESS                     1123
#define IDR_HTMLPAD_TOOLBAR             1200
#define IDM_VIEW_ITEMABOVE              1200
#define IDM_VIEW_ITEMBELOW              1201
#define IDR_HTMLPAD_TBSTANDARD          1202
#define IDR_HTMLPAD_TBFORMAT            1203
#define IDR_HTMLPAD_CONTEXT_MENU        1205
#define IDM_PAD_TESTTEMPLATES           1206
#define IDM_PAD_SAVE                    2000
#define ID_TO_BUTTON                    2000
#define IDM_PAD_SAVEAS                  2001
#define IDM_PAD_PAGESETUP               2002
#define ID_CC_BUTTON                    2002
#define IDM_PAD_PRINT                   2003
#define ID_CC                           2003
#define ID_SUBJECT_LABEL                2004
#define IDM_PAD_EXIT                    2006
#define ID_FROM_LABEL                   2006
#define IDM_PAD_BACK                    2007
#define ID_FROM                         2007
#define IDM_PAD_FORWARD                 2008
#define ID_SENT_LABEL                   2008
#define IDM_PAD_UPLEVEL                 2009
#define ID_SENT                         2009
#define IDM_PAD_OPTIONS                 2010
#define ID_TO_LABEL                     2010
#define IDM_PAD_OPENFAVORITE            2011
#define ID_TO                           2011
#define IDM_PAD_ADDFAVORITE             2012
#define ID_CC_LABEL                     2012
#define IDM_PAD_ABOUT                   2013
#define ID_SUBJECT                      2013
//#define IDM_PAD_TOOLBOX               2014
#define IDM_PAD_DEBUG_TRACE             2015
#define IDM_PAD_OPEN_URL                2017
#define IDM_PAD_OPEN_FILE               2018
#define IDM_PAD_NEW_HTML                2019
#define IDM_PAD_PRINTPREVIEW            2020
#define IDM_PAD_GOTO                    2021
#define IDM_PAD_HOME                    2022
#define IDM_PAD_REGISTER_LOCAL_TRIDENT  2023
#define IDM_PAD_STOP                    2024
#define IDM_PAD_REFRESH                 2025
#define IDM_PAD_FONTINC                 2026
#define IDM_PAD_FONTDEC                 2027
#define IDM_PAD_CUT                     2028
#define IDM_PAD_COPY                    2029
#define IDM_PAD_PASTE                   2030
#define IDM_PAD_EDITBROWSE              2031
#define IDM_PAD_EXECUTE_DRT             2034
#define IDM_PAD_EXECUTE_SCRIPT          2035
#define IDM_PAD_REGISTER_SYSTEM_TRIDENT 2036
#define IDM_PAD_OPENNSCP                2037
#define IDM_PAD_LOGTIME                 2038
#define IDM_PAD_IMMEDIATE_WINDOW        2039
#define IDM_PAD_NEWWIN                  2040
#define IDD_CFDIALOG                    2045
#define IDC_TREEVIEW                    2046
#define IDC_NEWFLD                      2047
#define IDI_ALLSTORES                   2048
#define IDI_ROOTFLD                     2049
#define IDI_OPENFLD                     2050
#define IDI_CLSDFLD                     2051
#define IDD_NEWNAME                     2052
#define IDC_NAME                        2053
#define IDC_NAMELABEL                   2054
#define IDM_PAD_SCRUB                   2055
#define IDM_PAD_REGISTER_PAD            2058
#define IDS_ErrorCaptionMail            2059
#define IDS_TripoleFullName             2060
#define IDM_MESSAGE_SAVE_AS             2061
#define IDM_PAD_REGISTER_MSG            2062
#define IDM_MESSAGE_OPENHTM             2063
#define IDM_PAD_CLEAR_CACHE             2064
#define IDM_MESSAGE_CHECK_NAMES         2065
#define IDM_PAD_VIEW_MON                2066
#define IDM_PAD_MEM_MON                 2067
#define IDM_PAD_FIND                    2070
#define IDM_PAD_SHORTCUT                2071
#define IDM_PAD_SENDFLOPPY              2072
#define IDM_PAD_SENDMAIL                2073
#define IDM_PAD_SENDBRIEFCASE           2074
#define IDM_PAD_SENDWEB                 2075
#define IDM_PAD_EDIT                    2076
#define IDM_PAD_BROWSE                  2077
#define IDM_PAD_PROPERTIES              2078
#define IDC_BITMAPSPLASH                2079
#define IDM_PAD_USESHDOCVW              2080
#define IDM_PAD_HOSTSHDOCVW             2081
#define IDM_PAD_UNHOSTSHDOCVW           2082
#define IDM_PAD_RELOADHIST              2083
#define IDM_PAD_CLOSE                   2084
#define IDM_PAD_METERS                  2085
#define IDM_PAD_PERFTAGS                2086
#define IDS_COLOR_BLACK                 2087
#define IDS_COLOR_NAVY                  2088
#define IDS_COLOR_BLUE                  2089
#define IDS_COLOR_CYAN                  2090
#define IDS_COLOR_RED                   2091
#define IDS_COLOR_LIME                  2092
#define IDS_COLOR_GRAY                  2093
#define IDS_COLOR_GREEN                 2094
#define IDS_COLOR_YELLOW                2095
#define IDS_COLOR_PINK                  2096
#define IDS_COLOR_VIOLET                2097
#define IDS_COLOR_WHITE                 2098

#define IDS_ZOOM_1000                   2099
#define IDS_ZOOM_900                    2100
#define IDS_ZOOM_800                    2101
#define IDS_ZOOM_700                    2102
#define IDS_ZOOM_600                    2103
#define IDS_ZOOM_500                    2104
#define IDS_ZOOM_400                    2105
#define IDS_ZOOM_300                    2106
#define IDS_ZOOM_275                    2107
#define IDS_ZOOM_250                    2108
#define IDS_ZOOM_225                    2109
#define IDS_ZOOM_200                    2110
#define IDS_ZOOM_175                    2111
#define IDS_ZOOM_150                    2112
#define IDS_ZOOM_125                    2113
#define IDS_ZOOM_100                    2114
#define IDS_ZOOM_90                     2115
#define IDS_ZOOM_80                     2116
#define IDS_ZOOM_75                     2117
#define IDS_ZOOM_70                     2118
#define IDS_ZOOM_60                     2119
#define IDS_ZOOM_50                     2120
#define IDS_ZOOM_40                     2121
#define IDS_ZOOM_30                     2122
#define IDS_ZOOM_25                     2123
#define IDS_ZOOM_20                     2124
#define IDS_ZOOM_15                     2125
#define IDS_ZOOM_10                     2126
#define IDS_ZOOM_5                      2127
#define IDS_ZOOM_1                      2128

#define IDM_PAD_VERIFYHTML_CUR_BLOCK    10000
#define IDM_PAD_VERIFYHTML_BODY         10001
#define IDM_PAD_TOGGLE_CICERO           10002
#define IDM_PAD_SHOWGLYPHS              10003
#define IDM_PAD_ENABLE_IME_RECONVERSION   10004
#define IDM_PAD_DISABLE_IME_RECONVERSION  10005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         2089
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padrc2.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padrc2.h
//
//  Contents:   Definitions for the Trident application
//
//-------------------------------------------------------------------------


//
// Custom Resource types
//

#define FILERESOURCE    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padole.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padole.cxx
//
//  Contents:   CPadDoc IOleObject implementation.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

HRESULT
CPadDoc::SetClientSite(IOleClientSite *)
{
    RRETURN(E_NOTIMPL);
}
       
HRESULT
CPadDoc::GetClientSite(IOleClientSite **ppClientSite)
{
    *ppClientSite = NULL;
    return S_OK;
}
      
HRESULT
CPadDoc::SetHostNames(LPCOLESTR, LPCOLESTR)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Close(DWORD)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetMoniker(DWORD , IMoniker *)
{
    RRETURN(E_NOTIMPL);
}
  
HRESULT
CPadDoc::GetMoniker(DWORD, DWORD, IMoniker **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::InitFromData(IDataObject *, BOOL, DWORD)
{
    RRETURN(E_NOTIMPL);
}
        
HRESULT
CPadDoc::GetClipboardData(DWORD, IDataObject **)
{
    RRETURN(E_NOTIMPL);
}
       
HRESULT
CPadDoc::DoVerb(LONG, LPMSG, IOleClientSite *, LONG, HWND, LPCOLERECT)
{
    RRETURN(E_NOTIMPL);
}
    
HRESULT
CPadDoc::EnumVerbs(IEnumOLEVERB **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Update()
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::IsUpToDate()
{
    RRETURN(E_NOTIMPL);
}
     
HRESULT
CPadDoc::GetUserClassID(CLSID *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetUserType(DWORD, LPOLESTR *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetExtent(DWORD, SIZEL *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetExtent(DWORD, SIZEL *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Advise(IAdviseSink *, DWORD *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Unadvise(DWORD)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::EnumAdvise(IEnumSTATDATA **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetMiscStatus(DWORD, DWORD *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetColorScheme(LOGPALETTE  *pLogpal)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::ParseDisplayName(IBindCtx *, LPOLESTR, ULONG *, IMoniker **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::EnumObjects(DWORD, IEnumUnknown **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::LockContainer(BOOL)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padsend.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padauto.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

enum SENDKEY_FLAGS
{
    FLAG_SHIFT      = 1,
    FLAG_CONTROL    = 2,
    FLAG_MENU       = 4
};

//---------------------------------------------------------------------------
//?
//  Member:     CPadDoc::EnqueueKeyAction
//
//  Synopsis:   Enqueue action for later processing.  Actions are
//              processed by DoKeyAction in response to WM_USER messages.
//
//---------------------------------------------------------------------------

void
CPadDoc::EnqueueKeyAction(DWORD dwFlags, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if ( IsWindow( g_hwndActiveWindow ) )
    {
        PostMessage(g_hwndActiveWindow, msg, wParam, lParam);
    }
    else
    {
        PADTHREADSTATE * pts = GetThreadState();
        SENDKEY_ACTION *paction;

        if (pts->caction >= ARRAY_SIZE(pts->aaction) - 1)
        {
            Assert(0 && "SendKey buffer overflow.");
            return;
        }

        paction = &pts->aaction[pts->caction++];
        paction->msg  = msg;
        paction->wParam = wParam;
        paction->lParam = lParam;
        paction->dwFlags = dwFlags;

        if (pts->caction == 1)
        {
            PostMessage(_hwnd, WM_DOKEYACION, 0, 0);
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::DoKeyAction
//
//  Synopsis:   This method is called in response to a WM_USER message
//              and processes on keyboard action at a time.  If more
//              keyboard actions are waiting, it posts a new WM_USER
//              message. 
//
//---------------------------------------------------------------------------

void
CPadDoc::DoKeyAction()
{
    PADTHREADSTATE * pts = GetThreadState();
    SENDKEY_ACTION * paction;
    BYTE             abState[256];
    HWND             hwnd;
    MSG              msg = {0};
    
    Assert(pts->iaction < pts->caction);
    paction = &pts->aaction[pts->iaction++];   

    if (!_fKeyStateLocked)
    {
        if (GetKeyboardState(abState))
        {
            abState[VK_SHIFT] = (paction->dwFlags & FLAG_SHIFT) ? 0x80 : 0;
            abState[VK_CONTROL] = (paction->dwFlags & FLAG_CONTROL) ? 0x80 : 0;
            abState[VK_MENU] = (paction->dwFlags & FLAG_MENU) ? 0x80 : 0;
            SetKeyboardState(abState);
        }
    }

    msg.message = paction->msg;
    msg.wParam = paction->wParam;
    msg.lParam = paction->lParam;

    if (GetLastActivePopup(_hwnd) == _hwnd)
    {
        if ((hwnd = GetFocus()) != NULL)
        {
            // use focus window if we can get one
        }
        else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
        {
            // use inplace active object hwnd
        }
        else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
        {
            // use inplace object window
        }
        else
        {
            // use our window
            hwnd = _hwnd;
        }

        msg.hwnd = hwnd;
        if (!OnTranslateAccelerator(&msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            // Retrieve the WM_CHAR/WM_SYSCHAR message that may have been
            // generated by TranslateMessage() and dispatch it
            // immediately, so that it gets processed with the right
            // key state set.
            if (PeekMessage(&msg,
                     msg.hwnd, 
                    (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR, 
                    (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR,
                    PM_REMOVE))

            {
                if (!OnTranslateAccelerator(&msg))
                    DispatchMessage(&msg);
            }
        }
    }
    else
    {
        // Active window is not the pad window.  Make it be the foreground
        // window so that the focus is correct.
        
        if (GetForegroundWindow() != GetLastActivePopup(_hwnd))
        {
            SetForegroundWindow(GetLastActivePopup(_hwnd));
        }

        // Send the message to the foreground window.
        msg.hwnd = GetFocus();

        if (paction->dwFlags & (FLAG_MENU|FLAG_SHIFT|FLAG_CONTROL))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            // Retrieve the WM_CHAR/WM_SYSCHAR message that may have been
            // generated by TranslateMessage() and dispatch it
            // immediately, so that it gets processed with the right
            // key state set.
            if (PeekMessage(&msg,
                        msg.hwnd, 
                        (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR, 
                        (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR,
                        PM_REMOVE))

             {
                DispatchMessage(&msg);
             }
        }
        else
            PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
    }

    if (pts->iaction < pts->caction)
    {
        PostMessage(_hwnd, WM_DOKEYACION, 0, 0);
    }
    else
    {
        if (!_fKeyStateLocked)
        {
            abState[VK_MENU] = 0;
            abState[VK_SHIFT] = 0;
            abState[VK_CONTROL] = 0;
            SetKeyboardState(abState);
        }
        pts->iaction = 0;
        pts->caction = 0;

        if (_pDebugWindow && pts->fDebugWindowInFront)
        {
            SetForegroundWindow(_pDebugWindow->_hwnd);
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::LockKeyState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LockKeyState(VARIANT_BOOL fShift, VARIANT_BOOL fControl, VARIANT_BOOL fAlt)
{
    if (!_fKeyStateLocked)
    {
        BYTE    abState[256];
    
        _fKeyStateLocked = TRUE;
        if (GetKeyboardState(abState))
        {
            abState[VK_SHIFT] = (fShift) ? 0x80 : 0;
            abState[VK_CONTROL] = (fControl) ? 0x80 : 0;
            abState[VK_MENU] = (fAlt) ? 0x80 : 0;
            SetKeyboardState(abState);
        }
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::UnlockKeyState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::UnlockKeyState()
{
    if (_fKeyStateLocked)
    {
        BYTE    abState[256];
    
        _fKeyStateLocked = FALSE;
        if (GetKeyboardState(abState))
        {
            abState[VK_MENU] = 0;
            abState[VK_SHIFT] = 0;
            abState[VK_CONTROL] = 0;
            SetKeyboardState(abState);
        }
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SendKeys, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SendKeys(BSTR bstrKeys, VARIANT_BOOL fWait)
{
    PADTHREADSTATE * pts = GetThreadState();
    TCHAR * pch;

    if (!g_hwndActiveWindow && !_pInPlaceActiveObject)
        return S_OK;

    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            SetForegroundWindow( g_hwndActiveWindow );
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (_pDebugWindow &&
        GetForegroundWindow() == _pDebugWindow->_hwnd)
    {
        pts->fDebugWindowInFront = TRUE;
        SetForegroundWindow(GetLastActivePopup(_hwnd));
    }
    else
    {
        pts->fDebugWindowInFront = FALSE;
    }

    pch = bstrKeys;

    while (*pch != 0)
    {
        pch = SendKey(pch, 0);
    }

    if (fWait)
    {
        Run(TRUE);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SendKey, IPad
//
//---------------------------------------------------------------------------
          
TCHAR *
CPadDoc::SendKey(TCHAR * pch, DWORD dwFlags)
{
    switch (*pch)
    {
    case _T('+'):
        pch = SendKey(++pch, dwFlags | FLAG_SHIFT);
        break;
    
    case _T('^'):
        pch = SendKey(++pch, dwFlags | FLAG_CONTROL);
        break;
     
    case _T('%'):
        pch = SendKey(++pch, dwFlags | FLAG_MENU);
        break;

    case _T('{'):
        pch = SendSpecial(++pch, dwFlags);
        break;

    case _T('~'):
        EnqueueKeyAction(dwFlags, WM_KEYDOWN, VK_RETURN, (LPARAM)1);

        // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
        // generates spurious WM_CHAR.
        EnqueueKeyAction(dwFlags, WM_KEYUP, VK_RETURN, (LPARAM)0xc0000001);
        pch++;
        break;

    case _T('('):
        pch++;
        while (*pch != _T(')') && *pch != 0)
            pch = SendKey(pch, dwFlags);
        if(*pch == _T(')'))
            pch++;
        break;

    default:
        {
            WORD vKeyCode = VkKeyScan(*pch++);
        
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_SYSKEYDOWN, LOBYTE(vKeyCode), 0x20000001);
            else
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_KEYDOWN, LOBYTE(vKeyCode),1);

            // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
            // generates spurious WM_CHAR.            
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_SYSKEYUP, LOBYTE(vKeyCode), 0xc0000001);
            else
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_KEYUP, LOBYTE(vKeyCode), 0xc0000001);
        }
        break;
    }

    return pch;
}

struct KEYENTRY
{
    TCHAR achName[20];
    int nKey;
};

KEYENTRY aKeyEntry[] =
{
    {_T("BACKSPACE"),   VK_BACK},
    {_T("BS"),          VK_BACK},
    {_T("BKSP"),        VK_BACK},
    {_T("BREAK"),       VK_PAUSE},
    {_T("CAPSLOCK"),    VK_CAPITAL},
    {_T("DELETE"),      VK_DELETE},
    {_T("DEL"),         VK_DELETE},
    {_T("DOWN"),        VK_DOWN},
    {_T("END"),         VK_END},
    {_T("ENTER"),       VK_RETURN},
    {_T("ESC"),         VK_ESCAPE},
    {_T("HOME"),        VK_HOME},
    {_T("INSERT"),      VK_INSERT},
    {_T("LEFT"),        VK_LEFT},
    {_T("NUMLOCK"),     VK_NUMLOCK},
    {_T("PGDN"),        VK_NEXT},
    {_T("PGUP"),        VK_PRIOR},
    {_T("PRTSC"),       VK_SNAPSHOT},
    {_T("RIGHT"),       VK_RIGHT},
    {_T("SCROLLLOCK"),  VK_SCROLL},
    {_T("TAB"),         VK_TAB},
    {_T("UP"),          VK_UP},
    {_T("HELP"),        VK_HELP},
    {_T("NUMPAD0"),     VK_NUMPAD0},
    {_T("NUMPAD0"),     VK_NUMPAD1},
    {_T("NUMPAD0"),     VK_NUMPAD2},
    {_T("NUMPAD0"),     VK_NUMPAD3},
    {_T("NUMPAD0"),     VK_NUMPAD4},
    {_T("NUMPAD0"),     VK_NUMPAD5},
    {_T("NUMPAD0"),     VK_NUMPAD6},
    {_T("NUMPAD0"),     VK_NUMPAD7},
    {_T("NUMPAD0"),     VK_NUMPAD8},
    {_T("NUMPAD0"),     VK_NUMPAD9},
    {_T("MULTIPLY"),    VK_MULTIPLY},
    {_T("ADD"),         VK_ADD},
    {_T("SEPARATOR"),   VK_SEPARATOR},
    {_T("SUBTRACT"),    VK_SUBTRACT},
    {_T("DECIMAL"),     VK_DECIMAL},
    {_T("DIVIDE"),      VK_DIVIDE},
    {_T("F1"),          VK_F1},
    {_T("F2"),          VK_F2},
    {_T("F3"),          VK_F3},
    {_T("F4"),          VK_F4},
    {_T("F5"),          VK_F5},
    {_T("F6"),          VK_F6},
    {_T("F7"),          VK_F7},
    {_T("F8"),          VK_F8},
    {_T("F9"),          VK_F9},
    {_T("F10"),         VK_F10},
    {_T("F11"),         VK_F11},
    {_T("F12"),         VK_F12},
    {_T("F13"),         VK_F13},
    {_T("F14"),         VK_F14},
    {_T("F15"),         VK_F15},
    {_T("F16"),         VK_F16},
    {_T("KANJI"),       VK_KANJI},
    {_T(""),            0}
};

TCHAR *
CPadDoc::SendSpecial(TCHAR * pch, DWORD dwFlags)
{
    KEYENTRY *pKeyEntry = aKeyEntry;
    TCHAR * pch1, * pch2;
    TCHAR ch1, ch2;
    int cRepeat = 1;

    Assert (pch[-1] == _T('{'));

    pch1 = pch;
    while(*pch1 != _T(' ') && *pch1 != _T('}') && *pch1)
        pch1++;

    ch1 = *pch1;
    *pch1 = 0;

    pch2 = pch1 + 1;

    if(ch1 == _T(' '))
    {
        while(*pch2 != _T('}') && *pch2)
            pch2++;

        ch2 = *pch2;
        *pch2 = 0;

        cRepeat = _wtoi(pch1 + 1);

        *pch2 = ch2;

        pch2++;
    }

    while(pKeyEntry->nKey != 0)
    {
        if(StrCmpIC(pch, pKeyEntry->achName) == 0)
        {
            for(int i = 0; i < cRepeat; i++)
            {
                if (dwFlags & FLAG_MENU)
                    EnqueueKeyAction(
                            dwFlags,
                            WM_SYSKEYDOWN,
                            pKeyEntry->nKey,
                            (LPARAM) 0x20000001);
                else
                    EnqueueKeyAction(
                            dwFlags,
                            WM_KEYDOWN,
                            pKeyEntry->nKey,
                            (LPARAM)1);
            }
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(
                        dwFlags,
                        WM_SYSKEYUP,
                        pKeyEntry->nKey,
                        (LPARAM) 0xC0000001);
            else
                // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
                // generates spurious WM_CHAR.            
                EnqueueKeyAction(
                        dwFlags,
                        WM_KEYUP,
                        pKeyEntry->nKey,
                        (LPARAM)0xC0000001);
            break;
        }

        pKeyEntry++;
    }

    // ??????? Ask Gary what this could be
    if(pKeyEntry->nKey == 0 && *pch != 0 && pch1 == pch + 1)
    {
        for(int i = 0; i < cRepeat; i++)
            EnqueueKeyAction(dwFlags, WM_CHAR, *pch, 1);
    }

    *pch1 = ch1;

    return pch2;
}


// Send keys in such a way that the IME can see them.
TCHAR *
   CPadDoc::SendIMESpecial(TCHAR * pch, DWORD dwFlags)
{
    KEYENTRY *pKeyEntry = aKeyEntry;
    TCHAR * pch1, * pch2;
    TCHAR ch1, ch2;

    Assert (pch[-1] == _T('{'));

    // Eat leading spaces.
    pch1 = pch;
    while(*pch1 != _T(' ') && *pch1 != _T('}') && *pch1)
        pch1++;

    ch1 = *pch1;
    *pch1 = 0;

    pch2 = pch1 + 1;

    // Eat trailling spaces.
    if(ch1 == _T(' '))
    {
        while(*pch2 != _T('}') && *pch2)
            pch2++;

        ch2 = *pch2;
        *pch2 = 0;

        *pch2 = ch2;

        pch2++;
    }

    while(pKeyEntry->nKey != 0)
    {
        if(StrCmpIC(pch, pKeyEntry->achName) == 0)
        {
            keybd_event((BYTE)pKeyEntry->nKey, 0, 0, 0);
            keybd_event((BYTE)pKeyEntry->nKey, 0, KEYEVENTF_KEYUP, 0);
            break;
        }

        pKeyEntry++;
    }

    *pch1 = ch1;

    return pch2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padmain.cxx
//
//  Contents:   WinMain and associated functions.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include "shlobj.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

void CreatePerfCtl(DWORD dwFlags, void * pvHost);
void DeletePerfCtl();

MtDefine(SAryThreads_pv, Pad, "s_aryThreads::_pv")
MtDefine(PADTHREADSTATE, Pad, "PADTHREADSTATE")
DeclareTag(tagPadNoCycleBreak, "Pad", "Don't call UrlZonesDetach in wininet.dll")

//+-------------------------------------------------------------------------
//
// Definitions required for files linked from other directories.
//
//--------------------------------------------------------------------------

CRITICAL_SECTION    CGlobalLock::g_cs;                  // Critical section to protect globals
BOOL                CGlobalLock::g_fInit = FALSE;           // Init flag to protect Critical Section
#if DBG==1
DWORD               CGlobalLock::g_dwThreadID = 0;      // Thread ID which owns the critical section
LONG                CGlobalLock::g_cNesting = 0;        // Enter/LeaveCriticalSection nesting level (DEBUG only)
#endif

// used for assert to fool the compiler
DWORD g_dwFALSE = 0;

// default to loading MSHTML.DLL from the pad directory
BOOL g_fLoadSystemMSHTML = 0;

#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

HINSTANCE           g_hInstCore;
HINSTANCE           g_hInstResource;
EXTERN_C HANDLE     g_hProcessHeap;
HANDLE              g_hProcessHeap;
DWORD               g_dwTls;

#if defined(_X86_)
// P6 counter system
HANDLE  g_hPStat;
char *  g_apchCtrShort[2];
char *  g_apchCtrLong[2];
char    g_achCtrModes[2];
#endif

extern void DeinitDynamicLibraries();
extern void FreeLibraries();

DeclareTag(tagDumpHeapsOnExit, "Pad", "Dump heaps on exit");

//+-------------------------------------------------------------------------
//
// Global variables
//
//--------------------------------------------------------------------------

ATOM               g_atomMain;
HWND               g_hwndMain;
HWND               g_hwndActiveWindow; // Handle to window that hosts Trident in another app
static LONGLONG    s_liPerfFreq;       // perf frequency
static LONGLONG    s_liTimeStart;      // time at start of subtest
static int         s_iInterval;
static long        s_lSecondaryObjCount = 0;

ExternTag(tagScriptLog);

//+-------------------------------------------------------------------------
//
// Timing stuff
//
//--------------------------------------------------------------------------

#define MAXINTERVALS 200
#define MAXNAME      100


struct INTERVAL
{
    int iTime;
    TCHAR achName[MAXNAME];
    BOOL fReset;
}
    intervals[MAXINTERVALS];

class CPadEvent : public CEventCallBack
{
public:

    virtual int Event(LPCTSTR pchEvent, BOOL fReset = FALSE);
};

int CPadEvent::Event(LPCTSTR pchName, BOOL fReset)
{
    LONGLONG    liTimeStop;       // time at stop of subtest

    LOCK_GLOBALS;

    QueryPerformanceCounter((LARGE_INTEGER *)&liTimeStop);
    if (s_iInterval < MAXINTERVALS)
    {
        intervals[s_iInterval].iTime = (int)(((liTimeStop - s_liTimeStart) * 1000) / s_liPerfFreq);
        _tcsncpy(intervals[s_iInterval].achName, pchName, MAXNAME);
        intervals[s_iInterval].fReset = fReset;
        s_iInterval++;
    }
    QueryPerformanceCounter((LARGE_INTEGER *)&s_liTimeStart);

    return 0;
}


static CDataAry<THREAD_HANDLE> s_aryThreads(Mt(SAryThreads_pv));
                                // array of thread handles.
                                // This array is used only by the main
                                // thread.


CPadEvent g_PadEvent;
CPadEvent * g_pEvent = NULL;

void DumpTimes()
{
#if 0
    CHAR    rgch[MAX_PATH];
    UINT    cch = (UINT) GetModuleFileNameA(g_hInstCore, rgch, sizeof(rgch));

    if (s_iInterval)
    {
        Assert(rgch[cch-4] == '.');
        strcpy(&rgch[cch-4], ".tim");
        FILE * f = fopen(rgch, "w");
        int iAbsTime = 0;

        if (f == NULL)
            return;

        for (int i = 0; i < s_iInterval; i++)
        {
            iAbsTime += intervals[i].iTime;
            if (intervals[i].fReset)
            {
                iAbsTime = 0;
            }
            fprintf(f, "%S,\t%d\t%d\n", intervals[i].achName, iAbsTime, intervals[i].iTime);
        }

        fclose(f);
    }
#endif
}

void
IncrementObjectCount()
{
    GetThreadState()->lObjCount++;
    Verify(InterlockedIncrement(&s_lSecondaryObjCount) > 0);
}

void
DecrementObjectCount()
{
    if (--GetThreadState()->lObjCount == 0)
    {
        PostQuitMessage(0);
    }
    Verify(InterlockedDecrement(&s_lSecondaryObjCount) >= 0);
}

void
CheckObjCount()
{
    if (GetThreadState()->lObjCount)
    {
        TraceTag((tagError,
                "Thread (TID=0x%08x) terminated with primary object count=%d",
                GetCurrentThreadId(), GetThreadState()->lObjCount));
    }
}

PADTHREADSTATE *
GetThreadState()
{
    PADTHREADSTATE * pts = (PADTHREADSTATE *)TlsGetValue(g_dwTls);
    //AssertSz(pts != NULL, "PADTHREADSTATE not initialized on this thread");
    return(pts);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreatePadDocThreadProc
//
//  Synopsis:   Creates a new pad window.
//
//
//--------------------------------------------------------------------------

DWORD WINAPI CALLBACK
CreatePadDocThreadProc(void * pv)
{
    CThreadProcParam *ptpp = (CThreadProcParam *)pv;
    CPadDoc *   pDoc = NULL;
    EVENT_HANDLE      hEvent = ptpp->_hEvent;
    HRESULT     hr;
    VARIANT     varScriptParam;
    PADTHREADSTATE * pts = (PADTHREADSTATE *)MemAllocClear(Mt(PADTHREADSTATE), sizeof(PADTHREADSTATE));

    if (pts == NULL)
        goto MemoryError;

    TlsSetValue(g_dwTls, pts);

    // Name this thread for IceCAP
    NameThread("PadDoc");

    ::StartCAP();

    // Emit the PadDoc thread's thread ID so people who are debugging can always
    // know which thread they are looking at - the primary, OLE-non-apartment-model
    // thread, or the 2ndary paddoc thread:
    TraceTag((tagError, "PadDoc 2ndary Thread ID: 0x%x", GetCurrentThreadId() ));

    hr = THR(OleInitialize(NULL));
    if (!OK(hr))
        goto Cleanup;

    pDoc = new CPadDoc(ptpp->_fUseShdocvw);

    if (!pDoc)
        goto MemoryError;

    if (ptpp->_ppStm)
    {
        hr = THR(CoMarshalInterThreadInterfaceInStream(
                IID_IUnknown,
                (IPad *) pDoc,
                ptpp->_ppStm));
        if (hr)
            goto Cleanup;
    }

    hr = pDoc->Init(ptpp->_uShow, g_pEvent);
    if (hr)
        goto Cleanup;

    switch (ptpp->_action)
    {
    case ACTION_SCRIPT:
        {
            BOOL  fKeepRunning        = ptpp->_fKeepRunning;
            TCHAR achParam[MAX_PATH];

            VariantInit(&varScriptParam);

            Assert(_tcslen(ptpp->_pchParam) <= MAX_PATH);

            _tcscpy(achParam, ptpp->_pchParam);

            //
            // Unblock the calling thread before we start executing script code,
            // otherwise we may deadlock. Because of this we must copy all the
            // parameters we plan on using because they'll be destroyed as soon
            // as the calling thread gets CPU time.
            //
            SetEvent(hEvent);
            hEvent = NULL;

            CheckError(pDoc->_hwnd, pDoc->ExecuteScript(achParam, &varScriptParam, FALSE));
            VariantClear(&varScriptParam);

            if (!fKeepRunning)
            {
                pDoc->ShowWindow(SW_HIDE);
            }
        }
        break;

    case ACTION_NEW:
        CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument));
        break;

    case ACTION_OPEN:
        if (ptpp->_fUseShdocvw)
        {
            CheckError(pDoc->_hwnd, pDoc->OpenFile(ptpp->_pchParam, NULL));
        }
        else
        {
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));
        }
        break;
        
    case ACTION_OPEN_EDITMODE:
        CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));

        hr = THR(pDoc->ExecuteCommand(IDM_EDITMODE, NULL, NULL));
        break;

    case ACTION_OPEN_SCRIPTMODE:
    {
        BSTR            bstrScriptPath = NULL;
        CScriptRecorder *pScriptRecorder = NULL;
        
        // Open file
        if (ptpp->_pchParam && *ptpp->_pchParam == 0)
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument));                    // new file
        else
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));   // open file

        // Start script recorder
        bstrScriptPath = SysAllocString(ptpp->_pchParam);
        pScriptRecorder = new CScriptRecorder(pDoc);
        if (!bstrScriptPath || !pScriptRecorder)
        {
            SysFreeString(bstrScriptPath);            
            hr = E_OUTOFMEMORY;
            goto Cleanup;            
        }

        hr = THR(pScriptRecorder->Init(bstrScriptPath));
        
        if (SUCCEEDED(hr))
        {
            pDoc->SetScriptRecorder(pScriptRecorder);

            // Go to edit mode 
            hr = THR(pDoc->ExecuteCommand(IDM_EDITMODE, NULL, NULL));
        }
        
        SysFreeString(bstrScriptPath);
            
        if (hr)
            goto Cleanup;
        break;
    }

    case ACTION_HELP:
        pDoc->OnCommand(0, IDM_PAD_ABOUT, NULL);
        // Fall Through

    case ACTION_WELCOME:
        pDoc->Welcome();
        break;

    }

    // We are done with paramters, allow calling thread to continue.

    SetEvent(hEvent);
    hEvent = NULL;

    pDoc->Release();
    pDoc = NULL;

    CPadDoc::Run();

#if DBG==1
    CheckObjCount();
#endif

Cleanup:
    if (hEvent)
        SetEvent(hEvent);
    if (pDoc)
        pDoc->Release();

    UnregisterLocalCLSIDs();

    OleUninitialize();

    FreeLibraries();

    ::StopCAP();

    MemFree(pts);
    TlsSetValue(g_dwTls, NULL);

    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT
CreatePadDoc(CThreadProcParam * ptpp, IUnknown ** ppUnk)
{
    HRESULT         hr = S_OK;
    THREAD_HANDLE   hThread = NULL;
    EVENT_HANDLE    hEvent = NULL;
    LPSTREAM        pStm = NULL;
    DWORD           idThread, dwResult;

    hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);

    if (hEvent == NULL)
        RRETURN(GetLastWin32Error());

    if (ppUnk)
    {
        ptpp->_ppStm = &pStm;
    }

    ptpp->_hEvent = hEvent;
    hThread = CreateThread(NULL, 0, CreatePadDocThreadProc, ptpp, 0, &idThread);
    if (hThread == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    s_aryThreads.AppendIndirect(&hThread);

    ::SuspendCAP();

    dwResult = WaitForSingleObject(hEvent, INFINITE);
    Assert(dwResult == WAIT_OBJECT_0);

    ::ResumeCAP();

    if (pStm)
    {
        hr = THR(CoGetInterfaceAndReleaseStream(pStm, IID_IUnknown, (void **) ppUnk));
    }

Cleanup:
    ptpp->_hEvent = NULL;
    CloseEvent(hEvent);
    RRETURN(hr);
}

LRESULT
WndProcMain(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   switch (msg)
   {
   case WM_DESTROY:
       PostQuitMessage(0);
       break;

   default:
       return DefWindowProc(hwnd, msg, wParam, lParam);
   }

   return 0;
}

PADTHREADSTATE stateMain = { 0 };

static HRESULT
Initialize()
{
    HRESULT             hr = S_OK;
    WNDCLASS            wc;

    g_dwTls = TlsAlloc();
    if (g_dwTls == 0xFFFFFFFF)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    TlsSetValue(g_dwTls, &stateMain);

    EnableTag(tagScriptLog, TRUE);
    SetDiskFlag(tagScriptLog, TRUE);
    SetBreakFlag(tagScriptLog, FALSE);

    QueryPerformanceFrequency((LARGE_INTEGER *)&s_liPerfFreq);
    QueryPerformanceCounter((LARGE_INTEGER *)&s_liTimeStart);

    hr = CGlobalLock::Init();
    if (hr)
        goto Cleanup;

    g_hProcessHeap = GetProcessHeap();

    InitUnicodeWrappers();

    // Create "main" window.  This window is used to keep Windows
    // and OLE happy while we are waiting for something to happen
    // when launched to handle an embedding.

    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = WndProcMain;   // windows of this class.
    wc.hInstance = g_hInstCore;
    wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
    wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" Main");
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    g_atomMain = RegisterClass(&wc);

    if (!g_atomMain)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    g_hwndMain = CreateWindow(
            SZ_APPLICATION_NAME TEXT(" Main"),
            NULL, WS_OVERLAPPEDWINDOW,
            0, 0, 0, 0, NULL, NULL, g_hInstCore, NULL);
    if (!g_hwndMain)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(OleInitialize(NULL));
    if (hr)
        goto Cleanup;

#if 0
    // Force allocation of memory to hide leaks in OLEAUT32.
    DbgMemoryTrackDisable(TRUE);
    SysFreeString(SysAllocString(_T("Force Allocation Of Memory")));
    DbgMemoryTrackDisable(FALSE);
#endif

    CreatePerfCtl(0, NULL);

    g_hwndActiveWindow = 0;

Cleanup:
    RRETURN(hr);
}

static DYNLIB g_dynlibWininet = { NULL, NULL, "wininet.dll" };
static DYNPROC g_dynprocUrlZonesDetach = { NULL, &g_dynlibWininet, "UrlZonesDetach" };

static void
Terminate()
{
    extern void DeinitPalette();
    DeinitPalette();

#if defined(_X86_)
    int i;
    for (i=0; i<2; i++)
    {
        delete g_apchCtrShort[i];
        g_apchCtrShort[i] = NULL;
        delete g_apchCtrLong[i];
        g_apchCtrLong[i] = NULL;
    }
#endif

    if (g_hwndMain)
    {
        Assert(IsWindow(g_hwndMain));
        Verify(DestroyWindow(g_hwndMain));
    }

    if (g_atomMain)
    {
        Verify(UnregisterClass((TCHAR *)(DWORD_PTR)g_atomMain, g_hInstCore));
    }

    // Hack to break LoadLibrary cycle between WININET and URLMON

    if (    !IsTagEnabled(tagPadNoCycleBreak)
        &&  GetModuleHandleA("wininet.dll")
        &&  GetModuleHandleA("urlmon.dll")
        &&  LoadProcedure(&g_dynprocUrlZonesDetach) == S_OK)
    {
        ((void (STDAPICALLTYPE *)())g_dynprocUrlZonesDetach.pfn)();
    }

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x1");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x1");
    }
#endif

    CPadFactory::Revoke();

    DumpTimes();

    OleUninitialize();

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x2");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x2");
    }
#endif

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    DeinitControlPalette();
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    DeinitDynamicLibraries();

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x3");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x3");
    }
#endif

    CGlobalLock::Deinit();

    DeletePerfCtl();

    TlsFree(g_dwTls);
}


HRESULT
CheckError(HWND hwnd, HRESULT hr)
{
    TCHAR achBuf[MAX_PATH];

    if (OK(hr))
        return hr;

    if (!FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        hr,
        LANG_SYSTEM_DEFAULT,
        achBuf,
        ARRAY_SIZE(achBuf),
        NULL))
    {
        _tcscpy(achBuf, TEXT("Unknown error."));
    }

    MessageBox(hwnd,
            achBuf,
            NULL,
            MB_APPLMODAL | MB_ICONERROR | MB_OK);

    return hr;
}


void
Run ()
{
    for (;;)
    {
        DWORD   result ;
                int     cObjects = s_aryThreads.Size();
        THREAD_HANDLE * pHandle = s_aryThreads;

        // wait for any message sent or posted to this queue
        // or for one of the passed handles to become signaled

        ::SuspendCAP();

        result = MsgWaitForMultipleObjects(
                        cObjects,
                        pHandle,
                        FALSE,
                        INFINITE,
                        QS_ALLINPUT);

        ::ResumeCAP();

        // result tells us the type of event we have:
        // a message or a signaled handle

        // if there are one or more messages in the queue ...
        if (result == (WAIT_OBJECT_0 + cObjects))
        {
            MSG    msg;
            BOOL   fQuit;

            // read all of the messages in this next loop
            // removing each message as we read it

            for (;;)
            {
                ::SuspendCAP();

#ifndef UNIX
                Assert(!InSendMessage());
#endif
                fQuit = !PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

                ::ResumeCAP();

                if (fQuit)
                    break;

#ifdef UNIX
                if (msg.hwnd != GetDesktopWindow()) {
                    CPadDoc::RunOneMessage(&msg);
                    continue;
                }

                Assert(!InSendMessage());
#endif

                if (msg.message == WM_QUIT)
                    return;

                CPadDoc::RunOneMessage(&msg);
            }
        }
        else
        {
            int i = result - WAIT_OBJECT_0;

            CloseThread(s_aryThreads[i]);
            s_aryThreads.Delete(i);
            if (s_aryThreads.Size() == 0)
                return;
        }
    }
}
#ifdef UNIX
extern "C"
#endif
int WINAPI
PadMain(int argc, char ** argv, IMallocSpy * pSpy)
{
    HRESULT     hr = S_OK;
    char *      pchParam = NULL;
    TCHAR       achParam[MAX_PATH];
    int         nRet = 0;
    int         i;
    BOOL        fKeepRunning = FALSE;
    PAD_ACTION  action = ACTION_WELCOME;
    char *      pLogFileName = NULL;
    BOOL        fOpenLogFile = FALSE;
    BOOL        fDoTrace = FALSE;
    BOOL        fDialogs = TRUE;
    BOOL        fUseShdocvw = FALSE;

    // Name this thread for IceCAP
    NameThread("Main");

    ::StopCAPAll();

    hr = Initialize();
    if (hr)
        goto Cleanup;

    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiA(argv[i], "/embedding") == 0 ||
            lstrcmpiA(argv[i], "-embedding") == 0)
        {
            action = ACTION_SERVER;
            fOpenLogFile = TRUE;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/r") == 0 ||
                 lstrcmpiA(argv[i], "-r") == 0 ||
                 lstrcmpiA(argv[i], "/register") == 0 ||
                 lstrcmpiA(argv[i], "-register") == 0))
        {
            action = ACTION_REGISTER_PAD;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/local") == 0 ||
                 lstrcmpiA(argv[i], "-local") == 0))
        {
            action = ACTION_REGISTER_LOCAL_TRIDENT;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/system") == 0 ||
                 lstrcmpiA(argv[i], "-system") == 0))
        {
            action = ACTION_REGISTER_SYSTEM_TRIDENT;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/m") == 0 ||
                 lstrcmpiA(argv[i], "-m") == 0 ||
                 lstrcmpiA(argv[i], "/mail") == 0 ||
                 lstrcmpiA(argv[i], "-mail") == 0))
        {
            action = ACTION_REGISTER_MAIL;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/nomail") == 0 ||
                 lstrcmpiA(argv[i], "-nomail") == 0))
        {
            action = ACTION_UNREGISTER_MAIL;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/nuke") == 0 ||
                 lstrcmpiA(argv[i], "-nuke") == 0))
        {
            action = ACTION_NUKE_KNOWNDLLS;
        }
        else if (lstrcmpiA(argv[i], "-n") == 0 ||
                lstrcmpiA(argv[i], "/n") == 0)
        {
            action = ACTION_NEW;
        }
        else if (lstrcmpiA(argv[i], "-k") == 0 ||
                lstrcmpiA(argv[i], "/k") == 0)
        {
            fKeepRunning = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-s") == 0 ||
                lstrcmpiA(argv[i], "/s") == 0)
        {
            fDialogs = FALSE;
        }
        else if (lstrcmpiA(argv[i], "-t") == 0 ||
                lstrcmpiA(argv[i], "/t") == 0)
        {
            g_pEvent = &g_PadEvent;  // to log event times
        }
#ifdef UNIX_LATER
        else if (lstrcmpiA(argv[i], "-d") == 0 ||
                 lstrcmpiA(argv[i], "/d") == 0)
        {
            g_pEvent = new CDispatchEvent(); // to do dhtml via IDispatch
        }
#endif
        else if (lstrcmpiA(argv[i], "-l") == 0 ||
                lstrcmpiA(argv[i], "/l") == 0)
        {
            i++;
            fOpenLogFile = TRUE;
            if(i < argc)
            {
                pLogFileName = argv[i];
            }
        }
        else if (lstrcmpiA(argv[i], "-x") == 0 ||
                lstrcmpiA(argv[i], "/x") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i];
                action = ACTION_SCRIPT;
            }
        }
        else if (argc > 2 &&
                (lstrcmpiA(argv[i], "/trace") == 0 ||
                 lstrcmpiA(argv[i], "-trace") == 0))
        {
            fDoTrace = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-?") == 0 ||
                lstrcmpiA(argv[i], "/?") == 0)
        {
            action = ACTION_HELP;
        }
        else if (lstrcmpiA(argv[i], "-shdocvw") == 0 ||
                lstrcmpiA(argv[i], "/shdocvw") == 0)
        {
            fUseShdocvw = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-loadsystem") == 0 ||
                lstrcmpiA(argv[i], "/loadsystem") == 0)
        {
            g_fLoadSystemMSHTML = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-nopreload") == 0 ||
                lstrcmpiA(argv[i], "/nopreload") == 0)
        {
            NoLocalCLSIDs();
        }
        else if (lstrcmpiA(argv[i], "-1") == 0 ||
                lstrcmpiA(argv[i], "/1") == 0)
        {
            BOOL (WINAPI *pfn)(HANDLE, DWORD);
            pfn = (BOOL (WINAPI *)(HANDLE, DWORD))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "SetProcessAffinityMask");
            if (pfn)
            {
                pfn(GetCurrentProcess(), 1);
            }
        }
        else if (lstrcmpiA(argv[i], "-rt") == 0 ||
                lstrcmpiA(argv[i], "/rt") == 0)
        {
            BOOL (WINAPI *pfn)(HANDLE, DWORD);
            pfn = (BOOL (WINAPI *)(HANDLE, DWORD))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "SetPriorityClass");
            if (pfn)
            {
                pfn(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
            }
        }
        else if (lstrcmpiA(argv[i], "-p6cnt") == 0 ||
                lstrcmpiA(argv[i], "/p6cnt") == 0)
        {
#if defined(_X86_)
            InitP6Counters();
#endif
        }
        else if (lstrcmpiA(argv[i], "-e") == 0 ||
                lstrcmpiA(argv[i], "/e") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i];
                action = ACTION_OPEN_EDITMODE;
            }
        }
        else if (lstrcmpiA(argv[i], "-g") == 0 ||
                lstrcmpiA(argv[i], "/g") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i]; // open existing file
            }
            else
            {
                pchParam = "";        // create new file
            }
            action = ACTION_OPEN_SCRIPTMODE;
        } 
        else
        {
            pchParam = argv[i];
            action = ACTION_OPEN;
        }
    }

    if (fDoTrace)
    {
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExDoTracePointsDialog(FALSE);
        }
    }

    if((pLogFileName != NULL && *pLogFileName != 0) || fOpenLogFile)
    {
        DbgExOpenLogFile(pLogFileName);
    }


    if (pchParam)
    {
        MultiByteToWideChar(CP_ACP, 0, pchParam, -1, achParam, ARRAY_SIZE(achParam));
    }

    if (pSpy)
    {
        CoRegisterMallocSpy(pSpy);
    }

    // Emit the main thread's thread ID so people who are debugging can always
    // know which thread they are looking at - the primary, OLE-non-apartment-model
    // thread, or the 2ndary paddoc thread:
    TraceTag((tagError, "Main Thread ID: 0x%x", GetCurrentThreadId() ));

    switch (action)
    {
    case ACTION_SERVER:
        hr = THR(CPadFactory::Register());
        break;

    case ACTION_REGISTER_PAD:
        hr = THR(RegisterPad());
        goto Cleanup;

    case ACTION_REGISTER_LOCAL_TRIDENT:
        hr = THR(RegisterTrident(NULL, fDialogs, FALSE));
        goto Cleanup;

    case ACTION_REGISTER_SYSTEM_TRIDENT:
        hr = THR(RegisterTrident(NULL, fDialogs, TRUE));
        goto Cleanup;

    case ACTION_NUKE_KNOWNDLLS:
        hr = THR(NukeKnownDLLStuff());
        goto Cleanup;

    default:
        {
            CThreadProcParam tpp(fUseShdocvw, action, fKeepRunning, achParam);
            if (CheckError(NULL, CreatePadDoc(&tpp, NULL)) != S_OK)
                goto Cleanup;
        }
        break;
    }

    Run();

Cleanup:

    // Flush the message queue now

    {
        MSG msg;
        for (int n = 0; n < 1000; ++n)
            PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    }

    Terminate();
    return nRet;
}

#ifdef UNIX
extern "C"
#endif
BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore     = (HINSTANCE)hDll;
    g_hInstResource = (HINSTANCE)hDll;
#ifdef DLOAD1
    BaseDllHandle   = (HINSTANCE)hDll;    // for DelayLoadFailureHook
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls((HINSTANCE)hDll);

        //  Tags for the .dll should be registered before
        //  calling DbgExRestoreDefaultDebugState().  Do this by
        //  declaring each global tag object or by explicitly calling
        //  DbgExTagRegisterTrace.

        DbgExRestoreDefaultDebugState();

        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    AssertThreadDisable(FALSE);

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       padreg.cxx
//
//  Contents:   Register pad stuff
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#include "platform.h"

#define MSHTML_STR  _T("mshtml.dll")
#define MSHTMLED_STR _T("mshtmled.dll")
#define MSTIME_STR _T("mstime.dll")
#define DXTRANS_STR _T("dxtrans.dll")
#define DXTMSFT_STR _T("dxtmsft.dll")
#define PROCTEXE_STR _T("proctexe.ocx")

#define IEPEERS_STR _T("iepeers.dll")
#define MSHTMLTB_STR _T("mshtmltb.dll")

typedef HRESULT (STDAPICALLTYPE *CTLREGPROC)();
extern void DeinitDynamicLibraries();


//+------------------------------------------------------------------------
//
//  Format Strings
//
//  The following strings describe the data added to the registry.
//
//  The strings consist of major keys followed by subkey/value pairs.
//  Each set of subkey/value pairs is terminated with two nulls (that is,
//  the next subkey name is missing). The entire list is terminated
//  by three nulls (that is, the next major key is missing). Major
//  keys are allowed one value without an associated name (subkey); the
//  value of the first subkey, if the subkey name is missing, is treated
//  as the value for the major key. Since a missing subkey name usually
//  terminates the list of subkey/value pairs, the value for the major key
//  (the one without a subkey) *must* be first in the set of subkey/value
//  pairs. This works because all keys must have at least one value.
//
//  (While the values of named subkeys may be other than strings, only
//   strings are supported. To support more than strings, these structures
//   should be changed to precede the value with a single character type ID.)
//
//  To keep the strings clear, the major keys occur first, on a line
//  by themselves, followed by the pairs of subkey/value indented underneath.
//  The terminator for the subkey/value pair stands on a line by itself as well.
//
//  Each key and value string is used as a format string in the Format
//  function (see CORE\FORMAT.CXX for more info).  The arguments for
//  substitution into these strings are:
//
//      0 pstr      - Name of EXE
//      1 pclsid    - Class id
//      2 pstr      - Prog ID
//      3 pstr      - Friendly name
//      4 idr       - Icon
//
//-------------------------------------------------------------------------

#define DEFAULT_VALUE   TEXT("\0")

static TCHAR s_strCLSIDFmt[] =
    TEXT("<1g>\0")
        DEFAULT_VALUE               TEXT("<3s>\0")
        TEXT("\0")
        TEXT("LocalServer32\0")
                DEFAULT_VALUE               TEXT("<0s>\0")
        TEXT("\0")
    TEXT("ProgID\0")
        DEFAULT_VALUE               TEXT("<2s>\0")
        TEXT("\0")
    TEXT("DefaultIcon\0")
        DEFAULT_VALUE               TEXT("<0s>,-<4d>\0")
        TEXT("\0")
    TEXT("\0");

static TCHAR s_strProgIDFmt[] =
    TEXT("<2s>\0")
        DEFAULT_VALUE               TEXT("<3s>\0")
        TEXT("\0")
    TEXT("CLSID\0")
        DEFAULT_VALUE               TEXT("<1g>\0")
        TEXT("\0")
    TEXT("\0");

//+------------------------------------------------------------------------
//
//  Function:   GetPadDLLName
//
//  Synopsis:   Return a .DLL pathname for a .DLL in the same directory
//              as the pad .EXE
//
//-------------------------------------------------------------------------

void
GetPadDLLName(TCHAR * pszDLL, TCHAR * achBuf, int cchBuf)
{
    TCHAR * pName;

        achBuf[0] = 0;
    Verify(::GetModuleFileName(NULL, achBuf, cchBuf));
    pName = _tcsrchr(achBuf, FILENAME_SEPARATOR);
    if (pName)
    {
        *pName = '\0';              // Remove the name.
    }

    _tcscat(achBuf, pszDLL);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterClass
//
// Synopsis:    Register a single class.
//
//-------------------------------------------------------------------------

HRESULT
RegisterOneClass(HKEY hkeyCLSID, TCHAR *pchFile, REFCLSID clsid, TCHAR *pchProgID, TCHAR *pchFriendly)
{
    HRESULT hr;
    DWORD_PTR adwArgs[10];

    adwArgs[0] = (DWORD_PTR)pchFile;
    adwArgs[1] = (DWORD_PTR)&clsid;
    adwArgs[2] = (DWORD_PTR)pchProgID;
    adwArgs[3] = (DWORD_PTR)pchFriendly;
    adwArgs[4] = IDR_PADICON;

    hr = THR(RegDbSetValues(HKEY_CLASSES_ROOT, s_strProgIDFmt, adwArgs));
    if (hr)
        goto Cleanup;

    hr = THR(RegDbSetValues(hkeyCLSID, s_strCLSIDFmt, adwArgs));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterPad
//
// Synopsis:    Register objects for this server.
//
//-------------------------------------------------------------------------

HRESULT
RegisterPad()
{
    HRESULT hr;
    HKEY    hkeyCLSID = 0;
    TCHAR   achExe[MAX_PATH];
    HINSTANCE hInst = 0;

    GetModuleFileName(hInst, achExe, ARRAY_SIZE(achExe));

    hr = THR(RegDbOpenCLSIDKey(&hkeyCLSID));
    if (hr)
        RRETURN(hr);

    hr = THR(RegisterOneClass(
            hkeyCLSID,
            achExe,
            CLSID_Pad,
            _T("TridentPad"),
            _T("Trident Pad")));
    if (hr)
        goto Cleanup;

Cleanup:
    RegCloseKey(hkeyCLSID);
    RegFlushKey(HKEY_CLASSES_ROOT);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterTrident
//
// Purpose:     Registers Mshtml.dll as well as Mshtmled.dll
//-------------------------------------------------------------------------

HRESULT
RegisterTrident(HWND hwnd, BOOL fDialog, BOOL fSystem)
{
    TCHAR       achBuf[MAX_PATH];
    TCHAR       achMshtmled[MAX_PATH];
    TCHAR       achMstime[MAX_PATH];
    TCHAR       achIepeers[MAX_PATH];
    TCHAR       achDxtrans[MAX_PATH];
    TCHAR       achDxtmsft[MAX_PATH];
    TCHAR       achProctexe[MAX_PATH];
    TCHAR       achMshtmltb[MAX_PATH];

    HRESULT     hr;

    if (fSystem)
    {
        Verify(GetSystemDirectory(achBuf, ARRAY_SIZE(achBuf)));
        _tcscat(achBuf, 
                _T(FILENAME_SEPARATOR_STR)
                MSHTML_STR);
        Verify(GetSystemDirectory(achMshtmled, ARRAY_SIZE(achMshtmled)));
        _tcscat(achMshtmled,
                _T(FILENAME_SEPARATOR_STR)
                MSHTMLED_STR);

        Verify(GetSystemDirectory(achMstime, ARRAY_SIZE(achMstime)));
        _tcscat(achMstime,
            _T(FILENAME_SEPARATOR_STR)
            MSTIME_STR);

        Verify(GetSystemDirectory(achIepeers, ARRAY_SIZE(achIepeers)));
        _tcscat(achIepeers,
                _T(FILENAME_SEPARATOR_STR)
                IEPEERS_STR);
                                    
        Verify(GetSystemDirectory(achDxtrans, ARRAY_SIZE(achDxtrans)));
        _tcscat(achDxtrans,
            _T(FILENAME_SEPARATOR_STR)
            DXTRANS_STR);
        
        Verify(GetSystemDirectory(achDxtmsft, ARRAY_SIZE(achDxtmsft)));
        _tcscat(achDxtmsft,
            _T(FILENAME_SEPARATOR_STR)
            DXTMSFT_STR);

        Verify(GetSystemDirectory(achProctexe, ARRAY_SIZE(achProctexe)));
        _tcscat(achProctexe,
            _T(FILENAME_SEPARATOR_STR)
            PROCTEXE_STR);

        Verify(GetSystemDirectory(achMshtmltb, ARRAY_SIZE(achMshtmltb)));
        _tcscat(achMshtmltb,
                _T(FILENAME_SEPARATOR_STR)
                MSHTMLTB_STR);
    }
    else
    {
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTML_STR, achBuf, ARRAY_SIZE(achBuf));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLED_STR, achMshtmled, ARRAY_SIZE(achMshtmled));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSTIME_STR, achMstime, ARRAY_SIZE(achMstime));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      IEPEERS_STR, achIepeers, ARRAY_SIZE(achIepeers));

        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      DXTMSFT_STR, achDxtmsft, ARRAY_SIZE(achDxtmsft));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      DXTRANS_STR, achDxtrans, ARRAY_SIZE(achDxtrans));
        
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      PROCTEXE_STR, achProctexe, ARRAY_SIZE(achProctexe));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLTB_STR, achMshtmltb, ARRAY_SIZE(achMshtmltb));               
    }

    hr = RegisterDLL(achBuf);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMshtmled);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMstime);
    if (hr)
        goto Error;

    hr = RegisterDLL(achIepeers);
    if (hr)
        goto Error;

    hr = RegisterDLL(achDxtrans);
    if (hr)
        goto Error;

    hr = RegisterDLL(achDxtmsft);
    if (hr)
        goto Error;

    hr = RegisterDLL(achProctexe);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMshtmltb);
    if (hr && !fSystem)
        goto Error;
    else if (hr)
    {
        // If we can't register the system version, at 
        // least unregister the local version.
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLTB_STR, achMshtmltb, ARRAY_SIZE(achMshtmltb));
        hr = UnregisterDLL(achMshtmltb);
        if (hr)
            goto Error;
    }

    //Undo kill-bit IELabel control here.
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, 
            "Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility\\{99B42120-6EC7-11CF-A6C7-00AA00A47DD2}");
            
    
    if (fDialog)
    {
        if(fSystem)
        {
            MessageBox(
                hwnd,
                _T("System MSHTML and other system dlls registered as HTML viewer."),
                SZ_APPLICATION_NAME,
                MB_APPLMODAL | MB_OK);
        }
        else
        {
            MessageBox(
                hwnd,
                _T("Local trident MSHTML and other dlls registered as HTML viewer."),
                SZ_APPLICATION_NAME,
                MB_APPLMODAL | MB_OK);
        }
    }

Error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterLocalCLSIDs
//
//-------------------------------------------------------------------------

DYNLIB  g_dynlibMSHTML = { NULL, NULL, "mshtml.dll" };
DYNPROC g_dynprocMSHTMLClassObjects = { NULL, &g_dynlibMSHTML, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSHTMLED = { NULL, NULL, "mshtmled.dll" };
DYNPROC g_dynprocMSHTMLEDClassObjects = { NULL, &g_dynlibMSHTMLED, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSTIME = { NULL, NULL, "mstime.dll" };
DYNPROC g_dynprocMSTIMEClassObjects = { NULL, &g_dynlibMSTIME, "DllEnumClassObjects" };
DYNLIB  g_dynlibIEPEERS = { NULL, NULL, "iepeers.dll" };
DYNPROC g_dynprocIEPEERSClassObjects = { NULL, &g_dynlibIEPEERS, "DllEnumClassObjects" };
DYNLIB  g_dynlibDXTRANS = { NULL, NULL, "dxtrans.dll" };
DYNPROC g_dynprocDXTRANSClassObjects = { NULL, &g_dynlibDXTRANS, "DllEnumClassObjects" };
DYNLIB  g_dynlibDXTMSFT = { NULL, NULL, "dxtmsft.dll" };
DYNPROC g_dynprocDXTMSFTClassObjects = { NULL, &g_dynlibDXTMSFT, "DllEnumClassObjects" };
DYNLIB  g_dynlibPROCTEXE = { NULL, NULL, "proctexe.ocx" };
DYNPROC g_dynprocPROCTEXEClassObjects = { NULL, &g_dynlibPROCTEXE, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSHTMLTB = { NULL, NULL, "mshtmltb.dll" };
DYNPROC g_dynprocMSHTMLTBClassObjects = { NULL, &g_dynlibMSHTMLTB, "DllEnumClassObjects" };

DYNPROC * g_adynprocDlls[] = {
                                &g_dynprocMSHTMLClassObjects,
#ifndef UNIX
                                &g_dynprocMSHTMLEDClassObjects,
                                &g_dynprocMSTIMEClassObjects,
                                &g_dynprocDXTRANSClassObjects,
                                &g_dynprocDXTMSFTClassObjects,
                                &g_dynprocPROCTEXEClassObjects,
#endif
                                &g_dynprocIEPEERSClassObjects,
#ifndef UNIX
                                &g_dynprocMSHTMLTBClassObjects,
#endif                                
                                NULL
                             };

HRESULT
RegisterLocalCLSIDs()
{
    PADTHREADSTATE * pts = GetThreadState();
    int         i, j;
    HRESULT     hr = S_OK;
    CLSID       clsid;
    int         cFactory = 0;

    IUnknown ** pUnkFactory = pts->pUnkFactory;
    DWORD *     dwCookie    = pts->dwCookie;

    if (pts->fLocalReg)
        return S_OK;

    // We register class objects per thread, so hold on to
    // one instance of library per thread.

    for (i=0; g_adynprocDlls[i]; i++)
    {
        //
        // We do an explicit load to increment the system's refcount on the DLL.
        //
        pts->hinstDllThread[i] = LoadLibraryA(g_adynprocDlls[i]->pdynlib->achName);

        hr = THR(LoadProcedure(g_adynprocDlls[i]));
        if (hr)
        {
#if DBG == 1
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                TraceTag((tagError, "\n\n**** WARNING! Could not locally register class "
                          "factories for %hs!", g_adynprocDlls[i]->pdynlib->achName));
                TraceTagEx((tagError, TAG_NONAME, "OLE objects may be pulled from the system DLL "
                          "instead of the local DLL.\n"));
            }
#endif

            // Couldn't load this DLL. Go on to the next one.
            hr = S_OK;
            continue;
        }

        for (j = 0; cFactory < PUNKFACTORY_ARRAY_SIZE; j++, cFactory++)
        {
            hr = THR(((HRESULT (STDAPICALLTYPE *)(int, CLSID *, IUnknown **))
                        g_adynprocDlls[i]->pfn)(j,
                        &clsid,
                        &pUnkFactory[cFactory]));
            if (hr)
                break;

            hr = THR(CoRegisterClassObject( clsid,
                                            pUnkFactory[cFactory],
                                            CLSCTX_INPROC_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            &dwCookie[cFactory]));
            if (hr)
                break;
        }

        if (!OK(hr))
            RRETURN(hr);
    }

    AssertSz(cFactory < PUNKFACTORY_ARRAY_SIZE, "Ran out of room to register factories!");

    if (OK(hr))
        hr = S_OK;

    pts->fLocalReg = hr == S_OK;

    RRETURN(hr);
}

void
UnregisterLocalCLSIDs()
{
    PADTHREADSTATE * pts = GetThreadState();
    IUnknown ** pUnkFactory = pts->pUnkFactory;
    DWORD * dwCookie = pts->dwCookie;
    int i;

    for (i = 0; i < PUNKFACTORY_ARRAY_SIZE; i++)
    {
        if (dwCookie[i])
        {
            Verify(OK(CoRevokeClassObject(dwCookie[i])));
            dwCookie[i] = 0;
        }

        ClearInterface(&pUnkFactory[i]);
    }

    pts->fLocalReg = FALSE;
}

void NoLocalCLSIDs()
{
    // this clears the local DLL list
    ZeroMemory(g_adynprocDlls, sizeof(g_adynprocDlls));
}

void
FreeLibraries()
{
    PADTHREADSTATE * pts = GetThreadState();

    for (int i = 0; i < NUM_LOCAL_DLLS; i++)
    {
        if (pts->hinstDllThread[i] != NULL)
        {
            FreeLibrary(pts->hinstDllThread[i]);
        }
    }

    DeinitDynamicLibraries();
}


//+------------------------------------------------------------------------
//
// Function:    RegisterDLL
//
//-------------------------------------------------------------------------

HRESULT
RegisterDLL(LPOLESTR Path)
{
    HMODULE     hModule = NULL;
    CTLREGPROC  DLLRegisterServer;
    HRESULT     hr = E_FAIL;

    hModule = ::LoadLibraryEx(Path, 0, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hModule)
    {
        goto WinError;
    }

    // Control found try to register.
    DLLRegisterServer = (CTLREGPROC)::GetProcAddress(hModule,
                                                       "DllRegisterServer");

    if (DLLRegisterServer == NULL)
    {
        goto WinError;
    }

    hr = THR(DLLRegisterServer());  // Register control

Cleanup:
    if (hModule)
    {
        ::FreeLibrary(hModule);
    }
#if DBG == 1
    OutputDebugString(_T("\n\rDLL "));
    OutputDebugString((hr == S_OK) ?
                        _T("registered: ") :
                        _T("NOT registered: "));
    OutputDebugString(Path);
    OutputDebugString(_T("\n\r"));
#endif
    RRETURN(hr);

WinError:
    hr = HRESULT_FROM_WIN32(::GetLastError());
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
// Function:    UnregisterDLL
//
//-------------------------------------------------------------------------

HRESULT
UnregisterDLL(LPOLESTR Path)
{
    HMODULE     hModule = NULL;
    CTLREGPROC  DLLUnregisterServer;
    HRESULT     hr = E_FAIL;

    hModule = ::LoadLibraryEx(Path, 0, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hModule)
    {
        goto WinError;
    }

    // Control found try to register.
    DLLUnregisterServer = (CTLREGPROC)::GetProcAddress(hModule,
                                                       "DllUnregisterServer");

    if (DLLUnregisterServer == NULL)
    {
        goto WinError;
    }

    hr = THR(DLLUnregisterServer());  // Register control

Cleanup:
    if (hModule)
    {
        ::FreeLibrary(hModule);
    }
#if DBG == 1
    OutputDebugString(_T("\n\rDLL "));
    OutputDebugString((hr == S_OK) ?
                        _T("unregistered: ") :
                        _T("NOT unregistered: "));
    OutputDebugString(Path);
    OutputDebugString(_T("\n\r"));
#endif
    RRETURN(hr);

WinError:
    hr = HRESULT_FROM_WIN32(::GetLastError());
    goto Cleanup;
}
//+---------------------------------------------------------------------------
//
//  Function:   NukeKnownDLLStuff
//
//  Synopsis:   Removes standard dlls from the knowndll list.
//
//----------------------------------------------------------------------------

HRESULT
NukeKnownDLLStuff()
{
    HRESULT             hr      = S_OK;
    long                error;
    HKEY                hkey    = NULL;
    long                i;
    BOOL                fChanged = FALSE;
    static char *       g_achDLLs[] =
        { "shdocvw", "urlmon", "wininet" };

    // Check if oleaut32 is in known dlls list.
    error = TW32_NOTRACE(1, RegOpenKeyA(
            HKEY_LOCAL_MACHINE,
            "System\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs",
            &hkey));
    if (error)
    {
        // On Win95, the key is spelled differently.
        error = TW32(1, RegOpenKeyA(
                HKEY_LOCAL_MACHINE,
                "System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs",
                &hkey));

        if (error)
            goto Cleanup;
    }

    for (i = ARRAY_SIZE(g_achDLLs); i > 0; i--)
    {
        error = TW32_NOTRACE(1, RegQueryValueExA(
                hkey,
                g_achDLLs[i-1],
                NULL,
                NULL,
                NULL,
                NULL));
        if (error)
            continue;

        // Delete the value.
        error = TW32(1, RegDeleteValueA(hkey, g_achDLLs[i-1]));
        if (error)
            goto Win32Error;

        fChanged = TRUE;
    }

Cleanup:
    if (hkey)
        Verify(!RegCloseKey(hkey));

    if (!hr)
    {
        MessageBox(
            NULL,
            fChanged ?
                _T("Known DLLs nuked OK. Need Reboot.") :
                _T("Known DLLs nuked OK."),
            SZ_APPLICATION_NAME,
            MB_APPLMODAL | MB_OK);
    }
    else
    {
        MessageBox(
            NULL,
            _T("Failed nuking Known DLLs."),
            SZ_APPLICATION_NAME,
            MB_APPLMODAL | MB_OK);
    }

    RRETURN(hr);

Win32Error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padsite.cxx
//
//  Contents:   CPadSite class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

DeclareTag(tagUserAgent, "Pad", "Test user agent string");
DeclareTag(tagNoClientPull, "Pad", "No client-pull");
DeclareTag(tagIAsyncServiceProvider, "Pad", "Test IAsyncServiceProvider");
DeclareTag(tagNoContextMenus, "Pad", "Turn off context menus in MSHtmPad");

DeclareTag(tagIHTMLDragEditHostResizeFeedback, "Pad", "Test Resize of Drag Feedback ");
DeclareTag(tagIHTMLDragEditHostDrawFeedback, "Pad", "Test Drawing of Drag Feedback");
DeclareTag(tagIHTMLDragEditHostSnapPoint, "Pad", "Test Point Snap at End ");
DeclareTag(tagIHTMLDragEditHostChangeElement, "Pad", "Test Changing IHTMLElement at Begin Drag");
DeclareTag(tagIHTMLDragEditHostCancelDrag, "Pad", "Test Cancelling drag at Begin Drag");
DeclareTag(tagIHTMLDragEditHostPasteInFlow, "Pad", "Test Paste In Flow Code at End Drag");
DeclareTag(tagPeerProvideTestBehaviors, "Peer", "Provide test host behaviors");
DeclareTag(tagShowSnap, "Pad", "Show snap to grid output");
DeclareTag(tagImplementNSFactory2, "Peer", "Have pad implement NS factory 2")
DeclareTag(tagIHostBehaviorInit, "Peer", "Implement IHostBehaviorInit");

ExternTag(tagSnapGrid);

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadSite, CPadDoc, PadDoc, _Site);

// {94D12430-B6A8-11d0-8778-00A0C90564EC}
static const GUID IID_IAsyncServiceProvider =
{ 0x94d12430, 0xb6a8, 0x11d0, { 0x87, 0x78, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xec } };

const IID IID_IHTMLDragEditHost = {0x3050f5e1,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};

extern "C" const GUID SID_SEditCommandTarget;
extern "C" const GUID CGID_EditStateCommands;

STDMETHODIMP
CPadSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *) this;
    }
    else if (iid == IID_IOleDocumentSite)
    {
        *ppv = (IOleDocumentSite *) this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IAdviseSink)
    {
        *ppv = (IAdviseSink *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
#if DBG==1
    else if (IsTagEnabled(tagIAsyncServiceProvider) && (iid == IID_IAsyncServiceProvider))
    {
        *ppv = (IServiceProvider *) this;
    }
#endif
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *) this;
    }
    else if (IsTagEnabled(tagIHostBehaviorInit) && (iid == IID_IHostBehaviorInit))
    {
        *ppv = (IHostBehaviorInit *) this;
    }
    else if (iid == IID_IElementBehaviorFactory)
    {
        *ppv = (IElementBehaviorFactory *) this;
    }
    else if (iid == IID_IElementNamespaceFactory)
    {
        *ppv = (IElementNamespaceFactory *) this;
    }
    else if (iid == IID_IElementNamespaceFactory2 && 
             IsTagEnabled(tagImplementNSFactory2))
    {
        *ppv = (IElementNamespaceFactory2 *) this;
    }
    else if (iid == IID_IElementNamespaceFactoryCallback)
    {
        *ppv = (IElementNamespaceFactoryCallback *) this;
    }
    else if (iid == IID_IVersionHost)
    {
        *ppv = (IVersionHost *) this;
    }
#if DBG==1
    else if (IsTagEnabled(tagSnapGrid) && (iid == IID_IHTMLEditHost))
    {
        *ppv = (IHTMLEditHost*) this;
    }
#endif
    else if( iid == IID_ISequenceNumber )
    {
        *ppv = (ISequenceNumber *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP
CPadSite::SaveObject()
{
    RRETURN(PadDoc()->Save((LPCTSTR)NULL));
}


STDMETHODIMP
CPadSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    if ((OLEGETMONIKER_UNASSIGN != dwAssign) &&
        (OLEWHICHMK_OBJFULL == dwWhichMoniker))
    {
        RRETURN (PadDoc()->GetMoniker(ppmk));
    }
    else
    {
        *ppmk = NULL;
        RRETURN(E_NOTIMPL);
    }
}


STDMETHODIMP
CPadSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    *ppContainer = PadDoc();
    (*ppContainer)->AddRef();
    return S_OK;
}


STDMETHODIMP
CPadSite::ShowObject( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::OnShowWindow(BOOL fShow)
{
    return S_OK;
}


STDMETHODIMP
CPadSite::RequestNewObjectLayout( )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::GetWindow(HWND * phwnd)
{
    *phwnd = PadDoc()->_hwnd;
    return S_OK;
}


STDMETHODIMP
CPadSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::CanInPlaceActivate( )
{
    return S_OK;
}

extern LRESULT
ObjectWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);

STDMETHODIMP
CPadSite::OnInPlaceActivate( )
{
    HRESULT     hr;
    IUnknown *  pUnk;

    if (PadDoc()->_pView)
    {
        // Use view if activating an ActiveX Document.
        pUnk = PadDoc()->_pView;
    }
    else
    {
        // Use object if activating an ActiveX Control.
        pUnk =  PadDoc()->_pObject;
    }

    hr = THR(pUnk->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &PadDoc()->_pInPlaceObject));

    if (!hr)
    {
        HWND hwnd;

        if (!PadDoc()->_pInPlaceObject->GetWindow(&hwnd))
        {
            PadDoc()->_hwndHooked = hwnd;
            PadDoc()->_pfnOrigWndProc = (WNDPROC) SetWindowLongPtr(
                hwnd, GWLP_WNDPROC, (LONG_PTR) ObjectWndProc);
            SetProp(hwnd, _T("TRIDENT_DOC"), (HANDLE)PadDoc());
        }
    }

    RRETURN(hr);
}


STDMETHODIMP
CPadSite::OnUIActivate( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    *ppFrame = &PadDoc()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

    PadDoc()->GetViewRect(prcPosRect, TRUE);
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = PadDoc()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


STDMETHODIMP
CPadSite::Scroll(OLESIZE scrollExtent)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::OnUIDeactivate(BOOL fUndoable)
{
    HWND hwnd;
    HRESULT hr;

    // release hook for server window
    hr = PadDoc()->_pInPlaceObject->GetWindow(&hwnd);
    if (hr)
        goto Cleanup;

    if (hwnd == PadDoc()->_hwndHooked)
    {
        RemoveProp(hwnd, _T("TRIDENT_DOC"));
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) PadDoc()->_pfnOrigWndProc);
        PadDoc()->_hwndHooked = NULL;
    }

    // Set focus back to the frame.
    SetFocus(PadDoc()->_hwnd);

    // Show our menu again.
    IGNORE_HR(PadDoc()->_Frame.SetMenu(NULL, NULL, NULL));

Cleanup:

    RRETURN(hr);
}

STDMETHODIMP
CPadSite::OnInPlaceDeactivate( )
{
    ClearInterface(&PadDoc()->_pInPlaceObject);
    ClearInterface(&PadDoc()->_pView);
    PadDoc()->InplaceDeactivate();
    return S_OK;
}


STDMETHODIMP
CPadSite::DiscardUndoState( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::DeactivateAndUndo( )
{
    RRETURN(THR(PadDoc()->_pInPlaceObject->UIDeactivate()));
}


STDMETHODIMP
CPadSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    Assert(FALSE);
    return S_OK;
}

STDMETHODIMP
CPadSite::ActivateMe(IOleDocumentView *pView)
{
    HRESULT         hr;
    IOleDocument *  pDocument = NULL;
    RECT            rc;

    if (PadDoc()->_pView &&
        PadDoc()->_pView != pView)
        RRETURN(E_UNEXPECTED);

    //
    // *********** ISSUE: TODO: UGLY TERRIBLE HACK FOR MSHTML ! (istvanc) **************
    //
    if (PadDoc()->_fMSHTML)
    {
        hr = THR(PadDoc()->_pObject->QueryInterface(IID_IOleDocument,
                (void **)&pDocument));
        if (hr)
            goto Cleanup;

        hr = THR(pDocument->CreateView(this, NULL, 0, &pView));
        if (hr)
            goto Cleanup;

        hr = THR(pView->SetInPlaceSite(this));
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (!pView)
        {
            hr = THR(PadDoc()->_pObject->QueryInterface(IID_IOleDocument,
                    (void **)&pDocument));
            if (hr)
                goto Cleanup;

            hr = THR(pDocument->CreateView(this, NULL, 0, &pView));
            if (hr)
                goto Cleanup;
        }
        else if(!PadDoc()->_pView)
        {
            hr = THR(pView->SetInPlaceSite(this));
            if (hr)
                goto Cleanup;

            pView->AddRef();
        }
    }

    PadDoc()->_pView = pView;

    // This sets up toolbars and menus first

    hr = THR(pView->UIActivate(TRUE));
    if (hr)
        goto Cleanup;

    // Set the window size sensitive to new toolbars

    PadDoc()->GetViewRect(&rc, TRUE);
    hr = THR(pView->SetRect(&rc));
    if (hr)
        goto Cleanup;

    // Makes it all visible
    hr = THR(pView->Show(TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDocument);
    RRETURN(hr);
}

STDMETHODIMP
CPadSite::GetTypeInfoCount( UINT * pctinfo )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::GetIDsOfNames(
        REFIID      riid,
        LPTSTR *    rgstrNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::Invoke(
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_AMBIENT_USERMODE:
        V_VT(pvarResult) = VT_BOOL;
        V_BOOL(pvarResult) = !!PadDoc()->_fUserMode;
        break;

    case DISPID_AMBIENT_SILENT:
        V_VT(pvarResult) = VT_BOOL;
        V_BOOL(pvarResult) = !!IsTagEnabled(tagAssertExit);
        break;

    case DISPID_AMBIENT_PALETTE:
        V_VT(pvarResult) = VT_HANDLE;
        V_BYREF(pvarResult) = PadDoc()->_hpal;
        break;

    case DISPID_AMBIENT_USERAGENT:
        if (IsTagEnabled(tagUserAgent))
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(_T("Mozilla/4.0 (compatible; MSIE 4.0b1; user agent string test)"),
                                      &V_BSTR(pvarResult)));
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
        break;

    case DISPID_AMBIENT_DLCONTROL:
        if (IsTagEnabled(tagNoClientPull))
        {
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = DLCTL_NO_CLIENTPULL;
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
        break;

    default:
        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    return hr;
}

STDMETHODIMP
CPadSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    if (sid == SID_SControlPalette)
    {
        hr = THR(GetControlPaletteService(iid, ppv));
    }
    else
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED
        if (sid == IID_IElementBehaviorFactory && IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHostBehaviorInit && IsTagEnabled(tagIHostBehaviorInit))
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == SID_SVersionHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLDragEditHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLEditHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == SID_SEditCommandTarget)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if( sid == IID_ISequenceNumber )
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

// ICommandTarget methods

STDMETHODIMP
CPadSite::QueryStatus(
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    if (pguidCmdGroup != NULL)
        return (OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // By default command text is NOT SUPPORTED.
    if (pcmdtext && (pcmdtext->cmdtextf != MSOCMDTEXTF_NONE))
        pcmdtext->cwActual = 0;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch (pCmd->cmdID)
        {
        case OLECMDID_UPDATECOMMANDS:
        case OLECMDID_SETTITLE:
        case OLECMDID_NEW:
        case OLECMDID_OPEN:
        case OLECMDID_SAVE:
        case OLECMDID_SETPROGRESSTEXT:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
        }
    }

    return (hr);
}

STDMETHODIMP
CPadSite::Exec(const GUID * pguidCmdGroup,
              DWORD nCmdID,
              DWORD nCmdexecopt,
              VARIANTARG * pvarargIn,
              VARIANTARG * pvarargOut)
{
    HRESULT hr = S_OK;

    if ( ! pguidCmdGroup )
    {
        switch (nCmdID)
        {
        case OLECMDID_NEW:
            if (!(THR_NOTRACE(PadDoc()->QuerySave(SAVEOPTS_PROMPTSAVE))))
                THR_NOTRACE(PadDoc()->Open(CLSID_HTMLDocument));
            break;

        case OLECMDID_OPEN:
            THR_NOTRACE(PadDoc()->PromptOpenFile(
                    PadDoc()->_hwnd,
                    &CLSID_HTMLDocument));
            break;

        case OLECMDID_SAVE:
            THR_NOTRACE(PadDoc()->DoSave(FALSE));
            break;

        case OLECMDID_SETPROGRESSTEXT:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                PadDoc()->SetStatusText(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        case OLECMDID_UPDATECOMMANDS:
            if( PadDoc()->_fUpdateUI )
                PadDoc()->UpdateToolbarUI();
            break;

        case OLECMDID_SETTITLE:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {            
                PadDoc()->OnSetTitle(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;

        if (*pguidCmdGroup == CGID_MSHTML)
        {
            // Only register non-query based commands
            if (pvarargOut == NULL)
                IGNORE_HR(PadDoc()->GetScriptRecorder()->RegisterCommand(nCmdID, nCmdexecopt, pvarargIn) );

        }
        else if (*pguidCmdGroup == CGID_EditStateCommands)
        {
            // Make sure script recorder is enabled before returning S_OK here
            if (nCmdID == IDM_CONTEXT)
                hr = S_OK; // must return S_OK to enable routing to the pad
        }
    }
    return (hr);
}

// snap to grid implementation from the host - IPad
STDMETHODIMP
CPadSite::SnapRect(IHTMLElement* pIElement, RECT* prcNew, ELEMENT_CORNER eHandle)
{
#if DBG==1
    if (IsTagEnabled(tagSnapGrid))
    { 
        RECT rect = *prcNew;

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_LEFT       || 
            eHandle == ELEMENT_CORNER_TOPLEFT    ||
            eHandle == ELEMENT_CORNER_BOTTOMLEFT ||
            eHandle == ELEMENT_CORNER_NONE )
        {           
            if ((rect.left % 10) != 0)
                rect.left += 10 - (rect.left % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_RIGHT       || 
            eHandle == ELEMENT_CORNER_TOPRIGHT    ||
            eHandle == ELEMENT_CORNER_BOTTOMRIGHT )
        {
            if ((rect.right % 10) != 0)
                rect.right += 10 - (rect.right % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_TOP      || 
            eHandle == ELEMENT_CORNER_TOPLEFT  ||
            eHandle == ELEMENT_CORNER_TOPRIGHT ||
            eHandle == ELEMENT_CORNER_NONE )
        {
            if ((rect.top % 10) != 0)
                rect.top += 10 - (rect.top % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_BOTTOM      || 
            eHandle == ELEMENT_CORNER_BOTTOMLEFT  ||
            eHandle == ELEMENT_CORNER_BOTTOMRIGHT )
        {
            if ((rect.bottom % 10) != 0)
                rect.bottom  += 10 - (rect.bottom % 10);
        }

        TraceTag((tagShowSnap,"Rect snapped to: left:%d top:%d right:%d bottom:%d", 
                              rect.left, rect.top, rect.right, rect.bottom));

        *prcNew = rect;
    }    

    
#endif
    RRETURN(S_OK);
}


STDMETHODIMP
CPadSite::OnControlInfoChanged(void)
{
    return S_OK;
}

STDMETHODIMP
CPadSite::LockInPlaceActive(BOOL fLock)
{
    return S_OK;
}

STDMETHODIMP
CPadSite::GetExtendedControl(IDispatch ** ppDisp)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::TransformCoords(
        POINTL * pPtlHiMetric,
        POINTF * pPtfContainer,
        DWORD dwFlags)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::TranslateAccelerator(MSG * lpmsg, DWORD grfModifiers)
{
    RRETURN1(S_FALSE, S_FALSE);
}

STDMETHODIMP
CPadSite::OnFocus(BOOL fGotFocus)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::ShowPropertyFrame(void)
{
    RRETURN(E_NOTIMPL);
}

void STDMETHODCALLTYPE
CPadSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    if ((dwAspect & DVASPECT_CONTENT))
        PadDoc()->DirtyColors();

    PadDoc()->_lViewChangesFired++;
}

void STDMETHODCALLTYPE
CPadSite::OnDataChange(FORMATETC *petc, STGMEDIUM *pstgmed)
{
    PadDoc()->_lDataChangesFired++;
}

void STDMETHODCALLTYPE
CPadSite::OnRename(IMoniker *pmk)
{
}

void STDMETHODCALLTYPE
CPadSite::OnSave()
{
}

void STDMETHODCALLTYPE
CPadSite::OnClose()
{
}

DeclareTag(tagDefaultDIV, "Edit", "Default block element is DIV");

//+---------------------------------------------------------------
//
//      Skeletal Implemenation of IDocHostUIHandler
//
//+---------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetHostInfo
//
//  Synopsis:   Fetch information and flags from the host.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    HRESULT     hr = S_OK;

    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
        return E_INVALIDARG;

    pInfo->dwFlags = DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
    
    if (IsTagEnabled(tagDefaultDIV))
        pInfo->dwFlags |= DOCHOSTUIFLAG_DIV_BLOCKDEFAULT;

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    //
    // behaviors testing
    //

    if (IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        static const TCHAR achNS [] = _T("HOST1;HOST2");
        static const TCHAR achCss[] = _T("HOST1\\:* { behavior:url(#default#DRT1) } ")
                                      _T("HOST2\\:* { behavior:url(#default#DRT2) } ");

        pInfo->pchHostNS  = (LPTSTR) CoTaskMemAlloc (sizeof(achNS));
        pInfo->pchHostCss = (LPTSTR) CoTaskMemAlloc (sizeof(achCss));
        if (!pInfo->pchHostNS || !pInfo->pchHostCss)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _tcscpy (pInfo->pchHostNS,  achNS);
        _tcscpy (pInfo->pchHostCss, achCss);
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ShowUI
//
//  Synopsis:   This method allows the host replace object's menu
//              and toolbars. It returns S_OK if host display
//              menu and toolbar, otherwise, returns S_FALSE.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ShowUI(
        DWORD dwID,
        IOleInPlaceActiveObject * pActiveObject,
        IOleCommandTarget * pCommandTarget,
        IOleInPlaceFrame * pFrame,
        IOleInPlaceUIWindow * pDoc)
{
    return S_OK ;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::HideUI
//
//  Synopsis:   Remove menus and toolbars cretaed during the call
//              to ShowUI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::HideUI(void)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::UpdateUI
//
//  Synopsis:   Update the state of toolbar buttons.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::UpdateUI(void)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::EnableModeless
//
//  Synopsis:   Enable or disable modless UI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::OnDocWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::OnDocWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::OnFrameWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::OnFrameWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ResizeBorder
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ResizeBorder(
        LPCRECT prc,
        IOleInPlaceUIWindow * pUIWindow,
        BOOL fFrameWindow)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ShowContextMenu
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display any UI.
//              DOCHOST_E_UNKNOWN -- The menu ID is unknown..
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ShowContextMenu(
            DWORD dwID,
            POINT * pptPosition,
            IUnknown * pcmdtReserved,
            IDispatch * pDispatchObjectHit)
{
    // lie about displaying UI to disable context menus
    if(IsTagEnabled(tagNoContextMenus))
        return S_OK;
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::TranslateAccelerator
//
//  Returns:    S_OK -- The mesage was translated successfully.
//              S_FALSE -- The message was not translated.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::TranslateAccelerator(
            LPMSG lpmsg,
            const GUID * pguidCmdGroup,
            DWORD nCmdID)
{
    HRESULT hr = S_FALSE;

    if (PadDoc()->_hAccelerators)
    {
        INT rc;

        rc = ::TranslateAccelerator(PadDoc()->_hwnd, PadDoc()->_hAccelerators, lpmsg);
        hr = rc ? S_OK : S_FALSE;
    }

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetOptionKeyPath
//
//  Synopsis:   Get the registry key where host stores its default
//              options.
//
//  Returns:    S_OK          -- Success.
//              E_OUTOFMEMORY -- Fail.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetDropTarget
//
//  Returns:    S_OK -- Host will return its droptarget to overwrite given one.
//              S_FALSE -- Host does not want to overwrite droptarget
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetDropTarget(
        IDropTarget * pDropTarget,
        IDropTarget ** ppDropTarget)
{
    return S_FALSE;
}
//+------------------------------------------------------------------------
//
//  Member:     CPadSite::PopulateNamespaceTable()
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPadSite::PopulateNamespaceTable(void)
{
    IDispatch * pdispDoc = NULL;
    
    HRESULT                     hr;
    IServiceProvider *          pServiceProvider = NULL;
    IElementNamespaceTable *    pTable = NULL;
    VARIANT                     varFactory;
    BSTR                        bstrNamespace1 = SysAllocString(_T("HBINS1"));
    BSTR                        bstrNamespace2 = SysAllocString(_T("HBINS2"));
    BSTR                        bstrNamespace3 = SysAllocString(_T("HBINS3"));

    if (bstrNamespace1 == NULL ||
        bstrNamespace2 == NULL ||
        bstrNamespace3 == NULL)
        goto Cleanup;

    HWND Wnd;

    VariantInit(&varFactory);

    hr = PadDoc()->get_Document_Early(&pdispDoc);
    if (hr || pdispDoc == NULL)
        goto Cleanup;

    // get the table

    hr = THR(pdispDoc->QueryInterface(IID_IServiceProvider, (void**) &pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(IID_IElementNamespaceTable, IID_IElementNamespaceTable, (void**) &pTable));
    if (hr)
        goto Cleanup;

    // prepare factory

    V_VT(&varFactory) = VT_UNKNOWN;
    hr = THR(QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varFactory)));
    if (hr)
        goto Cleanup;

    // add namespaces

    hr = THR(pTable->AddNamespace(bstrNamespace1, NULL, 0, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace2, NULL, ELEMENTNAMESPACEFLAGS_ALLOWANYTAG, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace3, NULL, ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS, &varFactory));
    if( hr )
        goto Cleanup;

Cleanup:

    ReleaseInterface(pdispDoc);

    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pTable);
    VariantClear (&varFactory);
    SysFreeString(bstrNamespace1);
    SysFreeString(bstrNamespace2);
    SysFreeString(bstrNamespace3);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPadSite::Create, per IElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT
CreateHelper(IElementNamespace * pNamespace, BOOL fSpecial)
{
    HRESULT     hr = S_OK;
    BSTR        bstrTag1 = SysAllocString(_T("ELEM1"));
    BSTR        bstrTag2 = SysAllocString(_T("ELEM2"));
    BSTR        bstrTag3 = SysAllocString(_T("ELEM3"));
    BSTR        bstrTag4 = SysAllocString(_T("Special"));

    Assert (pNamespace);

    hr = THR(pNamespace->AddTag(bstrTag1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->AddTag(bstrTag2, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->AddTag(bstrTag3, 0));
    if (hr)
        goto Cleanup;

    if( fSpecial )
    {
        hr = THR(pNamespace->AddTag(bstrTag4, 2));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrTag1);
    SysFreeString(bstrTag2);
    SysFreeString(bstrTag3);
    SysFreeString(bstrTag4);
    
    RRETURN (hr);
}

HRESULT
CPadSite::Create(IElementNamespace * pNamespace)
{
    if( !IsTagEnabled(tagImplementNSFactory2) )
    {
        RRETURN( CreateHelper( pNamespace, FALSE ) );
    }
    else
    {
        return E_UNEXPECTED;
    }
}

HRESULT
CPadSite::CreateWithImplementation( IElementNamespace * pNamespace, BSTR bstrImplementation )
{
    BOOL fSpecial = bstrImplementation && !StrCmpIC( bstrImplementation, _T("#default#special") );

    RRETURN (CreateHelper( pNamespace, fSpecial ) );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CPadSite::Resolve
//  
//  Synopsis:   Responds to requests from Trident to resolve tags
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          BSTR bstrNamespace - 
//          BSTR bstrTagName - 
//          BSTR bstrAttrs - 
//          IElementNamespace * pNamespace - 
//  
//+----------------------------------------------------------------------------

HRESULT
CPadSite::Resolve( BSTR bstrNamespace,
                   BSTR bstrTagName,
                   BSTR bstrAttrs,
                   IElementNamespace * pNamespace )
{
    Assert( bstrTagName && *bstrTagName );

    BOOL    fMakeLiteral = bstrTagName[0] == _T('L');
    BOOL    fMakeNested  = bstrTagName[0] == _T('N');
    BOOL    fMakeUnknown = bstrTagName[0] == _T('U');
    HRESULT hr           = S_OK;

    //
    // Testing host-queried element behaviors.  
    // If first char is "L", we'll call it literal.
    // If first char is "N", it's nested literal
    // If first char is "U", we'll claim we don't know it.
    //

    if( fMakeUnknown )
        goto Cleanup;

    hr = THR( pNamespace->AddTag( bstrTagName, fMakeLiteral ? ELEMENTDESCRIPTORFLAGS_LITERAL : ( fMakeNested ? ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL : 0 ) ) );
    if( hr )
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::FindBehavior, per IElementBehaviorFactory
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::FindBehavior(
    LPOLESTR                pchName,
    LPOLESTR                pchUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT         hr = S_OK;
    const static CLSID CLSID_OmegaBehavior = {0x3BF60250,0x6FAA,0x11D2,{0x98,0x68,0x00,0x00,0xF8,0x7A,0x48,0xD6}};

    if (!pchName ||
        (0 != StrCmpNIC(_T("DRT"),    pchName, 3) &&
         0 != StrCmpNIC(_T("ELEM1"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM2"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM3"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM01"), pchName, 6) &&
         0 != StrCmpNIC(_T("ELEM02"), pchName, 6) &&
         0 != StrCmpNIC(_T("ELEM03"), pchName, 6) &&
         0 != StrCmpNIC(_T("QueryElem"), pchName, 10) &&
         0 != StrCmpNIC(_T("LiteralElem"), pchName, 12) &&
         0 != StrCmpNIC(_T("RandomElem"), pchName, 11) &&
         0 != StrCmpNIC(_T("NestedLiteral"), pchName, 13) &&
         0 != StrCmpNIC(_T("Special"), pchName, 7)))
        return E_FAIL;

    if (ppPeer)
    {
        hr = THR(CoCreateInstance(
            CLSID_OmegaBehavior,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehavior,
            (void **)ppPeer));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPadSite::QueryUseLocalVersionVector
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::QueryUseLocalVersionVector(BOOL *pfUseLocal)
{
    *pfUseLocal = FALSE;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::QueryVersionVector
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::QueryVersionVector(IVersionVector *pVersion)
{
    HRESULT hr;
    TCHAR ach[MAX_PATH];

    hr = THR(pVersion->SetVersion(_T("mshtmpad"), _T("1.1p")));
    if (hr)
        goto Cleanup;

    _tcscpy(ach, _T("1."));
    _tcscat(ach, PadDoc()->ProcessorArchitecture());
    hr = THR(pVersion->SetVersion(_T("ProcessorArchitecture"), ach));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CPadSite::GetSequenceNumber( long nCurrent, long * pnNew )
{
    static long nSequenceNumber;

    if( !pnNew )
    {
        return E_INVALIDARG;
    }

    if( nCurrent == nSequenceNumber )
        *pnNew = nCurrent;
    else
        *pnNew = InterlockedIncrement( &nSequenceNumber );

    return S_OK;
}

STDMETHODIMP
CPadSite::GetExternal(IDispatch** ppDisp)
{
    HRESULT hr = E_INVALIDARG;

    if (ppDisp && PadDoc())
    {
        Assert(PadDoc()->GetObjectRefs());
        hr = THR(PadDoc()->QueryInterface(IID_IDispatch, (void**)ppDisp));
        Assert(PadDoc()->GetObjectRefs());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padscrub.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scrub.cxx
//
//  Contents:   Function to delete dangling references from the system registry.
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include "stdio.h"
#endif

char g_achScrub[2048];

static BOOL
OkToDelete(char *pch)
{
    static BOOL g_fAlwaysDelete;
    int iRet;

    if (g_fAlwaysDelete)
        return TRUE;

    wsprintfA(&g_achScrub[lstrlenA(g_achScrub)], "\nDelete %s from the registry?", pch);

    iRet = MessageBoxA(g_hwndMain, g_achScrub, "Scrub Registry", MB_APPLMODAL | MB_YESNO);

    if (iRet != IDYES)
        return FALSE;

    if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
        g_fAlwaysDelete = TRUE;

    return TRUE;
}

static void
DeleteKey(HKEY hkeyParent, char *pstrDelete)
{
    char    achSubKey[MAX_PATH];
    HKEY    hkeyDelete;

    if (RegOpenKeyA(hkeyParent, pstrDelete, &hkeyDelete) == ERROR_SUCCESS)
    {
        while (RegEnumKeyA(hkeyDelete, 0, achSubKey, sizeof(achSubKey))
                == ERROR_SUCCESS)
        {
            DeleteKey(hkeyDelete, achSubKey);
        }

        RegCloseKey(hkeyDelete);
    }
    RegDeleteKeyA(hkeyParent, pstrDelete);
}

static void
CheckCLSIDs(HKEY hkeyCLSID)
{
    char    achServer[MAX_PATH];
    char    achClass[MAX_PATH];
    char    achProgID[MAX_PATH];
    char    achPath[MAX_PATH];
    char    achUserType[MAX_PATH];
    HKEY    hkeyClass = NULL;
    DWORD   i;
    long    cb;

    // For each class....

    i = 0;
    while (RegEnumKeyA(hkeyCLSID,
            i,
            achClass,
            sizeof(achClass)) == ERROR_SUCCESS)
    {
        if (hkeyClass)
        {
            Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
            hkeyClass = NULL;
        }

        if (RegOpenKeyA(hkeyCLSID, achClass, &hkeyClass) == ERROR_SUCCESS)
        {
            // If we can't find the server for a class....

            cb = sizeof(achServer);
            if (RegQueryValueA(hkeyClass, INPROCSERVER, achServer, &cb)
                    == ERROR_SUCCESS &&
                achServer[0] &&         // Ignore empty strings.
                achServer[0] != '"' &&  // Ole2View registers with quotes. Ignore.
                SearchPathA(NULL, achServer, NULL, sizeof(achPath), achPath, NULL)
                    == 0)
            {
                // Find ProgID and user type name.

                cb = sizeof(achProgID);
                if (RegQueryValueA(hkeyClass, "ProgID", achProgID, &cb)
                        != ERROR_SUCCESS)
                {
                    achProgID[0] = 0;
                    achUserType[0] = 0;
                }
                else
                {
                    cb = sizeof(achUserType);
                    if (RegQueryValueA(HKEY_CLASSES_ROOT, achProgID, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }
                }

                // If we couldn't get a user type name from the ProgID, then
                // try to fetch one from the class id key.

                if (achUserType[0] == 0)
                {
                    cb = sizeof(achUserType);
                    if (RegQueryValueA(hkeyCLSID, achClass, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }
                }

                // Ask the user about deleting the class.

                wsprintfA(g_achScrub, "Server not found for CLSID\n\n"
                    "  Name   = %s\n"
                    "  Server = %s\n"
                    "  CLSID  = %s\n"
                    "  ProgID = %s\n",
                    achUserType,
                    achServer,
                    achClass,
                    achProgID);
                if (OkToDelete("class"))
                {
                    Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
                    hkeyClass = NULL;
                    DeleteKey(hkeyCLSID, achClass);
                    if (achProgID[0])
                        DeleteKey(HKEY_CLASSES_ROOT, achProgID);
                    continue;
                }
            }
        }
        i += 1;
    }

    if (hkeyClass)
    {
        Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
    }
}

static void
CheckProgIDs(HKEY hkeyCLSID)
{
    char    achClass[MAX_PATH];
    char    achProgID[MAX_PATH];
    char    achUserType[MAX_PATH];
    HKEY    hkeyProgID = NULL;
    HKEY    hkeyClass;
    DWORD   i;
    long    cb;

    // For each ProgID....

    i = 0;
    while (RegEnumKeyA(HKEY_CLASSES_ROOT,
            i,
            achProgID,
            sizeof(achProgID)) == ERROR_SUCCESS)
    {
        if (hkeyProgID)
        {
            Verify(RegCloseKey(hkeyProgID)  == ERROR_SUCCESS);
            hkeyProgID = NULL;
        }

        if (RegOpenKeyA(HKEY_CLASSES_ROOT, achProgID, &hkeyProgID) == ERROR_SUCCESS)
        {
            // If there's a class id...

            cb = sizeof(achClass);
            if (RegQueryValueA(hkeyProgID, "CLSID", achClass, &cb)
                    == ERROR_SUCCESS)
            {
                if (achClass[0] && RegOpenKeyA(hkeyCLSID, achClass, &hkeyClass) == ERROR_SUCCESS)
                {
                    RegCloseKey(hkeyClass);
                    hkeyClass = NULL;
                }
                else
                {
                    // We can't find the class id in the registry, so ask about deleting it.

                    cb = sizeof(achUserType);
                    if (RegQueryValueA(HKEY_CLASSES_ROOT, achProgID, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }

                    wsprintfA(g_achScrub, "CLSID not found for ProgID:\n\n"
                        "  Name   = %s\n"
                        "  CLSID  = %s\n"
                        "  ProgID = %s\n",
                        achUserType,
                        achClass,
                        achProgID);
                    if (OkToDelete("ProgID"))
                    {
                        RegCloseKey(hkeyProgID);
                        hkeyProgID = NULL;
                        DeleteKey(HKEY_CLASSES_ROOT, achProgID);
                        continue;
                    }
                }
            }

        }
        i += 1;
    }

    if (hkeyProgID)
    {
        Verify(RegCloseKey(hkeyProgID)  == ERROR_SUCCESS);
    }
}

static BOOL
CheckTypeLibraryPlatforms(
    HKEY hkeyVersion,
    char *pchTypeLib,
    char *pchVersion,
    char *pchName,
    char *pchLanguage)
{
    char    achFile[MAX_PATH];
    char    achPath[MAX_PATH];
    char    achPlatform[MAX_PATH];
    HKEY    hkeyLanguage;
    BOOL    fDelete = TRUE;
    long    cb;
    int     i;

    if (RegOpenKeyA(hkeyVersion, pchLanguage, &hkeyLanguage) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyLanguage,
            i,
            achPlatform,
            sizeof(achPlatform)) == ERROR_SUCCESS)
    {
        cb = sizeof(achFile);
        if (RegQueryValueA(hkeyLanguage, achPlatform, achFile, &cb)
                == ERROR_SUCCESS &&
            SearchPathA(NULL, achFile, NULL, sizeof(achPath), achPath, NULL)
                == 0)
        {
            wsprintfA(g_achScrub, "Type library file not found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n"
                "  Version  = %s\n"
                "  Language = %s\n"
                "  Platform = %s\n"
                "  File     = %s\n",
                pchName,
                pchTypeLib,
                pchVersion,
                pchLanguage,
                achPlatform,
                achFile);
            if (OkToDelete("platform entry"))
            {
                DeleteKey(hkeyLanguage, achPlatform);
                continue;
            }
            else
            {
                fDelete = FALSE;
            }
        }
        else
        {
            fDelete = FALSE;
        }
        i += 1;
    }

    RegCloseKey(hkeyLanguage);

    return fDelete;
}

static BOOL
CheckTypeLibraryLanguages(
    HKEY hkeyTypeLib,
    char *pchTypeLib,
    char *pchName,
    char *pchVersion)
{
    char    achLanguage[MAX_PATH];
    HKEY    hkeyVersion;
    BOOL    fDelete = TRUE;
    int     i;

    if (RegOpenKeyA(hkeyTypeLib, pchVersion, &hkeyVersion) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyVersion,
            i,
            achLanguage,
            sizeof(achLanguage)) == ERROR_SUCCESS)
    {
        if ('0' <= achLanguage[0] && achLanguage[0] <= '9')
        {
            if (CheckTypeLibraryPlatforms(
                        hkeyVersion,
                        pchTypeLib,
                        pchVersion,
                        pchName,
                        achLanguage))
            {
                wsprintfA(g_achScrub, "No entries for type library language found:\n\n"
                    "  Name     = %s\n"
                    "  TLID     = %s\n"
                    "  Version  = %s\n"
                    "  Language = %s\n",
                    pchName,
                    pchTypeLib,
                    pchVersion,
                    achLanguage);
                if (OkToDelete("language entry"))
                {
                    DeleteKey(hkeyVersion, achLanguage);
                    continue;
                }
                else
                {
                    fDelete = FALSE;
                }
            }
            else
            {
                fDelete = FALSE;
            }
        }
        i += 1;
    }

    RegCloseKey(hkeyVersion);

    return fDelete;
}

static BOOL
CheckTypeLibraryVersions(
    HKEY hkeyTypeLibRoot,
    char *pchTypeLib,
    char *pchName)
{
    char    achVersion[MAX_PATH];
    HKEY    hkeyTypeLib;
    BOOL    fDelete = TRUE;
    int     i;
    long    cb;

    if (RegOpenKeyA(hkeyTypeLibRoot, pchTypeLib, &hkeyTypeLib) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyTypeLib,
            i,
            achVersion,
            sizeof(achVersion)) == ERROR_SUCCESS)
    {
        cb = MAX_PATH;
        if (RegQueryValueA(hkeyTypeLib, achVersion, pchName, &cb)
                != ERROR_SUCCESS)
        {
            pchName[0] = 0;
        }

        if (CheckTypeLibraryLanguages(hkeyTypeLib, pchTypeLib, pchName, achVersion))
        {
            wsprintfA(g_achScrub, "No entries for type library version found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n"
                "  Version  = %s\n",
                pchName,
                pchTypeLib,
                achVersion);
            if (OkToDelete("version entry"))
            {
                DeleteKey(hkeyTypeLib, achVersion);
                continue;
            }
            else
            {
                fDelete = FALSE;
            }
        }
        else
        {
            fDelete = FALSE;
        }
        i += 1;
    }

    RegCloseKey( hkeyTypeLib );

    return fDelete;
}

static void
CheckTypeLibraries()
{
    char    achTypeLib[MAX_PATH];
    char    achName[MAX_PATH];
    HKEY    hkeyTypeLibRoot = NULL;
    int i;

    RegOpenKeyA(HKEY_CLASSES_ROOT, "TypeLib", &hkeyTypeLibRoot);

    i = 0;
    while (RegEnumKeyA(hkeyTypeLibRoot,
            i,
            achTypeLib,
            sizeof(achTypeLib)) == ERROR_SUCCESS)
    {
        achName[0] = 0;

        if (CheckTypeLibraryVersions(hkeyTypeLibRoot, achTypeLib, achName))
        {
            wsprintfA(g_achScrub, "No entries for type library found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n",
                achName,
                achTypeLib);
            if (OkToDelete("type library entry"))
            {
                DeleteKey(hkeyTypeLibRoot, achTypeLib);
                continue;
            }
        }
        i += 1;
    }

    RegCloseKey(hkeyTypeLibRoot);
}

void
ScrubRegistry()
{
    HKEY  hkeyCLSID = NULL;

    RegOpenKeyA(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);

    // Find dangling CLSIDs (server is missing)
    CheckCLSIDs(hkeyCLSID);

    // Find dangling ProgIDs (CLSID is missing)
    CheckProgIDs(hkeyCLSID);

    RegCloseKey(hkeyCLSID);

    // Find dangling Type libraries

    CheckTypeLibraries();

    MessageBoxA(g_hwndMain, "Done scanning registry for dangling references.", "Scrub Registry", MB_APPLMODAL | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padssite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padssite.hxx
//
//  Contents:   CPadScriptSite
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

EXTERN_C const GUID CGID_ScriptSite = {0x3050f3f1, 0x98b5, 0x11cf, {0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}};
#define CMDID_SCRIPTSITE_URL            0
#define CMDID_SCRIPTSITE_HTMLDLGTRUST   1
#define CMDID_SCRIPTSITE_SECSTATE       2
#define CMDID_SCRIPTSITE_SID            3

#undef ASSERT

class CConnectionPoint : public IConnectionPoint
{
public:

    CConnectionPoint(CPadScriptSite *pSite);
    ~CConnectionPoint();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CPadScriptSite *_pSite;
    ULONG    _ulRefs;
};

CConnectionPoint::CConnectionPoint(CPadScriptSite *pSite)
{
    _ulRefs = 1;
    _pSite = pSite;
    _pSite->AddRef();
}

CConnectionPoint::~CConnectionPoint()
{
    _pSite->Release();
}

ULONG
CConnectionPoint::AddRef()
{
    return _ulRefs += 1;
}

ULONG
CConnectionPoint::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

HRESULT
CConnectionPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_PadEvents;
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pSite;
    (*ppCPC)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    ClearInterface(&_pSite->_pDispSink);
    RRETURN(THR(pUnkSink->QueryInterface(IID_IDispatch, (void **)&_pSite->_pDispSink)));
}

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    ClearInterface(&_pSite->_pDispSink);
    return S_OK;
}

HRESULT
CConnectionPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadScriptSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IPad || iid == IID_IDispatch)
    {
        *ppv = (IPad *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppv = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo ||
            iid == IID_IProvideClassInfo2 ||
            iid == IID_IProvideMultipleClassInfo)
    {
        *ppv = (IProvideMultipleClassInfo *)this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite constructor
//
//---------------------------------------------------------------------------

CPadScriptSite::CPadScriptSite(CPadDoc * pDoc)
{
    _pDoc = pDoc;
    _ulRefs = 1;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite destructor
//
//---------------------------------------------------------------------------

CPadScriptSite::~CPadScriptSite()
{
    VariantClear(&_varParam);
    ClearInterface(&_pDispSink);
    Assert(_ulRefs <= 1);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::AddRef, Release
//
//---------------------------------------------------------------------------

ULONG
CPadScriptSite::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CPadScriptSite::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::Init
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::Init(TCHAR *pchType)
{
    HRESULT hr;
    IActiveScriptParse *pParse = NULL;
    static const CLSID CLSID_VBS = { 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8 };
    static const CLSID CLSID_JSCRIPT = { 0xf414c260, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58};
    BSTR    bstrName = NULL;
    BOOL    fJscript = FALSE;

    // CoCreate and connect to Script engine

    if (pchType)
    {
        fJscript = (StrCmpIC(pchType, _T(".js")) == 0);
    }

    hr = THR(CoCreateInstance(
            pchType && fJscript ? CLSID_JSCRIPT : CLSID_VBS,
            NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&_pScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->InitNew());
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->AddNamedItem(_T("Pad"), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS));
    if (hr)
        goto Cleanup;

    if (fJscript)
    {
        //
        // For JavaScript we have to manually hook up known event handlers.
        // All four of these methods _must_ exist in the .js file.
        //

        // Add any pad events that we know people use.
        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadLoad()"),
                     _T("Pad"),
                     NULL,
                     _T("Load"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadDocLoaded(fLoaded)"),
                     _T("Pad"),
                     NULL,
                     _T("DocLoaded(fLoaded)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadStatus(Status)"),
                     _T("Pad"),
                     NULL,
                     _T("Status(Status)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadTimer()"),
                     _T("Pad"),
                     NULL,
                     _T("Timer"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadUnload()"),
                     _T("Pad"),
                     NULL,
                     _T("Unload"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadPerfCtl(dwArg)"),
                     _T("Pad"),
                     NULL,
                     _T("PerfCtl(dwArg)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::Close
//
//---------------------------------------------------------------------------

void
CPadScriptSite::Close()
{
    if (_pScript)
    {
        IGNORE_HR(_pScript->Close());
        ClearInterface(&_pScript);
    }
}


//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetClassInfo, IProvideClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    HRESULT hr;

    hr = _pDoc->LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *ppTypeInfo = _pDoc->_pTypeInfoCPad;
    (*ppTypeInfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetGUID, IProvideClassInfo2
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = DIID_PadEvents;
    }
    else
    {
        return E_NOTIMPL;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
CPadScriptSite::GetMultiTypeInfoCount(ULONG *pc)
{
    *pc = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetInfoOfIndex, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetInfoOfIndex(
    ULONG       itinfo,
    DWORD       dwFlags,
    ITypeInfo** pptinfoCoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    Assert(itinfo == 0);

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        *pptinfoCoClass = _pDoc->_pTypeInfoCPad;
        (*pptinfoCoClass)->AddRef();
        if (pdwTIFlags)
            *pdwTIFlags = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        *pcdispidReserved = 100;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = IID_IPad;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = DIID_PadEvents;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------
HRESULT
CPadScriptSite::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    // I hate this interface.
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_PadEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CConnectionPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetLCID, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetLCID(LCID *plcid)
{
  return E_NOTIMPL;     // Use system settings
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetItemInfo, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetItemInfo(
      LPCOLESTR   pstrName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
            return E_INVALIDARG;
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
            return E_INVALIDARG;
        *ppunkItemOut = NULL;
    }

    if (!StrCmpIC(_T("Pad"), pstrName))
    {
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            *pptinfoOut = PadDoc()->_pTypeInfoCPad;
            (*pptinfoOut)->AddRef();
        }
        if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
        {
            *ppunkItemOut = (IPad *)this;
            (*ppunkItemOut)->AddRef();
        }
        return S_OK;
    }


    return TYPE_E_ELEMENTNOTFOUND;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetDocVersionString, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetDocVersionString(BSTR *pbstrVersion)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::RequestItems()
{
    return _pScript->AddNamedItem(_T("Pad"), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::RequestTypeLibs, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::RequestTypeLibs()
{
    return _pScript->AddTypeLib(LIBID_Pad, 1, 0, 0);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnScriptTerminate, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnScriptTerminate(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo)
{
    // UNDONE: Put up error dlg here
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnStateChange, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
    // Don't care about notification
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnScriptError, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnScriptError(IActiveScriptError *pse)
{
    BSTR        bstrLine = NULL;
    BSTR        bstr;
    TCHAR *     pchDescription;
    TCHAR       achDescription[256];
    TCHAR *     pchMessage = NULL;
    EXCEPINFO   ei;
    DWORD       dwSrcContext;
    ULONG       ulLine;
    LONG        ichError;
    HRESULT     hr;

    hr = THR(pse->GetExceptionInfo(&ei));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourceLineText(&bstrLine));
    if (hr)
        hr = S_OK;  // Ignore this error, there may not be source available

    if (ei.bstrDescription)
    {
        pchDescription = ei.bstrDescription;
    }
    else
    {
        achDescription[0] = 0;
        FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                ei.scode,
                LANG_SYSTEM_DEFAULT,
                achDescription,
                ARRAY_SIZE(achDescription),
                NULL);
        pchDescription = achDescription;
    }

    hr = THR(Format(FMT_OUT_ALLOC, &pchMessage, 0,
        _T("File: <0s>\r\n")
        _T("Line: <1d>\r\n")
        _T("Char: <2d>\r\n")
        _T("Text: <3s>\r\n")
        _T("Scode: <4x>\r\n")
        _T("Source: <5s>\r\n")
        _T("Description: <6s>\r\n"),
        _achPath,
        (long)(ulLine + 1),
        (long)(ichError),
        bstrLine ? bstrLine : _T(""),
        ei.scode,
        ei.bstrSource ? ei.bstrSource : _T(""),
        pchDescription));
    if (hr)
        goto Cleanup;

    bstr = SysAllocString(pchMessage);

    // PrintLog needs a BSTR
    _pDoc->PrintLog(bstr);

    SysFreeString(bstr);

    if (!IsTagEnabled(tagAssertExit))
    {
        MSGBOXPARAMS mbp;
        memset(&mbp, 0, sizeof(mbp));
        mbp.cbSize = sizeof(mbp);
        mbp.hwndOwner = PadDoc()->_hwnd;
        mbp.lpszText = pchMessage;
        mbp.lpszCaption = _T("Error");
        mbp.dwStyle = MB_APPLMODAL | MB_ICONERROR | MB_OK;

        MessageBoxIndirect(&mbp);
    }
    else
    {
        AssertSz(FALSE, "Script Error Occurred. (See logfile)");
    }

Cleanup:
    if(ei.bstrSource)
        SysFreeString(ei.bstrSource);
    if(ei.bstrDescription)
        SysFreeString(ei.bstrDescription);
    if(ei.bstrHelpFile)
        SysFreeString(ei.bstrHelpFile);
    MemFree(pchMessage);
    if (bstrLine)
        SysFreeString(bstrLine);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnEnterScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::OnEnterScript()
{
    // No need to do anything
    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnLeaveScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::OnLeaveScript()
{
    // No need to do anything
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::GetWindow(HWND *phwndOut)
{
    *phwndOut = PadDoc()->_hwnd;
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::EnableModeless, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::ExecuteScriptFile
//
//  Load and execute script file
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::ExecuteScriptFile(TCHAR *pchPath)
{
    HRESULT     hr;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cchFile;
    DWORD       cbRead;
    char *      pchBuf = 0;
    TCHAR *     pchBufWide = 0;
    TCHAR *     pchFile;

    GetFullPathName(pchPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);

    // Load script file

    hFile = CreateFile(pchPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    cchFile = GetFileSize(hFile, NULL);
    if (cchFile == 0xFFFFFFFF)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    pchBuf = new char[cchFile + 1];
    pchBufWide = new TCHAR[cchFile + 1];
    if (!pchBuf || !pchBufWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!ReadFile(hFile, pchBuf, cchFile, &cbRead, 0))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    pchBuf[cbRead] = 0;

    MultiByteToWideChar(CP_ACP, 0, pchBuf, -1, pchBufWide, cchFile + 1);

    // Execute script

    _pDoc->SetStatusText(NULL);

    hr = ExecuteScriptStr(pchBufWide);
    if(hr)
        goto Cleanup;

    _pDoc->SetStatusText(NULL);

Cleanup:
    delete pchBuf;
    delete pchBufWide;
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::ExecuteScriptStr
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::ExecuteScriptStr(TCHAR * pchScript)
{
    HRESULT hr;
    IActiveScriptParse * pParse = NULL;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->ParseScriptText(pchScript, _T("Pad"), NULL, NULL, 0, 0, 0L, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::SetScriptState
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::SetScriptState(SCRIPTSTATE ss)
{
    return _pScript->SetScriptState(ss);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::xxx, IPad
//
//          The implementation of IPad passed to the script engine
//          cannot be the same as that of the CPadDoc because this
//          causes a reference count loop with the script engine.
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::GetTypeInfoCount(UINT FAR* pctinfo)
            { return PadDoc()->GetTypeInfoCount(pctinfo); }
HRESULT CPadScriptSite::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo FAR* FAR* pptinfo)
            { return PadDoc()->GetTypeInfo(itinfo, lcid, pptinfo); }
HRESULT CPadScriptSite::GetIDsOfNames(
  REFIID riid,
  OLECHAR FAR* FAR* rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID FAR* rgdispid)
            { return PadDoc()->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
HRESULT CPadScriptSite::Invoke(
						  DISPID dispidMember,
						  REFIID riid,
						  LCID lcid,
						  WORD wFlags,
						  DISPPARAMS FAR* pdispparams,
						  VARIANT FAR* pvarResult,
						  EXCEPINFO FAR* pexcepinfo,
						  UINT FAR* puArgErr)
            { return PadDoc()->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }
HRESULT CPadScriptSite::DoEvents(VARIANT_BOOL Wait)
            { return PadDoc()->DoEvents(Wait); }
HRESULT CPadScriptSite::EndEvents()
            { return PadDoc()->EndEvents(); }
HRESULT CPadScriptSite::ClearDownloadCache()
            { return PadDoc()->ClearDownloadCache(); }
HRESULT CPadScriptSite::WaitForRecalc()
            { return PadDoc()->WaitForRecalc(); }
HRESULT CPadScriptSite::SetPerfCtl(DWORD dwFlags)
            { return PadDoc()->SetPerfCtl(dwFlags); }
HRESULT CPadScriptSite::LockWindowUpdate(VARIANT_BOOL fLock)
            { return PadDoc()->LockWindowUpdate(fLock); }
HRESULT CPadScriptSite::LockKeyState(VARIANT_BOOL fShift, VARIANT_BOOL fControl, VARIANT_BOOL fAlt)
            { return PadDoc()->LockKeyState(fShift, fControl, fAlt); }
HRESULT CPadScriptSite::UnlockKeyState()
            { return PadDoc()->UnlockKeyState(); }
HRESULT CPadScriptSite::SendKeys(BSTR Keys, VARIANT_BOOL Wait)
            { return PadDoc()->SendKeys(Keys, Wait); }
HRESULT CPadScriptSite::OpenFile(BSTR Path, BSTR ProgID)
            { return PadDoc()->OpenFile(Path, ProgID); }
HRESULT CPadScriptSite::SaveFile(BSTR Path)
            { return PadDoc()->SaveFile(Path); }
HRESULT CPadScriptSite::CloseFile()
            { return PadDoc()->CloseFile(); }
HRESULT CPadScriptSite::ExecuteCommand(long CmdID, VARIANT * Data, VARIANT *pIDocument)
            { return PadDoc()->ExecuteCommand(CmdID, Data, pIDocument); }
HRESULT CPadScriptSite::QueryCommandStatus(long CmdID, VARIANT * Status)
            { return PadDoc()->QueryCommandStatus(CmdID, Status); }
HRESULT CPadScriptSite::ExecuteScript(BSTR Path, VARIANT *ScriptParam, VARIANT_BOOL Async)
            { return PadDoc()->ExecuteScript(Path, ScriptParam, Async); }
HRESULT CPadScriptSite::RegisterControl(BSTR Path)
            { return PadDoc()->RegisterControl(Path); }
HRESULT CPadScriptSite::IncludeScript(BSTR Path)
            { return PadDoc()->IncludeScript(Path); }
HRESULT CPadScriptSite::SetProperty(IDispatch * pDisp, BSTR bstrProp, VARIANT * pVar)
            { return PadDoc()->SetProperty(pDisp, bstrProp, pVar); }
HRESULT CPadScriptSite::GetProperty(IDispatch * pDisp, BSTR bstrProp, VARIANT * pVar)
            { return PadDoc()->GetProperty(pDisp, bstrProp, pVar); }
HRESULT CPadScriptSite::get_ScriptPath(long Level, BSTR * Path)
            { return PadDoc()->get_ScriptPath(Level, Path); }
HRESULT CPadScriptSite::get_ProcessorArchitecture(BSTR * MachineType)
            { return PadDoc()->get_ProcessorArchitecture(MachineType); }
HRESULT CPadScriptSite::get_ScriptParam(VARIANT *ScriptParam)
            { return PadDoc()->get_ScriptParam(ScriptParam); }
HRESULT CPadScriptSite::get_ScriptObject(IDispatch **ScriptObject)
            { return PadDoc()->get_ScriptObject(ScriptObject); }
HRESULT CPadScriptSite::get_CurrentTime(long * Time)
            { return PadDoc()->get_CurrentTime(Time); }
HRESULT CPadScriptSite::get_Document(IDispatch * * Document)
            { return PadDoc()->get_Document(Document); }
HRESULT CPadScriptSite::get_TempPath(BSTR * Path)
            { return PadDoc()->get_TempPath(Path); }
HRESULT CPadScriptSite::GetTempFileName(BSTR * Name)
            { return PadDoc()->GetTempFileName(Name); }
HRESULT CPadScriptSite::PrintStatus(BSTR Message)
            { return PadDoc()->PrintStatus(Message); }
HRESULT CPadScriptSite::PrintLog(BSTR Line)
            { return PadDoc()->PrintLog(Line); }
HRESULT CPadScriptSite::PrintLogFile(BSTR FileName)
            { return PadDoc()->PrintLogFile(FileName); }
HRESULT CPadScriptSite::PrintDebug(BSTR Line)
            { return PadDoc()->PrintDebug(Line); }
HRESULT CPadScriptSite::CreateObject(BSTR ProgID, IDispatch **ppDisp)
            { return PadDoc()->CreateObject(ProgID, ppDisp); }
HRESULT CPadScriptSite::GetObject(BSTR FileName, BSTR ProgID, IDispatch **ppDisp)
            { return PadDoc()->GetObject(FileName, ProgID, ppDisp); }
HRESULT CPadScriptSite::CompareFiles(BSTR File1, BSTR File2, VARIANT_BOOL * FilesMatch)
            { return PadDoc()->CompareFiles(File1, File2, FilesMatch); }
HRESULT CPadScriptSite::CopyThisFile(BSTR File1, BSTR File2, VARIANT_BOOL * Success)
            { return PadDoc()->CopyThisFile(File1, File2, Success); }
HRESULT CPadScriptSite::DRTPrint(long Flags, VARIANT_BOOL * Success)
            { return PadDoc()->DRTPrint(Flags, Success); }
HRESULT CPadScriptSite::SetDefaultPrinter(BSTR bstrNewDefaultPrinter, VARIANT_BOOL * Success)
            { return PadDoc()->SetDefaultPrinter(bstrNewDefaultPrinter, Success); }
HRESULT CPadScriptSite::SetPrintTemplate(IUnknown *pUnk, VARIANT_BOOL fTemplate)
            { return PadDoc()->SetPrintTemplate(pUnk, fTemplate); }
HRESULT CPadScriptSite::IsPrintTemplate(IUnknown *pUnk, VARIANT_BOOL *pfTemplate)
            { return PadDoc()->IsPrintTemplate(pUnk, pfTemplate); }
HRESULT CPadScriptSite::FileExists(BSTR File, VARIANT_BOOL * pfFileExists)
            { return PadDoc()->FileExists(File, pfFileExists); }
HRESULT CPadScriptSite::get_TimerInterval(long * Interval)
            { return PadDoc()->get_TimerInterval(Interval); }
HRESULT CPadScriptSite::put_TimerInterval(long Interval)
            { return PadDoc()->put_TimerInterval(Interval); }
HRESULT CPadScriptSite::DisableDialogs()
            { return PadDoc()->DisableDialogs(); }
HRESULT CPadScriptSite::ShowWindow(long lCmdShow)
            { return PadDoc()->ShowWindow(lCmdShow); }
HRESULT CPadScriptSite::MoveWindow(long x,long y, long cx, long cy)
            { return PadDoc()->MoveWindow(x, y, cx, cy); }
HRESULT CPadScriptSite::get_WindowLeft(long *x)
            { return PadDoc()->get_WindowLeft(x); }
HRESULT CPadScriptSite::get_WindowTop(long *y)
            { return PadDoc()->get_WindowTop(y); }
HRESULT CPadScriptSite::get_WindowWidth(long *cx)
            { return PadDoc()->get_WindowWidth(cx); }
HRESULT CPadScriptSite::get_WindowHeight(long *cy)
            { return PadDoc()->get_WindowHeight(cy); }
HRESULT CPadScriptSite::get_DialogsEnabled(VARIANT_BOOL *Enabled)
            { return PadDoc()->get_DialogsEnabled(Enabled); }
HRESULT CPadScriptSite::StartCAP()
            { return PadDoc()->StartCAP(); }
HRESULT CPadScriptSite::StopCAP()
            { return PadDoc()->StopCAP(); }
HRESULT CPadScriptSite::SuspendCAP()
            { return PadDoc()->SuspendCAP(); }
HRESULT CPadScriptSite::ResumeCAP()
            { return PadDoc()->ResumeCAP(); }
HRESULT CPadScriptSite::TicStartAll()
            { return PadDoc()->TicStartAll(); }
HRESULT CPadScriptSite::TicStopAll()
            { return PadDoc()->TicStopAll(); }
HRESULT CPadScriptSite::ASSERT(VARIANT_BOOL Assertion, BSTR LogMsg)
            { return PadDoc()->ASSERT(Assertion, LogMsg); }
HRESULT CPadScriptSite::get_Lines(IDispatch * pObject, long *pl)
            { return PadDoc()->get_Lines(pObject, pl); }
HRESULT CPadScriptSite::get_Line(IDispatch * pObject, long l, IDispatch **ppLine)
            { return PadDoc()->get_Line(pObject, l, ppLine); }
HRESULT CPadScriptSite::get_Cascaded(IDispatch * pObject, IDispatch **ppCascaded)
            { return PadDoc()->get_Cascaded(pObject, ppCascaded); }
HRESULT CPadScriptSite::EnableTraceTag(BSTR bstrTag, BOOL fEnable)
            { return PadDoc()->EnableTraceTag(bstrTag, fEnable); }
HRESULT CPadScriptSite::EnableSnapToGrid(BOOL fEnable)
            { return PadDoc()->EnableSnapToGrid(fEnable); }
HRESULT CPadScriptSite::get_Dbg(long * plDbg)
            { return PadDoc()->get_Dbg(plDbg); }
HRESULT CPadScriptSite::CleanupTempFiles()
            { return PadDoc()->CleanupTempFiles(); }
HRESULT CPadScriptSite::WsClear()
            { return PadDoc()->WsClear(); }
HRESULT CPadScriptSite::WsTakeSnapshot()
            { return PadDoc()->WsTakeSnapshot(); }
HRESULT CPadScriptSite::get_WsModule(long row, BSTR *pbstrModule)
            { return PadDoc()->get_WsModule(row, pbstrModule); }
HRESULT CPadScriptSite::get_WsSection(long row, BSTR *pbstrSection)
            { return PadDoc()->get_WsSection(row, pbstrSection); }
HRESULT CPadScriptSite::get_WsSize(long row, long *plWsSize)
            { return PadDoc()->get_WsSize(row, plWsSize); }
HRESULT CPadScriptSite::get_WsCount(long *plCount)
            { return PadDoc()->get_WsCount(plCount); }
HRESULT CPadScriptSite::get_WsTotal(long *plTotal)
            { return PadDoc()->get_WsTotal(plTotal); }
HRESULT CPadScriptSite::WsStartDelta()
            { return PadDoc()->WsStartDelta(); }
HRESULT CPadScriptSite::WsEndDelta(long *pnPageFaults)
            { return PadDoc()->WsEndDelta(pnPageFaults); }
HRESULT CPadScriptSite::SetRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName, VARIANT value)
            { return PadDoc()->SetRegValue(hkey, bstrSubKey, bstrValueName, value); }
HRESULT CPadScriptSite::CoMemoryTrackDisable(VARIANT_BOOL fDisable)
            { return PadDoc()->CoMemoryTrackDisable(fDisable); }
HRESULT CPadScriptSite::get_UseShdocvw(VARIANT_BOOL *pfHosted)
            { return PadDoc()->get_UseShdocvw(pfHosted); }
HRESULT CPadScriptSite::put_UseShdocvw(VARIANT_BOOL fHosted)
            { return PadDoc()->put_UseShdocvw(fHosted); }
HRESULT CPadScriptSite::GoBack(VARIANT_BOOL *pfWentBack)
            { return PadDoc()->GoBack(pfWentBack); }
HRESULT CPadScriptSite::GoForward(VARIANT_BOOL *pfWentForward)
            { return PadDoc()->GoForward(pfWentForward); }
HRESULT CPadScriptSite::TestExternal(BSTR bstrDLLName, BSTR bstrFunctionName, VARIANT *pParam, long *plRetVal)
            { return PadDoc()->TestExternal(bstrDLLName, bstrFunctionName, pParam, plRetVal); }
HRESULT CPadScriptSite::UnLoadDLL()
            { return PadDoc()->UnLoadDLL(); }
HRESULT CPadScriptSite::DeinitDynamicLibrary(BSTR bstrDLLName)
            { return PadDoc()->DeinitDynamicLibrary(bstrDLLName); }
HRESULT CPadScriptSite::IsDynamicLibraryLoaded(BSTR bstrDLLName, VARIANT_BOOL * pfLoaded)
            { return PadDoc()->IsDynamicLibraryLoaded(bstrDLLName, pfLoaded); }
HRESULT CPadScriptSite::GetRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName, VARIANT *pValue)
            { return PadDoc()->GetRegValue(hkey, bstrSubKey, bstrValueName, pValue); }
HRESULT CPadScriptSite::DeleteRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName)
            { return PadDoc()->DeleteRegValue(hkey, bstrSubKey, bstrValueName); }
HRESULT CPadScriptSite::TrustProvider(BSTR bstrKey, BSTR bstrProvider, VARIANT *poldValue)
            { return PadDoc()->TrustProvider(bstrKey, bstrProvider, poldValue); }
HRESULT CPadScriptSite::RevertTrustProvider(BSTR bstrKey)
            { return PadDoc()->RevertTrustProvider(bstrKey); }
HRESULT CPadScriptSite::DoReloadHistory()
            { return PadDoc()->DoReloadHistory(); }
HRESULT CPadScriptSite::ComputeCRC(BSTR bstrKey, VARIANT * pCRC)
            { return PadDoc()->ComputeCRC(bstrKey, pCRC); }
HRESULT CPadScriptSite::OpenFileStream(BSTR bstrPath)
            { return PadDoc()->OpenFileStream(bstrPath); }
HRESULT CPadScriptSite::get_ViewChangesFired(long *plCount)
            { return PadDoc()->get_ViewChangesFired(plCount); }
HRESULT CPadScriptSite::get_DataChangesFired(long *plCount)
            { return PadDoc()->get_DataChangesFired(plCount); }
HRESULT CPadScriptSite::get_DownloadNotifyMask(ULONG *pulMask)
            { return PadDoc()->get_DownloadNotifyMask(pulMask); }
HRESULT CPadScriptSite::put_DownloadNotifyMask(ULONG ulMask)
            { return PadDoc()->put_DownloadNotifyMask(ulMask); }
HRESULT CPadScriptSite::DumpMeterLog(BSTR bstrFileName)
            { return PadDoc()->DumpMeterLog(bstrFileName); }
HRESULT CPadScriptSite::LookupMeter(BSTR Meter, long* mt)
            { return PadDoc()->LookupMeter(Meter, mt); }
HRESULT CPadScriptSite::GetMeterName(long mt, BSTR* pbstrName)
            { return PadDoc()->GetMeterName(mt, pbstrName); }
HRESULT CPadScriptSite::GetMeterDesc(long mt, BSTR* pbstrDesc)
            { return PadDoc()->GetMeterDesc(mt, pbstrDesc); }
HRESULT CPadScriptSite::GetMeterCnt(long mt, VARIANT_BOOL fExcl, long* plCnt)
            { return PadDoc()->GetMeterCnt(mt, fExcl, plCnt); }
HRESULT CPadScriptSite::GetMeterVal(long mt, VARIANT_BOOL fExcl, long* plVal)
            { return PadDoc()->GetMeterVal(mt, fExcl, plVal); }
HRESULT CPadScriptSite::MeterAdd(long mt, long lCnt, long lVal)
            { return PadDoc()->MeterAdd(mt, lCnt, lVal); }
HRESULT CPadScriptSite::MeterSet(long mt, long lCnt, long lVal)
            { return PadDoc()->MeterSet(mt, lCnt, lVal); }
HRESULT CPadScriptSite::GetSwitchTimers(VARIANT * pValue)
            { return PadDoc()->GetSwitchTimers(pValue); }
HRESULT CPadScriptSite::TransformXGlobal(int x, int* retX)
            { return PadDoc()->TransformXGlobal(x, retX); }
HRESULT CPadScriptSite::TransformYGlobal(int y, int* retY)
            { return PadDoc()->TransformXGlobal(y,retY); }
HRESULT CPadScriptSite::TransformXDocument(int x, int* retX)
            { return PadDoc()->TransformXDocument(x, retX);}
HRESULT CPadScriptSite::TransformYDocument(int y, int* retY)
            { return PadDoc()->TransformYDocument(y,retY);}
HRESULT CPadScriptSite::MoveMouseTo(int X, int Y, VARIANT_BOOL fLeftButton, int keyState)
            { return PadDoc()->MoveMouseTo(X, Y, fLeftButton, keyState); }
HRESULT CPadScriptSite::DoMouseButton(VARIANT_BOOL fLeftButton, BSTR action, int keyState)
            { return PadDoc()->DoMouseButton(fLeftButton, action, keyState); }
HRESULT CPadScriptSite::DoMouseButtonAt(int X, int Y,VARIANT_BOOL fLeftButton, BSTR action, int keyState)
            { return PadDoc()->DoMouseButtonAt(X, Y, fLeftButton, action, keyState); }            
HRESULT CPadScriptSite::TimeSaveDocToDummyStream(long * plTimeMicros)
            { return PadDoc()->TimeSaveDocToDummyStream(plTimeMicros); }
HRESULT CPadScriptSite::Sleep (int nTimeout)
            { return PadDoc()->Sleep (nTimeout); }
HRESULT CPadScriptSite::IsWin95 (long * pfWin95)
            { return PadDoc()->IsWin95(pfWin95); }
HRESULT CPadScriptSite::GetAccWindow( IDispatch ** ppAccWindow)
        { return PadDoc()->GetAccWindow( ppAccWindow ); }
HRESULT CPadScriptSite::GetAccObjAtPoint( long x, long y, IDispatch **ppAccObject )
        { return PadDoc()->GetAccObjAtPoint(x, y, ppAccObject ); }
HRESULT CPadScriptSite::GetAccChildIdAtPoint( IDispatch * pAccObj, long x, long y, long * plChildId )
        { return PadDoc()->GetAccChildIdAtPoint( pAccObj, x, y, plChildId ); }
HRESULT CPadScriptSite::SetKeyboard(BSTR bstrKeyboard)
        { return PadDoc()->SetKeyboard(bstrKeyboard); }
HRESULT CPadScriptSite::GetKeyboard(VARIANT *pKeyboard)
        { return PadDoc()->GetKeyboard(pKeyboard); }
HRESULT CPadScriptSite::ToggleIMEMode(BSTR bstrIME)
        { return PadDoc()->ToggleIMEMode(bstrIME); }
HRESULT CPadScriptSite::SendIMEKeys(BSTR bstrKeys)
        { return PadDoc()->SendIMEKeys(bstrKeys); }
HRESULT CPadScriptSite::Markup(VARIANT * p1,VARIANT * p2,VARIANT * p3, VARIANT * p4, VARIANT * p5, VARIANT * p6, VARIANT * p7 )
        { return PadDoc()->Markup( p1, p2, p3, p4, p5, p6, p7 ); }
HRESULT CPadScriptSite::Random(long a, long * b )
        { return PadDoc()->Random( a, b ); }
HRESULT CPadScriptSite::RandomSeed(long a )
        { return PadDoc()->RandomSeed( a ); }
HRESULT CPadScriptSite::GetHeapCounter(long a, long * b )
        { return PadDoc()->GetHeapCounter( a, b ); }
HRESULT CPadScriptSite::CreateProcess(BSTR bstrCommandLine, VARIANT_BOOL fWait, VARIANT_BOOL fCaptureOutput, DWORD *pdwExitCode)
        { return PadDoc()->CreateProcess(bstrCommandLine, fWait, fCaptureOutput, pdwExitCode); }
HRESULT CPadScriptSite::GetCurrentProcessId(long * plRetVal)
        { return PadDoc()->GetCurrentProcessId(plRetVal); }
HRESULT CPadScriptSite::InnerHTML(IDispatch *pdispElement, BSTR *pbstrHTML)
        { return PadDoc()->InnerHTML(pdispElement, pbstrHTML); }
HRESULT CPadScriptSite::CurrentBlockElement(IDispatch **ppdispElement)
        { return PadDoc()->CurrentBlockElement(ppdispElement); }
HRESULT CPadScriptSite::FindMshtmlWindow(BSTR bstrClassName, long * plhwnd)
        { return PadDoc()->FindMshtmlWindow( bstrClassName, plhwnd ); }
HRESULT CPadScriptSite::GetMshtmlDoc(long hwnd, IDispatch **ppdispDocument)
        { return PadDoc()->GetMshtmlDoc( hwnd, ppdispDocument); }
HRESULT CPadScriptSite::SetActiveWindow( long lhwnd )
        { return PadDoc()->SetActiveWindow( lhwnd ); }
HRESULT CPadScriptSite::DoPerfEnable(BOOL fEnable)
        { return PadDoc()->DoPerfEnable(fEnable); }
HRESULT CPadScriptSite::DoPerfLog(BSTR bstrLog)
        { return PadDoc()->DoPerfLog(bstrLog); }
HRESULT CPadScriptSite::DoPerfDump()
        { return PadDoc()->DoPerfDump(); }
HRESULT CPadScriptSite::DoPerfClear()
        { return PadDoc()->DoPerfClear(); }
HRESULT CPadScriptSite::BeginPCounters()
        { return PadDoc()->BeginPCounters(); }
HRESULT CPadScriptSite::EndPCounters()
        { return PadDoc()->EndPCounters(); }
HRESULT CPadScriptSite::GetPCounter(long lWhich, DWORD * plCounter)
        { return PadDoc()->GetPCounter(lWhich, plCounter); }
HRESULT CPadScriptSite::GetPTime(DWORD * plTime)
        { return PadDoc()->GetPTime(plTime); }
HRESULT CPadScriptSite::Repaint()
        { return PadDoc()->Repaint(); }
HRESULT CPadScriptSite::alert(BSTR str)
        { return PadDoc()->alert(str); }
HRESULT CPadScriptSite::IsDebugPad(VARIANT_BOOL *pfDebugPad)
        { return PadDoc()->IsDebugPad(pfDebugPad); }        
HRESULT CPadScriptSite::GetPCounterString(VARIANT *pValue)
        { return PadDoc()->GetPCounterString(pValue); }
HRESULT CPadScriptSite::GetPrimaryElement( int* piPrimaryElement )
        { return PadDoc()->GetPrimaryElement( piPrimaryElement ) ; }
HRESULT CPadScriptSite::LinesInElement(IDispatch *pDispElement, int *pValue)
        { return PadDoc()->LinesInElement(pDispElement, pValue); }
HRESULT CPadScriptSite::FontsOnLine(IDispatch *pDispElement, int iLine, BSTR *pbstrFonts)
        { return PadDoc()->FontsOnLine(pDispElement, iLine, pbstrFonts); }
HRESULT CPadScriptSite::IsDebugTrident(VARIANT_BOOL *pfDebugTrident)
        { return PadDoc()->IsDebugTrident(pfDebugTrident); }        
HRESULT CPadScriptSite::IsWin2k(VARIANT_BOOL *pfWin2k)
        { return PadDoc()->IsWin2k(pfWin2k); }        
HRESULT CPadScriptSite::IsWhistler(VARIANT_BOOL *pfWhistler)
        { return PadDoc()->IsWhistler(pfWhistler); }        
HRESULT CPadScriptSite::ComputerName(BSTR *pbstrComputerName)
        { return PadDoc()->ComputerName(pbstrComputerName); }        
HRESULT CPadScriptSite::GetPixel(int X, int Y, int *piColor)
        { return PadDoc()->GetPixel(X, Y, piColor); }
HRESULT CPadScriptSite::GetUnsecureWindow(IDispatch * pWindowIn, IDispatch **ppWndDisp)
        { return PadDoc()->GetUnsecureWindow(pWindowIn, ppWndDisp); }
HRESULT CPadScriptSite::EnableUIUpdate( VARIANT_BOOL fEnable )
        { return PadDoc()->EnableUIUpdate( fEnable ); }
HRESULT CPadScriptSite::get_BuildId(BSTR * pbstrBuildId)
            { return PadDoc()->get_BuildId(pbstrBuildId); }
HRESULT CPadScriptSite::IsUsingBckgrnRecalc(VARIANT_BOOL *pfUsingBckgrnRecalc)
        { return PadDoc()->IsUsingBckgrnRecalc(pfUsingBckgrnRecalc); }        
HRESULT CPadScriptSite::IsEncodingAutoSelect(VARIANT_BOOL *pfEncodingAutoSelect)
        { return PadDoc()->IsEncodingAutoSelect(pfEncodingAutoSelect); }        
HRESULT CPadScriptSite::EnableEncodingAutoSelect(VARIANT_BOOL fEnable)
        { return PadDoc()->EnableEncodingAutoSelect(fEnable); }        
HRESULT CPadScriptSite::IsUsingTableIncRecalc(VARIANT_BOOL *pfUsingTableIncRecalc)
        { return PadDoc()->IsUsingTableIncRecalc(pfUsingTableIncRecalc); }        
HRESULT CPadScriptSite::GetPadEnumPrivacyRecords(IDispatch** ppEnumPrivacyRecords)
        { return PadDoc()->GetPadEnumPrivacyRecords(ppEnumPrivacyRecords); }
HRESULT CPadScriptSite::PadCommand(WORD widm)
        { return PadDoc()->PadCommand(widm); }

HRESULT 
CPadScriptSite::QueryStatus(
			        const GUID * pguidCmdGroup,
			        ULONG cCmds,
			        MSOCMD rgCmds[],
			        MSOCMDTEXT * pcmdtext)
{
    return S_OK;
}

HRESULT 
CPadScriptSite::Exec(
			const GUID * pguidCmdGroup,
			DWORD nCmdID,
			DWORD nCmdexecopt,
			VARIANTARG * pvarargIn,
			VARIANTARG * pvarargOut)
{
    HRESULT                     hr = S_OK;
    IDispatch *                 pDisp = NULL;
    IInternetSecurityManager *  pSecMgr = NULL;
    CVariant                    VarUrl;
    TCHAR                       ach[4096];  // pdlUrlLen
    DWORD                       dwSize;
    BYTE                        abSID[MAX_SIZE_SECURITY_ID];
    DWORD                       cbSID = ARRAY_SIZE(abSID);

    if (!pguidCmdGroup || *pguidCmdGroup != CGID_ScriptSite)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    switch (nCmdID)
    {
    case CMDID_SCRIPTSITE_SID:
    case CMDID_SCRIPTSITE_URL:
        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT(pvarargOut) = VT_BSTR;

        hr = THR(_pDoc->_pObject->QueryInterface(IID_IDispatch, (void **) &pDisp));
        if (hr)
            goto Cleanup;

        // call invoke DISPID_SECURITYCTX off pDisp to get SID
        hr = THR_NOTRACE(GetDispProp(
                pDisp,
                DISPID_SECURITYCTX,
                LOCALE_SYSTEM_DEFAULT,
                &VarUrl,
                NULL,
                FALSE));
        if (hr) 
            goto Cleanup;

        if (V_VT(&VarUrl) != VT_BSTR || !V_BSTR(&VarUrl))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(CoInternetParseUrl(
                V_BSTR(&VarUrl), 
                PARSE_ENCODE, 
                0, 
                ach, 
                ARRAY_SIZE(ach), 
                &dwSize, 
                0));
        if (hr)
            goto Cleanup;

        if (nCmdID == CMDID_SCRIPTSITE_URL)
        {
            hr = FormsAllocStringLen(ach, dwSize, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;
        }
        else    // nCmdID == CMDID_SCRIPTSITE_SID
        {
            hr = THR(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0));
            if (hr)
                goto Cleanup;

            memset(abSID, 0, cbSID);

            hr = THR(pSecMgr->GetSecurityId(
                    ach, 
                    abSID, 
                    &cbSID,
                    0));
            if (hr)
                goto Cleanup;

            hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;

            memcpy(V_BSTR(pvarargOut), abSID, MAX_SIZE_SECURITY_ID);
        }

        break;

    case CMDID_SCRIPTSITE_HTMLDLGTRUST:
        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = TRUE;      // Trusted
            break;
        }

    case CMDID_SCRIPTSITE_SECSTATE:
        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = (long) 2;    // SSL_SECURITY_SECURE;
            break;
        }

    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
        break;

    }

Cleanup:
    ReleaseInterface(pDisp);
    ReleaseInterface(pSecMgr);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padurl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padurl.cxx
//
//  Contents:   Ask the user for a URL.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

static INT_PTR CALLBACK
GetURLProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PADTHREADSTATE * pts = GetThreadState();

    switch (msg)
    {
    case WM_INITDIALOG:
        if (pts->achURL[0] == 0)
        {
#if !defined(WINCE)
            if (!GetEnvironmentVariable(_T("PAD_DEFAULTURL"), pts->achURL, INTERNET_MAX_URL_LENGTH))
            {
#endif
#if DBG==1
                _tcscpy(pts->achURL, TEXT("http://trident"));
#else
                _tcscpy(pts->achURL, TEXT("http://www.microsoft.com"));
#endif
#if !defined(WINCE)
            }
#endif
        }
        SetDlgItemText(hwnd, IDI_ADDRESS, pts->achURL);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDOK:
                GetDlgItemText(hwnd, IDI_ADDRESS, pts->achURL, ARRAY_SIZE(pts->achURL));
                // Fall through.
            case IDCANCEL:
                EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                return TRUE;
        }
        // Fall through

    default:
        return FALSE;
    }
}

// el cheapo file path recognition logic copied from shdocvw
BOOL PathIsFilePath(TCHAR *pchPath)
{
    if (pchPath[0]==_T('\\') || pchPath[0] && pchPath[1]==_T(':'))
        return TRUE;

    if (_tcsnipre(_T("file:"), 5, pchPath, -1))
        return TRUE;

    return FALSE;
}

BOOL
GetURL(HWND hwnd, TCHAR *pchURL, int cch)
{
    if (DialogBoxParam(
        g_hInstResource,
        MAKEINTRESOURCE(IDR_OPEN_URL),
        hwnd,
        &GetURLProc,
        NULL) == IDOK)
    {
        PADTHREADSTATE * pts = GetThreadState();
        ULONG cchUlong = cch;

        if (!PathIsFilePath(pts->achURL))
            return InternetCanonicalizeUrl(pts->achURL, pchURL, &cchUlong, 0);

        if (_tcsnipre(_T("file:"), 5, pts->achURL, -1))
        {
            TCHAR *pch = pts->achURL+5;

            if (_tcsnipre(_T("//"), 2, pch, -1))
                pch += 2;

            _tcsncpy(pchURL, pch, cch);
        }
        else
            _tcsncpy(pchURL, pts->achURL, cch);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\padws.cxx ===
//+------------------------------------------------------------------------
//  
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       Working set test infrastructure
//  
//-------------------------------------------------------------------------

#include "padhead.hxx"

HRESULT CPadDoc::WsClear()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(DbgExWsClear(hProcess));
}

HRESULT CPadDoc::WsTakeSnapshot()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

	RRETURN(DbgExWsTakeSnapshot(hProcess));
}

HRESULT CPadDoc::get_WsModule(long row, BSTR *pbstrModule)
{
    *pbstrModule = SysAllocString(DbgExWsGetModule(row));
    return S_OK;
}

HRESULT CPadDoc::get_WsSection(long row, BSTR *pbstrSection)
{
    *pbstrSection = SysAllocString(DbgExWsGetSection(row));
    return S_OK;
}

HRESULT CPadDoc::get_WsSize(long row, long *plWsSize)
{
    *plWsSize = DbgExWsSize(row);
    return S_OK;
}

HRESULT CPadDoc::get_WsCount(long *plCount)
{
    *plCount = DbgExWsCount();
    return S_OK;
}

HRESULT CPadDoc::get_WsTotal(long *plTotal)
{
    *plTotal = DbgExWsTotal();
    return S_OK;
}

HRESULT CPadDoc::WsStartDelta()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(DbgExWsStartDelta(hProcess));
}

HRESULT CPadDoc::WsEndDelta(long *pnPageFaults)
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    *pnPageFaults = DbgExWsEndDelta(hProcess);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\pad_wrap.c ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:   Wrap the midl generated pad_i.c so we don't get lots of 
//          level 4 warnings from the system headers
//
//-------------------------------------------------------------------------

#define WIN32_LEAN_AND_MEAN
#pragma warning(disable:4201)   // nameless struct/union

#include <pad_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\tvdlg.h ===
////////////////////////////////////////////////////////////////////////////
//
//      TVDLG.H
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////

#ifndef __TVDLG__H__
#define __TVDLG__H__


enum { iEID, iDispName, iSubfldrs, nhtProps};
static SizedSPropTagArray(nhtProps, spthtProps) =
{ nhtProps,
    {   PR_ENTRYID,
        PR_DISPLAY_NAME_A,
        PR_SUBFOLDERS
    }
};  

#define Align4(_cb) (((_cb) + 3) & ~3)

extern LPTSTR g_szNoFolderName;
extern LPSTR g_szAllStoresA;

class CTVNodeFactory;
class CChsFldDlg;


/////////////////////////////////////////////////////////////////////////
// CTVNode

class CTVNode;
typedef CTVNode * LPTVNODE;

class CTVNode
{

friend CTVNodeFactory;
friend HTREEITEM HtiFindChild(HWND hwTreeCtl, HTREEITEM hti, ULONG cb,
                LPENTRYID pbEID, CChsFldDlg *pCFDlg, LPTVNODE *ppNode);


public:
    LPTSTR GetName(void);
    HRESULT HrExpand(CChsFldDlg * pCFDlg);
    HRESULT HrGetFolder(CChsFldDlg * pCFDlg, LPMAPIFOLDER * ppfld,
                            LPMDB *ppmdb);

    void SetHandle(HTREEITEM hItem) { _htiMe = hItem;}
    void SetKidsLoaded(BOOL fLoaded) { _fKidsLoaded = fLoaded;}

    HRESULT HrNewFolder(CChsFldDlg * pCFDlg, LPTSTR szFldName);

    static LPVOID operator new( size_t cb );
    static VOID   operator delete( LPVOID pv );

    void Write(BOOL fWrite, LONG iLevel, LPBYTE * ppb);
    
    ~CTVNode();

private:
    
    //can only be created in CTVNodeFactory::HrCreateNode
    CTVNode(LPSPropValue pvals, ULONG cprops, LPMDB pmdb);

    HRESULT HrOpenMDB(CChsFldDlg * pCFDlg);
    HRESULT HrOpenFolder(CChsFldDlg * pCFDlg);
    
    HTREEITEM       _htiMe;
    LPSPropValue    _pval;
    BOOL            _fKidsLoaded;
    LPMAPIFOLDER    _pfld;
    CTVNode         *_pNext;
    LPMDB           _pmdb;
};


////////////////////////////////////////////////////////////////////////
// CTVNodeFactory

class CTVNodeFactory
{
public:
    HRESULT HrCreateNode(LPSPropValue pval, ULONG cVals, LPMDB pmdb,
                            LPTVNODE * pptvnode);

    CTVNodeFactory();
    ~CTVNodeFactory();

private:
    void Insert(CTVNode * ptvnode);

    LPTVNODE    _pHead;
};


////////////////////////////////////////////////////////////////////////
// CChsFldDlg

class CChsFldDlg
{
public:
    HRESULT HrPick(LPCTSTR lpTemplateName, HWND hWnd,
                DLGPROC pfnDlgProc, LPMAPIFOLDER * ppfld, LPMDB *ppmdb);
    HRESULT HrInitTree(HWND hDlg, HWND hwTreeCtl);
    HRESULT HrLoadRoots(void);
    HRESULT HrInsertRoot(LPSPropValue pval);
    BOOL    IsTreeRoot(HTREEITEM hti) { return (hti == _hiRoot); }

    int     IndAllStores(void)  { return _iIconAllStores; }
    int     IndRootFld(void)    { return _iIconRootFld; }
    int     IndOpenFld(void)    { return _iIconOpenFld; }
    int     IndClsdFld(void)    { return _iIconClsdFld; }
    HWND    hwDialog(void)      { return _hDlg; }
    HWND    hwTreeCtl(void)     { return _hwTreeCtl; }

    LPMAPISESSION   Session(void) { return _pses; }

    
    HINSTANCE hInst(void)   { return _hInst; }

    HRESULT HrCreateNode(LPSPropValue pval, ULONG cvals, LPMDB pmdb,
                            LPTVNODE * ppNode)
        { return _NodeFactory.HrCreateNode(pval, cvals, pmdb, ppNode);}

    void    SetFolder(LPMAPIFOLDER plfd, LPMDB pmdb);
    void    SetError(HRESULT hr)    { _hr = hr;}

    HRESULT HrSaveTreeState(void);
    HRESULT HrRestoreTreeState(void);

    CChsFldDlg(LPMAPISESSION pses, HINSTANCE hInst, ULONG * pcb, LPBYTE * ppb);
    ~CChsFldDlg();

private:

    HRESULT HrSaveTreeStateEx(BOOL fWrite, ULONG * pcb, LPBYTE * ppb);
    HRESULT HrRestoreTreeState(ULONG cb, LPBYTE pb);
    
    LPMAPISESSION   _pses;
    LPMAPIFOLDER    _pfld;
    LPMDB           _pmdb;
    HRESULT         _hr;
    HTREEITEM       _hiRoot;
    HINSTANCE       _hInst;
    HWND            _hDlg;
    HWND            _hwTreeCtl;

    HIMAGELIST      _hIml;
    int             _iIconAllStores;
    int             _iIconRootFld;
    int             _iIconOpenFld;
    int             _iIconClsdFld;
    
    ULONG           *_pcbState;
    LPBYTE          *_ppbState;
    
    CTVNodeFactory  _NodeFactory;
    
};


HTREEITEM AddOneItem( HTREEITEM hParent, HTREEITEM hInsAfter, 
    int iImage, int iImageSel, HWND hwndTree, LPTVNODE pNode, int cKids);


#endif //__TVDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\scripter.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       script.cxx
//
//  Contents:   Implementation of script recorder
//
//  History:    03-22-99 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "padhead.hxx"

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

//
// Externs
//
MtDefine(CScriptRecorder, EditCommand, "CScriptRecorder");
MtDefine(CDummyScriptRecorder, EditCommand, "CDummyScriptRecorder");

extern HINSTANCE     g_hInstCore;         // Instance of dll

////////////////////////////////////////////////////////////////////////////////
// CScriptRecorder
////////////////////////////////////////////////////////////////////////////////

CScriptRecorder::CScriptRecorder(CPadDoc *pPadDoc)
{
    _pPadDoc = pPadDoc;
    _hStream = NULL;
}

CScriptRecorder::~CScriptRecorder()
{
    IGNORE_HR( Flush() );
    Output(_T("}\r\n"));
    CloseHandle(_hStream);
}

HRESULT
CScriptRecorder::Init(BSTR bstrFileName)
{
    HRESULT     hr;
    CStr        strPreScript;
    HRSRC       hRsrc;
    HGLOBAL     hGlob;
    char        *szBase;
    DWORD       nbw = 0;
    INT         rc;

    hRsrc = FindResource(g_hInstCore, L"base.js", RT_HTML);
    if (!hRsrc)
        return E_UNEXPECTED;

    hGlob = LoadResource(g_hInstCore, hRsrc);
    szBase = (char*)LockResource(hGlob);
    if (szBase == NULL)
        return E_UNEXPECTED;
    
    _hStream = CreateFile(
            _T("c:\\ee.js"),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (!_hStream)
        return E_FAIL;

    rc = ::WriteFile(_hStream, szBase, ::SizeofResource(g_hInstCore, hRsrc), &nbw, NULL);
    if (!rc)
        return E_UNEXPECTED;    

    IFC( strPreScript.Append(_T("var g_fileName = \'")) );
    IFC( GetPadDoc()->AppendQuotedString(strPreScript, bstrFileName, SysStringLen(bstrFileName)) );
    IFC( strPreScript.Append(_T("\';\r\n\r\n")) );
    IFC( strPreScript.Append(_T("function Test()\r\n{\r\n")) );

    IFC( Output(strPreScript) );
    
 Cleanup:        
    RRETURN(hr);
}


HRESULT
CScriptRecorder::WriteFile(TCHAR *szBuffer, LONG cLength)
{
    const LONG  cBufferSize = 1024;
    char        szAnsiBuffer[cBufferSize+1]; 
    LONG        cchLen;
    DWORD       nbw = 0;
    INT         rc = 0;     

    if (cLength < cBufferSize)
    {
        cchLen = WideCharToMultiByte(
            CP_ACP, 0, szBuffer, cLength,
            szAnsiBuffer, ARRAY_SIZE(szAnsiBuffer), NULL, NULL );

        szAnsiBuffer[cchLen] = 0;

        rc = ::WriteFile(_hStream, szAnsiBuffer, cchLen, &nbw, NULL);
    }
    else
    {
        char *szLargeBuffer = new char[cLength + 1];

        cchLen = WideCharToMultiByte(
            CP_ACP, 0, szBuffer, cLength,
            szLargeBuffer, cLength, NULL, NULL );

        szLargeBuffer[cchLen] = 0;

        rc = ::WriteFile(_hStream, szLargeBuffer, cchLen, &nbw, NULL);

        delete [] szLargeBuffer;
    }

    if (!rc)
        return E_UNEXPECTED;

    return S_OK; // TODO: return error for WriteFile status
}

HRESULT 
CScriptRecorder::OutputLinePrefix()
{
    HRESULT hr;

    hr = THR(Output(_T("    ")));

    RRETURN(hr);
}

HRESULT
CScriptRecorder::Output(CStr &cstr)
{
    HRESULT hr;

    hr = THR(WriteFile(cstr, cstr.Length()));

    RRETURN(hr);
}

HRESULT
CScriptRecorder::Output(TCHAR *szOutput)
{
    HRESULT hr;

    hr = THR(WriteFile(szOutput, _tcslen(szOutput)));

    RRETURN(hr);
}

HRESULT 
CScriptRecorder::Flush(BOOL fDoEvents)
{
    HRESULT hr = S_OK;
    
    if (_strKeyStrokes.Length() > 0)
    {
        IFC( OutputLinePrefix() );
        
        if (fDoEvents)        
        {
            IFC( Output(_T("SendKeysDE(\"")) )
        }
        else
        {
            IFC( Output(_T("SendKeys(\"")) );
        }
        
        IFC( Output(_strKeyStrokes) );
        IFC( Output(_T("\");\r\n")) );
        
        _strKeyStrokes.Free();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT 
CScriptRecorder::RegisterChar(DWORD dwKey, KEYSTATE ks)
{    
    HRESULT     hr = S_OK;
    const UINT  cMaxSendKeyLen = 50;
    CStr        strKeyStroke;
    
    // Add keystroke
    if (dwKey > ' ' && dwKey < 128)
    {
        TCHAR szBuf[2];
        
        // Wrapping of sendkey statements to make the generated script more readable.
        if (_strKeyStrokes.Length() > cMaxSendKeyLen)
        {
            Flush(FALSE /* Do Events */);
        }

        // TODO: fix range above [ashrafm]
        szBuf[0] = dwKey;
        szBuf[1] = 0;

        IFC( GetPadDoc()->AppendQuotedString(_strKeyStrokes, szBuf, 1) );
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT 
CScriptRecorder::RegisterKeyDown(DWORD dwKey, KEYSTATE ks)
{    
    HRESULT     hr = S_OK;
    const UINT  cMaxSendKeyLen = 50;
    CStr        strKeyStroke;

    // Add keystroke
    switch (dwKey)
    {
        case VK_RETURN:
            IFC( strKeyStroke.Append(_T("{enter}")) );
            break;

        case VK_BACK:
            IFC( strKeyStroke.Append(_T("{bs}")) );
            break;

        case VK_SPACE:
            IFC( strKeyStroke.Append(_T(" ")) );
            break;

        case VK_TAB:
            IFC( strKeyStroke.Append(_T("{tab}")) );
            break;
    
        case VK_LEFT:
            IFC( strKeyStroke.Append(_T("{left}")) );
            break;

        case VK_RIGHT:
            IFC( strKeyStroke.Append(_T("{right}")) );
            break;

        case VK_UP:
            IFC( strKeyStroke.Append(_T("{up}")) );
            break;

        case VK_DOWN:
            IFC( strKeyStroke.Append(_T("{down}")) );
            break;
        
        case VK_HOME:
            IFC( strKeyStroke.Append(_T("{home}")) );
            break;

        case VK_END:
            IFC( strKeyStroke.Append(_T("{end}")) );
            break;

        case VK_ESCAPE:
            IFC( strKeyStroke.Append(_T("{esc}")) );
            break;            

        case VK_NEXT:
            IFC( strKeyStroke.Append(_T("{pgdn}")) );
            break;            

        case VK_PRIOR:
            IFC( strKeyStroke.Append(_T("{pgup}")) );
            break;            
    }

    if (strKeyStroke.Length() > 0)
    {
        // Wrapping of sendkey statements to make the generated script more readable.
        if (_strKeyStrokes.Length() > cMaxSendKeyLen)
        {
            Flush(FALSE /* Do Events */);
        }

        // Add modifiers
        if (ks & KEYSTATE_Ctrl)
            IFC( _strKeyStrokes.Append(_T("{ctrl}+")) );

        if (ks & KEYSTATE_Shift)
            IFC( _strKeyStrokes.Append(_T("{shift}+")) );

        IFC( GetPadDoc()->AppendQuotedString(_strKeyStrokes, strKeyStroke, strKeyStroke.Length()) );
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CScriptRecorder::ShouldQuote(VARENUM vt)
{
    switch (vt)
    {
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_I8:
        case VT_UI8:
        case VT_INT:
        case VT_UINT:
            return FALSE;
    }

    return TRUE;
}
    
HRESULT 
CScriptRecorder::RegisterCommand(DWORD    cmdId,     
                                 DWORD    nCmdexecopt,
                                 VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;
    VARIANT varCmdId;
    VARIANT varCmdIdBSTR;
    VARIANT varParam;
    CStr    strParam;

    // Check for some commands that should not be scripted
    switch (cmdId)
    {
        case IDM_EDITSOURCE:
        case IDM_BROWSEMODE:
        case IDM_EDITMODE:
        case IDM_VIEWSOURCE:
        case IDM_GETBLOCKFMTS:
        case IDM_PARSECOMPLETE:
        case IDM_HTMLEDITMODE:
        case IDM_CONTEXT:
        case IDM_HWND:
        case IDM_SIZETOCONTROLWIDTH:
        case IDM_SIZETOCONTROLHEIGHT:
            goto Cleanup;        
            break;

        case IDM_HYPERLINK:
        case IDM_IMAGE:
        case IDM_FONT:
            // don't script dialog commands
            if (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER)
                goto Cleanup;
            break;
    };

    

    VariantInit(&varCmdId);
    VariantInit(&varCmdIdBSTR);
    VariantInit(&varParam);
    
    IFC( Flush() );

    // Change cmdId to appropriate string
    V_VT(&varCmdId) = VT_I4;
    V_I4(&varCmdId) = cmdId;
    IFC( VariantChangeType(&varCmdIdBSTR, &varCmdId, 0, VT_BSTR) );

    // Change param type to string and output as such
    if (pvarargIn)
    {
        IFC( VariantChangeType(&varParam, pvarargIn, 0, VT_BSTR) );
        IFC( GetPadDoc()->AppendQuotedString(strParam, V_BSTR(&varParam), SysStringLen(V_BSTR(&varParam))) );
    }
    else
    {
        IFC( strParam.Append(L"null") );
    }

    // Output exec command
    IFC( OutputLinePrefix() );
    IFC( Output(L"ExecuteCommand(") );
    IFC( Output(V_BSTR(&varCmdIdBSTR)) );
    IFC( Output(L", ") );
    
    if (pvarargIn && ShouldQuote(VARENUM(V_VT(pvarargIn))))
        IFC( Output(L"\"") );
        
    IFC( Output(strParam) );
    
    if (pvarargIn && ShouldQuote(VARENUM(V_VT(pvarargIn))))
        IFC( Output(L"\"") );
        
    IFC( Output(L");\r\n") );
    
Cleanup:
    VariantClear(&varCmdId);
    VariantClear(&varParam);

    RRETURN(hr);
}
                            
HRESULT
CScriptRecorder::VerifyHTML(TestScope ts)
{
    HRESULT         hr;
    CStr            str;
    BSTR            bstrElement      = NULL;
    BSTR            bstrHTML         = NULL;
    IHTMLDocument2  *pDoc            = NULL;
    IHTMLElement    *pElement        = NULL;
    IDispatch       *pdispDoc        = NULL;
    IMarkupServices *pMarkupServices = NULL;

    IFC( GetPadDoc()->GetMarkupServices(&pMarkupServices) );

    //
    // Get test element
    //
    
    switch (ts)
    {
        case TS_Body:
        {
            IFC( GetPadDoc()->get_Document(&pdispDoc) );
            IFC( pdispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
            IFC( pDoc->get_body(&pElement) );            
            bstrElement = SysAllocString(L"document.body");
            break;
        }
            
        case TS_CurrentElement:
        {
            ELEMENT_TAG_ID tagId;
            
            IFC( GetPadDoc()->CurrentBlockElement(pMarkupServices, &pElement) );            
            if (pElement == NULL)
                return E_FAIL;

            IFC( pMarkupServices->GetElementTagId(pElement, &tagId) );
            if (tagId == TAGID_BODY)
                return E_FAIL;
            
            bstrElement = SysAllocString(L"CurrentBlockElement()");
            break;
        }

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    IFC( GetPadDoc()->InnerHTML(pMarkupServices, pElement, &bstrHTML) );
    
    //
    // Generate HTML
    //
    IFC( Flush() );

    IFC( OutputLinePrefix() );
    
    IFC( Output(L"VerifyHTML(InnerHTML(") );
    IFC( Output(bstrElement) );
    IFC( Output(L"), \"") );
    
    IFC( GetPadDoc()->AppendQuotedString(str, bstrHTML, SysStringLen(bstrHTML)) );
    IFC( Output(str) );

    IFC( Output(L"\");\r\n") );

Cleanup:
    SysFreeString(bstrElement);
    SysFreeString(bstrHTML);
    ReleaseInterface(pDoc);
    ReleaseInterface(pElement);
    ReleaseInterface(pdispDoc);
    ReleaseInterface(pMarkupServices);
    
    RRETURN(hr);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\privacy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       privacy.cxx
//
//  Contents:   Definition of classes to expose privacy list to pad
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_PRIVACY_H_
#define X_PRIVACY_H_
#include "privacy.h"
#endif

#undef ASSERT

CPadEnumPrivacyRecords::CPadEnumPrivacyRecords(IEnumPrivacyRecords * pIEPR)
    :_ulRefs(1)
{
    Assert(pIEPR);
    _pIEPR = pIEPR;
    _pIEPR->AddRef();
}

CPadEnumPrivacyRecords::~CPadEnumPrivacyRecords()
{
    _pIEPR->Release();
}

HRESULT
CPadEnumPrivacyRecords::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG
CPadEnumPrivacyRecords::AddRef()
{
    return ++_ulRefs;
}

ULONG 
CPadEnumPrivacyRecords::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }
    
    return _ulRefs;
}

HRESULT
CPadEnumPrivacyRecords::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return NOERROR;
}
HRESULT
CPadEnumPrivacyRecords::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
    *ppTInfo = NULL;
    return ResultFromScode(E_NOTIMPL);
}

#define   DISPID_CPrivacyList_size                           1000
#define   DISPID_CPrivacyList_next                           1001
#define   DISPID_CPrivacyList_reset                          1002
#define   DISPID_CPrivacyList_privacyimpacted                1003
#define   DISPID_CPrivacyList_url                            1004
#define   DISPID_CPrivacyList_cookiestate                    1005
#define   DISPID_CPrivacyList_policyref                      1006
#define   DISPID_CPrivacyList_privacyflags                   1007

HRESULT
CPadEnumPrivacyRecords::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    
    for (; cNames > 0; --cNames)
    {
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("size")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_size;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("next")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_next;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("reset")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_reset;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("privacyimpacted")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_privacyimpacted;
            hr = NO_ERROR;
        }
        else
        {
            hr = ResultFromScode(DISP_E_UNKNOWNNAME);
            break;
        }
    }

    RRETURN(hr);
}
HRESULT
CPadEnumPrivacyRecords::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT             hr          = ResultFromScode(DISPID_UNKNOWN);
    CPadPrivacyRecord * pPPR        = NULL;    

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    if (NULL == pVarResult)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    VariantInit(pVarResult);
    
    switch(dispIdMember)
    {
    case DISPID_CPrivacyList_size:
        ULONG ulSize;
        hr = _pIEPR->GetSize(&ulSize);
        if (hr)
            RRETURN(hr);
        V_VT(pVarResult) = VT_I4;
        V_I4(pVarResult) = (int)ulSize;
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_next:
        {
        BSTR  bstrUrl     = NULL;     
        LONG  cookieState = 0;
        BSTR  bstrPolicyRef = NULL;
        DWORD dwFlags = 0;

        hr = _pIEPR->Next(&bstrUrl, &bstrPolicyRef, &cookieState, &dwFlags);
        if (hr)
            RRETURN(hr);        
        pPPR = new CPadPrivacyRecord(bstrUrl, cookieState, bstrPolicyRef, dwFlags);
        if (!pPPR)
        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
        V_VT(pVarResult) = VT_DISPATCH;
        V_DISPATCH(pVarResult) = (IDispatch*)pPPR;
        hr = NOERROR;
        }
        break;

    case DISPID_CPrivacyList_reset:
        V_VT(pVarResult) = VT_EMPTY;
        _pIEPR->Reset();
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_privacyimpacted:
        BOOL bImpacted;
        hr = _pIEPR->GetPrivacyImpacted(&bImpacted);
        if (hr)
            RRETURN(hr);
        V_VT(pVarResult) = VT_BOOL;
        V_BOOL(pVarResult) = (int)bImpacted;
        hr = NOERROR;
        break;

    }

    return hr;
}

HRESULT
CPadPrivacyRecord::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG
CPadPrivacyRecord::AddRef(void)
{
    return ++_ulRefs;
}

ULONG
CPadPrivacyRecord::Release(void)
{
    --_ulRefs;
    if (!_ulRefs)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

HRESULT
CPadPrivacyRecord::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return NOERROR;
}
 
HRESULT
CPadPrivacyRecord::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
    *ppTInfo = NULL;
    return ResultFromScode(E_NOTIMPL);
}

HRESULT
CPadPrivacyRecord::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    
    for (; cNames > 0; --cNames)
    {
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("url")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_url;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("cookiestate")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_cookiestate;
            hr = NO_ERROR;
        }
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("policyref")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_policyref;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("privacyflags")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_privacyflags;
            hr = NO_ERROR;
        }
        else
        {
            hr = ResultFromScode(DISP_E_UNKNOWNNAME);
            break;
        }
    }

    RRETURN(hr);
}

HRESULT
CPadPrivacyRecord::Invoke(DISPID dispIdMember, 
                          REFIID riid, 
                          LCID lcid, 
                          WORD wFlags, 
                          DISPPARAMS *pDispParams, 
                          VARIANT *pVarResult, 
                          EXCEPINFO *pExcepInfo, 
                          UINT *puArgErr)
{
    HRESULT hr            = ResultFromScode(DISPID_UNKNOWN);
    BSTR    bstrUrl       = NULL;
    BSTR    bstrPolicyRef = NULL;
    
    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    if (NULL == pVarResult)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    VariantInit(pVarResult);
    
    switch(dispIdMember)
    {
    case DISPID_CPrivacyList_url:
        hr = FormsAllocString((LPCWSTR)_bstrUrl, &bstrUrl);        
        if (hr)
            break;
        V_VT(pVarResult) = VT_BSTR;
        V_BSTR(pVarResult) = bstrUrl;
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_cookiestate:
        V_VT(pVarResult) = VT_I4;
        V_I4(pVarResult) = (int)_cookieState;
        hr = NOERROR;
        break;

     case DISPID_CPrivacyList_policyref:
        hr = FormsAllocString((LPCWSTR)_bstrPolicyRef, &bstrPolicyRef);
        if (hr)
            break;
        V_VT(pVarResult) = VT_BSTR;
        V_BSTR(pVarResult) = bstrPolicyRef;
        hr = NOERROR;
        break;

     case DISPID_CPrivacyList_privacyflags:
        V_VT(pVarResult) = VT_UI4;
        V_UI4(pVarResult) = (int)_dwFlags;
        hr = NOERROR;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>         // for UINT_MAX below
#endif

//+---------------------------------------------------------------
//
//  Class:      CEnumXXX
//
//  Synopsis:   Base class for enumerators.
//
//----------------------------------------------------------------

class CEnumXXX : public IUnknown
{
public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(CEnumXXX);

    //*** IEnumX methods ***
    STDMETHOD(Next) (ULONG c, void * pv, ULONG * pcFetched);
    STDMETHOD(Skip) (ULONG c);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (void ** ppEnumXXX) = 0;

protected:
    CEnumXXX(REFIID iid, int c, int i);
    virtual ~CEnumXXX();

    virtual HRESULT FetchElements(int c, void *pv) = 0;

    REFIID _iid;
    int  _c;
    int  _i;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::CEnumXXX
//
//  Synopsis:   Constructor.
//
//  Arguments:  iid     iid for this enumerator.
//              c       count of elements
//              i       starting index
//
//----------------------------------------------------------------

CEnumXXX::CEnumXXX(REFIID iid, int c, int i)
    : _iid(iid)
{
    _c = c;
    _i = i;
    _ulRefs = 1;
    IncrementObjectCount();
}

CEnumXXX::~CEnumXXX()
{
    DecrementObjectCount();
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::QueryInterface, IUnknown
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::QueryInterface(REFIID iid, void ** ppvObj)
{
    if (IsEqualIID(iid,IID_IUnknown) || IsEqualIID(iid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Next(ULONG c, void *pv, ULONG *pcFetched)
{
    int   cFetched;
    HRESULT hr;

    cFetched = c;
    if (cFetched > _c - _i)
        cFetched = _c - _i;

    Assert(cFetched >= 0);

    hr = THR(FetchElements(cFetched, pv));
    if (hr)
        goto Error;

    _i += cFetched;
    hr = cFetched == (int)c ? S_OK : S_FALSE;

Cleanup:
    if (pcFetched)
    {
        *pcFetched = cFetched;
    }

    RRETURN1(hr, S_FALSE);

Error:
    cFetched = 0;
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Skip(ULONG c)
{
    _i += c;
    if (_i > _c)
        _i = c;

    return _i == _c ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Reset()
{
    _i = 0;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

class CEnumOLEVERB: public CEnumXXX
{
    friend HRESULT CreateOLEVERBEnum(OLEVERB const *, ULONG, LPENUMOLEVERB FAR*);

public:
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

private:
    CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iVerb);

    OLEVERB const * _pOleVerb;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumOLEVERB::CEnumOLEVERB, private
//
//  Synopsis:   Constructor for CEnumOLEVERB objects
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [iOleVerb] -- starting index for enumerator.
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

inline
CEnumOLEVERB::CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iOleVerb)
    : CEnumXXX(IID_IEnumOLEVERB, cOleVerb, iOleVerb)
{
    _pOleVerb = pOleVerb;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumOLEVERB::FetchElements(int c, void *pv)
{
    HRESULT   hr = S_OK;
    int       i;
    LPOLEVERB pOleVerb = (LPOLEVERB)pv;

    for (i = 0; i < c; i++)
    {
        pOleVerb[i] = _pOleVerb[i + _i];
        if (pOleVerb[i].lpszVerbName)
        {
            hr = TaskAllocString(pOleVerb[i].lpszVerbName,
                    &pOleVerb[i].lpszVerbName);
            if (hr)
                goto Error;
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    while (--i >= 0)
    {
        TaskFreeString(pOleVerb[i].lpszVerbName);
    }
    memset(pv, 0, sizeof(OLEVERB) * c);
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumOLEVERB::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumOLEVERB(_pOleVerb, _c, _i);
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [ppEnum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(OLEVERB const * pOleVerb, ULONG cOleVerb, LPENUMOLEVERB * ppEnum)
{
    *ppEnum = (LPENUMOLEVERB)new CEnumOLEVERB(pOleVerb, cOleVerb, 0);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

class CEnumFORMATETC: public CEnumXXX
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*, BOOL fDeleteOnExit);
public:

    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

    CEnumFORMATETC  *_pClonedFrom;

protected:
    virtual ~CEnumFORMATETC();

private:
    CEnumFORMATETC(LPFORMATETC pFmt, int cFmt, int iFmt, BOOL fDeleteOnExit);

    LPFORMATETC     _pFmtEtc;
    BOOL            _fDeleteOnExit;

};

//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::CEnumFORMATETC, private
//
//  Synopsis:   Constructor for CEnumFORMATETC objects
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [iFmtEtc] -- starting position for enumerator.
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

inline
CEnumFORMATETC::CEnumFORMATETC(LPFORMATETC pFmtEtc, int cFmtEtc, int iFmtEtc, BOOL fDeleteOnExit)
    : CEnumXXX(IID_IEnumFORMATETC, cFmtEtc, iFmtEtc)
{
    _pFmtEtc = pFmtEtc;
    _fDeleteOnExit = fDeleteOnExit;
    _pClonedFrom = 0;
}

CEnumFORMATETC::~CEnumFORMATETC()
{
    if (_fDeleteOnExit)
    {
        delete [] _pFmtEtc;
    }
    ReleaseInterface(_pClonedFrom);
}

//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumFORMATETC::FetchElements(int c, void *pv)
{
    HRESULT     hr = S_OK;
    int         i;
    LPFORMATETC pFmtEtc = (LPFORMATETC)pv;

    for (i = 0; i < c; i++)
    {
        pFmtEtc[i] = _pFmtEtc[i + _i];
        if (pFmtEtc[i].ptd)
        {
            pFmtEtc[i].ptd = (DVTARGETDEVICE *)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));
            if (!pFmtEtc[i].ptd)
                goto MemoryError;
            *(pFmtEtc[i].ptd) = *(_pFmtEtc[i + _i].ptd);
        }
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    while (--i >= 0)
    {
        CoTaskMemFree(pFmtEtc[i].ptd);
    }
    memset(pv, 0, sizeof(FORMATETC) * c);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumFORMATETC::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumFORMATETC(_pFmtEtc, _c, _i, FALSE);
    if (*ppEnumXXX && _fDeleteOnExit)
    {
        ((CEnumFORMATETC*)*ppEnumXXX)->_pClonedFrom = this;
        AddRef();
    }
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFmtEtc, ULONG cFmtEtc, LPENUMFORMATETC * ppEnum, BOOL fDeleteOnExit)
{
    *ppEnum = (IEnumFORMATETC *)new CEnumFORMATETC(pFmtEtc, cFmtEtc, 0, fDeleteOnExit);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}


#if 0   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;

    TraceTag((tagStdEnum, "StdStaticEnum constructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    TraceTag((tagStdEnum, "StdStaticEnum destructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\tvstack.h ===
///////////////////////////////////////////////////////////////////////
//
//  TVSTACK.H
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
///////////////////////////////////////////////////////////////////////


#define StackSize 64

class CTIStack
{

public:
    CTIStack()  { m_ptos = m_ahti; m_pMax = m_ahti + StackSize - 1;}
    ~CTIStack() {};

    BOOL Push(HTREEITEM hti);
    HTREEITEM Pop(void);
    BOOL IsEmpty(void);

private:
    HTREEITEM m_ahti[StackSize];
    HTREEITEM *m_ptos;
    HTREEITEM *m_pMax;
};

inline BOOL CTIStack::Push(HTREEITEM hti)
{
    Assert(m_ptos >= m_ahti);
    Assert(m_ptos <= m_pMax);

    if(m_ptos == m_pMax)
        return FALSE;

    *m_ptos++ = hti;
    return TRUE;
}

inline BOOL CTIStack::IsEmpty(void)
{
    Assert(m_ptos >= m_ahti);
    Assert(m_ptos <= m_pMax);
    
    return (m_ptos == m_ahti);
}

inline HTREEITEM CTIStack::Pop(void)
{
    Assert(m_ptos > m_ahti);
    Assert(m_ptos <= m_pMax);

    if(m_ptos == m_ahti)
        return NULL;
        
    return *--m_ptos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\exe\padexe.cxx ===
#include <windows.h>
#include <w4warn.h>
#include <mshtmdbg.h>

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

void NonCrtStrCat(LPSTR pszDst, LPCSTR pszSrc)
{
    while (*pszDst)
        ++pszDst;

    while (*pszSrc)
        *pszDst++ = *pszSrc++;

    *pszDst = 0;
}

class CPadMallocSpy : public IMallocSpy
{
public:

    CPadMallocSpy() { _pSpyFwd = 0; }
    void * __cdecl operator new(size_t cb) { return(LocalAlloc(LPTR, cb)); } \
    void __cdecl operator delete(void * pv) { LocalFree(pv); }

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IMallocSpy methods

    STDMETHOD_(SIZE_T, PreAlloc)(SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc)(void *pvActual);
    STDMETHOD_(void *, PreFree)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(void,   PostFree)(BOOL fSpyed);
    STDMETHOD_(SIZE_T, PreRealloc)(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc)(void *pvActual, BOOL fSpyed);
    STDMETHOD_(void *, PreGetSize)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize)(SIZE_T cbActual, BOOL fSpyed);
    STDMETHOD_(void *, PreDidAlloc)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(BOOL,   PostDidAlloc)(void *pvRequest, BOOL fSpyed, BOOL fActual);
    STDMETHOD_(void,   PreHeapMinimize)();
    STDMETHOD_(void,   PostHeapMinimize)();

    IMallocSpy *    _pSpyFwd;
};

STDMETHODIMP
CPadMallocSpy::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IMallocSpy)
    {
        *ppv = (IMallocSpy *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CPadMallocSpy::AddRef()
{
    return 1;
}

STDMETHODIMP_(ULONG)
CPadMallocSpy::Release()
{
    return 1;
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreAlloc(cbRequest));
    else
        return(cbRequest);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PostAlloc(void *pvActual)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostAlloc(pvActual));
    else
        return(pvActual);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreFree(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreFree(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(void)
CPadMallocSpy::PostFree(BOOL fSpyed)
{
    if (_pSpyFwd)
        _pSpyFwd->PostFree(fSpyed);
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PreRealloc(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreRealloc(pvRequest, cbRequest, ppvActual, fSpyed));
    else
    {
        *ppvActual = pvRequest;
        return(cbRequest);
    }
}

STDMETHODIMP_(void *)
CPadMallocSpy::PostRealloc(void *pvActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostRealloc(pvActual, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreGetSize(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreGetSize(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostGetSize(cbActual, fSpyed));
    else
        return(0);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreDidAlloc(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreDidAlloc(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(BOOL)
CPadMallocSpy::PostDidAlloc(void *pvRequest, BOOL fSpyed, BOOL fActual)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostDidAlloc(pvRequest, fSpyed, fActual));
    else
        return(FALSE);
}

STDMETHODIMP_(void)
CPadMallocSpy::PreHeapMinimize()
{
}

STDMETHODIMP_(void)
CPadMallocSpy::PostHeapMinimize()
{
}

typedef int (WINAPI * PFNPADMAIN)(int argc, char ** argv, IMallocSpy * pSpy);
typedef DWORD (WINAPI * PFNDBGEXGETVERSION)();
typedef TRACETAG (WINAPI * PFNTAGREGISTEROTHER)(char * szOwner, char * szDesc, BOOL fEnabled);
typedef void (WINAPI * PFNDBGCOMEMORYTRACKDISABLE)(BOOL fDisable);
typedef void * (WINAPI * PFNDBGGETMALLOCSPY)();
typedef void (WINAPI * PFNRESTOREDEFAULTDEBUGSTATE)();
typedef BOOL (WINAPI * PFNISTAGENABLED)(TRACETAG tag);
typedef BOOL (WINAPI * PFNASSERTIMPL)(char const * szFile, int iLine, char const * szMessage);
typedef BOOL (WINAPI * PFNENUMPROCESSMODULES)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded);
typedef DWORD (WINAPI * PFNGETMODULEBASENAMEA)(HANDLE hProcess, HMODULE hModule, LPSTR lpBaseName, DWORD nSize);

extern "C"
void WINAPI mainCRTStartup(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    CPadMallocSpy *             g_pSpy = new CPadMallocSpy;
    HINSTANCE                   hInstPSAPI  = NULL;
    PFNDBGEXGETVERSION          pfnDbgExGetVersion = NULL;
    PFNTAGREGISTEROTHER         pfnTagRegisterOther = NULL;
    PFNDBGCOMEMORYTRACKDISABLE  pfnDbgCoMemoryTrackDisable = NULL;
    PFNDBGGETMALLOCSPY          pfnDbgGetMallocSpy = NULL;
    PFNRESTOREDEFAULTDEBUGSTATE pfnRestoreDefaultDebugState = NULL;
    PFNISTAGENABLED             pfnIsTagEnabled = NULL;
    PFNASSERTIMPL               pfnAssertImpl = NULL;
    PFNENUMPROCESSMODULES       pfnEnumProcessModules = NULL;
    PFNGETMODULEBASENAMEA       pfnGetModuleBaseNameA = NULL;
    TRACETAG                    tagCoTrack = 0;
    TRACETAG                    tagCoTrackDisable = 0;
    TRACETAG                    tagModuleLeaks = 0;
    HMODULE                     ahModuleBeg[64];
    UINT                        chModuleBeg = 0;
    DWORD                       cb;
    int                         argc = 0;
    char *                      argv[64] = { 0 };
    char *                      pch = GetCommandLineA();
    char                        chDelim;

    // Parse command line manually
    while (*pch)
    {
        while (*pch == ' ') ++pch;
                
                if (*pch == '\0')
                        break;

        if (*pch == '"')
        {
            chDelim = '"';
            ++pch;
        }
        else
        {
            chDelim = ' ';
        }

        if (argc == 64)
            break;

        argv[argc++] = pch;

        while (*pch != chDelim && *pch != '\0') ++pch;

        if (*pch == chDelim)
            *pch++ = '\0';
    }

    hInstPSAPI = LoadLibraryA("PSAPI.DLL");

    if (hInstPSAPI)
    {
        pfnEnumProcessModules = (PFNENUMPROCESSMODULES)GetProcAddress(hInstPSAPI, "EnumProcessModules");
        pfnGetModuleBaseNameA = (PFNGETMODULEBASENAMEA)GetProcAddress(hInstPSAPI, "GetModuleBaseNameA");

        if (pfnEnumProcessModules && pfnEnumProcessModules(GetCurrentProcess(), ahModuleBeg, sizeof(ahModuleBeg), &cb))
        {
            chModuleBeg = cb / sizeof(HMODULE);
        }
    }

    HINSTANCE hInstDbg = LoadLibraryA("mshtmdbg.dll");

    if (hInstDbg)
    {
        pfnDbgExGetVersion          = (PFNDBGEXGETVERSION)GetProcAddress(hInstDbg, "DbgExGetVersion");
        pfnTagRegisterOther         = (PFNTAGREGISTEROTHER)GetProcAddress(hInstDbg, "DbgExTagRegisterOther");
        pfnDbgCoMemoryTrackDisable  = (PFNDBGCOMEMORYTRACKDISABLE)GetProcAddress(hInstDbg, "DbgExCoMemoryTrackDisable");
        pfnDbgGetMallocSpy          = (PFNDBGGETMALLOCSPY)GetProcAddress(hInstDbg, "DbgExGetMallocSpy");
        pfnRestoreDefaultDebugState = (PFNRESTOREDEFAULTDEBUGSTATE)GetProcAddress(hInstDbg, "DbgExRestoreDefaultDebugState");
        pfnIsTagEnabled             = (PFNISTAGENABLED)GetProcAddress(hInstDbg, "DbgExIsTagEnabled");
        pfnAssertImpl               = (PFNASSERTIMPL)GetProcAddress(hInstDbg, "DbgExAssertImpl");

        DWORD dwVer = pfnDbgExGetVersion ? pfnDbgExGetVersion() : 0;

        if (pfnDbgExGetVersion)
        {
            if (dwVer != MSHTMDBG_API_VERSION)
            {
                OutputDebugStringA("MSHTMPAD: Version mismatch for MSHTMDBG.DLL.  Continuing without it.\r\n");
                FreeLibrary(hInstDbg);
                hInstDbg = NULL;
            }
        }

        if (    hInstDbg
            &&  (   !pfnTagRegisterOther
                ||  !pfnDbgCoMemoryTrackDisable
                ||  !pfnDbgGetMallocSpy
                ||  !pfnRestoreDefaultDebugState
                ||  !pfnIsTagEnabled))
        {
            OutputDebugStringA("MSHTMPAD: Can't find one or more entrypoints in MSHTMDBG.DLL.  Continuing without it.\r\n");
            FreeLibrary(hInstDbg);
            hInstDbg = NULL;
        }

        if (hInstDbg)
        {
            tagCoTrack = pfnTagRegisterOther("!Memory", "Track all CoMemory leaks", FALSE);
            tagCoTrackDisable = pfnTagRegisterOther("!Memory", "Do not register CoMemory spy (MUST RESTART EXE)", FALSE);
            tagModuleLeaks = pfnTagRegisterOther("!Memory", "Leaks: Assert on module leaks", FALSE);
            pfnRestoreDefaultDebugState();
        }
    }
    else
    {
        OutputDebugStringA("MSHTMPAD: Can't find MSHTMDBG.DLL.  Continuing without it.\r\n");
    }

#if !defined(PRODUCT_PROF)
    if (g_pSpy && hInstDbg && !pfnIsTagEnabled(tagCoTrackDisable))
    {
        g_pSpy->_pSpyFwd = (IMallocSpy *)pfnDbgGetMallocSpy();
    }
#endif

    if (hInstDbg && !pfnIsTagEnabled(tagCoTrack))
    {
        pfnDbgCoMemoryTrackDisable(TRUE);

        //$ISSUE: Not ready for prime-time yet
        pfnDbgCoMemoryTrackDisable(TRUE);
    }

    HINSTANCE hInstPad = LoadLibraryA("htmlpad.dll");

    if (hInstPad == NULL)
    {
        OutputDebugStringA("MSHTMPAD: Unable to load HTMLPAD.DLL\r\n");
        ExitProcess(1);
    }

    PFNPADMAIN pfnPadMain = (PFNPADMAIN)GetProcAddress(hInstPad, "PadMain");

    if (!pfnPadMain)
    {
        OutputDebugStringA("MSHTMPAD: Can't find PadMain entrypoint in HTMLPAD.DLL\r\n");
        ExitProcess(1);
    }

    pfnPadMain(argc, argv, (g_pSpy && g_pSpy->_pSpyFwd) ? g_pSpy : NULL);

    FreeLibrary(hInstPad);

    if (hInstDbg && pfnIsTagEnabled(tagModuleLeaks))
    {
        HMODULE ahModuleEnd[64];
        UINT    chModuleEnd = 0;
        
        if (pfnEnumProcessModules && pfnEnumProcessModules(GetCurrentProcess(), ahModuleEnd, sizeof(ahModuleEnd), &cb))
        {
            chModuleEnd = cb / sizeof(HMODULE);
        }

        if (chModuleEnd)
        {
            HMODULE ahModuleLeak[64];
            UINT    chModuleLeak = 0;
            
            while (chModuleEnd > 0)
            {
                chModuleEnd -= 1;

                HMODULE hModule = ahModuleEnd[chModuleEnd];

                for (cb = 0; cb < chModuleBeg; ++cb)
                {
                    if (ahModuleBeg[cb] == hModule)
                        break;
                }

                if (cb == chModuleBeg && hModule != (HMODULE)hInstDbg)
                {
                    ahModuleLeak[chModuleLeak++] = hModule;
                }
            }

            if (chModuleLeak)
            {
                char achLeakMsg[2048];
                char achModule[128];

                achLeakMsg[0] = 0;

                NonCrtStrCat(achLeakMsg, "The following modules were leaked: ");

                for (cb = 0; cb < chModuleLeak; ++cb)
                {
                    if (!pfnGetModuleBaseNameA(GetCurrentProcess(), ahModuleLeak[cb], achModule, sizeof(achModule)))
                        NonCrtStrCat(achLeakMsg, "<unknown>");
                    if (cb > 0)
                        NonCrtStrCat(achLeakMsg, ", ");
                    NonCrtStrCat(achLeakMsg, achModule);
                }

                if (pfnAssertImpl(__FILE__, __LINE__, achLeakMsg))
                    F3DebugBreak();
            }
        }
    }

        if (hInstPSAPI)
        {
                FreeLibrary(hInstPSAPI);
        }

    if (hInstDbg)
    {
        FreeLibrary(hInstDbg);
    }

    g_pSpy->_pSpyFwd = NULL;

    ExitProcess(0);
}

#ifdef UNIX
// IEUNIX uses WinMain as program entry.
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    return mainCRTStartup(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\htmlpad\tvnode.cpp ===
/////////////////////////////////////
//
//  TVNODE.CPP
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
/////////////////////////////////////


#include <padhead.hxx>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>
#endif

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_TVDLG_H_
#define X_TVDLG_H_
#include "tvdlg.h"
#endif

LPTSTR g_szNoFolderName = TEXT("<No Name>");

//
//  CTVNode::CTVNode
//
CTVNode::CTVNode(LPSPropValue pval, ULONG cProps, LPMDB pmdb)
{
    Assert(cProps == nhtProps);
    Assert(pval);

    _pval = pval;

    _htiMe = NULL;
        
    _fKidsLoaded = FALSE;

    _pfld = NULL;

    _pNext = NULL;

    _pmdb = pmdb;
    if(pmdb)
        pmdb->AddRef();

}

//
//  CTVNode::~CTVNode
//
CTVNode::~CTVNode()
{
    MAPIFreeBuffer(_pval);
    ReleaseInterface(_pfld);
    ReleaseInterface(_pmdb);
}

//
//  CTVNode::GetName
//
LPTSTR CTVNode::GetName(void)
{
    static TCHAR achw[256];

    if(_pval[iDispName].ulPropTag == PR_DISPLAY_NAME_A)
    {
        MultiByteToWideChar(CP_ACP, 0, _pval[iDispName].Value.lpszA, -1, 
                            achw, sizeof(achw));
        return achw;
    }
    else
        return g_szNoFolderName;
}

//
//  CTVNode::HrExpand
//
//  Put all kids of the given folder in the tree control
//
HRESULT CTVNode::HrExpand(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    LPMAPITABLE ptblHier = NULL;
    LPSRowSet pRowSet = NULL;
    UINT ind;
    
    static SSortOrderSet sosName;

    sosName.cSorts = 1;
    sosName.cCategories = 0;
    sosName.cExpanded = 0;
    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME_A;
    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND;


    Assert(_htiMe);
    
    if(_fKidsLoaded || !_pval[iSubfldrs].Value.b)
        return hrSuccess;

    if(!_pmdb)
    {
    // this node corresponds to the top level of a message store which has
    // not been opend yet.
    // _pval[iEID] contains entry ID of the message store
    // 
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }
    
    Assert(_pmdb);     
    
    if(!_pfld)
    {
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pfld); 
    
    hr = _pfld->GetHierarchyTable(MAPI_DEFERRED_ERRORS, &ptblHier);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pfld);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }

    hr = HrQueryAllRows(ptblHier, (LPSPropTagArray)&spthtProps, NULL, &sosName,
                        0, &pRowSet);
    if(HR_FAILED(hr))
        goto err;

    if(0 == pRowSet->cRows)
    {
        _pval[iSubfldrs].Value.b = FALSE;
        goto err;
    }

    for(ind = 0; ind < pRowSet->cRows; ++ind)
    {
        LPSPropValue pval = pRowSet->aRow[ind].lpProps;
        
        Assert(pRowSet->aRow[ind].cValues == nhtProps);
        Assert(pval[iEID].ulPropTag == PR_ENTRYID);
        Assert(pval[iDispName].ulPropTag == PR_DISPLAY_NAME_A);
        Assert(pval[iSubfldrs].ulPropTag == PR_SUBFOLDERS);

        LPTVNODE pNode = NULL;

        hr = pCFDlg->HrCreateNode(pval, nhtProps, _pmdb, &pNode);
        if(hr)
            goto err;
    
        //this row will be freed in ~CTVNode
        pRowSet->aRow[ind].cValues = 0;
        pRowSet->aRow[ind].lpProps = NULL;

        HTREEITEM hItem;
        
        hItem = AddOneItem(_htiMe,  TVI_LAST, pCFDlg->IndClsdFld(),
                            pCFDlg->IndOpenFld(), pCFDlg->hwTreeCtl(), pNode,
                            pval[iSubfldrs].Value.b? 1: 0);
        if(!hItem)
        {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto err;
        }
            
    }

    _fKidsLoaded = TRUE;

err:
    ReleaseInterface(ptblHier);
    FreeProws(pRowSet);

    //DebugTraceResult(CTVNode::HrExpand, hr);
    return hr;
}

//
//  CTVNode::HrOpenMDB
//
HRESULT CTVNode::HrOpenMDB(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    LPMDB pmdb = NULL;
    LPSPropValue pvalIPM = NULL;
    ULONG ulObjType;
    
    Assert(_pval[iEID].ulPropTag == PR_ENTRYID);

    //DebugTrace("ChsFld: Openning Msg Store: %s\n", GetName());
    
    hr = pCFDlg->Session()->OpenMsgStore(0L, _pval[iEID].Value.bin.cb,
                                (LPENTRYID)_pval[iEID].Value.bin.lpb,
                                NULL, MAPI_BEST_ACCESS, &pmdb);
    if(hr) //Display warning messages too
    {
        g_LastError.SetLastError(hr, pCFDlg->Session());
        g_LastError.ShowError(pCFDlg->hwDialog());
    }

    if(HR_FAILED(hr))
        goto err;

    hr = HrGetOneProp(pmdb, PR_IPM_SUBTREE_ENTRYID, &pvalIPM);
    if(hr)
    {
        g_LastError.SetLastError(hr, pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());

        goto err;
    }

    hr = pmdb->OpenEntry(pvalIPM->Value.bin.cb,
                (LPENTRYID)pvalIPM->Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,
                 &ulObjType, (LPUNKNOWN *) &_pfld);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }
    
    Assert(MAPI_FOLDER == ulObjType);

/*  if(pvalIPM->Value.bin.cb > _pval[iEID].Value.bin.cb)
    {
        if(hr = MAPIAllocateMore(pvalIPM->Value.bin.cb,
                        _pval, (LPVOID *)&_pval[iEID].Value.bin.lpb))
            goto err;
                
    }

    CopyMemory(_pval[iEID].Value.bin.lpb, pvalIPM->Value.bin.lpb,
                                        pvalIPM->Value.bin.cb);
    _pval[iEID].Value.bin.cb = pvalIPM->Value.bin.cb;*/

err:
    if(HR_FAILED(hr))
    {
        ReleaseInterface(pmdb);
        ReleaseInterface(_pfld);
        _pfld = NULL;
    }
    else
    {
        _pmdb = pmdb;
        hr = hrSuccess; //don't return warnings
    }

    MAPIFreeBuffer(pvalIPM);

    //DebugTraceResult(CTVNode::HrOpenMDB, hr);
    return hr;
}

//
//  CTVNode::HrOpenFolder
//
HRESULT CTVNode::HrOpenFolder(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    ULONG ulObjType;

    Assert(_pval[iEID].ulPropTag == PR_ENTRYID);
    Assert(_pmdb);
    
    // MAPI_MODIFY flag affects only IMAPIProp interface of the object.
    // It does not guarantee permission to create subfolders.
    hr = _pmdb->OpenEntry(_pval[iEID].Value.bin.cb,
                (LPENTRYID)_pval[iEID].Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,
                 &ulObjType, (LPUNKNOWN *) &_pfld);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }
    
    Assert(MAPI_FOLDER == ulObjType);
err:

    //DebugTraceResult(CTVNode::HrOpenFolder, hr);
    return hr;

}

//
//  CTVNode::HrGetFolder
//
//  return folder interface for the node
HRESULT CTVNode::HrGetFolder(CChsFldDlg * pCFDlg,
                            LPMAPIFOLDER * ppfld, LPMDB *ppmdb)
{
    HRESULT hr = hrSuccess;
    ULONG ulObjType = 0;

    
    Assert(pCFDlg);
    Assert(ppfld);
    Assert(ppmdb);


    if(!_pmdb)
    {
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }
    Assert(_pmdb);
    
    if(!_pfld)
    {
        Assert(!_fKidsLoaded);
        
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;

    }
    Assert(_pfld);

    *ppfld = _pfld;
    _pfld->AddRef();

    _pmdb->AddRef();
    *ppmdb = _pmdb;            

err:

    //DebugTraceResult(CTVNode::HrGetFolder, hr);
    return hr;
}


//
//  CTVNode::HrNewFolder
//
// Create subfolder szFldName
//
HRESULT CTVNode::HrNewFolder(CChsFldDlg * pCFDlg,
                                     LPTSTR szFldName)
{
    HRESULT hr;
    LPMAPIFOLDER pfldNew = NULL;
    LPTVNODE pNode = NULL;
    ULONG ulObjType = 0;
    LPSPropValue pval = NULL;
    HTREEITEM hItem;

    Assert(szFldName);
    Assert(pCFDlg);
    

    if(!_pmdb)
    {
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pmdb);
    
    if(!_pfld)
    {
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pmdb);
    
    hr = _pfld->CreateFolder(FOLDER_GENERIC, szFldName, NULL,
                                NULL, 0, &pfldNew);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pfld);
        g_LastError.ShowError(pCFDlg->hwDialog());

        goto err;
    }

    if(!_pval[iSubfldrs].Value.b)
    {
        _pval[iSubfldrs].Value.b = TRUE;

        TV_ITEM tvI;

        tvI.hItem           = _htiMe;
        tvI.mask            = TVIF_CHILDREN;
        tvI.cChildren       = 1;

        TreeView_SetItem(pCFDlg->hwTreeCtl(), &tvI);
    }

    if(_fKidsLoaded)
    {
        hr = MAPIAllocateBuffer(sizeof(SPropValue)* nhtProps, (LPVOID *)&pval);
        if(hr)
            goto err;

        ZeroMemory(pval, sizeof(SPropValue) * nhtProps );

        pval[iEID].ulPropTag = PR_ENTRYID;
        pval[iDispName].ulPropTag = PR_DISPLAY_NAME_A;
        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;

        pval[iSubfldrs].Value.b = FALSE;

        int cb = lstrlen(szFldName) + 1;
        hr = MAPIAllocateMore(cb, pval, (LPVOID *)&pval[iDispName].Value.lpszA);
        if(hr) 
            goto err;

        WideCharToMultiByte(CP_ACP, 0, szFldName, -1, pval[iDispName].Value.lpszA, cb+1, NULL, NULL);

        hr = pCFDlg->HrCreateNode(pval, nhtProps, _pmdb, &pNode);
        if(HR_FAILED(hr))
            goto err;

        pval = NULL;

        hItem = AddOneItem(_htiMe,  TVI_SORT, pCFDlg->IndClsdFld(),
                        pCFDlg->IndOpenFld(), pCFDlg->hwTreeCtl(), pNode, 0);
        if(!hItem)
        {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto err;
        }
            
        pNode->_pfld = pfldNew;
        pfldNew = NULL;
        
    }

err:
    MAPIFreeBuffer(pval);
    ReleaseInterface(pfldNew);

    //DebugTraceResult(CTVNode::HrNewFolder, hr);
    return hr;
}

//
//  CTVNode::Write
//
// Used in CChsFldDlg::HrSaveTreeState
void CTVNode::Write(BOOL fWrite, LONG iLevel, LPBYTE * ppb)
{
    if(fWrite)
        *((LONG *)*ppb) = iLevel;
    *ppb += sizeof(LONG);

    if(iLevel != 0)
    {
        ULONG cb = _pval[iEID].Value.bin.cb;
        
        if(fWrite)
            *((ULONG *)*ppb) = cb;
        *ppb += sizeof(ULONG);

        if(fWrite)
            CopyMemory(*ppb, _pval[iEID].Value.bin.lpb, cb);
        *ppb += Align4(cb);
    }
    else
    {
        Assert(_pval[iDispName].Value.lpszA == g_szAllStoresA);
    }

}

LPVOID CTVNode::operator new( size_t cb )
{
    LPVOID pv;

    if ( MAPIAllocateBuffer( (ULONG)cb, &pv ) )
        pv = NULL;

    return pv; 
}

void CTVNode::operator delete( LPVOID pv )
{
    MAPIFreeBuffer( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\include\trirt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       Common header file for trirt
//
//  Note:       This file is very order-dependent.  Don't switch files around
//              just for the heck of it!
//
//----------------------------------------------------------------------------

#ifndef I_TRIRT_H_
#define I_TRIRT_H_

#ifndef INCMSG
//#define INCMSG(x)
#define INCMSG(x) message(x)
#endif

#pragma INCMSG("--- Beg 'trirt.h'")


// Make it so you can't use the CRT strdup functions.  Use MemAllocString instead.
// We want to do this so that the memory is allocated and tagged with our allocators.
#define _strdup CRT__strdup_DontUse
#define _wcsdup CRT__wcsdup_DontUse
#define strdup  CRT_strdup_DontUse

// Also don't let people use the CRT malloc/realloc/calloc/free functions
#define malloc  CRT_malloc_DontUse
#define realloc CRT_realloc_DontUse
#define calloc  CRT_calloc_DontUse
#define free    CRT_free_DontUse

// We are redefining this one because at one time we had our own implemenation that
// used Win32 CompareString.  Apparently CompareString can take NULL as an input
// but _wcsicmp can't.  So, lets just keep using the CompareString version.  We can't
// use the standard prototype however as it will be tagged with __declspec(dllimport).
#define _wcsicmp CRT__wcsicmp

// We want to use shlwapi for these so we redefine them
#define isdigit     CRT_isdigit
#define isalpha     CRT_isalpha
#define isspace     CRT_isspace
#define iswspace    CRT_iswspace

// Windows include
#include <w4warn.h>

#ifndef X_SHLWRAP_H_
#define X_SHLWRAP_H_
#include "shlwrap.h"
#endif

#include <w4warn.h>

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#pragma INCMSG("--- Beg <windows.h>")
#include <windows.h>
#pragma INCMSG("--- End <windows.h>")
#endif

#include <w4warn.h> // windows.h reenables some pragmas

#ifndef X_WINDOWSX_H_
#define X_WINDOWSX_H_
#pragma INCMSG("--- Beg <windowsx.h>")
#include <windowsx.h>
#pragma INCMSG("--- End <windowsx.h>")
#endif

// C runtime includes

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#pragma INCMSG("--- Beg <stdlib.h>")
#include <stdlib.h>
#pragma INCMSG("--- End <stdlib.h>")
#endif


#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#pragma INCMSG("--- Beg <limits.h>")
#include <limits.h>
#pragma INCMSG("--- End <limits.h>")
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#pragma INCMSG("--- Beg <stddef.h>")
#include <stddef.h>
#pragma INCMSG("--- End <stddef.h>")
#endif

#ifndef X_SEARCH_H_
#define X_SEARCH_H_
#pragma INCMSG("--- Beg <search.h>")
#include <search.h>
#pragma INCMSG("--- End <search.h>")
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#pragma INCMSG("--- Beg <string.h>")
#include <string.h>
#pragma INCMSG("--- End <string.h>")
#endif

#ifndef X_TCHAR_H_
#define X_TCHAR_H_
#pragma INCMSG("--- Beg <tchar.h>")
#include <tchar.h>
#pragma INCMSG("--- End <tchar.h>")
#endif

// We want to include this here so that
// no one else can.
#ifndef X_MALLOC_H_
#define X_MALLOC_H_
#pragma INCMSG("--- Beg <malloc.h>")
#include <malloc.h>
#pragma INCMSG("--- End <malloc.h>")
#endif

#undef _strdup
#undef _wcsdup
#undef strdup
#undef _wcsicmp
#undef malloc
#undef realloc
#undef calloc
#undef free

#undef isdigit
#undef isalpha
#undef isspace
#undef iswspace


// If you get an error pointing to these functions please look at
// at the note above -- JBeda
__declspec(deprecated) char *  __cdecl _strdup(const char *);
__declspec(deprecated) char *  __cdecl strdup(const char *);
__declspec(deprecated) wchar_t * __cdecl _wcsdup(const wchar_t *);
__declspec(deprecated) void * __cdecl malloc(size_t);
__declspec(deprecated) void * __cdecl realloc(void *, size_t);
__declspec(deprecated) void * __cdecl calloc(size_t, size_t);
__declspec(deprecated) void   __cdecl free(void *);

int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);


#ifndef X_F3DEBUG_H_
#define X_F3DEBUG_H_
#include "f3debug.h"
#endif

//+---------------------------------------------------------------------------
//
// Usefull Macros
//
//----------------------------------------------------------------------------
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x
#define IF_WIN32(x) x

#define PTR_DIFF(x, y)   ((x) - (y))

#if defined(_M_AMD64) || defined(_M_IA64)
#define SPEED_OPTIMIZE_FLAGS "tg"       // flags used for local speed optimisation in #pragma optimize
#else
#define SPEED_OPTIMIZE_FLAGS "tyg"      // flags used for local speed optimisation in #pragma optimize
#endif


#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

//+------------------------------------------------------------------------
//
// DYNCAST macro
//
// Use to cast objects from one class type to another. This should be used
// rather than using standard casts.
//
// Example:
//         CBodyElement *pBody = (CBodyElement*)_pElement;
//
//      is replaced by:
//
//         CBodyElement *pBody = DYNCAST(CBodyElement, _pElement);
//
// The dyncast macro will assert if _pElement is not really a CBodyElement.
//
// For ship builds the DYNCAST macro expands to a standard cast.
//
//-------------------------------------------------------------------------

#if DBG != 1 || defined(WINCE) || defined(NO_RTTI)

#ifdef UNIX
#define DYNCAST(Dest_type, Source_Value) ((Dest_type*)(Source_Value))
#else
#define DYNCAST(Dest_type, Source_Value) (static_cast<Dest_type*>(Source_Value))
#endif

#else // DBG == 1

#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#pragma INCMSG("--- Beg <typeinfo.h>")
#include <typeinfo.h>
#pragma INCMSG("--- End <typeinfo.h>")
#endif

extern char g_achDynCastMsg[];
extern char *g_pszDynMsg;
extern char *g_pszDynMsg2;

template <class TS, class TD>
TD * DYNCAST_IMPL (TS * source, TD &, char* pszType)
{
    if (!source) return NULL;

    TD * dest  = dynamic_cast <TD *> (source);
    TD * dest2 = static_cast <TD *> (source);
    if (!dest)
    {
        wsprintfA(g_achDynCastMsg, g_pszDynMsg, typeid(*source).name(), pszType);
        AssertSz(FALSE, g_achDynCastMsg);
    }
    else if (dest != dest2)
    {
        wsprintfA(g_achDynCastMsg, g_pszDynMsg2, typeid(*source).name(), pszType);
        AssertSz(FALSE, g_achDynCastMsg);
    }

    return dest2;
}

#define DYNCAST(Dest_type, Source_value) \
    DYNCAST_IMPL(Source_value,(Dest_type &)*(Dest_type*)NULL, #Dest_type)

#endif // ifdef DBG != 1


//+------------------------------------------------------------------------
//
// Min and max templates
//
// Warning, Arguments must be cast to same types for template instantiation
//
//-------------------------------------------------------------------------

#ifdef min
#undef min
#endif

template < class T > inline T min ( T a, T b ) { return a < b ? a : b; }

#ifdef max
#undef max
#endif

template < class T > inline T max ( T a, T b ) { return a > b ? a : b; }

//+------------------------------------------------------------------------
// Performance tags and metering
//-------------------------------------------------------------------------

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#pragma INCMSG("--- Beg <mshtmdbg.h>")
#include <mshtmdbg.h>
#pragma INCMSG("--- End <mshtmdbg.h>")
#endif

extern HTMPERFCTL * g_pHtmPerfCtl;

//+------------------------------------------------------------------------
// Memory allocation
//-------------------------------------------------------------------------

MtExtern(Mem)

EXTERN_C void *  _MemAlloc(ULONG cb);
EXTERN_C void *  _MemAllocClear(ULONG cb);
EXTERN_C HRESULT _MemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MemGetSize(void * pv);
EXTERN_C void    _MemFree(void * pv);
HRESULT          _MemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDest);
#define          _MemFreeString(pch) _MemFree(pch)
void __cdecl     _MemSetName(void * pv, char * szFmt, ...);
char *           _MemGetName(void * pv);

EXTERN_C void *  _MtMemAlloc(PERFMETERTAG mt, ULONG cb);
EXTERN_C void *  _MtMemAllocClear(PERFMETERTAG mt, ULONG cb);
EXTERN_C HRESULT _MtMemRealloc(PERFMETERTAG mt, void ** ppv, ULONG cb);
EXTERN_C ULONG   _MtMemGetSize(void * pv);
EXTERN_C void    _MtMemFree(void * pv);
HRESULT          _MtMemAllocString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MtMemAllocString(PERFMETERTAG mt, ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MtMemReplaceString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst);
#define          _MtMemFreeString(pch) _MtMemFree(pch)
void __cdecl     _MtMemSetName(void * pv, char * szFmt, ...);
char *           _MtMemGetName(void * pv);
int              _MtMemGetMeter(void * pv);
void             _MtMemSetMeter(void * pv, PERFMETERTAG mt);

EXTERN_C void *  _MgMemAlloc(ULONG cb);
EXTERN_C void *  _MgMemAllocClear(ULONG cb);
EXTERN_C HRESULT _MgMemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MgMemGetSize(void * pv);
EXTERN_C void    _MgMemFree(void * pv);
HRESULT          _MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MgMemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MgMemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDst);
#define          _MgMemFreeString(pch) _MgMemFree(pch)

#ifdef PERFMETER

#define MemAlloc(mt, cb)                            _MtMemAlloc(mt, cb)
#define MemAllocClear(mt, cb)                       _MtMemAllocClear(mt, cb)
#define MemRealloc(mt, ppv, cb)                     _MtMemRealloc(mt, ppv, cb)
#define MemGetSize(pv)                              _MtMemGetSize(pv)
#define MemFree(pv)                                 _MtMemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MtMemAllocString(mt, pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MtMemAllocString(mt, cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MtMemReplaceString(mt, pch, ppch)
#define MemFreeString(pch)                          _MtMemFreeString(pch)
#define MemGetMeter(pv)                             _MtMemGetMeter(pv)
#define MemSetMeter(pv, mt)                         _MtMemSetMeter(pv, mt)

#elif defined(MEMGUARD)

#define MemAlloc(mt, cb)                            _MgMemAlloc(cb)
#define MemAllocClear(mt, cb)                       _MgMemAllocClear(cb)
#define MemRealloc(mt, ppv, cb)                     _MgMemRealloc(ppv, cb)
#define MemGetSize(pv)                              _MgMemGetSize(pv)
#define MemFree(pv)                                 _MgMemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MgMemAllocString(pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MgMemAllocString(cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MgMemReplaceString(pch, ppch)
#define MemFreeString(pch)                          _MgMemFreeString(pch)
#define MemGetMeter(pv)                             0
#define MemSetMeter(pv, mt)

#else

#define MemAlloc(mt, cb)                            _MemAlloc(cb)
#define MemAllocClear(mt, cb)                       _MemAllocClear(cb)
#define MemRealloc(mt, ppv, cb)                     _MemRealloc(ppv, cb)
#define MemGetSize(pv)                              _MemGetSize(pv)
#define MemFree(pv)                                 _MemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MemAllocString(pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MemAllocString(cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MemReplaceString(pch, ppch)
#define MemFreeString(pch)                          _MemFreeString(pch)
#define MemGetMeter(pv)                             0
#define MemSetMeter(pv, mt)

#endif

#if DBG==1
    #ifdef PERFMETER
        #define MemGetName(pv)              _MtMemGetName(pv)
        #define MemSetName(x)               _MtMemSetName x
    #else
        #define MemGetName(pv)              _MemGetName(pv)
        #define MemSetName(x)               _MemSetName x
    #endif
#else
    #define MemGetName(pv)
    #define MemSetName(x)
#endif

HRESULT TaskAllocString(const TCHAR *pstrSrc, TCHAR **ppstrDest);
HRESULT TaskReplaceString(const TCHAR * pstrSrc, TCHAR **ppstrDest);

MtExtern(OpNew)

#ifndef TRIMEM_NOOPNEW

#ifdef PERFMETER
       void * __cdecl UseOperatorNewWithMemoryMeterInstead(size_t cb);
inline void * __cdecl operator new(size_t cb)           { return UseOperatorNewWithMemoryMeterInstead(cb); }
inline void * __cdecl operator new[](size_t cb)         { return UseOperatorNewWithMemoryMeterInstead(cb); }
#else
inline void * __cdecl operator new(size_t cb)           { return MemAlloc(Mt(OpNew), cb); }
#ifndef UNIX // UNIX can't take new[] and delete[]
inline void * __cdecl operator new[](size_t cb)         { return MemAlloc(Mt(OpNew), cb); }
#endif // UNIX
#endif

inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt)   { return MemAlloc(mt, cb); }
#ifndef UNIX
inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return MemAlloc(mt, cb); }
#endif
inline void * __cdecl operator new(size_t cb, void * pv){ return pv; }
inline void   __cdecl operator delete(void *pv)         { MemFree(pv); }
#ifndef UNIX
inline void   __cdecl operator delete[](void *pv)       { MemFree(pv); }
#endif

#else // TRIMEM_NOOPNEW

inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt)   { return operator new(cb); }
#ifndef UNIX
inline void * __cdecl operator new[](size_t cb) { return operator new(cb); }
inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return operator new(cb); }
#endif

#endif // TRIMEM_NOOPNEW

inline void TaskFreeString(LPVOID pstr)
        { CoTaskMemFree(pstr); }

#ifndef UNIX
#define DECLARE_MEMALLOC_NEW_DELETE(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(mt, cb)); }

#define DECLARE_DELETE \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(mt, cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMMETER_NEW \
    inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); }
#else
#define DECLARE_MEMALLOC_NEW_DELETE(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); }

#define DECLARE_DELETE \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAllocClear(mt, cb)); } \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMMETER_NEW \
    void * __cdecl operator new(size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); }
#endif //UNIX

#define DECLARE_PLACEMENT_NEW \
    inline void * __cdecl operator new(size_t cb, void * pv) { return pv; }

//+------------------------------------------------------------------------
//
//  Locale-correct implementations for the string compare functions
//  Added benefit is getting rid of the C runtime baggage.
//
//  Implementation lives in strcmp.c
//
//-------------------------------------------------------------------------

#undef _tcscmp
#undef _tcsicmp
#ifndef WINCE
#undef _wcsicmp
#endif
#undef _tcsncmp
#undef _tcsnicmp

#undef _istspace
#undef _istdigit
#undef _istalpha
#undef _istalnum
#undef _istxdigit
#undef _istprint

// Unlocalized string comparisons
int _cdecl _tcscmp  (const TCHAR *string1, const TCHAR *string2);
int _cdecl _tcsicmp (const TCHAR *string1, const TCHAR *string2);
const TCHAR * __cdecl _tcsistr (const TCHAR * wcs1,const TCHAR * wcs2);
int _cdecl _tcsncmp (const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
int _cdecl _tcsnicmp(const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
BOOL _tcsequal(const TCHAR *string1, const TCHAR *string2);
BOOL _tcsiequal(const TCHAR *string1, const TCHAR *string2);
BOOL _tcsnpre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);
BOOL _tcsnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);
BOOL _7csnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);

// Localized string comparisons
int _cdecl _tcscmpLoc  (const TCHAR *string1, const TCHAR *string2);
int _cdecl _tcsicmpLoc (const TCHAR *string1, const TCHAR *string2);
const TCHAR * __cdecl _tcsistrLoc (const TCHAR * wcs1,const TCHAR * wcs2);
int _cdecl _tcsncmpLoc (const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
int _cdecl _tcsnicmpLoc(const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);

int _cdecl _istspace  (TCHAR ch);
int _cdecl _istdigit  (TCHAR ch);
int _cdecl _istalpha  (TCHAR ch);
int _cdecl _istalnum  (TCHAR ch);
int _cdecl _istxdigit  (TCHAR ch);
int _cdecl _istprint  (TCHAR ch);

int __cdecl isdigit(int ch);
int __cdecl isalpha(int ch);
int __cdecl isspace(int ch);
int __cdecl iswspace(wchar_t ch);


#pragma INCMSG("--- End 'trirt.h'")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\critsec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       critsec.cxx
//
//  Contents:   Critical Section initialization wrapper
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WIN16

CGlobalCriticalSection *CGlobalCriticalSection::g_gcsList = NULL;

//+---------------------------------------------------------------------------
//
//  Wrapper for InitializeCriticalSection to hide the exception that can be
//  thrown and convert it to an HRESULT
//
//----------------------------------------------------------------------------

HRESULT     HrInitializeCriticalSection(LPCRITICAL_SECTION pcs)
{
    HRESULT     hr = S_OK;

    __try
    {
        ::InitializeCriticalSection(pcs);
    } __except(GetExceptionCode() == STATUS_NO_MEMORY)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#endif  // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\rsrc\makefile.inc ===
# Run the HTML dialogs though the preprocessor to remove comments
# then through a sed script to reomave extra whitespace.

$O\replace.dls : replace.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP replace.dlg > $@

$O\replace.dlx : $O\replace.dls dlg.pl
    perl dlg.pl < $O\replace.dls > $@

$O\forpar.dls : forpar.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP forpar.dlg > $@

$O\forpar.dlx : $O\forpar.dls dlg.pl
    perl dlg.pl < $O\forpar.dls > $@

$O\gobook.dls : gobook.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP gobook.dlg > $@

$O\gobook.dlx : $O\gobook.dls dlg.pl
    perl dlg.pl < $O\gobook.dls > $@

# Run the HTML property pages through a sed
# script to remove extra whitespaces.

$O\selfreg_mshtml.inf : selfreg.inx
	cleaninf.exe -w selfreg.inx $@

FORMS3R_DEP = \
    $(BASEDIR)\public\sdk\inc\ieverp.h \
    $O\replace.dlx \
    $O\forpar.dlx \
    $O\gobook.dlx \
    backgrnd.ppg \
    backgrnd.jpg \
    clouds.gif \
    waves.gif \
    authfla.gif \
    cforms.ico \
    selbar.cur \
    west.cur \
    south.cur \
    north.cur \
    nomove2d.cur \
    east.cur \
    sw.cur \
    se.cur \
    nw.cur \
    ne.cur \
    hyperlnk.cur \
    hlnocach.cur \
    csimtool.bmp \
    $O\selfreg_mshtml.inf

forms3r.rc : $(FORMS3R_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dbgstk.cxx ===
/***
*dbgstk.c - debug check stack routine
*
*       Copyright (c) 1986-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This module contains a debug impelmentation of the standard _chkstk
*   for i386.  It will do the standard stack probe (code copied from
*   VC5 CRT) and then call a debug routine which will have the oportunity
*   top spew the stack before it gets initialized (or not).
*
*******************************************************************************/
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if defined(USE_STACK_SPEW) && defined(_X86_)

#pragma check_stack(off)

static BOOL    g_fStackSpewEnabled = FALSE;
static DWORD   g_dwSpew = 0x0;

extern "C" void __declspec(naked) __cdecl _chkstk()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't 
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx                        

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled
        
        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:        
        ret     12                      ; return, popping off 12 padding
    }
}

// NOTE: _alloca_probe is impelemented exactly the same as _chkstk
// I'd like to find some way to merge these two pieces of code but I
// don't know how with inline assembly...
extern "C" void __declspec(naked) __cdecl _alloca_probe()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't 
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx                        

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled
        
        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:        
        ret     12                      ; return, popping off 12 padding
    }
}

//
// Initialize the debug stack system
//

extern "C" void
InitChkStk(BOOL dwFill)
{
    g_dwSpew = dwFill;
    g_fStackSpewEnabled = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dllmain1.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define DLL_MAIN_FUNCTION_NAME  _DllMainStartup
#define DLL_MAIN_PRE_CINIT      /* Nothing */
#define DLL_MAIN_PRE_CEXIT      /* Nothing */
#define DLL_MAIN_POST_CEXIT     /* Nothing */
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dllmain3.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitChkStk(unsigned long dwFill);
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupChkStk
#define DLL_MAIN_PRE_CINIT      InitChkStk(0xCCCCCCCC);
#define DLL_MAIN_PRE_CEXIT      /* Nothing */
#define DLL_MAIN_POST_CEXIT     /* Nothing */
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dllmain.cxx ===
#ifdef __cplusplus
extern "C" {
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern CRITICAL_SECTION g_csHeap;
extern int  __cdecl __sbh_process_detach();
extern int trirt_proc_attached;
extern HANDLE g_hProcessHeap;
extern BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);

BOOL WINAPI DLL_MAIN_FUNCTION_NAME(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
    BOOL retcode = TRUE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            trirt_proc_attached++;

            if (HrInitializeCriticalSection(&g_csHeap) != S_OK)
                retcode = FALSE;

            if (!retcode)
                break;

            g_hProcessHeap = GetProcessHeap();

            DLL_MAIN_PRE_CINIT

            // Initialize the CRT and have it call into our DllMain for us
            
            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            if (trirt_proc_attached <= 0)
            {
                /*
                 * no prior process attach notification. just return
                 * without doing anything.
                 */
                return FALSE;
            }

            DLL_MAIN_PRE_CEXIT

            trirt_proc_attached--;

            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);

            DLL_MAIN_POST_CEXIT

#if DBG==1
            if (!__sbh_process_detach())
            {
				char ach[1024];
                wsprintfA(ach, "Small block heap not empty at DLL_PROCESS_DETACH\r\nFile: %s; Line %ld\r\n", __FILE__, __LINE__);
				OutputDebugStringA(ach);
            }
#else
            __sbh_process_detach();
#endif

            DeleteCriticalSection(&g_csHeap);

            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);
            break;
        }
    }

    return retcode;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dllmain2.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void TermDebugLib(HANDLE, BOOL);
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupDebug
#define DLL_MAIN_PRE_CINIT      InitDebugLib(hDllHandle, DLL_MAIN_FUNCTION_NAME);
#define DLL_MAIN_PRE_CEXIT      TermDebugLib(hDllHandle, FALSE);
#define DLL_MAIN_POST_CEXIT     TermDebugLib(hDllHandle, TRUE);
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\dllmain4.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void InitDebugChkStk(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void TermDebugLib(HANDLE, BOOL);
extern "C" void InitChkStk(unsigned long dwFill);
#undef  DLL_MAIN_FUNCTION_NAME
#undef  DLL_MAIN_PRE_CINIT
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupDebugChkStk
#define DLL_MAIN_PRE_CINIT      InitDebugChkStk(hDllHandle, DLL_MAIN_FUNCTION_NAME);
#define DLL_MAIN_PRE_CEXIT      TermDebugLib(hDllHandle, FALSE);
#define DLL_MAIN_POST_CEXIT     TermDebugLib(hDllHandle, TRUE);
#include "dllmain.cxx"
#include <mshtmdbg.h>

extern "C"
void
InitDebugChkStk(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    DWORD dwFill;

    InitDebugLib(hDllHandle, pfnDllMain);

    if (DbgExGetChkStkFill(&dwFill))
    {
        InitChkStk(dwFill);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intl.inc ===
WARNING_LEVEL=W4

# include common.inc in mshtml
!include $(ROOT)\common.inc

# optimize for the ppro/pII
# X86_CPU_OPTIMIZATION = /G6

SRCROOT=$(ROOT)\src
INTLROOT=$(SRCROOT)\intl

INTL_INC_DIRS= \
    $(INTLROOT)\include; \
    $(INTLROOT)\idl\$(O); \
    $(ROOT)\src\core\include; \
    $(SHELL_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\trirt0.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       trirt0.c
//
//  Contents:   Data for trirt
//
//----------------------------------------------------------------------------

#include <w4warn.h>
#define NOGDI
#define NOCRYPT
#include <windows.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

CRITICAL_SECTION g_csHeap;

int trirt_proc_attached = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\winheap.h ===
/***
*winheap.h - Private include file for winheap directory.
*
*       Copyright (c) 1988-1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains information needed by the C library heap code.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_WINHEAP
#define _INC_WINHEAP

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#include <windows.h>
#endif

#if defined(UNIX)
#define _PAGESIZE_      0x2000      /* one page */
#else
#define _PAGESIZE_      0x1000      /* one page */
#endif

/*
 * Constants and types for used by the small-block heap
 */
#define _PARASIZE               0x10
#define _PARASHIFT              0x4

#if defined(_M_AMD64) || defined(_M_IA64)

#define _PARAS_PER_PAGE         239
#define _PADDING_PER_PAGE       12
#define _PAGES_PER_REGION       1024
#define _PAGES_PER_COMMITMENT   16

#elif defined(UNIX)

#define _PARAS_PER_PAGE         454
#define _PADDING_PER_PAGE       3
#define _PAGES_PER_REGION       512
#define _PAGES_PER_COMMITMENT   8

#else

#define _PARAS_PER_PAGE         240
#define _PADDING_PER_PAGE       3
#define _PAGES_PER_REGION       1024
#define _PAGES_PER_COMMITMENT   16
#define _MARK_SBH

#endif

#define _NO_INDEX               -1

typedef char            __para_t[16];

#if defined(UNIX)
typedef unsigned short  __map_t;
#else
typedef unsigned char   __map_t;
#endif

#define _FREE_PARA              (__map_t)(0)
#define _UNCOMMITTED_PAGE       (__map_t)(-1)
#define _NO_FAILED_ALLOC        (__map_t)(_PARAS_PER_PAGE + 1);

typedef struct __sbh_region_struct  __sbh_region_t;

/*
 * Small-block heap page. The first four fields of the structure below are
 * descriptor for the page. That is, they hold information about allocations
 * in the page. The last field (typed as an array of paragraphs) is the
 * allocation area.
 */
typedef struct {
        __map_t *   pstarting_alloc_map;
        unsigned long free_paras_at_start;
        __map_t     alloc_map[_PARAS_PER_PAGE];
        __map_t     sentinel;                       /* always set to -1 */
        __map_t     reserved[_PADDING_PER_PAGE];
        __sbh_region_t * preg;
        __para_t    alloc_blocks[_PARAS_PER_PAGE];
}       __sbh_page_t;

// If the compiler barfs on the following line, it means that the data structure for
// __sbh_page_t is not exactly the size of a page.  It needs to be.  Adjust the parameter
// above until this compile-time assert doesn't fire.
typedef int _farf___sbh_page_t[sizeof(__sbh_page_t) == (_PAGESIZE_)];

/*
 * Small-block heap region descriptor. Most often, the small-block heap
 * consists of a single region, described by the statically allocated
 * decriptor __small_block_heap (declared below).
 */
struct __sbh_region_struct {
        struct __sbh_region_struct *    p_next_region;
        struct __sbh_region_struct *    p_prev_region;
        int                             starting_page_index;
        int                             first_uncommitted_index;
        __map_t                         region_map[_PAGES_PER_REGION];
        __map_t                         last_failed_alloc[_PAGES_PER_REGION];
        __sbh_page_t *                  p_pages;
};

typedef struct __sbh_region_struct  __sbh_region_t;

extern  HANDLE _crtheap;

/*
 * Global variable declarations for the small-block heap.
 */
extern __sbh_region_t  __small_block_heap;

// BUGBUG until CTableCell goes below 480 bytes (istvanc)
//efine __sbh_threshold (_PARASIZE * (_PARAS_PER_PAGE / 8))
#define __sbh_threshold (_PARASIZE * 35)

void * __cdecl _nh_malloc( size_t, int);
void * __cdecl _heap_alloc(size_t);

/*
 * Prototypes for internal functions of the small-block heap.
 */
void *    __cdecl __sbh_alloc_block(size_t);
void *    __cdecl __sbh_alloc_block_from_page(__sbh_page_t *, size_t, size_t);
void      __cdecl __sbh_decommit_pages(int);
__map_t * __cdecl __sbh_find_block(void *, __sbh_region_t **, __sbh_page_t **);
void      __cdecl __sbh_free_block(__sbh_region_t *, __sbh_page_t *, __map_t *);
int       __cdecl __sbh_heap_check(void);
__sbh_region_t * __cdecl __sbh_new_region(void);
void      __cdecl __sbh_release_region(__sbh_region_t *);
int       __cdecl __sbh_resize_block(__sbh_region_t *, __sbh_page_t *,
                                     __map_t *, size_t);


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif  /* _INC_WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\fontlinkcore\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\idl\$(O) to $(O)
#

$(O)\fontlink_i.c : ..\idl\$(O)\fontlink_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\strutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       strutil.cxx
//
//  Contents:   These string comparison functions replace the C runtime's
//              implementation. They use the correct locale for string
//              comparison and make it unnecessary to link to the C runtime.
//
//              Also contains our versions of the _is??? C-Runtime functions
//
//  Note:       For Far East compatibility, the case insensitive compare functions
//              should also ignore char width (single-byte 'a' is the same
//              as double-byte 'a') and kana type (this is Japanese-specific).
//  NOTE:       How do we convert the internal Unicode representation to BDCS?
//              Is it possible to convert in a way that we can avoid these extra
//              comparison attributes for performance's sake?
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTYPE_H_
#define X_CTYPE_H_
#include <ctype.h>
#endif

#if defined(_MAC) && !defined(_MACUNICODE)
#define RETURN_TYPE int
#else
#define RETURN_TYPE int __cdecl
#endif

// IEUNIX: From NT's string.h  Where should this go?
#ifdef UNIX
#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif
#endif

//  "Language-Neutral" on downlevel platforms - this just uses the user locale info.
//  "Language-Invariant" is only available on Whistler.
//  US English has the same sort order for string comparisions as Language Invariant, and is supported on downlevel, so we use that.
const LCID g_lcidLangInvariant = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);

#ifndef IsCharDigit
BOOL
IsCharDigit(TCHAR ch)
{
    return (unsigned)(ch - L'0') <= (L'9' - L'0');
}
#endif

BOOL
_tcsequal(const TCHAR *string1, const TCHAR *string2)
{
    // This function optimizes the case where all we want to find
    // is if the strings are equal and do not care about the relative
    // ordering of the strings.

    while (*string1)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;

    }
    return (*string2) ? (FALSE) : (TRUE);
}

BOOL
_tcsiequal(const TCHAR *string1, const TCHAR *string2)
{
    // NOTE: Doing two CharLowerBuffs per char is way way too expensive
#if DBG==1
    BOOL fSlowCheck;
    LPCTSTR strdbg1 = string1, strdbg2 = string2;
    // This function optimizes the case where all we want to find
    // is if the strings are equal and do not care about the relative
    // ordering of the strings (or CaSe).

    while (*strdbg1)
    {
        TCHAR ch1 = *strdbg1;
        TCHAR ch2 = *strdbg2;

        CharLowerBuff(&ch1, 1);
        CharLowerBuff(&ch2, 1);

        if (ch1 != ch2)
        {
            fSlowCheck = FALSE;
            goto SlowDone;
        }

        strdbg1 += 1;
        strdbg2 += 1;

    }
    fSlowCheck = (*strdbg2) ? (FALSE) : (TRUE);

SlowDone:
#endif

    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    Assert( fSlowCheck == (cc == CSTR_EQUAL) );

    return cc == CSTR_EQUAL;
}

BOOL
_tcsnpre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(string1);
    if (cch2 == -1)
        cch2 = _tcslen(string2);
    return( cch1 <= cch2
        &&  CompareString(g_lcidLangInvariant,
                          0,
                          string1, cch1,
                          string2, cch1) == 2);
}

BOOL
_tcsnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(string1);
    if (cch2 == -1)
        cch2 = _tcslen(string2);
    return( cch1 <= cch2
        &&  CompareString(g_lcidLangInvariant,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                string1, cch1, string2, cch1) == 2);
}

#ifndef WIN16
RETURN_TYPE
_tcscmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString( g_lcidLangInvariant,
                        0, string1, -1, string2, -1);

    if ( cc > 0 )
        return(cc - 2);     //  CompareString returns values in the 1..3 range
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcscmpLoc(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault, 0, string1, -1, string2, -1);

    if ( cc > 0 )
        return(cc - 2);     //  CompareString returns values in the 1..3 range
    else
        return _NLSCMPERROR;
}


// Matches behavior of CRT's _wcsicmp -- case insensitive, lexographic (i.e. stringsort
// instead of wordsort), locale insensitive.
RETURN_TYPE
_wcsicmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(0,   // deliberately NOT locale sensitive
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE | SORT_STRINGSORT,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}

RETURN_TYPE
_tcsicmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsicmpLoc(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}



RETURN_TYPE
_tcsncmp(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       0,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsncmpLoc(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       0,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
            return(cc - 2);
    else
        return _NLSCMPERROR;
}

RETURN_TYPE
_tcsnicmp(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant, 
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsnicmpLoc(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}


//
// CONSIDER -- would it be better to have these inline?
//

RETURN_TYPE
_istspace(TCHAR ch)
{
    return IsCharSpace(ch);
}

RETURN_TYPE
_istdigit(TCHAR ch)
{
    return IsCharDigit(ch);
}

RETURN_TYPE
_istxdigit(TCHAR ch)
{
    return IsCharXDigit(ch);
}

RETURN_TYPE
_istalpha(TCHAR ch)
{
    return IsCharAlpha(ch);
}

RETURN_TYPE
_istalnum(TCHAR ch)
{
    return IsCharAlphaNumeric(ch);
}

RETURN_TYPE
_istprint(TCHAR ch)
{
    return IsCharCntrl(ch) ? 0 : 1;
}

RETURN_TYPE
isspace(int ch)
{
    return IsCharSpace((USHORT)ch);
}

RETURN_TYPE
isdigit(int ch)
{
    WORD    charType;

    BOOL fRet = GetStringTypeExA(g_lcidLangInvariant, CT_CTYPE1, (LPCSTR) &ch, 1, &charType);
    if (!fRet)
        return 0;

    return (charType & C1_DIGIT) ? 1: 0;
}

RETURN_TYPE
isalpha(int ch)
{
    WORD    charType;

    BOOL fRet = GetStringTypeExA(g_lcidLangInvariant, CT_CTYPE1, (LPCSTR) &ch, 1, &charType);
    if (!fRet)
        return 0;

    return (charType & C1_ALPHA) ? 1: 0;
}

RETURN_TYPE
iswspace(wchar_t ch)
{
    return IsCharSpace(ch);
}

#endif // !WIN16

//+------------------------------------------------------------------------
//
//  Member:     _7csicmp
//
//  Synopsis:   Compare two 7 bit ascii strings case insensitive
//
//-------------------------------------------------------------------------

int
_7csicmp(const TCHAR *pch1, const TCHAR *pch2)
{
    while (*pch1)
    {
        TCHAR ch1 = *pch1 >= _T('a') && *pch1 <= _T('z') ?
                *pch1 + _T('A') - _T('a') : *pch1;

        TCHAR ch2 = *pch2 >= _T('a') && *pch2 <= _T('z') ?
                *pch2 + _T('A') - _T('a') : *pch2;

        if (ch1 > ch2)
            return 1;
        else if (ch1 < ch2)
            return -1;

        pch1 += 1;
        pch2 += 1;
    }

    return *pch2 ? -1 : 0;
}


//+------------------------------------------------------------------------
//
//  Member:     _7cscmp
//
//  Synopsis:   Compare two 7 bit ascii strings case insensitive
//
//-------------------------------------------------------------------------

int
_7cscmp(const TCHAR *pch1, const TCHAR *pch2)
{
    while (*pch1)
    {
        TCHAR ch1 = *pch1;
        TCHAR ch2 = *pch2;

        if (ch1 > ch2)
            return 1;
        else if (ch1 < ch2)
            return -1;

        pch1 += 1;
        pch2 += 1;
    }

     return *pch2 ? -1 : 0;
}

BOOL
_7csnipre(const TCHAR * pch1, int cch1, const TCHAR * pch2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(pch1);
    if (cch2 == -1)
        cch2 = _tcslen(pch2);
    if (cch1 <= cch2)
    {
        while (cch1)
        {
            TCHAR ch1 = *pch1 >= _T('a') && *pch1 <= _T('z') ?
                    *pch1 + _T('A') - _T('a') : *pch1;

            TCHAR ch2 = *pch2 >= _T('a') && *pch2 <= _T('z') ?
                    *pch2 + _T('A') - _T('a') : *pch2;

            if (ch1 != ch2)
                return FALSE;

            pch1 += 1;
            pch2 += 1;
            cch1--;
        }
        return TRUE;
    }
    else
        return FALSE;
}

const TCHAR * __cdecl _tcsistr (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(g_lcidLangInvariant,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}
const TCHAR * __cdecl _tcsistrLoc (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(g_lcidUserDefault,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\fontlinkcore\fontlinkcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       fontlinkcf.cxx
//
//  Contents:   Class factory for fontlinking objects.
//
//----------------------------------------------------------------------------

#ifndef X_FONTLINKCORE_HXX_
#define X_FONTLINKCORE_HXX_
#include "fontlinkcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef NEVER 

extern CUnicodeRanges g_UnicodeRanges;

CFontLinkCF::CFontLinkCF()
{
    _cRef = 0;
    AddRef();
}

CFontLinkCF::~CFontLinkCF()
{
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::QueryInterface(
    REFIID riid,
    void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (IsEqualGUID(IID_IClassFactory, riid))
    {
        *ppvObject = static_cast<IClassFactory *>(this);
    }

    if (*ppvObject)
    {
        static_cast<IUnknown *>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CFontLinkCF::AddRef()
{
    InterlockedIncrement(reinterpret_cast<long *>(&_cRef));
    return _cRef;
}

ULONG STDMETHODCALLTYPE CFontLinkCF::Release()
{
    InterlockedDecrement(reinterpret_cast<long *>(&_cRef));

    //_ASSERT(_cRef != 0);    // This object is created on the stack

    return _cRef;
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID riid, 
    void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    // Just say no to aggregation.
    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Query for requested interface
    if (IsEqualGUID(IID_IUnicodeScriptMapper, riid))
    {
        return g_UnicodeRanges.QueryInterface(riid, ppvObject);
    }

    // Query for requested interface
    return QueryInterface(riid, ppvObject);
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::LockServer(
    BOOL fLock)
{
    if (fLock)
        AddRef();
    else
        Release();

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\f3\trirt\sbheap.c ===
/***
*sbheap.c -  Small-block heap code
*
*       Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Core code for small-block heap.
*
*******************************************************************************/

#define _CRTBLD 1

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4244)
#pragma warning(disable:4514)
#pragma warning(disable:4711) /* function 'function' selected for inline expansion */
#define WIN32_LEAN_AND_MEAN
#include <stdlib.h>
#include <string.h>
#include "winheap.h"
#include <windows.h>
#include <limits.h>

#if DBG==1
#define OUTDBG(x)   OutputDebugStringA("TRI SBHEAP: " x "\r\n")
#else
#define OUTDBG(x)
#endif

extern HANDLE g_hProcessHeap;

__sbh_region_t __small_block_heap = {
        &__small_block_heap,
        &__small_block_heap,
        0,
        0,
        {(__map_t)(-1)},
        {(__map_t)(-1)},
        NULL };

static __sbh_region_t *__sbh_p_starting_region = &__small_block_heap;

static int __sbh_decommitable_pages = 0;

/*
 * Prototypes for user functions.
 */
size_t __cdecl _get_sbh_threshold(void);
int    __cdecl _set_sbh_threshold(size_t);


/***
*size_t _get_sbh_threshold() - return small-block threshold
*
*Purpose:
*       Return the current value of __sbh_threshold
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _get_sbh_threshold (
        void
        )
{
        return __sbh_threshold;
}


/***
*int _set_sbh_threshold(size_t threshold) - set small-block heap threshold
*
*Purpose:
*       Set the upper limit for the size of an allocation which will be
*       supported from the small-block heap. It is required that at least two
*       allocations can come from a page. This imposes an upper limit on how
*       big the new threshold can  be.
*
*Entry:
*       size_t  threshold   - proposed new value for __sbh_theshold
*
*Exit:
*       Returns 1 if successful. Returns 0 if threshold was too big.
*
*Exceptions:
*
*******************************************************************************/

#if 0
int __cdecl _set_sbh_threshold (
        size_t threshold
        )
{
        /*
         * Round up the proposed new value to the nearest paragraph
         */
        threshold = (threshold + _PARASIZE - 1) & ~(_PARASIZE - 1);

        /*
         * Require that at least two allocations be can be made within a
         * page.
         */
        if ( threshold <= (_PARASIZE * (_PARAS_PER_PAGE / 2)) ) {
            __sbh_threshold = threshold;
            return 1;
        }
        else
            return 0;
}
#endif

/***
*__sbh_region_t * __sbh_new_region() - get a region for the small-block heap
*
*Purpose:
*       Creates and adds a new region for the small-block heap. First, a
*       descriptor (__sbh_region_t) is obtained for the new region. Next,
*       VirtualAlloc() is used to reserved an address space of size
*       _PAGES_PER_REGION * _PAGESIZE_, and the first _PAGES_PER_COMMITTMENT
*       pages are committed.
*
*       Note that if __small_block_heap is available (i.e., the p_pages field
*       is NULL), it becomes the descriptor for the new regions. This is
*       basically the small-block heap initialization.
*
*Entry:
*       No arguments.
*
*Exit:
*       If successful, a pointer to the descriptor for the new region is
*       returned. Otherwise, NULL is returned.
*
*******************************************************************************/

__sbh_region_t * __cdecl __sbh_new_region(
        void
        )
{
        __sbh_region_t *pregnew;
        __sbh_page_t *  ppage;
        int             i;

        /*
         * Get a region descriptor (__sbh_region_t). If __small_block_heap is
         * available, always use it.
         */
        if ( __small_block_heap.p_pages == NULL ) {
            pregnew = &__small_block_heap;
        }
        else {
            /*
             * Allocate space for the new __sbh_region_t structure. Note that
             * this allocation comes out of the 'big block heap.
             */
            if ( (pregnew = HeapAlloc( g_hProcessHeap, 0, sizeof(__sbh_region_t) ))
                 == NULL )
                return NULL;
        }

        /*
         * Reserve a new contiguous address range (i.e., a region).
         */
        if ( (ppage = VirtualAlloc( NULL,
                                    _PAGESIZE_ * _PAGES_PER_REGION,
                                    MEM_RESERVE,
                                    PAGE_READWRITE )) != NULL )
        {
            /*
             * Commit the first _PAGES_PER_COMMITMENT of the new region.
             */
            if ( VirtualAlloc( ppage,
                               _PAGESIZE_ * _PAGES_PER_COMMITMENT,
                               MEM_COMMIT,
                               PAGE_READWRITE ) != NULL )
            {
                /*
                 * Insert *pregnew into the linked list of regions (just
                 * before __small_block_heap)
                 */
                if ( pregnew == &__small_block_heap ) {
                    if ( __small_block_heap.p_next_region == NULL )
                        __small_block_heap.p_next_region =
                            &__small_block_heap;
                    if ( __small_block_heap.p_prev_region == NULL )
                        __small_block_heap.p_prev_region =
                            &__small_block_heap;
                }
                else {
                    pregnew->p_next_region = &__small_block_heap;
                    pregnew->p_prev_region = __small_block_heap.p_prev_region;
                    __small_block_heap.p_prev_region = pregnew;
                    pregnew->p_prev_region->p_next_region = pregnew;
                }

                /*
                 * Fill in the rest of *pregnew
                 */
                pregnew->p_pages = ppage;
                pregnew->starting_page_index = 0;
                pregnew->first_uncommitted_index = _PAGES_PER_COMMITMENT;

                /*
                 * Initialize pregnew->region_map[].
                 */
                for ( i = 0 ; i < _PAGES_PER_REGION ; i++ ) {

                    if ( i < _PAGES_PER_COMMITMENT )
                        pregnew->region_map[i] = (__map_t)_PARAS_PER_PAGE;
                    else
                        pregnew->region_map[i] = _UNCOMMITTED_PAGE;

                    pregnew->last_failed_alloc[i] = _NO_FAILED_ALLOC;
                }

                /*
                 * Initialize pages
                 */
                while ( ppage < pregnew->p_pages + _PAGES_PER_COMMITMENT ) {
                    ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                    ppage->free_paras_at_start = _PARAS_PER_PAGE;
                    memset(ppage->alloc_map, 0, sizeof(ppage->alloc_map));
#ifdef _MARK_SBH
                    *(DWORD *)&ppage->sentinel = 0x486253FF;    // SbH
#else
                    ppage->sentinel = (__map_t)-1;
#endif
                    ppage->preg = &__small_block_heap;
                    ++ppage;
                }

                /*
                 * Return success
                 */
                return pregnew;
            }
            else {
                /*
                 * Couldn't commit the pages. Release the address space .
                 */
                VirtualFree( ppage, 0, MEM_RELEASE );
            }
        }

        /*
         * Unable to create the new region. Free the region descriptor, if necessary.
         */
        if ( pregnew != &__small_block_heap )
            HeapFree(g_hProcessHeap, 0, pregnew);

        /*
         * Return failure.
         */
        return NULL;
}


/***
*void __sbh_release_region(preg) - release region
*
*Purpose:
*       Release the address space associated with the specified region
*       descriptor. Also, free the specified region descriptor and update
*       the linked list of region descriptors if appropriate.
*
*Entry:
*       __sbh_region_t *    preg    - pointer to descriptor for the region to
*                                     be released.
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_release_region(
        __sbh_region_t *preg
        )
{
        /*
         * Release the passed region
         */
        VirtualFree( preg->p_pages, 0, MEM_RELEASE);

        /*
         * Update __sbh_p_starting_region, if necessary
         */
        if ( __sbh_p_starting_region == preg )
            __sbh_p_starting_region = preg->p_prev_region;

        if ( preg != &__small_block_heap ) {
            /*
             * Update linked list of region descriptors.
             */
            preg->p_prev_region->p_next_region = preg->p_next_region;
            preg->p_next_region->p_prev_region = preg->p_prev_region;

            /*
             * Free the region desciptor
             */
            HeapFree(g_hProcessHeap, 0, preg);
        }
        else {
            /*
             * Mark p_pages as NULL to indicate __small_block_heap is not
             * associated with any region (and can be reused). This the only
             * region descriptor for which this is supported.
             */
            __small_block_heap.p_pages = NULL;
        }
}


/***
*void __sbh_decommit_pages(count) - decommit specified number of pages
*
*Purpose:
*       Decommit count pages, if possible, in reverse (i.e., last to
*       first) order. If this results in all the pages in any region being
*       uncommitted, the region is released.
*
*Entry:
*       int count   -  number of pages to decommit
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_decommit_pages(
        int             count
        )
{
        __sbh_region_t *preg1;
        __sbh_region_t *preg2;
        __map_t *       pmap;
        int             page_decommitted_flag;
        int             i;

        /*
         * Scan the regions of the small-block heap, in reverse order. looking
         * for pages which can be decommitted.
         */
        preg1 = __small_block_heap.p_prev_region;
        do {
            if ( preg1->p_pages != NULL ) {
                /*
                 * Scan the pages in *preg1, in reverse order, looking for
                 * pages which can be decommitted.
                 */
                for ( i = _PAGES_PER_REGION - 1, page_decommitted_flag = 0,
                        pmap = &((preg1->region_map)[i]) ;
                      i >= 0 ; i--, pmap-- )
                {
                    /*
                     * Check if the pool page is unused and, if so, decommit it.
                     */
                    if ( *pmap == _PARAS_PER_PAGE ) {
                        if ( VirtualFree((preg1->p_pages) + i, _PAGESIZE_,
                                         MEM_DECOMMIT) )
                        {
                            /*
                             * Mark the page as uncommitted, update the count
                             * (global) decommitable pages, update the
                             * first_uncommitted_index field of the region
                             * descriptor, set the flag indicating at least
                             * one page has been decommitted in the region,
                             * and decrement count.
                             */
                            *pmap = _UNCOMMITTED_PAGE;

                            __sbh_decommitable_pages--;

                            if ( (preg1->first_uncommitted_index == _NO_INDEX)
                                 || (preg1->first_uncommitted_index > i) )
                                preg1->first_uncommitted_index = i;

                            page_decommitted_flag++;
                            if ( --count == 0 )
                                break;
                        }
                    }
                }

                /*
                 * 'Decrement' the preg1 pointer, but save a copy in preg2 in
                 * case the region needs to be released.
                 */
                preg2 = preg1;
                preg1 = preg1->p_prev_region;

                /*
                 * If appropriate, determine if all the pages in the region
                 * are uncommitted so that the region can be released.
                 */
                if ( page_decommitted_flag &&
                    ((preg2->region_map)[0] == _UNCOMMITTED_PAGE) )
                {

                    for ( i = 1, pmap = &((preg2->region_map)[1]) ;
                          (i < _PAGES_PER_REGION) &&
                            (*pmap == _UNCOMMITTED_PAGE) ;
                          i++, pmap++ );

                    if ( i == _PAGES_PER_REGION )
                        __sbh_release_region(preg2);
                }
            }
        }
        while ( (preg1 != __small_block_heap.p_prev_region) && (count > 0) );
}


/***
*__map_t *__sbh_find_block(pblck, ppreg, pppage) - find block in small-block
*       heap
*
*Purpose:
*       Determine if the specified allocation block lies in the small-block
*       heap and, if so, return the region, page and starting paragraph index
*       of the block.
*
*Entry:
*       void *              pblck   - pointer to block to be freed
*       __sbh_region_t **   ppreg   - pointer to a pointer to the region
*                                     holding *pblck, if found
*       __sbh_page_t **     pppage  - pointer to a pointer to the page holding
*                                     *pblck, if found
*
*Exit:
*       If successful, a pointer to the starting alloc_map[] entry for the
*       allocation block is returned.
*       If unsuccessful, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

__map_t * __cdecl __sbh_find_block (
        void *              pblck,
        __sbh_region_t **   ppreg,
        __sbh_page_t   **   pppage
        )
{
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;

        preg = &__small_block_heap;
        do
        {
            /*
             * Does the block lie within this small heap region?
             */
            if ( (preg->p_pages != NULL) &&
                 (pblck > (void *)preg->p_pages) &&
                 (pblck < (void *)(preg->p_pages + _PAGES_PER_REGION)) )
            {
                /*
                 * Yes, fill copy the region and page through the
                 * passed pointers.
                 */
                *ppreg = preg;
                *pppage = ppage = (__sbh_page_t *)((DWORD_PTR)pblck &
                                  ~(_PAGESIZE_ - 1));

                /*
                 * Return the alloc_map[] index of the block.
                 */
                return ( &(ppage->alloc_map[0]) + ((__para_t *)pblck -
                         &(ppage->alloc_blocks[0])) );
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        return NULL;
}


/***
*void __sbh_free_block(preg, ppage, pmap) - free block
*
*Purpose:
*       Free the specified block from the small-block heap.
*
*Entry:
*       __sbh_region_t *preg        - pointer to the descriptor for the
*                                     region containing the block
*       __sbh_page_t *  ppage       - pointer to the page containing the
*                                     block
*       __map_t *       pmap        - pointer to the initial alloc_map[]
*                                     entry for the allocation block
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_free_block (
        __sbh_region_t *preg,
        __sbh_page_t *  ppage,
        __map_t *       pmap
        )
{
        int             page_index;

        /*
         * Update the region_map[] entry.
         */
        page_index = (int)(ppage - (preg->p_pages));
        preg->region_map[page_index] += (int)*pmap;

        /*
         * Mark the alloc_map[] entry as free
         */
        *pmap = _FREE_PARA;

        /*
         * Clear the last_failed_alloc[] entry for the page.
         */
        preg->last_failed_alloc[page_index] = _NO_FAILED_ALLOC;

        /*
         * Check if the count of decommitable pages needs to be updated, and
         * if some pages need to be decommited.
         */
        if ( (preg->region_map)[page_index] == _PARAS_PER_PAGE )
            if ( ++__sbh_decommitable_pages == 2 * _PAGES_PER_COMMITMENT )
                __sbh_decommit_pages(_PAGES_PER_COMMITMENT);
}


/***
*void * __sbh_alloc_block(para_req) - allocate a block
*
*Purpose:
*       Allocate a block from the small-block heap, the specified number of
*       paragraphs in size.
*
*Entry:
*       size_t  para_req    - size of the allocation request in paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, if failure.
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl __sbh_alloc_block (
        size_t          para_req
        )
{
        __sbh_region_t  *preg;
        __sbh_page_t    *ppage;
        void *          retp;
        int             i, j;

        /*
         * Prevent allocation of zero paragraphs because it will trash the heap.
         */

        if (para_req == 0)
        {
            #if DBG==1
            OUTDBG("Attempt to allocate zero paragraphs");
            DebugBreak();
            #endif
            return NULL;
        }

        /*
         * First pass through the small-block heap. Try to satisfy the current
         * request from already committed pages.
         */
        preg = __sbh_p_starting_region;

        do {
            if ( preg->p_pages != NULL ) {
                /*
                 * Search from starting_page_index to the end of the region.
                 */
                for ( i = preg->starting_page_index ; i < _PAGES_PER_REGION ;
                      i++ )
                {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (preg->region_map[i] >= para_req) &&
                         (preg->region_map[i] != _UNCOMMITTED_PAGE) &&
                         (preg->last_failed_alloc[i] > para_req) )
                    {
                        if ( (retp = __sbh_alloc_block_from_page(
                                        preg->p_pages + i,
                                        (int)(preg->region_map[i]),
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __sbh_p_starting_region.
                             *  Update the region_map[] entry for the page.
                             *  Update the starting_page_index in the region.
                             *  Return a pointer to the allocated block.
                             */
                            __sbh_p_starting_region = preg;
                            preg->region_map[i] -= (__map_t)para_req;
                            preg->starting_page_index = i;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc[] entry.
                             */
                            preg->last_failed_alloc[i] = (__map_t)para_req;
                        }
                    }
                }

                /*
                 * If necessary, search from 0 page to search_start_index.
                 */
                for ( i = 0 ; i < preg->starting_page_index ; i++ ) {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (preg->region_map[i] >= para_req) &&
                         (preg->region_map[i] != _UNCOMMITTED_PAGE) &&
                         (preg->last_failed_alloc[i] > para_req) )
                    {
                        if ( (retp = __sbh_alloc_block_from_page(
                                        preg->p_pages + i,
                                        (int)(preg->region_map[i]),
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __sbh_p_starting_region.
                             *  Update the region_map[] entry for the page
                             *  Update the starting_page_index in the region.
                             *  Return a pointer to the allocated block.
                             */
                            __sbh_p_starting_region = preg;
                            preg->region_map[i] -= (__map_t)para_req;
                            preg->starting_page_index = i;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc[] entry.
                             */
                            preg->last_failed_alloc[i] = (__map_t)para_req;
                        }
                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != __sbh_p_starting_region );

        /*
         * Second pass through the small-block heap. This time, look for an
         * uncommitted page. Also, start at __small_block_heap rather than at
         * *__sbh_p_starting_region.
         */
        preg = &__small_block_heap;

        do
        {
            if ( (preg->p_pages != NULL) &&
                 (preg->first_uncommitted_index != _NO_INDEX) )
            {
                i = preg->first_uncommitted_index;
                j = __min( i + _PAGES_PER_COMMITMENT, _PAGES_PER_REGION );

                /*
                 * Determine how many adjacent pages, up to
                 * _PAGES_PER_COMMITMENT, are uncommitted (and can now be
                 * committed)
                 */
                for ( i++ ;
                      (i < j) && (preg->region_map[i] == _UNCOMMITTED_PAGE) ;
                      i++ ) ;

                /*
                 * Commit the pages.
                 */
                if ( VirtualAlloc( (void *)(preg->p_pages +
                                        preg->first_uncommitted_index),
                                   (i - preg->first_uncommitted_index) *
                                        _PAGESIZE_,
                                   MEM_COMMIT,
                                   PAGE_READWRITE ) ==
                     (preg->p_pages + preg->first_uncommitted_index) )
                {
                    /*
                     * Initialize the committed pages.
                     */
                    for ( j = preg->first_uncommitted_index,
                            ppage = preg->p_pages + j ;
                          j < i ; j++, ppage++ )
                    {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = _PARAS_PER_PAGE;
                        memset(ppage->alloc_map, 0, sizeof(ppage->alloc_map));
#ifdef _MARK_SBH
                        *(DWORD *)&ppage->sentinel = 0x486253FF;    // SbH
#else
                        ppage->sentinel = (__map_t)-1;
#endif
                        ppage->preg = &__small_block_heap;
                        preg->region_map[j] = _PARAS_PER_PAGE;
                        preg->last_failed_alloc[j] = _NO_FAILED_ALLOC;
                    }

                    /*
                     * Update __sbh_p_starting_region
                     */
                    __sbh_p_starting_region = preg;

                    /*
                     * Update the first_uncommitted_index for the region.
                     */
                    while ( (i < _PAGES_PER_REGION) &&
                            (preg->region_map[i] != _UNCOMMITTED_PAGE) )
                        i++;

                    j = preg->first_uncommitted_index;

                    preg->first_uncommitted_index = (i < _PAGES_PER_REGION) ?
                                                    i : _NO_INDEX;

                    /*
                     * Fulfill the allocation request using the first of the
                     * newly committed pages.
                     */
                    ppage = preg->p_pages + j;
                    ppage->alloc_map[0] = (__map_t)para_req;

                    /*
                     * Update the starting_page_index field in the region
                     * descriptor and region_map[] entry for the page. Also,
                     * update the starting_para_index field in the page.
                     */
                    preg->starting_page_index = j;
                    preg->region_map[j] -= (__map_t)para_req;

                    /*
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields of the page.
                     */
                    ppage->pstarting_alloc_map = &(ppage->alloc_map[para_req]);
                    ppage->free_paras_at_start -= para_req;

                    /*
                     * Return pointer to allocated paragraphs.
                     */
                    return (void *)&(((preg->p_pages + j)->alloc_blocks)[0]);
                }
                else {
                    /*
                     * Attempt to commit the pages failed. Return failure, the
                     * allocation will be attempted in the Win32 heap manager.
                     */
                    return NULL;
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        /*
         * Failure so far. None of the pages have a big enough free area to
         * fulfill the pending request. All of the pages in all of the current
         * regions are committed. Therefore, try to create a new region.
         */
        if ( (preg = __sbh_new_region()) != NULL ) {
            /*
             * Success! A new region has been created and the first few pages
             * (_PAGES_PER_COMMITMENT to be exact) have been committed.
             * satisfy the request out of the first page of the new region.
             */
            ppage = preg->p_pages;
            ppage->alloc_map[0] = (__map_t)para_req;

            __sbh_p_starting_region = preg;
            ppage->pstarting_alloc_map = &(ppage->alloc_map[para_req]);
            ppage->free_paras_at_start = _PARAS_PER_PAGE - para_req;
            (preg->region_map)[0] -= (__map_t)para_req;
            return (void *)&((preg->p_pages->alloc_blocks)[0]);
        }

        /*
         * Everything has failed, return NULL
         */
        return NULL;
}


/***
*void * __sbh_alloc_block_from_page(ppage, free_para_count, para_req) -
*       allocate a block from the given page.
*
*Purpose:
*       Allocate a block from the specified page of the small-block heap, of
*       the specified number of paragraphs in size.
*
*Entry:
*       __sbh_page_t *  ppage           - pointer to a page in the small-block
*                                         heap
*       int             free_para_count - number of free paragraphs in *ppage
*       size_t          para_req        - size of the allocation request in
*                                         paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, otherwise.
*
*Exceptions:
*       It is assumed that free_para_count >= para_req on entry. This must be
*       guaranteed by the caller. The behavior is undefined if this condition
*       is violated.
*
*******************************************************************************/

void * __cdecl __sbh_alloc_block_from_page (
        __sbh_page_t *  ppage,
        size_t          free_para_count,
        size_t          para_req
        )
{
        __map_t *   pmap1;
        __map_t *   pmap2;
        __map_t *   pstartmap;
        size_t      contiguous_free;

        /*
         * Start at start_para_index and walk towards the end of alloc_map[],
         * looking for a string of free paragraphs big enough to satisfy the
         * the current request.
         */
        pmap1 = pstartmap = ppage->pstarting_alloc_map;

        /*
         * Check if there are enough free paragraphs are pstarting_alloc_map
         * to satisfy the pending allocation request.
         */
        if ( ppage->free_paras_at_start >= para_req ) {
            /*
             * Success right off!
             * Mark the alloc_map entry with the size of the allocation
             * request.
             */
            *pmap1 = (__map_t)para_req;

            /*
             * Update the pstarting_alloc_map and free_paras_at_start fields
             * in the page.
             */
            if ( pmap1 + para_req < &(ppage->sentinel) ) {
                ppage->pstarting_alloc_map += para_req;
                ppage->free_paras_at_start -= para_req;
            }
            else {
                ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                ppage->free_paras_at_start = 0;
            }

            /*
             * Derive and return a pointer to the newly allocated
             * paragraphs.
             */
            return (void *)&(ppage->alloc_blocks[pmap1 -
                &(ppage->alloc_map[0])]);
        }

        /*
         * See if the search loop can be started just beyond the paragraphs
         * examined above. Note, this test assumes sentinel != _FREE_PARA!
         */
        if ( *(pmap1 + ppage->free_paras_at_start) != _FREE_PARA )
            pmap1 += ppage->free_paras_at_start;

        while ( pmap1 + para_req < &ppage->sentinel ) {

            if ( *pmap1 == _FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request. Note that the loop below requires that
                 * sentinel != _FREE_PARA to guarantee termination.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs. Do
                     * a little bookkeeping before going on to the next
                     * interation.
                     */

                     /* If pmap1 != pstartmap then these free paragraphs
                     * cannot be revisited.
                     */
                    if ( pmap1 == pstartmap ) {
                        /*
                         * Make sure free_paras_at_start is up-to-date.
                         */
                         ppage->free_paras_at_start = contiguous_free;
                    }
                    else {
                        /*
                         * These free paragraphs will not be revisited!
                         */
                        if ( (free_para_count -= contiguous_free) < para_req )
                            /*
                             * There are not enough unvisited free paragraphs
                             * to satisfy the current request. Return failure
                             * to the caller.
                             */
                            return NULL;
                    }

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields in the page.
                     */
                    if ( pmap1 + para_req < &(ppage->sentinel) ) {
                        ppage->pstarting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = (DWORD)(contiguous_free -
                                                     para_req);
                    }
                    else {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Now start at index 0 in alloc_map[] and walk towards, but not past,
         * index starting_para_index, looking for a string of free paragraphs
         * big enough to satisfy the allocation request.
         */
        pmap1 = &(ppage->alloc_map[0]);

        while ( (pmap1 < pstartmap) &&
                (pmap1 + para_req <= &(ppage->alloc_map[_PARAS_PER_PAGE - 1])) )
        {
            if ( *pmap1 == _FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs.
                     *
                     * Update the count of unvisited free paragraphs.
                     */
                    if ( (free_para_count -= contiguous_free) < para_req )
                        /*
                         * There are not enough unvisited free paragraphs
                         * to satisfy the current request. Return failure
                         * to the caller.
                         */
                        return NULL;

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields in the page..
                     */
                    if ( pmap1 + para_req < &(ppage->sentinel) ) {
                        ppage->pstarting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = (DWORD)(contiguous_free -
                                                     para_req);
                    }
                    else {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Return failure.
         */
        return NULL;
}


/***
*size_t __sbh_resize_block(preg, ppage, pmap, new_para_sz) -
*       resize block
*
*Purpose:
*       Resize the specified block from the small-block heap. The allocation
*       block is not moved.
*
*Entry:
*       __sbh_region_t *preg        - pointer to the descriptor for the
*                                     region containing the block
*       __sbh_page_t *  ppage       - pointer to the page containing the
*                                     block
*       __map_t *       pmap        - pointer to the initial alloc_map[]
*                                     entry for the allocation block
*       size_t          new_para_sz - requested new size for the allocation
*                                     block, in paragraphs.
*
*Exit:
*       Returns 1, if successful. Otherwise, 0 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_resize_block (
        __sbh_region_t *preg,
        __sbh_page_t *  ppage,
        __map_t *       pmap,
        size_t          new_para_sz
        )
{
        __map_t *       pmap2;
        __map_t *       pmap3;
        size_t          old_para_sz;
        size_t          free_para_count;
        int             retval = 0;

        if ( (old_para_sz = *pmap) > new_para_sz ) {
            /*
             *  The allocation block is to be shrunk.
             */
            *pmap = (__map_t)new_para_sz;

            preg->region_map[ppage - preg->p_pages] += (__map_t)(old_para_sz - new_para_sz);
            preg->last_failed_alloc[ppage - preg->p_pages] = _NO_FAILED_ALLOC;

            retval++;
        }
        else if ( old_para_sz < new_para_sz ) {
            /*
             * The allocation block is to be grown to new_para_sz paragraphs
             * (if possible).
             */
            if ( pmap + new_para_sz <= &(ppage->sentinel) ) {
                /*
                 * Determine if there are sufficient free paragraphs to
                 * expand the block to the desired new size.
                 */
                for ( pmap2 = pmap + old_para_sz,
                        pmap3 = pmap + new_para_sz ;
                      (pmap2 < pmap3) && (*pmap2 == _FREE_PARA) ;
                      pmap2++ ) ;

                if ( pmap2 == pmap3 ) {
                    /*
                     * Success, mark the resized allocation
                     */
                    *pmap = (__map_t)new_para_sz;

                    /*
                     * Check whether the pstarting_alloc_map and the
                     * free_paras_at_start fields need to be updated.
                     */
                    if ( (pmap <= ppage->pstarting_alloc_map) &&
                         (pmap3 > ppage->pstarting_alloc_map) )
                    {
                        if ( pmap3 < &(ppage->sentinel) ) {
                            ppage->pstarting_alloc_map = pmap3;
                            /*
                             * Determine how many contiguous free paragraphs
                             * there are starting a *pmap3. Note, this assumes
                             * that sentinel != _FREE_PARA.
                             */
                            for ( free_para_count = 0 ; *pmap3 == _FREE_PARA ;
                                  free_para_count++, pmap3++ ) ;
                            ppage->free_paras_at_start = free_para_count;
                        }
                        else {
                            ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                            ppage->free_paras_at_start = 0;
                        }
                    }

                    /*
                     * Update the region_map[] entry.
                     */
                    preg->region_map[ppage - preg->p_pages] -=
                        (__map_t)(new_para_sz - old_para_sz);

                    retval++;
                }
            }
        }

        return retval;
}


/***
*void * __sbh_heap_check() - check small-block heap
*
*Purpose:
*       Perform validity checks on the small-block heap.
*
*Entry:
*       There are no arguments.
*
*Exit:
*       Returns 0 if the small-block is okay.
*       Returns < 0 if the small-block heap has an error. The exact value
*       identifies where, in the source code below, the error was detected.
*
*Exceptions:
*       There is no protection against memory access error (exceptions).
*
*******************************************************************************/

int __cdecl __sbh_heap_check (
        void
        )
{
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        int                 uncommitted_pages;
        int                 free_paras_in_page;
        int                 contiguous_free_paras;
        int                 starting_region_found;
        int                 pstarting_alloc_map_found;
        int                 i, j, k;

        starting_region_found = 0;
        preg = &__small_block_heap;
        do {
            if ( __sbh_p_starting_region == preg )
                starting_region_found++;

            if ( (ppage = preg->p_pages) != NULL ) {
                /*
                 * Scan the pages of the region looking for
                 * inconsistencies.
                 */
                for ( i = 0, uncommitted_pages = 0, ppage = preg->p_pages ;
                      i < _PAGES_PER_REGION ;
                      i++, ppage++ )
                {
                    if ( preg->region_map[i] == _UNCOMMITTED_PAGE ) {
                        /*
                         * Verify the first_uncommitted_index field.
                         */
                        if ( (uncommitted_pages == 0) &&
                             (preg->first_uncommitted_index != i) )
                        {
                            OUTDBG("Bad first_uncommitted_index field");
                            return -1;
                        }

                        uncommitted_pages++;
                    }
                    else {

                        if ( ppage->pstarting_alloc_map >=
                             &(ppage->sentinel) )
                        {
                            OUTDBG("Bad pstarting_alloc_map field");
                            return -2;
                        }

                        if ( ppage->sentinel != (__map_t)-1 )
                        {
                            OUTDBG("Bad sentinel field");
                            return -3;
                        }

                        /*
                         * Scan alloc_map[].
                         */
                        j  = 0;
                        pstarting_alloc_map_found = 0;
                        free_paras_in_page = 0;
                        contiguous_free_paras = 0;

                        while ( j < _PARAS_PER_PAGE ) {
                            /*
                             * Look for the *pstarting_alloc_map.
                             */
                            if ( &(ppage->alloc_map[j]) ==
                                 ppage->pstarting_alloc_map )
                                pstarting_alloc_map_found++;

                            if ( ppage->alloc_map[j] == _FREE_PARA ) {
                                /*
                                 * Free paragraph, increment the count.
                                 */
                                free_paras_in_page++;
                                contiguous_free_paras++;
                                j++;
                            }
                            else {
                                /*
                                 * First paragraph of an allocated block.
                                 */

                                /*
                                 * Make sure the preceding free block, if any,
                                 * was smaller than the last_failed_alloc[]
                                 * entry for the page.
                                 */
                                if ( contiguous_free_paras >=
                                     (int)preg->last_failed_alloc[i] )
                                {
                                     OUTDBG("last_failed_alloc[i] was mismarked!");
                                     return -4;
                                }

                                /*
                                 * If this is the end of the string of free
                                 * paragraphs starting at *pstarting_alloc_map,
                                 * verify that free_paras_at_start is
                                 * reasonable.
                                 */
                                if ( pstarting_alloc_map_found == 1 ) {
                                    if ( contiguous_free_paras <
                                         (int)ppage->free_paras_at_start )
                                    {
                                         OUTDBG("free_paras_at_start not reasonable");
                                         return -5;
                                    }
                                    else
                                        /*
                                         * Set flag to 2 so the check is not
                                         * repeated.
                                         */
                                        pstarting_alloc_map_found++;
                                }

                                contiguous_free_paras = 0;

                                /*
                                 * Scan the remaining paragraphs and make
                                 * sure they are marked properly (they should
                                 * look like free paragraphs).
                                 */
                                for ( k = j + 1 ;
                                      k < j + ppage->alloc_map[j] ; k++ )
                                {
                                    if ( ppage->alloc_map[k] != _FREE_PARA )
                                    {
                                        OUTDBG("alloc_map[k] is mismarked!");
                                        return -6;
                                    }
                                }

                                j = k;
                            }
                        }

                        if ( free_paras_in_page != preg->region_map[i] )
                        {
                            OUTDBG("region_map[i] does not match the number of free paragraphs in the page!");
                            return -7;
                        }

                        if ( pstarting_alloc_map_found == 0 )
                        {
                            OUTDBG("Bad pstarting_alloc_map field!");
                            return -8;
                        }
                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        if ( starting_region_found == 0 )
        {
            OUTDBG("Bad __sbh_p_starting_region!");
            return -9;
        }

        return 0;
}

int __cdecl __sbh_process_detach()
{
   __sbh_decommit_pages(INT_MAX);
   return(   __small_block_heap.p_next_region == &__small_block_heap
          && __small_block_heap.p_prev_region == &__small_block_heap
          && __small_block_heap.p_pages == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\fontlinkcore\unicoderanges.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       unicoderanges.cxx
//
//  Contents:   Object encapsulating Unicode ranges and it's properties.
//
//----------------------------------------------------------------------------

#ifndef X_FONTLINKCORE_HXX_
#define X_FONTLINKCORE_HXX_
#include "fontlinkcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
// The only one CUnicodeRanges object
//-----------------------------------------------------------------------------

CUnicodeRanges g_UnicodeRanges;

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::CUnicodeRanges
//
//-----------------------------------------------------------------------------

CUnicodeRanges::CUnicodeRanges()
{
    _cRef = 0;
    AddRef();
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::~CUnicodeRanges
//
//-----------------------------------------------------------------------------

CUnicodeRanges::~CUnicodeRanges()
{
    Assert(_cRef == 1); // This object is a global object.
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::QueryInterface
//
//  Synopsis:   Return a pointer to a specified interface on an object to 
//              which a client currently holds an interface pointer.
//
//  Arguments:  [riid]      - identifier of the requested interface
//              [ppvObject] - address of output variable that receives the 
//                            interface pointer requested in riid
//
//  Returns:    S_OK if the interface is supported, E_NOINTERFACE if not.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::QueryInterface(
    REFIID riid,        // [in]
    void ** ppvObject)  // [out]
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (IsEqualGUID(IID_IUnicodeScriptMapper, riid))
    {
        *ppvObject = static_cast<IUnicodeScriptMapper *>(this);
    }

    if (*ppvObject)
    {
        static_cast<IUnknown *>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::AddRef
//
//  Synopsis:   Increment the reference count of the object.
//
//  Returns:    The value of the new reference count.
//
//-----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CUnicodeRanges::AddRef()
{
    InterlockedIncrement(reinterpret_cast<long *>(&_cRef));
    return _cRef;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::Release
//
//  Synopsis:   Decrement the reference count of the object.
//
//  Returns:    The resulting value of the reference count.
//
//-----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CUnicodeRanges::Release()
{
    InterlockedDecrement(reinterpret_cast<long *>(&_cRef));

    Assert(_cRef != 0); // This object is a global object.

    return _cRef;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::GetScriptId
//
//  Synopsis:   Map Unicode character to an appropriate script id. In case of:
//              * sidAmbiguous - the caller should disambiguate script
//              * sidHan - the caller should ununify Han script
//              * sidMerge - the caller should merge with the previous character
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::GetScriptId(
    wchar_t ch,         // [in]
    byte * pScriptId)   // [out]
{
    if (pScriptId == NULL)
        return E_INVALIDARG;

    *pScriptId = ScriptIDFromCh(ch);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::GetScriptIdMulti
//
//  Synopsis:   Map string of Unicode characters to an appropriate script id. 
//              Will stop analyzing when finds a new script.
//              In case of:
//              * sidAmbiguous - the caller should disambiguate script
//              * sidHan - the caller should ununify Han script
//              * sidMerge - the caller should merge with the previous character
//
//  Arguments:  [pch]       - text buffer to analyze
//              [cch]       - number of characters to analyze
//              [pcchSplit] - number of characters analyzed
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::GetScriptIdMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL)
        return E_INVALIDARG;

    // TODO

    if (pcchSplit)
        *pcchSplit = cch;

    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::UnunifyHanScript
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a Han character.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::UnunifyHanScript(
    wchar_t ch,          // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    byte * pScriptId)    // [out]
{
    if ((pScriptId == NULL) || (sidHan != ScriptIDFromCh(ch)))
        return E_INVALIDARG;

    DWORD dwPriorityCodePages;
    long cch = 1;
    dwPriorityCodePages = (FS_JOHAB | FS_CHINESETRAD | FS_WANSUNG | FS_CHINESESIMP | FS_JISJAPAN);
    *pScriptId = ResolveAmbiguousScript(&ch, &cch, sidPrefered, sidsAvailable, 
                                        dwPriorityCodePages, (unsigned char)flags);

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::UnunifyHanScriptMulti
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a string of Han characters.
//              Will stop analyzing when finds a new script.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::UnunifyHanScriptMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(*pch);
    if (sidHan != sid && sidMerge != sid && sid != sidAmbiguous)
        return E_INVALIDARG;

    if (sid != sidAmbiguous)
    {
        DWORD dwPriorityCodePages;
        dwPriorityCodePages = (FS_JOHAB | FS_CHINESETRAD | FS_WANSUNG | FS_CHINESESIMP | FS_JISJAPAN);
        *pScriptId = ResolveAmbiguousScript(pch, &cch, sidPrefered, sidsAvailable, 
                                            dwPriorityCodePages, (unsigned char)flags);
    }
    else
    {
        *pScriptId = sidHan; // This character has been already disambiguated.
        cch = 1;
    }

    if (pcchSplit)
        *pcchSplit = cch;

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::DisambiguateScript
//
//  Synopsis:   Pick up one of valid script ids for an ambiguous character.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::DisambiguateScript(
    wchar_t ch,          // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    byte * pScriptId)    // [out]
{
    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(ch);
    if (sidAmbiguous != sid && sidMerge != sid)
        return E_INVALIDARG;

    long cch = 1;
    *pScriptId = ResolveAmbiguousScript(&ch, &cch, sidPrefered, sidsAvailable, 
                                        0xFFFFFFFF, (unsigned char)flags);

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::DisambiguateScriptMulti
//
//  Synopsis:   Pick up one of valid script ids for a string of ambiguous characters.
//              Will stop analyzing when finds a new script.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::DisambiguateScriptMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(*pch);
    if (sidAmbiguous != sid && sidMerge != sid)
        return E_INVALIDARG;

    *pScriptId = ResolveAmbiguousScript(pch, &cch, sidPrefered, sidsAvailable, 
                                        0xFFFFFFFF, (unsigned char)flags);

    if (pcchSplit)
        *pcchSplit = cch;

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::ResolveAmbiguousScript
//
//  Synopsis:   Relolve ambiguous script to a valid script.
//
//  Returns:    A valid script id, appropriate for passed Unicode string.
//
//-----------------------------------------------------------------------------

SCRIPT_ID CUnicodeRanges::ResolveAmbiguousScript(
    const wchar_t * pch,        // [in]
    long * pcch,                // [in, out]
    SCRIPT_ID sidPrefered,      // [in]
    SCRIPT_IDS sidsAvailable,   // [in]
    DWORD dwCPBit,              // [in]
    unsigned char uFlags)       // [in]
{
    DWORD dwCodePages;
    SCRIPT_ID sid;
    SCRIPT_IDS sidsText;

    dwCodePages = mlang().GetTextCodePages(dwCPBit, pch, pcch);
    sidsText = ScriptsFromCPBit(dwCodePages);

    if (   (sidPrefered != sidDefault)
        && (ScriptBit(sidPrefered) & sidsText)
       )
    {
        sid = sidPrefered;
    }
    else
    {
        // Prefer to use user default locale
        LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
        sidPrefered = ScriptIDFromLangID(lid);

        if (sidsAvailable & sidsText)
        {
            if (ScriptBit(sidPrefered) & sidsAvailable & sidsText)
                sid = sidPrefered;
            else
                sid = ScriptIDFromCPBit((CPBitFromScripts(sidsAvailable) & dwCodePages));
        }
        else if (uFlags & USM_AVAILABLESIDONLY)
        {
            sid = sidDefault;
        }
        else
        {
            if (ScriptBit(sidPrefered) & sidsText)
                sid = sidPrefered;
            else
                sid = ScriptIDFromCPBit(dwCodePages);
        }
    }

    return sid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intlcore\unisid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       unisid.cxx
//
//  Contents:   Unicode scripts helpers.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  g_asidScriptIDFromCharClass
//
//  Unicode partition to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidScriptIDFromCharClass[]=
{
    // CC           SCRIPT_ID
    /* WOB_   1*/   sidHan,
    /* NOPP   2*/   sidAsciiSym,
    /* NOPA   2*/   sidAsciiSym,
    /* NOPW   2*/   sidDefault,        // was sidLatin for no good reason
    /* HOP_   3*/   sidHalfWidthKana,
    /* WOP_   4*/   sidHan,
    /* WOP5   5*/   sidHan,
    /* NOQW   6*/   sidLatin,          // 00AB and 2039 only, new partition required
    /* AOQW   7*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* WOQ_   8*/   sidHan,
    /* WCB_   9*/   sidHan,
    /* NCPP  10*/   sidAsciiSym,
    /* NCPA  10*/   sidAsciiSym,
    /* NCPW  10*/   sidDefault,
    /* HCP_  11*/   sidHalfWidthKana,
    /* WCP_  12*/   sidHan,
    /* WCP5  13*/   sidHan,
    /* NCQW  14*/   sidLatin,
    /* ACQW  15*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* WCQ_  16*/   sidHan,
    /* ARQW  17*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* NCSA  18*/   sidAsciiSym,
    /* HCO_  19*/   sidHalfWidthKana,
    /* WC__  20*/   sidHan,
    /* WCS_  20*/   sidHan,
    /* WC5_  21*/   sidHan,
    /* WC5S  21*/   sidHan,
    /* NKS_  22*/   sidHalfWidthKana,
    /* WKSM  23*/   sidKana,
    /* WIM_  24*/   sidHan,
    /* NSSW  25*/   sidDefault,
    /* WSS_  26*/   sidHan,
    /* WHIM  27*/   sidKana,
    /* WKIM  28*/   sidKana,
    /* NKSL  29*/   sidHalfWidthKana,
    /* WKS_  30*/   sidKana,
    /* WKSC  30*/   sidKana,
    /* WHS_  31*/   sidKana,
    /* NQFP  32*/   sidAsciiSym,
    /* NQFA  32*/   sidAsciiSym,
    /* WQE_  33*/   sidHan,
    /* WQE5  34*/   sidHan,
    /* NKCC  35*/   sidHalfWidthKana,
    /* WKC_  36*/   sidKana,
    /* NOCP  37*/   sidAsciiSym,
    /* NOCA  37*/   sidAsciiSym,
    /* NOCW  37*/   sidLatin,
    /* WOC_  38*/   sidHan,
    /* WOCS  38*/   sidHan,
    /* WOC5  39*/   sidHan,
    /* WOC6  39*/   sidHan,
    /* AHPW  40*/   sidAmbiguous,
    /* NPEP  41*/   sidAsciiSym,
    /* NPAR  41*/   sidAmbiguous,
    /* HPE_  42*/   sidHalfWidthKana,
    /* WPE_  43*/   sidHan,
    /* WPES  43*/   sidHan,
    /* WPE5  44*/   sidHan,
    /* NISW  45*/   sidDefault,
    /* AISW  46*/   sidAmbiguous,      // if narrow, 2014 and 2026 should go to sidLatin, NP
    /* NQCS  47*/   sidAmbiguous,
    /* NQCW  47*/   sidAmbiguous,
    /* NQCC  47*/   sidAmbiguous,
    /* NPTA  48*/   sidAsciiSym,
    /* NPNA  48*/   sidAsciiSym,
    /* NPEW  48*/   sidLatin,          // would really require a new partition, NP
    /* NPEH  48*/   sidHebrew,
    /* NPEV  48*/   sidLatin,          // NEW Dong sign
    /* APNW  49*/   sidAmbiguous,
    /* HPEW  50*/   sidHangul,
    /* WPR_  51*/   sidHan,
    /* NQEP  52*/   sidAsciiSym,
    /* NQEW  52*/   sidLatin,          // would really require a new partition, NP
    /* NQNW  52*/   sidDefault,
    /* AQEW  53*/   sidAmbiguous,      // if narrow, 00B0, 2030 should go to sidLatin, NP
    /* AQNW  53*/   sidAmbiguous,
    /* AQLW  53*/   sidAmbiguous,
    /* WQO_  54*/   sidHan,
    /* NSBL  55*/   sidAsciiSym,
    /* WSP_  56*/   sidHan,
    /* WHI_  57*/   sidKana,
    /* NKA_  58*/   sidHalfWidthKana,
    /* WKA_  59*/   sidKana,
    /* ASNW  60*/   sidAmbiguous,      // if narrow, most should go to sidLatin, NP
    /* ASEW  60*/   sidAmbiguous,
    /* ASRN  60*/   sidAmbiguous,
    /* ASEN  60*/   sidAmbiguous,
    /* ALA_  61*/   sidLatin,
    /* AGR_  62*/   sidGreek,
    /* ACY_  63*/   sidCyrillic,
    /* WID_  64*/   sidHan,
    /* WPUA  65*/   sidEUDC,
    /* NHG_  66*/   sidHangul,
    /* WHG_  67*/   sidHangul,
    /* WCI_  68*/   sidHan,
    /* NOI_  69*/   sidHan,
    /* WOI_  70*/   sidHan,
    /* WOIC  70*/   sidHan,
    /* WOIL  70*/   sidHan,
    /* WOIS  70*/   sidHan,
    /* WOIT  70*/   sidHan,
    /* NSEN  71*/   sidDefault,
    /* NSET  71*/   sidDefault,
    /* NSNW  71*/   sidDefault,
    /* ASAN  72*/   sidAmbiguous,
    /* ASAE  72*/   sidAmbiguous,
    /* NDEA  73*/   sidAsciiLatin,
    /* WD__  74*/   sidHan,
    /* NLLA  75*/   sidAsciiLatin,
    /* WLA_  76*/   sidHan,
    /* NWBL  77*/   sidDefault,
    /* NWZW  77*/   sidDefault,
    /* NPLW  78*/   sidAmbiguous,
    /* NPZW  78*/   sidMerge,
    /* NPF_  78*/   sidAmbiguous,
    /* NPFL  78*/   sidAmbiguous,
    /* NPNW  78*/   sidAmbiguous,
    /* APLW  79*/   sidAmbiguous,
    /* APCO  79*/   sidAmbiguous,
    /* ASYW  80*/   sidAmbiguous,
    /* NHYP  81*/   sidAsciiSym,       // was sidDefault (error)
    /* NHYW  81*/   sidDefault,
    /* AHYW  82*/   sidAmbiguous,      // if narrow, 2013 should be sidLatin, NP
    /* NAPA  83*/   sidAsciiSym,
    /* NQMP  84*/   sidAsciiSym,
    /* NSLS  85*/   sidAsciiSym,
    /* NSF_  86*/   sidAmbiguous,
    /* NSBS  86*/   sidAmbiguous,
    /* NSBB  86*/   sidAmbiguous,      // NEW
    /* NLA_  87*/   sidLatin,
    /* NLQ_  88*/   sidLatin,
    /* NLQN  88*/   sidLatin,
    /* NLQC  88*/   sidLatin,          // NEW
    /* ALQ_  89*/   sidAmbiguous,      // if narrow, should go to sidLatin, no NP
    /* ALQN  89*/   sidAmbiguous,      // NEW, same remark as above
    /* NGR_  90*/   sidGreek,
    /* NGRN  90*/   sidGreek,
    /* NGQ_  91*/   sidGreek,
    /* NGQN  91*/   sidGreek,
    /* NCY_  92*/   sidCyrillic,
    /* NCYP  93*/   sidCyrillic,
    /* NCYC  93*/   sidCyrillic,
    /* NAR_  94*/   sidArmenian,
    /* NAQL  95*/   sidArmenian,       // NEW
    /* NAQN  95*/   sidArmenian,
    /* NHB_  96*/   sidHebrew,
    /* NHBC  96*/   sidHebrew,
    /* NHBW  96*/   sidHebrew,
    /* NHBR  96*/   sidHebrew,
    /* NASR  97*/   sidArabic,
    /* NAAR  97*/   sidArabic,
    /* NAAC  97*/   sidArabic,
    /* NAAD  97*/   sidArabic,
    /* NAED  97*/   sidArabic,
    /* NANW  97*/   sidArabic,
    /* NAEW  97*/   sidArabic,
    /* NAAS  97*/   sidArabic,
    /* NHI_  98*/   sidDevanagari,
    /* NHIN  98*/   sidDevanagari,
    /* NHIC  98*/   sidDevanagari,
    /* NHID  98*/   sidDevanagari,
    /* NBE_  99*/   sidBengali,
    /* NBEC  99*/   sidBengali,
    /* NBED  99*/   sidBengali,
    /* NBET  99*/   sidBengali,        // NEW
    /* NGM_ 100*/   sidGurmukhi,
    /* NGMC 100*/   sidGurmukhi,
    /* NGMD 100*/   sidGurmukhi,
    /* NGJ_ 101*/   sidGujarati,
    /* NGJC 101*/   sidGujarati,
    /* NGJD 101*/   sidGujarati,
    /* NOR_ 102*/   sidOriya,
    /* NORC 102*/   sidOriya,
    /* NORD 102*/   sidOriya,
    /* NTA_ 103*/   sidTamil,
    /* NTAC 103*/   sidTamil,
    /* NTAD 103*/   sidTamil,
    /* NTE_ 104*/   sidTelugu,
    /* NTEC 104*/   sidTelugu,
    /* NTED 104*/   sidTelugu,
    /* NKD_ 105*/   sidKannada,
    /* NKDC 105*/   sidKannada,
    /* NKDD 105*/   sidKannada,
    /* NMA_ 106*/   sidMalayalam,
    /* NMAC 106*/   sidMalayalam,
    /* NMAD 106*/   sidMalayalam,
    /* NTH_ 107*/   sidThai,
    /* NTHC 107*/   sidThai,
    /* NTHD 107*/   sidThai,
    /* NTHT 107*/   sidThai,
    /* NLO_ 108*/   sidLao,
    /* NLOC 108*/   sidLao,
    /* NLOD 108*/   sidLao,
    /* NTI_ 109*/   sidTibetan,
    /* NTIC 109*/   sidTibetan,
    /* NTID 109*/   sidTibetan,
    /* NTIN 109*/   sidTibetan,        // NEW
    /* NGE_ 110*/   sidGeorgian,
    /* NGEQ 111*/   sidGeorgian,
    /* NBO_ 112*/   sidBopomofo,
    /* NBSP 113*/   sidAsciiSym,
    /* NBSS 113*/   sidDefault,        // NEW
    /* NOF_ 114*/   sidAmbiguous,
    /* NOBS 114*/   sidAmbiguous,
    /* NOEA 114*/   sidAsciiSym,
    /* NONA 114*/   sidAsciiSym,
    /* NONP 114*/   sidAsciiSym,
    /* NOEP 114*/   sidAsciiSym,
    /* NONW 114*/   sidLatin,          // should be split in 2 partitions
    /* NOEW 114*/   sidCurrency,
    /* NOLW 114*/   sidLatin,          // should be split in 2 partitions
    /* NOCO 114*/   sidMerge,          // was sidLatin
    /* NOSP 114*/   sidAmbiguous,      // why?, what about sidMerge
    /* NOEN 114*/   sidDefault,
    /* NOBN 114*/   sidAsciiSym,       // NEW, some are not Ascii, issue?
    /* NET_ 115*/   sidEthiopic,
    /* NETP 115*/   sidEthiopic,
    /* NETD 115*/   sidEthiopic,
    /* NCA_ 116*/   sidCanSyllabic,
    /* NCH_ 117*/   sidCherokee,
    /* WYI_ 118*/   sidYi,
    /* WYIN 118*/   sidYi,             // NEW
    /* NBR_ 119*/   sidBraille,
    /* NRU_ 120*/   sidRunic,
    /* NOG_ 121*/   sidOgham,
    /* NOGS 121*/   sidOgham,          // NEW
    /* NOGN 121*/   sidOgham,          // NEW
    /* NSI_ 122*/   sidSinhala,
    /* NSIC 122*/   sidSinhala,
    /* NTN_ 123*/   sidThaana,
    /* NTNC 123*/   sidThaana,
    /* NKH_ 124*/   sidKhmer,
    /* NKHC 124*/   sidKhmer,
    /* NKHD 124*/   sidKhmer,
    /* NKHT 124*/   sidKhmer,          // NEW
    /* NBU_ 125*/   sidBurmese,
    /* NBUC 125*/   sidBurmese,
    /* NBUD 125*/   sidBurmese,
    /* NSY_ 126*/   sidSyriac,
    /* NSYP 126*/   sidSyriac,
    /* NSYC 126*/   sidSyriac,
    /* NSYW 126*/   sidSyriac,
    /* NMO_ 127*/   sidMongolian,
    /* NMOC 127*/   sidMongolian,
    /* NMOD 127*/   sidMongolian,
    /* NMOB 127*/   sidMongolian,      // NEW
    /* NMON 127*/   sidMongolian,      // NEW
#ifndef NO_UTF16
    /* NHS_ 128*/   sidSurrogateA,
    /* WHT_ 129*/   sidSurrogateB,
#else
    /* NHS_ 128*/   sidDefault,
    /* WHT_ 129*/   sidDefault,
#endif
    /* LS__ 130*/   sidMerge,
    /* XNW_ 131*/   sidDefault,
    /* XNWA 131*/   sidDefault,        // NEW
};

//+----------------------------------------------------------------------------
//
//  g_asidAscii
//
//  [U+0000, U+007F] Unicode range to script identifier mapping.
//
//  NB (cthrash) This table name is a little misleading. Obviously not all
//  script ids in the ASCII range are sidAscii(Latin or Sym). This is just
//  a quick lookup for the most common characters on the web.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidAscii[128] =
{
    /* U+0000 */ sidMerge,
    /* U+0001 */ sidMerge,
    /* U+0002 */ sidMerge,
    /* U+0003 */ sidMerge,
    /* U+0004 */ sidMerge,
    /* U+0005 */ sidMerge,
    /* U+0006 */ sidMerge,
    /* U+0007 */ sidMerge,
    /* U+0008 */ sidMerge,
    /* U+0009 */ sidMerge,
    /* U+000A */ sidMerge,
    /* U+000B */ sidMerge,
    /* U+000C */ sidMerge,
    /* U+000D */ sidMerge,
    /* U+000E */ sidMerge,
    /* U+000F */ sidMerge,
    /* U+0010 */ sidMerge,
    /* U+0011 */ sidMerge,
    /* U+0012 */ sidMerge,
    /* U+0013 */ sidMerge,
    /* U+0014 */ sidMerge,
    /* U+0015 */ sidMerge,
    /* U+0016 */ sidMerge,
    /* U+0017 */ sidMerge,
    /* U+0018 */ sidMerge,
    /* U+0019 */ sidMerge,
    /* U+001A */ sidMerge,
    /* U+001B */ sidMerge,
    /* U+001C */ sidMerge,
    /* U+001D */ sidMerge,
    /* U+001E */ sidMerge,
    /* U+001F */ sidMerge,
    /* U+0020 */ sidMerge,
    /* U+0021 */ sidAsciiSym,
    /* U+0022 */ sidAsciiSym,
    /* U+0023 */ sidAsciiSym,
    /* U+0024 */ sidAsciiSym,
    /* U+0025 */ sidAsciiSym,
    /* U+0026 */ sidAsciiSym,
    /* U+0027 */ sidAsciiSym,
    /* U+0028 */ sidAsciiSym,
    /* U+0029 */ sidAsciiSym,
    /* U+002A */ sidAsciiSym,
    /* U+002B */ sidAsciiSym,
    /* U+002C */ sidAsciiSym,
    /* U+002D */ sidDefault,
    /* U+002E */ sidAsciiSym,
    /* U+002F */ sidAsciiSym,
    /* U+0030 */ sidAsciiLatin,
    /* U+0031 */ sidAsciiLatin,
    /* U+0032 */ sidAsciiLatin,
    /* U+0033 */ sidAsciiLatin,
    /* U+0034 */ sidAsciiLatin,
    /* U+0035 */ sidAsciiLatin,
    /* U+0036 */ sidAsciiLatin,
    /* U+0037 */ sidAsciiLatin,
    /* U+0038 */ sidAsciiLatin,
    /* U+0039 */ sidAsciiLatin,
    /* U+003A */ sidAsciiSym,
    /* U+003B */ sidAsciiSym,
    /* U+003C */ sidAsciiSym,
    /* U+003D */ sidAsciiSym,
    /* U+003E */ sidAsciiSym,
    /* U+003F */ sidAsciiSym,
    /* U+0040 */ sidAsciiSym,
    /* U+0041 */ sidAsciiLatin,
    /* U+0042 */ sidAsciiLatin,
    /* U+0043 */ sidAsciiLatin,
    /* U+0044 */ sidAsciiLatin,
    /* U+0045 */ sidAsciiLatin,
    /* U+0046 */ sidAsciiLatin,
    /* U+0047 */ sidAsciiLatin,
    /* U+0048 */ sidAsciiLatin,
    /* U+0049 */ sidAsciiLatin,
    /* U+004A */ sidAsciiLatin,
    /* U+004B */ sidAsciiLatin,
    /* U+004C */ sidAsciiLatin,
    /* U+004D */ sidAsciiLatin,
    /* U+004E */ sidAsciiLatin,
    /* U+004F */ sidAsciiLatin,
    /* U+0050 */ sidAsciiLatin,
    /* U+0051 */ sidAsciiLatin,
    /* U+0052 */ sidAsciiLatin,
    /* U+0053 */ sidAsciiLatin,
    /* U+0054 */ sidAsciiLatin,
    /* U+0055 */ sidAsciiLatin,
    /* U+0056 */ sidAsciiLatin,
    /* U+0057 */ sidAsciiLatin,
    /* U+0058 */ sidAsciiLatin,
    /* U+0059 */ sidAsciiLatin,
    /* U+005A */ sidAsciiLatin,
    /* U+005B */ sidAsciiSym,
    /* U+005C */ sidAsciiSym,
    /* U+005D */ sidAsciiSym,
    /* U+005E */ sidAsciiSym,
    /* U+005F */ sidAsciiSym,
    /* U+0060 */ sidAsciiSym,
    /* U+0061 */ sidAsciiLatin,
    /* U+0062 */ sidAsciiLatin,
    /* U+0063 */ sidAsciiLatin,
    /* U+0064 */ sidAsciiLatin,
    /* U+0065 */ sidAsciiLatin,
    /* U+0066 */ sidAsciiLatin,
    /* U+0067 */ sidAsciiLatin,
    /* U+0068 */ sidAsciiLatin,
    /* U+0069 */ sidAsciiLatin,
    /* U+006A */ sidAsciiLatin,
    /* U+006B */ sidAsciiLatin,
    /* U+006C */ sidAsciiLatin,
    /* U+006D */ sidAsciiLatin,
    /* U+006E */ sidAsciiLatin,
    /* U+006F */ sidAsciiLatin,
    /* U+0070 */ sidAsciiLatin,
    /* U+0071 */ sidAsciiLatin,
    /* U+0072 */ sidAsciiLatin,
    /* U+0073 */ sidAsciiLatin,
    /* U+0074 */ sidAsciiLatin,
    /* U+0075 */ sidAsciiLatin,
    /* U+0076 */ sidAsciiLatin,
    /* U+0077 */ sidAsciiLatin,
    /* U+0078 */ sidAsciiLatin,
    /* U+0079 */ sidAsciiLatin,
    /* U+007A */ sidAsciiLatin,
    /* U+007B */ sidAsciiSym,
    /* U+007C */ sidAsciiSym,
    /* U+007D */ sidAsciiSym,
    /* U+007E */ sidAsciiSym,
    /* U+007F */ sidAsciiSym,
};

//+----------------------------------------------------------------------------
//
//  g_asidLang
//
//  Primary language identifier to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidLang[LANG_NEPALI + 1] =
{
    /* LANG_NEUTRAL     0x00 */ sidDefault,
    /* LANG_ARABIC      0x01 */ sidArabic,
    /* LANG_BULGARIAN   0x02 */ sidCyrillic,
    /* LANG_CATALAN     0x03 */ sidLatin,
    /* LANG_CHINESE     0x04 */ sidMerge,       // need to look at sublang id
    /* LANG_CZECH       0x05 */ sidLatin,
    /* LANG_DANISH      0x06 */ sidLatin,
    /* LANG_GERMAN      0x07 */ sidLatin,
    /* LANG_GREEK       0x08 */ sidGreek,
    /* LANG_ENGLISH     0x09 */ sidLatin,
    /* LANG_SPANISH     0x0a */ sidLatin,
    /* LANG_FINNISH     0x0b */ sidLatin,
    /* LANG_FRENCH      0x0c */ sidLatin,
    /* LANG_HEBREW      0x0d */ sidHebrew,
    /* LANG_HUNGARIAN   0x0e */ sidLatin,
    /* LANG_ICELANDIC   0x0f */ sidLatin,
    /* LANG_ITALIAN     0x10 */ sidLatin,
    /* LANG_JAPANESE    0x11 */ sidKana,
    /* LANG_KOREAN      0x12 */ sidHangul,
    /* LANG_DUTCH       0x13 */ sidLatin,
    /* LANG_NORWEGIAN   0x14 */ sidLatin,
    /* LANG_POLISH      0x15 */ sidLatin,
    /* LANG_PORTUGUESE  0x16 */ sidLatin,
    /*                  0x17 */ sidDefault,
    /* LANG_ROMANIAN    0x18 */ sidLatin,
    /* LANG_RUSSIAN     0x19 */ sidCyrillic,
    /* LANG_SERBIAN     0x1a */ sidMerge,       // need to look at sublang id
    /* LANG_SLOVAK      0x1b */ sidLatin,
    /* LANG_ALBANIAN    0x1c */ sidLatin,
    /* LANG_SWEDISH     0x1d */ sidLatin,
    /* LANG_THAI        0x1e */ sidThai,
    /* LANG_TURKISH     0x1f */ sidLatin,
    /* LANG_URDU        0x20 */ sidArabic,
    /* LANG_INDONESIAN  0x21 */ sidLatin,
    /* LANG_UKRAINIAN   0x22 */ sidCyrillic,
    /* LANG_BELARUSIAN  0x23 */ sidCyrillic,
    /* LANG_SLOVENIAN   0x24 */ sidLatin,
    /* LANG_ESTONIAN    0x25 */ sidLatin,
    /* LANG_LATVIAN     0x26 */ sidLatin,
    /* LANG_LITHUANIAN  0x27 */ sidLatin,
    /*                  0x28 */ sidDefault,
    /* LANG_FARSI       0x29 */ sidArabic,
    /* LANG_VIETNAMESE  0x2a */ sidLatin,
    /* LANG_ARMENIAN    0x2b */ sidArmenian,
    /* LANG_AZERI       0x2c */ sidMerge,       // need to look at sublang id
    /* LANG_BASQUE      0x2d */ sidLatin,
    /*                  0x2e */ sidDefault,
    /* LANG_MACEDONIAN  0x2f */ sidCyrillic,
    /* LANG_SUTU        0x30 */ sidLatin,
    /*                  0x31 */ sidDefault,
    /*                  0x32 */ sidDefault,
    /*                  0x33 */ sidDefault,
    /*                  0x34 */ sidDefault,
    /*                  0x35 */ sidDefault,
    /* LANG_AFRIKAANS   0x36 */ sidLatin,
    /* LANG_GEORGIAN    0x37 */ sidGeorgian,
    /* LANG_FAEROESE    0x38 */ sidLatin,
    /* LANG_HINDI       0x39 */ sidDevanagari,
    /*                  0x3a */ sidDefault,
    /*                  0x3b */ sidDefault,
    /*                  0x3c */ sidDefault,
    /*                  0x3d */ sidDefault,
    /* LANG_MALAY       0x3e */ sidLatin,
    /* LANG_KAZAKH      0x3f */ sidCyrillic,
    /*                  0x40 */ sidDefault,
    /* LANG_SWAHILI     0x41 */ sidLatin,
    /*                  0x42 */ sidDefault,
    /* LANG_UZBEK       0x43 */ sidMerge,       // need to look at sublang id
    /* LANG_TATAR       0x44 */ sidCyrillic,
    /* LANG_BENGALI     0x45 */ sidBengali,
    /* LANG_PUNJABI     0x46 */ sidGurmukhi,
    /* LANG_GUJARATI    0x47 */ sidGujarati,
    /* LANG_ORIYA       0x48 */ sidOriya,
    /* LANG_TAMIL       0x49 */ sidTamil,
    /* LANG_TELUGU      0x4a */ sidTelugu,
    /* LANG_KANNADA     0x4b */ sidKannada,
    /* LANG_MALAYALAM   0x4c */ sidMalayalam,
    /* LANG_ASSAMESE    0x4d */ sidBengali,
    /* LANG_MARATHI     0x4e */ sidDevanagari,
    /* LANG_SANSKRIT    0x4f */ sidDevanagari,
    /*                  0x50 */ sidDefault,
    /*                  0x51 */ sidDefault,
    /*                  0x52 */ sidDefault,
    /*                  0x53 */ sidDefault,
    /*                  0x54 */ sidDefault,
    /* LANG_BURMESE     0x55 */ sidBurmese,
    /*                  0x56 */ sidDefault,
    /* LANG_KONKANI     0x57 */ sidDevanagari,
    /* LANG_MANIPURI    0x58 */ sidBengali,
    /* LANG_SINDHI      0x59 */ sidArabic,
    /*                  0x5a */ sidDefault,
    /*                  0x5b */ sidDefault,
    /*                  0x5c */ sidDefault,
    /*                  0x5d */ sidDefault,
    /*                  0x5e */ sidDefault,
    /*                  0x5f */ sidDefault,
    /* LANG_KASHMIRI    0x60 */ sidArabic,
    /* LANG_NEPALI      0x61 */ sidDevanagari,
};

//+----------------------------------------------------------------------------
//
//  g_asidCPBit
//
//  Code page bit to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidCPBit[32] =
{
    /* FS_LATIN1        0x00000001 */ sidLatin,
    /* FS_LATIN2        0x00000002 */ sidLatin,
    /* FS_CYRILLIC      0x00000004 */ sidCyrillic,
    /* FS_GREEK         0x00000008 */ sidGreek,
    /* FS_TURKISH       0x00000010 */ sidLatin,
    /* FS_HEBREW        0x00000020 */ sidHebrew,
    /* FS_ARABIC        0x00000040 */ sidArabic,
    /* FS_BALTIC        0x00000080 */ sidLatin,
    /* FS_VIETNAMESE    0x00000100 */ sidLatin,
    /* FS_UNKNOWN       0x00000200 */ sidDefault,
    /* FS_UNKNOWN       0x00000400 */ sidDefault,
    /* FS_UNKNOWN       0x00000800 */ sidDefault,
    /* FS_UNKNOWN       0x00001000 */ sidDefault,
    /* FS_UNKNOWN       0x00002000 */ sidDefault,
    /* FS_UNKNOWN       0x00004000 */ sidDefault,
    /* FS_UNKNOWN       0x00008000 */ sidDefault,
    /* FS_THAI          0x00010000 */ sidThai,
    /* FS_JISJAPAN      0x00020000 */ sidKana,
    /* FS_CHINESESIMP   0x00040000 */ sidHan,
    /* FS_WANSUNG       0x00080000 */ sidHangul,
    /* FS_CHINESETRAD   0x00100000 */ sidBopomofo,
    /* FS_JOHAB         0x00200000 */ sidHangul,
    /* FS_UNKNOWN       0x00400000 */ sidDefault,
    /* FS_UNKNOWN       0x00800000 */ sidDefault,
    /* FS_UNKNOWN       0x01000000 */ sidDefault,
    /* FS_UNKNOWN       0x02000000 */ sidDefault,
    /* FS_UNKNOWN       0x04000000 */ sidDefault,
    /* FS_UNKNOWN       0x08000000 */ sidDefault,
    /* FS_UNKNOWN       0x10000000 */ sidDefault,
    /* FS_UNKNOWN       0x20000000 */ sidDefault,
    /* FS_UNKNOWN       0x40000000 */ sidDefault,
    /* FS_SYMBOL        0x80000000 */ sidDefault,
};

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCharClass
//
//  Synopsis:   Map character class to script id.
//
//  Arguments:  [cc] - character class
//
//  Returns:    Script id appropriate for given character class.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromCharClass(
    CHAR_CLASS cc)  // [in]
{
    Assert(cc >= 0 && cc < CHAR_CLASS_MAX);

    return g_asidScriptIDFromCharClass[cc];
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromLangIDSlow
//
//  Synopsis:   Map language identifier to script id.
//
//  Arguments:  [lang] - language id
//
//  Returns:    Script id appropriate for given language id.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromLangIDSlow(
    LANGID lang)    // [in]
{
    SCRIPT_ID sid = sidDefault;
    WORD sublang = SUBLANGID(lang);
    switch (PRIMARYLANGID(lang))
    {
    case LANG_CHINESE:
        sid = (SCRIPT_ID)(sublang == SUBLANG_CHINESE_TRADITIONAL ? sidBopomofo : sidHan);
        break;
    case LANG_SERBIAN:
        sid = (SCRIPT_ID)(sublang == SUBLANG_SERBIAN_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    case LANG_AZERI:
        sid = (SCRIPT_ID)(sublang == SUBLANG_AZERI_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    case LANG_UZBEK:
        sid = (SCRIPT_ID)(sublang == SUBLANG_UZBEK_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    default:
        Assert(FALSE); // Should get data in fast vertion (ScriptIDFromLangID)
    }
    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCPBit
//
//  Synopsis:   Map code page bit to script id.
//
//  Arguments:  [dwCPBit] - code page bit
//
//  Returns:    Script id appropriate for given code page bit.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromCPBit(
    DWORD dwCPBit)  // [in]
{
    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        if (dwCPBit & (1 << i))
            return g_asidCPBit[i];
        ++i;
    }
    return sidDefault;
}

//+----------------------------------------------------------------------------
//
//  Function:   CPBitFromScripts
//
//  Synopsis:   Map scripts to code page bits.
//
//  Arguments:  [sids] - scripts
//
//  Returns:    Code page bits appropriate for given scripts.
//
//-----------------------------------------------------------------------------

DWORD CPBitFromScripts(
    SCRIPT_IDS sids)  // [in]
{
    DWORD dwCPBit = 0;
    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        SCRIPT_ID sid = g_asidCPBit[i];
        if (sid != sidDefault && (ScriptBit(sid) & sids))
            dwCPBit |= (1 << i);
        ++i;
    }
    return dwCPBit;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptsFromCPBit
//
//  Synopsis:   Map code page bits to script ids.
//
//  Arguments:  [dwCPBit] - code page bit-mask
//
//  Returns:    Script ids appropriate for given code page bit-mask.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS ScriptsFromCPBit(
    DWORD dwCPBit)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;

    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        if (dwCPBit & DWORD(1 << i))
            sids |= ScriptBit(g_asidCPBit[i]);
        ++i;
    }

    return sids;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\project.inc ===
# project.inc - project specific settings

OTHER_INC_DIRS = $(SRCROOT)\core\include $(SRCROOT)\other\include $(SRCROOT)\f3\include $(SDKDIR) 
OTHER_INC_DIRS = $(OTHER_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) $(BLDROOT)\types 
OTHER_INC_DIRS = $(OTHER_INC_DIRS) $(SRCROOT)\core\types $(SRCROOT)\f3\types $(SRCROOT)\f3\ocx96
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\hta\main.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       main.cxx
//
//  Contents:   WinMain and associated functions.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

typedef HRESULT STDAPICALLTYPE RUNHTMLAPPLICATIONFN(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow);

#define ARRAYSIZE   (MAX_PATH + 1)

// Simply a pass-through entry point.  It forwards this call to the registered MSHTML's 
// RunHTMLApplication API.

EXTERN_C int PASCAL
WinMain(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow)
{

    HINSTANCE hinstMSHTML = NULL;
    RUNHTMLAPPLICATIONFN *lpfnRunHTMLApp = NULL;
    HKEY hKey = (HKEY)INVALID_HANDLE_VALUE;    
    DWORD dwType;
    DWORD dwLen = ARRAYSIZE;
    LPSTR lpszMshtmlPath = new char[ARRAYSIZE];
    LPSTR lpszExpandedMshtmlPath = new char[ARRAYSIZE];

    if (!lpszMshtmlPath || !lpszExpandedMshtmlPath)
        goto Cleanup;

    // Find the location of the registered mshtml.dll on this system

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_CLASSES_ROOT, "clsid\\{25336920-03f9-11cf-8fd0-00aa00686f13}\\InProcServer32", 0, KEY_QUERY_VALUE, &hKey))
        goto Cleanup;

    if (ERROR_SUCCESS != RegQueryValueExA(hKey, NULL, NULL, &dwType, (LPBYTE)lpszMshtmlPath, &dwLen))
        goto Cleanup;
        
    // Expand environment variables, if necessary
    if (REG_EXPAND_SZ == dwType)
    {
        if (0 == ExpandEnvironmentStringsA(lpszMshtmlPath, lpszExpandedMshtmlPath, ARRAYSIZE))
            goto Cleanup;
    }
    
    hinstMSHTML = LoadLibraryA(((dwType == REG_EXPAND_SZ) ? lpszExpandedMshtmlPath : lpszMshtmlPath));

    // Done with the char arrays and reg handle, release now so they aren't allocated
    // for the entire lifetime of the HTA.

    delete [] lpszMshtmlPath;
    delete [] lpszExpandedMshtmlPath;
    lpszMshtmlPath = lpszExpandedMshtmlPath = NULL;

    if (hKey != INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hKey);
        hKey = (HKEY)INVALID_HANDLE_VALUE;
    }
    
    // Run the HTA
    if (hinstMSHTML)
    {
        lpfnRunHTMLApp = (RUNHTMLAPPLICATIONFN *) GetProcAddress(hinstMSHTML, "RunHTMLApplication");
        if (lpfnRunHTMLApp)
        {
            (*lpfnRunHTMLApp)(hinst, hPrevInst, szCmdLine, nCmdShow);
        }
        FreeLibrary(hinstMSHTML);
    }

Cleanup:

    if (lpszMshtmlPath)
        delete [] lpszMshtmlPath;

    if (lpszExpandedMshtmlPath)
        delete [] lpszExpandedMshtmlPath;
        
    if (hKey != INVALID_HANDLE_VALUE)
        RegCloseKey(hKey);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intlcore\altfont.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       altfont.cxx
//
//  Contents:   Alternate font name helpers.
//              Provide English <=> localized font name mapping.
//
//  The following was generated programmatically.  It is crucial that the
//  strings remain sort StrCmpIC-wise, as we use a bsearch to find the
//  alternate name of the font.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const TCHAR g_pszAltFontName000[] = L"Ami R";
const TCHAR g_pszAltFontName001[] = L"AR P\x30da\x30f3\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName002[] = L"AR P\x30da\x30f3\x884c\x6977\x66f8\x4f53 L";
const TCHAR g_pszAltFontName003[] = L"AR P\x52d8\x4ead\x6d41H";
const TCHAR g_pszAltFontName004[] = L"AR P\x53e4\x5370\x4f53\x0042";
const TCHAR g_pszAltFontName005[] = L"AR P\x6977\x66f8\x4f53\x4f53 M";
const TCHAR g_pszAltFontName006[] = L"AR P\x767d\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName007[] = L"AR P\x884c\x6977\x66f8\x4f53H";
const TCHAR g_pszAltFontName008[] = L"AR P\x884c\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName009[] = L"AR P\x96b7\x66f8\x4f53 M";
const TCHAR g_pszAltFontName010[] = L"AR P\x9ed2\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName011[] = L"Arphic Gyokailenmentai Heavy JIS";
const TCHAR g_pszAltFontName012[] = L"Arphic Gyokailenmentai Light JIS";
const TCHAR g_pszAltFontName013[] = L"Arphic Gyokaisho Heavy JIS";
const TCHAR g_pszAltFontName014[] = L"Arphic Gyokaisho Light JIS";
const TCHAR g_pszAltFontName015[] = L"Arphic Kaisho Medium JIS";
const TCHAR g_pszAltFontName016[] = L"Arphic Kanteiryu Heavy JIS";
const TCHAR g_pszAltFontName017[] = L"Arphic Koin-Tai Bold JIS";
const TCHAR g_pszAltFontName018[] = L"Arphic Kuro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName019[] = L"Arphic Pengyokaisho Light JIS";
const TCHAR g_pszAltFontName020[] = L"Arphic Penkaisho Light JIS";
const TCHAR g_pszAltFontName021[] = L"Arphic PGyokaisho Heavy JIS";
const TCHAR g_pszAltFontName022[] = L"Arphic PGyokaisho Light JIS";
const TCHAR g_pszAltFontName023[] = L"Arphic PKaisho Medium JIS";
const TCHAR g_pszAltFontName024[] = L"Arphic PKanteiryu Heavy JIS";
const TCHAR g_pszAltFontName025[] = L"Arphic PKoin-Tai Bold JIS";
const TCHAR g_pszAltFontName026[] = L"Arphic PKuro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName027[] = L"Arphic PPengyokaisho Light JIS";
const TCHAR g_pszAltFontName028[] = L"Arphic PPenkaisho Light JIS";
const TCHAR g_pszAltFontName029[] = L"Arphic PReisho Medium JIS";
const TCHAR g_pszAltFontName030[] = L"Arphic PSiro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName031[] = L"Arphic Reisho Medium JIS";
const TCHAR g_pszAltFontName032[] = L"Arphic Siro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName033[] = L"AR\x30da\x30f3\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName034[] = L"AR\x30da\x30f3\x884c\x6977\x66f8\x4f53 L";
const TCHAR g_pszAltFontName035[] = L"AR\x52d8\x4ead\x6d41H";
const TCHAR g_pszAltFontName036[] = L"AR\x53e4\x5370\x4f53\x0042";
const TCHAR g_pszAltFontName037[] = L"AR\x6977\x66f8\x4f53 M";
const TCHAR g_pszAltFontName038[] = L"AR\x767d\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName039[] = L"AR\x884c\x6977\x66f8\x4f53H";
const TCHAR g_pszAltFontName040[] = L"AR\x884c\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName041[] = L"AR\x884c\x6977\x9023\x7dbf\x4f53H";
const TCHAR g_pszAltFontName042[] = L"AR\x884c\x6977\x9023\x7dbf\x4f53L";
const TCHAR g_pszAltFontName043[] = L"AR\x96b7\x66f8\x4f53 M";
const TCHAR g_pszAltFontName044[] = L"AR\x9ed2\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName045[] = L"Batang";
const TCHAR g_pszAltFontName046[] = L"BatangChe";
const TCHAR g_pszAltFontName047[] = L"DFGothic-EB";
const TCHAR g_pszAltFontName048[] = L"DFKai-SB";
const TCHAR g_pszAltFontName049[] = L"DFLiHeiBold";
const TCHAR g_pszAltFontName050[] = L"DFLiHeiBold(P)";
const TCHAR g_pszAltFontName051[] = L"DFPGothic-EB";
const TCHAR g_pszAltFontName052[] = L"DFPOP-SB";
const TCHAR g_pszAltFontName053[] = L"DFPPOP-SB";
const TCHAR g_pszAltFontName054[] = L"Dotum";
const TCHAR g_pszAltFontName055[] = L"DotumChe";
const TCHAR g_pszAltFontName056[] = L"Expo M";
const TCHAR g_pszAltFontName057[] = L"FangSong_GB2312";
const TCHAR g_pszAltFontName058[] = L"FZShuTi";
const TCHAR g_pszAltFontName059[] = L"FZYaoTi";
const TCHAR g_pszAltFontName060[] = L"Gulim";
const TCHAR g_pszAltFontName061[] = L"GulimChe";
const TCHAR g_pszAltFontName062[] = L"Gungsuh";
const TCHAR g_pszAltFontName063[] = L"GungsuhChe";
const TCHAR g_pszAltFontName064[] = L"Headline R";
const TCHAR g_pszAltFontName065[] = L"Headline Sans R";
const TCHAR g_pszAltFontName066[] = L"HGGothicE";
const TCHAR g_pszAltFontName067[] = L"HGGothicM";
const TCHAR g_pszAltFontName068[] = L"HGGyoshotai";
const TCHAR g_pszAltFontName069[] = L"HGKyokashotai";
const TCHAR g_pszAltFontName070[] = L"HGMinchoB";
const TCHAR g_pszAltFontName071[] = L"HGMinchoE";
const TCHAR g_pszAltFontName072[] = L"HGPGothicE";
const TCHAR g_pszAltFontName073[] = L"HGPGothicM";
const TCHAR g_pszAltFontName074[] = L"HGPGyoshotai";
const TCHAR g_pszAltFontName075[] = L"HGPKyokashotai";
const TCHAR g_pszAltFontName076[] = L"HGPMinchoB";
const TCHAR g_pszAltFontName077[] = L"HGPMinchoE";
const TCHAR g_pszAltFontName078[] = L"HGPSoeiKakugothicUB";
const TCHAR g_pszAltFontName079[] = L"HGPSoeiKakupoptai";
const TCHAR g_pszAltFontName080[] = L"HGPSoeiPresenceEB";
const TCHAR g_pszAltFontName081[] = L"HGP\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName082[] = L"HGP\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName083[] = L"HGP\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName084[] = L"HGP\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName085[] = L"HGP\x660e\x671d\x0042";
const TCHAR g_pszAltFontName086[] = L"HGP\x660e\x671d\x0045";
const TCHAR g_pszAltFontName087[] = L"HGP\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName088[] = L"HGP\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName089[] = L"HGP\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName090[] = L"HGSGothicE";
const TCHAR g_pszAltFontName091[] = L"HGSGothicM";
const TCHAR g_pszAltFontName092[] = L"HGSGyoshotai";
const TCHAR g_pszAltFontName093[] = L"HGSKyokashotai";
const TCHAR g_pszAltFontName094[] = L"HGSMinchoB";
const TCHAR g_pszAltFontName095[] = L"HGSMinchoE";
const TCHAR g_pszAltFontName096[] = L"HGSoeiKakugothicUB";
const TCHAR g_pszAltFontName097[] = L"HGSoeiKakupoptai";
const TCHAR g_pszAltFontName098[] = L"HGSoeiPresenceEB";
const TCHAR g_pszAltFontName099[] = L"HGSSoeiKakugothicUB";
const TCHAR g_pszAltFontName100[] = L"HGSSoeiKakupoptai";
const TCHAR g_pszAltFontName101[] = L"HGSSoeiPresenceEB";
const TCHAR g_pszAltFontName102[] = L"HGS\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName103[] = L"HGS\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName104[] = L"HGS\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName105[] = L"HGS\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName106[] = L"HGS\x660e\x671d\x0042";
const TCHAR g_pszAltFontName107[] = L"HGS\x660e\x671d\x0045";
const TCHAR g_pszAltFontName108[] = L"HGS\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName109[] = L"HGS\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName110[] = L"HGS\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName111[] = L"HG\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName112[] = L"HG\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName113[] = L"HG\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName114[] = L"HG\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName115[] = L"HG\x660e\x671d\x0042";
const TCHAR g_pszAltFontName116[] = L"HG\x660e\x671d\x0045";
const TCHAR g_pszAltFontName117[] = L"HG\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName118[] = L"HG\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName119[] = L"HG\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName120[] = L"HYGothic-Extra";
const TCHAR g_pszAltFontName121[] = L"HYMyeongJo-Extra";
const TCHAR g_pszAltFontName122[] = L"HYPMokGak-Bold";
const TCHAR g_pszAltFontName123[] = L"HYPost-Medium";
const TCHAR g_pszAltFontName124[] = L"HYShortSamul-Medium";
const TCHAR g_pszAltFontName125[] = L"HYSinMun-MyeongJo";
const TCHAR g_pszAltFontName126[] = L"HYTaJa-Medium";
const TCHAR g_pszAltFontName127[] = L"HY\xacac\xace0\xb515";
const TCHAR g_pszAltFontName128[] = L"HY\xacac\xba85\xc870";
const TCHAR g_pszAltFontName129[] = L"HY\xbaa9\xac01\xd30c\xc784\x0042";
const TCHAR g_pszAltFontName130[] = L"HY\xc2e0\xbb38\xba85\xc870";
const TCHAR g_pszAltFontName131[] = L"HY\xc595\xc740\xc0d8\xbb3cM";
const TCHAR g_pszAltFontName132[] = L"HY\xc5fd\xc11cM";
const TCHAR g_pszAltFontName133[] = L"HY\xd0c0\xc790M";
const TCHAR g_pszAltFontName134[] = L"KaiTi_GB2312";
const TCHAR g_pszAltFontName135[] = L"LiSu";
const TCHAR g_pszAltFontName136[] = L"MingLiU";
const TCHAR g_pszAltFontName137[] = L"MingLiU_HKSCS";
const TCHAR g_pszAltFontName138[] = L"MoeumT R";
const TCHAR g_pszAltFontName139[] = L"MS Gothic";
const TCHAR g_pszAltFontName140[] = L"MS Mincho";
const TCHAR g_pszAltFontName141[] = L"MS PGothic";
const TCHAR g_pszAltFontName142[] = L"MS PMincho";
const TCHAR g_pszAltFontName143[] = L"NSimSun";
const TCHAR g_pszAltFontName144[] = L"PMingLiU";
const TCHAR g_pszAltFontName145[] = L"Pyunji R";
const TCHAR g_pszAltFontName146[] = L"SimHei";
const TCHAR g_pszAltFontName147[] = L"SimSun";
const TCHAR g_pszAltFontName148[] = L"STCaiyun";
const TCHAR g_pszAltFontName149[] = L"STFangsong";
const TCHAR g_pszAltFontName150[] = L"STHupo";
const TCHAR g_pszAltFontName151[] = L"STKaii";
const TCHAR g_pszAltFontName152[] = L"STLiti";
const TCHAR g_pszAltFontName153[] = L"STSong";
const TCHAR g_pszAltFontName154[] = L"STXihei";
const TCHAR g_pszAltFontName155[] = L"STXingkai";
const TCHAR g_pszAltFontName156[] = L"STXinwei";
const TCHAR g_pszAltFontName157[] = L"STZhongsong";
const TCHAR g_pszAltFontName158[] = L"Yet R";
const TCHAR g_pszAltFontName159[] = L"YouYuan";
const TCHAR g_pszAltFontName160[] = L"\x4eff\x5b8b_GBG2312";
const TCHAR g_pszAltFontName161[] = L"\x534e\x6587\x4e2d\x5b8b";
const TCHAR g_pszAltFontName162[] = L"\x534e\x6587\x4eff\x5b8b";
const TCHAR g_pszAltFontName163[] = L"\x534e\x6587\x5b8b\x4f53";
const TCHAR g_pszAltFontName164[] = L"\x534e\x6587\x5f69\x4e91";
const TCHAR g_pszAltFontName165[] = L"\x534e\x6587\x65b0\x9b4f";
const TCHAR g_pszAltFontName166[] = L"\x534e\x6587\x6977\x4f53";
const TCHAR g_pszAltFontName167[] = L"\x534e\x6587\x7425\x73c0";
const TCHAR g_pszAltFontName168[] = L"\x534e\x6587\x7ec6\x9ed1";
const TCHAR g_pszAltFontName169[] = L"\x534e\x6587\x884c\x6977";
const TCHAR g_pszAltFontName170[] = L"\x534e\x6587\x96b6\x4e66";
const TCHAR g_pszAltFontName171[] = L"\x5b8b\x4f53";
const TCHAR g_pszAltFontName172[] = L"\x5e7c\x5706";
const TCHAR g_pszAltFontName173[] = L"\x65b0\x5b8b\x4f53";
const TCHAR g_pszAltFontName174[] = L"\x65b0\x7d30\x660e\x9ad4";
const TCHAR g_pszAltFontName175[] = L"\x65b9\x6b63\x59da\x4f53\x7b80\x4f53";
const TCHAR g_pszAltFontName176[] = L"\x65b9\x6b63\x8212\x4f53\x7b80\x4f53";
const TCHAR g_pszAltFontName177[] = L"\x6977\x4f53_GBG2312";
const TCHAR g_pszAltFontName178[] = L"\x6a19\x6977\x9ad4";
const TCHAR g_pszAltFontName179[] = L"\x7d30\x660e\x9ad4";
const TCHAR g_pszAltFontName180[] = L"\x7d30\x660e\x9ad4_HKSCS";
const TCHAR g_pszAltFontName181[] = L"\x83ef\x5eb7\x5137\x7c97\x9ed1";
const TCHAR g_pszAltFontName182[] = L"\x83ef\x5eb7\x65b0\x5137\x7c97\x9ed1";
const TCHAR g_pszAltFontName183[] = L"\x96b6\x4e66";
const TCHAR g_pszAltFontName184[] = L"\x9ed1\x4f53";
const TCHAR g_pszAltFontName185[] = L"\xad74\xb9bc";
const TCHAR g_pszAltFontName186[] = L"\xad74\xb9bc\xccb4";
const TCHAR g_pszAltFontName187[] = L"\xad81\xc11c";
const TCHAR g_pszAltFontName188[] = L"\xad81\xc11c\xccb4";
const TCHAR g_pszAltFontName189[] = L"\xb3cb\xc6c0";
const TCHAR g_pszAltFontName190[] = L"\xb3cb\xc6c0\xccb4";
const TCHAR g_pszAltFontName191[] = L"\xbc14\xd0d5";
const TCHAR g_pszAltFontName192[] = L"\xbc14\xd0d5\xccb4";
const TCHAR g_pszAltFontName193[] = L"\xd734\xba3c\xac01\xc9c4\xd5e4\xb4dc\xb77c\xc778";
const TCHAR g_pszAltFontName194[] = L"\xd734\xba3c\xb465\xadfc\xd5e4\xb4dc\xb77c\xc778";
const TCHAR g_pszAltFontName195[] = L"\xd734\xba3c\xbaa8\xc74cT";
const TCHAR g_pszAltFontName196[] = L"\xd734\xba3c\xc544\xbbf8\xccb4";
const TCHAR g_pszAltFontName197[] = L"\xd734\xba3c\xc5d1\xc2a4\xd3ec";
const TCHAR g_pszAltFontName198[] = L"\xd734\xba3c\xc61b\xccb4";
const TCHAR g_pszAltFontName199[] = L"\xd734\xba3c\xd3b8\xc9c0\xccb4";
const TCHAR g_pszAltFontName200[] = L"\xff24\xff26POP\x4f53";
const TCHAR g_pszAltFontName201[] = L"\xff24\xff26\x7279\x592a\x30b4\x30b7\x30c3\x30af\x4f53";
const TCHAR g_pszAltFontName202[] = L"\xff24\xff26\xff30POP\x4f53";
const TCHAR g_pszAltFontName203[] = L"\xff24\xff26\xff30\x7279\x592a\x30b4\x30b7\x30c3\x30af\x4f53";
const TCHAR g_pszAltFontName204[] = L"\xff28\xff27\x30b4\x30b7\x30c3\x30af\x0045-PRO";
const TCHAR g_pszAltFontName205[] = L"\xff28\xff27\xff7a\xff9e\xff7c\xff6f\xff78\x0045-PRO";
const TCHAR g_pszAltFontName206[] = L"\xff2d\xff33 \x30b4\x30b7\x30c3\x30af";
const TCHAR g_pszAltFontName207[] = L"\xff2d\xff33 \x660e\x671d";
const TCHAR g_pszAltFontName208[] = L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af";
const TCHAR g_pszAltFontName209[] = L"\xff2d\xff33 \xff30\x660e\x671d";

const TCHAR * const pszAltFontNames[] = 
{
   g_pszAltFontName000,
   g_pszAltFontName001,
   g_pszAltFontName002,
   g_pszAltFontName003,
   g_pszAltFontName004,
   g_pszAltFontName005,
   g_pszAltFontName006,
   g_pszAltFontName007,
   g_pszAltFontName008,
   g_pszAltFontName009,
   g_pszAltFontName010,
   g_pszAltFontName011,
   g_pszAltFontName012,
   g_pszAltFontName013,
   g_pszAltFontName014,
   g_pszAltFontName015,
   g_pszAltFontName016,
   g_pszAltFontName017,
   g_pszAltFontName018,
   g_pszAltFontName019,
   g_pszAltFontName020,
   g_pszAltFontName021,
   g_pszAltFontName022,
   g_pszAltFontName023,
   g_pszAltFontName024,
   g_pszAltFontName025,
   g_pszAltFontName026,
   g_pszAltFontName027,
   g_pszAltFontName028,
   g_pszAltFontName029,
   g_pszAltFontName030,
   g_pszAltFontName031,
   g_pszAltFontName032,
   g_pszAltFontName033,
   g_pszAltFontName034,
   g_pszAltFontName035,
   g_pszAltFontName036,
   g_pszAltFontName037,
   g_pszAltFontName038,
   g_pszAltFontName039,
   g_pszAltFontName040,
   g_pszAltFontName041,
   g_pszAltFontName042,
   g_pszAltFontName043,
   g_pszAltFontName044,
   g_pszAltFontName045,
   g_pszAltFontName046,
   g_pszAltFontName047,
   g_pszAltFontName048,
   g_pszAltFontName049,
   g_pszAltFontName050,
   g_pszAltFontName051,
   g_pszAltFontName052,
   g_pszAltFontName053,
   g_pszAltFontName054,
   g_pszAltFontName055,
   g_pszAltFontName056,
   g_pszAltFontName057,
   g_pszAltFontName058,
   g_pszAltFontName059,
   g_pszAltFontName060,
   g_pszAltFontName061,
   g_pszAltFontName062,
   g_pszAltFontName063,
   g_pszAltFontName064,
   g_pszAltFontName065,
   g_pszAltFontName066,
   g_pszAltFontName067,
   g_pszAltFontName068,
   g_pszAltFontName069,
   g_pszAltFontName070,
   g_pszAltFontName071,
   g_pszAltFontName072,
   g_pszAltFontName073,
   g_pszAltFontName074,
   g_pszAltFontName075,
   g_pszAltFontName076,
   g_pszAltFontName077,
   g_pszAltFontName078,
   g_pszAltFontName079,
   g_pszAltFontName080,
   g_pszAltFontName081,
   g_pszAltFontName082,
   g_pszAltFontName083,
   g_pszAltFontName084,
   g_pszAltFontName085,
   g_pszAltFontName086,
   g_pszAltFontName087,
   g_pszAltFontName088,
   g_pszAltFontName089,
   g_pszAltFontName090,
   g_pszAltFontName091,
   g_pszAltFontName092,
   g_pszAltFontName093,
   g_pszAltFontName094,
   g_pszAltFontName095,
   g_pszAltFontName096,
   g_pszAltFontName097,
   g_pszAltFontName098,
   g_pszAltFontName099,
   g_pszAltFontName100,
   g_pszAltFontName101,
   g_pszAltFontName102,
   g_pszAltFontName103,
   g_pszAltFontName104,
   g_pszAltFontName105,
   g_pszAltFontName106,
   g_pszAltFontName107,
   g_pszAltFontName108,
   g_pszAltFontName109,
   g_pszAltFontName110,
   g_pszAltFontName111,
   g_pszAltFontName112,
   g_pszAltFontName113,
   g_pszAltFontName114,
   g_pszAltFontName115,
   g_pszAltFontName116,
   g_pszAltFontName117,
   g_pszAltFontName118,
   g_pszAltFontName119,
   g_pszAltFontName120,
   g_pszAltFontName121,
   g_pszAltFontName122,
   g_pszAltFontName123,
   g_pszAltFontName124,
   g_pszAltFontName125,
   g_pszAltFontName126,
   g_pszAltFontName127,
   g_pszAltFontName128,
   g_pszAltFontName129,
   g_pszAltFontName130,
   g_pszAltFontName131,
   g_pszAltFontName132,
   g_pszAltFontName133,
   g_pszAltFontName134,
   g_pszAltFontName135,
   g_pszAltFontName136,
   g_pszAltFontName137,
   g_pszAltFontName138,
   g_pszAltFontName139,
   g_pszAltFontName140,
   g_pszAltFontName141,
   g_pszAltFontName142,
   g_pszAltFontName143,
   g_pszAltFontName144,
   g_pszAltFontName145,
   g_pszAltFontName146,
   g_pszAltFontName147,
   g_pszAltFontName148,
   g_pszAltFontName149,
   g_pszAltFontName150,
   g_pszAltFontName151,
   g_pszAltFontName152,
   g_pszAltFontName153,
   g_pszAltFontName154,
   g_pszAltFontName155,
   g_pszAltFontName156,
   g_pszAltFontName157,
   g_pszAltFontName158,
   g_pszAltFontName159,
   g_pszAltFontName160,
   g_pszAltFontName161,
   g_pszAltFontName162,
   g_pszAl